import * as HttpClient from "effect/unstable/http/HttpClient";
import * as effect from "effect/Effect";
import * as redacted from "effect/Redacted";
import * as S from "effect/Schema";
import * as stream from "effect/Stream";
import * as API from "../client/api.ts";
import * as T from "../traits.ts";
import * as C from "../category.ts";
import type { Credentials } from "../credentials.ts";
import type { CommonErrors } from "../errors.ts";
import type { Region as Rgn } from "../region.ts";
import { SensitiveString, SensitiveBlob } from "../sensitive.ts";
const ns = T.XmlNamespace("http://ec2.amazonaws.com/doc/2016-11-15");
const svc = T.AwsApiService({ sdkId: "EC2", serviceShapeName: "AmazonEC2" });
const auth = T.AwsAuthSigv4({ name: "ec2" });
const ver = T.ServiceVersion("2016-11-15");
const proto = T.AwsProtocolsEc2Query();
const rules = T.EndpointResolver((p, _) => {
  const { Region, UseDualStack = false, UseFIPS = false, Endpoint } = p;
  const e = (u: unknown, p = {}, h = {}): T.EndpointResolverResult => ({
    type: "endpoint" as const,
    endpoint: { url: u as string, properties: p, headers: h },
  });
  const err = (m: unknown): T.EndpointResolverResult => ({
    type: "error" as const,
    message: m as string,
  });
  if (Endpoint != null) {
    if (UseFIPS === true) {
      return err(
        "Invalid Configuration: FIPS and custom endpoint are not supported",
      );
    }
    if (UseDualStack === true) {
      return err(
        "Invalid Configuration: Dualstack and custom endpoint are not supported",
      );
    }
    return e(Endpoint);
  }
  if (Region != null) {
    {
      const PartitionResult = _.partition(Region);
      if (PartitionResult != null && PartitionResult !== false) {
        if (UseFIPS === true && UseDualStack === true) {
          if (
            true === _.getAttr(PartitionResult, "supportsFIPS") &&
            true === _.getAttr(PartitionResult, "supportsDualStack")
          ) {
            return e(
              `https://ec2-fips.${Region}.${_.getAttr(PartitionResult, "dualStackDnsSuffix")}`,
            );
          }
          return err(
            "FIPS and DualStack are enabled, but this partition does not support one or both",
          );
        }
        if (UseFIPS === true) {
          if (_.getAttr(PartitionResult, "supportsFIPS") === true) {
            if (_.getAttr(PartitionResult, "name") === "aws-us-gov") {
              return e(`https://ec2.${Region}.amazonaws.com`);
            }
            return e(
              `https://ec2-fips.${Region}.${_.getAttr(PartitionResult, "dnsSuffix")}`,
            );
          }
          return err(
            "FIPS is enabled but this partition does not support FIPS",
          );
        }
        if (UseDualStack === true) {
          if (true === _.getAttr(PartitionResult, "supportsDualStack")) {
            return e(
              `https://ec2.${Region}.${_.getAttr(PartitionResult, "dualStackDnsSuffix")}`,
            );
          }
          return err(
            "DualStack is enabled but this partition does not support DualStack",
          );
        }
        return e(
          `https://ec2.${Region}.${_.getAttr(PartitionResult, "dnsSuffix")}`,
        );
      }
    }
  }
  return err("Invalid Configuration: Missing Region");
});

//# Newtypes
export type MillisecondDateTime = Date;
export type CapacityReservationId = string;
export type ReservationId = string;
export type ReservedInstancesOfferingId = string;
export type TransitGatewayMulticastDomainId = string;
export type TransitGatewayAttachmentId = string;
export type VpcEndpointServiceId = string;
export type VpcEndpointId = string;
export type VpcPeeringConnectionIdWithResolver = string;
export type PublicIpAddress = string;
export type Ipv4PoolEc2Id = string;
export type IpamPoolId = string;
export type AssetId = string;
export type AvailabilityZoneId = string;
export type AvailabilityZoneName = string;
export type IpamPoolAllocationId = string;
export type ClientVpnEndpointId = string;
export type VpcId = string;
export type SecurityGroupId = string;
export type NetworkInterfaceId = string;
export type NatGatewayId = string;
export type PrivateIpAddressCount = number;
export type AllocationId = string;
export type InstanceId = string;
export type EipAllocationPublicIp = string;
export type AccountID = string;
export type SubnetId = string;
export type DefaultingDhcpOptionsId = string;
export type CertificateId = string;
export type RoleId = string;
export type InstanceEventWindowId = string;
export type DedicatedHostId = string;
export type Hour = number;
export type InstanceEventWindowCronExpression = string;
export type IpamId = string;
export type IpamResourceDiscoveryId = string;
export type IpamResourceDiscoveryAssociationId = string;
export type ResourceArn = string;
export type RouteServerId = string;
export type RouteGatewayId = string;
export type RouteTableId = string;
export type NetmaskLength = number;
export type SubnetCidrAssociationId = string;
export type TransitGatewayPolicyTableId = string;
export type TransitGatewayRouteTableId = string;
export type TrunkInterfaceAssociationId = string;
export type Ipv6PoolEc2Id = string;
export type InternetGatewayId = string;
export type VerifiedAccessInstanceId = string;
export type VerifiedAccessTrustProviderId = string;
export type ClientSecretType = string | redacted.Redacted<string>;
export type KmsKeyArn = string;
export type VolumeId = string;
export type BoxedInteger = number;
export type VpnGatewayId = string;
export type SecurityGroupRuleId = string;
export type PrefixListResourceId = string;
export type SecurityGroupName = string;
export type S3StorageUploadPolicySignature = string | redacted.Redacted<string>;
export type BundleId = string;
export type CapacityReservationFleetId = string;
export type CancelCapacityReservationFleetErrorCode = string;
export type CancelCapacityReservationFleetErrorMessage = string;
export type ConversionTaskId = string;
export type DeclarativePoliciesReportId = string;
export type ExportVmTaskId = string;
export type ImageId = string;
export type ImportTaskId = string;
export type ReservedInstancesListingId = string;
export type SpotFleetRequestId = string;
export type SpotInstanceRequestId = string;
export type KmsKeyId = string;
export type CopySnapshotRequestPSU = string | redacted.Redacted<string>;
export type SnapshotCompletionDurationMinutesRequest = number;
export type CapacityManagerDataExportId = string;
export type OutpostArn = string;
export type PlacementGroupArn = string;
export type CapacityReservationCommitmentDuration = number;
export type CapacityBlockId = string;
export type BoxedBoolean = boolean;
export type DoubleWithConstraints = number;
export type IntegerWithConstraints = number;
export type CarrierGatewayId = string;
export type Ipv4PoolCoipId = string;
export type LocalGatewayRoutetableId = string;
export type CoipPoolId = string;
export type VpcEncryptionControlId = string;
export type SensitiveMacCredentials = string | redacted.Redacted<string>;
export type MacModificationTaskId = string;
export type EgressOnlyInternetGatewayId = string;
export type LaunchTemplateId = string;
export type LaunchTemplateName = string;
export type PlacementGroupName = string;
export type PlacementGroupId = string;
export type SnapshotId = string;
export type ExcludedInstanceType = string;
export type AllowedInstanceType = string;
export type FleetId = string;
export type FlowLogResourceId = string;
export type ImageUsageResourceTypeName = string;
export type ImageUsageResourceTypeOptionValue = string;
export type ImageUsageReportId = string;
export type InstanceConnectEndpointId = string;
export type IpamScopeId = string;
export type IpamExternalResourceVerificationTokenId = string;
export type IpamPolicyId = string;
export type IpamNetmaskLength = number;
export type IpamPrefixListResolverId = string;
export type BoxedLong = number;
export type IpamPrefixListResolverTargetId = string;
export type SensitiveUserData = string | redacted.Redacted<string>;
export type VersionDescription = string;
export type KernelId = string;
export type KeyPairName = string;
export type RamdiskId = string;
export type LaunchTemplateElasticInferenceAcceleratorCount = number;
export type SecondarySubnetId = string;
export type LocalGatewayVirtualInterfaceGroupId = string;
export type LocalGatewayId = string;
export type LocalGatewayRouteTableVirtualInterfaceGroupAssociationId = string;
export type LocalGatewayRouteTableVpcAssociationId = string;
export type OutpostLagId = string;
export type LocalGatewayVirtualInterfaceId = string;
export type NetworkAclId = string;
export type NetworkInsightsAccessScopeId = string;
export type IpAddress = string;
export type NetworkInsightsResourceId = string;
export type Port = number;
export type NetworkInsightsPathId = string;
export type ReplaceRootVolumeTaskId = string;
export type TransitGatewayId = string;
export type CoreNetworkArn = string;
export type OdbNetworkArn = string;
export type VpcPeeringConnectionId = string;
export type RouteServerEndpointId = string;
export type RouteServerPeerId = string;
export type SecondaryNetworkId = string;
export type SecondaryNetworkCidrAssociationId = string;
export type SecondarySubnetCidrAssociationId = string;
export type SnapshotCompletionDurationMinutesResponse = number;
export type InstanceIdWithVolumeResolver = string;
export type SubnetCidrReservationId = string;
export type TaggableResourceId = string;
export type TrafficMirrorFilterId = string;
export type TrafficMirrorTargetId = string;
export type TransitGatewayConnectPeerId = string;
export type TransitGatewayMeteringPolicyId = string;
export type TransitAssociationGatewayId = string;
export type TransitGatewayRouteTableAnnouncementId = string;
export type VerifiedAccessGroupId = string;
export type CertificateArn = string;
export type VerifiedAccessEndpointPortNumber = number;
export type LoadBalancerArn = string;
export type RdsDbInstanceArn = string;
export type RdsDbClusterArn = string;
export type RdsDbProxyArn = string;
export type VpcBlockPublicAccessExclusionId = string;
export type ServiceNetworkArn = string;
export type ResourceConfigurationArn = string;
export type CustomerGatewayId = string;
export type VpnConcentratorId = string;
export type PreSharedKey = string | redacted.Redacted<string>;
export type CloudWatchLogGroupArn = string;
export type CustomerGatewayConfiguration = string | redacted.Redacted<string>;
export type VpnConnectionId = string;
export type DhcpOptionsId = string;
export type VpcFlowLogId = string;
export type FpgaImageId = string;
export type KeyPairNameWithResolver = string;
export type KeyPairId = string;
export type NetworkInsightsAccessScopeAnalysisId = string;
export type NetworkInsightsAnalysisId = string;
export type NetworkInterfacePermissionId = string;
export type PlacementGroupNameWithResolver = string;
export type TrafficMirrorFilterRuleIdWithResolver = string;
export type TrafficMirrorSessionId = string;
export type VerifiedAccessEndpointId = string;
export type ConnectionNotificationId = string;
export type IpamPoolCidrId = string;
export type NextToken = string;
export type AddressMaxResults = number;
export type DescribeAddressTransfersMaxResults = number;
export type MaxResultsParam = number;
export type DescribeByoipCidrsMaxResults = number;
export type DescribeFutureCapacityMaxResults = number;
export type OfferingId = string;
export type DescribeCapacityBlockExtensionOfferingsMaxResults = number;
export type DescribeCapacityBlockOfferingsMaxResults = number;
export type DescribeCapacityBlocksMaxResults = number;
export type DescribeCapacityBlockStatusMaxResults = number;
export type DescribeCapacityManagerDataExportsRequestMaxResults = number;
export type DescribeCapacityReservationBillingRequestsRequestMaxResults =
  number;
export type DescribeCapacityReservationFleetsMaxResults = number;
export type DescribeCapacityReservationsMaxResults = number;
export type DescribeCapacityReservationTopologyMaxResults = number;
export type CarrierGatewayMaxResults = number;
export type DescribeClassicLinkInstancesMaxResults = number;
export type DescribeClientVpnAuthorizationRulesMaxResults = number;
export type DescribeClientVpnConnectionsMaxResults = number;
export type DescribeClientVpnEndpointMaxResults = number;
export type DescribeClientVpnRoutesMaxResults = number;
export type DescribeClientVpnTargetNetworksMaxResults = number;
export type CoipPoolMaxResults = number;
export type ImportManifestUrl = string | redacted.Redacted<string>;
export type DeclarativePoliciesMaxResults = number;
export type DescribeDhcpOptionsMaxResults = number;
export type DescribeEgressOnlyInternetGatewaysMaxResults = number;
export type ElasticGpuId = string;
export type DescribeElasticGpusMaxResults = number;
export type ExportImageTaskId = string;
export type DescribeExportImageTasksMaxResults = number;
export type ExportTaskId = string;
export type DescribeFastLaunchImagesRequestMaxResults = number;
export type DescribeFastSnapshotRestoresMaxResults = number;
export type DescribeFpgaImagesMaxResults = number;
export type DescribeHostReservationsMaxResults = number;
export type HostReservationId = string;
export type IamInstanceProfileAssociationId = string;
export type DescribeIamInstanceProfileAssociationsMaxResults = number;
export type ResourceTypeOptionValue = string;
export type DescribeImageReferencesMaxResults = number;
export type DescribeImageUsageReportEntriesMaxResults = number;
export type DescribeImageUsageReportsMaxResults = number;
export type ImageUsageReportState = string;
export type ImageUsageReportStateReason = string;
export type ImportImageTaskId = string;
export type SensitiveUrl = string | redacted.Redacted<string>;
export type ImportSnapshotTaskId = string;
export type InstanceConnectEndpointMaxResults = number;
export type DescribeInstanceCreditSpecificationsMaxResults = number;
export type ResultRange = number;
export type DescribeInstanceImageMetadataMaxResults = number;
export type SecondaryInterfaceId = string;
export type DescribeInstanceSqlHaStatesRequestMaxResultsInteger = number;
export type InstanceEventId = string;
export type DescribeInstanceTopologyMaxResults = number;
export type DITOMaxResults = number;
export type Location = string;
export type DITMaxResults = number;
export type CurrentGenerationFlag = boolean;
export type FreeTierEligibleFlag = boolean;
export type BareMetalFlag = boolean;
export type ProcessorSustainedClockSpeed = number;
export type CpuManufacturerName = string;
export type VCpuCount = number;
export type CoreCount = number;
export type ThreadsPerCore = number;
export type MemorySize = number;
export type InstanceStorageFlag = boolean;
export type DiskSize = number;
export type DiskCount = number;
export type BaselineBandwidthInMbps = number;
export type BaselineThroughputInMBps = number;
export type BaselineIops = number;
export type MaximumBandwidthInMbps = number;
export type MaximumThroughputInMBps = number;
export type MaximumIops = number;
export type MaximumEbsAttachments = number;
export type MaximumEbsCards = number;
export type EbsCardIndex = number;
export type NetworkPerformance = string;
export type MaxNetworkInterfaces = number;
export type MaximumNetworkCards = number;
export type DefaultNetworkCardIndex = number;
export type NetworkCardIndex = number;
export type AdditionalFlexibleNetworkInterfaces = number;
export type BaselineBandwidthInGbps = number;
export type PeakBandwidthInGbps = number;
export type DefaultEnaQueueCountPerInterface = number;
export type MaximumEnaQueueCount = number;
export type MaximumEnaQueueCountPerInterface = number;
export type MaxIpv4AddrPerInterface = number;
export type MaxIpv6AddrPerInterface = number;
export type Ipv6Flag = boolean;
export type EfaSupportedFlag = boolean;
export type MaximumEfaInterfaces = number;
export type EncryptionInTransitSupported = boolean;
export type EnaSrdSupported = boolean;
export type SecondaryNetworkSupportedFlag = boolean;
export type MaximumSecondaryNetworkInterfaces = number;
export type Ipv4AddressesPerSecondaryInterface = number;
export type GpuDeviceName = string;
export type GpuDeviceManufacturerName = string;
export type GpuDeviceCount = number;
export type LogicalGpuCount = number;
export type GpuPartitionSize = number;
export type Workload = string;
export type GpuDeviceMemorySize = number;
export type TotalGpuMemory = number;
export type FpgaDeviceName = string;
export type FpgaDeviceManufacturerName = string;
export type FpgaDeviceCount = number;
export type FpgaDeviceMemorySize = number;
export type TotalFpgaMemory = number;
export type InferenceDeviceCount = number;
export type InferenceDeviceName = string;
export type InferenceDeviceManufacturerName = string;
export type InferenceDeviceMemorySize = number;
export type TotalInferenceMemory = number;
export type HibernationFlag = boolean;
export type BurstablePerformanceFlag = boolean;
export type DedicatedHostFlag = boolean;
export type AutoRecoveryFlag = boolean;
export type NitroTpmSupportedVersionType = string;
export type MediaDeviceCount = number;
export type MediaDeviceName = string;
export type MediaDeviceManufacturerName = string;
export type MediaDeviceMemorySize = number;
export type TotalMediaMemory = number;
export type NeuronDeviceCount = number;
export type NeuronDeviceName = string;
export type NeuronDeviceCoreCount = number;
export type NeuronDeviceCoreVersion = number;
export type NeuronDeviceMemorySize = number;
export type TotalNeuronMemory = number;
export type DescribeInternetGatewaysMaxResults = number;
export type DescribeIpamByoasnMaxResults = number;
export type IpamMaxResults = number;
export type Ipv6PoolMaxResults = number;
export type DescribeLaunchTemplatesMaxResults = number;
export type LocalGatewayMaxResults = number;
export type DescribeLockedSnapshotsMaxResults = number;
export type RetentionPeriodResponseDays = number;
export type CoolOffPeriodResponseHours = number;
export type DescribeMacHostsRequestMaxResults = number;
export type DescribeMacModificationTasksMaxResults = number;
export type PrefixListMaxResults = number;
export type DescribeMovingAddressesMaxResults = number;
export type DescribeNatGatewaysMaxResults = number;
export type DescribeNetworkAclsMaxResults = number;
export type NetworkInsightsMaxResults = number;
export type ComponentAccount = string;
export type ComponentRegion = string;
export type ProtocolInt = number;
export type Priority = number;
export type DescribeNetworkInterfacePermissionsMaxResults = number;
export type DescribeNetworkInterfacesMaxResults = number;
export type OutpostLagMaxResults = number;
export type ServiceLinkVirtualInterfaceId = string;
export type DescribePrincipalIdFormatMaxResults = number;
export type PoolMaxResults = number;
export type DescribeReplaceRootVolumeTasksMaxResults = number;
export type ReservedInstancesModificationId = string;
export type RouteServerMaxResults = number;
export type DescribeRouteTablesMaxResults = number;
export type DescribeScheduledInstanceAvailabilityMaxResults = number;
export type ScheduledInstanceId = string;
export type DescribeSecondaryInterfacesMaxResults = number;
export type DescribeSecondaryNetworksMaxResults = number;
export type DescribeSecondarySubnetsMaxResults = number;
export type DescribeSecurityGroupRulesMaxResults = number;
export type DescribeSecurityGroupsMaxResults = number;
export type DescribeSecurityGroupVpcAssociationsMaxResults = number;
export type ServiceLinkMaxResults = number;
export type DescribeSnapshotTierStatusMaxResults = number;
export type DescribeSpotFleetInstancesMaxResults = number;
export type DescribeSpotFleetRequestHistoryMaxResults = number;
export type DescribeStaleSecurityGroupsMaxResults = number;
export type DescribeStaleSecurityGroupsNextToken = string;
export type DescribeStoreImageTasksRequestMaxResults = number;
export type DescribeSubnetsMaxResults = number;
export type TrafficMirroringMaxResults = number;
export type TransitGatewayMaxResults = number;
export type DescribeTrunkInterfaceAssociationsMaxResults = number;
export type DescribeVerifiedAccessEndpointsMaxResults = number;
export type DescribeVerifiedAccessGroupMaxResults = number;
export type DescribeVerifiedAccessInstanceLoggingConfigurationsMaxResults =
  number;
export type DescribeVerifiedAccessInstancesMaxResults = number;
export type DescribeVerifiedAccessTrustProvidersMaxResults = number;
export type DescribeVpcBlockPublicAccessExclusionsMaxResults = number;
export type DescribeVpcClassicLinkDnsSupportMaxResults = number;
export type DescribeVpcClassicLinkDnsSupportNextToken = string;
export type DescribeVpcEncryptionControlsMaxResults = number;
export type MaxResults2 = number;
export type DescribeVpcPeeringConnectionsMaxResults = number;
export type DescribeVpcsMaxResults = number;
export type GVCDMaxResults = number;
export type NetworkInterfaceAttachmentId = string;
export type InstanceIdForResolver = string;
export type VolumeIdWithResolver = string;
export type ElasticIpAssociationId = string;
export type DrainSeconds = number;
export type RouteTableAssociationId = string;
export type DisassociateSecurityGroupVpcSecurityGroupId = string;
export type VpcCidrAssociationId = string;
export type SecretArn = string;
export type ImageProvider = string;
export type MarketplaceProductCode = string;
export type ImageName = string;
export type MaximumDaysSinceDeprecatedValue = number;
export type MaximumDaysSinceCreatedValue = number;
export type Period = number;
export type MaxResults = number;
export type GetCapacityReservationUsageRequestMaxResults = number;
export type GetGroupsForCapacityReservationRequestMaxResults = number;
export type EkPubKeyValue = string | redacted.Redacted<string>;
export type IpamAddressHistoryMaxResults = number;
export type BoxedDouble = number;
export type GetIpamPoolAllocationsMaxResults = number;
export type GetManagedPrefixListAssociationsMaxResults = number;
export type GetNetworkInsightsAccessScopeAnalysisFindingsMaxResults = number;
export type PasswordData = string | redacted.Redacted<string>;
export type GetSecurityGroupsForVpcRequestMaxResults = number;
export type SpotPlacementScoresTargetCapacity = number;
export type SpotPlacementScoresMaxResults = number;
export type GetSubnetCidrReservationsMaxResults = number;
export type GetVerifiedAccessEndpointTargetsMaxResults = number;
export type GetVpcResourcesBlockingEncryptionEnforcementMaxResults = number;
export type VpnConnectionDeviceTypeId = string;
export type VpnConnectionDeviceSampleConfiguration =
  | string
  | redacted.Redacted<string>;
export type ListImagesInRecycleBinMaxResults = number;
export type ListSnapshotsInRecycleBinMaxResults = number;
export type CoolOffPeriodRequestHours = number;
export type RetentionPeriodRequestDays = number;
export type StringType = string;
export type ImageProviderRequest = string;
export type MarketplaceProductCodeRequest = string;
export type ImageNameRequest = string;
export type NetworkAclAssociationId = string;
export type ReportInstanceStatusRequestDescription =
  | string
  | redacted.Redacted<string>;
export type RestoreSnapshotTierRequestTemporaryRestoreDays = number;
export type RunInstancesUserData = string | redacted.Redacted<string>;
export type ElasticInferenceAcceleratorCount = number;
export type Ipv6Address = string;

//# Schemas
export type ResourceType =
  | "capacity-reservation"
  | "client-vpn-endpoint"
  | "customer-gateway"
  | "carrier-gateway"
  | "coip-pool"
  | "declarative-policies-report"
  | "dedicated-host"
  | "dhcp-options"
  | "egress-only-internet-gateway"
  | "elastic-ip"
  | "elastic-gpu"
  | "export-image-task"
  | "export-instance-task"
  | "fleet"
  | "fpga-image"
  | "host-reservation"
  | "image"
  | "image-usage-report"
  | "import-image-task"
  | "import-snapshot-task"
  | "instance"
  | "instance-event-window"
  | "internet-gateway"
  | "ipam"
  | "ipam-pool"
  | "ipam-scope"
  | "ipv4pool-ec2"
  | "ipv6pool-ec2"
  | "key-pair"
  | "launch-template"
  | "local-gateway"
  | "local-gateway-route-table"
  | "local-gateway-virtual-interface"
  | "local-gateway-virtual-interface-group"
  | "local-gateway-route-table-vpc-association"
  | "local-gateway-route-table-virtual-interface-group-association"
  | "natgateway"
  | "network-acl"
  | "network-interface"
  | "network-insights-analysis"
  | "network-insights-path"
  | "network-insights-access-scope"
  | "network-insights-access-scope-analysis"
  | "outpost-lag"
  | "placement-group"
  | "prefix-list"
  | "replace-root-volume-task"
  | "reserved-instances"
  | "route-table"
  | "security-group"
  | "security-group-rule"
  | "service-link-virtual-interface"
  | "snapshot"
  | "spot-fleet-request"
  | "spot-instances-request"
  | "subnet"
  | "subnet-cidr-reservation"
  | "traffic-mirror-filter"
  | "traffic-mirror-session"
  | "traffic-mirror-target"
  | "transit-gateway"
  | "transit-gateway-attachment"
  | "transit-gateway-connect-peer"
  | "transit-gateway-multicast-domain"
  | "transit-gateway-policy-table"
  | "transit-gateway-metering-policy"
  | "transit-gateway-route-table"
  | "transit-gateway-route-table-announcement"
  | "volume"
  | "vpc"
  | "vpc-endpoint"
  | "vpc-endpoint-connection"
  | "vpc-endpoint-service"
  | "vpc-endpoint-service-permission"
  | "vpc-peering-connection"
  | "vpn-connection"
  | "vpn-gateway"
  | "vpc-flow-log"
  | "capacity-reservation-fleet"
  | "traffic-mirror-filter-rule"
  | "vpc-endpoint-connection-device-type"
  | "verified-access-instance"
  | "verified-access-group"
  | "verified-access-endpoint"
  | "verified-access-policy"
  | "verified-access-trust-provider"
  | "vpn-connection-device-type"
  | "vpc-block-public-access-exclusion"
  | "vpc-encryption-control"
  | "route-server"
  | "route-server-endpoint"
  | "route-server-peer"
  | "ipam-resource-discovery"
  | "ipam-resource-discovery-association"
  | "instance-connect-endpoint"
  | "verified-access-endpoint-target"
  | "ipam-external-resource-verification-token"
  | "capacity-block"
  | "mac-modification-task"
  | "ipam-prefix-list-resolver"
  | "ipam-policy"
  | "ipam-prefix-list-resolver-target"
  | "secondary-interface"
  | "secondary-network"
  | "secondary-subnet"
  | "capacity-manager-data-export"
  | "vpn-concentrator"
  | (string & {});
export const ResourceType = S.String;
export interface Tag {
  Key?: string;
  Value?: string;
}
export const Tag = S.suspend(() =>
  S.Struct({
    Key: S.optional(S.String).pipe(T.XmlName("key"), T.Ec2QueryName("Key")),
    Value: S.optional(S.String).pipe(
      T.XmlName("value"),
      T.Ec2QueryName("Value"),
    ),
  }),
).annotate({ identifier: "Tag" }) as any as S.Schema<Tag>;
export type TagList = Tag[];
export const TagList = S.Array(
  Tag.pipe(T.XmlName("item")).annotate({ identifier: "Tag" }),
);
export interface TagSpecification {
  ResourceType?: ResourceType;
  Tags?: Tag[];
}
export const TagSpecification = S.suspend(() =>
  S.Struct({
    ResourceType: S.optional(ResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    Tags: S.optional(TagList).pipe(T.XmlName("Tag")),
  }),
).annotate({
  identifier: "TagSpecification",
}) as any as S.Schema<TagSpecification>;
export type TagSpecificationList = TagSpecification[];
export const TagSpecificationList = S.Array(
  TagSpecification.pipe(T.XmlName("item")).annotate({
    identifier: "TagSpecification",
  }),
);
export interface AcceptAddressTransferRequest {
  Address?: string;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const AcceptAddressTransferRequest = S.suspend(() =>
  S.Struct({
    Address: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AcceptAddressTransferRequest",
}) as any as S.Schema<AcceptAddressTransferRequest>;
export type AddressTransferStatus =
  | "pending"
  | "disabled"
  | "accepted"
  | (string & {});
export const AddressTransferStatus = S.String;
export interface AddressTransfer {
  PublicIp?: string;
  AllocationId?: string;
  TransferAccountId?: string;
  TransferOfferExpirationTimestamp?: Date;
  TransferOfferAcceptedTimestamp?: Date;
  AddressTransferStatus?: AddressTransferStatus;
}
export const AddressTransfer = S.suspend(() =>
  S.Struct({
    PublicIp: S.optional(S.String).pipe(
      T.XmlName("publicIp"),
      T.Ec2QueryName("PublicIp"),
    ),
    AllocationId: S.optional(S.String).pipe(
      T.XmlName("allocationId"),
      T.Ec2QueryName("AllocationId"),
    ),
    TransferAccountId: S.optional(S.String).pipe(
      T.XmlName("transferAccountId"),
      T.Ec2QueryName("TransferAccountId"),
    ),
    TransferOfferExpirationTimestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("transferOfferExpirationTimestamp"),
      T.Ec2QueryName("TransferOfferExpirationTimestamp"),
    ),
    TransferOfferAcceptedTimestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("transferOfferAcceptedTimestamp"),
      T.Ec2QueryName("TransferOfferAcceptedTimestamp"),
    ),
    AddressTransferStatus: S.optional(AddressTransferStatus).pipe(
      T.XmlName("addressTransferStatus"),
      T.Ec2QueryName("AddressTransferStatus"),
    ),
  }),
).annotate({
  identifier: "AddressTransfer",
}) as any as S.Schema<AddressTransfer>;
export interface AcceptAddressTransferResult {
  AddressTransfer?: AddressTransfer;
}
export const AcceptAddressTransferResult = S.suspend(() =>
  S.Struct({
    AddressTransfer: S.optional(AddressTransfer)
      .pipe(T.XmlName("addressTransfer"), T.Ec2QueryName("AddressTransfer"))
      .annotate({ identifier: "AddressTransfer" }),
  }).pipe(ns),
).annotate({
  identifier: "AcceptAddressTransferResult",
}) as any as S.Schema<AcceptAddressTransferResult>;
export interface AcceptCapacityReservationBillingOwnershipRequest {
  DryRun?: boolean;
  CapacityReservationId?: string;
}
export const AcceptCapacityReservationBillingOwnershipRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    CapacityReservationId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AcceptCapacityReservationBillingOwnershipRequest",
}) as any as S.Schema<AcceptCapacityReservationBillingOwnershipRequest>;
export interface AcceptCapacityReservationBillingOwnershipResult {
  Return?: boolean;
}
export const AcceptCapacityReservationBillingOwnershipResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AcceptCapacityReservationBillingOwnershipResult",
}) as any as S.Schema<AcceptCapacityReservationBillingOwnershipResult>;
export type ReservedInstanceIdSet = string[];
export const ReservedInstanceIdSet = S.Array(
  S.String.pipe(T.XmlName("ReservedInstanceId")),
);
export interface TargetConfigurationRequest {
  InstanceCount?: number;
  OfferingId?: string;
}
export const TargetConfigurationRequest = S.suspend(() =>
  S.Struct({
    InstanceCount: S.optional(S.Number),
    OfferingId: S.optional(S.String),
  }),
).annotate({
  identifier: "TargetConfigurationRequest",
}) as any as S.Schema<TargetConfigurationRequest>;
export type TargetConfigurationRequestSet = TargetConfigurationRequest[];
export const TargetConfigurationRequestSet = S.Array(
  TargetConfigurationRequest.pipe(
    T.XmlName("TargetConfigurationRequest"),
  ).annotate({ identifier: "TargetConfigurationRequest" }),
);
export interface AcceptReservedInstancesExchangeQuoteRequest {
  DryRun?: boolean;
  ReservedInstanceIds?: string[];
  TargetConfigurations?: TargetConfigurationRequest[];
}
export const AcceptReservedInstancesExchangeQuoteRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ReservedInstanceIds: S.optional(ReservedInstanceIdSet).pipe(
      T.XmlName("ReservedInstanceId"),
    ),
    TargetConfigurations: S.optional(TargetConfigurationRequestSet).pipe(
      T.XmlName("TargetConfiguration"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AcceptReservedInstancesExchangeQuoteRequest",
}) as any as S.Schema<AcceptReservedInstancesExchangeQuoteRequest>;
export interface AcceptReservedInstancesExchangeQuoteResult {
  ExchangeId?: string;
}
export const AcceptReservedInstancesExchangeQuoteResult = S.suspend(() =>
  S.Struct({
    ExchangeId: S.optional(S.String).pipe(
      T.XmlName("exchangeId"),
      T.Ec2QueryName("ExchangeId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AcceptReservedInstancesExchangeQuoteResult",
}) as any as S.Schema<AcceptReservedInstancesExchangeQuoteResult>;
export type ValueStringList = string[];
export const ValueStringList = S.Array(S.String.pipe(T.XmlName("item")));
export interface AcceptTransitGatewayMulticastDomainAssociationsRequest {
  TransitGatewayMulticastDomainId?: string;
  TransitGatewayAttachmentId?: string;
  SubnetIds?: string[];
  DryRun?: boolean;
}
export const AcceptTransitGatewayMulticastDomainAssociationsRequest = S.suspend(
  () =>
    S.Struct({
      TransitGatewayMulticastDomainId: S.optional(S.String),
      TransitGatewayAttachmentId: S.optional(S.String),
      SubnetIds: S.optional(ValueStringList),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "AcceptTransitGatewayMulticastDomainAssociationsRequest",
}) as any as S.Schema<AcceptTransitGatewayMulticastDomainAssociationsRequest>;
export type TransitGatewayAttachmentResourceType =
  | "vpc"
  | "vpn"
  | "vpn-concentrator"
  | "direct-connect-gateway"
  | "connect"
  | "peering"
  | "tgw-peering"
  | "network-function"
  | (string & {});
export const TransitGatewayAttachmentResourceType = S.String;
export type TransitGatewayMulitcastDomainAssociationState =
  | "pendingAcceptance"
  | "associating"
  | "associated"
  | "disassociating"
  | "disassociated"
  | "rejected"
  | "failed"
  | (string & {});
export const TransitGatewayMulitcastDomainAssociationState = S.String;
export interface SubnetAssociation {
  SubnetId?: string;
  State?: TransitGatewayMulitcastDomainAssociationState;
}
export const SubnetAssociation = S.suspend(() =>
  S.Struct({
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    State: S.optional(TransitGatewayMulitcastDomainAssociationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({
  identifier: "SubnetAssociation",
}) as any as S.Schema<SubnetAssociation>;
export type SubnetAssociationList = SubnetAssociation[];
export const SubnetAssociationList = S.Array(
  SubnetAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "SubnetAssociation",
  }),
);
export interface TransitGatewayMulticastDomainAssociations {
  TransitGatewayMulticastDomainId?: string;
  TransitGatewayAttachmentId?: string;
  ResourceId?: string;
  ResourceType?: TransitGatewayAttachmentResourceType;
  ResourceOwnerId?: string;
  Subnets?: SubnetAssociation[];
}
export const TransitGatewayMulticastDomainAssociations = S.suspend(() =>
  S.Struct({
    TransitGatewayMulticastDomainId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayMulticastDomainId"),
      T.Ec2QueryName("TransitGatewayMulticastDomainId"),
    ),
    TransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayAttachmentId"),
      T.Ec2QueryName("TransitGatewayAttachmentId"),
    ),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    ResourceType: S.optional(TransitGatewayAttachmentResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    ResourceOwnerId: S.optional(S.String).pipe(
      T.XmlName("resourceOwnerId"),
      T.Ec2QueryName("ResourceOwnerId"),
    ),
    Subnets: S.optional(SubnetAssociationList).pipe(
      T.XmlName("subnets"),
      T.Ec2QueryName("Subnets"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayMulticastDomainAssociations",
}) as any as S.Schema<TransitGatewayMulticastDomainAssociations>;
export interface AcceptTransitGatewayMulticastDomainAssociationsResult {
  Associations?: TransitGatewayMulticastDomainAssociations;
}
export const AcceptTransitGatewayMulticastDomainAssociationsResult = S.suspend(
  () =>
    S.Struct({
      Associations: S.optional(TransitGatewayMulticastDomainAssociations)
        .pipe(T.XmlName("associations"), T.Ec2QueryName("Associations"))
        .annotate({ identifier: "TransitGatewayMulticastDomainAssociations" }),
    }).pipe(ns),
).annotate({
  identifier: "AcceptTransitGatewayMulticastDomainAssociationsResult",
}) as any as S.Schema<AcceptTransitGatewayMulticastDomainAssociationsResult>;
export interface AcceptTransitGatewayPeeringAttachmentRequest {
  TransitGatewayAttachmentId?: string;
  DryRun?: boolean;
}
export const AcceptTransitGatewayPeeringAttachmentRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AcceptTransitGatewayPeeringAttachmentRequest",
}) as any as S.Schema<AcceptTransitGatewayPeeringAttachmentRequest>;
export interface PeeringTgwInfo {
  TransitGatewayId?: string;
  CoreNetworkId?: string;
  OwnerId?: string;
  Region?: string;
}
export const PeeringTgwInfo = S.suspend(() =>
  S.Struct({
    TransitGatewayId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayId"),
      T.Ec2QueryName("TransitGatewayId"),
    ),
    CoreNetworkId: S.optional(S.String).pipe(
      T.XmlName("coreNetworkId"),
      T.Ec2QueryName("CoreNetworkId"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    Region: S.optional(S.String).pipe(
      T.XmlName("region"),
      T.Ec2QueryName("Region"),
    ),
  }),
).annotate({ identifier: "PeeringTgwInfo" }) as any as S.Schema<PeeringTgwInfo>;
export type DynamicRoutingValue = "enable" | "disable" | (string & {});
export const DynamicRoutingValue = S.String;
export interface TransitGatewayPeeringAttachmentOptions {
  DynamicRouting?: DynamicRoutingValue;
}
export const TransitGatewayPeeringAttachmentOptions = S.suspend(() =>
  S.Struct({
    DynamicRouting: S.optional(DynamicRoutingValue).pipe(
      T.XmlName("dynamicRouting"),
      T.Ec2QueryName("DynamicRouting"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayPeeringAttachmentOptions",
}) as any as S.Schema<TransitGatewayPeeringAttachmentOptions>;
export interface PeeringAttachmentStatus {
  Code?: string;
  Message?: string;
}
export const PeeringAttachmentStatus = S.suspend(() =>
  S.Struct({
    Code: S.optional(S.String).pipe(T.XmlName("code"), T.Ec2QueryName("Code")),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "PeeringAttachmentStatus",
}) as any as S.Schema<PeeringAttachmentStatus>;
export type TransitGatewayAttachmentState =
  | "initiating"
  | "initiatingRequest"
  | "pendingAcceptance"
  | "rollingBack"
  | "pending"
  | "available"
  | "modifying"
  | "deleting"
  | "deleted"
  | "failed"
  | "rejected"
  | "rejecting"
  | "failing"
  | (string & {});
export const TransitGatewayAttachmentState = S.String;
export interface TransitGatewayPeeringAttachment {
  TransitGatewayAttachmentId?: string;
  AccepterTransitGatewayAttachmentId?: string;
  RequesterTgwInfo?: PeeringTgwInfo;
  AccepterTgwInfo?: PeeringTgwInfo;
  Options?: TransitGatewayPeeringAttachmentOptions;
  Status?: PeeringAttachmentStatus;
  State?: TransitGatewayAttachmentState;
  CreationTime?: Date;
  Tags?: Tag[];
}
export const TransitGatewayPeeringAttachment = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayAttachmentId"),
      T.Ec2QueryName("TransitGatewayAttachmentId"),
    ),
    AccepterTransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("accepterTransitGatewayAttachmentId"),
      T.Ec2QueryName("AccepterTransitGatewayAttachmentId"),
    ),
    RequesterTgwInfo: S.optional(PeeringTgwInfo)
      .pipe(T.XmlName("requesterTgwInfo"), T.Ec2QueryName("RequesterTgwInfo"))
      .annotate({ identifier: "PeeringTgwInfo" }),
    AccepterTgwInfo: S.optional(PeeringTgwInfo)
      .pipe(T.XmlName("accepterTgwInfo"), T.Ec2QueryName("AccepterTgwInfo"))
      .annotate({ identifier: "PeeringTgwInfo" }),
    Options: S.optional(TransitGatewayPeeringAttachmentOptions)
      .pipe(T.XmlName("options"), T.Ec2QueryName("Options"))
      .annotate({ identifier: "TransitGatewayPeeringAttachmentOptions" }),
    Status: S.optional(PeeringAttachmentStatus)
      .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
      .annotate({ identifier: "PeeringAttachmentStatus" }),
    State: S.optional(TransitGatewayAttachmentState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    CreationTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("creationTime"), T.Ec2QueryName("CreationTime")),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayPeeringAttachment",
}) as any as S.Schema<TransitGatewayPeeringAttachment>;
export interface AcceptTransitGatewayPeeringAttachmentResult {
  TransitGatewayPeeringAttachment?: TransitGatewayPeeringAttachment;
}
export const AcceptTransitGatewayPeeringAttachmentResult = S.suspend(() =>
  S.Struct({
    TransitGatewayPeeringAttachment: S.optional(TransitGatewayPeeringAttachment)
      .pipe(
        T.XmlName("transitGatewayPeeringAttachment"),
        T.Ec2QueryName("TransitGatewayPeeringAttachment"),
      )
      .annotate({ identifier: "TransitGatewayPeeringAttachment" }),
  }).pipe(ns),
).annotate({
  identifier: "AcceptTransitGatewayPeeringAttachmentResult",
}) as any as S.Schema<AcceptTransitGatewayPeeringAttachmentResult>;
export interface AcceptTransitGatewayVpcAttachmentRequest {
  TransitGatewayAttachmentId?: string;
  DryRun?: boolean;
}
export const AcceptTransitGatewayVpcAttachmentRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AcceptTransitGatewayVpcAttachmentRequest",
}) as any as S.Schema<AcceptTransitGatewayVpcAttachmentRequest>;
export type DnsSupportValue = "enable" | "disable" | (string & {});
export const DnsSupportValue = S.String;
export type SecurityGroupReferencingSupportValue =
  | "enable"
  | "disable"
  | (string & {});
export const SecurityGroupReferencingSupportValue = S.String;
export type Ipv6SupportValue = "enable" | "disable" | (string & {});
export const Ipv6SupportValue = S.String;
export type ApplianceModeSupportValue = "enable" | "disable" | (string & {});
export const ApplianceModeSupportValue = S.String;
export interface TransitGatewayVpcAttachmentOptions {
  DnsSupport?: DnsSupportValue;
  SecurityGroupReferencingSupport?: SecurityGroupReferencingSupportValue;
  Ipv6Support?: Ipv6SupportValue;
  ApplianceModeSupport?: ApplianceModeSupportValue;
}
export const TransitGatewayVpcAttachmentOptions = S.suspend(() =>
  S.Struct({
    DnsSupport: S.optional(DnsSupportValue).pipe(
      T.XmlName("dnsSupport"),
      T.Ec2QueryName("DnsSupport"),
    ),
    SecurityGroupReferencingSupport: S.optional(
      SecurityGroupReferencingSupportValue,
    ).pipe(
      T.XmlName("securityGroupReferencingSupport"),
      T.Ec2QueryName("SecurityGroupReferencingSupport"),
    ),
    Ipv6Support: S.optional(Ipv6SupportValue).pipe(
      T.XmlName("ipv6Support"),
      T.Ec2QueryName("Ipv6Support"),
    ),
    ApplianceModeSupport: S.optional(ApplianceModeSupportValue).pipe(
      T.XmlName("applianceModeSupport"),
      T.Ec2QueryName("ApplianceModeSupport"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayVpcAttachmentOptions",
}) as any as S.Schema<TransitGatewayVpcAttachmentOptions>;
export interface TransitGatewayVpcAttachment {
  TransitGatewayAttachmentId?: string;
  TransitGatewayId?: string;
  VpcId?: string;
  VpcOwnerId?: string;
  State?: TransitGatewayAttachmentState;
  SubnetIds?: string[];
  CreationTime?: Date;
  Options?: TransitGatewayVpcAttachmentOptions;
  Tags?: Tag[];
}
export const TransitGatewayVpcAttachment = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayAttachmentId"),
      T.Ec2QueryName("TransitGatewayAttachmentId"),
    ),
    TransitGatewayId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayId"),
      T.Ec2QueryName("TransitGatewayId"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    VpcOwnerId: S.optional(S.String).pipe(
      T.XmlName("vpcOwnerId"),
      T.Ec2QueryName("VpcOwnerId"),
    ),
    State: S.optional(TransitGatewayAttachmentState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    SubnetIds: S.optional(ValueStringList).pipe(
      T.XmlName("subnetIds"),
      T.Ec2QueryName("SubnetIds"),
    ),
    CreationTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("creationTime"), T.Ec2QueryName("CreationTime")),
    Options: S.optional(TransitGatewayVpcAttachmentOptions)
      .pipe(T.XmlName("options"), T.Ec2QueryName("Options"))
      .annotate({ identifier: "TransitGatewayVpcAttachmentOptions" }),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayVpcAttachment",
}) as any as S.Schema<TransitGatewayVpcAttachment>;
export interface AcceptTransitGatewayVpcAttachmentResult {
  TransitGatewayVpcAttachment?: TransitGatewayVpcAttachment;
}
export const AcceptTransitGatewayVpcAttachmentResult = S.suspend(() =>
  S.Struct({
    TransitGatewayVpcAttachment: S.optional(TransitGatewayVpcAttachment)
      .pipe(
        T.XmlName("transitGatewayVpcAttachment"),
        T.Ec2QueryName("TransitGatewayVpcAttachment"),
      )
      .annotate({ identifier: "TransitGatewayVpcAttachment" }),
  }).pipe(ns),
).annotate({
  identifier: "AcceptTransitGatewayVpcAttachmentResult",
}) as any as S.Schema<AcceptTransitGatewayVpcAttachmentResult>;
export type VpcEndpointIdList = string[];
export const VpcEndpointIdList = S.Array(S.String.pipe(T.XmlName("item")));
export interface AcceptVpcEndpointConnectionsRequest {
  DryRun?: boolean;
  ServiceId?: string;
  VpcEndpointIds?: string[];
}
export const AcceptVpcEndpointConnectionsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ServiceId: S.optional(S.String),
    VpcEndpointIds: S.optional(VpcEndpointIdList).pipe(
      T.XmlName("VpcEndpointId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AcceptVpcEndpointConnectionsRequest",
}) as any as S.Schema<AcceptVpcEndpointConnectionsRequest>;
export interface UnsuccessfulItemError {
  Code?: string;
  Message?: string;
}
export const UnsuccessfulItemError = S.suspend(() =>
  S.Struct({
    Code: S.optional(S.String).pipe(T.XmlName("code"), T.Ec2QueryName("Code")),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "UnsuccessfulItemError",
}) as any as S.Schema<UnsuccessfulItemError>;
export interface UnsuccessfulItem {
  Error?: UnsuccessfulItemError;
  ResourceId?: string;
}
export const UnsuccessfulItem = S.suspend(() =>
  S.Struct({
    Error: S.optional(UnsuccessfulItemError)
      .pipe(T.XmlName("error"), T.Ec2QueryName("Error"))
      .annotate({ identifier: "UnsuccessfulItemError" }),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
  }),
).annotate({
  identifier: "UnsuccessfulItem",
}) as any as S.Schema<UnsuccessfulItem>;
export type UnsuccessfulItemSet = UnsuccessfulItem[];
export const UnsuccessfulItemSet = S.Array(
  UnsuccessfulItem.pipe(T.XmlName("item")).annotate({
    identifier: "UnsuccessfulItem",
  }),
);
export interface AcceptVpcEndpointConnectionsResult {
  Unsuccessful?: UnsuccessfulItem[];
}
export const AcceptVpcEndpointConnectionsResult = S.suspend(() =>
  S.Struct({
    Unsuccessful: S.optional(UnsuccessfulItemSet).pipe(
      T.XmlName("unsuccessful"),
      T.Ec2QueryName("Unsuccessful"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AcceptVpcEndpointConnectionsResult",
}) as any as S.Schema<AcceptVpcEndpointConnectionsResult>;
export interface AcceptVpcPeeringConnectionRequest {
  DryRun?: boolean;
  VpcPeeringConnectionId?: string;
}
export const AcceptVpcPeeringConnectionRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    VpcPeeringConnectionId: S.optional(S.String).pipe(
      T.XmlName("vpcPeeringConnectionId"),
      T.Ec2QueryName("VpcPeeringConnectionId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AcceptVpcPeeringConnectionRequest",
}) as any as S.Schema<AcceptVpcPeeringConnectionRequest>;
export interface Ipv6CidrBlock {
  Ipv6CidrBlock?: string;
}
export const Ipv6CidrBlock = S.suspend(() =>
  S.Struct({
    Ipv6CidrBlock: S.optional(S.String).pipe(
      T.XmlName("ipv6CidrBlock"),
      T.Ec2QueryName("Ipv6CidrBlock"),
    ),
  }),
).annotate({ identifier: "Ipv6CidrBlock" }) as any as S.Schema<Ipv6CidrBlock>;
export type Ipv6CidrBlockSet = Ipv6CidrBlock[];
export const Ipv6CidrBlockSet = S.Array(
  Ipv6CidrBlock.pipe(T.XmlName("item")).annotate({
    identifier: "Ipv6CidrBlock",
  }),
);
export interface CidrBlock {
  CidrBlock?: string;
}
export const CidrBlock = S.suspend(() =>
  S.Struct({
    CidrBlock: S.optional(S.String).pipe(
      T.XmlName("cidrBlock"),
      T.Ec2QueryName("CidrBlock"),
    ),
  }),
).annotate({ identifier: "CidrBlock" }) as any as S.Schema<CidrBlock>;
export type CidrBlockSet = CidrBlock[];
export const CidrBlockSet = S.Array(
  CidrBlock.pipe(T.XmlName("item")).annotate({ identifier: "CidrBlock" }),
);
export interface VpcPeeringConnectionOptionsDescription {
  AllowDnsResolutionFromRemoteVpc?: boolean;
  AllowEgressFromLocalClassicLinkToRemoteVpc?: boolean;
  AllowEgressFromLocalVpcToRemoteClassicLink?: boolean;
}
export const VpcPeeringConnectionOptionsDescription = S.suspend(() =>
  S.Struct({
    AllowDnsResolutionFromRemoteVpc: S.optional(S.Boolean).pipe(
      T.XmlName("allowDnsResolutionFromRemoteVpc"),
      T.Ec2QueryName("AllowDnsResolutionFromRemoteVpc"),
    ),
    AllowEgressFromLocalClassicLinkToRemoteVpc: S.optional(S.Boolean).pipe(
      T.XmlName("allowEgressFromLocalClassicLinkToRemoteVpc"),
      T.Ec2QueryName("AllowEgressFromLocalClassicLinkToRemoteVpc"),
    ),
    AllowEgressFromLocalVpcToRemoteClassicLink: S.optional(S.Boolean).pipe(
      T.XmlName("allowEgressFromLocalVpcToRemoteClassicLink"),
      T.Ec2QueryName("AllowEgressFromLocalVpcToRemoteClassicLink"),
    ),
  }),
).annotate({
  identifier: "VpcPeeringConnectionOptionsDescription",
}) as any as S.Schema<VpcPeeringConnectionOptionsDescription>;
export interface VpcPeeringConnectionVpcInfo {
  CidrBlock?: string;
  Ipv6CidrBlockSet?: Ipv6CidrBlock[];
  CidrBlockSet?: CidrBlock[];
  OwnerId?: string;
  PeeringOptions?: VpcPeeringConnectionOptionsDescription;
  VpcId?: string;
  Region?: string;
}
export const VpcPeeringConnectionVpcInfo = S.suspend(() =>
  S.Struct({
    CidrBlock: S.optional(S.String).pipe(
      T.XmlName("cidrBlock"),
      T.Ec2QueryName("CidrBlock"),
    ),
    Ipv6CidrBlockSet: S.optional(Ipv6CidrBlockSet).pipe(
      T.XmlName("ipv6CidrBlockSet"),
      T.Ec2QueryName("Ipv6CidrBlockSet"),
    ),
    CidrBlockSet: S.optional(CidrBlockSet).pipe(
      T.XmlName("cidrBlockSet"),
      T.Ec2QueryName("CidrBlockSet"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    PeeringOptions: S.optional(VpcPeeringConnectionOptionsDescription)
      .pipe(T.XmlName("peeringOptions"), T.Ec2QueryName("PeeringOptions"))
      .annotate({ identifier: "VpcPeeringConnectionOptionsDescription" }),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    Region: S.optional(S.String).pipe(
      T.XmlName("region"),
      T.Ec2QueryName("Region"),
    ),
  }),
).annotate({
  identifier: "VpcPeeringConnectionVpcInfo",
}) as any as S.Schema<VpcPeeringConnectionVpcInfo>;
export type VpcPeeringConnectionStateReasonCode =
  | "initiating-request"
  | "pending-acceptance"
  | "active"
  | "deleted"
  | "rejected"
  | "failed"
  | "expired"
  | "provisioning"
  | "deleting"
  | (string & {});
export const VpcPeeringConnectionStateReasonCode = S.String;
export interface VpcPeeringConnectionStateReason {
  Code?: VpcPeeringConnectionStateReasonCode;
  Message?: string;
}
export const VpcPeeringConnectionStateReason = S.suspend(() =>
  S.Struct({
    Code: S.optional(VpcPeeringConnectionStateReasonCode).pipe(
      T.XmlName("code"),
      T.Ec2QueryName("Code"),
    ),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "VpcPeeringConnectionStateReason",
}) as any as S.Schema<VpcPeeringConnectionStateReason>;
export interface VpcPeeringConnection {
  AccepterVpcInfo?: VpcPeeringConnectionVpcInfo;
  ExpirationTime?: Date;
  RequesterVpcInfo?: VpcPeeringConnectionVpcInfo;
  Status?: VpcPeeringConnectionStateReason;
  Tags?: Tag[];
  VpcPeeringConnectionId?: string;
}
export const VpcPeeringConnection = S.suspend(() =>
  S.Struct({
    AccepterVpcInfo: S.optional(VpcPeeringConnectionVpcInfo)
      .pipe(T.XmlName("accepterVpcInfo"), T.Ec2QueryName("AccepterVpcInfo"))
      .annotate({ identifier: "VpcPeeringConnectionVpcInfo" }),
    ExpirationTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("expirationTime"), T.Ec2QueryName("ExpirationTime")),
    RequesterVpcInfo: S.optional(VpcPeeringConnectionVpcInfo)
      .pipe(T.XmlName("requesterVpcInfo"), T.Ec2QueryName("RequesterVpcInfo"))
      .annotate({ identifier: "VpcPeeringConnectionVpcInfo" }),
    Status: S.optional(VpcPeeringConnectionStateReason)
      .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
      .annotate({ identifier: "VpcPeeringConnectionStateReason" }),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    VpcPeeringConnectionId: S.optional(S.String).pipe(
      T.XmlName("vpcPeeringConnectionId"),
      T.Ec2QueryName("VpcPeeringConnectionId"),
    ),
  }),
).annotate({
  identifier: "VpcPeeringConnection",
}) as any as S.Schema<VpcPeeringConnection>;
export interface AcceptVpcPeeringConnectionResult {
  VpcPeeringConnection?: VpcPeeringConnection;
}
export const AcceptVpcPeeringConnectionResult = S.suspend(() =>
  S.Struct({
    VpcPeeringConnection: S.optional(VpcPeeringConnection)
      .pipe(
        T.XmlName("vpcPeeringConnection"),
        T.Ec2QueryName("VpcPeeringConnection"),
      )
      .annotate({ identifier: "VpcPeeringConnection" }),
  }).pipe(ns),
).annotate({
  identifier: "AcceptVpcPeeringConnectionResult",
}) as any as S.Schema<AcceptVpcPeeringConnectionResult>;
export interface AdvertiseByoipCidrRequest {
  Cidr?: string;
  Asn?: string;
  DryRun?: boolean;
  NetworkBorderGroup?: string;
}
export const AdvertiseByoipCidrRequest = S.suspend(() =>
  S.Struct({
    Cidr: S.optional(S.String),
    Asn: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    NetworkBorderGroup: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AdvertiseByoipCidrRequest",
}) as any as S.Schema<AdvertiseByoipCidrRequest>;
export type AsnAssociationState =
  | "disassociated"
  | "failed-disassociation"
  | "failed-association"
  | "pending-disassociation"
  | "pending-association"
  | "associated"
  | (string & {});
export const AsnAssociationState = S.String;
export interface AsnAssociation {
  Asn?: string;
  Cidr?: string;
  StatusMessage?: string;
  State?: AsnAssociationState;
}
export const AsnAssociation = S.suspend(() =>
  S.Struct({
    Asn: S.optional(S.String).pipe(T.XmlName("asn"), T.Ec2QueryName("Asn")),
    Cidr: S.optional(S.String).pipe(T.XmlName("cidr"), T.Ec2QueryName("Cidr")),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    State: S.optional(AsnAssociationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({ identifier: "AsnAssociation" }) as any as S.Schema<AsnAssociation>;
export type AsnAssociationSet = AsnAssociation[];
export const AsnAssociationSet = S.Array(
  AsnAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "AsnAssociation",
  }),
);
export type ByoipCidrState =
  | "advertised"
  | "deprovisioned"
  | "failed-deprovision"
  | "failed-provision"
  | "pending-advertising"
  | "pending-deprovision"
  | "pending-provision"
  | "pending-withdrawal"
  | "provisioned"
  | "provisioned-not-publicly-advertisable"
  | (string & {});
export const ByoipCidrState = S.String;
export interface ByoipCidr {
  Cidr?: string;
  Description?: string;
  AsnAssociations?: AsnAssociation[];
  StatusMessage?: string;
  State?: ByoipCidrState;
  NetworkBorderGroup?: string;
  AdvertisementType?: string;
}
export const ByoipCidr = S.suspend(() =>
  S.Struct({
    Cidr: S.optional(S.String).pipe(T.XmlName("cidr"), T.Ec2QueryName("Cidr")),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    AsnAssociations: S.optional(AsnAssociationSet).pipe(
      T.XmlName("asnAssociationSet"),
      T.Ec2QueryName("AsnAssociationSet"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    State: S.optional(ByoipCidrState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    NetworkBorderGroup: S.optional(S.String).pipe(
      T.XmlName("networkBorderGroup"),
      T.Ec2QueryName("NetworkBorderGroup"),
    ),
    AdvertisementType: S.optional(S.String).pipe(
      T.XmlName("advertisementType"),
      T.Ec2QueryName("AdvertisementType"),
    ),
  }),
).annotate({ identifier: "ByoipCidr" }) as any as S.Schema<ByoipCidr>;
export interface AdvertiseByoipCidrResult {
  ByoipCidr?: ByoipCidr;
}
export const AdvertiseByoipCidrResult = S.suspend(() =>
  S.Struct({
    ByoipCidr: S.optional(ByoipCidr)
      .pipe(T.XmlName("byoipCidr"), T.Ec2QueryName("ByoipCidr"))
      .annotate({ identifier: "ByoipCidr" }),
  }).pipe(ns),
).annotate({
  identifier: "AdvertiseByoipCidrResult",
}) as any as S.Schema<AdvertiseByoipCidrResult>;
export type DomainType = "vpc" | "standard" | (string & {});
export const DomainType = S.String;
export interface AllocateAddressRequest {
  Domain?: DomainType;
  Address?: string;
  PublicIpv4Pool?: string;
  NetworkBorderGroup?: string;
  CustomerOwnedIpv4Pool?: string;
  TagSpecifications?: TagSpecification[];
  IpamPoolId?: string;
  DryRun?: boolean;
}
export const AllocateAddressRequest = S.suspend(() =>
  S.Struct({
    Domain: S.optional(DomainType),
    Address: S.optional(S.String),
    PublicIpv4Pool: S.optional(S.String),
    NetworkBorderGroup: S.optional(S.String),
    CustomerOwnedIpv4Pool: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    IpamPoolId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AllocateAddressRequest",
}) as any as S.Schema<AllocateAddressRequest>;
export interface AllocateAddressResult {
  AllocationId?: string;
  PublicIpv4Pool?: string;
  NetworkBorderGroup?: string;
  Domain?: DomainType;
  CustomerOwnedIp?: string;
  CustomerOwnedIpv4Pool?: string;
  CarrierIp?: string;
  PublicIp?: string;
}
export const AllocateAddressResult = S.suspend(() =>
  S.Struct({
    AllocationId: S.optional(S.String).pipe(
      T.XmlName("allocationId"),
      T.Ec2QueryName("AllocationId"),
    ),
    PublicIpv4Pool: S.optional(S.String).pipe(
      T.XmlName("publicIpv4Pool"),
      T.Ec2QueryName("PublicIpv4Pool"),
    ),
    NetworkBorderGroup: S.optional(S.String).pipe(
      T.XmlName("networkBorderGroup"),
      T.Ec2QueryName("NetworkBorderGroup"),
    ),
    Domain: S.optional(DomainType).pipe(
      T.XmlName("domain"),
      T.Ec2QueryName("Domain"),
    ),
    CustomerOwnedIp: S.optional(S.String).pipe(
      T.XmlName("customerOwnedIp"),
      T.Ec2QueryName("CustomerOwnedIp"),
    ),
    CustomerOwnedIpv4Pool: S.optional(S.String).pipe(
      T.XmlName("customerOwnedIpv4Pool"),
      T.Ec2QueryName("CustomerOwnedIpv4Pool"),
    ),
    CarrierIp: S.optional(S.String).pipe(
      T.XmlName("carrierIp"),
      T.Ec2QueryName("CarrierIp"),
    ),
    PublicIp: S.optional(S.String).pipe(
      T.XmlName("publicIp"),
      T.Ec2QueryName("PublicIp"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AllocateAddressResult",
}) as any as S.Schema<AllocateAddressResult>;
export type HostRecovery = "on" | "off" | (string & {});
export const HostRecovery = S.String;
export type HostMaintenance = "on" | "off" | (string & {});
export const HostMaintenance = S.String;
export type AssetIdList = string[];
export const AssetIdList = S.Array(S.String);
export type AutoPlacement = "on" | "off" | (string & {});
export const AutoPlacement = S.String;
export interface AllocateHostsRequest {
  InstanceFamily?: string;
  TagSpecifications?: TagSpecification[];
  HostRecovery?: HostRecovery;
  OutpostArn?: string;
  HostMaintenance?: HostMaintenance;
  AssetIds?: string[];
  AvailabilityZoneId?: string;
  AutoPlacement?: AutoPlacement;
  ClientToken?: string;
  InstanceType?: string;
  Quantity?: number;
  AvailabilityZone?: string;
}
export const AllocateHostsRequest = S.suspend(() =>
  S.Struct({
    InstanceFamily: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    HostRecovery: S.optional(HostRecovery),
    OutpostArn: S.optional(S.String),
    HostMaintenance: S.optional(HostMaintenance),
    AssetIds: S.optional(AssetIdList).pipe(T.XmlName("AssetId")),
    AvailabilityZoneId: S.optional(S.String),
    AutoPlacement: S.optional(AutoPlacement).pipe(
      T.XmlName("autoPlacement"),
      T.Ec2QueryName("AutoPlacement"),
    ),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
    InstanceType: S.optional(S.String).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    Quantity: S.optional(S.Number).pipe(
      T.XmlName("quantity"),
      T.Ec2QueryName("Quantity"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AllocateHostsRequest",
}) as any as S.Schema<AllocateHostsRequest>;
export type ResponseHostIdList = string[];
export const ResponseHostIdList = S.Array(S.String.pipe(T.XmlName("item")));
export interface AllocateHostsResult {
  HostIds?: string[];
}
export const AllocateHostsResult = S.suspend(() =>
  S.Struct({
    HostIds: S.optional(ResponseHostIdList).pipe(
      T.XmlName("hostIdSet"),
      T.Ec2QueryName("HostIdSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AllocateHostsResult",
}) as any as S.Schema<AllocateHostsResult>;
export type IpamPoolAllocationAllowedCidrs = string[];
export const IpamPoolAllocationAllowedCidrs = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export type IpamPoolAllocationDisallowedCidrs = string[];
export const IpamPoolAllocationDisallowedCidrs = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface AllocateIpamPoolCidrRequest {
  DryRun?: boolean;
  IpamPoolId?: string;
  Cidr?: string;
  NetmaskLength?: number;
  ClientToken?: string;
  Description?: string;
  PreviewNextCidr?: boolean;
  AllowedCidrs?: string[];
  DisallowedCidrs?: string[];
}
export const AllocateIpamPoolCidrRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPoolId: S.optional(S.String),
    Cidr: S.optional(S.String),
    NetmaskLength: S.optional(S.Number),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    Description: S.optional(S.String),
    PreviewNextCidr: S.optional(S.Boolean),
    AllowedCidrs: S.optional(IpamPoolAllocationAllowedCidrs).pipe(
      T.XmlName("AllowedCidr"),
    ),
    DisallowedCidrs: S.optional(IpamPoolAllocationDisallowedCidrs).pipe(
      T.XmlName("DisallowedCidr"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AllocateIpamPoolCidrRequest",
}) as any as S.Schema<AllocateIpamPoolCidrRequest>;
export type IpamPoolAllocationResourceType =
  | "ipam-pool"
  | "vpc"
  | "ec2-public-ipv4-pool"
  | "custom"
  | "subnet"
  | "eip"
  | "anycast-ip-list"
  | (string & {});
export const IpamPoolAllocationResourceType = S.String;
export interface IpamPoolAllocation {
  Cidr?: string;
  IpamPoolAllocationId?: string;
  Description?: string;
  ResourceId?: string;
  ResourceType?: IpamPoolAllocationResourceType;
  ResourceRegion?: string;
  ResourceOwner?: string;
}
export const IpamPoolAllocation = S.suspend(() =>
  S.Struct({
    Cidr: S.optional(S.String).pipe(T.XmlName("cidr"), T.Ec2QueryName("Cidr")),
    IpamPoolAllocationId: S.optional(S.String).pipe(
      T.XmlName("ipamPoolAllocationId"),
      T.Ec2QueryName("IpamPoolAllocationId"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    ResourceType: S.optional(IpamPoolAllocationResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    ResourceRegion: S.optional(S.String).pipe(
      T.XmlName("resourceRegion"),
      T.Ec2QueryName("ResourceRegion"),
    ),
    ResourceOwner: S.optional(S.String).pipe(
      T.XmlName("resourceOwner"),
      T.Ec2QueryName("ResourceOwner"),
    ),
  }),
).annotate({
  identifier: "IpamPoolAllocation",
}) as any as S.Schema<IpamPoolAllocation>;
export interface AllocateIpamPoolCidrResult {
  IpamPoolAllocation?: IpamPoolAllocation;
}
export const AllocateIpamPoolCidrResult = S.suspend(() =>
  S.Struct({
    IpamPoolAllocation: S.optional(IpamPoolAllocation)
      .pipe(
        T.XmlName("ipamPoolAllocation"),
        T.Ec2QueryName("IpamPoolAllocation"),
      )
      .annotate({ identifier: "IpamPoolAllocation" }),
  }).pipe(ns),
).annotate({
  identifier: "AllocateIpamPoolCidrResult",
}) as any as S.Schema<AllocateIpamPoolCidrResult>;
export type ClientVpnSecurityGroupIdSet = string[];
export const ClientVpnSecurityGroupIdSet = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface ApplySecurityGroupsToClientVpnTargetNetworkRequest {
  ClientVpnEndpointId?: string;
  VpcId?: string;
  SecurityGroupIds?: string[];
  DryRun?: boolean;
}
export const ApplySecurityGroupsToClientVpnTargetNetworkRequest = S.suspend(
  () =>
    S.Struct({
      ClientVpnEndpointId: S.optional(S.String),
      VpcId: S.optional(S.String),
      SecurityGroupIds: S.optional(ClientVpnSecurityGroupIdSet).pipe(
        T.XmlName("SecurityGroupId"),
      ),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "ApplySecurityGroupsToClientVpnTargetNetworkRequest",
}) as any as S.Schema<ApplySecurityGroupsToClientVpnTargetNetworkRequest>;
export interface ApplySecurityGroupsToClientVpnTargetNetworkResult {
  SecurityGroupIds?: string[];
}
export const ApplySecurityGroupsToClientVpnTargetNetworkResult = S.suspend(() =>
  S.Struct({
    SecurityGroupIds: S.optional(ClientVpnSecurityGroupIdSet).pipe(
      T.XmlName("securityGroupIds"),
      T.Ec2QueryName("SecurityGroupIds"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ApplySecurityGroupsToClientVpnTargetNetworkResult",
}) as any as S.Schema<ApplySecurityGroupsToClientVpnTargetNetworkResult>;
export type IpPrefixList = string[];
export const IpPrefixList = S.Array(S.String.pipe(T.XmlName("item")));
export type Ipv6AddressList = string[];
export const Ipv6AddressList = S.Array(S.String.pipe(T.XmlName("item")));
export interface AssignIpv6AddressesRequest {
  Ipv6PrefixCount?: number;
  Ipv6Prefixes?: string[];
  NetworkInterfaceId?: string;
  Ipv6Addresses?: string[];
  Ipv6AddressCount?: number;
}
export const AssignIpv6AddressesRequest = S.suspend(() =>
  S.Struct({
    Ipv6PrefixCount: S.optional(S.Number),
    Ipv6Prefixes: S.optional(IpPrefixList).pipe(T.XmlName("Ipv6Prefix")),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    Ipv6Addresses: S.optional(Ipv6AddressList).pipe(
      T.XmlName("ipv6Addresses"),
      T.Ec2QueryName("Ipv6Addresses"),
    ),
    Ipv6AddressCount: S.optional(S.Number).pipe(
      T.XmlName("ipv6AddressCount"),
      T.Ec2QueryName("Ipv6AddressCount"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssignIpv6AddressesRequest",
}) as any as S.Schema<AssignIpv6AddressesRequest>;
export interface AssignIpv6AddressesResult {
  AssignedIpv6Addresses?: string[];
  AssignedIpv6Prefixes?: string[];
  NetworkInterfaceId?: string;
}
export const AssignIpv6AddressesResult = S.suspend(() =>
  S.Struct({
    AssignedIpv6Addresses: S.optional(Ipv6AddressList).pipe(
      T.XmlName("assignedIpv6Addresses"),
      T.Ec2QueryName("AssignedIpv6Addresses"),
    ),
    AssignedIpv6Prefixes: S.optional(IpPrefixList).pipe(
      T.XmlName("assignedIpv6PrefixSet"),
      T.Ec2QueryName("AssignedIpv6PrefixSet"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AssignIpv6AddressesResult",
}) as any as S.Schema<AssignIpv6AddressesResult>;
export type PrivateIpAddressStringList = string[];
export const PrivateIpAddressStringList = S.Array(
  S.String.pipe(T.XmlName("PrivateIpAddress")),
);
export interface AssignPrivateIpAddressesRequest {
  Ipv4Prefixes?: string[];
  Ipv4PrefixCount?: number;
  NetworkInterfaceId?: string;
  PrivateIpAddresses?: string[];
  SecondaryPrivateIpAddressCount?: number;
  AllowReassignment?: boolean;
}
export const AssignPrivateIpAddressesRequest = S.suspend(() =>
  S.Struct({
    Ipv4Prefixes: S.optional(IpPrefixList).pipe(T.XmlName("Ipv4Prefix")),
    Ipv4PrefixCount: S.optional(S.Number),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    PrivateIpAddresses: S.optional(PrivateIpAddressStringList).pipe(
      T.XmlName("privateIpAddress"),
      T.Ec2QueryName("PrivateIpAddress"),
    ),
    SecondaryPrivateIpAddressCount: S.optional(S.Number).pipe(
      T.XmlName("secondaryPrivateIpAddressCount"),
      T.Ec2QueryName("SecondaryPrivateIpAddressCount"),
    ),
    AllowReassignment: S.optional(S.Boolean).pipe(
      T.XmlName("allowReassignment"),
      T.Ec2QueryName("AllowReassignment"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssignPrivateIpAddressesRequest",
}) as any as S.Schema<AssignPrivateIpAddressesRequest>;
export interface AssignedPrivateIpAddress {
  PrivateIpAddress?: string;
}
export const AssignedPrivateIpAddress = S.suspend(() =>
  S.Struct({
    PrivateIpAddress: S.optional(S.String).pipe(
      T.XmlName("privateIpAddress"),
      T.Ec2QueryName("PrivateIpAddress"),
    ),
  }),
).annotate({
  identifier: "AssignedPrivateIpAddress",
}) as any as S.Schema<AssignedPrivateIpAddress>;
export type AssignedPrivateIpAddressList = AssignedPrivateIpAddress[];
export const AssignedPrivateIpAddressList = S.Array(
  AssignedPrivateIpAddress.pipe(T.XmlName("item")).annotate({
    identifier: "AssignedPrivateIpAddress",
  }),
);
export interface Ipv4PrefixSpecification {
  Ipv4Prefix?: string;
}
export const Ipv4PrefixSpecification = S.suspend(() =>
  S.Struct({
    Ipv4Prefix: S.optional(S.String).pipe(
      T.XmlName("ipv4Prefix"),
      T.Ec2QueryName("Ipv4Prefix"),
    ),
  }),
).annotate({
  identifier: "Ipv4PrefixSpecification",
}) as any as S.Schema<Ipv4PrefixSpecification>;
export type Ipv4PrefixesList = Ipv4PrefixSpecification[];
export const Ipv4PrefixesList = S.Array(
  Ipv4PrefixSpecification.pipe(T.XmlName("item")).annotate({
    identifier: "Ipv4PrefixSpecification",
  }),
);
export interface AssignPrivateIpAddressesResult {
  NetworkInterfaceId?: string;
  AssignedPrivateIpAddresses?: AssignedPrivateIpAddress[];
  AssignedIpv4Prefixes?: Ipv4PrefixSpecification[];
}
export const AssignPrivateIpAddressesResult = S.suspend(() =>
  S.Struct({
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    AssignedPrivateIpAddresses: S.optional(AssignedPrivateIpAddressList).pipe(
      T.XmlName("assignedPrivateIpAddressesSet"),
      T.Ec2QueryName("AssignedPrivateIpAddressesSet"),
    ),
    AssignedIpv4Prefixes: S.optional(Ipv4PrefixesList).pipe(
      T.XmlName("assignedIpv4PrefixSet"),
      T.Ec2QueryName("AssignedIpv4PrefixSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AssignPrivateIpAddressesResult",
}) as any as S.Schema<AssignPrivateIpAddressesResult>;
export type IpList = string[];
export const IpList = S.Array(S.String.pipe(T.XmlName("item")));
export interface AssignPrivateNatGatewayAddressRequest {
  NatGatewayId?: string;
  PrivateIpAddresses?: string[];
  PrivateIpAddressCount?: number;
  DryRun?: boolean;
}
export const AssignPrivateNatGatewayAddressRequest = S.suspend(() =>
  S.Struct({
    NatGatewayId: S.optional(S.String),
    PrivateIpAddresses: S.optional(IpList).pipe(T.XmlName("PrivateIpAddress")),
    PrivateIpAddressCount: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssignPrivateNatGatewayAddressRequest",
}) as any as S.Schema<AssignPrivateNatGatewayAddressRequest>;
export type NatGatewayAddressStatus =
  | "assigning"
  | "unassigning"
  | "associating"
  | "disassociating"
  | "succeeded"
  | "failed"
  | (string & {});
export const NatGatewayAddressStatus = S.String;
export interface NatGatewayAddress {
  AllocationId?: string;
  NetworkInterfaceId?: string;
  PrivateIp?: string;
  PublicIp?: string;
  AssociationId?: string;
  IsPrimary?: boolean;
  FailureMessage?: string;
  Status?: NatGatewayAddressStatus;
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
}
export const NatGatewayAddress = S.suspend(() =>
  S.Struct({
    AllocationId: S.optional(S.String).pipe(
      T.XmlName("allocationId"),
      T.Ec2QueryName("AllocationId"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    PrivateIp: S.optional(S.String).pipe(
      T.XmlName("privateIp"),
      T.Ec2QueryName("PrivateIp"),
    ),
    PublicIp: S.optional(S.String).pipe(
      T.XmlName("publicIp"),
      T.Ec2QueryName("PublicIp"),
    ),
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
    IsPrimary: S.optional(S.Boolean).pipe(
      T.XmlName("isPrimary"),
      T.Ec2QueryName("IsPrimary"),
    ),
    FailureMessage: S.optional(S.String).pipe(
      T.XmlName("failureMessage"),
      T.Ec2QueryName("FailureMessage"),
    ),
    Status: S.optional(NatGatewayAddressStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
  }),
).annotate({
  identifier: "NatGatewayAddress",
}) as any as S.Schema<NatGatewayAddress>;
export type NatGatewayAddressList = NatGatewayAddress[];
export const NatGatewayAddressList = S.Array(
  NatGatewayAddress.pipe(T.XmlName("item")).annotate({
    identifier: "NatGatewayAddress",
  }),
);
export interface AssignPrivateNatGatewayAddressResult {
  NatGatewayId?: string;
  NatGatewayAddresses?: NatGatewayAddress[];
}
export const AssignPrivateNatGatewayAddressResult = S.suspend(() =>
  S.Struct({
    NatGatewayId: S.optional(S.String).pipe(
      T.XmlName("natGatewayId"),
      T.Ec2QueryName("NatGatewayId"),
    ),
    NatGatewayAddresses: S.optional(NatGatewayAddressList).pipe(
      T.XmlName("natGatewayAddressSet"),
      T.Ec2QueryName("NatGatewayAddressSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AssignPrivateNatGatewayAddressResult",
}) as any as S.Schema<AssignPrivateNatGatewayAddressResult>;
export interface AssociateAddressRequest {
  AllocationId?: string;
  InstanceId?: string;
  PublicIp?: string;
  DryRun?: boolean;
  NetworkInterfaceId?: string;
  PrivateIpAddress?: string;
  AllowReassociation?: boolean;
}
export const AssociateAddressRequest = S.suspend(() =>
  S.Struct({
    AllocationId: S.optional(S.String),
    InstanceId: S.optional(S.String),
    PublicIp: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    PrivateIpAddress: S.optional(S.String).pipe(
      T.XmlName("privateIpAddress"),
      T.Ec2QueryName("PrivateIpAddress"),
    ),
    AllowReassociation: S.optional(S.Boolean).pipe(
      T.XmlName("allowReassociation"),
      T.Ec2QueryName("AllowReassociation"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateAddressRequest",
}) as any as S.Schema<AssociateAddressRequest>;
export interface AssociateAddressResult {
  AssociationId?: string;
}
export const AssociateAddressResult = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AssociateAddressResult",
}) as any as S.Schema<AssociateAddressResult>;
export interface AssociateCapacityReservationBillingOwnerRequest {
  DryRun?: boolean;
  CapacityReservationId?: string;
  UnusedReservationBillingOwnerId?: string;
}
export const AssociateCapacityReservationBillingOwnerRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    CapacityReservationId: S.optional(S.String),
    UnusedReservationBillingOwnerId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateCapacityReservationBillingOwnerRequest",
}) as any as S.Schema<AssociateCapacityReservationBillingOwnerRequest>;
export interface AssociateCapacityReservationBillingOwnerResult {
  Return?: boolean;
}
export const AssociateCapacityReservationBillingOwnerResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AssociateCapacityReservationBillingOwnerResult",
}) as any as S.Schema<AssociateCapacityReservationBillingOwnerResult>;
export interface AssociateClientVpnTargetNetworkRequest {
  ClientVpnEndpointId?: string;
  SubnetId?: string;
  ClientToken?: string;
  DryRun?: boolean;
}
export const AssociateClientVpnTargetNetworkRequest = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String),
    SubnetId: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateClientVpnTargetNetworkRequest",
}) as any as S.Schema<AssociateClientVpnTargetNetworkRequest>;
export type AssociationStatusCode =
  | "associating"
  | "associated"
  | "association-failed"
  | "disassociating"
  | "disassociated"
  | (string & {});
export const AssociationStatusCode = S.String;
export interface AssociationStatus {
  Code?: AssociationStatusCode;
  Message?: string;
}
export const AssociationStatus = S.suspend(() =>
  S.Struct({
    Code: S.optional(AssociationStatusCode).pipe(
      T.XmlName("code"),
      T.Ec2QueryName("Code"),
    ),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "AssociationStatus",
}) as any as S.Schema<AssociationStatus>;
export interface AssociateClientVpnTargetNetworkResult {
  AssociationId?: string;
  Status?: AssociationStatus;
}
export const AssociateClientVpnTargetNetworkResult = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
    Status: S.optional(AssociationStatus)
      .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
      .annotate({ identifier: "AssociationStatus" }),
  }).pipe(ns),
).annotate({
  identifier: "AssociateClientVpnTargetNetworkResult",
}) as any as S.Schema<AssociateClientVpnTargetNetworkResult>;
export interface AssociateDhcpOptionsRequest {
  DhcpOptionsId?: string;
  VpcId?: string;
  DryRun?: boolean;
}
export const AssociateDhcpOptionsRequest = S.suspend(() =>
  S.Struct({
    DhcpOptionsId: S.optional(S.String),
    VpcId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateDhcpOptionsRequest",
}) as any as S.Schema<AssociateDhcpOptionsRequest>;
export interface AssociateDhcpOptionsResponse {}
export const AssociateDhcpOptionsResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "AssociateDhcpOptionsResponse",
}) as any as S.Schema<AssociateDhcpOptionsResponse>;
export interface AssociateEnclaveCertificateIamRoleRequest {
  CertificateArn?: string;
  RoleArn?: string;
  DryRun?: boolean;
}
export const AssociateEnclaveCertificateIamRoleRequest = S.suspend(() =>
  S.Struct({
    CertificateArn: S.optional(S.String),
    RoleArn: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateEnclaveCertificateIamRoleRequest",
}) as any as S.Schema<AssociateEnclaveCertificateIamRoleRequest>;
export interface AssociateEnclaveCertificateIamRoleResult {
  CertificateS3BucketName?: string;
  CertificateS3ObjectKey?: string;
  EncryptionKmsKeyId?: string;
}
export const AssociateEnclaveCertificateIamRoleResult = S.suspend(() =>
  S.Struct({
    CertificateS3BucketName: S.optional(S.String).pipe(
      T.XmlName("certificateS3BucketName"),
      T.Ec2QueryName("CertificateS3BucketName"),
    ),
    CertificateS3ObjectKey: S.optional(S.String).pipe(
      T.XmlName("certificateS3ObjectKey"),
      T.Ec2QueryName("CertificateS3ObjectKey"),
    ),
    EncryptionKmsKeyId: S.optional(S.String).pipe(
      T.XmlName("encryptionKmsKeyId"),
      T.Ec2QueryName("EncryptionKmsKeyId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AssociateEnclaveCertificateIamRoleResult",
}) as any as S.Schema<AssociateEnclaveCertificateIamRoleResult>;
export interface IamInstanceProfileSpecification {
  Arn?: string;
  Name?: string;
}
export const IamInstanceProfileSpecification = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String).pipe(T.XmlName("arn"), T.Ec2QueryName("Arn")),
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
  }),
).annotate({
  identifier: "IamInstanceProfileSpecification",
}) as any as S.Schema<IamInstanceProfileSpecification>;
export interface AssociateIamInstanceProfileRequest {
  IamInstanceProfile?: IamInstanceProfileSpecification;
  InstanceId?: string;
}
export const AssociateIamInstanceProfileRequest = S.suspend(() =>
  S.Struct({
    IamInstanceProfile: S.optional(IamInstanceProfileSpecification),
    InstanceId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateIamInstanceProfileRequest",
}) as any as S.Schema<AssociateIamInstanceProfileRequest>;
export interface IamInstanceProfile {
  Arn?: string;
  Id?: string;
}
export const IamInstanceProfile = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String).pipe(T.XmlName("arn"), T.Ec2QueryName("Arn")),
    Id: S.optional(S.String).pipe(T.XmlName("id"), T.Ec2QueryName("Id")),
  }),
).annotate({
  identifier: "IamInstanceProfile",
}) as any as S.Schema<IamInstanceProfile>;
export type IamInstanceProfileAssociationState =
  | "associating"
  | "associated"
  | "disassociating"
  | "disassociated"
  | (string & {});
export const IamInstanceProfileAssociationState = S.String;
export interface IamInstanceProfileAssociation {
  AssociationId?: string;
  InstanceId?: string;
  IamInstanceProfile?: IamInstanceProfile;
  State?: IamInstanceProfileAssociationState;
  Timestamp?: Date;
}
export const IamInstanceProfileAssociation = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    IamInstanceProfile: S.optional(IamInstanceProfile)
      .pipe(
        T.XmlName("iamInstanceProfile"),
        T.Ec2QueryName("IamInstanceProfile"),
      )
      .annotate({ identifier: "IamInstanceProfile" }),
    State: S.optional(IamInstanceProfileAssociationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Timestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("timestamp"), T.Ec2QueryName("Timestamp")),
  }),
).annotate({
  identifier: "IamInstanceProfileAssociation",
}) as any as S.Schema<IamInstanceProfileAssociation>;
export interface AssociateIamInstanceProfileResult {
  IamInstanceProfileAssociation?: IamInstanceProfileAssociation;
}
export const AssociateIamInstanceProfileResult = S.suspend(() =>
  S.Struct({
    IamInstanceProfileAssociation: S.optional(IamInstanceProfileAssociation)
      .pipe(
        T.XmlName("iamInstanceProfileAssociation"),
        T.Ec2QueryName("IamInstanceProfileAssociation"),
      )
      .annotate({ identifier: "IamInstanceProfileAssociation" }),
  }).pipe(ns),
).annotate({
  identifier: "AssociateIamInstanceProfileResult",
}) as any as S.Schema<AssociateIamInstanceProfileResult>;
export type InstanceIdList = string[];
export const InstanceIdList = S.Array(S.String.pipe(T.XmlName("item")));
export type DedicatedHostIdList = string[];
export const DedicatedHostIdList = S.Array(S.String.pipe(T.XmlName("item")));
export interface InstanceEventWindowAssociationRequest {
  InstanceIds?: string[];
  InstanceTags?: Tag[];
  DedicatedHostIds?: string[];
}
export const InstanceEventWindowAssociationRequest = S.suspend(() =>
  S.Struct({
    InstanceIds: S.optional(InstanceIdList).pipe(T.XmlName("InstanceId")),
    InstanceTags: S.optional(TagList).pipe(T.XmlName("InstanceTag")),
    DedicatedHostIds: S.optional(DedicatedHostIdList).pipe(
      T.XmlName("DedicatedHostId"),
    ),
  }),
).annotate({
  identifier: "InstanceEventWindowAssociationRequest",
}) as any as S.Schema<InstanceEventWindowAssociationRequest>;
export interface AssociateInstanceEventWindowRequest {
  DryRun?: boolean;
  InstanceEventWindowId?: string;
  AssociationTarget?: InstanceEventWindowAssociationRequest;
}
export const AssociateInstanceEventWindowRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    InstanceEventWindowId: S.optional(S.String),
    AssociationTarget: S.optional(InstanceEventWindowAssociationRequest),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateInstanceEventWindowRequest",
}) as any as S.Schema<AssociateInstanceEventWindowRequest>;
export type WeekDay =
  | "sunday"
  | "monday"
  | "tuesday"
  | "wednesday"
  | "thursday"
  | "friday"
  | "saturday"
  | (string & {});
export const WeekDay = S.String;
export interface InstanceEventWindowTimeRange {
  StartWeekDay?: WeekDay;
  StartHour?: number;
  EndWeekDay?: WeekDay;
  EndHour?: number;
}
export const InstanceEventWindowTimeRange = S.suspend(() =>
  S.Struct({
    StartWeekDay: S.optional(WeekDay).pipe(
      T.XmlName("startWeekDay"),
      T.Ec2QueryName("StartWeekDay"),
    ),
    StartHour: S.optional(S.Number).pipe(
      T.XmlName("startHour"),
      T.Ec2QueryName("StartHour"),
    ),
    EndWeekDay: S.optional(WeekDay).pipe(
      T.XmlName("endWeekDay"),
      T.Ec2QueryName("EndWeekDay"),
    ),
    EndHour: S.optional(S.Number).pipe(
      T.XmlName("endHour"),
      T.Ec2QueryName("EndHour"),
    ),
  }),
).annotate({
  identifier: "InstanceEventWindowTimeRange",
}) as any as S.Schema<InstanceEventWindowTimeRange>;
export type InstanceEventWindowTimeRangeList = InstanceEventWindowTimeRange[];
export const InstanceEventWindowTimeRangeList = S.Array(
  InstanceEventWindowTimeRange.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceEventWindowTimeRange",
  }),
);
export interface InstanceEventWindowAssociationTarget {
  InstanceIds?: string[];
  Tags?: Tag[];
  DedicatedHostIds?: string[];
}
export const InstanceEventWindowAssociationTarget = S.suspend(() =>
  S.Struct({
    InstanceIds: S.optional(InstanceIdList).pipe(
      T.XmlName("instanceIdSet"),
      T.Ec2QueryName("InstanceIdSet"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    DedicatedHostIds: S.optional(DedicatedHostIdList).pipe(
      T.XmlName("dedicatedHostIdSet"),
      T.Ec2QueryName("DedicatedHostIdSet"),
    ),
  }),
).annotate({
  identifier: "InstanceEventWindowAssociationTarget",
}) as any as S.Schema<InstanceEventWindowAssociationTarget>;
export type InstanceEventWindowState =
  | "creating"
  | "deleting"
  | "active"
  | "deleted"
  | (string & {});
export const InstanceEventWindowState = S.String;
export interface InstanceEventWindow {
  InstanceEventWindowId?: string;
  TimeRanges?: InstanceEventWindowTimeRange[];
  Name?: string;
  CronExpression?: string;
  AssociationTarget?: InstanceEventWindowAssociationTarget;
  State?: InstanceEventWindowState;
  Tags?: Tag[];
}
export const InstanceEventWindow = S.suspend(() =>
  S.Struct({
    InstanceEventWindowId: S.optional(S.String).pipe(
      T.XmlName("instanceEventWindowId"),
      T.Ec2QueryName("InstanceEventWindowId"),
    ),
    TimeRanges: S.optional(InstanceEventWindowTimeRangeList).pipe(
      T.XmlName("timeRangeSet"),
      T.Ec2QueryName("TimeRangeSet"),
    ),
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
    CronExpression: S.optional(S.String).pipe(
      T.XmlName("cronExpression"),
      T.Ec2QueryName("CronExpression"),
    ),
    AssociationTarget: S.optional(InstanceEventWindowAssociationTarget)
      .pipe(T.XmlName("associationTarget"), T.Ec2QueryName("AssociationTarget"))
      .annotate({ identifier: "InstanceEventWindowAssociationTarget" }),
    State: S.optional(InstanceEventWindowState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "InstanceEventWindow",
}) as any as S.Schema<InstanceEventWindow>;
export interface AssociateInstanceEventWindowResult {
  InstanceEventWindow?: InstanceEventWindow;
}
export const AssociateInstanceEventWindowResult = S.suspend(() =>
  S.Struct({
    InstanceEventWindow: S.optional(InstanceEventWindow)
      .pipe(
        T.XmlName("instanceEventWindow"),
        T.Ec2QueryName("InstanceEventWindow"),
      )
      .annotate({ identifier: "InstanceEventWindow" }),
  }).pipe(ns),
).annotate({
  identifier: "AssociateInstanceEventWindowResult",
}) as any as S.Schema<AssociateInstanceEventWindowResult>;
export interface AssociateIpamByoasnRequest {
  DryRun?: boolean;
  Asn?: string;
  Cidr?: string;
}
export const AssociateIpamByoasnRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Asn: S.optional(S.String),
    Cidr: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateIpamByoasnRequest",
}) as any as S.Schema<AssociateIpamByoasnRequest>;
export interface AssociateIpamByoasnResult {
  AsnAssociation?: AsnAssociation;
}
export const AssociateIpamByoasnResult = S.suspend(() =>
  S.Struct({
    AsnAssociation: S.optional(AsnAssociation)
      .pipe(T.XmlName("asnAssociation"), T.Ec2QueryName("AsnAssociation"))
      .annotate({ identifier: "AsnAssociation" }),
  }).pipe(ns),
).annotate({
  identifier: "AssociateIpamByoasnResult",
}) as any as S.Schema<AssociateIpamByoasnResult>;
export interface AssociateIpamResourceDiscoveryRequest {
  DryRun?: boolean;
  IpamId?: string;
  IpamResourceDiscoveryId?: string;
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
}
export const AssociateIpamResourceDiscoveryRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamId: S.optional(S.String),
    IpamResourceDiscoveryId: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateIpamResourceDiscoveryRequest",
}) as any as S.Schema<AssociateIpamResourceDiscoveryRequest>;
export type IpamAssociatedResourceDiscoveryStatus =
  | "active"
  | "not-found"
  | (string & {});
export const IpamAssociatedResourceDiscoveryStatus = S.String;
export type IpamResourceDiscoveryAssociationState =
  | "associate-in-progress"
  | "associate-complete"
  | "associate-failed"
  | "disassociate-in-progress"
  | "disassociate-complete"
  | "disassociate-failed"
  | "isolate-in-progress"
  | "isolate-complete"
  | "restore-in-progress"
  | (string & {});
export const IpamResourceDiscoveryAssociationState = S.String;
export interface IpamResourceDiscoveryAssociation {
  OwnerId?: string;
  IpamResourceDiscoveryAssociationId?: string;
  IpamResourceDiscoveryAssociationArn?: string;
  IpamResourceDiscoveryId?: string;
  IpamId?: string;
  IpamArn?: string;
  IpamRegion?: string;
  IsDefault?: boolean;
  ResourceDiscoveryStatus?: IpamAssociatedResourceDiscoveryStatus;
  State?: IpamResourceDiscoveryAssociationState;
  Tags?: Tag[];
}
export const IpamResourceDiscoveryAssociation = S.suspend(() =>
  S.Struct({
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    IpamResourceDiscoveryAssociationId: S.optional(S.String).pipe(
      T.XmlName("ipamResourceDiscoveryAssociationId"),
      T.Ec2QueryName("IpamResourceDiscoveryAssociationId"),
    ),
    IpamResourceDiscoveryAssociationArn: S.optional(S.String).pipe(
      T.XmlName("ipamResourceDiscoveryAssociationArn"),
      T.Ec2QueryName("IpamResourceDiscoveryAssociationArn"),
    ),
    IpamResourceDiscoveryId: S.optional(S.String).pipe(
      T.XmlName("ipamResourceDiscoveryId"),
      T.Ec2QueryName("IpamResourceDiscoveryId"),
    ),
    IpamId: S.optional(S.String).pipe(
      T.XmlName("ipamId"),
      T.Ec2QueryName("IpamId"),
    ),
    IpamArn: S.optional(S.String).pipe(
      T.XmlName("ipamArn"),
      T.Ec2QueryName("IpamArn"),
    ),
    IpamRegion: S.optional(S.String).pipe(
      T.XmlName("ipamRegion"),
      T.Ec2QueryName("IpamRegion"),
    ),
    IsDefault: S.optional(S.Boolean).pipe(
      T.XmlName("isDefault"),
      T.Ec2QueryName("IsDefault"),
    ),
    ResourceDiscoveryStatus: S.optional(
      IpamAssociatedResourceDiscoveryStatus,
    ).pipe(
      T.XmlName("resourceDiscoveryStatus"),
      T.Ec2QueryName("ResourceDiscoveryStatus"),
    ),
    State: S.optional(IpamResourceDiscoveryAssociationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "IpamResourceDiscoveryAssociation",
}) as any as S.Schema<IpamResourceDiscoveryAssociation>;
export interface AssociateIpamResourceDiscoveryResult {
  IpamResourceDiscoveryAssociation?: IpamResourceDiscoveryAssociation;
}
export const AssociateIpamResourceDiscoveryResult = S.suspend(() =>
  S.Struct({
    IpamResourceDiscoveryAssociation: S.optional(
      IpamResourceDiscoveryAssociation,
    )
      .pipe(
        T.XmlName("ipamResourceDiscoveryAssociation"),
        T.Ec2QueryName("IpamResourceDiscoveryAssociation"),
      )
      .annotate({ identifier: "IpamResourceDiscoveryAssociation" }),
  }).pipe(ns),
).annotate({
  identifier: "AssociateIpamResourceDiscoveryResult",
}) as any as S.Schema<AssociateIpamResourceDiscoveryResult>;
export type AllocationIdList = string[];
export const AllocationIdList = S.Array(
  S.String.pipe(T.XmlName("AllocationId")),
);
export interface AssociateNatGatewayAddressRequest {
  NatGatewayId?: string;
  AllocationIds?: string[];
  PrivateIpAddresses?: string[];
  DryRun?: boolean;
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
}
export const AssociateNatGatewayAddressRequest = S.suspend(() =>
  S.Struct({
    NatGatewayId: S.optional(S.String),
    AllocationIds: S.optional(AllocationIdList).pipe(T.XmlName("AllocationId")),
    PrivateIpAddresses: S.optional(IpList).pipe(T.XmlName("PrivateIpAddress")),
    DryRun: S.optional(S.Boolean),
    AvailabilityZone: S.optional(S.String),
    AvailabilityZoneId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateNatGatewayAddressRequest",
}) as any as S.Schema<AssociateNatGatewayAddressRequest>;
export interface AssociateNatGatewayAddressResult {
  NatGatewayId?: string;
  NatGatewayAddresses?: NatGatewayAddress[];
}
export const AssociateNatGatewayAddressResult = S.suspend(() =>
  S.Struct({
    NatGatewayId: S.optional(S.String).pipe(
      T.XmlName("natGatewayId"),
      T.Ec2QueryName("NatGatewayId"),
    ),
    NatGatewayAddresses: S.optional(NatGatewayAddressList).pipe(
      T.XmlName("natGatewayAddressSet"),
      T.Ec2QueryName("NatGatewayAddressSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AssociateNatGatewayAddressResult",
}) as any as S.Schema<AssociateNatGatewayAddressResult>;
export interface AssociateRouteServerRequest {
  RouteServerId?: string;
  VpcId?: string;
  DryRun?: boolean;
}
export const AssociateRouteServerRequest = S.suspend(() =>
  S.Struct({
    RouteServerId: S.optional(S.String),
    VpcId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateRouteServerRequest",
}) as any as S.Schema<AssociateRouteServerRequest>;
export type RouteServerAssociationState =
  | "associating"
  | "associated"
  | "disassociating"
  | (string & {});
export const RouteServerAssociationState = S.String;
export interface RouteServerAssociation {
  RouteServerId?: string;
  VpcId?: string;
  State?: RouteServerAssociationState;
}
export const RouteServerAssociation = S.suspend(() =>
  S.Struct({
    RouteServerId: S.optional(S.String).pipe(
      T.XmlName("routeServerId"),
      T.Ec2QueryName("RouteServerId"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    State: S.optional(RouteServerAssociationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({
  identifier: "RouteServerAssociation",
}) as any as S.Schema<RouteServerAssociation>;
export interface AssociateRouteServerResult {
  RouteServerAssociation?: RouteServerAssociation;
}
export const AssociateRouteServerResult = S.suspend(() =>
  S.Struct({
    RouteServerAssociation: S.optional(RouteServerAssociation)
      .pipe(
        T.XmlName("routeServerAssociation"),
        T.Ec2QueryName("RouteServerAssociation"),
      )
      .annotate({ identifier: "RouteServerAssociation" }),
  }).pipe(ns),
).annotate({
  identifier: "AssociateRouteServerResult",
}) as any as S.Schema<AssociateRouteServerResult>;
export interface AssociateRouteTableRequest {
  GatewayId?: string;
  PublicIpv4Pool?: string;
  DryRun?: boolean;
  SubnetId?: string;
  RouteTableId?: string;
}
export const AssociateRouteTableRequest = S.suspend(() =>
  S.Struct({
    GatewayId: S.optional(S.String),
    PublicIpv4Pool: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    RouteTableId: S.optional(S.String).pipe(
      T.XmlName("routeTableId"),
      T.Ec2QueryName("RouteTableId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateRouteTableRequest",
}) as any as S.Schema<AssociateRouteTableRequest>;
export type RouteTableAssociationStateCode =
  | "associating"
  | "associated"
  | "disassociating"
  | "disassociated"
  | "failed"
  | (string & {});
export const RouteTableAssociationStateCode = S.String;
export interface RouteTableAssociationState {
  State?: RouteTableAssociationStateCode;
  StatusMessage?: string;
}
export const RouteTableAssociationState = S.suspend(() =>
  S.Struct({
    State: S.optional(RouteTableAssociationStateCode).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
  }),
).annotate({
  identifier: "RouteTableAssociationState",
}) as any as S.Schema<RouteTableAssociationState>;
export interface AssociateRouteTableResult {
  AssociationId?: string;
  AssociationState?: RouteTableAssociationState;
}
export const AssociateRouteTableResult = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
    AssociationState: S.optional(RouteTableAssociationState)
      .pipe(T.XmlName("associationState"), T.Ec2QueryName("AssociationState"))
      .annotate({ identifier: "RouteTableAssociationState" }),
  }).pipe(ns),
).annotate({
  identifier: "AssociateRouteTableResult",
}) as any as S.Schema<AssociateRouteTableResult>;
export interface AssociateSecurityGroupVpcRequest {
  GroupId?: string;
  VpcId?: string;
  DryRun?: boolean;
}
export const AssociateSecurityGroupVpcRequest = S.suspend(() =>
  S.Struct({
    GroupId: S.optional(S.String),
    VpcId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateSecurityGroupVpcRequest",
}) as any as S.Schema<AssociateSecurityGroupVpcRequest>;
export type SecurityGroupVpcAssociationState =
  | "associating"
  | "associated"
  | "association-failed"
  | "disassociating"
  | "disassociated"
  | "disassociation-failed"
  | (string & {});
export const SecurityGroupVpcAssociationState = S.String;
export interface AssociateSecurityGroupVpcResult {
  State?: SecurityGroupVpcAssociationState;
}
export const AssociateSecurityGroupVpcResult = S.suspend(() =>
  S.Struct({
    State: S.optional(SecurityGroupVpcAssociationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AssociateSecurityGroupVpcResult",
}) as any as S.Schema<AssociateSecurityGroupVpcResult>;
export interface AssociateSubnetCidrBlockRequest {
  Ipv6IpamPoolId?: string;
  Ipv6NetmaskLength?: number;
  SubnetId?: string;
  Ipv6CidrBlock?: string;
}
export const AssociateSubnetCidrBlockRequest = S.suspend(() =>
  S.Struct({
    Ipv6IpamPoolId: S.optional(S.String),
    Ipv6NetmaskLength: S.optional(S.Number),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    Ipv6CidrBlock: S.optional(S.String).pipe(
      T.XmlName("ipv6CidrBlock"),
      T.Ec2QueryName("Ipv6CidrBlock"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateSubnetCidrBlockRequest",
}) as any as S.Schema<AssociateSubnetCidrBlockRequest>;
export type SubnetCidrBlockStateCode =
  | "associating"
  | "associated"
  | "disassociating"
  | "disassociated"
  | "failing"
  | "failed"
  | (string & {});
export const SubnetCidrBlockStateCode = S.String;
export interface SubnetCidrBlockState {
  State?: SubnetCidrBlockStateCode;
  StatusMessage?: string;
}
export const SubnetCidrBlockState = S.suspend(() =>
  S.Struct({
    State: S.optional(SubnetCidrBlockStateCode).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
  }),
).annotate({
  identifier: "SubnetCidrBlockState",
}) as any as S.Schema<SubnetCidrBlockState>;
export type Ipv6AddressAttribute = "public" | "private" | (string & {});
export const Ipv6AddressAttribute = S.String;
export type IpSource = "amazon" | "byoip" | "none" | (string & {});
export const IpSource = S.String;
export interface SubnetIpv6CidrBlockAssociation {
  AssociationId?: string;
  Ipv6CidrBlock?: string;
  Ipv6CidrBlockState?: SubnetCidrBlockState;
  Ipv6AddressAttribute?: Ipv6AddressAttribute;
  IpSource?: IpSource;
}
export const SubnetIpv6CidrBlockAssociation = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
    Ipv6CidrBlock: S.optional(S.String).pipe(
      T.XmlName("ipv6CidrBlock"),
      T.Ec2QueryName("Ipv6CidrBlock"),
    ),
    Ipv6CidrBlockState: S.optional(SubnetCidrBlockState)
      .pipe(
        T.XmlName("ipv6CidrBlockState"),
        T.Ec2QueryName("Ipv6CidrBlockState"),
      )
      .annotate({ identifier: "SubnetCidrBlockState" }),
    Ipv6AddressAttribute: S.optional(Ipv6AddressAttribute).pipe(
      T.XmlName("ipv6AddressAttribute"),
      T.Ec2QueryName("Ipv6AddressAttribute"),
    ),
    IpSource: S.optional(IpSource).pipe(
      T.XmlName("ipSource"),
      T.Ec2QueryName("IpSource"),
    ),
  }),
).annotate({
  identifier: "SubnetIpv6CidrBlockAssociation",
}) as any as S.Schema<SubnetIpv6CidrBlockAssociation>;
export interface AssociateSubnetCidrBlockResult {
  Ipv6CidrBlockAssociation?: SubnetIpv6CidrBlockAssociation;
  SubnetId?: string;
}
export const AssociateSubnetCidrBlockResult = S.suspend(() =>
  S.Struct({
    Ipv6CidrBlockAssociation: S.optional(SubnetIpv6CidrBlockAssociation)
      .pipe(
        T.XmlName("ipv6CidrBlockAssociation"),
        T.Ec2QueryName("Ipv6CidrBlockAssociation"),
      )
      .annotate({ identifier: "SubnetIpv6CidrBlockAssociation" }),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AssociateSubnetCidrBlockResult",
}) as any as S.Schema<AssociateSubnetCidrBlockResult>;
export type TransitGatewaySubnetIdList = string[];
export const TransitGatewaySubnetIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface AssociateTransitGatewayMulticastDomainRequest {
  TransitGatewayMulticastDomainId?: string;
  TransitGatewayAttachmentId?: string;
  SubnetIds?: string[];
  DryRun?: boolean;
}
export const AssociateTransitGatewayMulticastDomainRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayMulticastDomainId: S.optional(S.String),
    TransitGatewayAttachmentId: S.optional(S.String),
    SubnetIds: S.optional(TransitGatewaySubnetIdList),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateTransitGatewayMulticastDomainRequest",
}) as any as S.Schema<AssociateTransitGatewayMulticastDomainRequest>;
export interface AssociateTransitGatewayMulticastDomainResult {
  Associations?: TransitGatewayMulticastDomainAssociations;
}
export const AssociateTransitGatewayMulticastDomainResult = S.suspend(() =>
  S.Struct({
    Associations: S.optional(TransitGatewayMulticastDomainAssociations)
      .pipe(T.XmlName("associations"), T.Ec2QueryName("Associations"))
      .annotate({ identifier: "TransitGatewayMulticastDomainAssociations" }),
  }).pipe(ns),
).annotate({
  identifier: "AssociateTransitGatewayMulticastDomainResult",
}) as any as S.Schema<AssociateTransitGatewayMulticastDomainResult>;
export interface AssociateTransitGatewayPolicyTableRequest {
  TransitGatewayPolicyTableId?: string;
  TransitGatewayAttachmentId?: string;
  DryRun?: boolean;
}
export const AssociateTransitGatewayPolicyTableRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayPolicyTableId: S.optional(S.String),
    TransitGatewayAttachmentId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateTransitGatewayPolicyTableRequest",
}) as any as S.Schema<AssociateTransitGatewayPolicyTableRequest>;
export type TransitGatewayAssociationState =
  | "associating"
  | "associated"
  | "disassociating"
  | "disassociated"
  | (string & {});
export const TransitGatewayAssociationState = S.String;
export interface TransitGatewayPolicyTableAssociation {
  TransitGatewayPolicyTableId?: string;
  TransitGatewayAttachmentId?: string;
  ResourceId?: string;
  ResourceType?: TransitGatewayAttachmentResourceType;
  State?: TransitGatewayAssociationState;
}
export const TransitGatewayPolicyTableAssociation = S.suspend(() =>
  S.Struct({
    TransitGatewayPolicyTableId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayPolicyTableId"),
      T.Ec2QueryName("TransitGatewayPolicyTableId"),
    ),
    TransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayAttachmentId"),
      T.Ec2QueryName("TransitGatewayAttachmentId"),
    ),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    ResourceType: S.optional(TransitGatewayAttachmentResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    State: S.optional(TransitGatewayAssociationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayPolicyTableAssociation",
}) as any as S.Schema<TransitGatewayPolicyTableAssociation>;
export interface AssociateTransitGatewayPolicyTableResult {
  Association?: TransitGatewayPolicyTableAssociation;
}
export const AssociateTransitGatewayPolicyTableResult = S.suspend(() =>
  S.Struct({
    Association: S.optional(TransitGatewayPolicyTableAssociation)
      .pipe(T.XmlName("association"), T.Ec2QueryName("Association"))
      .annotate({ identifier: "TransitGatewayPolicyTableAssociation" }),
  }).pipe(ns),
).annotate({
  identifier: "AssociateTransitGatewayPolicyTableResult",
}) as any as S.Schema<AssociateTransitGatewayPolicyTableResult>;
export interface AssociateTransitGatewayRouteTableRequest {
  TransitGatewayRouteTableId?: string;
  TransitGatewayAttachmentId?: string;
  DryRun?: boolean;
}
export const AssociateTransitGatewayRouteTableRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String),
    TransitGatewayAttachmentId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateTransitGatewayRouteTableRequest",
}) as any as S.Schema<AssociateTransitGatewayRouteTableRequest>;
export interface TransitGatewayAssociation {
  TransitGatewayRouteTableId?: string;
  TransitGatewayAttachmentId?: string;
  ResourceId?: string;
  ResourceType?: TransitGatewayAttachmentResourceType;
  State?: TransitGatewayAssociationState;
}
export const TransitGatewayAssociation = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayRouteTableId"),
      T.Ec2QueryName("TransitGatewayRouteTableId"),
    ),
    TransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayAttachmentId"),
      T.Ec2QueryName("TransitGatewayAttachmentId"),
    ),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    ResourceType: S.optional(TransitGatewayAttachmentResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    State: S.optional(TransitGatewayAssociationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayAssociation",
}) as any as S.Schema<TransitGatewayAssociation>;
export interface AssociateTransitGatewayRouteTableResult {
  Association?: TransitGatewayAssociation;
}
export const AssociateTransitGatewayRouteTableResult = S.suspend(() =>
  S.Struct({
    Association: S.optional(TransitGatewayAssociation)
      .pipe(T.XmlName("association"), T.Ec2QueryName("Association"))
      .annotate({ identifier: "TransitGatewayAssociation" }),
  }).pipe(ns),
).annotate({
  identifier: "AssociateTransitGatewayRouteTableResult",
}) as any as S.Schema<AssociateTransitGatewayRouteTableResult>;
export interface AssociateTrunkInterfaceRequest {
  BranchInterfaceId?: string;
  TrunkInterfaceId?: string;
  VlanId?: number;
  GreKey?: number;
  ClientToken?: string;
  DryRun?: boolean;
}
export const AssociateTrunkInterfaceRequest = S.suspend(() =>
  S.Struct({
    BranchInterfaceId: S.optional(S.String),
    TrunkInterfaceId: S.optional(S.String),
    VlanId: S.optional(S.Number),
    GreKey: S.optional(S.Number),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateTrunkInterfaceRequest",
}) as any as S.Schema<AssociateTrunkInterfaceRequest>;
export type InterfaceProtocolType = "VLAN" | "GRE" | (string & {});
export const InterfaceProtocolType = S.String;
export interface TrunkInterfaceAssociation {
  AssociationId?: string;
  BranchInterfaceId?: string;
  TrunkInterfaceId?: string;
  InterfaceProtocol?: InterfaceProtocolType;
  VlanId?: number;
  GreKey?: number;
  Tags?: Tag[];
}
export const TrunkInterfaceAssociation = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
    BranchInterfaceId: S.optional(S.String).pipe(
      T.XmlName("branchInterfaceId"),
      T.Ec2QueryName("BranchInterfaceId"),
    ),
    TrunkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("trunkInterfaceId"),
      T.Ec2QueryName("TrunkInterfaceId"),
    ),
    InterfaceProtocol: S.optional(InterfaceProtocolType).pipe(
      T.XmlName("interfaceProtocol"),
      T.Ec2QueryName("InterfaceProtocol"),
    ),
    VlanId: S.optional(S.Number).pipe(
      T.XmlName("vlanId"),
      T.Ec2QueryName("VlanId"),
    ),
    GreKey: S.optional(S.Number).pipe(
      T.XmlName("greKey"),
      T.Ec2QueryName("GreKey"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "TrunkInterfaceAssociation",
}) as any as S.Schema<TrunkInterfaceAssociation>;
export interface AssociateTrunkInterfaceResult {
  InterfaceAssociation?: TrunkInterfaceAssociation;
  ClientToken?: string;
}
export const AssociateTrunkInterfaceResult = S.suspend(() =>
  S.Struct({
    InterfaceAssociation: S.optional(TrunkInterfaceAssociation)
      .pipe(
        T.XmlName("interfaceAssociation"),
        T.Ec2QueryName("InterfaceAssociation"),
      )
      .annotate({ identifier: "TrunkInterfaceAssociation" }),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AssociateTrunkInterfaceResult",
}) as any as S.Schema<AssociateTrunkInterfaceResult>;
export interface AssociateVpcCidrBlockRequest {
  CidrBlock?: string;
  Ipv6CidrBlockNetworkBorderGroup?: string;
  Ipv6Pool?: string;
  Ipv6CidrBlock?: string;
  Ipv4IpamPoolId?: string;
  Ipv4NetmaskLength?: number;
  Ipv6IpamPoolId?: string;
  Ipv6NetmaskLength?: number;
  VpcId?: string;
  AmazonProvidedIpv6CidrBlock?: boolean;
}
export const AssociateVpcCidrBlockRequest = S.suspend(() =>
  S.Struct({
    CidrBlock: S.optional(S.String),
    Ipv6CidrBlockNetworkBorderGroup: S.optional(S.String),
    Ipv6Pool: S.optional(S.String),
    Ipv6CidrBlock: S.optional(S.String),
    Ipv4IpamPoolId: S.optional(S.String),
    Ipv4NetmaskLength: S.optional(S.Number),
    Ipv6IpamPoolId: S.optional(S.String),
    Ipv6NetmaskLength: S.optional(S.Number),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    AmazonProvidedIpv6CidrBlock: S.optional(S.Boolean).pipe(
      T.XmlName("amazonProvidedIpv6CidrBlock"),
      T.Ec2QueryName("AmazonProvidedIpv6CidrBlock"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateVpcCidrBlockRequest",
}) as any as S.Schema<AssociateVpcCidrBlockRequest>;
export type VpcCidrBlockStateCode =
  | "associating"
  | "associated"
  | "disassociating"
  | "disassociated"
  | "failing"
  | "failed"
  | (string & {});
export const VpcCidrBlockStateCode = S.String;
export interface VpcCidrBlockState {
  State?: VpcCidrBlockStateCode;
  StatusMessage?: string;
}
export const VpcCidrBlockState = S.suspend(() =>
  S.Struct({
    State: S.optional(VpcCidrBlockStateCode).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
  }),
).annotate({
  identifier: "VpcCidrBlockState",
}) as any as S.Schema<VpcCidrBlockState>;
export interface VpcIpv6CidrBlockAssociation {
  AssociationId?: string;
  Ipv6CidrBlock?: string;
  Ipv6CidrBlockState?: VpcCidrBlockState;
  NetworkBorderGroup?: string;
  Ipv6Pool?: string;
  Ipv6AddressAttribute?: Ipv6AddressAttribute;
  IpSource?: IpSource;
}
export const VpcIpv6CidrBlockAssociation = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
    Ipv6CidrBlock: S.optional(S.String).pipe(
      T.XmlName("ipv6CidrBlock"),
      T.Ec2QueryName("Ipv6CidrBlock"),
    ),
    Ipv6CidrBlockState: S.optional(VpcCidrBlockState)
      .pipe(
        T.XmlName("ipv6CidrBlockState"),
        T.Ec2QueryName("Ipv6CidrBlockState"),
      )
      .annotate({ identifier: "VpcCidrBlockState" }),
    NetworkBorderGroup: S.optional(S.String).pipe(
      T.XmlName("networkBorderGroup"),
      T.Ec2QueryName("NetworkBorderGroup"),
    ),
    Ipv6Pool: S.optional(S.String).pipe(
      T.XmlName("ipv6Pool"),
      T.Ec2QueryName("Ipv6Pool"),
    ),
    Ipv6AddressAttribute: S.optional(Ipv6AddressAttribute).pipe(
      T.XmlName("ipv6AddressAttribute"),
      T.Ec2QueryName("Ipv6AddressAttribute"),
    ),
    IpSource: S.optional(IpSource).pipe(
      T.XmlName("ipSource"),
      T.Ec2QueryName("IpSource"),
    ),
  }),
).annotate({
  identifier: "VpcIpv6CidrBlockAssociation",
}) as any as S.Schema<VpcIpv6CidrBlockAssociation>;
export interface VpcCidrBlockAssociation {
  AssociationId?: string;
  CidrBlock?: string;
  CidrBlockState?: VpcCidrBlockState;
}
export const VpcCidrBlockAssociation = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
    CidrBlock: S.optional(S.String).pipe(
      T.XmlName("cidrBlock"),
      T.Ec2QueryName("CidrBlock"),
    ),
    CidrBlockState: S.optional(VpcCidrBlockState)
      .pipe(T.XmlName("cidrBlockState"), T.Ec2QueryName("CidrBlockState"))
      .annotate({ identifier: "VpcCidrBlockState" }),
  }),
).annotate({
  identifier: "VpcCidrBlockAssociation",
}) as any as S.Schema<VpcCidrBlockAssociation>;
export interface AssociateVpcCidrBlockResult {
  Ipv6CidrBlockAssociation?: VpcIpv6CidrBlockAssociation;
  CidrBlockAssociation?: VpcCidrBlockAssociation;
  VpcId?: string;
}
export const AssociateVpcCidrBlockResult = S.suspend(() =>
  S.Struct({
    Ipv6CidrBlockAssociation: S.optional(VpcIpv6CidrBlockAssociation)
      .pipe(
        T.XmlName("ipv6CidrBlockAssociation"),
        T.Ec2QueryName("Ipv6CidrBlockAssociation"),
      )
      .annotate({ identifier: "VpcIpv6CidrBlockAssociation" }),
    CidrBlockAssociation: S.optional(VpcCidrBlockAssociation)
      .pipe(
        T.XmlName("cidrBlockAssociation"),
        T.Ec2QueryName("CidrBlockAssociation"),
      )
      .annotate({ identifier: "VpcCidrBlockAssociation" }),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AssociateVpcCidrBlockResult",
}) as any as S.Schema<AssociateVpcCidrBlockResult>;
export type GroupIdStringList = string[];
export const GroupIdStringList = S.Array(S.String.pipe(T.XmlName("groupId")));
export interface AttachClassicLinkVpcRequest {
  DryRun?: boolean;
  InstanceId?: string;
  VpcId?: string;
  Groups?: string[];
}
export const AttachClassicLinkVpcRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    Groups: S.optional(GroupIdStringList).pipe(T.XmlName("SecurityGroupId")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AttachClassicLinkVpcRequest",
}) as any as S.Schema<AttachClassicLinkVpcRequest>;
export interface AttachClassicLinkVpcResult {
  Return?: boolean;
}
export const AttachClassicLinkVpcResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AttachClassicLinkVpcResult",
}) as any as S.Schema<AttachClassicLinkVpcResult>;
export interface AttachInternetGatewayRequest {
  DryRun?: boolean;
  InternetGatewayId?: string;
  VpcId?: string;
}
export const AttachInternetGatewayRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    InternetGatewayId: S.optional(S.String).pipe(
      T.XmlName("internetGatewayId"),
      T.Ec2QueryName("InternetGatewayId"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AttachInternetGatewayRequest",
}) as any as S.Schema<AttachInternetGatewayRequest>;
export interface AttachInternetGatewayResponse {}
export const AttachInternetGatewayResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "AttachInternetGatewayResponse",
}) as any as S.Schema<AttachInternetGatewayResponse>;
export interface EnaSrdUdpSpecification {
  EnaSrdUdpEnabled?: boolean;
}
export const EnaSrdUdpSpecification = S.suspend(() =>
  S.Struct({ EnaSrdUdpEnabled: S.optional(S.Boolean) }),
).annotate({
  identifier: "EnaSrdUdpSpecification",
}) as any as S.Schema<EnaSrdUdpSpecification>;
export interface EnaSrdSpecification {
  EnaSrdEnabled?: boolean;
  EnaSrdUdpSpecification?: EnaSrdUdpSpecification;
}
export const EnaSrdSpecification = S.suspend(() =>
  S.Struct({
    EnaSrdEnabled: S.optional(S.Boolean),
    EnaSrdUdpSpecification: S.optional(EnaSrdUdpSpecification),
  }),
).annotate({
  identifier: "EnaSrdSpecification",
}) as any as S.Schema<EnaSrdSpecification>;
export interface AttachNetworkInterfaceRequest {
  NetworkCardIndex?: number;
  EnaSrdSpecification?: EnaSrdSpecification;
  EnaQueueCount?: number;
  DryRun?: boolean;
  NetworkInterfaceId?: string;
  InstanceId?: string;
  DeviceIndex?: number;
}
export const AttachNetworkInterfaceRequest = S.suspend(() =>
  S.Struct({
    NetworkCardIndex: S.optional(S.Number),
    EnaSrdSpecification: S.optional(EnaSrdSpecification),
    EnaQueueCount: S.optional(S.Number),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    DeviceIndex: S.optional(S.Number).pipe(
      T.XmlName("deviceIndex"),
      T.Ec2QueryName("DeviceIndex"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AttachNetworkInterfaceRequest",
}) as any as S.Schema<AttachNetworkInterfaceRequest>;
export interface AttachNetworkInterfaceResult {
  AttachmentId?: string;
  NetworkCardIndex?: number;
}
export const AttachNetworkInterfaceResult = S.suspend(() =>
  S.Struct({
    AttachmentId: S.optional(S.String).pipe(
      T.XmlName("attachmentId"),
      T.Ec2QueryName("AttachmentId"),
    ),
    NetworkCardIndex: S.optional(S.Number).pipe(
      T.XmlName("networkCardIndex"),
      T.Ec2QueryName("NetworkCardIndex"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AttachNetworkInterfaceResult",
}) as any as S.Schema<AttachNetworkInterfaceResult>;
export interface AttachVerifiedAccessTrustProviderRequest {
  VerifiedAccessInstanceId?: string;
  VerifiedAccessTrustProviderId?: string;
  ClientToken?: string;
  DryRun?: boolean;
}
export const AttachVerifiedAccessTrustProviderRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessInstanceId: S.optional(S.String),
    VerifiedAccessTrustProviderId: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AttachVerifiedAccessTrustProviderRequest",
}) as any as S.Schema<AttachVerifiedAccessTrustProviderRequest>;
export type TrustProviderType = "user" | "device" | (string & {});
export const TrustProviderType = S.String;
export type UserTrustProviderType =
  | "iam-identity-center"
  | "oidc"
  | (string & {});
export const UserTrustProviderType = S.String;
export type DeviceTrustProviderType =
  | "jamf"
  | "crowdstrike"
  | "jumpcloud"
  | (string & {});
export const DeviceTrustProviderType = S.String;
export interface OidcOptions {
  Issuer?: string;
  AuthorizationEndpoint?: string;
  TokenEndpoint?: string;
  UserInfoEndpoint?: string;
  ClientId?: string;
  ClientSecret?: string | redacted.Redacted<string>;
  Scope?: string;
}
export const OidcOptions = S.suspend(() =>
  S.Struct({
    Issuer: S.optional(S.String).pipe(
      T.XmlName("issuer"),
      T.Ec2QueryName("Issuer"),
    ),
    AuthorizationEndpoint: S.optional(S.String).pipe(
      T.XmlName("authorizationEndpoint"),
      T.Ec2QueryName("AuthorizationEndpoint"),
    ),
    TokenEndpoint: S.optional(S.String).pipe(
      T.XmlName("tokenEndpoint"),
      T.Ec2QueryName("TokenEndpoint"),
    ),
    UserInfoEndpoint: S.optional(S.String).pipe(
      T.XmlName("userInfoEndpoint"),
      T.Ec2QueryName("UserInfoEndpoint"),
    ),
    ClientId: S.optional(S.String).pipe(
      T.XmlName("clientId"),
      T.Ec2QueryName("ClientId"),
    ),
    ClientSecret: S.optional(SensitiveString).pipe(
      T.XmlName("clientSecret"),
      T.Ec2QueryName("ClientSecret"),
    ),
    Scope: S.optional(S.String).pipe(
      T.XmlName("scope"),
      T.Ec2QueryName("Scope"),
    ),
  }),
).annotate({ identifier: "OidcOptions" }) as any as S.Schema<OidcOptions>;
export interface DeviceOptions {
  TenantId?: string;
  PublicSigningKeyUrl?: string;
}
export const DeviceOptions = S.suspend(() =>
  S.Struct({
    TenantId: S.optional(S.String).pipe(
      T.XmlName("tenantId"),
      T.Ec2QueryName("TenantId"),
    ),
    PublicSigningKeyUrl: S.optional(S.String).pipe(
      T.XmlName("publicSigningKeyUrl"),
      T.Ec2QueryName("PublicSigningKeyUrl"),
    ),
  }),
).annotate({ identifier: "DeviceOptions" }) as any as S.Schema<DeviceOptions>;
export interface VerifiedAccessSseSpecificationResponse {
  CustomerManagedKeyEnabled?: boolean;
  KmsKeyArn?: string;
}
export const VerifiedAccessSseSpecificationResponse = S.suspend(() =>
  S.Struct({
    CustomerManagedKeyEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("customerManagedKeyEnabled"),
      T.Ec2QueryName("CustomerManagedKeyEnabled"),
    ),
    KmsKeyArn: S.optional(S.String).pipe(
      T.XmlName("kmsKeyArn"),
      T.Ec2QueryName("KmsKeyArn"),
    ),
  }),
).annotate({
  identifier: "VerifiedAccessSseSpecificationResponse",
}) as any as S.Schema<VerifiedAccessSseSpecificationResponse>;
export interface NativeApplicationOidcOptions {
  PublicSigningKeyEndpoint?: string;
  Issuer?: string;
  AuthorizationEndpoint?: string;
  TokenEndpoint?: string;
  UserInfoEndpoint?: string;
  ClientId?: string;
  Scope?: string;
}
export const NativeApplicationOidcOptions = S.suspend(() =>
  S.Struct({
    PublicSigningKeyEndpoint: S.optional(S.String).pipe(
      T.XmlName("publicSigningKeyEndpoint"),
      T.Ec2QueryName("PublicSigningKeyEndpoint"),
    ),
    Issuer: S.optional(S.String).pipe(
      T.XmlName("issuer"),
      T.Ec2QueryName("Issuer"),
    ),
    AuthorizationEndpoint: S.optional(S.String).pipe(
      T.XmlName("authorizationEndpoint"),
      T.Ec2QueryName("AuthorizationEndpoint"),
    ),
    TokenEndpoint: S.optional(S.String).pipe(
      T.XmlName("tokenEndpoint"),
      T.Ec2QueryName("TokenEndpoint"),
    ),
    UserInfoEndpoint: S.optional(S.String).pipe(
      T.XmlName("userInfoEndpoint"),
      T.Ec2QueryName("UserInfoEndpoint"),
    ),
    ClientId: S.optional(S.String).pipe(
      T.XmlName("clientId"),
      T.Ec2QueryName("ClientId"),
    ),
    Scope: S.optional(S.String).pipe(
      T.XmlName("scope"),
      T.Ec2QueryName("Scope"),
    ),
  }),
).annotate({
  identifier: "NativeApplicationOidcOptions",
}) as any as S.Schema<NativeApplicationOidcOptions>;
export interface VerifiedAccessTrustProvider {
  VerifiedAccessTrustProviderId?: string;
  Description?: string;
  TrustProviderType?: TrustProviderType;
  UserTrustProviderType?: UserTrustProviderType;
  DeviceTrustProviderType?: DeviceTrustProviderType;
  OidcOptions?: OidcOptions;
  DeviceOptions?: DeviceOptions;
  PolicyReferenceName?: string;
  CreationTime?: string;
  LastUpdatedTime?: string;
  Tags?: Tag[];
  SseSpecification?: VerifiedAccessSseSpecificationResponse;
  NativeApplicationOidcOptions?: NativeApplicationOidcOptions;
}
export const VerifiedAccessTrustProvider = S.suspend(() =>
  S.Struct({
    VerifiedAccessTrustProviderId: S.optional(S.String).pipe(
      T.XmlName("verifiedAccessTrustProviderId"),
      T.Ec2QueryName("VerifiedAccessTrustProviderId"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    TrustProviderType: S.optional(TrustProviderType).pipe(
      T.XmlName("trustProviderType"),
      T.Ec2QueryName("TrustProviderType"),
    ),
    UserTrustProviderType: S.optional(UserTrustProviderType).pipe(
      T.XmlName("userTrustProviderType"),
      T.Ec2QueryName("UserTrustProviderType"),
    ),
    DeviceTrustProviderType: S.optional(DeviceTrustProviderType).pipe(
      T.XmlName("deviceTrustProviderType"),
      T.Ec2QueryName("DeviceTrustProviderType"),
    ),
    OidcOptions: S.optional(OidcOptions)
      .pipe(T.XmlName("oidcOptions"), T.Ec2QueryName("OidcOptions"))
      .annotate({ identifier: "OidcOptions" }),
    DeviceOptions: S.optional(DeviceOptions)
      .pipe(T.XmlName("deviceOptions"), T.Ec2QueryName("DeviceOptions"))
      .annotate({ identifier: "DeviceOptions" }),
    PolicyReferenceName: S.optional(S.String).pipe(
      T.XmlName("policyReferenceName"),
      T.Ec2QueryName("PolicyReferenceName"),
    ),
    CreationTime: S.optional(S.String).pipe(
      T.XmlName("creationTime"),
      T.Ec2QueryName("CreationTime"),
    ),
    LastUpdatedTime: S.optional(S.String).pipe(
      T.XmlName("lastUpdatedTime"),
      T.Ec2QueryName("LastUpdatedTime"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    SseSpecification: S.optional(VerifiedAccessSseSpecificationResponse)
      .pipe(T.XmlName("sseSpecification"), T.Ec2QueryName("SseSpecification"))
      .annotate({ identifier: "VerifiedAccessSseSpecificationResponse" }),
    NativeApplicationOidcOptions: S.optional(NativeApplicationOidcOptions)
      .pipe(
        T.XmlName("nativeApplicationOidcOptions"),
        T.Ec2QueryName("NativeApplicationOidcOptions"),
      )
      .annotate({ identifier: "NativeApplicationOidcOptions" }),
  }),
).annotate({
  identifier: "VerifiedAccessTrustProvider",
}) as any as S.Schema<VerifiedAccessTrustProvider>;
export interface VerifiedAccessTrustProviderCondensed {
  VerifiedAccessTrustProviderId?: string;
  Description?: string;
  TrustProviderType?: TrustProviderType;
  UserTrustProviderType?: UserTrustProviderType;
  DeviceTrustProviderType?: DeviceTrustProviderType;
}
export const VerifiedAccessTrustProviderCondensed = S.suspend(() =>
  S.Struct({
    VerifiedAccessTrustProviderId: S.optional(S.String).pipe(
      T.XmlName("verifiedAccessTrustProviderId"),
      T.Ec2QueryName("VerifiedAccessTrustProviderId"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    TrustProviderType: S.optional(TrustProviderType).pipe(
      T.XmlName("trustProviderType"),
      T.Ec2QueryName("TrustProviderType"),
    ),
    UserTrustProviderType: S.optional(UserTrustProviderType).pipe(
      T.XmlName("userTrustProviderType"),
      T.Ec2QueryName("UserTrustProviderType"),
    ),
    DeviceTrustProviderType: S.optional(DeviceTrustProviderType).pipe(
      T.XmlName("deviceTrustProviderType"),
      T.Ec2QueryName("DeviceTrustProviderType"),
    ),
  }),
).annotate({
  identifier: "VerifiedAccessTrustProviderCondensed",
}) as any as S.Schema<VerifiedAccessTrustProviderCondensed>;
export type VerifiedAccessTrustProviderCondensedList =
  VerifiedAccessTrustProviderCondensed[];
export const VerifiedAccessTrustProviderCondensedList = S.Array(
  VerifiedAccessTrustProviderCondensed.pipe(T.XmlName("item")).annotate({
    identifier: "VerifiedAccessTrustProviderCondensed",
  }),
);
export interface VerifiedAccessInstanceCustomSubDomain {
  SubDomain?: string;
  Nameservers?: string[];
}
export const VerifiedAccessInstanceCustomSubDomain = S.suspend(() =>
  S.Struct({
    SubDomain: S.optional(S.String).pipe(
      T.XmlName("subDomain"),
      T.Ec2QueryName("SubDomain"),
    ),
    Nameservers: S.optional(ValueStringList).pipe(
      T.XmlName("nameserverSet"),
      T.Ec2QueryName("NameserverSet"),
    ),
  }),
).annotate({
  identifier: "VerifiedAccessInstanceCustomSubDomain",
}) as any as S.Schema<VerifiedAccessInstanceCustomSubDomain>;
export interface VerifiedAccessInstance {
  VerifiedAccessInstanceId?: string;
  Description?: string;
  VerifiedAccessTrustProviders?: VerifiedAccessTrustProviderCondensed[];
  CreationTime?: string;
  LastUpdatedTime?: string;
  Tags?: Tag[];
  FipsEnabled?: boolean;
  CidrEndpointsCustomSubDomain?: VerifiedAccessInstanceCustomSubDomain;
}
export const VerifiedAccessInstance = S.suspend(() =>
  S.Struct({
    VerifiedAccessInstanceId: S.optional(S.String).pipe(
      T.XmlName("verifiedAccessInstanceId"),
      T.Ec2QueryName("VerifiedAccessInstanceId"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    VerifiedAccessTrustProviders: S.optional(
      VerifiedAccessTrustProviderCondensedList,
    ).pipe(
      T.XmlName("verifiedAccessTrustProviderSet"),
      T.Ec2QueryName("VerifiedAccessTrustProviderSet"),
    ),
    CreationTime: S.optional(S.String).pipe(
      T.XmlName("creationTime"),
      T.Ec2QueryName("CreationTime"),
    ),
    LastUpdatedTime: S.optional(S.String).pipe(
      T.XmlName("lastUpdatedTime"),
      T.Ec2QueryName("LastUpdatedTime"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    FipsEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("fipsEnabled"),
      T.Ec2QueryName("FipsEnabled"),
    ),
    CidrEndpointsCustomSubDomain: S.optional(
      VerifiedAccessInstanceCustomSubDomain,
    )
      .pipe(
        T.XmlName("cidrEndpointsCustomSubDomain"),
        T.Ec2QueryName("CidrEndpointsCustomSubDomain"),
      )
      .annotate({ identifier: "VerifiedAccessInstanceCustomSubDomain" }),
  }),
).annotate({
  identifier: "VerifiedAccessInstance",
}) as any as S.Schema<VerifiedAccessInstance>;
export interface AttachVerifiedAccessTrustProviderResult {
  VerifiedAccessTrustProvider?: VerifiedAccessTrustProvider;
  VerifiedAccessInstance?: VerifiedAccessInstance;
}
export const AttachVerifiedAccessTrustProviderResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessTrustProvider: S.optional(VerifiedAccessTrustProvider)
      .pipe(
        T.XmlName("verifiedAccessTrustProvider"),
        T.Ec2QueryName("VerifiedAccessTrustProvider"),
      )
      .annotate({ identifier: "VerifiedAccessTrustProvider" }),
    VerifiedAccessInstance: S.optional(VerifiedAccessInstance)
      .pipe(
        T.XmlName("verifiedAccessInstance"),
        T.Ec2QueryName("VerifiedAccessInstance"),
      )
      .annotate({ identifier: "VerifiedAccessInstance" }),
  }).pipe(ns),
).annotate({
  identifier: "AttachVerifiedAccessTrustProviderResult",
}) as any as S.Schema<AttachVerifiedAccessTrustProviderResult>;
export interface AttachVolumeRequest {
  Device?: string;
  InstanceId?: string;
  VolumeId?: string;
  EbsCardIndex?: number;
  DryRun?: boolean;
}
export const AttachVolumeRequest = S.suspend(() =>
  S.Struct({
    Device: S.optional(S.String),
    InstanceId: S.optional(S.String),
    VolumeId: S.optional(S.String),
    EbsCardIndex: S.optional(S.Number),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AttachVolumeRequest",
}) as any as S.Schema<AttachVolumeRequest>;
export type VolumeAttachmentState =
  | "attaching"
  | "attached"
  | "detaching"
  | "detached"
  | "busy"
  | (string & {});
export const VolumeAttachmentState = S.String;
export interface VolumeAttachment {
  DeleteOnTermination?: boolean;
  AssociatedResource?: string;
  InstanceOwningService?: string;
  EbsCardIndex?: number;
  VolumeId?: string;
  InstanceId?: string;
  Device?: string;
  State?: VolumeAttachmentState;
  AttachTime?: Date;
}
export const VolumeAttachment = S.suspend(() =>
  S.Struct({
    DeleteOnTermination: S.optional(S.Boolean).pipe(
      T.XmlName("deleteOnTermination"),
      T.Ec2QueryName("DeleteOnTermination"),
    ),
    AssociatedResource: S.optional(S.String).pipe(
      T.XmlName("associatedResource"),
      T.Ec2QueryName("AssociatedResource"),
    ),
    InstanceOwningService: S.optional(S.String).pipe(
      T.XmlName("instanceOwningService"),
      T.Ec2QueryName("InstanceOwningService"),
    ),
    EbsCardIndex: S.optional(S.Number).pipe(
      T.XmlName("ebsCardIndex"),
      T.Ec2QueryName("EbsCardIndex"),
    ),
    VolumeId: S.optional(S.String).pipe(
      T.XmlName("volumeId"),
      T.Ec2QueryName("VolumeId"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    Device: S.optional(S.String).pipe(
      T.XmlName("device"),
      T.Ec2QueryName("Device"),
    ),
    State: S.optional(VolumeAttachmentState).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    AttachTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("attachTime"), T.Ec2QueryName("AttachTime")),
  }).pipe(ns),
).annotate({
  identifier: "VolumeAttachment",
}) as any as S.Schema<VolumeAttachment>;
export interface AttachVpnGatewayRequest {
  VpcId?: string;
  VpnGatewayId?: string;
  DryRun?: boolean;
}
export const AttachVpnGatewayRequest = S.suspend(() =>
  S.Struct({
    VpcId: S.optional(S.String),
    VpnGatewayId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AttachVpnGatewayRequest",
}) as any as S.Schema<AttachVpnGatewayRequest>;
export type AttachmentStatus =
  | "attaching"
  | "attached"
  | "detaching"
  | "detached"
  | (string & {});
export const AttachmentStatus = S.String;
export interface VpcAttachment {
  VpcId?: string;
  State?: AttachmentStatus;
}
export const VpcAttachment = S.suspend(() =>
  S.Struct({
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    State: S.optional(AttachmentStatus).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({ identifier: "VpcAttachment" }) as any as S.Schema<VpcAttachment>;
export interface AttachVpnGatewayResult {
  VpcAttachment?: VpcAttachment;
}
export const AttachVpnGatewayResult = S.suspend(() =>
  S.Struct({
    VpcAttachment: S.optional(VpcAttachment)
      .pipe(T.XmlName("attachment"), T.Ec2QueryName("Attachment"))
      .annotate({ identifier: "VpcAttachment" }),
  }).pipe(ns),
).annotate({
  identifier: "AttachVpnGatewayResult",
}) as any as S.Schema<AttachVpnGatewayResult>;
export interface AuthorizeClientVpnIngressRequest {
  ClientVpnEndpointId?: string;
  TargetNetworkCidr?: string;
  AccessGroupId?: string;
  AuthorizeAllGroups?: boolean;
  Description?: string;
  ClientToken?: string;
  DryRun?: boolean;
}
export const AuthorizeClientVpnIngressRequest = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String),
    TargetNetworkCidr: S.optional(S.String),
    AccessGroupId: S.optional(S.String),
    AuthorizeAllGroups: S.optional(S.Boolean),
    Description: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AuthorizeClientVpnIngressRequest",
}) as any as S.Schema<AuthorizeClientVpnIngressRequest>;
export type ClientVpnAuthorizationRuleStatusCode =
  | "authorizing"
  | "active"
  | "failed"
  | "revoking"
  | (string & {});
export const ClientVpnAuthorizationRuleStatusCode = S.String;
export interface ClientVpnAuthorizationRuleStatus {
  Code?: ClientVpnAuthorizationRuleStatusCode;
  Message?: string;
}
export const ClientVpnAuthorizationRuleStatus = S.suspend(() =>
  S.Struct({
    Code: S.optional(ClientVpnAuthorizationRuleStatusCode).pipe(
      T.XmlName("code"),
      T.Ec2QueryName("Code"),
    ),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "ClientVpnAuthorizationRuleStatus",
}) as any as S.Schema<ClientVpnAuthorizationRuleStatus>;
export interface AuthorizeClientVpnIngressResult {
  Status?: ClientVpnAuthorizationRuleStatus;
}
export const AuthorizeClientVpnIngressResult = S.suspend(() =>
  S.Struct({
    Status: S.optional(ClientVpnAuthorizationRuleStatus)
      .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
      .annotate({ identifier: "ClientVpnAuthorizationRuleStatus" }),
  }).pipe(ns),
).annotate({
  identifier: "AuthorizeClientVpnIngressResult",
}) as any as S.Schema<AuthorizeClientVpnIngressResult>;
export interface UserIdGroupPair {
  Description?: string;
  UserId?: string;
  GroupName?: string;
  GroupId?: string;
  VpcId?: string;
  VpcPeeringConnectionId?: string;
  PeeringStatus?: string;
}
export const UserIdGroupPair = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    UserId: S.optional(S.String).pipe(
      T.XmlName("userId"),
      T.Ec2QueryName("UserId"),
    ),
    GroupName: S.optional(S.String).pipe(
      T.XmlName("groupName"),
      T.Ec2QueryName("GroupName"),
    ),
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    VpcPeeringConnectionId: S.optional(S.String).pipe(
      T.XmlName("vpcPeeringConnectionId"),
      T.Ec2QueryName("VpcPeeringConnectionId"),
    ),
    PeeringStatus: S.optional(S.String).pipe(
      T.XmlName("peeringStatus"),
      T.Ec2QueryName("PeeringStatus"),
    ),
  }),
).annotate({
  identifier: "UserIdGroupPair",
}) as any as S.Schema<UserIdGroupPair>;
export type UserIdGroupPairList = UserIdGroupPair[];
export const UserIdGroupPairList = S.Array(
  UserIdGroupPair.pipe(T.XmlName("item")).annotate({
    identifier: "UserIdGroupPair",
  }),
);
export interface IpRange {
  Description?: string;
  CidrIp?: string;
}
export const IpRange = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    CidrIp: S.optional(S.String).pipe(
      T.XmlName("cidrIp"),
      T.Ec2QueryName("CidrIp"),
    ),
  }),
).annotate({ identifier: "IpRange" }) as any as S.Schema<IpRange>;
export type IpRangeList = IpRange[];
export const IpRangeList = S.Array(
  IpRange.pipe(T.XmlName("item")).annotate({ identifier: "IpRange" }),
);
export interface Ipv6Range {
  Description?: string;
  CidrIpv6?: string;
}
export const Ipv6Range = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    CidrIpv6: S.optional(S.String).pipe(
      T.XmlName("cidrIpv6"),
      T.Ec2QueryName("CidrIpv6"),
    ),
  }),
).annotate({ identifier: "Ipv6Range" }) as any as S.Schema<Ipv6Range>;
export type Ipv6RangeList = Ipv6Range[];
export const Ipv6RangeList = S.Array(
  Ipv6Range.pipe(T.XmlName("item")).annotate({ identifier: "Ipv6Range" }),
);
export interface PrefixListId {
  Description?: string;
  PrefixListId?: string;
}
export const PrefixListId = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    PrefixListId: S.optional(S.String).pipe(
      T.XmlName("prefixListId"),
      T.Ec2QueryName("PrefixListId"),
    ),
  }),
).annotate({ identifier: "PrefixListId" }) as any as S.Schema<PrefixListId>;
export type PrefixListIdList = PrefixListId[];
export const PrefixListIdList = S.Array(
  PrefixListId.pipe(T.XmlName("item")).annotate({ identifier: "PrefixListId" }),
);
export interface IpPermission {
  IpProtocol?: string;
  FromPort?: number;
  ToPort?: number;
  UserIdGroupPairs?: UserIdGroupPair[];
  IpRanges?: IpRange[];
  Ipv6Ranges?: Ipv6Range[];
  PrefixListIds?: PrefixListId[];
}
export const IpPermission = S.suspend(() =>
  S.Struct({
    IpProtocol: S.optional(S.String).pipe(
      T.XmlName("ipProtocol"),
      T.Ec2QueryName("IpProtocol"),
    ),
    FromPort: S.optional(S.Number).pipe(
      T.XmlName("fromPort"),
      T.Ec2QueryName("FromPort"),
    ),
    ToPort: S.optional(S.Number).pipe(
      T.XmlName("toPort"),
      T.Ec2QueryName("ToPort"),
    ),
    UserIdGroupPairs: S.optional(UserIdGroupPairList).pipe(
      T.XmlName("groups"),
      T.Ec2QueryName("Groups"),
    ),
    IpRanges: S.optional(IpRangeList).pipe(
      T.XmlName("ipRanges"),
      T.Ec2QueryName("IpRanges"),
    ),
    Ipv6Ranges: S.optional(Ipv6RangeList).pipe(
      T.XmlName("ipv6Ranges"),
      T.Ec2QueryName("Ipv6Ranges"),
    ),
    PrefixListIds: S.optional(PrefixListIdList).pipe(
      T.XmlName("prefixListIds"),
      T.Ec2QueryName("PrefixListIds"),
    ),
  }),
).annotate({ identifier: "IpPermission" }) as any as S.Schema<IpPermission>;
export type IpPermissionList = IpPermission[];
export const IpPermissionList = S.Array(
  IpPermission.pipe(T.XmlName("item")).annotate({ identifier: "IpPermission" }),
);
export interface AuthorizeSecurityGroupEgressRequest {
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
  GroupId?: string;
  SourceSecurityGroupName?: string;
  SourceSecurityGroupOwnerId?: string;
  IpProtocol?: string;
  FromPort?: number;
  ToPort?: number;
  CidrIp?: string;
  IpPermissions?: IpPermission[];
}
export const AuthorizeSecurityGroupEgressRequest = S.suspend(() =>
  S.Struct({
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
    SourceSecurityGroupName: S.optional(S.String).pipe(
      T.XmlName("sourceSecurityGroupName"),
      T.Ec2QueryName("SourceSecurityGroupName"),
    ),
    SourceSecurityGroupOwnerId: S.optional(S.String).pipe(
      T.XmlName("sourceSecurityGroupOwnerId"),
      T.Ec2QueryName("SourceSecurityGroupOwnerId"),
    ),
    IpProtocol: S.optional(S.String).pipe(
      T.XmlName("ipProtocol"),
      T.Ec2QueryName("IpProtocol"),
    ),
    FromPort: S.optional(S.Number).pipe(
      T.XmlName("fromPort"),
      T.Ec2QueryName("FromPort"),
    ),
    ToPort: S.optional(S.Number).pipe(
      T.XmlName("toPort"),
      T.Ec2QueryName("ToPort"),
    ),
    CidrIp: S.optional(S.String).pipe(
      T.XmlName("cidrIp"),
      T.Ec2QueryName("CidrIp"),
    ),
    IpPermissions: S.optional(IpPermissionList).pipe(
      T.XmlName("ipPermissions"),
      T.Ec2QueryName("IpPermissions"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AuthorizeSecurityGroupEgressRequest",
}) as any as S.Schema<AuthorizeSecurityGroupEgressRequest>;
export interface ReferencedSecurityGroup {
  GroupId?: string;
  PeeringStatus?: string;
  UserId?: string;
  VpcId?: string;
  VpcPeeringConnectionId?: string;
}
export const ReferencedSecurityGroup = S.suspend(() =>
  S.Struct({
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
    PeeringStatus: S.optional(S.String).pipe(
      T.XmlName("peeringStatus"),
      T.Ec2QueryName("PeeringStatus"),
    ),
    UserId: S.optional(S.String).pipe(
      T.XmlName("userId"),
      T.Ec2QueryName("UserId"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    VpcPeeringConnectionId: S.optional(S.String).pipe(
      T.XmlName("vpcPeeringConnectionId"),
      T.Ec2QueryName("VpcPeeringConnectionId"),
    ),
  }),
).annotate({
  identifier: "ReferencedSecurityGroup",
}) as any as S.Schema<ReferencedSecurityGroup>;
export interface SecurityGroupRule {
  SecurityGroupRuleId?: string;
  GroupId?: string;
  GroupOwnerId?: string;
  IsEgress?: boolean;
  IpProtocol?: string;
  FromPort?: number;
  ToPort?: number;
  CidrIpv4?: string;
  CidrIpv6?: string;
  PrefixListId?: string;
  ReferencedGroupInfo?: ReferencedSecurityGroup;
  Description?: string;
  Tags?: Tag[];
  SecurityGroupRuleArn?: string;
}
export const SecurityGroupRule = S.suspend(() =>
  S.Struct({
    SecurityGroupRuleId: S.optional(S.String).pipe(
      T.XmlName("securityGroupRuleId"),
      T.Ec2QueryName("SecurityGroupRuleId"),
    ),
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
    GroupOwnerId: S.optional(S.String).pipe(
      T.XmlName("groupOwnerId"),
      T.Ec2QueryName("GroupOwnerId"),
    ),
    IsEgress: S.optional(S.Boolean).pipe(
      T.XmlName("isEgress"),
      T.Ec2QueryName("IsEgress"),
    ),
    IpProtocol: S.optional(S.String).pipe(
      T.XmlName("ipProtocol"),
      T.Ec2QueryName("IpProtocol"),
    ),
    FromPort: S.optional(S.Number).pipe(
      T.XmlName("fromPort"),
      T.Ec2QueryName("FromPort"),
    ),
    ToPort: S.optional(S.Number).pipe(
      T.XmlName("toPort"),
      T.Ec2QueryName("ToPort"),
    ),
    CidrIpv4: S.optional(S.String).pipe(
      T.XmlName("cidrIpv4"),
      T.Ec2QueryName("CidrIpv4"),
    ),
    CidrIpv6: S.optional(S.String).pipe(
      T.XmlName("cidrIpv6"),
      T.Ec2QueryName("CidrIpv6"),
    ),
    PrefixListId: S.optional(S.String).pipe(
      T.XmlName("prefixListId"),
      T.Ec2QueryName("PrefixListId"),
    ),
    ReferencedGroupInfo: S.optional(ReferencedSecurityGroup)
      .pipe(
        T.XmlName("referencedGroupInfo"),
        T.Ec2QueryName("ReferencedGroupInfo"),
      )
      .annotate({ identifier: "ReferencedSecurityGroup" }),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    SecurityGroupRuleArn: S.optional(S.String).pipe(
      T.XmlName("securityGroupRuleArn"),
      T.Ec2QueryName("SecurityGroupRuleArn"),
    ),
  }),
).annotate({
  identifier: "SecurityGroupRule",
}) as any as S.Schema<SecurityGroupRule>;
export type SecurityGroupRuleList = SecurityGroupRule[];
export const SecurityGroupRuleList = S.Array(
  SecurityGroupRule.pipe(T.XmlName("item")).annotate({
    identifier: "SecurityGroupRule",
  }),
);
export interface AuthorizeSecurityGroupEgressResult {
  Return?: boolean;
  SecurityGroupRules?: SecurityGroupRule[];
}
export const AuthorizeSecurityGroupEgressResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
    SecurityGroupRules: S.optional(SecurityGroupRuleList).pipe(
      T.XmlName("securityGroupRuleSet"),
      T.Ec2QueryName("SecurityGroupRuleSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AuthorizeSecurityGroupEgressResult",
}) as any as S.Schema<AuthorizeSecurityGroupEgressResult>;
export interface AuthorizeSecurityGroupIngressRequest {
  CidrIp?: string;
  FromPort?: number;
  GroupId?: string;
  GroupName?: string;
  IpPermissions?: IpPermission[];
  IpProtocol?: string;
  SourceSecurityGroupName?: string;
  SourceSecurityGroupOwnerId?: string;
  ToPort?: number;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const AuthorizeSecurityGroupIngressRequest = S.suspend(() =>
  S.Struct({
    CidrIp: S.optional(S.String),
    FromPort: S.optional(S.Number),
    GroupId: S.optional(S.String),
    GroupName: S.optional(S.String),
    IpPermissions: S.optional(IpPermissionList),
    IpProtocol: S.optional(S.String),
    SourceSecurityGroupName: S.optional(S.String),
    SourceSecurityGroupOwnerId: S.optional(S.String),
    ToPort: S.optional(S.Number),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AuthorizeSecurityGroupIngressRequest",
}) as any as S.Schema<AuthorizeSecurityGroupIngressRequest>;
export interface AuthorizeSecurityGroupIngressResult {
  Return?: boolean;
  SecurityGroupRules?: SecurityGroupRule[];
}
export const AuthorizeSecurityGroupIngressResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
    SecurityGroupRules: S.optional(SecurityGroupRuleList).pipe(
      T.XmlName("securityGroupRuleSet"),
      T.Ec2QueryName("SecurityGroupRuleSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "AuthorizeSecurityGroupIngressResult",
}) as any as S.Schema<AuthorizeSecurityGroupIngressResult>;
export interface S3Storage {
  AWSAccessKeyId?: string;
  Bucket?: string;
  Prefix?: string;
  UploadPolicy?: Uint8Array;
  UploadPolicySignature?: string | redacted.Redacted<string>;
}
export const S3Storage = S.suspend(() =>
  S.Struct({
    AWSAccessKeyId: S.optional(S.String),
    Bucket: S.optional(S.String).pipe(
      T.XmlName("bucket"),
      T.Ec2QueryName("Bucket"),
    ),
    Prefix: S.optional(S.String).pipe(
      T.XmlName("prefix"),
      T.Ec2QueryName("Prefix"),
    ),
    UploadPolicy: S.optional(T.Blob).pipe(
      T.XmlName("uploadPolicy"),
      T.Ec2QueryName("UploadPolicy"),
    ),
    UploadPolicySignature: S.optional(SensitiveString).pipe(
      T.XmlName("uploadPolicySignature"),
      T.Ec2QueryName("UploadPolicySignature"),
    ),
  }),
).annotate({ identifier: "S3Storage" }) as any as S.Schema<S3Storage>;
export interface Storage {
  S3?: S3Storage;
}
export const Storage = S.suspend(() =>
  S.Struct({
    S3: S.optional(S3Storage)
      .pipe(T.XmlName("S3"))
      .annotate({ identifier: "S3Storage" }),
  }),
).annotate({ identifier: "Storage" }) as any as S.Schema<Storage>;
export interface BundleInstanceRequest {
  InstanceId?: string;
  Storage?: Storage;
  DryRun?: boolean;
}
export const BundleInstanceRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    Storage: S.optional(Storage),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "BundleInstanceRequest",
}) as any as S.Schema<BundleInstanceRequest>;
export type BundleTaskState =
  | "pending"
  | "waiting-for-shutdown"
  | "bundling"
  | "storing"
  | "cancelling"
  | "complete"
  | "failed"
  | (string & {});
export const BundleTaskState = S.String;
export interface BundleTaskError {
  Code?: string;
  Message?: string;
}
export const BundleTaskError = S.suspend(() =>
  S.Struct({
    Code: S.optional(S.String).pipe(T.XmlName("code"), T.Ec2QueryName("Code")),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "BundleTaskError",
}) as any as S.Schema<BundleTaskError>;
export interface BundleTask {
  InstanceId?: string;
  BundleId?: string;
  State?: BundleTaskState;
  StartTime?: Date;
  UpdateTime?: Date;
  Storage?: Storage;
  Progress?: string;
  BundleTaskError?: BundleTaskError;
}
export const BundleTask = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    BundleId: S.optional(S.String).pipe(
      T.XmlName("bundleId"),
      T.Ec2QueryName("BundleId"),
    ),
    State: S.optional(BundleTaskState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startTime"), T.Ec2QueryName("StartTime")),
    UpdateTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("updateTime"), T.Ec2QueryName("UpdateTime")),
    Storage: S.optional(Storage)
      .pipe(T.XmlName("storage"), T.Ec2QueryName("Storage"))
      .annotate({ identifier: "Storage" }),
    Progress: S.optional(S.String).pipe(
      T.XmlName("progress"),
      T.Ec2QueryName("Progress"),
    ),
    BundleTaskError: S.optional(BundleTaskError)
      .pipe(T.XmlName("error"), T.Ec2QueryName("Error"))
      .annotate({ identifier: "BundleTaskError" }),
  }),
).annotate({ identifier: "BundleTask" }) as any as S.Schema<BundleTask>;
export interface BundleInstanceResult {
  BundleTask?: BundleTask;
}
export const BundleInstanceResult = S.suspend(() =>
  S.Struct({
    BundleTask: S.optional(BundleTask)
      .pipe(
        T.XmlName("bundleInstanceTask"),
        T.Ec2QueryName("BundleInstanceTask"),
      )
      .annotate({ identifier: "BundleTask" }),
  }).pipe(ns),
).annotate({
  identifier: "BundleInstanceResult",
}) as any as S.Schema<BundleInstanceResult>;
export interface CancelBundleTaskRequest {
  BundleId?: string;
  DryRun?: boolean;
}
export const CancelBundleTaskRequest = S.suspend(() =>
  S.Struct({
    BundleId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CancelBundleTaskRequest",
}) as any as S.Schema<CancelBundleTaskRequest>;
export interface CancelBundleTaskResult {
  BundleTask?: BundleTask;
}
export const CancelBundleTaskResult = S.suspend(() =>
  S.Struct({
    BundleTask: S.optional(BundleTask)
      .pipe(
        T.XmlName("bundleInstanceTask"),
        T.Ec2QueryName("BundleInstanceTask"),
      )
      .annotate({ identifier: "BundleTask" }),
  }).pipe(ns),
).annotate({
  identifier: "CancelBundleTaskResult",
}) as any as S.Schema<CancelBundleTaskResult>;
export interface CancelCapacityReservationRequest {
  CapacityReservationId?: string;
  DryRun?: boolean;
}
export const CancelCapacityReservationRequest = S.suspend(() =>
  S.Struct({
    CapacityReservationId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CancelCapacityReservationRequest",
}) as any as S.Schema<CancelCapacityReservationRequest>;
export interface CancelCapacityReservationResult {
  Return?: boolean;
}
export const CancelCapacityReservationResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CancelCapacityReservationResult",
}) as any as S.Schema<CancelCapacityReservationResult>;
export type CapacityReservationFleetIdSet = string[];
export const CapacityReservationFleetIdSet = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface CancelCapacityReservationFleetsRequest {
  DryRun?: boolean;
  CapacityReservationFleetIds?: string[];
}
export const CancelCapacityReservationFleetsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    CapacityReservationFleetIds: S.optional(CapacityReservationFleetIdSet).pipe(
      T.XmlName("CapacityReservationFleetId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CancelCapacityReservationFleetsRequest",
}) as any as S.Schema<CancelCapacityReservationFleetsRequest>;
export type CapacityReservationFleetState =
  | "submitted"
  | "modifying"
  | "active"
  | "partially_fulfilled"
  | "expiring"
  | "expired"
  | "cancelling"
  | "cancelled"
  | "failed"
  | (string & {});
export const CapacityReservationFleetState = S.String;
export interface CapacityReservationFleetCancellationState {
  CurrentFleetState?: CapacityReservationFleetState;
  PreviousFleetState?: CapacityReservationFleetState;
  CapacityReservationFleetId?: string;
}
export const CapacityReservationFleetCancellationState = S.suspend(() =>
  S.Struct({
    CurrentFleetState: S.optional(CapacityReservationFleetState).pipe(
      T.XmlName("currentFleetState"),
      T.Ec2QueryName("CurrentFleetState"),
    ),
    PreviousFleetState: S.optional(CapacityReservationFleetState).pipe(
      T.XmlName("previousFleetState"),
      T.Ec2QueryName("PreviousFleetState"),
    ),
    CapacityReservationFleetId: S.optional(S.String).pipe(
      T.XmlName("capacityReservationFleetId"),
      T.Ec2QueryName("CapacityReservationFleetId"),
    ),
  }),
).annotate({
  identifier: "CapacityReservationFleetCancellationState",
}) as any as S.Schema<CapacityReservationFleetCancellationState>;
export type CapacityReservationFleetCancellationStateSet =
  CapacityReservationFleetCancellationState[];
export const CapacityReservationFleetCancellationStateSet = S.Array(
  CapacityReservationFleetCancellationState.pipe(T.XmlName("item")).annotate({
    identifier: "CapacityReservationFleetCancellationState",
  }),
);
export interface CancelCapacityReservationFleetError {
  Code?: string;
  Message?: string;
}
export const CancelCapacityReservationFleetError = S.suspend(() =>
  S.Struct({
    Code: S.optional(S.String).pipe(T.XmlName("code"), T.Ec2QueryName("Code")),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "CancelCapacityReservationFleetError",
}) as any as S.Schema<CancelCapacityReservationFleetError>;
export interface FailedCapacityReservationFleetCancellationResult {
  CapacityReservationFleetId?: string;
  CancelCapacityReservationFleetError?: CancelCapacityReservationFleetError;
}
export const FailedCapacityReservationFleetCancellationResult = S.suspend(() =>
  S.Struct({
    CapacityReservationFleetId: S.optional(S.String).pipe(
      T.XmlName("capacityReservationFleetId"),
      T.Ec2QueryName("CapacityReservationFleetId"),
    ),
    CancelCapacityReservationFleetError: S.optional(
      CancelCapacityReservationFleetError,
    )
      .pipe(
        T.XmlName("cancelCapacityReservationFleetError"),
        T.Ec2QueryName("CancelCapacityReservationFleetError"),
      )
      .annotate({ identifier: "CancelCapacityReservationFleetError" }),
  }),
).annotate({
  identifier: "FailedCapacityReservationFleetCancellationResult",
}) as any as S.Schema<FailedCapacityReservationFleetCancellationResult>;
export type FailedCapacityReservationFleetCancellationResultSet =
  FailedCapacityReservationFleetCancellationResult[];
export const FailedCapacityReservationFleetCancellationResultSet = S.Array(
  FailedCapacityReservationFleetCancellationResult.pipe(
    T.XmlName("item"),
  ).annotate({
    identifier: "FailedCapacityReservationFleetCancellationResult",
  }),
);
export interface CancelCapacityReservationFleetsResult {
  SuccessfulFleetCancellations?: CapacityReservationFleetCancellationState[];
  FailedFleetCancellations?: FailedCapacityReservationFleetCancellationResult[];
}
export const CancelCapacityReservationFleetsResult = S.suspend(() =>
  S.Struct({
    SuccessfulFleetCancellations: S.optional(
      CapacityReservationFleetCancellationStateSet,
    ).pipe(
      T.XmlName("successfulFleetCancellationSet"),
      T.Ec2QueryName("SuccessfulFleetCancellationSet"),
    ),
    FailedFleetCancellations: S.optional(
      FailedCapacityReservationFleetCancellationResultSet,
    ).pipe(
      T.XmlName("failedFleetCancellationSet"),
      T.Ec2QueryName("FailedFleetCancellationSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CancelCapacityReservationFleetsResult",
}) as any as S.Schema<CancelCapacityReservationFleetsResult>;
export interface CancelConversionRequest {
  DryRun?: boolean;
  ConversionTaskId?: string;
  ReasonMessage?: string;
}
export const CancelConversionRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    ConversionTaskId: S.optional(S.String).pipe(
      T.XmlName("conversionTaskId"),
      T.Ec2QueryName("ConversionTaskId"),
    ),
    ReasonMessage: S.optional(S.String).pipe(
      T.XmlName("reasonMessage"),
      T.Ec2QueryName("ReasonMessage"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CancelConversionRequest",
}) as any as S.Schema<CancelConversionRequest>;
export interface CancelConversionTaskResponse {}
export const CancelConversionTaskResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "CancelConversionTaskResponse",
}) as any as S.Schema<CancelConversionTaskResponse>;
export interface CancelDeclarativePoliciesReportRequest {
  DryRun?: boolean;
  ReportId?: string;
}
export const CancelDeclarativePoliciesReportRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ReportId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CancelDeclarativePoliciesReportRequest",
}) as any as S.Schema<CancelDeclarativePoliciesReportRequest>;
export interface CancelDeclarativePoliciesReportResult {
  Return?: boolean;
}
export const CancelDeclarativePoliciesReportResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CancelDeclarativePoliciesReportResult",
}) as any as S.Schema<CancelDeclarativePoliciesReportResult>;
export interface CancelExportTaskRequest {
  ExportTaskId?: string;
}
export const CancelExportTaskRequest = S.suspend(() =>
  S.Struct({
    ExportTaskId: S.optional(S.String).pipe(
      T.XmlName("exportTaskId"),
      T.Ec2QueryName("ExportTaskId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CancelExportTaskRequest",
}) as any as S.Schema<CancelExportTaskRequest>;
export interface CancelExportTaskResponse {}
export const CancelExportTaskResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "CancelExportTaskResponse",
}) as any as S.Schema<CancelExportTaskResponse>;
export interface CancelImageLaunchPermissionRequest {
  ImageId?: string;
  DryRun?: boolean;
}
export const CancelImageLaunchPermissionRequest = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CancelImageLaunchPermissionRequest",
}) as any as S.Schema<CancelImageLaunchPermissionRequest>;
export interface CancelImageLaunchPermissionResult {
  Return?: boolean;
}
export const CancelImageLaunchPermissionResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CancelImageLaunchPermissionResult",
}) as any as S.Schema<CancelImageLaunchPermissionResult>;
export interface CancelImportTaskRequest {
  CancelReason?: string;
  DryRun?: boolean;
  ImportTaskId?: string;
}
export const CancelImportTaskRequest = S.suspend(() =>
  S.Struct({
    CancelReason: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    ImportTaskId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CancelImportTaskRequest",
}) as any as S.Schema<CancelImportTaskRequest>;
export interface CancelImportTaskResult {
  ImportTaskId?: string;
  PreviousState?: string;
  State?: string;
}
export const CancelImportTaskResult = S.suspend(() =>
  S.Struct({
    ImportTaskId: S.optional(S.String).pipe(
      T.XmlName("importTaskId"),
      T.Ec2QueryName("ImportTaskId"),
    ),
    PreviousState: S.optional(S.String).pipe(
      T.XmlName("previousState"),
      T.Ec2QueryName("PreviousState"),
    ),
    State: S.optional(S.String).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CancelImportTaskResult",
}) as any as S.Schema<CancelImportTaskResult>;
export interface CancelReservedInstancesListingRequest {
  ReservedInstancesListingId?: string;
}
export const CancelReservedInstancesListingRequest = S.suspend(() =>
  S.Struct({
    ReservedInstancesListingId: S.optional(S.String).pipe(
      T.XmlName("reservedInstancesListingId"),
      T.Ec2QueryName("ReservedInstancesListingId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CancelReservedInstancesListingRequest",
}) as any as S.Schema<CancelReservedInstancesListingRequest>;
export type ListingState =
  | "available"
  | "sold"
  | "cancelled"
  | "pending"
  | (string & {});
export const ListingState = S.String;
export interface InstanceCount {
  InstanceCount?: number;
  State?: ListingState;
}
export const InstanceCount = S.suspend(() =>
  S.Struct({
    InstanceCount: S.optional(S.Number).pipe(
      T.XmlName("instanceCount"),
      T.Ec2QueryName("InstanceCount"),
    ),
    State: S.optional(ListingState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({ identifier: "InstanceCount" }) as any as S.Schema<InstanceCount>;
export type InstanceCountList = InstanceCount[];
export const InstanceCountList = S.Array(
  InstanceCount.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceCount",
  }),
);
export type CurrencyCodeValues = "USD" | (string & {});
export const CurrencyCodeValues = S.String;
export interface PriceSchedule {
  Active?: boolean;
  CurrencyCode?: CurrencyCodeValues;
  Price?: number;
  Term?: number;
}
export const PriceSchedule = S.suspend(() =>
  S.Struct({
    Active: S.optional(S.Boolean).pipe(
      T.XmlName("active"),
      T.Ec2QueryName("Active"),
    ),
    CurrencyCode: S.optional(CurrencyCodeValues).pipe(
      T.XmlName("currencyCode"),
      T.Ec2QueryName("CurrencyCode"),
    ),
    Price: S.optional(S.Number).pipe(
      T.XmlName("price"),
      T.Ec2QueryName("Price"),
    ),
    Term: S.optional(S.Number).pipe(T.XmlName("term"), T.Ec2QueryName("Term")),
  }),
).annotate({ identifier: "PriceSchedule" }) as any as S.Schema<PriceSchedule>;
export type PriceScheduleList = PriceSchedule[];
export const PriceScheduleList = S.Array(
  PriceSchedule.pipe(T.XmlName("item")).annotate({
    identifier: "PriceSchedule",
  }),
);
export type ListingStatus =
  | "active"
  | "pending"
  | "cancelled"
  | "closed"
  | (string & {});
export const ListingStatus = S.String;
export interface ReservedInstancesListing {
  ClientToken?: string;
  CreateDate?: Date;
  InstanceCounts?: InstanceCount[];
  PriceSchedules?: PriceSchedule[];
  ReservedInstancesId?: string;
  ReservedInstancesListingId?: string;
  Status?: ListingStatus;
  StatusMessage?: string;
  Tags?: Tag[];
  UpdateDate?: Date;
}
export const ReservedInstancesListing = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
    CreateDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createDate"), T.Ec2QueryName("CreateDate")),
    InstanceCounts: S.optional(InstanceCountList).pipe(
      T.XmlName("instanceCounts"),
      T.Ec2QueryName("InstanceCounts"),
    ),
    PriceSchedules: S.optional(PriceScheduleList).pipe(
      T.XmlName("priceSchedules"),
      T.Ec2QueryName("PriceSchedules"),
    ),
    ReservedInstancesId: S.optional(S.String).pipe(
      T.XmlName("reservedInstancesId"),
      T.Ec2QueryName("ReservedInstancesId"),
    ),
    ReservedInstancesListingId: S.optional(S.String).pipe(
      T.XmlName("reservedInstancesListingId"),
      T.Ec2QueryName("ReservedInstancesListingId"),
    ),
    Status: S.optional(ListingStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    UpdateDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("updateDate"), T.Ec2QueryName("UpdateDate")),
  }),
).annotate({
  identifier: "ReservedInstancesListing",
}) as any as S.Schema<ReservedInstancesListing>;
export type ReservedInstancesListingList = ReservedInstancesListing[];
export const ReservedInstancesListingList = S.Array(
  ReservedInstancesListing.pipe(T.XmlName("item")).annotate({
    identifier: "ReservedInstancesListing",
  }),
);
export interface CancelReservedInstancesListingResult {
  ReservedInstancesListings?: ReservedInstancesListing[];
}
export const CancelReservedInstancesListingResult = S.suspend(() =>
  S.Struct({
    ReservedInstancesListings: S.optional(ReservedInstancesListingList).pipe(
      T.XmlName("reservedInstancesListingsSet"),
      T.Ec2QueryName("ReservedInstancesListingsSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CancelReservedInstancesListingResult",
}) as any as S.Schema<CancelReservedInstancesListingResult>;
export type SpotFleetRequestIdList = string[];
export const SpotFleetRequestIdList = S.Array(S.String.pipe(T.XmlName("item")));
export interface CancelSpotFleetRequestsRequest {
  DryRun?: boolean;
  SpotFleetRequestIds?: string[];
  TerminateInstances?: boolean;
}
export const CancelSpotFleetRequestsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    SpotFleetRequestIds: S.optional(SpotFleetRequestIdList).pipe(
      T.XmlName("spotFleetRequestId"),
      T.Ec2QueryName("SpotFleetRequestId"),
    ),
    TerminateInstances: S.optional(S.Boolean).pipe(
      T.XmlName("terminateInstances"),
      T.Ec2QueryName("TerminateInstances"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CancelSpotFleetRequestsRequest",
}) as any as S.Schema<CancelSpotFleetRequestsRequest>;
export type BatchState =
  | "submitted"
  | "active"
  | "cancelled"
  | "failed"
  | "cancelled_running"
  | "cancelled_terminating"
  | "modifying"
  | (string & {});
export const BatchState = S.String;
export interface CancelSpotFleetRequestsSuccessItem {
  CurrentSpotFleetRequestState?: BatchState;
  PreviousSpotFleetRequestState?: BatchState;
  SpotFleetRequestId?: string;
}
export const CancelSpotFleetRequestsSuccessItem = S.suspend(() =>
  S.Struct({
    CurrentSpotFleetRequestState: S.optional(BatchState).pipe(
      T.XmlName("currentSpotFleetRequestState"),
      T.Ec2QueryName("CurrentSpotFleetRequestState"),
    ),
    PreviousSpotFleetRequestState: S.optional(BatchState).pipe(
      T.XmlName("previousSpotFleetRequestState"),
      T.Ec2QueryName("PreviousSpotFleetRequestState"),
    ),
    SpotFleetRequestId: S.optional(S.String).pipe(
      T.XmlName("spotFleetRequestId"),
      T.Ec2QueryName("SpotFleetRequestId"),
    ),
  }),
).annotate({
  identifier: "CancelSpotFleetRequestsSuccessItem",
}) as any as S.Schema<CancelSpotFleetRequestsSuccessItem>;
export type CancelSpotFleetRequestsSuccessSet =
  CancelSpotFleetRequestsSuccessItem[];
export const CancelSpotFleetRequestsSuccessSet = S.Array(
  CancelSpotFleetRequestsSuccessItem.pipe(T.XmlName("item")).annotate({
    identifier: "CancelSpotFleetRequestsSuccessItem",
  }),
);
export type CancelBatchErrorCode =
  | "fleetRequestIdDoesNotExist"
  | "fleetRequestIdMalformed"
  | "fleetRequestNotInCancellableState"
  | "unexpectedError"
  | (string & {});
export const CancelBatchErrorCode = S.String;
export interface CancelSpotFleetRequestsError_ {
  Code?: CancelBatchErrorCode;
  Message?: string;
}
export const CancelSpotFleetRequestsError_ = S.suspend(() =>
  S.Struct({
    Code: S.optional(CancelBatchErrorCode).pipe(
      T.XmlName("code"),
      T.Ec2QueryName("Code"),
    ),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "CancelSpotFleetRequestsError",
}) as any as S.Schema<CancelSpotFleetRequestsError_>;
export interface CancelSpotFleetRequestsErrorItem {
  Error?: CancelSpotFleetRequestsError_;
  SpotFleetRequestId?: string;
}
export const CancelSpotFleetRequestsErrorItem = S.suspend(() =>
  S.Struct({
    Error: S.optional(CancelSpotFleetRequestsError_)
      .pipe(T.XmlName("error"), T.Ec2QueryName("Error"))
      .annotate({ identifier: "CancelSpotFleetRequestsError" }),
    SpotFleetRequestId: S.optional(S.String).pipe(
      T.XmlName("spotFleetRequestId"),
      T.Ec2QueryName("SpotFleetRequestId"),
    ),
  }),
).annotate({
  identifier: "CancelSpotFleetRequestsErrorItem",
}) as any as S.Schema<CancelSpotFleetRequestsErrorItem>;
export type CancelSpotFleetRequestsErrorSet =
  CancelSpotFleetRequestsErrorItem[];
export const CancelSpotFleetRequestsErrorSet = S.Array(
  CancelSpotFleetRequestsErrorItem.pipe(T.XmlName("item")).annotate({
    identifier: "CancelSpotFleetRequestsErrorItem",
  }),
);
export interface CancelSpotFleetRequestsResponse {
  SuccessfulFleetRequests?: CancelSpotFleetRequestsSuccessItem[];
  UnsuccessfulFleetRequests?: CancelSpotFleetRequestsErrorItem[];
}
export const CancelSpotFleetRequestsResponse = S.suspend(() =>
  S.Struct({
    SuccessfulFleetRequests: S.optional(CancelSpotFleetRequestsSuccessSet).pipe(
      T.XmlName("successfulFleetRequestSet"),
      T.Ec2QueryName("SuccessfulFleetRequestSet"),
    ),
    UnsuccessfulFleetRequests: S.optional(CancelSpotFleetRequestsErrorSet).pipe(
      T.XmlName("unsuccessfulFleetRequestSet"),
      T.Ec2QueryName("UnsuccessfulFleetRequestSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CancelSpotFleetRequestsResponse",
}) as any as S.Schema<CancelSpotFleetRequestsResponse>;
export type SpotInstanceRequestIdList = string[];
export const SpotInstanceRequestIdList = S.Array(
  S.String.pipe(T.XmlName("SpotInstanceRequestId")),
);
export interface CancelSpotInstanceRequestsRequest {
  DryRun?: boolean;
  SpotInstanceRequestIds?: string[];
}
export const CancelSpotInstanceRequestsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    SpotInstanceRequestIds: S.optional(SpotInstanceRequestIdList).pipe(
      T.XmlName("SpotInstanceRequestId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CancelSpotInstanceRequestsRequest",
}) as any as S.Schema<CancelSpotInstanceRequestsRequest>;
export type CancelSpotInstanceRequestState =
  | "active"
  | "open"
  | "closed"
  | "cancelled"
  | "completed"
  | (string & {});
export const CancelSpotInstanceRequestState = S.String;
export interface CancelledSpotInstanceRequest {
  SpotInstanceRequestId?: string;
  State?: CancelSpotInstanceRequestState;
}
export const CancelledSpotInstanceRequest = S.suspend(() =>
  S.Struct({
    SpotInstanceRequestId: S.optional(S.String).pipe(
      T.XmlName("spotInstanceRequestId"),
      T.Ec2QueryName("SpotInstanceRequestId"),
    ),
    State: S.optional(CancelSpotInstanceRequestState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({
  identifier: "CancelledSpotInstanceRequest",
}) as any as S.Schema<CancelledSpotInstanceRequest>;
export type CancelledSpotInstanceRequestList = CancelledSpotInstanceRequest[];
export const CancelledSpotInstanceRequestList = S.Array(
  CancelledSpotInstanceRequest.pipe(T.XmlName("item")).annotate({
    identifier: "CancelledSpotInstanceRequest",
  }),
);
export interface CancelSpotInstanceRequestsResult {
  CancelledSpotInstanceRequests?: CancelledSpotInstanceRequest[];
}
export const CancelSpotInstanceRequestsResult = S.suspend(() =>
  S.Struct({
    CancelledSpotInstanceRequests: S.optional(
      CancelledSpotInstanceRequestList,
    ).pipe(
      T.XmlName("spotInstanceRequestSet"),
      T.Ec2QueryName("SpotInstanceRequestSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CancelSpotInstanceRequestsResult",
}) as any as S.Schema<CancelSpotInstanceRequestsResult>;
export interface ConfirmProductInstanceRequest {
  InstanceId?: string;
  ProductCode?: string;
  DryRun?: boolean;
}
export const ConfirmProductInstanceRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    ProductCode: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ConfirmProductInstanceRequest",
}) as any as S.Schema<ConfirmProductInstanceRequest>;
export interface ConfirmProductInstanceResult {
  Return?: boolean;
  OwnerId?: string;
}
export const ConfirmProductInstanceResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ConfirmProductInstanceResult",
}) as any as S.Schema<ConfirmProductInstanceResult>;
export interface CopyFpgaImageRequest {
  DryRun?: boolean;
  SourceFpgaImageId?: string;
  Description?: string;
  Name?: string;
  SourceRegion?: string;
  ClientToken?: string;
}
export const CopyFpgaImageRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    SourceFpgaImageId: S.optional(S.String),
    Description: S.optional(S.String),
    Name: S.optional(S.String),
    SourceRegion: S.optional(S.String),
    ClientToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CopyFpgaImageRequest",
}) as any as S.Schema<CopyFpgaImageRequest>;
export interface CopyFpgaImageResult {
  FpgaImageId?: string;
}
export const CopyFpgaImageResult = S.suspend(() =>
  S.Struct({
    FpgaImageId: S.optional(S.String).pipe(
      T.XmlName("fpgaImageId"),
      T.Ec2QueryName("FpgaImageId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CopyFpgaImageResult",
}) as any as S.Schema<CopyFpgaImageResult>;
export interface CopyImageRequest {
  ClientToken?: string;
  Description?: string;
  Encrypted?: boolean;
  KmsKeyId?: string;
  Name?: string;
  SourceImageId?: string;
  SourceRegion?: string;
  DestinationOutpostArn?: string;
  CopyImageTags?: boolean;
  TagSpecifications?: TagSpecification[];
  SnapshotCopyCompletionDurationMinutes?: number;
  DestinationAvailabilityZone?: string;
  DestinationAvailabilityZoneId?: string;
  DryRun?: boolean;
}
export const CopyImageRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    Description: S.optional(S.String),
    Encrypted: S.optional(S.Boolean).pipe(
      T.XmlName("encrypted"),
      T.Ec2QueryName("Encrypted"),
    ),
    KmsKeyId: S.optional(S.String).pipe(
      T.XmlName("kmsKeyId"),
      T.Ec2QueryName("KmsKeyId"),
    ),
    Name: S.optional(S.String),
    SourceImageId: S.optional(S.String),
    SourceRegion: S.optional(S.String),
    DestinationOutpostArn: S.optional(S.String),
    CopyImageTags: S.optional(S.Boolean),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    SnapshotCopyCompletionDurationMinutes: S.optional(S.Number),
    DestinationAvailabilityZone: S.optional(S.String),
    DestinationAvailabilityZoneId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CopyImageRequest",
}) as any as S.Schema<CopyImageRequest>;
export interface CopyImageResult {
  ImageId?: string;
}
export const CopyImageResult = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CopyImageResult",
}) as any as S.Schema<CopyImageResult>;
export interface CopySnapshotRequest {
  Description?: string;
  DestinationOutpostArn?: string;
  DestinationRegion?: string;
  Encrypted?: boolean;
  KmsKeyId?: string;
  PresignedUrl?: string | redacted.Redacted<string>;
  SourceRegion?: string;
  SourceSnapshotId?: string;
  TagSpecifications?: TagSpecification[];
  CompletionDurationMinutes?: number;
  DestinationAvailabilityZone?: string;
  DryRun?: boolean;
}
export const CopySnapshotRequest = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String),
    DestinationOutpostArn: S.optional(S.String),
    DestinationRegion: S.optional(S.String).pipe(
      T.XmlName("destinationRegion"),
      T.Ec2QueryName("DestinationRegion"),
    ),
    Encrypted: S.optional(S.Boolean).pipe(
      T.XmlName("encrypted"),
      T.Ec2QueryName("Encrypted"),
    ),
    KmsKeyId: S.optional(S.String).pipe(
      T.XmlName("kmsKeyId"),
      T.Ec2QueryName("KmsKeyId"),
    ),
    PresignedUrl: S.optional(SensitiveString).pipe(
      T.XmlName("presignedUrl"),
      T.Ec2QueryName("PresignedUrl"),
    ),
    SourceRegion: S.optional(S.String),
    SourceSnapshotId: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    CompletionDurationMinutes: S.optional(S.Number),
    DestinationAvailabilityZone: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CopySnapshotRequest",
}) as any as S.Schema<CopySnapshotRequest>;
export interface CopySnapshotResult {
  Tags?: Tag[];
  SnapshotId?: string;
}
export const CopySnapshotResult = S.suspend(() =>
  S.Struct({
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CopySnapshotResult",
}) as any as S.Schema<CopySnapshotResult>;
export type VolumeType =
  | "standard"
  | "io1"
  | "io2"
  | "gp2"
  | "sc1"
  | "st1"
  | "gp3"
  | (string & {});
export const VolumeType = S.String;
export interface CopyVolumesRequest {
  SourceVolumeId?: string;
  Iops?: number;
  Size?: number;
  VolumeType?: VolumeType;
  DryRun?: boolean;
  TagSpecifications?: TagSpecification[];
  MultiAttachEnabled?: boolean;
  Throughput?: number;
  ClientToken?: string;
}
export const CopyVolumesRequest = S.suspend(() =>
  S.Struct({
    SourceVolumeId: S.optional(S.String),
    Iops: S.optional(S.Number),
    Size: S.optional(S.Number),
    VolumeType: S.optional(VolumeType),
    DryRun: S.optional(S.Boolean),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    MultiAttachEnabled: S.optional(S.Boolean),
    Throughput: S.optional(S.Number),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CopyVolumesRequest",
}) as any as S.Schema<CopyVolumesRequest>;
export type SSEType = "sse-ebs" | "sse-kms" | "none" | (string & {});
export const SSEType = S.String;
export interface OperatorResponse {
  Managed?: boolean;
  Principal?: string;
}
export const OperatorResponse = S.suspend(() =>
  S.Struct({
    Managed: S.optional(S.Boolean).pipe(
      T.XmlName("managed"),
      T.Ec2QueryName("Managed"),
    ),
    Principal: S.optional(S.String).pipe(
      T.XmlName("principal"),
      T.Ec2QueryName("Principal"),
    ),
  }),
).annotate({
  identifier: "OperatorResponse",
}) as any as S.Schema<OperatorResponse>;
export type VolumeState =
  | "creating"
  | "available"
  | "in-use"
  | "deleting"
  | "deleted"
  | "error"
  | (string & {});
export const VolumeState = S.String;
export type VolumeAttachmentList = VolumeAttachment[];
export const VolumeAttachmentList = S.Array(
  VolumeAttachment.pipe(T.XmlName("item")).annotate({
    identifier: "VolumeAttachment",
  }),
);
export interface Volume {
  AvailabilityZoneId?: string;
  OutpostArn?: string;
  SourceVolumeId?: string;
  Iops?: number;
  Tags?: Tag[];
  VolumeType?: VolumeType;
  FastRestored?: boolean;
  MultiAttachEnabled?: boolean;
  Throughput?: number;
  SseType?: SSEType;
  Operator?: OperatorResponse;
  VolumeInitializationRate?: number;
  VolumeId?: string;
  Size?: number;
  SnapshotId?: string;
  AvailabilityZone?: string;
  State?: VolumeState;
  CreateTime?: Date;
  Attachments?: VolumeAttachment[];
  Encrypted?: boolean;
  KmsKeyId?: string;
}
export const Volume = S.suspend(() =>
  S.Struct({
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    OutpostArn: S.optional(S.String).pipe(
      T.XmlName("outpostArn"),
      T.Ec2QueryName("OutpostArn"),
    ),
    SourceVolumeId: S.optional(S.String).pipe(
      T.XmlName("sourceVolumeId"),
      T.Ec2QueryName("SourceVolumeId"),
    ),
    Iops: S.optional(S.Number).pipe(T.XmlName("iops"), T.Ec2QueryName("Iops")),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    VolumeType: S.optional(VolumeType).pipe(
      T.XmlName("volumeType"),
      T.Ec2QueryName("VolumeType"),
    ),
    FastRestored: S.optional(S.Boolean).pipe(
      T.XmlName("fastRestored"),
      T.Ec2QueryName("FastRestored"),
    ),
    MultiAttachEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("multiAttachEnabled"),
      T.Ec2QueryName("MultiAttachEnabled"),
    ),
    Throughput: S.optional(S.Number).pipe(
      T.XmlName("throughput"),
      T.Ec2QueryName("Throughput"),
    ),
    SseType: S.optional(SSEType).pipe(
      T.XmlName("sseType"),
      T.Ec2QueryName("SseType"),
    ),
    Operator: S.optional(OperatorResponse)
      .pipe(T.XmlName("operator"), T.Ec2QueryName("Operator"))
      .annotate({ identifier: "OperatorResponse" }),
    VolumeInitializationRate: S.optional(S.Number).pipe(
      T.XmlName("volumeInitializationRate"),
      T.Ec2QueryName("VolumeInitializationRate"),
    ),
    VolumeId: S.optional(S.String).pipe(
      T.XmlName("volumeId"),
      T.Ec2QueryName("VolumeId"),
    ),
    Size: S.optional(S.Number).pipe(T.XmlName("size"), T.Ec2QueryName("Size")),
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    State: S.optional(VolumeState).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    CreateTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createTime"), T.Ec2QueryName("CreateTime")),
    Attachments: S.optional(VolumeAttachmentList).pipe(
      T.XmlName("attachmentSet"),
      T.Ec2QueryName("AttachmentSet"),
    ),
    Encrypted: S.optional(S.Boolean).pipe(
      T.XmlName("encrypted"),
      T.Ec2QueryName("Encrypted"),
    ),
    KmsKeyId: S.optional(S.String).pipe(
      T.XmlName("kmsKeyId"),
      T.Ec2QueryName("KmsKeyId"),
    ),
  }).pipe(ns),
).annotate({ identifier: "Volume" }) as any as S.Schema<Volume>;
export type VolumeList = Volume[];
export const VolumeList = S.Array(
  Volume.pipe(T.XmlName("item")).annotate({ identifier: "Volume" }),
);
export interface CopyVolumesResult {
  Volumes?: Volume[];
}
export const CopyVolumesResult = S.suspend(() =>
  S.Struct({
    Volumes: S.optional(VolumeList).pipe(
      T.XmlName("volumeSet"),
      T.Ec2QueryName("VolumeSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CopyVolumesResult",
}) as any as S.Schema<CopyVolumesResult>;
export type Schedule = "hourly" | (string & {});
export const Schedule = S.String;
export type OutputFormat = "csv" | "parquet" | (string & {});
export const OutputFormat = S.String;
export interface CreateCapacityManagerDataExportRequest {
  S3BucketName?: string;
  S3BucketPrefix?: string;
  Schedule?: Schedule;
  OutputFormat?: OutputFormat;
  ClientToken?: string;
  DryRun?: boolean;
  TagSpecifications?: TagSpecification[];
}
export const CreateCapacityManagerDataExportRequest = S.suspend(() =>
  S.Struct({
    S3BucketName: S.optional(S.String),
    S3BucketPrefix: S.optional(S.String),
    Schedule: S.optional(Schedule),
    OutputFormat: S.optional(OutputFormat),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateCapacityManagerDataExportRequest",
}) as any as S.Schema<CreateCapacityManagerDataExportRequest>;
export interface CreateCapacityManagerDataExportResult {
  CapacityManagerDataExportId?: string;
}
export const CreateCapacityManagerDataExportResult = S.suspend(() =>
  S.Struct({
    CapacityManagerDataExportId: S.optional(S.String).pipe(
      T.XmlName("capacityManagerDataExportId"),
      T.Ec2QueryName("CapacityManagerDataExportId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateCapacityManagerDataExportResult",
}) as any as S.Schema<CreateCapacityManagerDataExportResult>;
export type CapacityReservationInstancePlatform =
  | "Linux/UNIX"
  | "Red Hat Enterprise Linux"
  | "SUSE Linux"
  | "Windows"
  | "Windows with SQL Server"
  | "Windows with SQL Server Enterprise"
  | "Windows with SQL Server Standard"
  | "Windows with SQL Server Web"
  | "Linux with SQL Server Standard"
  | "Linux with SQL Server Web"
  | "Linux with SQL Server Enterprise"
  | "RHEL with SQL Server Standard"
  | "RHEL with SQL Server Enterprise"
  | "RHEL with SQL Server Web"
  | "RHEL with HA"
  | "RHEL with HA and SQL Server Standard"
  | "RHEL with HA and SQL Server Enterprise"
  | "Ubuntu Pro"
  | (string & {});
export const CapacityReservationInstancePlatform = S.String;
export type CapacityReservationTenancy =
  | "default"
  | "dedicated"
  | (string & {});
export const CapacityReservationTenancy = S.String;
export type EndDateType = "unlimited" | "limited" | (string & {});
export const EndDateType = S.String;
export type InstanceMatchCriteria = "open" | "targeted" | (string & {});
export const InstanceMatchCriteria = S.String;
export type CapacityReservationDeliveryPreference =
  | "fixed"
  | "incremental"
  | (string & {});
export const CapacityReservationDeliveryPreference = S.String;
export interface CreateCapacityReservationRequest {
  ClientToken?: string;
  InstanceType?: string;
  InstancePlatform?: CapacityReservationInstancePlatform;
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  Tenancy?: CapacityReservationTenancy;
  InstanceCount?: number;
  EbsOptimized?: boolean;
  EphemeralStorage?: boolean;
  EndDate?: Date;
  EndDateType?: EndDateType;
  InstanceMatchCriteria?: InstanceMatchCriteria;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
  OutpostArn?: string;
  PlacementGroupArn?: string;
  StartDate?: Date;
  CommitmentDuration?: number;
  DeliveryPreference?: CapacityReservationDeliveryPreference;
}
export const CreateCapacityReservationRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String),
    InstanceType: S.optional(S.String),
    InstancePlatform: S.optional(CapacityReservationInstancePlatform),
    AvailabilityZone: S.optional(S.String),
    AvailabilityZoneId: S.optional(S.String),
    Tenancy: S.optional(CapacityReservationTenancy),
    InstanceCount: S.optional(S.Number),
    EbsOptimized: S.optional(S.Boolean),
    EphemeralStorage: S.optional(S.Boolean),
    EndDate: S.optional(T.DateFromString.pipe(T.TimestampFormat("date-time"))),
    EndDateType: S.optional(EndDateType),
    InstanceMatchCriteria: S.optional(InstanceMatchCriteria),
    TagSpecifications: S.optional(TagSpecificationList),
    DryRun: S.optional(S.Boolean),
    OutpostArn: S.optional(S.String),
    PlacementGroupArn: S.optional(S.String),
    StartDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    CommitmentDuration: S.optional(S.Number),
    DeliveryPreference: S.optional(CapacityReservationDeliveryPreference),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateCapacityReservationRequest",
}) as any as S.Schema<CreateCapacityReservationRequest>;
export type CapacityReservationState =
  | "active"
  | "expired"
  | "cancelled"
  | "pending"
  | "failed"
  | "scheduled"
  | "payment-pending"
  | "payment-failed"
  | "assessing"
  | "delayed"
  | "unsupported"
  | "unavailable"
  | (string & {});
export const CapacityReservationState = S.String;
export type AllocationType = "used" | "future" | (string & {});
export const AllocationType = S.String;
export interface CapacityAllocation {
  AllocationType?: AllocationType;
  Count?: number;
}
export const CapacityAllocation = S.suspend(() =>
  S.Struct({
    AllocationType: S.optional(AllocationType).pipe(
      T.XmlName("allocationType"),
      T.Ec2QueryName("AllocationType"),
    ),
    Count: S.optional(S.Number).pipe(
      T.XmlName("count"),
      T.Ec2QueryName("Count"),
    ),
  }),
).annotate({
  identifier: "CapacityAllocation",
}) as any as S.Schema<CapacityAllocation>;
export type CapacityAllocations = CapacityAllocation[];
export const CapacityAllocations = S.Array(
  CapacityAllocation.pipe(T.XmlName("item")).annotate({
    identifier: "CapacityAllocation",
  }),
);
export type CapacityReservationType =
  | "default"
  | "capacity-block"
  | (string & {});
export const CapacityReservationType = S.String;
export interface CapacityReservationCommitmentInfo {
  CommittedInstanceCount?: number;
  CommitmentEndDate?: Date;
}
export const CapacityReservationCommitmentInfo = S.suspend(() =>
  S.Struct({
    CommittedInstanceCount: S.optional(S.Number).pipe(
      T.XmlName("committedInstanceCount"),
      T.Ec2QueryName("CommittedInstanceCount"),
    ),
    CommitmentEndDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("commitmentEndDate"), T.Ec2QueryName("CommitmentEndDate")),
  }),
).annotate({
  identifier: "CapacityReservationCommitmentInfo",
}) as any as S.Schema<CapacityReservationCommitmentInfo>;
export type InterruptibleCapacityReservationAllocationStatus =
  | "pending"
  | "active"
  | "updating"
  | "canceling"
  | "canceled"
  | "failed"
  | (string & {});
export const InterruptibleCapacityReservationAllocationStatus = S.String;
export type InterruptionType = "adhoc" | (string & {});
export const InterruptionType = S.String;
export interface InterruptibleCapacityAllocation {
  InstanceCount?: number;
  TargetInstanceCount?: number;
  Status?: InterruptibleCapacityReservationAllocationStatus;
  InterruptibleCapacityReservationId?: string;
  InterruptionType?: InterruptionType;
}
export const InterruptibleCapacityAllocation = S.suspend(() =>
  S.Struct({
    InstanceCount: S.optional(S.Number).pipe(
      T.XmlName("instanceCount"),
      T.Ec2QueryName("InstanceCount"),
    ),
    TargetInstanceCount: S.optional(S.Number).pipe(
      T.XmlName("targetInstanceCount"),
      T.Ec2QueryName("TargetInstanceCount"),
    ),
    Status: S.optional(InterruptibleCapacityReservationAllocationStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    InterruptibleCapacityReservationId: S.optional(S.String).pipe(
      T.XmlName("interruptibleCapacityReservationId"),
      T.Ec2QueryName("InterruptibleCapacityReservationId"),
    ),
    InterruptionType: S.optional(InterruptionType).pipe(
      T.XmlName("interruptionType"),
      T.Ec2QueryName("InterruptionType"),
    ),
  }),
).annotate({
  identifier: "InterruptibleCapacityAllocation",
}) as any as S.Schema<InterruptibleCapacityAllocation>;
export interface InterruptionInfo {
  SourceCapacityReservationId?: string;
  InterruptionType?: InterruptionType;
}
export const InterruptionInfo = S.suspend(() =>
  S.Struct({
    SourceCapacityReservationId: S.optional(S.String).pipe(
      T.XmlName("sourceCapacityReservationId"),
      T.Ec2QueryName("SourceCapacityReservationId"),
    ),
    InterruptionType: S.optional(InterruptionType).pipe(
      T.XmlName("interruptionType"),
      T.Ec2QueryName("InterruptionType"),
    ),
  }),
).annotate({
  identifier: "InterruptionInfo",
}) as any as S.Schema<InterruptionInfo>;
export interface CapacityReservation {
  CapacityReservationId?: string;
  OwnerId?: string;
  CapacityReservationArn?: string;
  AvailabilityZoneId?: string;
  InstanceType?: string;
  InstancePlatform?: CapacityReservationInstancePlatform;
  AvailabilityZone?: string;
  Tenancy?: CapacityReservationTenancy;
  TotalInstanceCount?: number;
  AvailableInstanceCount?: number;
  EbsOptimized?: boolean;
  EphemeralStorage?: boolean;
  State?: CapacityReservationState;
  StartDate?: Date;
  EndDate?: Date;
  EndDateType?: EndDateType;
  InstanceMatchCriteria?: InstanceMatchCriteria;
  CreateDate?: Date;
  Tags?: Tag[];
  OutpostArn?: string;
  CapacityReservationFleetId?: string;
  PlacementGroupArn?: string;
  CapacityAllocations?: CapacityAllocation[];
  ReservationType?: CapacityReservationType;
  UnusedReservationBillingOwnerId?: string;
  CommitmentInfo?: CapacityReservationCommitmentInfo;
  DeliveryPreference?: CapacityReservationDeliveryPreference;
  CapacityBlockId?: string;
  Interruptible?: boolean;
  InterruptibleCapacityAllocation?: InterruptibleCapacityAllocation;
  InterruptionInfo?: InterruptionInfo;
}
export const CapacityReservation = S.suspend(() =>
  S.Struct({
    CapacityReservationId: S.optional(S.String).pipe(
      T.XmlName("capacityReservationId"),
      T.Ec2QueryName("CapacityReservationId"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    CapacityReservationArn: S.optional(S.String).pipe(
      T.XmlName("capacityReservationArn"),
      T.Ec2QueryName("CapacityReservationArn"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    InstanceType: S.optional(S.String).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    InstancePlatform: S.optional(CapacityReservationInstancePlatform).pipe(
      T.XmlName("instancePlatform"),
      T.Ec2QueryName("InstancePlatform"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    Tenancy: S.optional(CapacityReservationTenancy).pipe(
      T.XmlName("tenancy"),
      T.Ec2QueryName("Tenancy"),
    ),
    TotalInstanceCount: S.optional(S.Number).pipe(
      T.XmlName("totalInstanceCount"),
      T.Ec2QueryName("TotalInstanceCount"),
    ),
    AvailableInstanceCount: S.optional(S.Number).pipe(
      T.XmlName("availableInstanceCount"),
      T.Ec2QueryName("AvailableInstanceCount"),
    ),
    EbsOptimized: S.optional(S.Boolean).pipe(
      T.XmlName("ebsOptimized"),
      T.Ec2QueryName("EbsOptimized"),
    ),
    EphemeralStorage: S.optional(S.Boolean).pipe(
      T.XmlName("ephemeralStorage"),
      T.Ec2QueryName("EphemeralStorage"),
    ),
    State: S.optional(CapacityReservationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StartDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startDate"), T.Ec2QueryName("StartDate")),
    EndDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("endDate"), T.Ec2QueryName("EndDate")),
    EndDateType: S.optional(EndDateType).pipe(
      T.XmlName("endDateType"),
      T.Ec2QueryName("EndDateType"),
    ),
    InstanceMatchCriteria: S.optional(InstanceMatchCriteria).pipe(
      T.XmlName("instanceMatchCriteria"),
      T.Ec2QueryName("InstanceMatchCriteria"),
    ),
    CreateDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createDate"), T.Ec2QueryName("CreateDate")),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    OutpostArn: S.optional(S.String).pipe(
      T.XmlName("outpostArn"),
      T.Ec2QueryName("OutpostArn"),
    ),
    CapacityReservationFleetId: S.optional(S.String).pipe(
      T.XmlName("capacityReservationFleetId"),
      T.Ec2QueryName("CapacityReservationFleetId"),
    ),
    PlacementGroupArn: S.optional(S.String).pipe(
      T.XmlName("placementGroupArn"),
      T.Ec2QueryName("PlacementGroupArn"),
    ),
    CapacityAllocations: S.optional(CapacityAllocations).pipe(
      T.XmlName("capacityAllocationSet"),
      T.Ec2QueryName("CapacityAllocationSet"),
    ),
    ReservationType: S.optional(CapacityReservationType).pipe(
      T.XmlName("reservationType"),
      T.Ec2QueryName("ReservationType"),
    ),
    UnusedReservationBillingOwnerId: S.optional(S.String).pipe(
      T.XmlName("unusedReservationBillingOwnerId"),
      T.Ec2QueryName("UnusedReservationBillingOwnerId"),
    ),
    CommitmentInfo: S.optional(CapacityReservationCommitmentInfo)
      .pipe(T.XmlName("commitmentInfo"), T.Ec2QueryName("CommitmentInfo"))
      .annotate({ identifier: "CapacityReservationCommitmentInfo" }),
    DeliveryPreference: S.optional(CapacityReservationDeliveryPreference).pipe(
      T.XmlName("deliveryPreference"),
      T.Ec2QueryName("DeliveryPreference"),
    ),
    CapacityBlockId: S.optional(S.String).pipe(
      T.XmlName("capacityBlockId"),
      T.Ec2QueryName("CapacityBlockId"),
    ),
    Interruptible: S.optional(S.Boolean).pipe(
      T.XmlName("interruptible"),
      T.Ec2QueryName("Interruptible"),
    ),
    InterruptibleCapacityAllocation: S.optional(InterruptibleCapacityAllocation)
      .pipe(
        T.XmlName("interruptibleCapacityAllocation"),
        T.Ec2QueryName("InterruptibleCapacityAllocation"),
      )
      .annotate({ identifier: "InterruptibleCapacityAllocation" }),
    InterruptionInfo: S.optional(InterruptionInfo)
      .pipe(T.XmlName("interruptionInfo"), T.Ec2QueryName("InterruptionInfo"))
      .annotate({ identifier: "InterruptionInfo" }),
  }),
).annotate({
  identifier: "CapacityReservation",
}) as any as S.Schema<CapacityReservation>;
export interface CreateCapacityReservationResult {
  CapacityReservation?: CapacityReservation;
}
export const CreateCapacityReservationResult = S.suspend(() =>
  S.Struct({
    CapacityReservation: S.optional(CapacityReservation)
      .pipe(
        T.XmlName("capacityReservation"),
        T.Ec2QueryName("CapacityReservation"),
      )
      .annotate({ identifier: "CapacityReservation" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateCapacityReservationResult",
}) as any as S.Schema<CreateCapacityReservationResult>;
export interface CreateCapacityReservationBySplittingRequest {
  DryRun?: boolean;
  ClientToken?: string;
  SourceCapacityReservationId?: string;
  InstanceCount?: number;
  TagSpecifications?: TagSpecification[];
}
export const CreateCapacityReservationBySplittingRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    SourceCapacityReservationId: S.optional(S.String),
    InstanceCount: S.optional(S.Number),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateCapacityReservationBySplittingRequest",
}) as any as S.Schema<CreateCapacityReservationBySplittingRequest>;
export interface CreateCapacityReservationBySplittingResult {
  SourceCapacityReservation?: CapacityReservation;
  DestinationCapacityReservation?: CapacityReservation;
  InstanceCount?: number;
}
export const CreateCapacityReservationBySplittingResult = S.suspend(() =>
  S.Struct({
    SourceCapacityReservation: S.optional(CapacityReservation)
      .pipe(
        T.XmlName("sourceCapacityReservation"),
        T.Ec2QueryName("SourceCapacityReservation"),
      )
      .annotate({ identifier: "CapacityReservation" }),
    DestinationCapacityReservation: S.optional(CapacityReservation)
      .pipe(
        T.XmlName("destinationCapacityReservation"),
        T.Ec2QueryName("DestinationCapacityReservation"),
      )
      .annotate({ identifier: "CapacityReservation" }),
    InstanceCount: S.optional(S.Number).pipe(
      T.XmlName("instanceCount"),
      T.Ec2QueryName("InstanceCount"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateCapacityReservationBySplittingResult",
}) as any as S.Schema<CreateCapacityReservationBySplittingResult>;
export type InstanceType =
  | "a1.medium"
  | "a1.large"
  | "a1.xlarge"
  | "a1.2xlarge"
  | "a1.4xlarge"
  | "a1.metal"
  | "c1.medium"
  | "c1.xlarge"
  | "c3.large"
  | "c3.xlarge"
  | "c3.2xlarge"
  | "c3.4xlarge"
  | "c3.8xlarge"
  | "c4.large"
  | "c4.xlarge"
  | "c4.2xlarge"
  | "c4.4xlarge"
  | "c4.8xlarge"
  | "c5.large"
  | "c5.xlarge"
  | "c5.2xlarge"
  | "c5.4xlarge"
  | "c5.9xlarge"
  | "c5.12xlarge"
  | "c5.18xlarge"
  | "c5.24xlarge"
  | "c5.metal"
  | "c5a.large"
  | "c5a.xlarge"
  | "c5a.2xlarge"
  | "c5a.4xlarge"
  | "c5a.8xlarge"
  | "c5a.12xlarge"
  | "c5a.16xlarge"
  | "c5a.24xlarge"
  | "c5ad.large"
  | "c5ad.xlarge"
  | "c5ad.2xlarge"
  | "c5ad.4xlarge"
  | "c5ad.8xlarge"
  | "c5ad.12xlarge"
  | "c5ad.16xlarge"
  | "c5ad.24xlarge"
  | "c5d.large"
  | "c5d.xlarge"
  | "c5d.2xlarge"
  | "c5d.4xlarge"
  | "c5d.9xlarge"
  | "c5d.12xlarge"
  | "c5d.18xlarge"
  | "c5d.24xlarge"
  | "c5d.metal"
  | "c5n.large"
  | "c5n.xlarge"
  | "c5n.2xlarge"
  | "c5n.4xlarge"
  | "c5n.9xlarge"
  | "c5n.18xlarge"
  | "c5n.metal"
  | "c6g.medium"
  | "c6g.large"
  | "c6g.xlarge"
  | "c6g.2xlarge"
  | "c6g.4xlarge"
  | "c6g.8xlarge"
  | "c6g.12xlarge"
  | "c6g.16xlarge"
  | "c6g.metal"
  | "c6gd.medium"
  | "c6gd.large"
  | "c6gd.xlarge"
  | "c6gd.2xlarge"
  | "c6gd.4xlarge"
  | "c6gd.8xlarge"
  | "c6gd.12xlarge"
  | "c6gd.16xlarge"
  | "c6gd.metal"
  | "c6gn.medium"
  | "c6gn.large"
  | "c6gn.xlarge"
  | "c6gn.2xlarge"
  | "c6gn.4xlarge"
  | "c6gn.8xlarge"
  | "c6gn.12xlarge"
  | "c6gn.16xlarge"
  | "c6i.large"
  | "c6i.xlarge"
  | "c6i.2xlarge"
  | "c6i.4xlarge"
  | "c6i.8xlarge"
  | "c6i.12xlarge"
  | "c6i.16xlarge"
  | "c6i.24xlarge"
  | "c6i.32xlarge"
  | "c6i.metal"
  | "cc1.4xlarge"
  | "cc2.8xlarge"
  | "cg1.4xlarge"
  | "cr1.8xlarge"
  | "d2.xlarge"
  | "d2.2xlarge"
  | "d2.4xlarge"
  | "d2.8xlarge"
  | "d3.xlarge"
  | "d3.2xlarge"
  | "d3.4xlarge"
  | "d3.8xlarge"
  | "d3en.xlarge"
  | "d3en.2xlarge"
  | "d3en.4xlarge"
  | "d3en.6xlarge"
  | "d3en.8xlarge"
  | "d3en.12xlarge"
  | "dl1.24xlarge"
  | "f1.2xlarge"
  | "f1.4xlarge"
  | "f1.16xlarge"
  | "g2.2xlarge"
  | "g2.8xlarge"
  | "g3.4xlarge"
  | "g3.8xlarge"
  | "g3.16xlarge"
  | "g3s.xlarge"
  | "g4ad.xlarge"
  | "g4ad.2xlarge"
  | "g4ad.4xlarge"
  | "g4ad.8xlarge"
  | "g4ad.16xlarge"
  | "g4dn.xlarge"
  | "g4dn.2xlarge"
  | "g4dn.4xlarge"
  | "g4dn.8xlarge"
  | "g4dn.12xlarge"
  | "g4dn.16xlarge"
  | "g4dn.metal"
  | "g5.xlarge"
  | "g5.2xlarge"
  | "g5.4xlarge"
  | "g5.8xlarge"
  | "g5.12xlarge"
  | "g5.16xlarge"
  | "g5.24xlarge"
  | "g5.48xlarge"
  | "g5g.xlarge"
  | "g5g.2xlarge"
  | "g5g.4xlarge"
  | "g5g.8xlarge"
  | "g5g.16xlarge"
  | "g5g.metal"
  | "hi1.4xlarge"
  | "hpc6a.48xlarge"
  | "hs1.8xlarge"
  | "h1.2xlarge"
  | "h1.4xlarge"
  | "h1.8xlarge"
  | "h1.16xlarge"
  | "i2.xlarge"
  | "i2.2xlarge"
  | "i2.4xlarge"
  | "i2.8xlarge"
  | "i3.large"
  | "i3.xlarge"
  | "i3.2xlarge"
  | "i3.4xlarge"
  | "i3.8xlarge"
  | "i3.16xlarge"
  | "i3.metal"
  | "i3en.large"
  | "i3en.xlarge"
  | "i3en.2xlarge"
  | "i3en.3xlarge"
  | "i3en.6xlarge"
  | "i3en.12xlarge"
  | "i3en.24xlarge"
  | "i3en.metal"
  | "im4gn.large"
  | "im4gn.xlarge"
  | "im4gn.2xlarge"
  | "im4gn.4xlarge"
  | "im4gn.8xlarge"
  | "im4gn.16xlarge"
  | "inf1.xlarge"
  | "inf1.2xlarge"
  | "inf1.6xlarge"
  | "inf1.24xlarge"
  | "is4gen.medium"
  | "is4gen.large"
  | "is4gen.xlarge"
  | "is4gen.2xlarge"
  | "is4gen.4xlarge"
  | "is4gen.8xlarge"
  | "m1.small"
  | "m1.medium"
  | "m1.large"
  | "m1.xlarge"
  | "m2.xlarge"
  | "m2.2xlarge"
  | "m2.4xlarge"
  | "m3.medium"
  | "m3.large"
  | "m3.xlarge"
  | "m3.2xlarge"
  | "m4.large"
  | "m4.xlarge"
  | "m4.2xlarge"
  | "m4.4xlarge"
  | "m4.10xlarge"
  | "m4.16xlarge"
  | "m5.large"
  | "m5.xlarge"
  | "m5.2xlarge"
  | "m5.4xlarge"
  | "m5.8xlarge"
  | "m5.12xlarge"
  | "m5.16xlarge"
  | "m5.24xlarge"
  | "m5.metal"
  | "m5a.large"
  | "m5a.xlarge"
  | "m5a.2xlarge"
  | "m5a.4xlarge"
  | "m5a.8xlarge"
  | "m5a.12xlarge"
  | "m5a.16xlarge"
  | "m5a.24xlarge"
  | "m5ad.large"
  | "m5ad.xlarge"
  | "m5ad.2xlarge"
  | "m5ad.4xlarge"
  | "m5ad.8xlarge"
  | "m5ad.12xlarge"
  | "m5ad.16xlarge"
  | "m5ad.24xlarge"
  | "m5d.large"
  | "m5d.xlarge"
  | "m5d.2xlarge"
  | "m5d.4xlarge"
  | "m5d.8xlarge"
  | "m5d.12xlarge"
  | "m5d.16xlarge"
  | "m5d.24xlarge"
  | "m5d.metal"
  | "m5dn.large"
  | "m5dn.xlarge"
  | "m5dn.2xlarge"
  | "m5dn.4xlarge"
  | "m5dn.8xlarge"
  | "m5dn.12xlarge"
  | "m5dn.16xlarge"
  | "m5dn.24xlarge"
  | "m5dn.metal"
  | "m5n.large"
  | "m5n.xlarge"
  | "m5n.2xlarge"
  | "m5n.4xlarge"
  | "m5n.8xlarge"
  | "m5n.12xlarge"
  | "m5n.16xlarge"
  | "m5n.24xlarge"
  | "m5n.metal"
  | "m5zn.large"
  | "m5zn.xlarge"
  | "m5zn.2xlarge"
  | "m5zn.3xlarge"
  | "m5zn.6xlarge"
  | "m5zn.12xlarge"
  | "m5zn.metal"
  | "m6a.large"
  | "m6a.xlarge"
  | "m6a.2xlarge"
  | "m6a.4xlarge"
  | "m6a.8xlarge"
  | "m6a.12xlarge"
  | "m6a.16xlarge"
  | "m6a.24xlarge"
  | "m6a.32xlarge"
  | "m6a.48xlarge"
  | "m6g.metal"
  | "m6g.medium"
  | "m6g.large"
  | "m6g.xlarge"
  | "m6g.2xlarge"
  | "m6g.4xlarge"
  | "m6g.8xlarge"
  | "m6g.12xlarge"
  | "m6g.16xlarge"
  | "m6gd.metal"
  | "m6gd.medium"
  | "m6gd.large"
  | "m6gd.xlarge"
  | "m6gd.2xlarge"
  | "m6gd.4xlarge"
  | "m6gd.8xlarge"
  | "m6gd.12xlarge"
  | "m6gd.16xlarge"
  | "m6i.large"
  | "m6i.xlarge"
  | "m6i.2xlarge"
  | "m6i.4xlarge"
  | "m6i.8xlarge"
  | "m6i.12xlarge"
  | "m6i.16xlarge"
  | "m6i.24xlarge"
  | "m6i.32xlarge"
  | "m6i.metal"
  | "mac1.metal"
  | "p2.xlarge"
  | "p2.8xlarge"
  | "p2.16xlarge"
  | "p3.2xlarge"
  | "p3.8xlarge"
  | "p3.16xlarge"
  | "p3dn.24xlarge"
  | "p4d.24xlarge"
  | "r3.large"
  | "r3.xlarge"
  | "r3.2xlarge"
  | "r3.4xlarge"
  | "r3.8xlarge"
  | "r4.large"
  | "r4.xlarge"
  | "r4.2xlarge"
  | "r4.4xlarge"
  | "r4.8xlarge"
  | "r4.16xlarge"
  | "r5.large"
  | "r5.xlarge"
  | "r5.2xlarge"
  | "r5.4xlarge"
  | "r5.8xlarge"
  | "r5.12xlarge"
  | "r5.16xlarge"
  | "r5.24xlarge"
  | "r5.metal"
  | "r5a.large"
  | "r5a.xlarge"
  | "r5a.2xlarge"
  | "r5a.4xlarge"
  | "r5a.8xlarge"
  | "r5a.12xlarge"
  | "r5a.16xlarge"
  | "r5a.24xlarge"
  | "r5ad.large"
  | "r5ad.xlarge"
  | "r5ad.2xlarge"
  | "r5ad.4xlarge"
  | "r5ad.8xlarge"
  | "r5ad.12xlarge"
  | "r5ad.16xlarge"
  | "r5ad.24xlarge"
  | "r5b.large"
  | "r5b.xlarge"
  | "r5b.2xlarge"
  | "r5b.4xlarge"
  | "r5b.8xlarge"
  | "r5b.12xlarge"
  | "r5b.16xlarge"
  | "r5b.24xlarge"
  | "r5b.metal"
  | "r5d.large"
  | "r5d.xlarge"
  | "r5d.2xlarge"
  | "r5d.4xlarge"
  | "r5d.8xlarge"
  | "r5d.12xlarge"
  | "r5d.16xlarge"
  | "r5d.24xlarge"
  | "r5d.metal"
  | "r5dn.large"
  | "r5dn.xlarge"
  | "r5dn.2xlarge"
  | "r5dn.4xlarge"
  | "r5dn.8xlarge"
  | "r5dn.12xlarge"
  | "r5dn.16xlarge"
  | "r5dn.24xlarge"
  | "r5dn.metal"
  | "r5n.large"
  | "r5n.xlarge"
  | "r5n.2xlarge"
  | "r5n.4xlarge"
  | "r5n.8xlarge"
  | "r5n.12xlarge"
  | "r5n.16xlarge"
  | "r5n.24xlarge"
  | "r5n.metal"
  | "r6g.medium"
  | "r6g.large"
  | "r6g.xlarge"
  | "r6g.2xlarge"
  | "r6g.4xlarge"
  | "r6g.8xlarge"
  | "r6g.12xlarge"
  | "r6g.16xlarge"
  | "r6g.metal"
  | "r6gd.medium"
  | "r6gd.large"
  | "r6gd.xlarge"
  | "r6gd.2xlarge"
  | "r6gd.4xlarge"
  | "r6gd.8xlarge"
  | "r6gd.12xlarge"
  | "r6gd.16xlarge"
  | "r6gd.metal"
  | "r6i.large"
  | "r6i.xlarge"
  | "r6i.2xlarge"
  | "r6i.4xlarge"
  | "r6i.8xlarge"
  | "r6i.12xlarge"
  | "r6i.16xlarge"
  | "r6i.24xlarge"
  | "r6i.32xlarge"
  | "r6i.metal"
  | "t1.micro"
  | "t2.nano"
  | "t2.micro"
  | "t2.small"
  | "t2.medium"
  | "t2.large"
  | "t2.xlarge"
  | "t2.2xlarge"
  | "t3.nano"
  | "t3.micro"
  | "t3.small"
  | "t3.medium"
  | "t3.large"
  | "t3.xlarge"
  | "t3.2xlarge"
  | "t3a.nano"
  | "t3a.micro"
  | "t3a.small"
  | "t3a.medium"
  | "t3a.large"
  | "t3a.xlarge"
  | "t3a.2xlarge"
  | "t4g.nano"
  | "t4g.micro"
  | "t4g.small"
  | "t4g.medium"
  | "t4g.large"
  | "t4g.xlarge"
  | "t4g.2xlarge"
  | "u-6tb1.56xlarge"
  | "u-6tb1.112xlarge"
  | "u-9tb1.112xlarge"
  | "u-12tb1.112xlarge"
  | "u-6tb1.metal"
  | "u-9tb1.metal"
  | "u-12tb1.metal"
  | "u-18tb1.metal"
  | "u-24tb1.metal"
  | "vt1.3xlarge"
  | "vt1.6xlarge"
  | "vt1.24xlarge"
  | "x1.16xlarge"
  | "x1.32xlarge"
  | "x1e.xlarge"
  | "x1e.2xlarge"
  | "x1e.4xlarge"
  | "x1e.8xlarge"
  | "x1e.16xlarge"
  | "x1e.32xlarge"
  | "x2iezn.2xlarge"
  | "x2iezn.4xlarge"
  | "x2iezn.6xlarge"
  | "x2iezn.8xlarge"
  | "x2iezn.12xlarge"
  | "x2iezn.metal"
  | "x2gd.medium"
  | "x2gd.large"
  | "x2gd.xlarge"
  | "x2gd.2xlarge"
  | "x2gd.4xlarge"
  | "x2gd.8xlarge"
  | "x2gd.12xlarge"
  | "x2gd.16xlarge"
  | "x2gd.metal"
  | "z1d.large"
  | "z1d.xlarge"
  | "z1d.2xlarge"
  | "z1d.3xlarge"
  | "z1d.6xlarge"
  | "z1d.12xlarge"
  | "z1d.metal"
  | "x2idn.16xlarge"
  | "x2idn.24xlarge"
  | "x2idn.32xlarge"
  | "x2iedn.xlarge"
  | "x2iedn.2xlarge"
  | "x2iedn.4xlarge"
  | "x2iedn.8xlarge"
  | "x2iedn.16xlarge"
  | "x2iedn.24xlarge"
  | "x2iedn.32xlarge"
  | "c6a.large"
  | "c6a.xlarge"
  | "c6a.2xlarge"
  | "c6a.4xlarge"
  | "c6a.8xlarge"
  | "c6a.12xlarge"
  | "c6a.16xlarge"
  | "c6a.24xlarge"
  | "c6a.32xlarge"
  | "c6a.48xlarge"
  | "c6a.metal"
  | "m6a.metal"
  | "i4i.large"
  | "i4i.xlarge"
  | "i4i.2xlarge"
  | "i4i.4xlarge"
  | "i4i.8xlarge"
  | "i4i.16xlarge"
  | "i4i.32xlarge"
  | "i4i.metal"
  | "x2idn.metal"
  | "x2iedn.metal"
  | "c7g.medium"
  | "c7g.large"
  | "c7g.xlarge"
  | "c7g.2xlarge"
  | "c7g.4xlarge"
  | "c7g.8xlarge"
  | "c7g.12xlarge"
  | "c7g.16xlarge"
  | "mac2.metal"
  | "c6id.large"
  | "c6id.xlarge"
  | "c6id.2xlarge"
  | "c6id.4xlarge"
  | "c6id.8xlarge"
  | "c6id.12xlarge"
  | "c6id.16xlarge"
  | "c6id.24xlarge"
  | "c6id.32xlarge"
  | "c6id.metal"
  | "m6id.large"
  | "m6id.xlarge"
  | "m6id.2xlarge"
  | "m6id.4xlarge"
  | "m6id.8xlarge"
  | "m6id.12xlarge"
  | "m6id.16xlarge"
  | "m6id.24xlarge"
  | "m6id.32xlarge"
  | "m6id.metal"
  | "r6id.large"
  | "r6id.xlarge"
  | "r6id.2xlarge"
  | "r6id.4xlarge"
  | "r6id.8xlarge"
  | "r6id.12xlarge"
  | "r6id.16xlarge"
  | "r6id.24xlarge"
  | "r6id.32xlarge"
  | "r6id.metal"
  | "r6a.large"
  | "r6a.xlarge"
  | "r6a.2xlarge"
  | "r6a.4xlarge"
  | "r6a.8xlarge"
  | "r6a.12xlarge"
  | "r6a.16xlarge"
  | "r6a.24xlarge"
  | "r6a.32xlarge"
  | "r6a.48xlarge"
  | "r6a.metal"
  | "p4de.24xlarge"
  | "u-3tb1.56xlarge"
  | "u-18tb1.112xlarge"
  | "u-24tb1.112xlarge"
  | "trn1.2xlarge"
  | "trn1.32xlarge"
  | "hpc6id.32xlarge"
  | "c6in.large"
  | "c6in.xlarge"
  | "c6in.2xlarge"
  | "c6in.4xlarge"
  | "c6in.8xlarge"
  | "c6in.12xlarge"
  | "c6in.16xlarge"
  | "c6in.24xlarge"
  | "c6in.32xlarge"
  | "m6in.large"
  | "m6in.xlarge"
  | "m6in.2xlarge"
  | "m6in.4xlarge"
  | "m6in.8xlarge"
  | "m6in.12xlarge"
  | "m6in.16xlarge"
  | "m6in.24xlarge"
  | "m6in.32xlarge"
  | "m6idn.large"
  | "m6idn.xlarge"
  | "m6idn.2xlarge"
  | "m6idn.4xlarge"
  | "m6idn.8xlarge"
  | "m6idn.12xlarge"
  | "m6idn.16xlarge"
  | "m6idn.24xlarge"
  | "m6idn.32xlarge"
  | "r6in.large"
  | "r6in.xlarge"
  | "r6in.2xlarge"
  | "r6in.4xlarge"
  | "r6in.8xlarge"
  | "r6in.12xlarge"
  | "r6in.16xlarge"
  | "r6in.24xlarge"
  | "r6in.32xlarge"
  | "r6idn.large"
  | "r6idn.xlarge"
  | "r6idn.2xlarge"
  | "r6idn.4xlarge"
  | "r6idn.8xlarge"
  | "r6idn.12xlarge"
  | "r6idn.16xlarge"
  | "r6idn.24xlarge"
  | "r6idn.32xlarge"
  | "c7g.metal"
  | "m7g.medium"
  | "m7g.large"
  | "m7g.xlarge"
  | "m7g.2xlarge"
  | "m7g.4xlarge"
  | "m7g.8xlarge"
  | "m7g.12xlarge"
  | "m7g.16xlarge"
  | "m7g.metal"
  | "r7g.medium"
  | "r7g.large"
  | "r7g.xlarge"
  | "r7g.2xlarge"
  | "r7g.4xlarge"
  | "r7g.8xlarge"
  | "r7g.12xlarge"
  | "r7g.16xlarge"
  | "r7g.metal"
  | "c6in.metal"
  | "m6in.metal"
  | "m6idn.metal"
  | "r6in.metal"
  | "r6idn.metal"
  | "inf2.xlarge"
  | "inf2.8xlarge"
  | "inf2.24xlarge"
  | "inf2.48xlarge"
  | "trn1n.32xlarge"
  | "i4g.large"
  | "i4g.xlarge"
  | "i4g.2xlarge"
  | "i4g.4xlarge"
  | "i4g.8xlarge"
  | "i4g.16xlarge"
  | "hpc7g.4xlarge"
  | "hpc7g.8xlarge"
  | "hpc7g.16xlarge"
  | "c7gn.medium"
  | "c7gn.large"
  | "c7gn.xlarge"
  | "c7gn.2xlarge"
  | "c7gn.4xlarge"
  | "c7gn.8xlarge"
  | "c7gn.12xlarge"
  | "c7gn.16xlarge"
  | "p5.48xlarge"
  | "m7i.large"
  | "m7i.xlarge"
  | "m7i.2xlarge"
  | "m7i.4xlarge"
  | "m7i.8xlarge"
  | "m7i.12xlarge"
  | "m7i.16xlarge"
  | "m7i.24xlarge"
  | "m7i.48xlarge"
  | "m7i-flex.large"
  | "m7i-flex.xlarge"
  | "m7i-flex.2xlarge"
  | "m7i-flex.4xlarge"
  | "m7i-flex.8xlarge"
  | "m7a.medium"
  | "m7a.large"
  | "m7a.xlarge"
  | "m7a.2xlarge"
  | "m7a.4xlarge"
  | "m7a.8xlarge"
  | "m7a.12xlarge"
  | "m7a.16xlarge"
  | "m7a.24xlarge"
  | "m7a.32xlarge"
  | "m7a.48xlarge"
  | "m7a.metal-48xl"
  | "hpc7a.12xlarge"
  | "hpc7a.24xlarge"
  | "hpc7a.48xlarge"
  | "hpc7a.96xlarge"
  | "c7gd.medium"
  | "c7gd.large"
  | "c7gd.xlarge"
  | "c7gd.2xlarge"
  | "c7gd.4xlarge"
  | "c7gd.8xlarge"
  | "c7gd.12xlarge"
  | "c7gd.16xlarge"
  | "m7gd.medium"
  | "m7gd.large"
  | "m7gd.xlarge"
  | "m7gd.2xlarge"
  | "m7gd.4xlarge"
  | "m7gd.8xlarge"
  | "m7gd.12xlarge"
  | "m7gd.16xlarge"
  | "r7gd.medium"
  | "r7gd.large"
  | "r7gd.xlarge"
  | "r7gd.2xlarge"
  | "r7gd.4xlarge"
  | "r7gd.8xlarge"
  | "r7gd.12xlarge"
  | "r7gd.16xlarge"
  | "r7a.medium"
  | "r7a.large"
  | "r7a.xlarge"
  | "r7a.2xlarge"
  | "r7a.4xlarge"
  | "r7a.8xlarge"
  | "r7a.12xlarge"
  | "r7a.16xlarge"
  | "r7a.24xlarge"
  | "r7a.32xlarge"
  | "r7a.48xlarge"
  | "c7i.large"
  | "c7i.xlarge"
  | "c7i.2xlarge"
  | "c7i.4xlarge"
  | "c7i.8xlarge"
  | "c7i.12xlarge"
  | "c7i.16xlarge"
  | "c7i.24xlarge"
  | "c7i.48xlarge"
  | "mac2-m2pro.metal"
  | "r7iz.large"
  | "r7iz.xlarge"
  | "r7iz.2xlarge"
  | "r7iz.4xlarge"
  | "r7iz.8xlarge"
  | "r7iz.12xlarge"
  | "r7iz.16xlarge"
  | "r7iz.32xlarge"
  | "c7a.medium"
  | "c7a.large"
  | "c7a.xlarge"
  | "c7a.2xlarge"
  | "c7a.4xlarge"
  | "c7a.8xlarge"
  | "c7a.12xlarge"
  | "c7a.16xlarge"
  | "c7a.24xlarge"
  | "c7a.32xlarge"
  | "c7a.48xlarge"
  | "c7a.metal-48xl"
  | "r7a.metal-48xl"
  | "r7i.large"
  | "r7i.xlarge"
  | "r7i.2xlarge"
  | "r7i.4xlarge"
  | "r7i.8xlarge"
  | "r7i.12xlarge"
  | "r7i.16xlarge"
  | "r7i.24xlarge"
  | "r7i.48xlarge"
  | "dl2q.24xlarge"
  | "mac2-m2.metal"
  | "i4i.12xlarge"
  | "i4i.24xlarge"
  | "c7i.metal-24xl"
  | "c7i.metal-48xl"
  | "m7i.metal-24xl"
  | "m7i.metal-48xl"
  | "r7i.metal-24xl"
  | "r7i.metal-48xl"
  | "r7iz.metal-16xl"
  | "r7iz.metal-32xl"
  | "c7gd.metal"
  | "m7gd.metal"
  | "r7gd.metal"
  | "g6.xlarge"
  | "g6.2xlarge"
  | "g6.4xlarge"
  | "g6.8xlarge"
  | "g6.12xlarge"
  | "g6.16xlarge"
  | "g6.24xlarge"
  | "g6.48xlarge"
  | "gr6.4xlarge"
  | "gr6.8xlarge"
  | "c7i-flex.large"
  | "c7i-flex.xlarge"
  | "c7i-flex.2xlarge"
  | "c7i-flex.4xlarge"
  | "c7i-flex.8xlarge"
  | "u7i-12tb.224xlarge"
  | "u7in-16tb.224xlarge"
  | "u7in-24tb.224xlarge"
  | "u7in-32tb.224xlarge"
  | "u7ib-12tb.224xlarge"
  | "c7gn.metal"
  | "r8g.medium"
  | "r8g.large"
  | "r8g.xlarge"
  | "r8g.2xlarge"
  | "r8g.4xlarge"
  | "r8g.8xlarge"
  | "r8g.12xlarge"
  | "r8g.16xlarge"
  | "r8g.24xlarge"
  | "r8g.48xlarge"
  | "r8g.metal-24xl"
  | "r8g.metal-48xl"
  | "mac2-m1ultra.metal"
  | "g6e.xlarge"
  | "g6e.2xlarge"
  | "g6e.4xlarge"
  | "g6e.8xlarge"
  | "g6e.12xlarge"
  | "g6e.16xlarge"
  | "g6e.24xlarge"
  | "g6e.48xlarge"
  | "c8g.medium"
  | "c8g.large"
  | "c8g.xlarge"
  | "c8g.2xlarge"
  | "c8g.4xlarge"
  | "c8g.8xlarge"
  | "c8g.12xlarge"
  | "c8g.16xlarge"
  | "c8g.24xlarge"
  | "c8g.48xlarge"
  | "c8g.metal-24xl"
  | "c8g.metal-48xl"
  | "m8g.medium"
  | "m8g.large"
  | "m8g.xlarge"
  | "m8g.2xlarge"
  | "m8g.4xlarge"
  | "m8g.8xlarge"
  | "m8g.12xlarge"
  | "m8g.16xlarge"
  | "m8g.24xlarge"
  | "m8g.48xlarge"
  | "m8g.metal-24xl"
  | "m8g.metal-48xl"
  | "x8g.medium"
  | "x8g.large"
  | "x8g.xlarge"
  | "x8g.2xlarge"
  | "x8g.4xlarge"
  | "x8g.8xlarge"
  | "x8g.12xlarge"
  | "x8g.16xlarge"
  | "x8g.24xlarge"
  | "x8g.48xlarge"
  | "x8g.metal-24xl"
  | "x8g.metal-48xl"
  | "i7ie.large"
  | "i7ie.xlarge"
  | "i7ie.2xlarge"
  | "i7ie.3xlarge"
  | "i7ie.6xlarge"
  | "i7ie.12xlarge"
  | "i7ie.18xlarge"
  | "i7ie.24xlarge"
  | "i7ie.48xlarge"
  | "i8g.large"
  | "i8g.xlarge"
  | "i8g.2xlarge"
  | "i8g.4xlarge"
  | "i8g.8xlarge"
  | "i8g.12xlarge"
  | "i8g.16xlarge"
  | "i8g.24xlarge"
  | "i8g.metal-24xl"
  | "u7i-6tb.112xlarge"
  | "u7i-8tb.112xlarge"
  | "u7inh-32tb.480xlarge"
  | "p5e.48xlarge"
  | "p5en.48xlarge"
  | "f2.12xlarge"
  | "f2.48xlarge"
  | "trn2.48xlarge"
  | "c7i-flex.12xlarge"
  | "c7i-flex.16xlarge"
  | "m7i-flex.12xlarge"
  | "m7i-flex.16xlarge"
  | "i7ie.metal-24xl"
  | "i7ie.metal-48xl"
  | "i8g.48xlarge"
  | "c8gd.medium"
  | "c8gd.large"
  | "c8gd.xlarge"
  | "c8gd.2xlarge"
  | "c8gd.4xlarge"
  | "c8gd.8xlarge"
  | "c8gd.12xlarge"
  | "c8gd.16xlarge"
  | "c8gd.24xlarge"
  | "c8gd.48xlarge"
  | "c8gd.metal-24xl"
  | "c8gd.metal-48xl"
  | "i7i.large"
  | "i7i.xlarge"
  | "i7i.2xlarge"
  | "i7i.4xlarge"
  | "i7i.8xlarge"
  | "i7i.12xlarge"
  | "i7i.16xlarge"
  | "i7i.24xlarge"
  | "i7i.48xlarge"
  | "i7i.metal-24xl"
  | "i7i.metal-48xl"
  | "p6-b200.48xlarge"
  | "m8gd.medium"
  | "m8gd.large"
  | "m8gd.xlarge"
  | "m8gd.2xlarge"
  | "m8gd.4xlarge"
  | "m8gd.8xlarge"
  | "m8gd.12xlarge"
  | "m8gd.16xlarge"
  | "m8gd.24xlarge"
  | "m8gd.48xlarge"
  | "m8gd.metal-24xl"
  | "m8gd.metal-48xl"
  | "r8gd.medium"
  | "r8gd.large"
  | "r8gd.xlarge"
  | "r8gd.2xlarge"
  | "r8gd.4xlarge"
  | "r8gd.8xlarge"
  | "r8gd.12xlarge"
  | "r8gd.16xlarge"
  | "r8gd.24xlarge"
  | "r8gd.48xlarge"
  | "r8gd.metal-24xl"
  | "r8gd.metal-48xl"
  | "c8gn.medium"
  | "c8gn.large"
  | "c8gn.xlarge"
  | "c8gn.2xlarge"
  | "c8gn.4xlarge"
  | "c8gn.8xlarge"
  | "c8gn.12xlarge"
  | "c8gn.16xlarge"
  | "c8gn.24xlarge"
  | "c8gn.48xlarge"
  | "c8gn.metal-24xl"
  | "c8gn.metal-48xl"
  | "f2.6xlarge"
  | "p6e-gb200.36xlarge"
  | "g6f.large"
  | "g6f.xlarge"
  | "g6f.2xlarge"
  | "g6f.4xlarge"
  | "gr6f.4xlarge"
  | "p5.4xlarge"
  | "r8i.large"
  | "r8i.xlarge"
  | "r8i.2xlarge"
  | "r8i.4xlarge"
  | "r8i.8xlarge"
  | "r8i.12xlarge"
  | "r8i.16xlarge"
  | "r8i.24xlarge"
  | "r8i.32xlarge"
  | "r8i.48xlarge"
  | "r8i.96xlarge"
  | "r8i.metal-48xl"
  | "r8i.metal-96xl"
  | "r8i-flex.large"
  | "r8i-flex.xlarge"
  | "r8i-flex.2xlarge"
  | "r8i-flex.4xlarge"
  | "r8i-flex.8xlarge"
  | "r8i-flex.12xlarge"
  | "r8i-flex.16xlarge"
  | "m8i.large"
  | "m8i.xlarge"
  | "m8i.2xlarge"
  | "m8i.4xlarge"
  | "m8i.8xlarge"
  | "m8i.12xlarge"
  | "m8i.16xlarge"
  | "m8i.24xlarge"
  | "m8i.32xlarge"
  | "m8i.48xlarge"
  | "m8i.96xlarge"
  | "m8i.metal-48xl"
  | "m8i.metal-96xl"
  | "m8i-flex.large"
  | "m8i-flex.xlarge"
  | "m8i-flex.2xlarge"
  | "m8i-flex.4xlarge"
  | "m8i-flex.8xlarge"
  | "m8i-flex.12xlarge"
  | "m8i-flex.16xlarge"
  | "i8ge.large"
  | "i8ge.xlarge"
  | "i8ge.2xlarge"
  | "i8ge.3xlarge"
  | "i8ge.6xlarge"
  | "i8ge.12xlarge"
  | "i8ge.18xlarge"
  | "i8ge.24xlarge"
  | "i8ge.48xlarge"
  | "i8ge.metal-24xl"
  | "i8ge.metal-48xl"
  | "mac-m4.metal"
  | "mac-m4pro.metal"
  | "r8gn.medium"
  | "r8gn.large"
  | "r8gn.xlarge"
  | "r8gn.2xlarge"
  | "r8gn.4xlarge"
  | "r8gn.8xlarge"
  | "r8gn.12xlarge"
  | "r8gn.16xlarge"
  | "r8gn.24xlarge"
  | "r8gn.48xlarge"
  | "r8gn.metal-24xl"
  | "r8gn.metal-48xl"
  | "c8i.large"
  | "c8i.xlarge"
  | "c8i.2xlarge"
  | "c8i.4xlarge"
  | "c8i.8xlarge"
  | "c8i.12xlarge"
  | "c8i.16xlarge"
  | "c8i.24xlarge"
  | "c8i.32xlarge"
  | "c8i.48xlarge"
  | "c8i.96xlarge"
  | "c8i.metal-48xl"
  | "c8i.metal-96xl"
  | "c8i-flex.large"
  | "c8i-flex.xlarge"
  | "c8i-flex.2xlarge"
  | "c8i-flex.4xlarge"
  | "c8i-flex.8xlarge"
  | "c8i-flex.12xlarge"
  | "c8i-flex.16xlarge"
  | "r8gb.medium"
  | "r8gb.large"
  | "r8gb.xlarge"
  | "r8gb.2xlarge"
  | "r8gb.4xlarge"
  | "r8gb.8xlarge"
  | "r8gb.12xlarge"
  | "r8gb.16xlarge"
  | "r8gb.24xlarge"
  | "r8gb.metal-24xl"
  | "m8a.medium"
  | "m8a.large"
  | "m8a.xlarge"
  | "m8a.2xlarge"
  | "m8a.4xlarge"
  | "m8a.8xlarge"
  | "m8a.12xlarge"
  | "m8a.16xlarge"
  | "m8a.24xlarge"
  | "m8a.48xlarge"
  | "m8a.metal-24xl"
  | "m8a.metal-48xl"
  | "trn2.3xlarge"
  | "r8a.medium"
  | "r8a.large"
  | "r8a.xlarge"
  | "r8a.2xlarge"
  | "r8a.4xlarge"
  | "r8a.8xlarge"
  | "r8a.12xlarge"
  | "r8a.16xlarge"
  | "r8a.24xlarge"
  | "r8a.48xlarge"
  | "r8a.metal-24xl"
  | "r8a.metal-48xl"
  | "p6-b300.48xlarge"
  | "c8a.medium"
  | "c8a.large"
  | "c8a.xlarge"
  | "c8a.2xlarge"
  | "c8a.4xlarge"
  | "c8a.8xlarge"
  | "c8a.12xlarge"
  | "c8a.16xlarge"
  | "c8a.24xlarge"
  | "c8a.48xlarge"
  | "c8a.metal-24xl"
  | "c8a.metal-48xl"
  | "c8gb.12xlarge"
  | "c8gb.16xlarge"
  | "c8gb.24xlarge"
  | "c8gb.2xlarge"
  | "c8gb.4xlarge"
  | "c8gb.8xlarge"
  | "c8gb.large"
  | "c8gb.medium"
  | "c8gb.metal-24xl"
  | "c8gb.xlarge"
  | "c8gb.48xlarge"
  | "c8gb.metal-48xl"
  | "m8gb.12xlarge"
  | "m8gb.16xlarge"
  | "m8gb.24xlarge"
  | "m8gb.2xlarge"
  | "m8gb.4xlarge"
  | "m8gb.8xlarge"
  | "m8gb.large"
  | "m8gb.medium"
  | "m8gb.xlarge"
  | "m8gb.48xlarge"
  | "m8gb.metal-24xl"
  | "m8gb.metal-48xl"
  | "m8gn.12xlarge"
  | "m8gn.16xlarge"
  | "m8gn.24xlarge"
  | "m8gn.2xlarge"
  | "m8gn.48xlarge"
  | "m8gn.4xlarge"
  | "m8gn.8xlarge"
  | "m8gn.large"
  | "m8gn.medium"
  | "m8gn.xlarge"
  | "m8gn.metal-24xl"
  | "m8gn.metal-48xl"
  | "x8aedz.12xlarge"
  | "x8aedz.24xlarge"
  | "x8aedz.3xlarge"
  | "x8aedz.6xlarge"
  | "x8aedz.large"
  | "x8aedz.metal-12xl"
  | "x8aedz.metal-24xl"
  | "x8aedz.xlarge"
  | "m8azn.medium"
  | "m8azn.large"
  | "m8azn.xlarge"
  | "m8azn.3xlarge"
  | "m8azn.6xlarge"
  | "m8azn.12xlarge"
  | "m8azn.24xlarge"
  | "m8azn.metal-12xl"
  | "m8azn.metal-24xl"
  | "x8i.large"
  | "x8i.xlarge"
  | "x8i.2xlarge"
  | "x8i.4xlarge"
  | "x8i.8xlarge"
  | "x8i.12xlarge"
  | "x8i.16xlarge"
  | "x8i.24xlarge"
  | "x8i.32xlarge"
  | "x8i.48xlarge"
  | "x8i.64xlarge"
  | "x8i.96xlarge"
  | "x8i.metal-48xl"
  | "x8i.metal-96xl"
  | "mac-m4max.metal"
  | "g7e.2xlarge"
  | "g7e.4xlarge"
  | "g7e.8xlarge"
  | "g7e.12xlarge"
  | "g7e.24xlarge"
  | "g7e.48xlarge"
  | "r8id.large"
  | "r8id.xlarge"
  | "r8id.2xlarge"
  | "r8id.4xlarge"
  | "r8id.8xlarge"
  | "r8id.12xlarge"
  | "r8id.16xlarge"
  | "r8id.24xlarge"
  | "r8id.32xlarge"
  | "r8id.48xlarge"
  | "r8id.96xlarge"
  | "r8id.metal-48xl"
  | "r8id.metal-96xl"
  | "c8gb.12xlarge"
  | "c8gb.16xlarge"
  | "c8gb.24xlarge"
  | "c8gb.2xlarge"
  | "c8gb.4xlarge"
  | "c8gb.8xlarge"
  | "c8gb.large"
  | "c8gb.medium"
  | "c8gb.metal-24xl"
  | "c8gb.xlarge"
  | "m8gb.12xlarge"
  | "m8gb.16xlarge"
  | "m8gb.24xlarge"
  | "m8gb.2xlarge"
  | "m8gb.4xlarge"
  | "m8gb.8xlarge"
  | "m8gb.large"
  | "m8gb.medium"
  | "m8gb.xlarge"
  | "m8gn.12xlarge"
  | "m8gn.16xlarge"
  | "m8gn.24xlarge"
  | "m8gn.2xlarge"
  | "m8gn.48xlarge"
  | "m8gn.4xlarge"
  | "m8gn.8xlarge"
  | "m8gn.large"
  | "m8gn.medium"
  | "m8gn.xlarge"
  | (string & {});
export const InstanceType = S.String;
export interface ReservationFleetInstanceSpecification {
  InstanceType?: InstanceType;
  InstancePlatform?: CapacityReservationInstancePlatform;
  Weight?: number;
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  EbsOptimized?: boolean;
  Priority?: number;
}
export const ReservationFleetInstanceSpecification = S.suspend(() =>
  S.Struct({
    InstanceType: S.optional(InstanceType),
    InstancePlatform: S.optional(CapacityReservationInstancePlatform),
    Weight: S.optional(S.Number),
    AvailabilityZone: S.optional(S.String),
    AvailabilityZoneId: S.optional(S.String),
    EbsOptimized: S.optional(S.Boolean),
    Priority: S.optional(S.Number),
  }),
).annotate({
  identifier: "ReservationFleetInstanceSpecification",
}) as any as S.Schema<ReservationFleetInstanceSpecification>;
export type ReservationFleetInstanceSpecificationList =
  ReservationFleetInstanceSpecification[];
export const ReservationFleetInstanceSpecificationList = S.Array(
  ReservationFleetInstanceSpecification,
);
export type FleetCapacityReservationTenancy = "default" | (string & {});
export const FleetCapacityReservationTenancy = S.String;
export type FleetInstanceMatchCriteria = "open" | (string & {});
export const FleetInstanceMatchCriteria = S.String;
export interface CreateCapacityReservationFleetRequest {
  AllocationStrategy?: string;
  ClientToken?: string;
  InstanceTypeSpecifications?: ReservationFleetInstanceSpecification[];
  Tenancy?: FleetCapacityReservationTenancy;
  TotalTargetCapacity?: number;
  EndDate?: Date;
  InstanceMatchCriteria?: FleetInstanceMatchCriteria;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateCapacityReservationFleetRequest = S.suspend(() =>
  S.Struct({
    AllocationStrategy: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    InstanceTypeSpecifications: S.optional(
      ReservationFleetInstanceSpecificationList,
    ).pipe(T.XmlName("InstanceTypeSpecification")),
    Tenancy: S.optional(FleetCapacityReservationTenancy),
    TotalTargetCapacity: S.optional(S.Number),
    EndDate: S.optional(T.DateFromString.pipe(T.TimestampFormat("date-time"))),
    InstanceMatchCriteria: S.optional(FleetInstanceMatchCriteria),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateCapacityReservationFleetRequest",
}) as any as S.Schema<CreateCapacityReservationFleetRequest>;
export interface FleetCapacityReservation {
  CapacityReservationId?: string;
  AvailabilityZoneId?: string;
  InstanceType?: InstanceType;
  InstancePlatform?: CapacityReservationInstancePlatform;
  AvailabilityZone?: string;
  TotalInstanceCount?: number;
  FulfilledCapacity?: number;
  EbsOptimized?: boolean;
  CreateDate?: Date;
  Weight?: number;
  Priority?: number;
}
export const FleetCapacityReservation = S.suspend(() =>
  S.Struct({
    CapacityReservationId: S.optional(S.String).pipe(
      T.XmlName("capacityReservationId"),
      T.Ec2QueryName("CapacityReservationId"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    InstanceType: S.optional(InstanceType).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    InstancePlatform: S.optional(CapacityReservationInstancePlatform).pipe(
      T.XmlName("instancePlatform"),
      T.Ec2QueryName("InstancePlatform"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    TotalInstanceCount: S.optional(S.Number).pipe(
      T.XmlName("totalInstanceCount"),
      T.Ec2QueryName("TotalInstanceCount"),
    ),
    FulfilledCapacity: S.optional(S.Number).pipe(
      T.XmlName("fulfilledCapacity"),
      T.Ec2QueryName("FulfilledCapacity"),
    ),
    EbsOptimized: S.optional(S.Boolean).pipe(
      T.XmlName("ebsOptimized"),
      T.Ec2QueryName("EbsOptimized"),
    ),
    CreateDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createDate"), T.Ec2QueryName("CreateDate")),
    Weight: S.optional(S.Number).pipe(
      T.XmlName("weight"),
      T.Ec2QueryName("Weight"),
    ),
    Priority: S.optional(S.Number).pipe(
      T.XmlName("priority"),
      T.Ec2QueryName("Priority"),
    ),
  }),
).annotate({
  identifier: "FleetCapacityReservation",
}) as any as S.Schema<FleetCapacityReservation>;
export type FleetCapacityReservationSet = FleetCapacityReservation[];
export const FleetCapacityReservationSet = S.Array(
  FleetCapacityReservation.pipe(T.XmlName("item")).annotate({
    identifier: "FleetCapacityReservation",
  }),
);
export interface CreateCapacityReservationFleetResult {
  CapacityReservationFleetId?: string;
  State?: CapacityReservationFleetState;
  TotalTargetCapacity?: number;
  TotalFulfilledCapacity?: number;
  InstanceMatchCriteria?: FleetInstanceMatchCriteria;
  AllocationStrategy?: string;
  CreateTime?: Date;
  EndDate?: Date;
  Tenancy?: FleetCapacityReservationTenancy;
  FleetCapacityReservations?: FleetCapacityReservation[];
  Tags?: Tag[];
}
export const CreateCapacityReservationFleetResult = S.suspend(() =>
  S.Struct({
    CapacityReservationFleetId: S.optional(S.String).pipe(
      T.XmlName("capacityReservationFleetId"),
      T.Ec2QueryName("CapacityReservationFleetId"),
    ),
    State: S.optional(CapacityReservationFleetState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    TotalTargetCapacity: S.optional(S.Number).pipe(
      T.XmlName("totalTargetCapacity"),
      T.Ec2QueryName("TotalTargetCapacity"),
    ),
    TotalFulfilledCapacity: S.optional(S.Number).pipe(
      T.XmlName("totalFulfilledCapacity"),
      T.Ec2QueryName("TotalFulfilledCapacity"),
    ),
    InstanceMatchCriteria: S.optional(FleetInstanceMatchCriteria).pipe(
      T.XmlName("instanceMatchCriteria"),
      T.Ec2QueryName("InstanceMatchCriteria"),
    ),
    AllocationStrategy: S.optional(S.String).pipe(
      T.XmlName("allocationStrategy"),
      T.Ec2QueryName("AllocationStrategy"),
    ),
    CreateTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createTime"), T.Ec2QueryName("CreateTime")),
    EndDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("endDate"), T.Ec2QueryName("EndDate")),
    Tenancy: S.optional(FleetCapacityReservationTenancy).pipe(
      T.XmlName("tenancy"),
      T.Ec2QueryName("Tenancy"),
    ),
    FleetCapacityReservations: S.optional(FleetCapacityReservationSet).pipe(
      T.XmlName("fleetCapacityReservationSet"),
      T.Ec2QueryName("FleetCapacityReservationSet"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateCapacityReservationFleetResult",
}) as any as S.Schema<CreateCapacityReservationFleetResult>;
export interface CreateCarrierGatewayRequest {
  VpcId?: string;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
  ClientToken?: string;
}
export const CreateCarrierGatewayRequest = S.suspend(() =>
  S.Struct({
    VpcId: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateCarrierGatewayRequest",
}) as any as S.Schema<CreateCarrierGatewayRequest>;
export type CarrierGatewayState =
  | "pending"
  | "available"
  | "deleting"
  | "deleted"
  | (string & {});
export const CarrierGatewayState = S.String;
export interface CarrierGateway {
  CarrierGatewayId?: string;
  VpcId?: string;
  State?: CarrierGatewayState;
  OwnerId?: string;
  Tags?: Tag[];
}
export const CarrierGateway = S.suspend(() =>
  S.Struct({
    CarrierGatewayId: S.optional(S.String).pipe(
      T.XmlName("carrierGatewayId"),
      T.Ec2QueryName("CarrierGatewayId"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    State: S.optional(CarrierGatewayState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({ identifier: "CarrierGateway" }) as any as S.Schema<CarrierGateway>;
export interface CreateCarrierGatewayResult {
  CarrierGateway?: CarrierGateway;
}
export const CreateCarrierGatewayResult = S.suspend(() =>
  S.Struct({
    CarrierGateway: S.optional(CarrierGateway)
      .pipe(T.XmlName("carrierGateway"), T.Ec2QueryName("CarrierGateway"))
      .annotate({ identifier: "CarrierGateway" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateCarrierGatewayResult",
}) as any as S.Schema<CreateCarrierGatewayResult>;
export type ClientVpnAuthenticationType =
  | "certificate-authentication"
  | "directory-service-authentication"
  | "federated-authentication"
  | (string & {});
export const ClientVpnAuthenticationType = S.String;
export interface DirectoryServiceAuthenticationRequest {
  DirectoryId?: string;
}
export const DirectoryServiceAuthenticationRequest = S.suspend(() =>
  S.Struct({ DirectoryId: S.optional(S.String) }),
).annotate({
  identifier: "DirectoryServiceAuthenticationRequest",
}) as any as S.Schema<DirectoryServiceAuthenticationRequest>;
export interface CertificateAuthenticationRequest {
  ClientRootCertificateChainArn?: string;
}
export const CertificateAuthenticationRequest = S.suspend(() =>
  S.Struct({ ClientRootCertificateChainArn: S.optional(S.String) }),
).annotate({
  identifier: "CertificateAuthenticationRequest",
}) as any as S.Schema<CertificateAuthenticationRequest>;
export interface FederatedAuthenticationRequest {
  SAMLProviderArn?: string;
  SelfServiceSAMLProviderArn?: string;
}
export const FederatedAuthenticationRequest = S.suspend(() =>
  S.Struct({
    SAMLProviderArn: S.optional(S.String),
    SelfServiceSAMLProviderArn: S.optional(S.String),
  }),
).annotate({
  identifier: "FederatedAuthenticationRequest",
}) as any as S.Schema<FederatedAuthenticationRequest>;
export interface ClientVpnAuthenticationRequest {
  Type?: ClientVpnAuthenticationType;
  ActiveDirectory?: DirectoryServiceAuthenticationRequest;
  MutualAuthentication?: CertificateAuthenticationRequest;
  FederatedAuthentication?: FederatedAuthenticationRequest;
}
export const ClientVpnAuthenticationRequest = S.suspend(() =>
  S.Struct({
    Type: S.optional(ClientVpnAuthenticationType),
    ActiveDirectory: S.optional(DirectoryServiceAuthenticationRequest),
    MutualAuthentication: S.optional(CertificateAuthenticationRequest),
    FederatedAuthentication: S.optional(FederatedAuthenticationRequest),
  }),
).annotate({
  identifier: "ClientVpnAuthenticationRequest",
}) as any as S.Schema<ClientVpnAuthenticationRequest>;
export type ClientVpnAuthenticationRequestList =
  ClientVpnAuthenticationRequest[];
export const ClientVpnAuthenticationRequestList = S.Array(
  ClientVpnAuthenticationRequest,
);
export interface ConnectionLogOptions {
  Enabled?: boolean;
  CloudwatchLogGroup?: string;
  CloudwatchLogStream?: string;
}
export const ConnectionLogOptions = S.suspend(() =>
  S.Struct({
    Enabled: S.optional(S.Boolean),
    CloudwatchLogGroup: S.optional(S.String),
    CloudwatchLogStream: S.optional(S.String),
  }),
).annotate({
  identifier: "ConnectionLogOptions",
}) as any as S.Schema<ConnectionLogOptions>;
export type TransportProtocol = "tcp" | "udp" | (string & {});
export const TransportProtocol = S.String;
export type SelfServicePortal = "enabled" | "disabled" | (string & {});
export const SelfServicePortal = S.String;
export interface ClientConnectOptions {
  Enabled?: boolean;
  LambdaFunctionArn?: string;
}
export const ClientConnectOptions = S.suspend(() =>
  S.Struct({
    Enabled: S.optional(S.Boolean),
    LambdaFunctionArn: S.optional(S.String),
  }),
).annotate({
  identifier: "ClientConnectOptions",
}) as any as S.Schema<ClientConnectOptions>;
export interface ClientLoginBannerOptions {
  Enabled?: boolean;
  BannerText?: string;
}
export const ClientLoginBannerOptions = S.suspend(() =>
  S.Struct({
    Enabled: S.optional(S.Boolean),
    BannerText: S.optional(S.String),
  }),
).annotate({
  identifier: "ClientLoginBannerOptions",
}) as any as S.Schema<ClientLoginBannerOptions>;
export interface ClientRouteEnforcementOptions {
  Enforced?: boolean;
}
export const ClientRouteEnforcementOptions = S.suspend(() =>
  S.Struct({ Enforced: S.optional(S.Boolean) }),
).annotate({
  identifier: "ClientRouteEnforcementOptions",
}) as any as S.Schema<ClientRouteEnforcementOptions>;
export type EndpointIpAddressType =
  | "ipv4"
  | "ipv6"
  | "dual-stack"
  | (string & {});
export const EndpointIpAddressType = S.String;
export type TrafficIpAddressType =
  | "ipv4"
  | "ipv6"
  | "dual-stack"
  | (string & {});
export const TrafficIpAddressType = S.String;
export interface CreateClientVpnEndpointRequest {
  ClientCidrBlock?: string;
  ServerCertificateArn?: string;
  AuthenticationOptions?: ClientVpnAuthenticationRequest[];
  ConnectionLogOptions?: ConnectionLogOptions;
  DnsServers?: string[];
  TransportProtocol?: TransportProtocol;
  VpnPort?: number;
  Description?: string;
  SplitTunnel?: boolean;
  DryRun?: boolean;
  ClientToken?: string;
  TagSpecifications?: TagSpecification[];
  SecurityGroupIds?: string[];
  VpcId?: string;
  SelfServicePortal?: SelfServicePortal;
  ClientConnectOptions?: ClientConnectOptions;
  SessionTimeoutHours?: number;
  ClientLoginBannerOptions?: ClientLoginBannerOptions;
  ClientRouteEnforcementOptions?: ClientRouteEnforcementOptions;
  DisconnectOnSessionTimeout?: boolean;
  EndpointIpAddressType?: EndpointIpAddressType;
  TrafficIpAddressType?: TrafficIpAddressType;
}
export const CreateClientVpnEndpointRequest = S.suspend(() =>
  S.Struct({
    ClientCidrBlock: S.optional(S.String),
    ServerCertificateArn: S.optional(S.String),
    AuthenticationOptions: S.optional(ClientVpnAuthenticationRequestList).pipe(
      T.XmlName("Authentication"),
    ),
    ConnectionLogOptions: S.optional(ConnectionLogOptions),
    DnsServers: S.optional(ValueStringList),
    TransportProtocol: S.optional(TransportProtocol),
    VpnPort: S.optional(S.Number),
    Description: S.optional(S.String),
    SplitTunnel: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    SecurityGroupIds: S.optional(ClientVpnSecurityGroupIdSet).pipe(
      T.XmlName("SecurityGroupId"),
    ),
    VpcId: S.optional(S.String),
    SelfServicePortal: S.optional(SelfServicePortal),
    ClientConnectOptions: S.optional(ClientConnectOptions),
    SessionTimeoutHours: S.optional(S.Number),
    ClientLoginBannerOptions: S.optional(ClientLoginBannerOptions),
    ClientRouteEnforcementOptions: S.optional(ClientRouteEnforcementOptions),
    DisconnectOnSessionTimeout: S.optional(S.Boolean),
    EndpointIpAddressType: S.optional(EndpointIpAddressType),
    TrafficIpAddressType: S.optional(TrafficIpAddressType),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateClientVpnEndpointRequest",
}) as any as S.Schema<CreateClientVpnEndpointRequest>;
export type ClientVpnEndpointStatusCode =
  | "pending-associate"
  | "available"
  | "deleting"
  | "deleted"
  | (string & {});
export const ClientVpnEndpointStatusCode = S.String;
export interface ClientVpnEndpointStatus {
  Code?: ClientVpnEndpointStatusCode;
  Message?: string;
}
export const ClientVpnEndpointStatus = S.suspend(() =>
  S.Struct({
    Code: S.optional(ClientVpnEndpointStatusCode).pipe(
      T.XmlName("code"),
      T.Ec2QueryName("Code"),
    ),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "ClientVpnEndpointStatus",
}) as any as S.Schema<ClientVpnEndpointStatus>;
export interface CreateClientVpnEndpointResult {
  ClientVpnEndpointId?: string;
  Status?: ClientVpnEndpointStatus;
  DnsName?: string;
}
export const CreateClientVpnEndpointResult = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String).pipe(
      T.XmlName("clientVpnEndpointId"),
      T.Ec2QueryName("ClientVpnEndpointId"),
    ),
    Status: S.optional(ClientVpnEndpointStatus)
      .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
      .annotate({ identifier: "ClientVpnEndpointStatus" }),
    DnsName: S.optional(S.String).pipe(
      T.XmlName("dnsName"),
      T.Ec2QueryName("DnsName"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateClientVpnEndpointResult",
}) as any as S.Schema<CreateClientVpnEndpointResult>;
export interface CreateClientVpnRouteRequest {
  ClientVpnEndpointId?: string;
  DestinationCidrBlock?: string;
  TargetVpcSubnetId?: string;
  Description?: string;
  ClientToken?: string;
  DryRun?: boolean;
}
export const CreateClientVpnRouteRequest = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String),
    DestinationCidrBlock: S.optional(S.String),
    TargetVpcSubnetId: S.optional(S.String),
    Description: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateClientVpnRouteRequest",
}) as any as S.Schema<CreateClientVpnRouteRequest>;
export type ClientVpnRouteStatusCode =
  | "creating"
  | "active"
  | "failed"
  | "deleting"
  | (string & {});
export const ClientVpnRouteStatusCode = S.String;
export interface ClientVpnRouteStatus {
  Code?: ClientVpnRouteStatusCode;
  Message?: string;
}
export const ClientVpnRouteStatus = S.suspend(() =>
  S.Struct({
    Code: S.optional(ClientVpnRouteStatusCode).pipe(
      T.XmlName("code"),
      T.Ec2QueryName("Code"),
    ),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "ClientVpnRouteStatus",
}) as any as S.Schema<ClientVpnRouteStatus>;
export interface CreateClientVpnRouteResult {
  Status?: ClientVpnRouteStatus;
}
export const CreateClientVpnRouteResult = S.suspend(() =>
  S.Struct({
    Status: S.optional(ClientVpnRouteStatus)
      .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
      .annotate({ identifier: "ClientVpnRouteStatus" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateClientVpnRouteResult",
}) as any as S.Schema<CreateClientVpnRouteResult>;
export interface CreateCoipCidrRequest {
  Cidr?: string;
  CoipPoolId?: string;
  DryRun?: boolean;
}
export const CreateCoipCidrRequest = S.suspend(() =>
  S.Struct({
    Cidr: S.optional(S.String),
    CoipPoolId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateCoipCidrRequest",
}) as any as S.Schema<CreateCoipCidrRequest>;
export interface CoipCidr {
  Cidr?: string;
  CoipPoolId?: string;
  LocalGatewayRouteTableId?: string;
}
export const CoipCidr = S.suspend(() =>
  S.Struct({
    Cidr: S.optional(S.String).pipe(T.XmlName("cidr"), T.Ec2QueryName("Cidr")),
    CoipPoolId: S.optional(S.String).pipe(
      T.XmlName("coipPoolId"),
      T.Ec2QueryName("CoipPoolId"),
    ),
    LocalGatewayRouteTableId: S.optional(S.String).pipe(
      T.XmlName("localGatewayRouteTableId"),
      T.Ec2QueryName("LocalGatewayRouteTableId"),
    ),
  }),
).annotate({ identifier: "CoipCidr" }) as any as S.Schema<CoipCidr>;
export interface CreateCoipCidrResult {
  CoipCidr?: CoipCidr;
}
export const CreateCoipCidrResult = S.suspend(() =>
  S.Struct({
    CoipCidr: S.optional(CoipCidr)
      .pipe(T.XmlName("coipCidr"), T.Ec2QueryName("CoipCidr"))
      .annotate({ identifier: "CoipCidr" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateCoipCidrResult",
}) as any as S.Schema<CreateCoipCidrResult>;
export interface CreateCoipPoolRequest {
  LocalGatewayRouteTableId?: string;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateCoipPoolRequest = S.suspend(() =>
  S.Struct({
    LocalGatewayRouteTableId: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateCoipPoolRequest",
}) as any as S.Schema<CreateCoipPoolRequest>;
export interface CoipPool {
  PoolId?: string;
  PoolCidrs?: string[];
  LocalGatewayRouteTableId?: string;
  Tags?: Tag[];
  PoolArn?: string;
}
export const CoipPool = S.suspend(() =>
  S.Struct({
    PoolId: S.optional(S.String).pipe(
      T.XmlName("poolId"),
      T.Ec2QueryName("PoolId"),
    ),
    PoolCidrs: S.optional(ValueStringList).pipe(
      T.XmlName("poolCidrSet"),
      T.Ec2QueryName("PoolCidrSet"),
    ),
    LocalGatewayRouteTableId: S.optional(S.String).pipe(
      T.XmlName("localGatewayRouteTableId"),
      T.Ec2QueryName("LocalGatewayRouteTableId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    PoolArn: S.optional(S.String).pipe(
      T.XmlName("poolArn"),
      T.Ec2QueryName("PoolArn"),
    ),
  }),
).annotate({ identifier: "CoipPool" }) as any as S.Schema<CoipPool>;
export interface CreateCoipPoolResult {
  CoipPool?: CoipPool;
}
export const CreateCoipPoolResult = S.suspend(() =>
  S.Struct({
    CoipPool: S.optional(CoipPool)
      .pipe(T.XmlName("coipPool"), T.Ec2QueryName("CoipPool"))
      .annotate({ identifier: "CoipPool" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateCoipPoolResult",
}) as any as S.Schema<CreateCoipPoolResult>;
export type GatewayType = "ipsec.1" | (string & {});
export const GatewayType = S.String;
export interface CreateCustomerGatewayRequest {
  BgpAsn?: number;
  PublicIp?: string;
  CertificateArn?: string;
  Type?: GatewayType;
  TagSpecifications?: TagSpecification[];
  DeviceName?: string;
  IpAddress?: string;
  BgpAsnExtended?: number;
  DryRun?: boolean;
}
export const CreateCustomerGatewayRequest = S.suspend(() =>
  S.Struct({
    BgpAsn: S.optional(S.Number),
    PublicIp: S.optional(S.String),
    CertificateArn: S.optional(S.String),
    Type: S.optional(GatewayType),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DeviceName: S.optional(S.String),
    IpAddress: S.optional(S.String),
    BgpAsnExtended: S.optional(S.Number),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateCustomerGatewayRequest",
}) as any as S.Schema<CreateCustomerGatewayRequest>;
export interface CustomerGateway {
  CertificateArn?: string;
  DeviceName?: string;
  Tags?: Tag[];
  BgpAsnExtended?: string;
  CustomerGatewayId?: string;
  State?: string;
  Type?: string;
  IpAddress?: string;
  BgpAsn?: string;
}
export const CustomerGateway = S.suspend(() =>
  S.Struct({
    CertificateArn: S.optional(S.String).pipe(
      T.XmlName("certificateArn"),
      T.Ec2QueryName("CertificateArn"),
    ),
    DeviceName: S.optional(S.String).pipe(
      T.XmlName("deviceName"),
      T.Ec2QueryName("DeviceName"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    BgpAsnExtended: S.optional(S.String).pipe(
      T.XmlName("bgpAsnExtended"),
      T.Ec2QueryName("BgpAsnExtended"),
    ),
    CustomerGatewayId: S.optional(S.String).pipe(
      T.XmlName("customerGatewayId"),
      T.Ec2QueryName("CustomerGatewayId"),
    ),
    State: S.optional(S.String).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Type: S.optional(S.String).pipe(T.XmlName("type"), T.Ec2QueryName("Type")),
    IpAddress: S.optional(S.String).pipe(
      T.XmlName("ipAddress"),
      T.Ec2QueryName("IpAddress"),
    ),
    BgpAsn: S.optional(S.String).pipe(
      T.XmlName("bgpAsn"),
      T.Ec2QueryName("BgpAsn"),
    ),
  }),
).annotate({
  identifier: "CustomerGateway",
}) as any as S.Schema<CustomerGateway>;
export interface CreateCustomerGatewayResult {
  CustomerGateway?: CustomerGateway;
}
export const CreateCustomerGatewayResult = S.suspend(() =>
  S.Struct({
    CustomerGateway: S.optional(CustomerGateway)
      .pipe(T.XmlName("customerGateway"), T.Ec2QueryName("CustomerGateway"))
      .annotate({ identifier: "CustomerGateway" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateCustomerGatewayResult",
}) as any as S.Schema<CreateCustomerGatewayResult>;
export interface CreateDefaultSubnetRequest {
  AvailabilityZone?: string;
  DryRun?: boolean;
  Ipv6Native?: boolean;
  AvailabilityZoneId?: string;
}
export const CreateDefaultSubnetRequest = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    Ipv6Native: S.optional(S.Boolean),
    AvailabilityZoneId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateDefaultSubnetRequest",
}) as any as S.Schema<CreateDefaultSubnetRequest>;
export type SubnetIpv6CidrBlockAssociationSet =
  SubnetIpv6CidrBlockAssociation[];
export const SubnetIpv6CidrBlockAssociationSet = S.Array(
  SubnetIpv6CidrBlockAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "SubnetIpv6CidrBlockAssociation",
  }),
);
export type HostnameType = "ip-name" | "resource-name" | (string & {});
export const HostnameType = S.String;
export interface PrivateDnsNameOptionsOnLaunch {
  HostnameType?: HostnameType;
  EnableResourceNameDnsARecord?: boolean;
  EnableResourceNameDnsAAAARecord?: boolean;
}
export const PrivateDnsNameOptionsOnLaunch = S.suspend(() =>
  S.Struct({
    HostnameType: S.optional(HostnameType).pipe(
      T.XmlName("hostnameType"),
      T.Ec2QueryName("HostnameType"),
    ),
    EnableResourceNameDnsARecord: S.optional(S.Boolean).pipe(
      T.XmlName("enableResourceNameDnsARecord"),
      T.Ec2QueryName("EnableResourceNameDnsARecord"),
    ),
    EnableResourceNameDnsAAAARecord: S.optional(S.Boolean).pipe(
      T.XmlName("enableResourceNameDnsAAAARecord"),
      T.Ec2QueryName("EnableResourceNameDnsAAAARecord"),
    ),
  }),
).annotate({
  identifier: "PrivateDnsNameOptionsOnLaunch",
}) as any as S.Schema<PrivateDnsNameOptionsOnLaunch>;
export type BlockPublicAccessMode =
  | "off"
  | "block-bidirectional"
  | "block-ingress"
  | (string & {});
export const BlockPublicAccessMode = S.String;
export interface BlockPublicAccessStates {
  InternetGatewayBlockMode?: BlockPublicAccessMode;
}
export const BlockPublicAccessStates = S.suspend(() =>
  S.Struct({
    InternetGatewayBlockMode: S.optional(BlockPublicAccessMode).pipe(
      T.XmlName("internetGatewayBlockMode"),
      T.Ec2QueryName("InternetGatewayBlockMode"),
    ),
  }),
).annotate({
  identifier: "BlockPublicAccessStates",
}) as any as S.Schema<BlockPublicAccessStates>;
export type SubnetState =
  | "pending"
  | "available"
  | "unavailable"
  | "failed"
  | "failed-insufficient-capacity"
  | (string & {});
export const SubnetState = S.String;
export interface Subnet {
  AvailabilityZoneId?: string;
  EnableLniAtDeviceIndex?: number;
  MapCustomerOwnedIpOnLaunch?: boolean;
  CustomerOwnedIpv4Pool?: string;
  OwnerId?: string;
  AssignIpv6AddressOnCreation?: boolean;
  Ipv6CidrBlockAssociationSet?: SubnetIpv6CidrBlockAssociation[];
  Tags?: Tag[];
  SubnetArn?: string;
  OutpostArn?: string;
  EnableDns64?: boolean;
  Ipv6Native?: boolean;
  PrivateDnsNameOptionsOnLaunch?: PrivateDnsNameOptionsOnLaunch;
  BlockPublicAccessStates?: BlockPublicAccessStates;
  Type?: string;
  SubnetId?: string;
  State?: SubnetState;
  VpcId?: string;
  CidrBlock?: string;
  AvailableIpAddressCount?: number;
  AvailabilityZone?: string;
  DefaultForAz?: boolean;
  MapPublicIpOnLaunch?: boolean;
}
export const Subnet = S.suspend(() =>
  S.Struct({
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    EnableLniAtDeviceIndex: S.optional(S.Number).pipe(
      T.XmlName("enableLniAtDeviceIndex"),
      T.Ec2QueryName("EnableLniAtDeviceIndex"),
    ),
    MapCustomerOwnedIpOnLaunch: S.optional(S.Boolean).pipe(
      T.XmlName("mapCustomerOwnedIpOnLaunch"),
      T.Ec2QueryName("MapCustomerOwnedIpOnLaunch"),
    ),
    CustomerOwnedIpv4Pool: S.optional(S.String).pipe(
      T.XmlName("customerOwnedIpv4Pool"),
      T.Ec2QueryName("CustomerOwnedIpv4Pool"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    AssignIpv6AddressOnCreation: S.optional(S.Boolean).pipe(
      T.XmlName("assignIpv6AddressOnCreation"),
      T.Ec2QueryName("AssignIpv6AddressOnCreation"),
    ),
    Ipv6CidrBlockAssociationSet: S.optional(
      SubnetIpv6CidrBlockAssociationSet,
    ).pipe(
      T.XmlName("ipv6CidrBlockAssociationSet"),
      T.Ec2QueryName("Ipv6CidrBlockAssociationSet"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    SubnetArn: S.optional(S.String).pipe(
      T.XmlName("subnetArn"),
      T.Ec2QueryName("SubnetArn"),
    ),
    OutpostArn: S.optional(S.String).pipe(
      T.XmlName("outpostArn"),
      T.Ec2QueryName("OutpostArn"),
    ),
    EnableDns64: S.optional(S.Boolean).pipe(
      T.XmlName("enableDns64"),
      T.Ec2QueryName("EnableDns64"),
    ),
    Ipv6Native: S.optional(S.Boolean).pipe(
      T.XmlName("ipv6Native"),
      T.Ec2QueryName("Ipv6Native"),
    ),
    PrivateDnsNameOptionsOnLaunch: S.optional(PrivateDnsNameOptionsOnLaunch)
      .pipe(
        T.XmlName("privateDnsNameOptionsOnLaunch"),
        T.Ec2QueryName("PrivateDnsNameOptionsOnLaunch"),
      )
      .annotate({ identifier: "PrivateDnsNameOptionsOnLaunch" }),
    BlockPublicAccessStates: S.optional(BlockPublicAccessStates)
      .pipe(
        T.XmlName("blockPublicAccessStates"),
        T.Ec2QueryName("BlockPublicAccessStates"),
      )
      .annotate({ identifier: "BlockPublicAccessStates" }),
    Type: S.optional(S.String).pipe(T.XmlName("type"), T.Ec2QueryName("Type")),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    State: S.optional(SubnetState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    CidrBlock: S.optional(S.String).pipe(
      T.XmlName("cidrBlock"),
      T.Ec2QueryName("CidrBlock"),
    ),
    AvailableIpAddressCount: S.optional(S.Number).pipe(
      T.XmlName("availableIpAddressCount"),
      T.Ec2QueryName("AvailableIpAddressCount"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    DefaultForAz: S.optional(S.Boolean).pipe(
      T.XmlName("defaultForAz"),
      T.Ec2QueryName("DefaultForAz"),
    ),
    MapPublicIpOnLaunch: S.optional(S.Boolean).pipe(
      T.XmlName("mapPublicIpOnLaunch"),
      T.Ec2QueryName("MapPublicIpOnLaunch"),
    ),
  }),
).annotate({ identifier: "Subnet" }) as any as S.Schema<Subnet>;
export interface CreateDefaultSubnetResult {
  Subnet?: Subnet;
}
export const CreateDefaultSubnetResult = S.suspend(() =>
  S.Struct({
    Subnet: S.optional(Subnet)
      .pipe(T.XmlName("subnet"), T.Ec2QueryName("Subnet"))
      .annotate({ identifier: "Subnet" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateDefaultSubnetResult",
}) as any as S.Schema<CreateDefaultSubnetResult>;
export interface CreateDefaultVpcRequest {
  DryRun?: boolean;
}
export const CreateDefaultVpcRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateDefaultVpcRequest",
}) as any as S.Schema<CreateDefaultVpcRequest>;
export type Tenancy = "default" | "dedicated" | "host" | (string & {});
export const Tenancy = S.String;
export type VpcIpv6CidrBlockAssociationSet = VpcIpv6CidrBlockAssociation[];
export const VpcIpv6CidrBlockAssociationSet = S.Array(
  VpcIpv6CidrBlockAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "VpcIpv6CidrBlockAssociation",
  }),
);
export type VpcCidrBlockAssociationSet = VpcCidrBlockAssociation[];
export const VpcCidrBlockAssociationSet = S.Array(
  VpcCidrBlockAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "VpcCidrBlockAssociation",
  }),
);
export type VpcEncryptionControlMode = "monitor" | "enforce" | (string & {});
export const VpcEncryptionControlMode = S.String;
export type VpcEncryptionControlState =
  | "enforce-in-progress"
  | "monitor-in-progress"
  | "enforce-failed"
  | "monitor-failed"
  | "deleting"
  | "deleted"
  | "available"
  | "creating"
  | "delete-failed"
  | (string & {});
export const VpcEncryptionControlState = S.String;
export type VpcEncryptionControlExclusionState =
  | "enabling"
  | "enabled"
  | "disabling"
  | "disabled"
  | (string & {});
export const VpcEncryptionControlExclusionState = S.String;
export interface VpcEncryptionControlExclusion {
  State?: VpcEncryptionControlExclusionState;
  StateMessage?: string;
}
export const VpcEncryptionControlExclusion = S.suspend(() =>
  S.Struct({
    State: S.optional(VpcEncryptionControlExclusionState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StateMessage: S.optional(S.String).pipe(
      T.XmlName("stateMessage"),
      T.Ec2QueryName("StateMessage"),
    ),
  }),
).annotate({
  identifier: "VpcEncryptionControlExclusion",
}) as any as S.Schema<VpcEncryptionControlExclusion>;
export interface VpcEncryptionControlExclusions {
  InternetGateway?: VpcEncryptionControlExclusion;
  EgressOnlyInternetGateway?: VpcEncryptionControlExclusion;
  NatGateway?: VpcEncryptionControlExclusion;
  VirtualPrivateGateway?: VpcEncryptionControlExclusion;
  VpcPeering?: VpcEncryptionControlExclusion;
  Lambda?: VpcEncryptionControlExclusion;
  VpcLattice?: VpcEncryptionControlExclusion;
  ElasticFileSystem?: VpcEncryptionControlExclusion;
}
export const VpcEncryptionControlExclusions = S.suspend(() =>
  S.Struct({
    InternetGateway: S.optional(VpcEncryptionControlExclusion)
      .pipe(T.XmlName("internetGateway"), T.Ec2QueryName("InternetGateway"))
      .annotate({ identifier: "VpcEncryptionControlExclusion" }),
    EgressOnlyInternetGateway: S.optional(VpcEncryptionControlExclusion)
      .pipe(
        T.XmlName("egressOnlyInternetGateway"),
        T.Ec2QueryName("EgressOnlyInternetGateway"),
      )
      .annotate({ identifier: "VpcEncryptionControlExclusion" }),
    NatGateway: S.optional(VpcEncryptionControlExclusion)
      .pipe(T.XmlName("natGateway"), T.Ec2QueryName("NatGateway"))
      .annotate({ identifier: "VpcEncryptionControlExclusion" }),
    VirtualPrivateGateway: S.optional(VpcEncryptionControlExclusion)
      .pipe(
        T.XmlName("virtualPrivateGateway"),
        T.Ec2QueryName("VirtualPrivateGateway"),
      )
      .annotate({ identifier: "VpcEncryptionControlExclusion" }),
    VpcPeering: S.optional(VpcEncryptionControlExclusion)
      .pipe(T.XmlName("vpcPeering"), T.Ec2QueryName("VpcPeering"))
      .annotate({ identifier: "VpcEncryptionControlExclusion" }),
    Lambda: S.optional(VpcEncryptionControlExclusion)
      .pipe(T.XmlName("lambda"), T.Ec2QueryName("Lambda"))
      .annotate({ identifier: "VpcEncryptionControlExclusion" }),
    VpcLattice: S.optional(VpcEncryptionControlExclusion)
      .pipe(T.XmlName("vpcLattice"), T.Ec2QueryName("VpcLattice"))
      .annotate({ identifier: "VpcEncryptionControlExclusion" }),
    ElasticFileSystem: S.optional(VpcEncryptionControlExclusion)
      .pipe(T.XmlName("elasticFileSystem"), T.Ec2QueryName("ElasticFileSystem"))
      .annotate({ identifier: "VpcEncryptionControlExclusion" }),
  }),
).annotate({
  identifier: "VpcEncryptionControlExclusions",
}) as any as S.Schema<VpcEncryptionControlExclusions>;
export interface VpcEncryptionControl {
  VpcId?: string;
  VpcEncryptionControlId?: string;
  Mode?: VpcEncryptionControlMode;
  State?: VpcEncryptionControlState;
  StateMessage?: string;
  ResourceExclusions?: VpcEncryptionControlExclusions;
  Tags?: Tag[];
}
export const VpcEncryptionControl = S.suspend(() =>
  S.Struct({
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    VpcEncryptionControlId: S.optional(S.String).pipe(
      T.XmlName("vpcEncryptionControlId"),
      T.Ec2QueryName("VpcEncryptionControlId"),
    ),
    Mode: S.optional(VpcEncryptionControlMode).pipe(
      T.XmlName("mode"),
      T.Ec2QueryName("Mode"),
    ),
    State: S.optional(VpcEncryptionControlState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StateMessage: S.optional(S.String).pipe(
      T.XmlName("stateMessage"),
      T.Ec2QueryName("StateMessage"),
    ),
    ResourceExclusions: S.optional(VpcEncryptionControlExclusions)
      .pipe(
        T.XmlName("resourceExclusions"),
        T.Ec2QueryName("ResourceExclusions"),
      )
      .annotate({ identifier: "VpcEncryptionControlExclusions" }),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "VpcEncryptionControl",
}) as any as S.Schema<VpcEncryptionControl>;
export type VpcState = "pending" | "available" | (string & {});
export const VpcState = S.String;
export interface Vpc {
  OwnerId?: string;
  InstanceTenancy?: Tenancy;
  Ipv6CidrBlockAssociationSet?: VpcIpv6CidrBlockAssociation[];
  CidrBlockAssociationSet?: VpcCidrBlockAssociation[];
  IsDefault?: boolean;
  EncryptionControl?: VpcEncryptionControl;
  Tags?: Tag[];
  BlockPublicAccessStates?: BlockPublicAccessStates;
  VpcId?: string;
  State?: VpcState;
  CidrBlock?: string;
  DhcpOptionsId?: string;
}
export const Vpc = S.suspend(() =>
  S.Struct({
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    InstanceTenancy: S.optional(Tenancy).pipe(
      T.XmlName("instanceTenancy"),
      T.Ec2QueryName("InstanceTenancy"),
    ),
    Ipv6CidrBlockAssociationSet: S.optional(
      VpcIpv6CidrBlockAssociationSet,
    ).pipe(
      T.XmlName("ipv6CidrBlockAssociationSet"),
      T.Ec2QueryName("Ipv6CidrBlockAssociationSet"),
    ),
    CidrBlockAssociationSet: S.optional(VpcCidrBlockAssociationSet).pipe(
      T.XmlName("cidrBlockAssociationSet"),
      T.Ec2QueryName("CidrBlockAssociationSet"),
    ),
    IsDefault: S.optional(S.Boolean).pipe(
      T.XmlName("isDefault"),
      T.Ec2QueryName("IsDefault"),
    ),
    EncryptionControl: S.optional(VpcEncryptionControl)
      .pipe(T.XmlName("encryptionControl"), T.Ec2QueryName("EncryptionControl"))
      .annotate({ identifier: "VpcEncryptionControl" }),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    BlockPublicAccessStates: S.optional(BlockPublicAccessStates)
      .pipe(
        T.XmlName("blockPublicAccessStates"),
        T.Ec2QueryName("BlockPublicAccessStates"),
      )
      .annotate({ identifier: "BlockPublicAccessStates" }),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    State: S.optional(VpcState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    CidrBlock: S.optional(S.String).pipe(
      T.XmlName("cidrBlock"),
      T.Ec2QueryName("CidrBlock"),
    ),
    DhcpOptionsId: S.optional(S.String).pipe(
      T.XmlName("dhcpOptionsId"),
      T.Ec2QueryName("DhcpOptionsId"),
    ),
  }),
).annotate({ identifier: "Vpc" }) as any as S.Schema<Vpc>;
export interface CreateDefaultVpcResult {
  Vpc?: Vpc;
}
export const CreateDefaultVpcResult = S.suspend(() =>
  S.Struct({
    Vpc: S.optional(Vpc)
      .pipe(T.XmlName("vpc"), T.Ec2QueryName("Vpc"))
      .annotate({ identifier: "Vpc" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateDefaultVpcResult",
}) as any as S.Schema<CreateDefaultVpcResult>;
export interface CreateDelegateMacVolumeOwnershipTaskRequest {
  ClientToken?: string;
  DryRun?: boolean;
  InstanceId?: string;
  MacCredentials?: string | redacted.Redacted<string>;
  TagSpecifications?: TagSpecification[];
}
export const CreateDelegateMacVolumeOwnershipTaskRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
    InstanceId: S.optional(S.String),
    MacCredentials: S.optional(SensitiveString),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateDelegateMacVolumeOwnershipTaskRequest",
}) as any as S.Schema<CreateDelegateMacVolumeOwnershipTaskRequest>;
export type MacSystemIntegrityProtectionSettingStatus =
  | "enabled"
  | "disabled"
  | (string & {});
export const MacSystemIntegrityProtectionSettingStatus = S.String;
export interface MacSystemIntegrityProtectionConfiguration {
  AppleInternal?: MacSystemIntegrityProtectionSettingStatus;
  BaseSystem?: MacSystemIntegrityProtectionSettingStatus;
  DebuggingRestrictions?: MacSystemIntegrityProtectionSettingStatus;
  DTraceRestrictions?: MacSystemIntegrityProtectionSettingStatus;
  FilesystemProtections?: MacSystemIntegrityProtectionSettingStatus;
  KextSigning?: MacSystemIntegrityProtectionSettingStatus;
  NvramProtections?: MacSystemIntegrityProtectionSettingStatus;
  Status?: MacSystemIntegrityProtectionSettingStatus;
}
export const MacSystemIntegrityProtectionConfiguration = S.suspend(() =>
  S.Struct({
    AppleInternal: S.optional(MacSystemIntegrityProtectionSettingStatus).pipe(
      T.XmlName("appleInternal"),
      T.Ec2QueryName("AppleInternal"),
    ),
    BaseSystem: S.optional(MacSystemIntegrityProtectionSettingStatus).pipe(
      T.XmlName("baseSystem"),
      T.Ec2QueryName("BaseSystem"),
    ),
    DebuggingRestrictions: S.optional(
      MacSystemIntegrityProtectionSettingStatus,
    ).pipe(
      T.XmlName("debuggingRestrictions"),
      T.Ec2QueryName("DebuggingRestrictions"),
    ),
    DTraceRestrictions: S.optional(
      MacSystemIntegrityProtectionSettingStatus,
    ).pipe(
      T.XmlName("dTraceRestrictions"),
      T.Ec2QueryName("DTraceRestrictions"),
    ),
    FilesystemProtections: S.optional(
      MacSystemIntegrityProtectionSettingStatus,
    ).pipe(
      T.XmlName("filesystemProtections"),
      T.Ec2QueryName("FilesystemProtections"),
    ),
    KextSigning: S.optional(MacSystemIntegrityProtectionSettingStatus).pipe(
      T.XmlName("kextSigning"),
      T.Ec2QueryName("KextSigning"),
    ),
    NvramProtections: S.optional(
      MacSystemIntegrityProtectionSettingStatus,
    ).pipe(T.XmlName("nvramProtections"), T.Ec2QueryName("NvramProtections")),
    Status: S.optional(MacSystemIntegrityProtectionSettingStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
  }),
).annotate({
  identifier: "MacSystemIntegrityProtectionConfiguration",
}) as any as S.Schema<MacSystemIntegrityProtectionConfiguration>;
export type MacModificationTaskState =
  | "successful"
  | "failed"
  | "in-progress"
  | "pending"
  | (string & {});
export const MacModificationTaskState = S.String;
export type MacModificationTaskType =
  | "sip-modification"
  | "volume-ownership-delegation"
  | (string & {});
export const MacModificationTaskType = S.String;
export interface MacModificationTask {
  InstanceId?: string;
  MacModificationTaskId?: string;
  MacSystemIntegrityProtectionConfig?: MacSystemIntegrityProtectionConfiguration;
  StartTime?: Date;
  Tags?: Tag[];
  TaskState?: MacModificationTaskState;
  TaskType?: MacModificationTaskType;
}
export const MacModificationTask = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    MacModificationTaskId: S.optional(S.String).pipe(
      T.XmlName("macModificationTaskId"),
      T.Ec2QueryName("MacModificationTaskId"),
    ),
    MacSystemIntegrityProtectionConfig: S.optional(
      MacSystemIntegrityProtectionConfiguration,
    )
      .pipe(
        T.XmlName("macSystemIntegrityProtectionConfig"),
        T.Ec2QueryName("MacSystemIntegrityProtectionConfig"),
      )
      .annotate({ identifier: "MacSystemIntegrityProtectionConfiguration" }),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startTime"), T.Ec2QueryName("StartTime")),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    TaskState: S.optional(MacModificationTaskState).pipe(
      T.XmlName("taskState"),
      T.Ec2QueryName("TaskState"),
    ),
    TaskType: S.optional(MacModificationTaskType).pipe(
      T.XmlName("taskType"),
      T.Ec2QueryName("TaskType"),
    ),
  }),
).annotate({
  identifier: "MacModificationTask",
}) as any as S.Schema<MacModificationTask>;
export interface CreateDelegateMacVolumeOwnershipTaskResult {
  MacModificationTask?: MacModificationTask;
}
export const CreateDelegateMacVolumeOwnershipTaskResult = S.suspend(() =>
  S.Struct({
    MacModificationTask: S.optional(MacModificationTask)
      .pipe(
        T.XmlName("macModificationTask"),
        T.Ec2QueryName("MacModificationTask"),
      )
      .annotate({ identifier: "MacModificationTask" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateDelegateMacVolumeOwnershipTaskResult",
}) as any as S.Schema<CreateDelegateMacVolumeOwnershipTaskResult>;
export interface NewDhcpConfiguration {
  Key?: string;
  Values?: string[];
}
export const NewDhcpConfiguration = S.suspend(() =>
  S.Struct({
    Key: S.optional(S.String).pipe(T.XmlName("key"), T.Ec2QueryName("Key")),
    Values: S.optional(ValueStringList).pipe(T.XmlName("Value")),
  }),
).annotate({
  identifier: "NewDhcpConfiguration",
}) as any as S.Schema<NewDhcpConfiguration>;
export type NewDhcpConfigurationList = NewDhcpConfiguration[];
export const NewDhcpConfigurationList = S.Array(
  NewDhcpConfiguration.pipe(T.XmlName("item")).annotate({
    identifier: "NewDhcpConfiguration",
  }),
);
export interface CreateDhcpOptionsRequest {
  DhcpConfigurations?: NewDhcpConfiguration[];
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateDhcpOptionsRequest = S.suspend(() =>
  S.Struct({
    DhcpConfigurations: S.optional(NewDhcpConfigurationList).pipe(
      T.XmlName("dhcpConfiguration"),
      T.Ec2QueryName("DhcpConfiguration"),
    ),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateDhcpOptionsRequest",
}) as any as S.Schema<CreateDhcpOptionsRequest>;
export interface AttributeValue {
  Value?: string;
}
export const AttributeValue = S.suspend(() =>
  S.Struct({
    Value: S.optional(S.String).pipe(
      T.XmlName("value"),
      T.Ec2QueryName("Value"),
    ),
  }),
).annotate({ identifier: "AttributeValue" }) as any as S.Schema<AttributeValue>;
export type DhcpConfigurationValueList = AttributeValue[];
export const DhcpConfigurationValueList = S.Array(
  AttributeValue.pipe(T.XmlName("item")).annotate({
    identifier: "AttributeValue",
  }),
);
export interface DhcpConfiguration {
  Key?: string;
  Values?: AttributeValue[];
}
export const DhcpConfiguration = S.suspend(() =>
  S.Struct({
    Key: S.optional(S.String).pipe(T.XmlName("key"), T.Ec2QueryName("Key")),
    Values: S.optional(DhcpConfigurationValueList).pipe(
      T.XmlName("valueSet"),
      T.Ec2QueryName("ValueSet"),
    ),
  }),
).annotate({
  identifier: "DhcpConfiguration",
}) as any as S.Schema<DhcpConfiguration>;
export type DhcpConfigurationList = DhcpConfiguration[];
export const DhcpConfigurationList = S.Array(
  DhcpConfiguration.pipe(T.XmlName("item")).annotate({
    identifier: "DhcpConfiguration",
  }),
);
export interface DhcpOptions {
  OwnerId?: string;
  Tags?: Tag[];
  DhcpOptionsId?: string;
  DhcpConfigurations?: DhcpConfiguration[];
}
export const DhcpOptions = S.suspend(() =>
  S.Struct({
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    DhcpOptionsId: S.optional(S.String).pipe(
      T.XmlName("dhcpOptionsId"),
      T.Ec2QueryName("DhcpOptionsId"),
    ),
    DhcpConfigurations: S.optional(DhcpConfigurationList).pipe(
      T.XmlName("dhcpConfigurationSet"),
      T.Ec2QueryName("DhcpConfigurationSet"),
    ),
  }),
).annotate({ identifier: "DhcpOptions" }) as any as S.Schema<DhcpOptions>;
export interface CreateDhcpOptionsResult {
  DhcpOptions?: DhcpOptions;
}
export const CreateDhcpOptionsResult = S.suspend(() =>
  S.Struct({
    DhcpOptions: S.optional(DhcpOptions)
      .pipe(T.XmlName("dhcpOptions"), T.Ec2QueryName("DhcpOptions"))
      .annotate({ identifier: "DhcpOptions" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateDhcpOptionsResult",
}) as any as S.Schema<CreateDhcpOptionsResult>;
export interface CreateEgressOnlyInternetGatewayRequest {
  ClientToken?: string;
  DryRun?: boolean;
  VpcId?: string;
  TagSpecifications?: TagSpecification[];
}
export const CreateEgressOnlyInternetGatewayRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    VpcId: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateEgressOnlyInternetGatewayRequest",
}) as any as S.Schema<CreateEgressOnlyInternetGatewayRequest>;
export interface InternetGatewayAttachment {
  State?: AttachmentStatus;
  VpcId?: string;
}
export const InternetGatewayAttachment = S.suspend(() =>
  S.Struct({
    State: S.optional(AttachmentStatus).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
  }),
).annotate({
  identifier: "InternetGatewayAttachment",
}) as any as S.Schema<InternetGatewayAttachment>;
export type InternetGatewayAttachmentList = InternetGatewayAttachment[];
export const InternetGatewayAttachmentList = S.Array(
  InternetGatewayAttachment.pipe(T.XmlName("item")).annotate({
    identifier: "InternetGatewayAttachment",
  }),
);
export interface EgressOnlyInternetGateway {
  Attachments?: InternetGatewayAttachment[];
  EgressOnlyInternetGatewayId?: string;
  Tags?: Tag[];
}
export const EgressOnlyInternetGateway = S.suspend(() =>
  S.Struct({
    Attachments: S.optional(InternetGatewayAttachmentList).pipe(
      T.XmlName("attachmentSet"),
      T.Ec2QueryName("AttachmentSet"),
    ),
    EgressOnlyInternetGatewayId: S.optional(S.String).pipe(
      T.XmlName("egressOnlyInternetGatewayId"),
      T.Ec2QueryName("EgressOnlyInternetGatewayId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "EgressOnlyInternetGateway",
}) as any as S.Schema<EgressOnlyInternetGateway>;
export interface CreateEgressOnlyInternetGatewayResult {
  ClientToken?: string;
  EgressOnlyInternetGateway?: EgressOnlyInternetGateway;
}
export const CreateEgressOnlyInternetGatewayResult = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
    EgressOnlyInternetGateway: S.optional(EgressOnlyInternetGateway)
      .pipe(
        T.XmlName("egressOnlyInternetGateway"),
        T.Ec2QueryName("EgressOnlyInternetGateway"),
      )
      .annotate({ identifier: "EgressOnlyInternetGateway" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateEgressOnlyInternetGatewayResult",
}) as any as S.Schema<CreateEgressOnlyInternetGatewayResult>;
export type SpotAllocationStrategy =
  | "lowest-price"
  | "diversified"
  | "capacity-optimized"
  | "capacity-optimized-prioritized"
  | "price-capacity-optimized"
  | (string & {});
export const SpotAllocationStrategy = S.String;
export type FleetReplacementStrategy =
  | "launch"
  | "launch-before-terminate"
  | (string & {});
export const FleetReplacementStrategy = S.String;
export interface FleetSpotCapacityRebalanceRequest {
  ReplacementStrategy?: FleetReplacementStrategy;
  TerminationDelay?: number;
}
export const FleetSpotCapacityRebalanceRequest = S.suspend(() =>
  S.Struct({
    ReplacementStrategy: S.optional(FleetReplacementStrategy),
    TerminationDelay: S.optional(S.Number),
  }),
).annotate({
  identifier: "FleetSpotCapacityRebalanceRequest",
}) as any as S.Schema<FleetSpotCapacityRebalanceRequest>;
export interface FleetSpotMaintenanceStrategiesRequest {
  CapacityRebalance?: FleetSpotCapacityRebalanceRequest;
}
export const FleetSpotMaintenanceStrategiesRequest = S.suspend(() =>
  S.Struct({
    CapacityRebalance: S.optional(FleetSpotCapacityRebalanceRequest),
  }),
).annotate({
  identifier: "FleetSpotMaintenanceStrategiesRequest",
}) as any as S.Schema<FleetSpotMaintenanceStrategiesRequest>;
export type SpotInstanceInterruptionBehavior =
  | "hibernate"
  | "stop"
  | "terminate"
  | (string & {});
export const SpotInstanceInterruptionBehavior = S.String;
export interface SpotOptionsRequest {
  AllocationStrategy?: SpotAllocationStrategy;
  MaintenanceStrategies?: FleetSpotMaintenanceStrategiesRequest;
  InstanceInterruptionBehavior?: SpotInstanceInterruptionBehavior;
  InstancePoolsToUseCount?: number;
  SingleInstanceType?: boolean;
  SingleAvailabilityZone?: boolean;
  MinTargetCapacity?: number;
  MaxTotalPrice?: string;
}
export const SpotOptionsRequest = S.suspend(() =>
  S.Struct({
    AllocationStrategy: S.optional(SpotAllocationStrategy),
    MaintenanceStrategies: S.optional(FleetSpotMaintenanceStrategiesRequest),
    InstanceInterruptionBehavior: S.optional(SpotInstanceInterruptionBehavior),
    InstancePoolsToUseCount: S.optional(S.Number),
    SingleInstanceType: S.optional(S.Boolean),
    SingleAvailabilityZone: S.optional(S.Boolean),
    MinTargetCapacity: S.optional(S.Number),
    MaxTotalPrice: S.optional(S.String),
  }),
).annotate({
  identifier: "SpotOptionsRequest",
}) as any as S.Schema<SpotOptionsRequest>;
export type FleetOnDemandAllocationStrategy =
  | "lowest-price"
  | "prioritized"
  | (string & {});
export const FleetOnDemandAllocationStrategy = S.String;
export type FleetCapacityReservationUsageStrategy =
  | "use-capacity-reservations-first"
  | (string & {});
export const FleetCapacityReservationUsageStrategy = S.String;
export interface CapacityReservationOptionsRequest {
  UsageStrategy?: FleetCapacityReservationUsageStrategy;
}
export const CapacityReservationOptionsRequest = S.suspend(() =>
  S.Struct({
    UsageStrategy: S.optional(FleetCapacityReservationUsageStrategy),
  }),
).annotate({
  identifier: "CapacityReservationOptionsRequest",
}) as any as S.Schema<CapacityReservationOptionsRequest>;
export interface OnDemandOptionsRequest {
  AllocationStrategy?: FleetOnDemandAllocationStrategy;
  CapacityReservationOptions?: CapacityReservationOptionsRequest;
  SingleInstanceType?: boolean;
  SingleAvailabilityZone?: boolean;
  MinTargetCapacity?: number;
  MaxTotalPrice?: string;
}
export const OnDemandOptionsRequest = S.suspend(() =>
  S.Struct({
    AllocationStrategy: S.optional(FleetOnDemandAllocationStrategy),
    CapacityReservationOptions: S.optional(CapacityReservationOptionsRequest),
    SingleInstanceType: S.optional(S.Boolean),
    SingleAvailabilityZone: S.optional(S.Boolean),
    MinTargetCapacity: S.optional(S.Number),
    MaxTotalPrice: S.optional(S.String),
  }),
).annotate({
  identifier: "OnDemandOptionsRequest",
}) as any as S.Schema<OnDemandOptionsRequest>;
export type FleetExcessCapacityTerminationPolicy =
  | "no-termination"
  | "termination"
  | (string & {});
export const FleetExcessCapacityTerminationPolicy = S.String;
export interface FleetLaunchTemplateSpecificationRequest {
  LaunchTemplateId?: string;
  LaunchTemplateName?: string;
  Version?: string;
}
export const FleetLaunchTemplateSpecificationRequest = S.suspend(() =>
  S.Struct({
    LaunchTemplateId: S.optional(S.String),
    LaunchTemplateName: S.optional(S.String),
    Version: S.optional(S.String),
  }),
).annotate({
  identifier: "FleetLaunchTemplateSpecificationRequest",
}) as any as S.Schema<FleetLaunchTemplateSpecificationRequest>;
export interface Placement {
  AvailabilityZoneId?: string;
  Affinity?: string;
  GroupName?: string;
  PartitionNumber?: number;
  HostId?: string;
  Tenancy?: Tenancy;
  SpreadDomain?: string;
  HostResourceGroupArn?: string;
  GroupId?: string;
  AvailabilityZone?: string;
}
export const Placement = S.suspend(() =>
  S.Struct({
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    Affinity: S.optional(S.String).pipe(
      T.XmlName("affinity"),
      T.Ec2QueryName("Affinity"),
    ),
    GroupName: S.optional(S.String).pipe(
      T.XmlName("groupName"),
      T.Ec2QueryName("GroupName"),
    ),
    PartitionNumber: S.optional(S.Number).pipe(
      T.XmlName("partitionNumber"),
      T.Ec2QueryName("PartitionNumber"),
    ),
    HostId: S.optional(S.String).pipe(
      T.XmlName("hostId"),
      T.Ec2QueryName("HostId"),
    ),
    Tenancy: S.optional(Tenancy).pipe(
      T.XmlName("tenancy"),
      T.Ec2QueryName("Tenancy"),
    ),
    SpreadDomain: S.optional(S.String).pipe(
      T.XmlName("spreadDomain"),
      T.Ec2QueryName("SpreadDomain"),
    ),
    HostResourceGroupArn: S.optional(S.String).pipe(
      T.XmlName("hostResourceGroupArn"),
      T.Ec2QueryName("HostResourceGroupArn"),
    ),
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
  }),
).annotate({ identifier: "Placement" }) as any as S.Schema<Placement>;
export interface FleetEbsBlockDeviceRequest {
  Encrypted?: boolean;
  DeleteOnTermination?: boolean;
  Iops?: number;
  Throughput?: number;
  KmsKeyId?: string;
  SnapshotId?: string;
  VolumeSize?: number;
  VolumeType?: VolumeType;
}
export const FleetEbsBlockDeviceRequest = S.suspend(() =>
  S.Struct({
    Encrypted: S.optional(S.Boolean),
    DeleteOnTermination: S.optional(S.Boolean),
    Iops: S.optional(S.Number),
    Throughput: S.optional(S.Number),
    KmsKeyId: S.optional(S.String),
    SnapshotId: S.optional(S.String),
    VolumeSize: S.optional(S.Number),
    VolumeType: S.optional(VolumeType),
  }),
).annotate({
  identifier: "FleetEbsBlockDeviceRequest",
}) as any as S.Schema<FleetEbsBlockDeviceRequest>;
export interface FleetBlockDeviceMappingRequest {
  DeviceName?: string;
  VirtualName?: string;
  Ebs?: FleetEbsBlockDeviceRequest;
  NoDevice?: string;
}
export const FleetBlockDeviceMappingRequest = S.suspend(() =>
  S.Struct({
    DeviceName: S.optional(S.String),
    VirtualName: S.optional(S.String),
    Ebs: S.optional(FleetEbsBlockDeviceRequest),
    NoDevice: S.optional(S.String),
  }),
).annotate({
  identifier: "FleetBlockDeviceMappingRequest",
}) as any as S.Schema<FleetBlockDeviceMappingRequest>;
export type FleetBlockDeviceMappingRequestList =
  FleetBlockDeviceMappingRequest[];
export const FleetBlockDeviceMappingRequestList = S.Array(
  FleetBlockDeviceMappingRequest.pipe(T.XmlName("BlockDeviceMapping")).annotate(
    { identifier: "FleetBlockDeviceMappingRequest" },
  ),
);
export interface VCpuCountRangeRequest {
  Min?: number;
  Max?: number;
}
export const VCpuCountRangeRequest = S.suspend(() =>
  S.Struct({ Min: S.optional(S.Number), Max: S.optional(S.Number) }),
).annotate({
  identifier: "VCpuCountRangeRequest",
}) as any as S.Schema<VCpuCountRangeRequest>;
export interface MemoryMiBRequest {
  Min?: number;
  Max?: number;
}
export const MemoryMiBRequest = S.suspend(() =>
  S.Struct({ Min: S.optional(S.Number), Max: S.optional(S.Number) }),
).annotate({
  identifier: "MemoryMiBRequest",
}) as any as S.Schema<MemoryMiBRequest>;
export type CpuManufacturer =
  | "intel"
  | "amd"
  | "amazon-web-services"
  | "apple"
  | (string & {});
export const CpuManufacturer = S.String;
export type CpuManufacturerSet = CpuManufacturer[];
export const CpuManufacturerSet = S.Array(
  CpuManufacturer.pipe(T.XmlName("item")),
);
export interface MemoryGiBPerVCpuRequest {
  Min?: number;
  Max?: number;
}
export const MemoryGiBPerVCpuRequest = S.suspend(() =>
  S.Struct({ Min: S.optional(S.Number), Max: S.optional(S.Number) }),
).annotate({
  identifier: "MemoryGiBPerVCpuRequest",
}) as any as S.Schema<MemoryGiBPerVCpuRequest>;
export type ExcludedInstanceTypeSet = string[];
export const ExcludedInstanceTypeSet = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export type InstanceGeneration = "current" | "previous" | (string & {});
export const InstanceGeneration = S.String;
export type InstanceGenerationSet = InstanceGeneration[];
export const InstanceGenerationSet = S.Array(
  InstanceGeneration.pipe(T.XmlName("item")),
);
export type BareMetal = "included" | "required" | "excluded" | (string & {});
export const BareMetal = S.String;
export type BurstablePerformance =
  | "included"
  | "required"
  | "excluded"
  | (string & {});
export const BurstablePerformance = S.String;
export interface NetworkInterfaceCountRequest {
  Min?: number;
  Max?: number;
}
export const NetworkInterfaceCountRequest = S.suspend(() =>
  S.Struct({ Min: S.optional(S.Number), Max: S.optional(S.Number) }),
).annotate({
  identifier: "NetworkInterfaceCountRequest",
}) as any as S.Schema<NetworkInterfaceCountRequest>;
export type LocalStorage = "included" | "required" | "excluded" | (string & {});
export const LocalStorage = S.String;
export type LocalStorageType = "hdd" | "ssd" | (string & {});
export const LocalStorageType = S.String;
export type LocalStorageTypeSet = LocalStorageType[];
export const LocalStorageTypeSet = S.Array(
  LocalStorageType.pipe(T.XmlName("item")),
);
export interface TotalLocalStorageGBRequest {
  Min?: number;
  Max?: number;
}
export const TotalLocalStorageGBRequest = S.suspend(() =>
  S.Struct({ Min: S.optional(S.Number), Max: S.optional(S.Number) }),
).annotate({
  identifier: "TotalLocalStorageGBRequest",
}) as any as S.Schema<TotalLocalStorageGBRequest>;
export interface BaselineEbsBandwidthMbpsRequest {
  Min?: number;
  Max?: number;
}
export const BaselineEbsBandwidthMbpsRequest = S.suspend(() =>
  S.Struct({ Min: S.optional(S.Number), Max: S.optional(S.Number) }),
).annotate({
  identifier: "BaselineEbsBandwidthMbpsRequest",
}) as any as S.Schema<BaselineEbsBandwidthMbpsRequest>;
export type AcceleratorType =
  | "gpu"
  | "fpga"
  | "inference"
  | "media"
  | (string & {});
export const AcceleratorType = S.String;
export type AcceleratorTypeSet = AcceleratorType[];
export const AcceleratorTypeSet = S.Array(
  AcceleratorType.pipe(T.XmlName("item")),
);
export interface AcceleratorCountRequest {
  Min?: number;
  Max?: number;
}
export const AcceleratorCountRequest = S.suspend(() =>
  S.Struct({ Min: S.optional(S.Number), Max: S.optional(S.Number) }),
).annotate({
  identifier: "AcceleratorCountRequest",
}) as any as S.Schema<AcceleratorCountRequest>;
export type AcceleratorManufacturer =
  | "amazon-web-services"
  | "amd"
  | "nvidia"
  | "xilinx"
  | "habana"
  | (string & {});
export const AcceleratorManufacturer = S.String;
export type AcceleratorManufacturerSet = AcceleratorManufacturer[];
export const AcceleratorManufacturerSet = S.Array(
  AcceleratorManufacturer.pipe(T.XmlName("item")),
);
export type AcceleratorName =
  | "a100"
  | "inferentia"
  | "k520"
  | "k80"
  | "m60"
  | "radeon-pro-v520"
  | "t4"
  | "vu9p"
  | "v100"
  | "a10g"
  | "h100"
  | "t4g"
  | "l40s"
  | "l4"
  | "gaudi-hl-205"
  | "inferentia2"
  | "trainium"
  | "trainium2"
  | "u30"
  | (string & {});
export const AcceleratorName = S.String;
export type AcceleratorNameSet = AcceleratorName[];
export const AcceleratorNameSet = S.Array(
  AcceleratorName.pipe(T.XmlName("item")),
);
export interface AcceleratorTotalMemoryMiBRequest {
  Min?: number;
  Max?: number;
}
export const AcceleratorTotalMemoryMiBRequest = S.suspend(() =>
  S.Struct({ Min: S.optional(S.Number), Max: S.optional(S.Number) }),
).annotate({
  identifier: "AcceleratorTotalMemoryMiBRequest",
}) as any as S.Schema<AcceleratorTotalMemoryMiBRequest>;
export interface NetworkBandwidthGbpsRequest {
  Min?: number;
  Max?: number;
}
export const NetworkBandwidthGbpsRequest = S.suspend(() =>
  S.Struct({ Min: S.optional(S.Number), Max: S.optional(S.Number) }),
).annotate({
  identifier: "NetworkBandwidthGbpsRequest",
}) as any as S.Schema<NetworkBandwidthGbpsRequest>;
export type AllowedInstanceTypeSet = string[];
export const AllowedInstanceTypeSet = S.Array(S.String.pipe(T.XmlName("item")));
export interface PerformanceFactorReferenceRequest {
  InstanceFamily?: string;
}
export const PerformanceFactorReferenceRequest = S.suspend(() =>
  S.Struct({ InstanceFamily: S.optional(S.String) }),
).annotate({
  identifier: "PerformanceFactorReferenceRequest",
}) as any as S.Schema<PerformanceFactorReferenceRequest>;
export type PerformanceFactorReferenceSetRequest =
  PerformanceFactorReferenceRequest[];
export const PerformanceFactorReferenceSetRequest = S.Array(
  PerformanceFactorReferenceRequest.pipe(T.XmlName("item")).annotate({
    identifier: "PerformanceFactorReferenceRequest",
  }),
);
export interface CpuPerformanceFactorRequest {
  References?: PerformanceFactorReferenceRequest[];
}
export const CpuPerformanceFactorRequest = S.suspend(() =>
  S.Struct({
    References: S.optional(PerformanceFactorReferenceSetRequest).pipe(
      T.XmlName("Reference"),
    ),
  }),
).annotate({
  identifier: "CpuPerformanceFactorRequest",
}) as any as S.Schema<CpuPerformanceFactorRequest>;
export interface BaselinePerformanceFactorsRequest {
  Cpu?: CpuPerformanceFactorRequest;
}
export const BaselinePerformanceFactorsRequest = S.suspend(() =>
  S.Struct({ Cpu: S.optional(CpuPerformanceFactorRequest) }),
).annotate({
  identifier: "BaselinePerformanceFactorsRequest",
}) as any as S.Schema<BaselinePerformanceFactorsRequest>;
export interface InstanceRequirementsRequest {
  VCpuCount?: VCpuCountRangeRequest;
  MemoryMiB?: MemoryMiBRequest;
  CpuManufacturers?: CpuManufacturer[];
  MemoryGiBPerVCpu?: MemoryGiBPerVCpuRequest;
  ExcludedInstanceTypes?: string[];
  InstanceGenerations?: InstanceGeneration[];
  SpotMaxPricePercentageOverLowestPrice?: number;
  OnDemandMaxPricePercentageOverLowestPrice?: number;
  BareMetal?: BareMetal;
  BurstablePerformance?: BurstablePerformance;
  RequireHibernateSupport?: boolean;
  NetworkInterfaceCount?: NetworkInterfaceCountRequest;
  LocalStorage?: LocalStorage;
  LocalStorageTypes?: LocalStorageType[];
  TotalLocalStorageGB?: TotalLocalStorageGBRequest;
  BaselineEbsBandwidthMbps?: BaselineEbsBandwidthMbpsRequest;
  AcceleratorTypes?: AcceleratorType[];
  AcceleratorCount?: AcceleratorCountRequest;
  AcceleratorManufacturers?: AcceleratorManufacturer[];
  AcceleratorNames?: AcceleratorName[];
  AcceleratorTotalMemoryMiB?: AcceleratorTotalMemoryMiBRequest;
  NetworkBandwidthGbps?: NetworkBandwidthGbpsRequest;
  AllowedInstanceTypes?: string[];
  MaxSpotPriceAsPercentageOfOptimalOnDemandPrice?: number;
  BaselinePerformanceFactors?: BaselinePerformanceFactorsRequest;
  RequireEncryptionInTransit?: boolean;
}
export const InstanceRequirementsRequest = S.suspend(() =>
  S.Struct({
    VCpuCount: S.optional(VCpuCountRangeRequest),
    MemoryMiB: S.optional(MemoryMiBRequest),
    CpuManufacturers: S.optional(CpuManufacturerSet).pipe(
      T.XmlName("CpuManufacturer"),
    ),
    MemoryGiBPerVCpu: S.optional(MemoryGiBPerVCpuRequest),
    ExcludedInstanceTypes: S.optional(ExcludedInstanceTypeSet).pipe(
      T.XmlName("ExcludedInstanceType"),
    ),
    InstanceGenerations: S.optional(InstanceGenerationSet).pipe(
      T.XmlName("InstanceGeneration"),
    ),
    SpotMaxPricePercentageOverLowestPrice: S.optional(S.Number),
    OnDemandMaxPricePercentageOverLowestPrice: S.optional(S.Number),
    BareMetal: S.optional(BareMetal),
    BurstablePerformance: S.optional(BurstablePerformance),
    RequireHibernateSupport: S.optional(S.Boolean),
    NetworkInterfaceCount: S.optional(NetworkInterfaceCountRequest),
    LocalStorage: S.optional(LocalStorage),
    LocalStorageTypes: S.optional(LocalStorageTypeSet).pipe(
      T.XmlName("LocalStorageType"),
    ),
    TotalLocalStorageGB: S.optional(TotalLocalStorageGBRequest),
    BaselineEbsBandwidthMbps: S.optional(BaselineEbsBandwidthMbpsRequest),
    AcceleratorTypes: S.optional(AcceleratorTypeSet).pipe(
      T.XmlName("AcceleratorType"),
    ),
    AcceleratorCount: S.optional(AcceleratorCountRequest),
    AcceleratorManufacturers: S.optional(AcceleratorManufacturerSet).pipe(
      T.XmlName("AcceleratorManufacturer"),
    ),
    AcceleratorNames: S.optional(AcceleratorNameSet).pipe(
      T.XmlName("AcceleratorName"),
    ),
    AcceleratorTotalMemoryMiB: S.optional(AcceleratorTotalMemoryMiBRequest),
    NetworkBandwidthGbps: S.optional(NetworkBandwidthGbpsRequest),
    AllowedInstanceTypes: S.optional(AllowedInstanceTypeSet).pipe(
      T.XmlName("AllowedInstanceType"),
    ),
    MaxSpotPriceAsPercentageOfOptimalOnDemandPrice: S.optional(S.Number),
    BaselinePerformanceFactors: S.optional(BaselinePerformanceFactorsRequest),
    RequireEncryptionInTransit: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "InstanceRequirementsRequest",
}) as any as S.Schema<InstanceRequirementsRequest>;
export interface FleetLaunchTemplateOverridesRequest {
  InstanceType?: InstanceType;
  MaxPrice?: string;
  SubnetId?: string;
  AvailabilityZone?: string;
  WeightedCapacity?: number;
  Priority?: number;
  Placement?: Placement;
  BlockDeviceMappings?: FleetBlockDeviceMappingRequest[];
  InstanceRequirements?: InstanceRequirementsRequest;
  ImageId?: string;
  AvailabilityZoneId?: string;
}
export const FleetLaunchTemplateOverridesRequest = S.suspend(() =>
  S.Struct({
    InstanceType: S.optional(InstanceType),
    MaxPrice: S.optional(S.String),
    SubnetId: S.optional(S.String),
    AvailabilityZone: S.optional(S.String),
    WeightedCapacity: S.optional(S.Number),
    Priority: S.optional(S.Number),
    Placement: S.optional(Placement),
    BlockDeviceMappings: S.optional(FleetBlockDeviceMappingRequestList).pipe(
      T.XmlName("BlockDeviceMapping"),
    ),
    InstanceRequirements: S.optional(InstanceRequirementsRequest),
    ImageId: S.optional(S.String),
    AvailabilityZoneId: S.optional(S.String),
  }),
).annotate({
  identifier: "FleetLaunchTemplateOverridesRequest",
}) as any as S.Schema<FleetLaunchTemplateOverridesRequest>;
export type FleetLaunchTemplateOverridesListRequest =
  FleetLaunchTemplateOverridesRequest[];
export const FleetLaunchTemplateOverridesListRequest = S.Array(
  FleetLaunchTemplateOverridesRequest.pipe(T.XmlName("item")).annotate({
    identifier: "FleetLaunchTemplateOverridesRequest",
  }),
);
export interface FleetLaunchTemplateConfigRequest {
  LaunchTemplateSpecification?: FleetLaunchTemplateSpecificationRequest;
  Overrides?: FleetLaunchTemplateOverridesRequest[];
}
export const FleetLaunchTemplateConfigRequest = S.suspend(() =>
  S.Struct({
    LaunchTemplateSpecification: S.optional(
      FleetLaunchTemplateSpecificationRequest,
    ),
    Overrides: S.optional(FleetLaunchTemplateOverridesListRequest),
  }),
).annotate({
  identifier: "FleetLaunchTemplateConfigRequest",
}) as any as S.Schema<FleetLaunchTemplateConfigRequest>;
export type FleetLaunchTemplateConfigListRequest =
  FleetLaunchTemplateConfigRequest[];
export const FleetLaunchTemplateConfigListRequest = S.Array(
  FleetLaunchTemplateConfigRequest.pipe(T.XmlName("item")).annotate({
    identifier: "FleetLaunchTemplateConfigRequest",
  }),
);
export type DefaultTargetCapacityType =
  | "spot"
  | "on-demand"
  | "capacity-block"
  | (string & {});
export const DefaultTargetCapacityType = S.String;
export type TargetCapacityUnitType =
  | "vcpu"
  | "memory-mib"
  | "units"
  | (string & {});
export const TargetCapacityUnitType = S.String;
export interface TargetCapacitySpecificationRequest {
  TotalTargetCapacity?: number;
  OnDemandTargetCapacity?: number;
  SpotTargetCapacity?: number;
  DefaultTargetCapacityType?: DefaultTargetCapacityType;
  TargetCapacityUnitType?: TargetCapacityUnitType;
}
export const TargetCapacitySpecificationRequest = S.suspend(() =>
  S.Struct({
    TotalTargetCapacity: S.optional(S.Number),
    OnDemandTargetCapacity: S.optional(S.Number),
    SpotTargetCapacity: S.optional(S.Number),
    DefaultTargetCapacityType: S.optional(DefaultTargetCapacityType),
    TargetCapacityUnitType: S.optional(TargetCapacityUnitType),
  }),
).annotate({
  identifier: "TargetCapacitySpecificationRequest",
}) as any as S.Schema<TargetCapacitySpecificationRequest>;
export type FleetType = "request" | "maintain" | "instant" | (string & {});
export const FleetType = S.String;
export interface CreateFleetRequest {
  DryRun?: boolean;
  ClientToken?: string;
  SpotOptions?: SpotOptionsRequest;
  OnDemandOptions?: OnDemandOptionsRequest;
  ExcessCapacityTerminationPolicy?: FleetExcessCapacityTerminationPolicy;
  LaunchTemplateConfigs?: FleetLaunchTemplateConfigRequest[];
  TargetCapacitySpecification?: TargetCapacitySpecificationRequest;
  TerminateInstancesWithExpiration?: boolean;
  Type?: FleetType;
  ValidFrom?: Date;
  ValidUntil?: Date;
  ReplaceUnhealthyInstances?: boolean;
  TagSpecifications?: TagSpecification[];
  Context?: string;
}
export const CreateFleetRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    SpotOptions: S.optional(SpotOptionsRequest),
    OnDemandOptions: S.optional(OnDemandOptionsRequest),
    ExcessCapacityTerminationPolicy: S.optional(
      FleetExcessCapacityTerminationPolicy,
    ),
    LaunchTemplateConfigs: S.optional(FleetLaunchTemplateConfigListRequest),
    TargetCapacitySpecification: S.optional(TargetCapacitySpecificationRequest),
    TerminateInstancesWithExpiration: S.optional(S.Boolean),
    Type: S.optional(FleetType),
    ValidFrom: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    ValidUntil: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    ReplaceUnhealthyInstances: S.optional(S.Boolean),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    Context: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateFleetRequest",
}) as any as S.Schema<CreateFleetRequest>;
export interface FleetLaunchTemplateSpecification {
  LaunchTemplateId?: string;
  LaunchTemplateName?: string;
  Version?: string;
}
export const FleetLaunchTemplateSpecification = S.suspend(() =>
  S.Struct({
    LaunchTemplateId: S.optional(S.String).pipe(
      T.XmlName("launchTemplateId"),
      T.Ec2QueryName("LaunchTemplateId"),
    ),
    LaunchTemplateName: S.optional(S.String).pipe(
      T.XmlName("launchTemplateName"),
      T.Ec2QueryName("LaunchTemplateName"),
    ),
    Version: S.optional(S.String).pipe(
      T.XmlName("version"),
      T.Ec2QueryName("Version"),
    ),
  }),
).annotate({
  identifier: "FleetLaunchTemplateSpecification",
}) as any as S.Schema<FleetLaunchTemplateSpecification>;
export interface PlacementResponse {
  GroupName?: string;
}
export const PlacementResponse = S.suspend(() =>
  S.Struct({
    GroupName: S.optional(S.String).pipe(
      T.XmlName("groupName"),
      T.Ec2QueryName("GroupName"),
    ),
  }),
).annotate({
  identifier: "PlacementResponse",
}) as any as S.Schema<PlacementResponse>;
export interface VCpuCountRange {
  Min?: number;
  Max?: number;
}
export const VCpuCountRange = S.suspend(() =>
  S.Struct({
    Min: S.optional(S.Number).pipe(T.XmlName("min"), T.Ec2QueryName("Min")),
    Max: S.optional(S.Number).pipe(T.XmlName("max"), T.Ec2QueryName("Max")),
  }),
).annotate({ identifier: "VCpuCountRange" }) as any as S.Schema<VCpuCountRange>;
export interface MemoryMiB {
  Min?: number;
  Max?: number;
}
export const MemoryMiB = S.suspend(() =>
  S.Struct({
    Min: S.optional(S.Number).pipe(T.XmlName("min"), T.Ec2QueryName("Min")),
    Max: S.optional(S.Number).pipe(T.XmlName("max"), T.Ec2QueryName("Max")),
  }),
).annotate({ identifier: "MemoryMiB" }) as any as S.Schema<MemoryMiB>;
export interface MemoryGiBPerVCpu {
  Min?: number;
  Max?: number;
}
export const MemoryGiBPerVCpu = S.suspend(() =>
  S.Struct({
    Min: S.optional(S.Number).pipe(T.XmlName("min"), T.Ec2QueryName("Min")),
    Max: S.optional(S.Number).pipe(T.XmlName("max"), T.Ec2QueryName("Max")),
  }),
).annotate({
  identifier: "MemoryGiBPerVCpu",
}) as any as S.Schema<MemoryGiBPerVCpu>;
export interface NetworkInterfaceCount {
  Min?: number;
  Max?: number;
}
export const NetworkInterfaceCount = S.suspend(() =>
  S.Struct({
    Min: S.optional(S.Number).pipe(T.XmlName("min"), T.Ec2QueryName("Min")),
    Max: S.optional(S.Number).pipe(T.XmlName("max"), T.Ec2QueryName("Max")),
  }),
).annotate({
  identifier: "NetworkInterfaceCount",
}) as any as S.Schema<NetworkInterfaceCount>;
export interface TotalLocalStorageGB {
  Min?: number;
  Max?: number;
}
export const TotalLocalStorageGB = S.suspend(() =>
  S.Struct({
    Min: S.optional(S.Number).pipe(T.XmlName("min"), T.Ec2QueryName("Min")),
    Max: S.optional(S.Number).pipe(T.XmlName("max"), T.Ec2QueryName("Max")),
  }),
).annotate({
  identifier: "TotalLocalStorageGB",
}) as any as S.Schema<TotalLocalStorageGB>;
export interface BaselineEbsBandwidthMbps {
  Min?: number;
  Max?: number;
}
export const BaselineEbsBandwidthMbps = S.suspend(() =>
  S.Struct({
    Min: S.optional(S.Number).pipe(T.XmlName("min"), T.Ec2QueryName("Min")),
    Max: S.optional(S.Number).pipe(T.XmlName("max"), T.Ec2QueryName("Max")),
  }),
).annotate({
  identifier: "BaselineEbsBandwidthMbps",
}) as any as S.Schema<BaselineEbsBandwidthMbps>;
export interface AcceleratorCount {
  Min?: number;
  Max?: number;
}
export const AcceleratorCount = S.suspend(() =>
  S.Struct({
    Min: S.optional(S.Number).pipe(T.XmlName("min"), T.Ec2QueryName("Min")),
    Max: S.optional(S.Number).pipe(T.XmlName("max"), T.Ec2QueryName("Max")),
  }),
).annotate({
  identifier: "AcceleratorCount",
}) as any as S.Schema<AcceleratorCount>;
export interface AcceleratorTotalMemoryMiB {
  Min?: number;
  Max?: number;
}
export const AcceleratorTotalMemoryMiB = S.suspend(() =>
  S.Struct({
    Min: S.optional(S.Number).pipe(T.XmlName("min"), T.Ec2QueryName("Min")),
    Max: S.optional(S.Number).pipe(T.XmlName("max"), T.Ec2QueryName("Max")),
  }),
).annotate({
  identifier: "AcceleratorTotalMemoryMiB",
}) as any as S.Schema<AcceleratorTotalMemoryMiB>;
export interface NetworkBandwidthGbps {
  Min?: number;
  Max?: number;
}
export const NetworkBandwidthGbps = S.suspend(() =>
  S.Struct({
    Min: S.optional(S.Number).pipe(T.XmlName("min"), T.Ec2QueryName("Min")),
    Max: S.optional(S.Number).pipe(T.XmlName("max"), T.Ec2QueryName("Max")),
  }),
).annotate({
  identifier: "NetworkBandwidthGbps",
}) as any as S.Schema<NetworkBandwidthGbps>;
export interface PerformanceFactorReference {
  InstanceFamily?: string;
}
export const PerformanceFactorReference = S.suspend(() =>
  S.Struct({
    InstanceFamily: S.optional(S.String).pipe(
      T.XmlName("instanceFamily"),
      T.Ec2QueryName("InstanceFamily"),
    ),
  }),
).annotate({
  identifier: "PerformanceFactorReference",
}) as any as S.Schema<PerformanceFactorReference>;
export type PerformanceFactorReferenceSet = PerformanceFactorReference[];
export const PerformanceFactorReferenceSet = S.Array(
  PerformanceFactorReference.pipe(T.XmlName("item")).annotate({
    identifier: "PerformanceFactorReference",
  }),
);
export interface CpuPerformanceFactor {
  References?: PerformanceFactorReference[];
}
export const CpuPerformanceFactor = S.suspend(() =>
  S.Struct({
    References: S.optional(PerformanceFactorReferenceSet).pipe(
      T.XmlName("referenceSet"),
      T.Ec2QueryName("ReferenceSet"),
    ),
  }),
).annotate({
  identifier: "CpuPerformanceFactor",
}) as any as S.Schema<CpuPerformanceFactor>;
export interface BaselinePerformanceFactors {
  Cpu?: CpuPerformanceFactor;
}
export const BaselinePerformanceFactors = S.suspend(() =>
  S.Struct({
    Cpu: S.optional(CpuPerformanceFactor)
      .pipe(T.XmlName("cpu"), T.Ec2QueryName("Cpu"))
      .annotate({ identifier: "CpuPerformanceFactor" }),
  }),
).annotate({
  identifier: "BaselinePerformanceFactors",
}) as any as S.Schema<BaselinePerformanceFactors>;
export interface InstanceRequirements {
  VCpuCount?: VCpuCountRange;
  MemoryMiB?: MemoryMiB;
  CpuManufacturers?: CpuManufacturer[];
  MemoryGiBPerVCpu?: MemoryGiBPerVCpu;
  ExcludedInstanceTypes?: string[];
  InstanceGenerations?: InstanceGeneration[];
  SpotMaxPricePercentageOverLowestPrice?: number;
  OnDemandMaxPricePercentageOverLowestPrice?: number;
  BareMetal?: BareMetal;
  BurstablePerformance?: BurstablePerformance;
  RequireHibernateSupport?: boolean;
  NetworkInterfaceCount?: NetworkInterfaceCount;
  LocalStorage?: LocalStorage;
  LocalStorageTypes?: LocalStorageType[];
  TotalLocalStorageGB?: TotalLocalStorageGB;
  BaselineEbsBandwidthMbps?: BaselineEbsBandwidthMbps;
  AcceleratorTypes?: AcceleratorType[];
  AcceleratorCount?: AcceleratorCount;
  AcceleratorManufacturers?: AcceleratorManufacturer[];
  AcceleratorNames?: AcceleratorName[];
  AcceleratorTotalMemoryMiB?: AcceleratorTotalMemoryMiB;
  NetworkBandwidthGbps?: NetworkBandwidthGbps;
  AllowedInstanceTypes?: string[];
  MaxSpotPriceAsPercentageOfOptimalOnDemandPrice?: number;
  BaselinePerformanceFactors?: BaselinePerformanceFactors;
  RequireEncryptionInTransit?: boolean;
}
export const InstanceRequirements = S.suspend(() =>
  S.Struct({
    VCpuCount: S.optional(VCpuCountRange)
      .pipe(T.XmlName("vCpuCount"), T.Ec2QueryName("VCpuCount"))
      .annotate({ identifier: "VCpuCountRange" }),
    MemoryMiB: S.optional(MemoryMiB)
      .pipe(T.XmlName("memoryMiB"), T.Ec2QueryName("MemoryMiB"))
      .annotate({ identifier: "MemoryMiB" }),
    CpuManufacturers: S.optional(CpuManufacturerSet).pipe(
      T.XmlName("cpuManufacturerSet"),
      T.Ec2QueryName("CpuManufacturerSet"),
    ),
    MemoryGiBPerVCpu: S.optional(MemoryGiBPerVCpu)
      .pipe(T.XmlName("memoryGiBPerVCpu"), T.Ec2QueryName("MemoryGiBPerVCpu"))
      .annotate({ identifier: "MemoryGiBPerVCpu" }),
    ExcludedInstanceTypes: S.optional(ExcludedInstanceTypeSet).pipe(
      T.XmlName("excludedInstanceTypeSet"),
      T.Ec2QueryName("ExcludedInstanceTypeSet"),
    ),
    InstanceGenerations: S.optional(InstanceGenerationSet).pipe(
      T.XmlName("instanceGenerationSet"),
      T.Ec2QueryName("InstanceGenerationSet"),
    ),
    SpotMaxPricePercentageOverLowestPrice: S.optional(S.Number).pipe(
      T.XmlName("spotMaxPricePercentageOverLowestPrice"),
      T.Ec2QueryName("SpotMaxPricePercentageOverLowestPrice"),
    ),
    OnDemandMaxPricePercentageOverLowestPrice: S.optional(S.Number).pipe(
      T.XmlName("onDemandMaxPricePercentageOverLowestPrice"),
      T.Ec2QueryName("OnDemandMaxPricePercentageOverLowestPrice"),
    ),
    BareMetal: S.optional(BareMetal).pipe(
      T.XmlName("bareMetal"),
      T.Ec2QueryName("BareMetal"),
    ),
    BurstablePerformance: S.optional(BurstablePerformance).pipe(
      T.XmlName("burstablePerformance"),
      T.Ec2QueryName("BurstablePerformance"),
    ),
    RequireHibernateSupport: S.optional(S.Boolean).pipe(
      T.XmlName("requireHibernateSupport"),
      T.Ec2QueryName("RequireHibernateSupport"),
    ),
    NetworkInterfaceCount: S.optional(NetworkInterfaceCount)
      .pipe(
        T.XmlName("networkInterfaceCount"),
        T.Ec2QueryName("NetworkInterfaceCount"),
      )
      .annotate({ identifier: "NetworkInterfaceCount" }),
    LocalStorage: S.optional(LocalStorage).pipe(
      T.XmlName("localStorage"),
      T.Ec2QueryName("LocalStorage"),
    ),
    LocalStorageTypes: S.optional(LocalStorageTypeSet).pipe(
      T.XmlName("localStorageTypeSet"),
      T.Ec2QueryName("LocalStorageTypeSet"),
    ),
    TotalLocalStorageGB: S.optional(TotalLocalStorageGB)
      .pipe(
        T.XmlName("totalLocalStorageGB"),
        T.Ec2QueryName("TotalLocalStorageGB"),
      )
      .annotate({ identifier: "TotalLocalStorageGB" }),
    BaselineEbsBandwidthMbps: S.optional(BaselineEbsBandwidthMbps)
      .pipe(
        T.XmlName("baselineEbsBandwidthMbps"),
        T.Ec2QueryName("BaselineEbsBandwidthMbps"),
      )
      .annotate({ identifier: "BaselineEbsBandwidthMbps" }),
    AcceleratorTypes: S.optional(AcceleratorTypeSet).pipe(
      T.XmlName("acceleratorTypeSet"),
      T.Ec2QueryName("AcceleratorTypeSet"),
    ),
    AcceleratorCount: S.optional(AcceleratorCount)
      .pipe(T.XmlName("acceleratorCount"), T.Ec2QueryName("AcceleratorCount"))
      .annotate({ identifier: "AcceleratorCount" }),
    AcceleratorManufacturers: S.optional(AcceleratorManufacturerSet).pipe(
      T.XmlName("acceleratorManufacturerSet"),
      T.Ec2QueryName("AcceleratorManufacturerSet"),
    ),
    AcceleratorNames: S.optional(AcceleratorNameSet).pipe(
      T.XmlName("acceleratorNameSet"),
      T.Ec2QueryName("AcceleratorNameSet"),
    ),
    AcceleratorTotalMemoryMiB: S.optional(AcceleratorTotalMemoryMiB)
      .pipe(
        T.XmlName("acceleratorTotalMemoryMiB"),
        T.Ec2QueryName("AcceleratorTotalMemoryMiB"),
      )
      .annotate({ identifier: "AcceleratorTotalMemoryMiB" }),
    NetworkBandwidthGbps: S.optional(NetworkBandwidthGbps)
      .pipe(
        T.XmlName("networkBandwidthGbps"),
        T.Ec2QueryName("NetworkBandwidthGbps"),
      )
      .annotate({ identifier: "NetworkBandwidthGbps" }),
    AllowedInstanceTypes: S.optional(AllowedInstanceTypeSet).pipe(
      T.XmlName("allowedInstanceTypeSet"),
      T.Ec2QueryName("AllowedInstanceTypeSet"),
    ),
    MaxSpotPriceAsPercentageOfOptimalOnDemandPrice: S.optional(S.Number).pipe(
      T.XmlName("maxSpotPriceAsPercentageOfOptimalOnDemandPrice"),
      T.Ec2QueryName("MaxSpotPriceAsPercentageOfOptimalOnDemandPrice"),
    ),
    BaselinePerformanceFactors: S.optional(BaselinePerformanceFactors)
      .pipe(
        T.XmlName("baselinePerformanceFactors"),
        T.Ec2QueryName("BaselinePerformanceFactors"),
      )
      .annotate({ identifier: "BaselinePerformanceFactors" }),
    RequireEncryptionInTransit: S.optional(S.Boolean).pipe(
      T.XmlName("requireEncryptionInTransit"),
      T.Ec2QueryName("RequireEncryptionInTransit"),
    ),
  }),
).annotate({
  identifier: "InstanceRequirements",
}) as any as S.Schema<InstanceRequirements>;
export interface EbsBlockDeviceResponse {
  Encrypted?: boolean;
  DeleteOnTermination?: boolean;
  Iops?: number;
  Throughput?: number;
  KmsKeyId?: string;
  SnapshotId?: string;
  VolumeSize?: number;
  VolumeType?: VolumeType;
}
export const EbsBlockDeviceResponse = S.suspend(() =>
  S.Struct({
    Encrypted: S.optional(S.Boolean).pipe(
      T.XmlName("encrypted"),
      T.Ec2QueryName("Encrypted"),
    ),
    DeleteOnTermination: S.optional(S.Boolean).pipe(
      T.XmlName("deleteOnTermination"),
      T.Ec2QueryName("DeleteOnTermination"),
    ),
    Iops: S.optional(S.Number).pipe(T.XmlName("iops"), T.Ec2QueryName("Iops")),
    Throughput: S.optional(S.Number).pipe(
      T.XmlName("throughput"),
      T.Ec2QueryName("Throughput"),
    ),
    KmsKeyId: S.optional(S.String).pipe(
      T.XmlName("kmsKeyId"),
      T.Ec2QueryName("KmsKeyId"),
    ),
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    VolumeSize: S.optional(S.Number).pipe(
      T.XmlName("volumeSize"),
      T.Ec2QueryName("VolumeSize"),
    ),
    VolumeType: S.optional(VolumeType).pipe(
      T.XmlName("volumeType"),
      T.Ec2QueryName("VolumeType"),
    ),
  }),
).annotate({
  identifier: "EbsBlockDeviceResponse",
}) as any as S.Schema<EbsBlockDeviceResponse>;
export interface BlockDeviceMappingResponse {
  DeviceName?: string;
  VirtualName?: string;
  Ebs?: EbsBlockDeviceResponse;
  NoDevice?: string;
}
export const BlockDeviceMappingResponse = S.suspend(() =>
  S.Struct({
    DeviceName: S.optional(S.String).pipe(
      T.XmlName("deviceName"),
      T.Ec2QueryName("DeviceName"),
    ),
    VirtualName: S.optional(S.String).pipe(
      T.XmlName("virtualName"),
      T.Ec2QueryName("VirtualName"),
    ),
    Ebs: S.optional(EbsBlockDeviceResponse)
      .pipe(T.XmlName("ebs"), T.Ec2QueryName("Ebs"))
      .annotate({ identifier: "EbsBlockDeviceResponse" }),
    NoDevice: S.optional(S.String).pipe(
      T.XmlName("noDevice"),
      T.Ec2QueryName("NoDevice"),
    ),
  }),
).annotate({
  identifier: "BlockDeviceMappingResponse",
}) as any as S.Schema<BlockDeviceMappingResponse>;
export type BlockDeviceMappingResponseList = BlockDeviceMappingResponse[];
export const BlockDeviceMappingResponseList = S.Array(
  BlockDeviceMappingResponse.pipe(T.XmlName("item")).annotate({
    identifier: "BlockDeviceMappingResponse",
  }),
);
export interface FleetLaunchTemplateOverrides {
  InstanceType?: InstanceType;
  MaxPrice?: string;
  SubnetId?: string;
  AvailabilityZone?: string;
  WeightedCapacity?: number;
  Priority?: number;
  Placement?: PlacementResponse;
  InstanceRequirements?: InstanceRequirements;
  ImageId?: string;
  BlockDeviceMappings?: BlockDeviceMappingResponse[];
  AvailabilityZoneId?: string;
}
export const FleetLaunchTemplateOverrides = S.suspend(() =>
  S.Struct({
    InstanceType: S.optional(InstanceType).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    MaxPrice: S.optional(S.String).pipe(
      T.XmlName("maxPrice"),
      T.Ec2QueryName("MaxPrice"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    WeightedCapacity: S.optional(S.Number).pipe(
      T.XmlName("weightedCapacity"),
      T.Ec2QueryName("WeightedCapacity"),
    ),
    Priority: S.optional(S.Number).pipe(
      T.XmlName("priority"),
      T.Ec2QueryName("Priority"),
    ),
    Placement: S.optional(PlacementResponse)
      .pipe(T.XmlName("placement"), T.Ec2QueryName("Placement"))
      .annotate({ identifier: "PlacementResponse" }),
    InstanceRequirements: S.optional(InstanceRequirements)
      .pipe(
        T.XmlName("instanceRequirements"),
        T.Ec2QueryName("InstanceRequirements"),
      )
      .annotate({ identifier: "InstanceRequirements" }),
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    BlockDeviceMappings: S.optional(BlockDeviceMappingResponseList).pipe(
      T.XmlName("blockDeviceMappingSet"),
      T.Ec2QueryName("BlockDeviceMappingSet"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
  }),
).annotate({
  identifier: "FleetLaunchTemplateOverrides",
}) as any as S.Schema<FleetLaunchTemplateOverrides>;
export interface LaunchTemplateAndOverridesResponse {
  LaunchTemplateSpecification?: FleetLaunchTemplateSpecification;
  Overrides?: FleetLaunchTemplateOverrides;
}
export const LaunchTemplateAndOverridesResponse = S.suspend(() =>
  S.Struct({
    LaunchTemplateSpecification: S.optional(FleetLaunchTemplateSpecification)
      .pipe(
        T.XmlName("launchTemplateSpecification"),
        T.Ec2QueryName("LaunchTemplateSpecification"),
      )
      .annotate({ identifier: "FleetLaunchTemplateSpecification" }),
    Overrides: S.optional(FleetLaunchTemplateOverrides)
      .pipe(T.XmlName("overrides"), T.Ec2QueryName("Overrides"))
      .annotate({ identifier: "FleetLaunchTemplateOverrides" }),
  }),
).annotate({
  identifier: "LaunchTemplateAndOverridesResponse",
}) as any as S.Schema<LaunchTemplateAndOverridesResponse>;
export type InstanceLifecycle = "spot" | "on-demand" | (string & {});
export const InstanceLifecycle = S.String;
export interface CreateFleetError_ {
  LaunchTemplateAndOverrides?: LaunchTemplateAndOverridesResponse;
  Lifecycle?: InstanceLifecycle;
  ErrorCode?: string;
  ErrorMessage?: string;
}
export const CreateFleetError_ = S.suspend(() =>
  S.Struct({
    LaunchTemplateAndOverrides: S.optional(LaunchTemplateAndOverridesResponse)
      .pipe(
        T.XmlName("launchTemplateAndOverrides"),
        T.Ec2QueryName("LaunchTemplateAndOverrides"),
      )
      .annotate({ identifier: "LaunchTemplateAndOverridesResponse" }),
    Lifecycle: S.optional(InstanceLifecycle).pipe(
      T.XmlName("lifecycle"),
      T.Ec2QueryName("Lifecycle"),
    ),
    ErrorCode: S.optional(S.String).pipe(
      T.XmlName("errorCode"),
      T.Ec2QueryName("ErrorCode"),
    ),
    ErrorMessage: S.optional(S.String).pipe(
      T.XmlName("errorMessage"),
      T.Ec2QueryName("ErrorMessage"),
    ),
  }),
).annotate({
  identifier: "CreateFleetError",
}) as any as S.Schema<CreateFleetError_>;
export type CreateFleetErrorsSet = CreateFleetError_[];
export const CreateFleetErrorsSet = S.Array(
  CreateFleetError_.pipe(T.XmlName("item")).annotate({
    identifier: "CreateFleetError",
  }),
);
export type InstanceIdsSet = string[];
export const InstanceIdsSet = S.Array(S.String.pipe(T.XmlName("item")));
export type PlatformValues = "Windows" | (string & {});
export const PlatformValues = S.String;
export interface CreateFleetInstance {
  LaunchTemplateAndOverrides?: LaunchTemplateAndOverridesResponse;
  Lifecycle?: InstanceLifecycle;
  InstanceIds?: string[];
  InstanceType?: InstanceType;
  Platform?: PlatformValues;
}
export const CreateFleetInstance = S.suspend(() =>
  S.Struct({
    LaunchTemplateAndOverrides: S.optional(LaunchTemplateAndOverridesResponse)
      .pipe(
        T.XmlName("launchTemplateAndOverrides"),
        T.Ec2QueryName("LaunchTemplateAndOverrides"),
      )
      .annotate({ identifier: "LaunchTemplateAndOverridesResponse" }),
    Lifecycle: S.optional(InstanceLifecycle).pipe(
      T.XmlName("lifecycle"),
      T.Ec2QueryName("Lifecycle"),
    ),
    InstanceIds: S.optional(InstanceIdsSet).pipe(
      T.XmlName("instanceIds"),
      T.Ec2QueryName("InstanceIds"),
    ),
    InstanceType: S.optional(InstanceType).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    Platform: S.optional(PlatformValues).pipe(
      T.XmlName("platform"),
      T.Ec2QueryName("Platform"),
    ),
  }),
).annotate({
  identifier: "CreateFleetInstance",
}) as any as S.Schema<CreateFleetInstance>;
export type CreateFleetInstancesSet = CreateFleetInstance[];
export const CreateFleetInstancesSet = S.Array(
  CreateFleetInstance.pipe(T.XmlName("item")).annotate({
    identifier: "CreateFleetInstance",
  }),
);
export interface CreateFleetResult {
  FleetId?: string;
  Errors?: CreateFleetError_[];
  Instances?: CreateFleetInstance[];
}
export const CreateFleetResult = S.suspend(() =>
  S.Struct({
    FleetId: S.optional(S.String).pipe(
      T.XmlName("fleetId"),
      T.Ec2QueryName("FleetId"),
    ),
    Errors: S.optional(CreateFleetErrorsSet).pipe(
      T.XmlName("errorSet"),
      T.Ec2QueryName("ErrorSet"),
    ),
    Instances: S.optional(CreateFleetInstancesSet).pipe(
      T.XmlName("fleetInstanceSet"),
      T.Ec2QueryName("FleetInstanceSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateFleetResult",
}) as any as S.Schema<CreateFleetResult>;
export type FlowLogResourceIds = string[];
export const FlowLogResourceIds = S.Array(S.String.pipe(T.XmlName("item")));
export type FlowLogsResourceType =
  | "VPC"
  | "Subnet"
  | "NetworkInterface"
  | "TransitGateway"
  | "TransitGatewayAttachment"
  | "RegionalNatGateway"
  | (string & {});
export const FlowLogsResourceType = S.String;
export type TrafficType = "ACCEPT" | "REJECT" | "ALL" | (string & {});
export const TrafficType = S.String;
export type LogDestinationType =
  | "cloud-watch-logs"
  | "s3"
  | "kinesis-data-firehose"
  | (string & {});
export const LogDestinationType = S.String;
export type DestinationFileFormat = "plain-text" | "parquet" | (string & {});
export const DestinationFileFormat = S.String;
export interface DestinationOptionsRequest {
  FileFormat?: DestinationFileFormat;
  HiveCompatiblePartitions?: boolean;
  PerHourPartition?: boolean;
}
export const DestinationOptionsRequest = S.suspend(() =>
  S.Struct({
    FileFormat: S.optional(DestinationFileFormat),
    HiveCompatiblePartitions: S.optional(S.Boolean),
    PerHourPartition: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "DestinationOptionsRequest",
}) as any as S.Schema<DestinationOptionsRequest>;
export interface CreateFlowLogsRequest {
  DryRun?: boolean;
  ClientToken?: string;
  DeliverLogsPermissionArn?: string;
  DeliverCrossAccountRole?: string;
  LogGroupName?: string;
  ResourceIds?: string[];
  ResourceType?: FlowLogsResourceType;
  TrafficType?: TrafficType;
  LogDestinationType?: LogDestinationType;
  LogDestination?: string;
  LogFormat?: string;
  TagSpecifications?: TagSpecification[];
  MaxAggregationInterval?: number;
  DestinationOptions?: DestinationOptionsRequest;
}
export const CreateFlowLogsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String),
    DeliverLogsPermissionArn: S.optional(S.String),
    DeliverCrossAccountRole: S.optional(S.String),
    LogGroupName: S.optional(S.String),
    ResourceIds: S.optional(FlowLogResourceIds).pipe(T.XmlName("ResourceId")),
    ResourceType: S.optional(FlowLogsResourceType),
    TrafficType: S.optional(TrafficType),
    LogDestinationType: S.optional(LogDestinationType),
    LogDestination: S.optional(S.String),
    LogFormat: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    MaxAggregationInterval: S.optional(S.Number),
    DestinationOptions: S.optional(DestinationOptionsRequest),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateFlowLogsRequest",
}) as any as S.Schema<CreateFlowLogsRequest>;
export interface CreateFlowLogsResult {
  ClientToken?: string;
  FlowLogIds?: string[];
  Unsuccessful?: UnsuccessfulItem[];
}
export const CreateFlowLogsResult = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
    FlowLogIds: S.optional(ValueStringList).pipe(
      T.XmlName("flowLogIdSet"),
      T.Ec2QueryName("FlowLogIdSet"),
    ),
    Unsuccessful: S.optional(UnsuccessfulItemSet).pipe(
      T.XmlName("unsuccessful"),
      T.Ec2QueryName("Unsuccessful"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateFlowLogsResult",
}) as any as S.Schema<CreateFlowLogsResult>;
export interface StorageLocation {
  Bucket?: string;
  Key?: string;
}
export const StorageLocation = S.suspend(() =>
  S.Struct({ Bucket: S.optional(S.String), Key: S.optional(S.String) }),
).annotate({
  identifier: "StorageLocation",
}) as any as S.Schema<StorageLocation>;
export interface CreateFpgaImageRequest {
  DryRun?: boolean;
  InputStorageLocation?: StorageLocation;
  LogsStorageLocation?: StorageLocation;
  Description?: string;
  Name?: string;
  ClientToken?: string;
  TagSpecifications?: TagSpecification[];
}
export const CreateFpgaImageRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    InputStorageLocation: S.optional(StorageLocation),
    LogsStorageLocation: S.optional(StorageLocation),
    Description: S.optional(S.String),
    Name: S.optional(S.String),
    ClientToken: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateFpgaImageRequest",
}) as any as S.Schema<CreateFpgaImageRequest>;
export interface CreateFpgaImageResult {
  FpgaImageId?: string;
  FpgaImageGlobalId?: string;
}
export const CreateFpgaImageResult = S.suspend(() =>
  S.Struct({
    FpgaImageId: S.optional(S.String).pipe(
      T.XmlName("fpgaImageId"),
      T.Ec2QueryName("FpgaImageId"),
    ),
    FpgaImageGlobalId: S.optional(S.String).pipe(
      T.XmlName("fpgaImageGlobalId"),
      T.Ec2QueryName("FpgaImageGlobalId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateFpgaImageResult",
}) as any as S.Schema<CreateFpgaImageResult>;
export type SnapshotLocationEnum = "regional" | "local" | (string & {});
export const SnapshotLocationEnum = S.String;
export interface EbsBlockDevice {
  DeleteOnTermination?: boolean;
  Iops?: number;
  SnapshotId?: string;
  VolumeSize?: number;
  VolumeType?: VolumeType;
  KmsKeyId?: string;
  Throughput?: number;
  OutpostArn?: string;
  AvailabilityZone?: string;
  Encrypted?: boolean;
  VolumeInitializationRate?: number;
  AvailabilityZoneId?: string;
  EbsCardIndex?: number;
}
export const EbsBlockDevice = S.suspend(() =>
  S.Struct({
    DeleteOnTermination: S.optional(S.Boolean).pipe(
      T.XmlName("deleteOnTermination"),
      T.Ec2QueryName("DeleteOnTermination"),
    ),
    Iops: S.optional(S.Number).pipe(T.XmlName("iops"), T.Ec2QueryName("Iops")),
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    VolumeSize: S.optional(S.Number).pipe(
      T.XmlName("volumeSize"),
      T.Ec2QueryName("VolumeSize"),
    ),
    VolumeType: S.optional(VolumeType).pipe(
      T.XmlName("volumeType"),
      T.Ec2QueryName("VolumeType"),
    ),
    KmsKeyId: S.optional(S.String).pipe(
      T.XmlName("kmsKeyId"),
      T.Ec2QueryName("KmsKeyId"),
    ),
    Throughput: S.optional(S.Number).pipe(
      T.XmlName("throughput"),
      T.Ec2QueryName("Throughput"),
    ),
    OutpostArn: S.optional(S.String).pipe(
      T.XmlName("outpostArn"),
      T.Ec2QueryName("OutpostArn"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    Encrypted: S.optional(S.Boolean).pipe(
      T.XmlName("encrypted"),
      T.Ec2QueryName("Encrypted"),
    ),
    VolumeInitializationRate: S.optional(S.Number),
    AvailabilityZoneId: S.optional(S.String),
    EbsCardIndex: S.optional(S.Number),
  }),
).annotate({ identifier: "EbsBlockDevice" }) as any as S.Schema<EbsBlockDevice>;
export interface BlockDeviceMapping {
  Ebs?: EbsBlockDevice;
  NoDevice?: string;
  DeviceName?: string;
  VirtualName?: string;
}
export const BlockDeviceMapping = S.suspend(() =>
  S.Struct({
    Ebs: S.optional(EbsBlockDevice)
      .pipe(T.XmlName("ebs"), T.Ec2QueryName("Ebs"))
      .annotate({ identifier: "EbsBlockDevice" }),
    NoDevice: S.optional(S.String).pipe(
      T.XmlName("noDevice"),
      T.Ec2QueryName("NoDevice"),
    ),
    DeviceName: S.optional(S.String).pipe(
      T.XmlName("deviceName"),
      T.Ec2QueryName("DeviceName"),
    ),
    VirtualName: S.optional(S.String).pipe(
      T.XmlName("virtualName"),
      T.Ec2QueryName("VirtualName"),
    ),
  }),
).annotate({
  identifier: "BlockDeviceMapping",
}) as any as S.Schema<BlockDeviceMapping>;
export type BlockDeviceMappingRequestList = BlockDeviceMapping[];
export const BlockDeviceMappingRequestList = S.Array(
  BlockDeviceMapping.pipe(T.XmlName("BlockDeviceMapping")).annotate({
    identifier: "BlockDeviceMapping",
  }),
);
export interface CreateImageRequest {
  TagSpecifications?: TagSpecification[];
  SnapshotLocation?: SnapshotLocationEnum;
  DryRun?: boolean;
  InstanceId?: string;
  Name?: string;
  Description?: string;
  NoReboot?: boolean;
  BlockDeviceMappings?: BlockDeviceMapping[];
}
export const CreateImageRequest = S.suspend(() =>
  S.Struct({
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    SnapshotLocation: S.optional(SnapshotLocationEnum),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    NoReboot: S.optional(S.Boolean).pipe(
      T.XmlName("noReboot"),
      T.Ec2QueryName("NoReboot"),
    ),
    BlockDeviceMappings: S.optional(BlockDeviceMappingRequestList).pipe(
      T.XmlName("blockDeviceMapping"),
      T.Ec2QueryName("BlockDeviceMapping"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateImageRequest",
}) as any as S.Schema<CreateImageRequest>;
export interface CreateImageResult {
  ImageId?: string;
}
export const CreateImageResult = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateImageResult",
}) as any as S.Schema<CreateImageResult>;
export type ImageUsageResourceTypeOptionValuesList = string[];
export const ImageUsageResourceTypeOptionValuesList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface ImageUsageResourceTypeOptionRequest {
  OptionName?: string;
  OptionValues?: string[];
}
export const ImageUsageResourceTypeOptionRequest = S.suspend(() =>
  S.Struct({
    OptionName: S.optional(S.String),
    OptionValues: S.optional(ImageUsageResourceTypeOptionValuesList).pipe(
      T.XmlName("OptionValue"),
    ),
  }),
).annotate({
  identifier: "ImageUsageResourceTypeOptionRequest",
}) as any as S.Schema<ImageUsageResourceTypeOptionRequest>;
export type ImageUsageResourceTypeOptionRequestList =
  ImageUsageResourceTypeOptionRequest[];
export const ImageUsageResourceTypeOptionRequestList = S.Array(
  ImageUsageResourceTypeOptionRequest,
);
export interface ImageUsageResourceTypeRequest {
  ResourceType?: string;
  ResourceTypeOptions?: ImageUsageResourceTypeOptionRequest[];
}
export const ImageUsageResourceTypeRequest = S.suspend(() =>
  S.Struct({
    ResourceType: S.optional(S.String),
    ResourceTypeOptions: S.optional(
      ImageUsageResourceTypeOptionRequestList,
    ).pipe(T.XmlName("ResourceTypeOption")),
  }),
).annotate({
  identifier: "ImageUsageResourceTypeRequest",
}) as any as S.Schema<ImageUsageResourceTypeRequest>;
export type ImageUsageResourceTypeRequestList = ImageUsageResourceTypeRequest[];
export const ImageUsageResourceTypeRequestList = S.Array(
  ImageUsageResourceTypeRequest,
);
export type ImageUsageReportUserIdStringList = string[];
export const ImageUsageReportUserIdStringList = S.Array(
  S.String.pipe(T.XmlName("UserId")),
);
export interface CreateImageUsageReportRequest {
  ImageId?: string;
  DryRun?: boolean;
  ResourceTypes?: ImageUsageResourceTypeRequest[];
  AccountIds?: string[];
  ClientToken?: string;
  TagSpecifications?: TagSpecification[];
}
export const CreateImageUsageReportRequest = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    ResourceTypes: S.optional(ImageUsageResourceTypeRequestList).pipe(
      T.XmlName("ResourceType"),
    ),
    AccountIds: S.optional(ImageUsageReportUserIdStringList).pipe(
      T.XmlName("AccountId"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateImageUsageReportRequest",
}) as any as S.Schema<CreateImageUsageReportRequest>;
export interface CreateImageUsageReportResult {
  ReportId?: string;
}
export const CreateImageUsageReportResult = S.suspend(() =>
  S.Struct({
    ReportId: S.optional(S.String).pipe(
      T.XmlName("reportId"),
      T.Ec2QueryName("ReportId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateImageUsageReportResult",
}) as any as S.Schema<CreateImageUsageReportResult>;
export type SecurityGroupIdStringListRequest = string[];
export const SecurityGroupIdStringListRequest = S.Array(
  S.String.pipe(T.XmlName("SecurityGroupId")),
);
export type IpAddressType = "ipv4" | "dualstack" | "ipv6" | (string & {});
export const IpAddressType = S.String;
export interface CreateInstanceConnectEndpointRequest {
  DryRun?: boolean;
  SubnetId?: string;
  SecurityGroupIds?: string[];
  PreserveClientIp?: boolean;
  ClientToken?: string;
  TagSpecifications?: TagSpecification[];
  IpAddressType?: IpAddressType;
}
export const CreateInstanceConnectEndpointRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    SubnetId: S.optional(S.String),
    SecurityGroupIds: S.optional(SecurityGroupIdStringListRequest).pipe(
      T.XmlName("SecurityGroupId"),
    ),
    PreserveClientIp: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    IpAddressType: S.optional(IpAddressType),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateInstanceConnectEndpointRequest",
}) as any as S.Schema<CreateInstanceConnectEndpointRequest>;
export type Ec2InstanceConnectEndpointState =
  | "create-in-progress"
  | "create-complete"
  | "create-failed"
  | "delete-in-progress"
  | "delete-complete"
  | "delete-failed"
  | "update-in-progress"
  | "update-complete"
  | "update-failed"
  | (string & {});
export const Ec2InstanceConnectEndpointState = S.String;
export type NetworkInterfaceIdSet = string[];
export const NetworkInterfaceIdSet = S.Array(S.String.pipe(T.XmlName("item")));
export type SecurityGroupIdSet = string[];
export const SecurityGroupIdSet = S.Array(S.String.pipe(T.XmlName("item")));
export interface InstanceConnectEndpointDnsNames {
  DnsName?: string;
  FipsDnsName?: string;
}
export const InstanceConnectEndpointDnsNames = S.suspend(() =>
  S.Struct({
    DnsName: S.optional(S.String).pipe(
      T.XmlName("dnsName"),
      T.Ec2QueryName("DnsName"),
    ),
    FipsDnsName: S.optional(S.String).pipe(
      T.XmlName("fipsDnsName"),
      T.Ec2QueryName("FipsDnsName"),
    ),
  }),
).annotate({
  identifier: "InstanceConnectEndpointDnsNames",
}) as any as S.Schema<InstanceConnectEndpointDnsNames>;
export interface InstanceConnectEndpointPublicDnsNames {
  Ipv4?: InstanceConnectEndpointDnsNames;
  Dualstack?: InstanceConnectEndpointDnsNames;
}
export const InstanceConnectEndpointPublicDnsNames = S.suspend(() =>
  S.Struct({
    Ipv4: S.optional(InstanceConnectEndpointDnsNames)
      .pipe(T.XmlName("ipv4"), T.Ec2QueryName("Ipv4"))
      .annotate({ identifier: "InstanceConnectEndpointDnsNames" }),
    Dualstack: S.optional(InstanceConnectEndpointDnsNames)
      .pipe(T.XmlName("dualstack"), T.Ec2QueryName("Dualstack"))
      .annotate({ identifier: "InstanceConnectEndpointDnsNames" }),
  }),
).annotate({
  identifier: "InstanceConnectEndpointPublicDnsNames",
}) as any as S.Schema<InstanceConnectEndpointPublicDnsNames>;
export interface Ec2InstanceConnectEndpoint {
  OwnerId?: string;
  InstanceConnectEndpointId?: string;
  InstanceConnectEndpointArn?: string;
  State?: Ec2InstanceConnectEndpointState;
  StateMessage?: string;
  DnsName?: string;
  FipsDnsName?: string;
  NetworkInterfaceIds?: string[];
  VpcId?: string;
  AvailabilityZone?: string;
  CreatedAt?: Date;
  SubnetId?: string;
  PreserveClientIp?: boolean;
  SecurityGroupIds?: string[];
  Tags?: Tag[];
  IpAddressType?: IpAddressType;
  PublicDnsNames?: InstanceConnectEndpointPublicDnsNames;
  AvailabilityZoneId?: string;
}
export const Ec2InstanceConnectEndpoint = S.suspend(() =>
  S.Struct({
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    InstanceConnectEndpointId: S.optional(S.String).pipe(
      T.XmlName("instanceConnectEndpointId"),
      T.Ec2QueryName("InstanceConnectEndpointId"),
    ),
    InstanceConnectEndpointArn: S.optional(S.String).pipe(
      T.XmlName("instanceConnectEndpointArn"),
      T.Ec2QueryName("InstanceConnectEndpointArn"),
    ),
    State: S.optional(Ec2InstanceConnectEndpointState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StateMessage: S.optional(S.String).pipe(
      T.XmlName("stateMessage"),
      T.Ec2QueryName("StateMessage"),
    ),
    DnsName: S.optional(S.String).pipe(
      T.XmlName("dnsName"),
      T.Ec2QueryName("DnsName"),
    ),
    FipsDnsName: S.optional(S.String).pipe(
      T.XmlName("fipsDnsName"),
      T.Ec2QueryName("FipsDnsName"),
    ),
    NetworkInterfaceIds: S.optional(NetworkInterfaceIdSet).pipe(
      T.XmlName("networkInterfaceIdSet"),
      T.Ec2QueryName("NetworkInterfaceIdSet"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    CreatedAt: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createdAt"), T.Ec2QueryName("CreatedAt")),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    PreserveClientIp: S.optional(S.Boolean).pipe(
      T.XmlName("preserveClientIp"),
      T.Ec2QueryName("PreserveClientIp"),
    ),
    SecurityGroupIds: S.optional(SecurityGroupIdSet).pipe(
      T.XmlName("securityGroupIdSet"),
      T.Ec2QueryName("SecurityGroupIdSet"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    IpAddressType: S.optional(IpAddressType).pipe(
      T.XmlName("ipAddressType"),
      T.Ec2QueryName("IpAddressType"),
    ),
    PublicDnsNames: S.optional(InstanceConnectEndpointPublicDnsNames)
      .pipe(T.XmlName("publicDnsNames"), T.Ec2QueryName("PublicDnsNames"))
      .annotate({ identifier: "InstanceConnectEndpointPublicDnsNames" }),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
  }),
).annotate({
  identifier: "Ec2InstanceConnectEndpoint",
}) as any as S.Schema<Ec2InstanceConnectEndpoint>;
export interface CreateInstanceConnectEndpointResult {
  InstanceConnectEndpoint?: Ec2InstanceConnectEndpoint;
  ClientToken?: string;
}
export const CreateInstanceConnectEndpointResult = S.suspend(() =>
  S.Struct({
    InstanceConnectEndpoint: S.optional(Ec2InstanceConnectEndpoint)
      .pipe(
        T.XmlName("instanceConnectEndpoint"),
        T.Ec2QueryName("InstanceConnectEndpoint"),
      )
      .annotate({ identifier: "Ec2InstanceConnectEndpoint" }),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateInstanceConnectEndpointResult",
}) as any as S.Schema<CreateInstanceConnectEndpointResult>;
export interface InstanceEventWindowTimeRangeRequest {
  StartWeekDay?: WeekDay;
  StartHour?: number;
  EndWeekDay?: WeekDay;
  EndHour?: number;
}
export const InstanceEventWindowTimeRangeRequest = S.suspend(() =>
  S.Struct({
    StartWeekDay: S.optional(WeekDay),
    StartHour: S.optional(S.Number),
    EndWeekDay: S.optional(WeekDay),
    EndHour: S.optional(S.Number),
  }),
).annotate({
  identifier: "InstanceEventWindowTimeRangeRequest",
}) as any as S.Schema<InstanceEventWindowTimeRangeRequest>;
export type InstanceEventWindowTimeRangeRequestSet =
  InstanceEventWindowTimeRangeRequest[];
export const InstanceEventWindowTimeRangeRequestSet = S.Array(
  InstanceEventWindowTimeRangeRequest,
);
export interface CreateInstanceEventWindowRequest {
  DryRun?: boolean;
  Name?: string;
  TimeRanges?: InstanceEventWindowTimeRangeRequest[];
  CronExpression?: string;
  TagSpecifications?: TagSpecification[];
}
export const CreateInstanceEventWindowRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Name: S.optional(S.String),
    TimeRanges: S.optional(InstanceEventWindowTimeRangeRequestSet).pipe(
      T.XmlName("TimeRange"),
    ),
    CronExpression: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateInstanceEventWindowRequest",
}) as any as S.Schema<CreateInstanceEventWindowRequest>;
export interface CreateInstanceEventWindowResult {
  InstanceEventWindow?: InstanceEventWindow;
}
export const CreateInstanceEventWindowResult = S.suspend(() =>
  S.Struct({
    InstanceEventWindow: S.optional(InstanceEventWindow)
      .pipe(
        T.XmlName("instanceEventWindow"),
        T.Ec2QueryName("InstanceEventWindow"),
      )
      .annotate({ identifier: "InstanceEventWindow" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateInstanceEventWindowResult",
}) as any as S.Schema<CreateInstanceEventWindowResult>;
export type ExportEnvironment =
  | "citrix"
  | "vmware"
  | "microsoft"
  | (string & {});
export const ExportEnvironment = S.String;
export type DiskImageFormat = "VMDK" | "RAW" | "VHD" | (string & {});
export const DiskImageFormat = S.String;
export type ContainerFormat = "ova" | (string & {});
export const ContainerFormat = S.String;
export interface ExportToS3TaskSpecification {
  DiskImageFormat?: DiskImageFormat;
  ContainerFormat?: ContainerFormat;
  S3Bucket?: string;
  S3Prefix?: string;
}
export const ExportToS3TaskSpecification = S.suspend(() =>
  S.Struct({
    DiskImageFormat: S.optional(DiskImageFormat).pipe(
      T.XmlName("diskImageFormat"),
      T.Ec2QueryName("DiskImageFormat"),
    ),
    ContainerFormat: S.optional(ContainerFormat).pipe(
      T.XmlName("containerFormat"),
      T.Ec2QueryName("ContainerFormat"),
    ),
    S3Bucket: S.optional(S.String).pipe(
      T.XmlName("s3Bucket"),
      T.Ec2QueryName("S3Bucket"),
    ),
    S3Prefix: S.optional(S.String).pipe(
      T.XmlName("s3Prefix"),
      T.Ec2QueryName("S3Prefix"),
    ),
  }),
).annotate({
  identifier: "ExportToS3TaskSpecification",
}) as any as S.Schema<ExportToS3TaskSpecification>;
export interface CreateInstanceExportTaskRequest {
  TagSpecifications?: TagSpecification[];
  Description?: string;
  InstanceId?: string;
  TargetEnvironment?: ExportEnvironment;
  ExportToS3Task?: ExportToS3TaskSpecification;
}
export const CreateInstanceExportTaskRequest = S.suspend(() =>
  S.Struct({
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    TargetEnvironment: S.optional(ExportEnvironment).pipe(
      T.XmlName("targetEnvironment"),
      T.Ec2QueryName("TargetEnvironment"),
    ),
    ExportToS3Task: S.optional(ExportToS3TaskSpecification)
      .pipe(T.XmlName("exportToS3"), T.Ec2QueryName("ExportToS3"))
      .annotate({ identifier: "ExportToS3TaskSpecification" }),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateInstanceExportTaskRequest",
}) as any as S.Schema<CreateInstanceExportTaskRequest>;
export interface ExportToS3Task {
  ContainerFormat?: ContainerFormat;
  DiskImageFormat?: DiskImageFormat;
  S3Bucket?: string;
  S3Key?: string;
}
export const ExportToS3Task = S.suspend(() =>
  S.Struct({
    ContainerFormat: S.optional(ContainerFormat).pipe(
      T.XmlName("containerFormat"),
      T.Ec2QueryName("ContainerFormat"),
    ),
    DiskImageFormat: S.optional(DiskImageFormat).pipe(
      T.XmlName("diskImageFormat"),
      T.Ec2QueryName("DiskImageFormat"),
    ),
    S3Bucket: S.optional(S.String).pipe(
      T.XmlName("s3Bucket"),
      T.Ec2QueryName("S3Bucket"),
    ),
    S3Key: S.optional(S.String).pipe(
      T.XmlName("s3Key"),
      T.Ec2QueryName("S3Key"),
    ),
  }),
).annotate({ identifier: "ExportToS3Task" }) as any as S.Schema<ExportToS3Task>;
export interface InstanceExportDetails {
  InstanceId?: string;
  TargetEnvironment?: ExportEnvironment;
}
export const InstanceExportDetails = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    TargetEnvironment: S.optional(ExportEnvironment).pipe(
      T.XmlName("targetEnvironment"),
      T.Ec2QueryName("TargetEnvironment"),
    ),
  }),
).annotate({
  identifier: "InstanceExportDetails",
}) as any as S.Schema<InstanceExportDetails>;
export type ExportTaskState =
  | "active"
  | "cancelling"
  | "cancelled"
  | "completed"
  | (string & {});
export const ExportTaskState = S.String;
export interface ExportTask {
  Description?: string;
  ExportTaskId?: string;
  ExportToS3Task?: ExportToS3Task;
  InstanceExportDetails?: InstanceExportDetails;
  State?: ExportTaskState;
  StatusMessage?: string;
  Tags?: Tag[];
}
export const ExportTask = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    ExportTaskId: S.optional(S.String).pipe(
      T.XmlName("exportTaskId"),
      T.Ec2QueryName("ExportTaskId"),
    ),
    ExportToS3Task: S.optional(ExportToS3Task)
      .pipe(T.XmlName("exportToS3"), T.Ec2QueryName("ExportToS3"))
      .annotate({ identifier: "ExportToS3Task" }),
    InstanceExportDetails: S.optional(InstanceExportDetails)
      .pipe(T.XmlName("instanceExport"), T.Ec2QueryName("InstanceExport"))
      .annotate({ identifier: "InstanceExportDetails" }),
    State: S.optional(ExportTaskState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({ identifier: "ExportTask" }) as any as S.Schema<ExportTask>;
export interface CreateInstanceExportTaskResult {
  ExportTask?: ExportTask;
}
export const CreateInstanceExportTaskResult = S.suspend(() =>
  S.Struct({
    ExportTask: S.optional(ExportTask)
      .pipe(T.XmlName("exportTask"), T.Ec2QueryName("ExportTask"))
      .annotate({ identifier: "ExportTask" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateInstanceExportTaskResult",
}) as any as S.Schema<CreateInstanceExportTaskResult>;
export interface CreateInternetGatewayRequest {
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateInternetGatewayRequest = S.suspend(() =>
  S.Struct({
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateInternetGatewayRequest",
}) as any as S.Schema<CreateInternetGatewayRequest>;
export interface InternetGateway {
  Attachments?: InternetGatewayAttachment[];
  InternetGatewayId?: string;
  OwnerId?: string;
  Tags?: Tag[];
}
export const InternetGateway = S.suspend(() =>
  S.Struct({
    Attachments: S.optional(InternetGatewayAttachmentList).pipe(
      T.XmlName("attachmentSet"),
      T.Ec2QueryName("AttachmentSet"),
    ),
    InternetGatewayId: S.optional(S.String).pipe(
      T.XmlName("internetGatewayId"),
      T.Ec2QueryName("InternetGatewayId"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "InternetGateway",
}) as any as S.Schema<InternetGateway>;
export interface CreateInternetGatewayResult {
  InternetGateway?: InternetGateway;
}
export const CreateInternetGatewayResult = S.suspend(() =>
  S.Struct({
    InternetGateway: S.optional(InternetGateway)
      .pipe(T.XmlName("internetGateway"), T.Ec2QueryName("InternetGateway"))
      .annotate({ identifier: "InternetGateway" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateInternetGatewayResult",
}) as any as S.Schema<CreateInternetGatewayResult>;
export interface CreateInterruptibleCapacityReservationAllocationRequest {
  CapacityReservationId?: string;
  InstanceCount?: number;
  ClientToken?: string;
  DryRun?: boolean;
  TagSpecifications?: TagSpecification[];
}
export const CreateInterruptibleCapacityReservationAllocationRequest =
  S.suspend(() =>
    S.Struct({
      CapacityReservationId: S.optional(S.String),
      InstanceCount: S.optional(S.Number),
      ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
      DryRun: S.optional(S.Boolean),
      TagSpecifications: S.optional(TagSpecificationList).pipe(
        T.XmlName("TagSpecification"),
      ),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
  ).annotate({
    identifier: "CreateInterruptibleCapacityReservationAllocationRequest",
  }) as any as S.Schema<CreateInterruptibleCapacityReservationAllocationRequest>;
export interface CreateInterruptibleCapacityReservationAllocationResult {
  SourceCapacityReservationId?: string;
  TargetInstanceCount?: number;
  Status?: InterruptibleCapacityReservationAllocationStatus;
  InterruptionType?: InterruptionType;
}
export const CreateInterruptibleCapacityReservationAllocationResult = S.suspend(
  () =>
    S.Struct({
      SourceCapacityReservationId: S.optional(S.String).pipe(
        T.XmlName("sourceCapacityReservationId"),
        T.Ec2QueryName("SourceCapacityReservationId"),
      ),
      TargetInstanceCount: S.optional(S.Number).pipe(
        T.XmlName("targetInstanceCount"),
        T.Ec2QueryName("TargetInstanceCount"),
      ),
      Status: S.optional(InterruptibleCapacityReservationAllocationStatus).pipe(
        T.XmlName("status"),
        T.Ec2QueryName("Status"),
      ),
      InterruptionType: S.optional(InterruptionType).pipe(
        T.XmlName("interruptionType"),
        T.Ec2QueryName("InterruptionType"),
      ),
    }).pipe(ns),
).annotate({
  identifier: "CreateInterruptibleCapacityReservationAllocationResult",
}) as any as S.Schema<CreateInterruptibleCapacityReservationAllocationResult>;
export interface AddIpamOperatingRegion {
  RegionName?: string;
}
export const AddIpamOperatingRegion = S.suspend(() =>
  S.Struct({ RegionName: S.optional(S.String) }),
).annotate({
  identifier: "AddIpamOperatingRegion",
}) as any as S.Schema<AddIpamOperatingRegion>;
export type AddIpamOperatingRegionSet = AddIpamOperatingRegion[];
export const AddIpamOperatingRegionSet = S.Array(AddIpamOperatingRegion);
export type IpamTier = "free" | "advanced" | (string & {});
export const IpamTier = S.String;
export type IpamMeteredAccount =
  | "ipam-owner"
  | "resource-owner"
  | (string & {});
export const IpamMeteredAccount = S.String;
export interface CreateIpamRequest {
  DryRun?: boolean;
  Description?: string;
  OperatingRegions?: AddIpamOperatingRegion[];
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
  Tier?: IpamTier;
  EnablePrivateGua?: boolean;
  MeteredAccount?: IpamMeteredAccount;
}
export const CreateIpamRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Description: S.optional(S.String),
    OperatingRegions: S.optional(AddIpamOperatingRegionSet).pipe(
      T.XmlName("OperatingRegion"),
    ),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    Tier: S.optional(IpamTier),
    EnablePrivateGua: S.optional(S.Boolean),
    MeteredAccount: S.optional(IpamMeteredAccount),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateIpamRequest",
}) as any as S.Schema<CreateIpamRequest>;
export interface IpamOperatingRegion {
  RegionName?: string;
}
export const IpamOperatingRegion = S.suspend(() =>
  S.Struct({
    RegionName: S.optional(S.String).pipe(
      T.XmlName("regionName"),
      T.Ec2QueryName("RegionName"),
    ),
  }),
).annotate({
  identifier: "IpamOperatingRegion",
}) as any as S.Schema<IpamOperatingRegion>;
export type IpamOperatingRegionSet = IpamOperatingRegion[];
export const IpamOperatingRegionSet = S.Array(
  IpamOperatingRegion.pipe(T.XmlName("item")).annotate({
    identifier: "IpamOperatingRegion",
  }),
);
export type IpamState =
  | "create-in-progress"
  | "create-complete"
  | "create-failed"
  | "modify-in-progress"
  | "modify-complete"
  | "modify-failed"
  | "delete-in-progress"
  | "delete-complete"
  | "delete-failed"
  | "isolate-in-progress"
  | "isolate-complete"
  | "restore-in-progress"
  | (string & {});
export const IpamState = S.String;
export interface Ipam {
  OwnerId?: string;
  IpamId?: string;
  IpamArn?: string;
  IpamRegion?: string;
  PublicDefaultScopeId?: string;
  PrivateDefaultScopeId?: string;
  ScopeCount?: number;
  Description?: string;
  OperatingRegions?: IpamOperatingRegion[];
  State?: IpamState;
  Tags?: Tag[];
  DefaultResourceDiscoveryId?: string;
  DefaultResourceDiscoveryAssociationId?: string;
  ResourceDiscoveryAssociationCount?: number;
  StateMessage?: string;
  Tier?: IpamTier;
  EnablePrivateGua?: boolean;
  MeteredAccount?: IpamMeteredAccount;
}
export const Ipam = S.suspend(() =>
  S.Struct({
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    IpamId: S.optional(S.String).pipe(
      T.XmlName("ipamId"),
      T.Ec2QueryName("IpamId"),
    ),
    IpamArn: S.optional(S.String).pipe(
      T.XmlName("ipamArn"),
      T.Ec2QueryName("IpamArn"),
    ),
    IpamRegion: S.optional(S.String).pipe(
      T.XmlName("ipamRegion"),
      T.Ec2QueryName("IpamRegion"),
    ),
    PublicDefaultScopeId: S.optional(S.String).pipe(
      T.XmlName("publicDefaultScopeId"),
      T.Ec2QueryName("PublicDefaultScopeId"),
    ),
    PrivateDefaultScopeId: S.optional(S.String).pipe(
      T.XmlName("privateDefaultScopeId"),
      T.Ec2QueryName("PrivateDefaultScopeId"),
    ),
    ScopeCount: S.optional(S.Number).pipe(
      T.XmlName("scopeCount"),
      T.Ec2QueryName("ScopeCount"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    OperatingRegions: S.optional(IpamOperatingRegionSet).pipe(
      T.XmlName("operatingRegionSet"),
      T.Ec2QueryName("OperatingRegionSet"),
    ),
    State: S.optional(IpamState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    DefaultResourceDiscoveryId: S.optional(S.String).pipe(
      T.XmlName("defaultResourceDiscoveryId"),
      T.Ec2QueryName("DefaultResourceDiscoveryId"),
    ),
    DefaultResourceDiscoveryAssociationId: S.optional(S.String).pipe(
      T.XmlName("defaultResourceDiscoveryAssociationId"),
      T.Ec2QueryName("DefaultResourceDiscoveryAssociationId"),
    ),
    ResourceDiscoveryAssociationCount: S.optional(S.Number).pipe(
      T.XmlName("resourceDiscoveryAssociationCount"),
      T.Ec2QueryName("ResourceDiscoveryAssociationCount"),
    ),
    StateMessage: S.optional(S.String).pipe(
      T.XmlName("stateMessage"),
      T.Ec2QueryName("StateMessage"),
    ),
    Tier: S.optional(IpamTier).pipe(T.XmlName("tier"), T.Ec2QueryName("Tier")),
    EnablePrivateGua: S.optional(S.Boolean).pipe(
      T.XmlName("enablePrivateGua"),
      T.Ec2QueryName("EnablePrivateGua"),
    ),
    MeteredAccount: S.optional(IpamMeteredAccount).pipe(
      T.XmlName("meteredAccount"),
      T.Ec2QueryName("MeteredAccount"),
    ),
  }),
).annotate({ identifier: "Ipam" }) as any as S.Schema<Ipam>;
export interface CreateIpamResult {
  Ipam?: Ipam;
}
export const CreateIpamResult = S.suspend(() =>
  S.Struct({
    Ipam: S.optional(Ipam)
      .pipe(T.XmlName("ipam"), T.Ec2QueryName("Ipam"))
      .annotate({ identifier: "Ipam" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateIpamResult",
}) as any as S.Schema<CreateIpamResult>;
export interface CreateIpamExternalResourceVerificationTokenRequest {
  DryRun?: boolean;
  IpamId?: string;
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
}
export const CreateIpamExternalResourceVerificationTokenRequest = S.suspend(
  () =>
    S.Struct({
      DryRun: S.optional(S.Boolean),
      IpamId: S.optional(S.String),
      TagSpecifications: S.optional(TagSpecificationList).pipe(
        T.XmlName("TagSpecification"),
      ),
      ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "CreateIpamExternalResourceVerificationTokenRequest",
}) as any as S.Schema<CreateIpamExternalResourceVerificationTokenRequest>;
export type TokenState = "valid" | "expired" | (string & {});
export const TokenState = S.String;
export type IpamExternalResourceVerificationTokenState =
  | "create-in-progress"
  | "create-complete"
  | "create-failed"
  | "delete-in-progress"
  | "delete-complete"
  | "delete-failed"
  | (string & {});
export const IpamExternalResourceVerificationTokenState = S.String;
export interface IpamExternalResourceVerificationToken {
  IpamExternalResourceVerificationTokenId?: string;
  IpamExternalResourceVerificationTokenArn?: string;
  IpamId?: string;
  IpamArn?: string;
  IpamRegion?: string;
  TokenValue?: string;
  TokenName?: string;
  NotAfter?: Date;
  Status?: TokenState;
  Tags?: Tag[];
  State?: IpamExternalResourceVerificationTokenState;
}
export const IpamExternalResourceVerificationToken = S.suspend(() =>
  S.Struct({
    IpamExternalResourceVerificationTokenId: S.optional(S.String).pipe(
      T.XmlName("ipamExternalResourceVerificationTokenId"),
      T.Ec2QueryName("IpamExternalResourceVerificationTokenId"),
    ),
    IpamExternalResourceVerificationTokenArn: S.optional(S.String).pipe(
      T.XmlName("ipamExternalResourceVerificationTokenArn"),
      T.Ec2QueryName("IpamExternalResourceVerificationTokenArn"),
    ),
    IpamId: S.optional(S.String).pipe(
      T.XmlName("ipamId"),
      T.Ec2QueryName("IpamId"),
    ),
    IpamArn: S.optional(S.String).pipe(
      T.XmlName("ipamArn"),
      T.Ec2QueryName("IpamArn"),
    ),
    IpamRegion: S.optional(S.String).pipe(
      T.XmlName("ipamRegion"),
      T.Ec2QueryName("IpamRegion"),
    ),
    TokenValue: S.optional(S.String).pipe(
      T.XmlName("tokenValue"),
      T.Ec2QueryName("TokenValue"),
    ),
    TokenName: S.optional(S.String).pipe(
      T.XmlName("tokenName"),
      T.Ec2QueryName("TokenName"),
    ),
    NotAfter: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("notAfter"), T.Ec2QueryName("NotAfter")),
    Status: S.optional(TokenState).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    State: S.optional(IpamExternalResourceVerificationTokenState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({
  identifier: "IpamExternalResourceVerificationToken",
}) as any as S.Schema<IpamExternalResourceVerificationToken>;
export interface CreateIpamExternalResourceVerificationTokenResult {
  IpamExternalResourceVerificationToken?: IpamExternalResourceVerificationToken;
}
export const CreateIpamExternalResourceVerificationTokenResult = S.suspend(() =>
  S.Struct({
    IpamExternalResourceVerificationToken: S.optional(
      IpamExternalResourceVerificationToken,
    )
      .pipe(
        T.XmlName("ipamExternalResourceVerificationToken"),
        T.Ec2QueryName("IpamExternalResourceVerificationToken"),
      )
      .annotate({ identifier: "IpamExternalResourceVerificationToken" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateIpamExternalResourceVerificationTokenResult",
}) as any as S.Schema<CreateIpamExternalResourceVerificationTokenResult>;
export interface CreateIpamPolicyRequest {
  DryRun?: boolean;
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
  IpamId?: string;
}
export const CreateIpamPolicyRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    IpamId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateIpamPolicyRequest",
}) as any as S.Schema<CreateIpamPolicyRequest>;
export type IpamPolicyState =
  | "create-in-progress"
  | "create-complete"
  | "create-failed"
  | "modify-in-progress"
  | "modify-complete"
  | "modify-failed"
  | "delete-in-progress"
  | "delete-complete"
  | "delete-failed"
  | "isolate-in-progress"
  | "isolate-complete"
  | "restore-in-progress"
  | (string & {});
export const IpamPolicyState = S.String;
export interface IpamPolicy {
  OwnerId?: string;
  IpamPolicyId?: string;
  IpamPolicyArn?: string;
  IpamPolicyRegion?: string;
  State?: IpamPolicyState;
  StateMessage?: string;
  Tags?: Tag[];
  IpamId?: string;
}
export const IpamPolicy = S.suspend(() =>
  S.Struct({
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    IpamPolicyId: S.optional(S.String).pipe(
      T.XmlName("ipamPolicyId"),
      T.Ec2QueryName("IpamPolicyId"),
    ),
    IpamPolicyArn: S.optional(S.String).pipe(
      T.XmlName("ipamPolicyArn"),
      T.Ec2QueryName("IpamPolicyArn"),
    ),
    IpamPolicyRegion: S.optional(S.String).pipe(
      T.XmlName("ipamPolicyRegion"),
      T.Ec2QueryName("IpamPolicyRegion"),
    ),
    State: S.optional(IpamPolicyState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StateMessage: S.optional(S.String).pipe(
      T.XmlName("stateMessage"),
      T.Ec2QueryName("StateMessage"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    IpamId: S.optional(S.String).pipe(
      T.XmlName("ipamId"),
      T.Ec2QueryName("IpamId"),
    ),
  }),
).annotate({ identifier: "IpamPolicy" }) as any as S.Schema<IpamPolicy>;
export interface CreateIpamPolicyResult {
  IpamPolicy?: IpamPolicy;
}
export const CreateIpamPolicyResult = S.suspend(() =>
  S.Struct({
    IpamPolicy: S.optional(IpamPolicy)
      .pipe(T.XmlName("ipamPolicy"), T.Ec2QueryName("IpamPolicy"))
      .annotate({ identifier: "IpamPolicy" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateIpamPolicyResult",
}) as any as S.Schema<CreateIpamPolicyResult>;
export type AddressFamily = "ipv4" | "ipv6" | (string & {});
export const AddressFamily = S.String;
export interface RequestIpamResourceTag {
  Key?: string;
  Value?: string;
}
export const RequestIpamResourceTag = S.suspend(() =>
  S.Struct({ Key: S.optional(S.String), Value: S.optional(S.String) }),
).annotate({
  identifier: "RequestIpamResourceTag",
}) as any as S.Schema<RequestIpamResourceTag>;
export type RequestIpamResourceTagList = RequestIpamResourceTag[];
export const RequestIpamResourceTagList = S.Array(
  RequestIpamResourceTag.pipe(T.XmlName("item")).annotate({
    identifier: "RequestIpamResourceTag",
  }),
);
export type IpamPoolAwsService = "ec2" | "global-services" | (string & {});
export const IpamPoolAwsService = S.String;
export type IpamPoolPublicIpSource = "amazon" | "byoip" | (string & {});
export const IpamPoolPublicIpSource = S.String;
export type IpamPoolSourceResourceType = "vpc" | (string & {});
export const IpamPoolSourceResourceType = S.String;
export interface IpamPoolSourceResourceRequest {
  ResourceId?: string;
  ResourceType?: IpamPoolSourceResourceType;
  ResourceRegion?: string;
  ResourceOwner?: string;
}
export const IpamPoolSourceResourceRequest = S.suspend(() =>
  S.Struct({
    ResourceId: S.optional(S.String),
    ResourceType: S.optional(IpamPoolSourceResourceType),
    ResourceRegion: S.optional(S.String),
    ResourceOwner: S.optional(S.String),
  }),
).annotate({
  identifier: "IpamPoolSourceResourceRequest",
}) as any as S.Schema<IpamPoolSourceResourceRequest>;
export interface CreateIpamPoolRequest {
  DryRun?: boolean;
  IpamScopeId?: string;
  Locale?: string;
  SourceIpamPoolId?: string;
  Description?: string;
  AddressFamily?: AddressFamily;
  AutoImport?: boolean;
  PubliclyAdvertisable?: boolean;
  AllocationMinNetmaskLength?: number;
  AllocationMaxNetmaskLength?: number;
  AllocationDefaultNetmaskLength?: number;
  AllocationResourceTags?: RequestIpamResourceTag[];
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
  AwsService?: IpamPoolAwsService;
  PublicIpSource?: IpamPoolPublicIpSource;
  SourceResource?: IpamPoolSourceResourceRequest;
}
export const CreateIpamPoolRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamScopeId: S.optional(S.String),
    Locale: S.optional(S.String),
    SourceIpamPoolId: S.optional(S.String),
    Description: S.optional(S.String),
    AddressFamily: S.optional(AddressFamily),
    AutoImport: S.optional(S.Boolean),
    PubliclyAdvertisable: S.optional(S.Boolean),
    AllocationMinNetmaskLength: S.optional(S.Number),
    AllocationMaxNetmaskLength: S.optional(S.Number),
    AllocationDefaultNetmaskLength: S.optional(S.Number),
    AllocationResourceTags: S.optional(RequestIpamResourceTagList).pipe(
      T.XmlName("AllocationResourceTag"),
    ),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    AwsService: S.optional(IpamPoolAwsService),
    PublicIpSource: S.optional(IpamPoolPublicIpSource),
    SourceResource: S.optional(IpamPoolSourceResourceRequest),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateIpamPoolRequest",
}) as any as S.Schema<CreateIpamPoolRequest>;
export type IpamScopeType = "public" | "private" | (string & {});
export const IpamScopeType = S.String;
export type IpamPoolState =
  | "create-in-progress"
  | "create-complete"
  | "create-failed"
  | "modify-in-progress"
  | "modify-complete"
  | "modify-failed"
  | "delete-in-progress"
  | "delete-complete"
  | "delete-failed"
  | "isolate-in-progress"
  | "isolate-complete"
  | "restore-in-progress"
  | (string & {});
export const IpamPoolState = S.String;
export interface IpamResourceTag {
  Key?: string;
  Value?: string;
}
export const IpamResourceTag = S.suspend(() =>
  S.Struct({
    Key: S.optional(S.String).pipe(T.XmlName("key"), T.Ec2QueryName("Key")),
    Value: S.optional(S.String).pipe(
      T.XmlName("value"),
      T.Ec2QueryName("Value"),
    ),
  }),
).annotate({
  identifier: "IpamResourceTag",
}) as any as S.Schema<IpamResourceTag>;
export type IpamResourceTagList = IpamResourceTag[];
export const IpamResourceTagList = S.Array(
  IpamResourceTag.pipe(T.XmlName("item")).annotate({
    identifier: "IpamResourceTag",
  }),
);
export interface IpamPoolSourceResource {
  ResourceId?: string;
  ResourceType?: IpamPoolSourceResourceType;
  ResourceRegion?: string;
  ResourceOwner?: string;
}
export const IpamPoolSourceResource = S.suspend(() =>
  S.Struct({
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    ResourceType: S.optional(IpamPoolSourceResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    ResourceRegion: S.optional(S.String).pipe(
      T.XmlName("resourceRegion"),
      T.Ec2QueryName("ResourceRegion"),
    ),
    ResourceOwner: S.optional(S.String).pipe(
      T.XmlName("resourceOwner"),
      T.Ec2QueryName("ResourceOwner"),
    ),
  }),
).annotate({
  identifier: "IpamPoolSourceResource",
}) as any as S.Schema<IpamPoolSourceResource>;
export interface IpamPool {
  OwnerId?: string;
  IpamPoolId?: string;
  SourceIpamPoolId?: string;
  IpamPoolArn?: string;
  IpamScopeArn?: string;
  IpamScopeType?: IpamScopeType;
  IpamArn?: string;
  IpamRegion?: string;
  Locale?: string;
  PoolDepth?: number;
  State?: IpamPoolState;
  StateMessage?: string;
  Description?: string;
  AutoImport?: boolean;
  PubliclyAdvertisable?: boolean;
  AddressFamily?: AddressFamily;
  AllocationMinNetmaskLength?: number;
  AllocationMaxNetmaskLength?: number;
  AllocationDefaultNetmaskLength?: number;
  AllocationResourceTags?: IpamResourceTag[];
  Tags?: Tag[];
  AwsService?: IpamPoolAwsService;
  PublicIpSource?: IpamPoolPublicIpSource;
  SourceResource?: IpamPoolSourceResource;
}
export const IpamPool = S.suspend(() =>
  S.Struct({
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    IpamPoolId: S.optional(S.String).pipe(
      T.XmlName("ipamPoolId"),
      T.Ec2QueryName("IpamPoolId"),
    ),
    SourceIpamPoolId: S.optional(S.String).pipe(
      T.XmlName("sourceIpamPoolId"),
      T.Ec2QueryName("SourceIpamPoolId"),
    ),
    IpamPoolArn: S.optional(S.String).pipe(
      T.XmlName("ipamPoolArn"),
      T.Ec2QueryName("IpamPoolArn"),
    ),
    IpamScopeArn: S.optional(S.String).pipe(
      T.XmlName("ipamScopeArn"),
      T.Ec2QueryName("IpamScopeArn"),
    ),
    IpamScopeType: S.optional(IpamScopeType).pipe(
      T.XmlName("ipamScopeType"),
      T.Ec2QueryName("IpamScopeType"),
    ),
    IpamArn: S.optional(S.String).pipe(
      T.XmlName("ipamArn"),
      T.Ec2QueryName("IpamArn"),
    ),
    IpamRegion: S.optional(S.String).pipe(
      T.XmlName("ipamRegion"),
      T.Ec2QueryName("IpamRegion"),
    ),
    Locale: S.optional(S.String).pipe(
      T.XmlName("locale"),
      T.Ec2QueryName("Locale"),
    ),
    PoolDepth: S.optional(S.Number).pipe(
      T.XmlName("poolDepth"),
      T.Ec2QueryName("PoolDepth"),
    ),
    State: S.optional(IpamPoolState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StateMessage: S.optional(S.String).pipe(
      T.XmlName("stateMessage"),
      T.Ec2QueryName("StateMessage"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    AutoImport: S.optional(S.Boolean).pipe(
      T.XmlName("autoImport"),
      T.Ec2QueryName("AutoImport"),
    ),
    PubliclyAdvertisable: S.optional(S.Boolean).pipe(
      T.XmlName("publiclyAdvertisable"),
      T.Ec2QueryName("PubliclyAdvertisable"),
    ),
    AddressFamily: S.optional(AddressFamily).pipe(
      T.XmlName("addressFamily"),
      T.Ec2QueryName("AddressFamily"),
    ),
    AllocationMinNetmaskLength: S.optional(S.Number).pipe(
      T.XmlName("allocationMinNetmaskLength"),
      T.Ec2QueryName("AllocationMinNetmaskLength"),
    ),
    AllocationMaxNetmaskLength: S.optional(S.Number).pipe(
      T.XmlName("allocationMaxNetmaskLength"),
      T.Ec2QueryName("AllocationMaxNetmaskLength"),
    ),
    AllocationDefaultNetmaskLength: S.optional(S.Number).pipe(
      T.XmlName("allocationDefaultNetmaskLength"),
      T.Ec2QueryName("AllocationDefaultNetmaskLength"),
    ),
    AllocationResourceTags: S.optional(IpamResourceTagList).pipe(
      T.XmlName("allocationResourceTagSet"),
      T.Ec2QueryName("AllocationResourceTagSet"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    AwsService: S.optional(IpamPoolAwsService).pipe(
      T.XmlName("awsService"),
      T.Ec2QueryName("AwsService"),
    ),
    PublicIpSource: S.optional(IpamPoolPublicIpSource).pipe(
      T.XmlName("publicIpSource"),
      T.Ec2QueryName("PublicIpSource"),
    ),
    SourceResource: S.optional(IpamPoolSourceResource)
      .pipe(T.XmlName("sourceResource"), T.Ec2QueryName("SourceResource"))
      .annotate({ identifier: "IpamPoolSourceResource" }),
  }),
).annotate({ identifier: "IpamPool" }) as any as S.Schema<IpamPool>;
export interface CreateIpamPoolResult {
  IpamPool?: IpamPool;
}
export const CreateIpamPoolResult = S.suspend(() =>
  S.Struct({
    IpamPool: S.optional(IpamPool)
      .pipe(T.XmlName("ipamPool"), T.Ec2QueryName("IpamPool"))
      .annotate({ identifier: "IpamPool" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateIpamPoolResult",
}) as any as S.Schema<CreateIpamPoolResult>;
export type IpamPrefixListResolverRuleType =
  | "static-cidr"
  | "ipam-resource-cidr"
  | "ipam-pool-cidr"
  | (string & {});
export const IpamPrefixListResolverRuleType = S.String;
export type IpamResourceType =
  | "vpc"
  | "subnet"
  | "eip"
  | "public-ipv4-pool"
  | "ipv6-pool"
  | "eni"
  | "anycast-ip-list"
  | (string & {});
export const IpamResourceType = S.String;
export type IpamPrefixListResolverRuleConditionOperation =
  | "equals"
  | "not-equals"
  | "subnet-of"
  | (string & {});
export const IpamPrefixListResolverRuleConditionOperation = S.String;
export interface IpamPrefixListResolverRuleConditionRequest {
  Operation?: IpamPrefixListResolverRuleConditionOperation;
  IpamPoolId?: string;
  ResourceId?: string;
  ResourceOwner?: string;
  ResourceRegion?: string;
  ResourceTag?: RequestIpamResourceTag;
  Cidr?: string;
}
export const IpamPrefixListResolverRuleConditionRequest = S.suspend(() =>
  S.Struct({
    Operation: S.optional(IpamPrefixListResolverRuleConditionOperation),
    IpamPoolId: S.optional(S.String),
    ResourceId: S.optional(S.String),
    ResourceOwner: S.optional(S.String),
    ResourceRegion: S.optional(S.String),
    ResourceTag: S.optional(RequestIpamResourceTag),
    Cidr: S.optional(S.String),
  }),
).annotate({
  identifier: "IpamPrefixListResolverRuleConditionRequest",
}) as any as S.Schema<IpamPrefixListResolverRuleConditionRequest>;
export type IpamPrefixListResolverRuleConditionRequestSet =
  IpamPrefixListResolverRuleConditionRequest[];
export const IpamPrefixListResolverRuleConditionRequestSet = S.Array(
  IpamPrefixListResolverRuleConditionRequest.pipe(
    T.XmlName("Condition"),
  ).annotate({ identifier: "IpamPrefixListResolverRuleConditionRequest" }),
);
export interface IpamPrefixListResolverRuleRequest {
  RuleType?: IpamPrefixListResolverRuleType;
  StaticCidr?: string;
  IpamScopeId?: string;
  ResourceType?: IpamResourceType;
  Conditions?: IpamPrefixListResolverRuleConditionRequest[];
}
export const IpamPrefixListResolverRuleRequest = S.suspend(() =>
  S.Struct({
    RuleType: S.optional(IpamPrefixListResolverRuleType),
    StaticCidr: S.optional(S.String),
    IpamScopeId: S.optional(S.String),
    ResourceType: S.optional(IpamResourceType),
    Conditions: S.optional(IpamPrefixListResolverRuleConditionRequestSet).pipe(
      T.XmlName("Condition"),
    ),
  }),
).annotate({
  identifier: "IpamPrefixListResolverRuleRequest",
}) as any as S.Schema<IpamPrefixListResolverRuleRequest>;
export type IpamPrefixListResolverRuleRequestSet =
  IpamPrefixListResolverRuleRequest[];
export const IpamPrefixListResolverRuleRequestSet = S.Array(
  IpamPrefixListResolverRuleRequest.pipe(T.XmlName("Rule")).annotate({
    identifier: "IpamPrefixListResolverRuleRequest",
  }),
);
export interface CreateIpamPrefixListResolverRequest {
  DryRun?: boolean;
  IpamId?: string;
  Description?: string;
  AddressFamily?: AddressFamily;
  Rules?: IpamPrefixListResolverRuleRequest[];
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
}
export const CreateIpamPrefixListResolverRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamId: S.optional(S.String),
    Description: S.optional(S.String),
    AddressFamily: S.optional(AddressFamily),
    Rules: S.optional(IpamPrefixListResolverRuleRequestSet).pipe(
      T.XmlName("Rule"),
    ),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateIpamPrefixListResolverRequest",
}) as any as S.Schema<CreateIpamPrefixListResolverRequest>;
export type IpamPrefixListResolverState =
  | "create-in-progress"
  | "create-complete"
  | "create-failed"
  | "modify-in-progress"
  | "modify-complete"
  | "modify-failed"
  | "delete-in-progress"
  | "delete-complete"
  | "delete-failed"
  | "isolate-in-progress"
  | "isolate-complete"
  | "restore-in-progress"
  | (string & {});
export const IpamPrefixListResolverState = S.String;
export type IpamPrefixListResolverVersionCreationStatus =
  | "pending"
  | "success"
  | "failure"
  | (string & {});
export const IpamPrefixListResolverVersionCreationStatus = S.String;
export interface IpamPrefixListResolver {
  OwnerId?: string;
  IpamPrefixListResolverId?: string;
  IpamPrefixListResolverArn?: string;
  IpamArn?: string;
  IpamRegion?: string;
  Description?: string;
  AddressFamily?: AddressFamily;
  State?: IpamPrefixListResolverState;
  Tags?: Tag[];
  LastVersionCreationStatus?: IpamPrefixListResolverVersionCreationStatus;
  LastVersionCreationStatusMessage?: string;
}
export const IpamPrefixListResolver = S.suspend(() =>
  S.Struct({
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    IpamPrefixListResolverId: S.optional(S.String).pipe(
      T.XmlName("ipamPrefixListResolverId"),
      T.Ec2QueryName("IpamPrefixListResolverId"),
    ),
    IpamPrefixListResolverArn: S.optional(S.String).pipe(
      T.XmlName("ipamPrefixListResolverArn"),
      T.Ec2QueryName("IpamPrefixListResolverArn"),
    ),
    IpamArn: S.optional(S.String).pipe(
      T.XmlName("ipamArn"),
      T.Ec2QueryName("IpamArn"),
    ),
    IpamRegion: S.optional(S.String).pipe(
      T.XmlName("ipamRegion"),
      T.Ec2QueryName("IpamRegion"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    AddressFamily: S.optional(AddressFamily).pipe(
      T.XmlName("addressFamily"),
      T.Ec2QueryName("AddressFamily"),
    ),
    State: S.optional(IpamPrefixListResolverState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    LastVersionCreationStatus: S.optional(
      IpamPrefixListResolverVersionCreationStatus,
    ).pipe(
      T.XmlName("lastVersionCreationStatus"),
      T.Ec2QueryName("LastVersionCreationStatus"),
    ),
    LastVersionCreationStatusMessage: S.optional(S.String).pipe(
      T.XmlName("lastVersionCreationStatusMessage"),
      T.Ec2QueryName("LastVersionCreationStatusMessage"),
    ),
  }),
).annotate({
  identifier: "IpamPrefixListResolver",
}) as any as S.Schema<IpamPrefixListResolver>;
export interface CreateIpamPrefixListResolverResult {
  IpamPrefixListResolver?: IpamPrefixListResolver;
}
export const CreateIpamPrefixListResolverResult = S.suspend(() =>
  S.Struct({
    IpamPrefixListResolver: S.optional(IpamPrefixListResolver)
      .pipe(
        T.XmlName("ipamPrefixListResolver"),
        T.Ec2QueryName("IpamPrefixListResolver"),
      )
      .annotate({ identifier: "IpamPrefixListResolver" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateIpamPrefixListResolverResult",
}) as any as S.Schema<CreateIpamPrefixListResolverResult>;
export interface CreateIpamPrefixListResolverTargetRequest {
  DryRun?: boolean;
  IpamPrefixListResolverId?: string;
  PrefixListId?: string;
  PrefixListRegion?: string;
  DesiredVersion?: number;
  TrackLatestVersion?: boolean;
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
}
export const CreateIpamPrefixListResolverTargetRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPrefixListResolverId: S.optional(S.String),
    PrefixListId: S.optional(S.String),
    PrefixListRegion: S.optional(S.String),
    DesiredVersion: S.optional(S.Number),
    TrackLatestVersion: S.optional(S.Boolean),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateIpamPrefixListResolverTargetRequest",
}) as any as S.Schema<CreateIpamPrefixListResolverTargetRequest>;
export type IpamPrefixListResolverTargetState =
  | "create-in-progress"
  | "create-complete"
  | "create-failed"
  | "modify-in-progress"
  | "modify-complete"
  | "modify-failed"
  | "sync-in-progress"
  | "sync-complete"
  | "sync-failed"
  | "delete-in-progress"
  | "delete-complete"
  | "delete-failed"
  | "isolate-in-progress"
  | "isolate-complete"
  | "restore-in-progress"
  | (string & {});
export const IpamPrefixListResolverTargetState = S.String;
export interface IpamPrefixListResolverTarget {
  IpamPrefixListResolverTargetId?: string;
  IpamPrefixListResolverTargetArn?: string;
  IpamPrefixListResolverId?: string;
  OwnerId?: string;
  PrefixListId?: string;
  PrefixListRegion?: string;
  DesiredVersion?: number;
  LastSyncedVersion?: number;
  TrackLatestVersion?: boolean;
  StateMessage?: string;
  State?: IpamPrefixListResolverTargetState;
  Tags?: Tag[];
}
export const IpamPrefixListResolverTarget = S.suspend(() =>
  S.Struct({
    IpamPrefixListResolverTargetId: S.optional(S.String).pipe(
      T.XmlName("ipamPrefixListResolverTargetId"),
      T.Ec2QueryName("IpamPrefixListResolverTargetId"),
    ),
    IpamPrefixListResolverTargetArn: S.optional(S.String).pipe(
      T.XmlName("ipamPrefixListResolverTargetArn"),
      T.Ec2QueryName("IpamPrefixListResolverTargetArn"),
    ),
    IpamPrefixListResolverId: S.optional(S.String).pipe(
      T.XmlName("ipamPrefixListResolverId"),
      T.Ec2QueryName("IpamPrefixListResolverId"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    PrefixListId: S.optional(S.String).pipe(
      T.XmlName("prefixListId"),
      T.Ec2QueryName("PrefixListId"),
    ),
    PrefixListRegion: S.optional(S.String).pipe(
      T.XmlName("prefixListRegion"),
      T.Ec2QueryName("PrefixListRegion"),
    ),
    DesiredVersion: S.optional(S.Number).pipe(
      T.XmlName("desiredVersion"),
      T.Ec2QueryName("DesiredVersion"),
    ),
    LastSyncedVersion: S.optional(S.Number).pipe(
      T.XmlName("lastSyncedVersion"),
      T.Ec2QueryName("LastSyncedVersion"),
    ),
    TrackLatestVersion: S.optional(S.Boolean).pipe(
      T.XmlName("trackLatestVersion"),
      T.Ec2QueryName("TrackLatestVersion"),
    ),
    StateMessage: S.optional(S.String).pipe(
      T.XmlName("stateMessage"),
      T.Ec2QueryName("StateMessage"),
    ),
    State: S.optional(IpamPrefixListResolverTargetState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "IpamPrefixListResolverTarget",
}) as any as S.Schema<IpamPrefixListResolverTarget>;
export interface CreateIpamPrefixListResolverTargetResult {
  IpamPrefixListResolverTarget?: IpamPrefixListResolverTarget;
}
export const CreateIpamPrefixListResolverTargetResult = S.suspend(() =>
  S.Struct({
    IpamPrefixListResolverTarget: S.optional(IpamPrefixListResolverTarget)
      .pipe(
        T.XmlName("ipamPrefixListResolverTarget"),
        T.Ec2QueryName("IpamPrefixListResolverTarget"),
      )
      .annotate({ identifier: "IpamPrefixListResolverTarget" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateIpamPrefixListResolverTargetResult",
}) as any as S.Schema<CreateIpamPrefixListResolverTargetResult>;
export interface CreateIpamResourceDiscoveryRequest {
  DryRun?: boolean;
  Description?: string;
  OperatingRegions?: AddIpamOperatingRegion[];
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
}
export const CreateIpamResourceDiscoveryRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Description: S.optional(S.String),
    OperatingRegions: S.optional(AddIpamOperatingRegionSet).pipe(
      T.XmlName("OperatingRegion"),
    ),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateIpamResourceDiscoveryRequest",
}) as any as S.Schema<CreateIpamResourceDiscoveryRequest>;
export type IpamResourceDiscoveryState =
  | "create-in-progress"
  | "create-complete"
  | "create-failed"
  | "modify-in-progress"
  | "modify-complete"
  | "modify-failed"
  | "delete-in-progress"
  | "delete-complete"
  | "delete-failed"
  | "isolate-in-progress"
  | "isolate-complete"
  | "restore-in-progress"
  | (string & {});
export const IpamResourceDiscoveryState = S.String;
export interface IpamOrganizationalUnitExclusion {
  OrganizationsEntityPath?: string;
}
export const IpamOrganizationalUnitExclusion = S.suspend(() =>
  S.Struct({
    OrganizationsEntityPath: S.optional(S.String).pipe(
      T.XmlName("organizationsEntityPath"),
      T.Ec2QueryName("OrganizationsEntityPath"),
    ),
  }),
).annotate({
  identifier: "IpamOrganizationalUnitExclusion",
}) as any as S.Schema<IpamOrganizationalUnitExclusion>;
export type IpamOrganizationalUnitExclusionSet =
  IpamOrganizationalUnitExclusion[];
export const IpamOrganizationalUnitExclusionSet = S.Array(
  IpamOrganizationalUnitExclusion.pipe(T.XmlName("item")).annotate({
    identifier: "IpamOrganizationalUnitExclusion",
  }),
);
export interface IpamResourceDiscovery {
  OwnerId?: string;
  IpamResourceDiscoveryId?: string;
  IpamResourceDiscoveryArn?: string;
  IpamResourceDiscoveryRegion?: string;
  Description?: string;
  OperatingRegions?: IpamOperatingRegion[];
  IsDefault?: boolean;
  State?: IpamResourceDiscoveryState;
  Tags?: Tag[];
  OrganizationalUnitExclusions?: IpamOrganizationalUnitExclusion[];
}
export const IpamResourceDiscovery = S.suspend(() =>
  S.Struct({
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    IpamResourceDiscoveryId: S.optional(S.String).pipe(
      T.XmlName("ipamResourceDiscoveryId"),
      T.Ec2QueryName("IpamResourceDiscoveryId"),
    ),
    IpamResourceDiscoveryArn: S.optional(S.String).pipe(
      T.XmlName("ipamResourceDiscoveryArn"),
      T.Ec2QueryName("IpamResourceDiscoveryArn"),
    ),
    IpamResourceDiscoveryRegion: S.optional(S.String).pipe(
      T.XmlName("ipamResourceDiscoveryRegion"),
      T.Ec2QueryName("IpamResourceDiscoveryRegion"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    OperatingRegions: S.optional(IpamOperatingRegionSet).pipe(
      T.XmlName("operatingRegionSet"),
      T.Ec2QueryName("OperatingRegionSet"),
    ),
    IsDefault: S.optional(S.Boolean).pipe(
      T.XmlName("isDefault"),
      T.Ec2QueryName("IsDefault"),
    ),
    State: S.optional(IpamResourceDiscoveryState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    OrganizationalUnitExclusions: S.optional(
      IpamOrganizationalUnitExclusionSet,
    ).pipe(
      T.XmlName("organizationalUnitExclusionSet"),
      T.Ec2QueryName("OrganizationalUnitExclusionSet"),
    ),
  }),
).annotate({
  identifier: "IpamResourceDiscovery",
}) as any as S.Schema<IpamResourceDiscovery>;
export interface CreateIpamResourceDiscoveryResult {
  IpamResourceDiscovery?: IpamResourceDiscovery;
}
export const CreateIpamResourceDiscoveryResult = S.suspend(() =>
  S.Struct({
    IpamResourceDiscovery: S.optional(IpamResourceDiscovery)
      .pipe(
        T.XmlName("ipamResourceDiscovery"),
        T.Ec2QueryName("IpamResourceDiscovery"),
      )
      .annotate({ identifier: "IpamResourceDiscovery" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateIpamResourceDiscoveryResult",
}) as any as S.Schema<CreateIpamResourceDiscoveryResult>;
export type IpamScopeExternalAuthorityType = "infoblox" | (string & {});
export const IpamScopeExternalAuthorityType = S.String;
export interface ExternalAuthorityConfiguration {
  Type?: IpamScopeExternalAuthorityType;
  ExternalResourceIdentifier?: string;
}
export const ExternalAuthorityConfiguration = S.suspend(() =>
  S.Struct({
    Type: S.optional(IpamScopeExternalAuthorityType),
    ExternalResourceIdentifier: S.optional(S.String),
  }),
).annotate({
  identifier: "ExternalAuthorityConfiguration",
}) as any as S.Schema<ExternalAuthorityConfiguration>;
export interface CreateIpamScopeRequest {
  DryRun?: boolean;
  IpamId?: string;
  Description?: string;
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
  ExternalAuthorityConfiguration?: ExternalAuthorityConfiguration;
}
export const CreateIpamScopeRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamId: S.optional(S.String),
    Description: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    ExternalAuthorityConfiguration: S.optional(ExternalAuthorityConfiguration),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateIpamScopeRequest",
}) as any as S.Schema<CreateIpamScopeRequest>;
export type IpamScopeState =
  | "create-in-progress"
  | "create-complete"
  | "create-failed"
  | "modify-in-progress"
  | "modify-complete"
  | "modify-failed"
  | "delete-in-progress"
  | "delete-complete"
  | "delete-failed"
  | "isolate-in-progress"
  | "isolate-complete"
  | "restore-in-progress"
  | (string & {});
export const IpamScopeState = S.String;
export interface IpamScopeExternalAuthorityConfiguration {
  Type?: IpamScopeExternalAuthorityType;
  ExternalResourceIdentifier?: string;
}
export const IpamScopeExternalAuthorityConfiguration = S.suspend(() =>
  S.Struct({
    Type: S.optional(IpamScopeExternalAuthorityType).pipe(
      T.XmlName("type"),
      T.Ec2QueryName("Type"),
    ),
    ExternalResourceIdentifier: S.optional(S.String).pipe(
      T.XmlName("externalResourceIdentifier"),
      T.Ec2QueryName("ExternalResourceIdentifier"),
    ),
  }),
).annotate({
  identifier: "IpamScopeExternalAuthorityConfiguration",
}) as any as S.Schema<IpamScopeExternalAuthorityConfiguration>;
export interface IpamScope {
  OwnerId?: string;
  IpamScopeId?: string;
  IpamScopeArn?: string;
  IpamArn?: string;
  IpamRegion?: string;
  IpamScopeType?: IpamScopeType;
  IsDefault?: boolean;
  Description?: string;
  PoolCount?: number;
  State?: IpamScopeState;
  Tags?: Tag[];
  ExternalAuthorityConfiguration?: IpamScopeExternalAuthorityConfiguration;
}
export const IpamScope = S.suspend(() =>
  S.Struct({
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    IpamScopeId: S.optional(S.String).pipe(
      T.XmlName("ipamScopeId"),
      T.Ec2QueryName("IpamScopeId"),
    ),
    IpamScopeArn: S.optional(S.String).pipe(
      T.XmlName("ipamScopeArn"),
      T.Ec2QueryName("IpamScopeArn"),
    ),
    IpamArn: S.optional(S.String).pipe(
      T.XmlName("ipamArn"),
      T.Ec2QueryName("IpamArn"),
    ),
    IpamRegion: S.optional(S.String).pipe(
      T.XmlName("ipamRegion"),
      T.Ec2QueryName("IpamRegion"),
    ),
    IpamScopeType: S.optional(IpamScopeType).pipe(
      T.XmlName("ipamScopeType"),
      T.Ec2QueryName("IpamScopeType"),
    ),
    IsDefault: S.optional(S.Boolean).pipe(
      T.XmlName("isDefault"),
      T.Ec2QueryName("IsDefault"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    PoolCount: S.optional(S.Number).pipe(
      T.XmlName("poolCount"),
      T.Ec2QueryName("PoolCount"),
    ),
    State: S.optional(IpamScopeState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    ExternalAuthorityConfiguration: S.optional(
      IpamScopeExternalAuthorityConfiguration,
    )
      .pipe(
        T.XmlName("externalAuthorityConfiguration"),
        T.Ec2QueryName("ExternalAuthorityConfiguration"),
      )
      .annotate({ identifier: "IpamScopeExternalAuthorityConfiguration" }),
  }),
).annotate({ identifier: "IpamScope" }) as any as S.Schema<IpamScope>;
export interface CreateIpamScopeResult {
  IpamScope?: IpamScope;
}
export const CreateIpamScopeResult = S.suspend(() =>
  S.Struct({
    IpamScope: S.optional(IpamScope)
      .pipe(T.XmlName("ipamScope"), T.Ec2QueryName("IpamScope"))
      .annotate({ identifier: "IpamScope" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateIpamScopeResult",
}) as any as S.Schema<CreateIpamScopeResult>;
export type KeyType = "rsa" | "ed25519" | (string & {});
export const KeyType = S.String;
export type KeyFormat = "pem" | "ppk" | (string & {});
export const KeyFormat = S.String;
export interface CreateKeyPairRequest {
  KeyName?: string;
  KeyType?: KeyType;
  TagSpecifications?: TagSpecification[];
  KeyFormat?: KeyFormat;
  DryRun?: boolean;
}
export const CreateKeyPairRequest = S.suspend(() =>
  S.Struct({
    KeyName: S.optional(S.String),
    KeyType: S.optional(KeyType),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    KeyFormat: S.optional(KeyFormat),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateKeyPairRequest",
}) as any as S.Schema<CreateKeyPairRequest>;
export interface KeyPair {
  KeyPairId?: string;
  Tags?: Tag[];
  KeyName?: string;
  KeyFingerprint?: string;
  KeyMaterial?: string | redacted.Redacted<string>;
}
export const KeyPair = S.suspend(() =>
  S.Struct({
    KeyPairId: S.optional(S.String).pipe(
      T.XmlName("keyPairId"),
      T.Ec2QueryName("KeyPairId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    KeyName: S.optional(S.String).pipe(
      T.XmlName("keyName"),
      T.Ec2QueryName("KeyName"),
    ),
    KeyFingerprint: S.optional(S.String).pipe(
      T.XmlName("keyFingerprint"),
      T.Ec2QueryName("KeyFingerprint"),
    ),
    KeyMaterial: S.optional(SensitiveString).pipe(
      T.XmlName("keyMaterial"),
      T.Ec2QueryName("KeyMaterial"),
    ),
  }).pipe(ns),
).annotate({ identifier: "KeyPair" }) as any as S.Schema<KeyPair>;
export interface LaunchTemplateIamInstanceProfileSpecificationRequest {
  Arn?: string;
  Name?: string;
}
export const LaunchTemplateIamInstanceProfileSpecificationRequest = S.suspend(
  () => S.Struct({ Arn: S.optional(S.String), Name: S.optional(S.String) }),
).annotate({
  identifier: "LaunchTemplateIamInstanceProfileSpecificationRequest",
}) as any as S.Schema<LaunchTemplateIamInstanceProfileSpecificationRequest>;
export interface LaunchTemplateEbsBlockDeviceRequest {
  Encrypted?: boolean;
  DeleteOnTermination?: boolean;
  Iops?: number;
  KmsKeyId?: string;
  SnapshotId?: string;
  VolumeSize?: number;
  VolumeType?: VolumeType;
  Throughput?: number;
  VolumeInitializationRate?: number;
  EbsCardIndex?: number;
}
export const LaunchTemplateEbsBlockDeviceRequest = S.suspend(() =>
  S.Struct({
    Encrypted: S.optional(S.Boolean),
    DeleteOnTermination: S.optional(S.Boolean),
    Iops: S.optional(S.Number),
    KmsKeyId: S.optional(S.String),
    SnapshotId: S.optional(S.String),
    VolumeSize: S.optional(S.Number),
    VolumeType: S.optional(VolumeType),
    Throughput: S.optional(S.Number),
    VolumeInitializationRate: S.optional(S.Number),
    EbsCardIndex: S.optional(S.Number),
  }),
).annotate({
  identifier: "LaunchTemplateEbsBlockDeviceRequest",
}) as any as S.Schema<LaunchTemplateEbsBlockDeviceRequest>;
export interface LaunchTemplateBlockDeviceMappingRequest {
  DeviceName?: string;
  VirtualName?: string;
  Ebs?: LaunchTemplateEbsBlockDeviceRequest;
  NoDevice?: string;
}
export const LaunchTemplateBlockDeviceMappingRequest = S.suspend(() =>
  S.Struct({
    DeviceName: S.optional(S.String),
    VirtualName: S.optional(S.String),
    Ebs: S.optional(LaunchTemplateEbsBlockDeviceRequest),
    NoDevice: S.optional(S.String),
  }),
).annotate({
  identifier: "LaunchTemplateBlockDeviceMappingRequest",
}) as any as S.Schema<LaunchTemplateBlockDeviceMappingRequest>;
export type LaunchTemplateBlockDeviceMappingRequestList =
  LaunchTemplateBlockDeviceMappingRequest[];
export const LaunchTemplateBlockDeviceMappingRequestList = S.Array(
  LaunchTemplateBlockDeviceMappingRequest.pipe(
    T.XmlName("BlockDeviceMapping"),
  ).annotate({ identifier: "LaunchTemplateBlockDeviceMappingRequest" }),
);
export type SecurityGroupIdStringList = string[];
export const SecurityGroupIdStringList = S.Array(
  S.String.pipe(T.XmlName("SecurityGroupId")),
);
export interface InstanceIpv6AddressRequest {
  Ipv6Address?: string;
}
export const InstanceIpv6AddressRequest = S.suspend(() =>
  S.Struct({ Ipv6Address: S.optional(S.String) }),
).annotate({
  identifier: "InstanceIpv6AddressRequest",
}) as any as S.Schema<InstanceIpv6AddressRequest>;
export type InstanceIpv6AddressListRequest = InstanceIpv6AddressRequest[];
export const InstanceIpv6AddressListRequest = S.Array(
  InstanceIpv6AddressRequest.pipe(T.XmlName("InstanceIpv6Address")).annotate({
    identifier: "InstanceIpv6AddressRequest",
  }),
);
export interface PrivateIpAddressSpecification {
  Primary?: boolean;
  PrivateIpAddress?: string;
}
export const PrivateIpAddressSpecification = S.suspend(() =>
  S.Struct({
    Primary: S.optional(S.Boolean).pipe(
      T.XmlName("primary"),
      T.Ec2QueryName("Primary"),
    ),
    PrivateIpAddress: S.optional(S.String).pipe(
      T.XmlName("privateIpAddress"),
      T.Ec2QueryName("PrivateIpAddress"),
    ),
  }),
).annotate({
  identifier: "PrivateIpAddressSpecification",
}) as any as S.Schema<PrivateIpAddressSpecification>;
export type PrivateIpAddressSpecificationList = PrivateIpAddressSpecification[];
export const PrivateIpAddressSpecificationList = S.Array(
  PrivateIpAddressSpecification.pipe(T.XmlName("item")).annotate({
    identifier: "PrivateIpAddressSpecification",
  }),
);
export interface Ipv4PrefixSpecificationRequest {
  Ipv4Prefix?: string;
}
export const Ipv4PrefixSpecificationRequest = S.suspend(() =>
  S.Struct({ Ipv4Prefix: S.optional(S.String) }),
).annotate({
  identifier: "Ipv4PrefixSpecificationRequest",
}) as any as S.Schema<Ipv4PrefixSpecificationRequest>;
export type Ipv4PrefixList = Ipv4PrefixSpecificationRequest[];
export const Ipv4PrefixList = S.Array(
  Ipv4PrefixSpecificationRequest.pipe(T.XmlName("item")).annotate({
    identifier: "Ipv4PrefixSpecificationRequest",
  }),
);
export interface Ipv6PrefixSpecificationRequest {
  Ipv6Prefix?: string;
}
export const Ipv6PrefixSpecificationRequest = S.suspend(() =>
  S.Struct({ Ipv6Prefix: S.optional(S.String) }),
).annotate({
  identifier: "Ipv6PrefixSpecificationRequest",
}) as any as S.Schema<Ipv6PrefixSpecificationRequest>;
export type Ipv6PrefixList = Ipv6PrefixSpecificationRequest[];
export const Ipv6PrefixList = S.Array(
  Ipv6PrefixSpecificationRequest.pipe(T.XmlName("item")).annotate({
    identifier: "Ipv6PrefixSpecificationRequest",
  }),
);
export interface EnaSrdUdpSpecificationRequest {
  EnaSrdUdpEnabled?: boolean;
}
export const EnaSrdUdpSpecificationRequest = S.suspend(() =>
  S.Struct({ EnaSrdUdpEnabled: S.optional(S.Boolean) }),
).annotate({
  identifier: "EnaSrdUdpSpecificationRequest",
}) as any as S.Schema<EnaSrdUdpSpecificationRequest>;
export interface EnaSrdSpecificationRequest {
  EnaSrdEnabled?: boolean;
  EnaSrdUdpSpecification?: EnaSrdUdpSpecificationRequest;
}
export const EnaSrdSpecificationRequest = S.suspend(() =>
  S.Struct({
    EnaSrdEnabled: S.optional(S.Boolean),
    EnaSrdUdpSpecification: S.optional(EnaSrdUdpSpecificationRequest),
  }),
).annotate({
  identifier: "EnaSrdSpecificationRequest",
}) as any as S.Schema<EnaSrdSpecificationRequest>;
export interface ConnectionTrackingSpecificationRequest {
  TcpEstablishedTimeout?: number;
  UdpStreamTimeout?: number;
  UdpTimeout?: number;
}
export const ConnectionTrackingSpecificationRequest = S.suspend(() =>
  S.Struct({
    TcpEstablishedTimeout: S.optional(S.Number),
    UdpStreamTimeout: S.optional(S.Number),
    UdpTimeout: S.optional(S.Number),
  }),
).annotate({
  identifier: "ConnectionTrackingSpecificationRequest",
}) as any as S.Schema<ConnectionTrackingSpecificationRequest>;
export interface LaunchTemplateInstanceNetworkInterfaceSpecificationRequest {
  AssociateCarrierIpAddress?: boolean;
  AssociatePublicIpAddress?: boolean;
  DeleteOnTermination?: boolean;
  Description?: string;
  DeviceIndex?: number;
  Groups?: string[];
  InterfaceType?: string;
  Ipv6AddressCount?: number;
  Ipv6Addresses?: InstanceIpv6AddressRequest[];
  NetworkInterfaceId?: string;
  PrivateIpAddress?: string;
  PrivateIpAddresses?: PrivateIpAddressSpecification[];
  SecondaryPrivateIpAddressCount?: number;
  SubnetId?: string;
  NetworkCardIndex?: number;
  Ipv4Prefixes?: Ipv4PrefixSpecificationRequest[];
  Ipv4PrefixCount?: number;
  Ipv6Prefixes?: Ipv6PrefixSpecificationRequest[];
  Ipv6PrefixCount?: number;
  PrimaryIpv6?: boolean;
  EnaSrdSpecification?: EnaSrdSpecificationRequest;
  ConnectionTrackingSpecification?: ConnectionTrackingSpecificationRequest;
  EnaQueueCount?: number;
}
export const LaunchTemplateInstanceNetworkInterfaceSpecificationRequest =
  S.suspend(() =>
    S.Struct({
      AssociateCarrierIpAddress: S.optional(S.Boolean),
      AssociatePublicIpAddress: S.optional(S.Boolean),
      DeleteOnTermination: S.optional(S.Boolean),
      Description: S.optional(S.String),
      DeviceIndex: S.optional(S.Number),
      Groups: S.optional(SecurityGroupIdStringList).pipe(
        T.XmlName("SecurityGroupId"),
      ),
      InterfaceType: S.optional(S.String),
      Ipv6AddressCount: S.optional(S.Number),
      Ipv6Addresses: S.optional(InstanceIpv6AddressListRequest),
      NetworkInterfaceId: S.optional(S.String),
      PrivateIpAddress: S.optional(S.String),
      PrivateIpAddresses: S.optional(PrivateIpAddressSpecificationList),
      SecondaryPrivateIpAddressCount: S.optional(S.Number),
      SubnetId: S.optional(S.String),
      NetworkCardIndex: S.optional(S.Number),
      Ipv4Prefixes: S.optional(Ipv4PrefixList).pipe(T.XmlName("Ipv4Prefix")),
      Ipv4PrefixCount: S.optional(S.Number),
      Ipv6Prefixes: S.optional(Ipv6PrefixList).pipe(T.XmlName("Ipv6Prefix")),
      Ipv6PrefixCount: S.optional(S.Number),
      PrimaryIpv6: S.optional(S.Boolean),
      EnaSrdSpecification: S.optional(EnaSrdSpecificationRequest),
      ConnectionTrackingSpecification: S.optional(
        ConnectionTrackingSpecificationRequest,
      ),
      EnaQueueCount: S.optional(S.Number),
    }),
  ).annotate({
    identifier: "LaunchTemplateInstanceNetworkInterfaceSpecificationRequest",
  }) as any as S.Schema<LaunchTemplateInstanceNetworkInterfaceSpecificationRequest>;
export type LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList =
  LaunchTemplateInstanceNetworkInterfaceSpecificationRequest[];
export const LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList =
  S.Array(
    LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.pipe(
      T.XmlName("InstanceNetworkInterfaceSpecification"),
    ).annotate({
      identifier: "LaunchTemplateInstanceNetworkInterfaceSpecificationRequest",
    }),
  );
export interface LaunchTemplatesMonitoringRequest {
  Enabled?: boolean;
}
export const LaunchTemplatesMonitoringRequest = S.suspend(() =>
  S.Struct({ Enabled: S.optional(S.Boolean) }),
).annotate({
  identifier: "LaunchTemplatesMonitoringRequest",
}) as any as S.Schema<LaunchTemplatesMonitoringRequest>;
export interface LaunchTemplatePlacementRequest {
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  Affinity?: string;
  GroupName?: string;
  HostId?: string;
  Tenancy?: Tenancy;
  SpreadDomain?: string;
  HostResourceGroupArn?: string;
  PartitionNumber?: number;
  GroupId?: string;
}
export const LaunchTemplatePlacementRequest = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String),
    AvailabilityZoneId: S.optional(S.String),
    Affinity: S.optional(S.String),
    GroupName: S.optional(S.String),
    HostId: S.optional(S.String),
    Tenancy: S.optional(Tenancy),
    SpreadDomain: S.optional(S.String),
    HostResourceGroupArn: S.optional(S.String),
    PartitionNumber: S.optional(S.Number),
    GroupId: S.optional(S.String),
  }),
).annotate({
  identifier: "LaunchTemplatePlacementRequest",
}) as any as S.Schema<LaunchTemplatePlacementRequest>;
export type ShutdownBehavior = "stop" | "terminate" | (string & {});
export const ShutdownBehavior = S.String;
export interface LaunchTemplateTagSpecificationRequest {
  ResourceType?: ResourceType;
  Tags?: Tag[];
}
export const LaunchTemplateTagSpecificationRequest = S.suspend(() =>
  S.Struct({
    ResourceType: S.optional(ResourceType),
    Tags: S.optional(TagList).pipe(T.XmlName("Tag")),
  }),
).annotate({
  identifier: "LaunchTemplateTagSpecificationRequest",
}) as any as S.Schema<LaunchTemplateTagSpecificationRequest>;
export type LaunchTemplateTagSpecificationRequestList =
  LaunchTemplateTagSpecificationRequest[];
export const LaunchTemplateTagSpecificationRequestList = S.Array(
  LaunchTemplateTagSpecificationRequest.pipe(
    T.XmlName("LaunchTemplateTagSpecificationRequest"),
  ).annotate({ identifier: "LaunchTemplateTagSpecificationRequest" }),
);
export interface ElasticGpuSpecification {
  Type?: string;
}
export const ElasticGpuSpecification = S.suspend(() =>
  S.Struct({ Type: S.optional(S.String) }),
).annotate({
  identifier: "ElasticGpuSpecification",
}) as any as S.Schema<ElasticGpuSpecification>;
export type ElasticGpuSpecificationList = ElasticGpuSpecification[];
export const ElasticGpuSpecificationList = S.Array(
  ElasticGpuSpecification.pipe(T.XmlName("ElasticGpuSpecification")).annotate({
    identifier: "ElasticGpuSpecification",
  }),
);
export interface LaunchTemplateElasticInferenceAccelerator {
  Type?: string;
  Count?: number;
}
export const LaunchTemplateElasticInferenceAccelerator = S.suspend(() =>
  S.Struct({ Type: S.optional(S.String), Count: S.optional(S.Number) }),
).annotate({
  identifier: "LaunchTemplateElasticInferenceAccelerator",
}) as any as S.Schema<LaunchTemplateElasticInferenceAccelerator>;
export type LaunchTemplateElasticInferenceAcceleratorList =
  LaunchTemplateElasticInferenceAccelerator[];
export const LaunchTemplateElasticInferenceAcceleratorList = S.Array(
  LaunchTemplateElasticInferenceAccelerator.pipe(T.XmlName("item")).annotate({
    identifier: "LaunchTemplateElasticInferenceAccelerator",
  }),
);
export type SecurityGroupStringList = string[];
export const SecurityGroupStringList = S.Array(
  S.String.pipe(T.XmlName("SecurityGroup")),
);
export type MarketType =
  | "spot"
  | "capacity-block"
  | "interruptible-capacity-reservation"
  | (string & {});
export const MarketType = S.String;
export type SpotInstanceType = "one-time" | "persistent" | (string & {});
export const SpotInstanceType = S.String;
export type InstanceInterruptionBehavior =
  | "hibernate"
  | "stop"
  | "terminate"
  | (string & {});
export const InstanceInterruptionBehavior = S.String;
export interface LaunchTemplateSpotMarketOptionsRequest {
  MaxPrice?: string;
  SpotInstanceType?: SpotInstanceType;
  BlockDurationMinutes?: number;
  ValidUntil?: Date;
  InstanceInterruptionBehavior?: InstanceInterruptionBehavior;
}
export const LaunchTemplateSpotMarketOptionsRequest = S.suspend(() =>
  S.Struct({
    MaxPrice: S.optional(S.String),
    SpotInstanceType: S.optional(SpotInstanceType),
    BlockDurationMinutes: S.optional(S.Number),
    ValidUntil: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    InstanceInterruptionBehavior: S.optional(InstanceInterruptionBehavior),
  }),
).annotate({
  identifier: "LaunchTemplateSpotMarketOptionsRequest",
}) as any as S.Schema<LaunchTemplateSpotMarketOptionsRequest>;
export interface LaunchTemplateInstanceMarketOptionsRequest {
  MarketType?: MarketType;
  SpotOptions?: LaunchTemplateSpotMarketOptionsRequest;
}
export const LaunchTemplateInstanceMarketOptionsRequest = S.suspend(() =>
  S.Struct({
    MarketType: S.optional(MarketType),
    SpotOptions: S.optional(LaunchTemplateSpotMarketOptionsRequest),
  }),
).annotate({
  identifier: "LaunchTemplateInstanceMarketOptionsRequest",
}) as any as S.Schema<LaunchTemplateInstanceMarketOptionsRequest>;
export interface CreditSpecificationRequest {
  CpuCredits?: string;
}
export const CreditSpecificationRequest = S.suspend(() =>
  S.Struct({ CpuCredits: S.optional(S.String) }),
).annotate({
  identifier: "CreditSpecificationRequest",
}) as any as S.Schema<CreditSpecificationRequest>;
export type AmdSevSnpSpecification = "enabled" | "disabled" | (string & {});
export const AmdSevSnpSpecification = S.String;
export type NestedVirtualizationSpecification =
  | "enabled"
  | "disabled"
  | (string & {});
export const NestedVirtualizationSpecification = S.String;
export interface LaunchTemplateCpuOptionsRequest {
  CoreCount?: number;
  ThreadsPerCore?: number;
  AmdSevSnp?: AmdSevSnpSpecification;
  NestedVirtualization?: NestedVirtualizationSpecification;
}
export const LaunchTemplateCpuOptionsRequest = S.suspend(() =>
  S.Struct({
    CoreCount: S.optional(S.Number),
    ThreadsPerCore: S.optional(S.Number),
    AmdSevSnp: S.optional(AmdSevSnpSpecification),
    NestedVirtualization: S.optional(NestedVirtualizationSpecification),
  }),
).annotate({
  identifier: "LaunchTemplateCpuOptionsRequest",
}) as any as S.Schema<LaunchTemplateCpuOptionsRequest>;
export type CapacityReservationPreference =
  | "capacity-reservations-only"
  | "open"
  | "none"
  | (string & {});
export const CapacityReservationPreference = S.String;
export interface CapacityReservationTarget {
  CapacityReservationId?: string;
  CapacityReservationResourceGroupArn?: string;
}
export const CapacityReservationTarget = S.suspend(() =>
  S.Struct({
    CapacityReservationId: S.optional(S.String),
    CapacityReservationResourceGroupArn: S.optional(S.String),
  }),
).annotate({
  identifier: "CapacityReservationTarget",
}) as any as S.Schema<CapacityReservationTarget>;
export interface LaunchTemplateCapacityReservationSpecificationRequest {
  CapacityReservationPreference?: CapacityReservationPreference;
  CapacityReservationTarget?: CapacityReservationTarget;
}
export const LaunchTemplateCapacityReservationSpecificationRequest = S.suspend(
  () =>
    S.Struct({
      CapacityReservationPreference: S.optional(CapacityReservationPreference),
      CapacityReservationTarget: S.optional(CapacityReservationTarget),
    }),
).annotate({
  identifier: "LaunchTemplateCapacityReservationSpecificationRequest",
}) as any as S.Schema<LaunchTemplateCapacityReservationSpecificationRequest>;
export interface LaunchTemplateLicenseConfigurationRequest {
  LicenseConfigurationArn?: string;
}
export const LaunchTemplateLicenseConfigurationRequest = S.suspend(() =>
  S.Struct({ LicenseConfigurationArn: S.optional(S.String) }),
).annotate({
  identifier: "LaunchTemplateLicenseConfigurationRequest",
}) as any as S.Schema<LaunchTemplateLicenseConfigurationRequest>;
export type LaunchTemplateLicenseSpecificationListRequest =
  LaunchTemplateLicenseConfigurationRequest[];
export const LaunchTemplateLicenseSpecificationListRequest = S.Array(
  LaunchTemplateLicenseConfigurationRequest.pipe(T.XmlName("item")).annotate({
    identifier: "LaunchTemplateLicenseConfigurationRequest",
  }),
);
export interface LaunchTemplateHibernationOptionsRequest {
  Configured?: boolean;
}
export const LaunchTemplateHibernationOptionsRequest = S.suspend(() =>
  S.Struct({ Configured: S.optional(S.Boolean) }),
).annotate({
  identifier: "LaunchTemplateHibernationOptionsRequest",
}) as any as S.Schema<LaunchTemplateHibernationOptionsRequest>;
export type LaunchTemplateHttpTokensState =
  | "optional"
  | "required"
  | (string & {});
export const LaunchTemplateHttpTokensState = S.String;
export type LaunchTemplateInstanceMetadataEndpointState =
  | "disabled"
  | "enabled"
  | (string & {});
export const LaunchTemplateInstanceMetadataEndpointState = S.String;
export type LaunchTemplateInstanceMetadataProtocolIpv6 =
  | "disabled"
  | "enabled"
  | (string & {});
export const LaunchTemplateInstanceMetadataProtocolIpv6 = S.String;
export type LaunchTemplateInstanceMetadataTagsState =
  | "disabled"
  | "enabled"
  | (string & {});
export const LaunchTemplateInstanceMetadataTagsState = S.String;
export interface LaunchTemplateInstanceMetadataOptionsRequest {
  HttpTokens?: LaunchTemplateHttpTokensState;
  HttpPutResponseHopLimit?: number;
  HttpEndpoint?: LaunchTemplateInstanceMetadataEndpointState;
  HttpProtocolIpv6?: LaunchTemplateInstanceMetadataProtocolIpv6;
  InstanceMetadataTags?: LaunchTemplateInstanceMetadataTagsState;
}
export const LaunchTemplateInstanceMetadataOptionsRequest = S.suspend(() =>
  S.Struct({
    HttpTokens: S.optional(LaunchTemplateHttpTokensState),
    HttpPutResponseHopLimit: S.optional(S.Number),
    HttpEndpoint: S.optional(LaunchTemplateInstanceMetadataEndpointState),
    HttpProtocolIpv6: S.optional(LaunchTemplateInstanceMetadataProtocolIpv6),
    InstanceMetadataTags: S.optional(LaunchTemplateInstanceMetadataTagsState),
  }),
).annotate({
  identifier: "LaunchTemplateInstanceMetadataOptionsRequest",
}) as any as S.Schema<LaunchTemplateInstanceMetadataOptionsRequest>;
export interface LaunchTemplateEnclaveOptionsRequest {
  Enabled?: boolean;
}
export const LaunchTemplateEnclaveOptionsRequest = S.suspend(() =>
  S.Struct({ Enabled: S.optional(S.Boolean) }),
).annotate({
  identifier: "LaunchTemplateEnclaveOptionsRequest",
}) as any as S.Schema<LaunchTemplateEnclaveOptionsRequest>;
export interface LaunchTemplatePrivateDnsNameOptionsRequest {
  HostnameType?: HostnameType;
  EnableResourceNameDnsARecord?: boolean;
  EnableResourceNameDnsAAAARecord?: boolean;
}
export const LaunchTemplatePrivateDnsNameOptionsRequest = S.suspend(() =>
  S.Struct({
    HostnameType: S.optional(HostnameType),
    EnableResourceNameDnsARecord: S.optional(S.Boolean),
    EnableResourceNameDnsAAAARecord: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "LaunchTemplatePrivateDnsNameOptionsRequest",
}) as any as S.Schema<LaunchTemplatePrivateDnsNameOptionsRequest>;
export type LaunchTemplateAutoRecoveryState =
  | "default"
  | "disabled"
  | (string & {});
export const LaunchTemplateAutoRecoveryState = S.String;
export interface LaunchTemplateInstanceMaintenanceOptionsRequest {
  AutoRecovery?: LaunchTemplateAutoRecoveryState;
}
export const LaunchTemplateInstanceMaintenanceOptionsRequest = S.suspend(() =>
  S.Struct({ AutoRecovery: S.optional(LaunchTemplateAutoRecoveryState) }),
).annotate({
  identifier: "LaunchTemplateInstanceMaintenanceOptionsRequest",
}) as any as S.Schema<LaunchTemplateInstanceMaintenanceOptionsRequest>;
export interface OperatorRequest {
  Principal?: string;
}
export const OperatorRequest = S.suspend(() =>
  S.Struct({ Principal: S.optional(S.String) }),
).annotate({
  identifier: "OperatorRequest",
}) as any as S.Schema<OperatorRequest>;
export type InstanceBandwidthWeighting =
  | "default"
  | "vpc-1"
  | "ebs-1"
  | (string & {});
export const InstanceBandwidthWeighting = S.String;
export interface LaunchTemplateNetworkPerformanceOptionsRequest {
  BandwidthWeighting?: InstanceBandwidthWeighting;
}
export const LaunchTemplateNetworkPerformanceOptionsRequest = S.suspend(() =>
  S.Struct({ BandwidthWeighting: S.optional(InstanceBandwidthWeighting) }),
).annotate({
  identifier: "LaunchTemplateNetworkPerformanceOptionsRequest",
}) as any as S.Schema<LaunchTemplateNetworkPerformanceOptionsRequest>;
export interface SecondaryInterfacePrivateIpAddressSpecificationRequest {
  PrivateIpAddress?: string;
}
export const SecondaryInterfacePrivateIpAddressSpecificationRequest = S.suspend(
  () => S.Struct({ PrivateIpAddress: S.optional(S.String) }),
).annotate({
  identifier: "SecondaryInterfacePrivateIpAddressSpecificationRequest",
}) as any as S.Schema<SecondaryInterfacePrivateIpAddressSpecificationRequest>;
export type SecondaryInterfacePrivateIpAddressSpecificationListRequest =
  SecondaryInterfacePrivateIpAddressSpecificationRequest[];
export const SecondaryInterfacePrivateIpAddressSpecificationListRequest =
  S.Array(
    SecondaryInterfacePrivateIpAddressSpecificationRequest.pipe(
      T.XmlName("SecondaryInterfacePrivateIpAddressSpecification"),
    ).annotate({
      identifier: "SecondaryInterfacePrivateIpAddressSpecificationRequest",
    }),
  );
export type SecondaryInterfaceType = "secondary" | (string & {});
export const SecondaryInterfaceType = S.String;
export interface LaunchTemplateInstanceSecondaryInterfaceSpecificationRequest {
  DeleteOnTermination?: boolean;
  DeviceIndex?: number;
  PrivateIpAddresses?: SecondaryInterfacePrivateIpAddressSpecificationRequest[];
  PrivateIpAddressCount?: number;
  SecondarySubnetId?: string;
  InterfaceType?: SecondaryInterfaceType;
  NetworkCardIndex?: number;
}
export const LaunchTemplateInstanceSecondaryInterfaceSpecificationRequest =
  S.suspend(() =>
    S.Struct({
      DeleteOnTermination: S.optional(S.Boolean),
      DeviceIndex: S.optional(S.Number),
      PrivateIpAddresses: S.optional(
        SecondaryInterfacePrivateIpAddressSpecificationListRequest,
      ).pipe(T.XmlName("PrivateIpAddress")),
      PrivateIpAddressCount: S.optional(S.Number),
      SecondarySubnetId: S.optional(S.String),
      InterfaceType: S.optional(SecondaryInterfaceType),
      NetworkCardIndex: S.optional(S.Number),
    }),
  ).annotate({
    identifier: "LaunchTemplateInstanceSecondaryInterfaceSpecificationRequest",
  }) as any as S.Schema<LaunchTemplateInstanceSecondaryInterfaceSpecificationRequest>;
export type LaunchTemplateInstanceSecondaryInterfaceSpecificationRequestList =
  LaunchTemplateInstanceSecondaryInterfaceSpecificationRequest[];
export const LaunchTemplateInstanceSecondaryInterfaceSpecificationRequestList =
  S.Array(
    LaunchTemplateInstanceSecondaryInterfaceSpecificationRequest.pipe(
      T.XmlName("InstanceSecondaryInterfaceSpecification"),
    ).annotate({
      identifier:
        "LaunchTemplateInstanceSecondaryInterfaceSpecificationRequest",
    }),
  );
export interface RequestLaunchTemplateData {
  KernelId?: string;
  EbsOptimized?: boolean;
  IamInstanceProfile?: LaunchTemplateIamInstanceProfileSpecificationRequest;
  BlockDeviceMappings?: LaunchTemplateBlockDeviceMappingRequest[];
  NetworkInterfaces?: LaunchTemplateInstanceNetworkInterfaceSpecificationRequest[];
  ImageId?: string;
  InstanceType?: InstanceType;
  KeyName?: string;
  Monitoring?: LaunchTemplatesMonitoringRequest;
  Placement?: LaunchTemplatePlacementRequest;
  RamDiskId?: string;
  DisableApiTermination?: boolean;
  InstanceInitiatedShutdownBehavior?: ShutdownBehavior;
  UserData?: string | redacted.Redacted<string>;
  TagSpecifications?: LaunchTemplateTagSpecificationRequest[];
  ElasticGpuSpecifications?: ElasticGpuSpecification[];
  ElasticInferenceAccelerators?: LaunchTemplateElasticInferenceAccelerator[];
  SecurityGroupIds?: string[];
  SecurityGroups?: string[];
  InstanceMarketOptions?: LaunchTemplateInstanceMarketOptionsRequest;
  CreditSpecification?: CreditSpecificationRequest;
  CpuOptions?: LaunchTemplateCpuOptionsRequest;
  CapacityReservationSpecification?: LaunchTemplateCapacityReservationSpecificationRequest;
  LicenseSpecifications?: LaunchTemplateLicenseConfigurationRequest[];
  HibernationOptions?: LaunchTemplateHibernationOptionsRequest;
  MetadataOptions?: LaunchTemplateInstanceMetadataOptionsRequest;
  EnclaveOptions?: LaunchTemplateEnclaveOptionsRequest;
  InstanceRequirements?: InstanceRequirementsRequest;
  PrivateDnsNameOptions?: LaunchTemplatePrivateDnsNameOptionsRequest;
  MaintenanceOptions?: LaunchTemplateInstanceMaintenanceOptionsRequest;
  DisableApiStop?: boolean;
  Operator?: OperatorRequest;
  NetworkPerformanceOptions?: LaunchTemplateNetworkPerformanceOptionsRequest;
  SecondaryInterfaces?: LaunchTemplateInstanceSecondaryInterfaceSpecificationRequest[];
}
export const RequestLaunchTemplateData = S.suspend(() =>
  S.Struct({
    KernelId: S.optional(S.String),
    EbsOptimized: S.optional(S.Boolean),
    IamInstanceProfile: S.optional(
      LaunchTemplateIamInstanceProfileSpecificationRequest,
    ),
    BlockDeviceMappings: S.optional(
      LaunchTemplateBlockDeviceMappingRequestList,
    ).pipe(T.XmlName("BlockDeviceMapping")),
    NetworkInterfaces: S.optional(
      LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList,
    ).pipe(T.XmlName("NetworkInterface")),
    ImageId: S.optional(S.String),
    InstanceType: S.optional(InstanceType),
    KeyName: S.optional(S.String),
    Monitoring: S.optional(LaunchTemplatesMonitoringRequest),
    Placement: S.optional(LaunchTemplatePlacementRequest),
    RamDiskId: S.optional(S.String),
    DisableApiTermination: S.optional(S.Boolean),
    InstanceInitiatedShutdownBehavior: S.optional(ShutdownBehavior),
    UserData: S.optional(SensitiveString),
    TagSpecifications: S.optional(
      LaunchTemplateTagSpecificationRequestList,
    ).pipe(T.XmlName("TagSpecification")),
    ElasticGpuSpecifications: S.optional(ElasticGpuSpecificationList).pipe(
      T.XmlName("ElasticGpuSpecification"),
    ),
    ElasticInferenceAccelerators: S.optional(
      LaunchTemplateElasticInferenceAcceleratorList,
    ).pipe(T.XmlName("ElasticInferenceAccelerator")),
    SecurityGroupIds: S.optional(SecurityGroupIdStringList).pipe(
      T.XmlName("SecurityGroupId"),
    ),
    SecurityGroups: S.optional(SecurityGroupStringList).pipe(
      T.XmlName("SecurityGroup"),
    ),
    InstanceMarketOptions: S.optional(
      LaunchTemplateInstanceMarketOptionsRequest,
    ),
    CreditSpecification: S.optional(CreditSpecificationRequest),
    CpuOptions: S.optional(LaunchTemplateCpuOptionsRequest),
    CapacityReservationSpecification: S.optional(
      LaunchTemplateCapacityReservationSpecificationRequest,
    ),
    LicenseSpecifications: S.optional(
      LaunchTemplateLicenseSpecificationListRequest,
    ).pipe(T.XmlName("LicenseSpecification")),
    HibernationOptions: S.optional(LaunchTemplateHibernationOptionsRequest),
    MetadataOptions: S.optional(LaunchTemplateInstanceMetadataOptionsRequest),
    EnclaveOptions: S.optional(LaunchTemplateEnclaveOptionsRequest),
    InstanceRequirements: S.optional(InstanceRequirementsRequest),
    PrivateDnsNameOptions: S.optional(
      LaunchTemplatePrivateDnsNameOptionsRequest,
    ),
    MaintenanceOptions: S.optional(
      LaunchTemplateInstanceMaintenanceOptionsRequest,
    ),
    DisableApiStop: S.optional(S.Boolean),
    Operator: S.optional(OperatorRequest),
    NetworkPerformanceOptions: S.optional(
      LaunchTemplateNetworkPerformanceOptionsRequest,
    ),
    SecondaryInterfaces: S.optional(
      LaunchTemplateInstanceSecondaryInterfaceSpecificationRequestList,
    ).pipe(T.XmlName("SecondaryInterface")),
  }),
).annotate({
  identifier: "RequestLaunchTemplateData",
}) as any as S.Schema<RequestLaunchTemplateData>;
export interface CreateLaunchTemplateRequest {
  DryRun?: boolean;
  ClientToken?: string;
  LaunchTemplateName?: string;
  VersionDescription?: string;
  LaunchTemplateData?: RequestLaunchTemplateData;
  Operator?: OperatorRequest;
  TagSpecifications?: TagSpecification[];
}
export const CreateLaunchTemplateRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    LaunchTemplateName: S.optional(S.String),
    VersionDescription: S.optional(S.String),
    LaunchTemplateData: S.optional(RequestLaunchTemplateData),
    Operator: S.optional(OperatorRequest),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateLaunchTemplateRequest",
}) as any as S.Schema<CreateLaunchTemplateRequest>;
export interface LaunchTemplate {
  LaunchTemplateId?: string;
  LaunchTemplateName?: string;
  CreateTime?: Date;
  CreatedBy?: string;
  DefaultVersionNumber?: number;
  LatestVersionNumber?: number;
  Tags?: Tag[];
  Operator?: OperatorResponse;
}
export const LaunchTemplate = S.suspend(() =>
  S.Struct({
    LaunchTemplateId: S.optional(S.String).pipe(
      T.XmlName("launchTemplateId"),
      T.Ec2QueryName("LaunchTemplateId"),
    ),
    LaunchTemplateName: S.optional(S.String).pipe(
      T.XmlName("launchTemplateName"),
      T.Ec2QueryName("LaunchTemplateName"),
    ),
    CreateTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createTime"), T.Ec2QueryName("CreateTime")),
    CreatedBy: S.optional(S.String).pipe(
      T.XmlName("createdBy"),
      T.Ec2QueryName("CreatedBy"),
    ),
    DefaultVersionNumber: S.optional(S.Number).pipe(
      T.XmlName("defaultVersionNumber"),
      T.Ec2QueryName("DefaultVersionNumber"),
    ),
    LatestVersionNumber: S.optional(S.Number).pipe(
      T.XmlName("latestVersionNumber"),
      T.Ec2QueryName("LatestVersionNumber"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    Operator: S.optional(OperatorResponse)
      .pipe(T.XmlName("operator"), T.Ec2QueryName("Operator"))
      .annotate({ identifier: "OperatorResponse" }),
  }),
).annotate({ identifier: "LaunchTemplate" }) as any as S.Schema<LaunchTemplate>;
export interface ValidationError {
  Code?: string;
  Message?: string;
}
export const ValidationError = S.suspend(() =>
  S.Struct({
    Code: S.optional(S.String).pipe(T.XmlName("code"), T.Ec2QueryName("Code")),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "ValidationError",
}) as any as S.Schema<ValidationError>;
export type ErrorSet = ValidationError[];
export const ErrorSet = S.Array(
  ValidationError.pipe(T.XmlName("item")).annotate({
    identifier: "ValidationError",
  }),
);
export interface ValidationWarning {
  Errors?: ValidationError[];
}
export const ValidationWarning = S.suspend(() =>
  S.Struct({
    Errors: S.optional(ErrorSet).pipe(
      T.XmlName("errorSet"),
      T.Ec2QueryName("ErrorSet"),
    ),
  }),
).annotate({
  identifier: "ValidationWarning",
}) as any as S.Schema<ValidationWarning>;
export interface CreateLaunchTemplateResult {
  LaunchTemplate?: LaunchTemplate;
  Warning?: ValidationWarning;
}
export const CreateLaunchTemplateResult = S.suspend(() =>
  S.Struct({
    LaunchTemplate: S.optional(LaunchTemplate)
      .pipe(T.XmlName("launchTemplate"), T.Ec2QueryName("LaunchTemplate"))
      .annotate({ identifier: "LaunchTemplate" }),
    Warning: S.optional(ValidationWarning)
      .pipe(T.XmlName("warning"), T.Ec2QueryName("Warning"))
      .annotate({ identifier: "ValidationWarning" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateLaunchTemplateResult",
}) as any as S.Schema<CreateLaunchTemplateResult>;
export interface CreateLaunchTemplateVersionRequest {
  DryRun?: boolean;
  ClientToken?: string;
  LaunchTemplateId?: string;
  LaunchTemplateName?: string;
  SourceVersion?: string;
  VersionDescription?: string;
  LaunchTemplateData?: RequestLaunchTemplateData;
  ResolveAlias?: boolean;
}
export const CreateLaunchTemplateVersionRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    LaunchTemplateId: S.optional(S.String),
    LaunchTemplateName: S.optional(S.String),
    SourceVersion: S.optional(S.String),
    VersionDescription: S.optional(S.String),
    LaunchTemplateData: S.optional(RequestLaunchTemplateData),
    ResolveAlias: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateLaunchTemplateVersionRequest",
}) as any as S.Schema<CreateLaunchTemplateVersionRequest>;
export interface LaunchTemplateIamInstanceProfileSpecification {
  Arn?: string;
  Name?: string;
}
export const LaunchTemplateIamInstanceProfileSpecification = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String).pipe(T.XmlName("arn"), T.Ec2QueryName("Arn")),
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
  }),
).annotate({
  identifier: "LaunchTemplateIamInstanceProfileSpecification",
}) as any as S.Schema<LaunchTemplateIamInstanceProfileSpecification>;
export interface LaunchTemplateEbsBlockDevice {
  Encrypted?: boolean;
  DeleteOnTermination?: boolean;
  Iops?: number;
  KmsKeyId?: string;
  SnapshotId?: string;
  VolumeSize?: number;
  VolumeType?: VolumeType;
  Throughput?: number;
  VolumeInitializationRate?: number;
  EbsCardIndex?: number;
}
export const LaunchTemplateEbsBlockDevice = S.suspend(() =>
  S.Struct({
    Encrypted: S.optional(S.Boolean).pipe(
      T.XmlName("encrypted"),
      T.Ec2QueryName("Encrypted"),
    ),
    DeleteOnTermination: S.optional(S.Boolean).pipe(
      T.XmlName("deleteOnTermination"),
      T.Ec2QueryName("DeleteOnTermination"),
    ),
    Iops: S.optional(S.Number).pipe(T.XmlName("iops"), T.Ec2QueryName("Iops")),
    KmsKeyId: S.optional(S.String).pipe(
      T.XmlName("kmsKeyId"),
      T.Ec2QueryName("KmsKeyId"),
    ),
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    VolumeSize: S.optional(S.Number).pipe(
      T.XmlName("volumeSize"),
      T.Ec2QueryName("VolumeSize"),
    ),
    VolumeType: S.optional(VolumeType).pipe(
      T.XmlName("volumeType"),
      T.Ec2QueryName("VolumeType"),
    ),
    Throughput: S.optional(S.Number).pipe(
      T.XmlName("throughput"),
      T.Ec2QueryName("Throughput"),
    ),
    VolumeInitializationRate: S.optional(S.Number).pipe(
      T.XmlName("volumeInitializationRate"),
      T.Ec2QueryName("VolumeInitializationRate"),
    ),
    EbsCardIndex: S.optional(S.Number).pipe(
      T.XmlName("ebsCardIndex"),
      T.Ec2QueryName("EbsCardIndex"),
    ),
  }),
).annotate({
  identifier: "LaunchTemplateEbsBlockDevice",
}) as any as S.Schema<LaunchTemplateEbsBlockDevice>;
export interface LaunchTemplateBlockDeviceMapping {
  DeviceName?: string;
  VirtualName?: string;
  Ebs?: LaunchTemplateEbsBlockDevice;
  NoDevice?: string;
}
export const LaunchTemplateBlockDeviceMapping = S.suspend(() =>
  S.Struct({
    DeviceName: S.optional(S.String).pipe(
      T.XmlName("deviceName"),
      T.Ec2QueryName("DeviceName"),
    ),
    VirtualName: S.optional(S.String).pipe(
      T.XmlName("virtualName"),
      T.Ec2QueryName("VirtualName"),
    ),
    Ebs: S.optional(LaunchTemplateEbsBlockDevice)
      .pipe(T.XmlName("ebs"), T.Ec2QueryName("Ebs"))
      .annotate({ identifier: "LaunchTemplateEbsBlockDevice" }),
    NoDevice: S.optional(S.String).pipe(
      T.XmlName("noDevice"),
      T.Ec2QueryName("NoDevice"),
    ),
  }),
).annotate({
  identifier: "LaunchTemplateBlockDeviceMapping",
}) as any as S.Schema<LaunchTemplateBlockDeviceMapping>;
export type LaunchTemplateBlockDeviceMappingList =
  LaunchTemplateBlockDeviceMapping[];
export const LaunchTemplateBlockDeviceMappingList = S.Array(
  LaunchTemplateBlockDeviceMapping.pipe(T.XmlName("item")).annotate({
    identifier: "LaunchTemplateBlockDeviceMapping",
  }),
);
export interface InstanceIpv6Address {
  Ipv6Address?: string;
  IsPrimaryIpv6?: boolean;
}
export const InstanceIpv6Address = S.suspend(() =>
  S.Struct({
    Ipv6Address: S.optional(S.String).pipe(
      T.XmlName("ipv6Address"),
      T.Ec2QueryName("Ipv6Address"),
    ),
    IsPrimaryIpv6: S.optional(S.Boolean).pipe(
      T.XmlName("isPrimaryIpv6"),
      T.Ec2QueryName("IsPrimaryIpv6"),
    ),
  }),
).annotate({
  identifier: "InstanceIpv6Address",
}) as any as S.Schema<InstanceIpv6Address>;
export type InstanceIpv6AddressList = InstanceIpv6Address[];
export const InstanceIpv6AddressList = S.Array(
  InstanceIpv6Address.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceIpv6Address",
  }),
);
export interface Ipv4PrefixSpecificationResponse {
  Ipv4Prefix?: string;
}
export const Ipv4PrefixSpecificationResponse = S.suspend(() =>
  S.Struct({
    Ipv4Prefix: S.optional(S.String).pipe(
      T.XmlName("ipv4Prefix"),
      T.Ec2QueryName("Ipv4Prefix"),
    ),
  }),
).annotate({
  identifier: "Ipv4PrefixSpecificationResponse",
}) as any as S.Schema<Ipv4PrefixSpecificationResponse>;
export type Ipv4PrefixListResponse = Ipv4PrefixSpecificationResponse[];
export const Ipv4PrefixListResponse = S.Array(
  Ipv4PrefixSpecificationResponse.pipe(T.XmlName("item")).annotate({
    identifier: "Ipv4PrefixSpecificationResponse",
  }),
);
export interface Ipv6PrefixSpecificationResponse {
  Ipv6Prefix?: string;
}
export const Ipv6PrefixSpecificationResponse = S.suspend(() =>
  S.Struct({
    Ipv6Prefix: S.optional(S.String).pipe(
      T.XmlName("ipv6Prefix"),
      T.Ec2QueryName("Ipv6Prefix"),
    ),
  }),
).annotate({
  identifier: "Ipv6PrefixSpecificationResponse",
}) as any as S.Schema<Ipv6PrefixSpecificationResponse>;
export type Ipv6PrefixListResponse = Ipv6PrefixSpecificationResponse[];
export const Ipv6PrefixListResponse = S.Array(
  Ipv6PrefixSpecificationResponse.pipe(T.XmlName("item")).annotate({
    identifier: "Ipv6PrefixSpecificationResponse",
  }),
);
export interface LaunchTemplateEnaSrdUdpSpecification {
  EnaSrdUdpEnabled?: boolean;
}
export const LaunchTemplateEnaSrdUdpSpecification = S.suspend(() =>
  S.Struct({
    EnaSrdUdpEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("enaSrdUdpEnabled"),
      T.Ec2QueryName("EnaSrdUdpEnabled"),
    ),
  }),
).annotate({
  identifier: "LaunchTemplateEnaSrdUdpSpecification",
}) as any as S.Schema<LaunchTemplateEnaSrdUdpSpecification>;
export interface LaunchTemplateEnaSrdSpecification {
  EnaSrdEnabled?: boolean;
  EnaSrdUdpSpecification?: LaunchTemplateEnaSrdUdpSpecification;
}
export const LaunchTemplateEnaSrdSpecification = S.suspend(() =>
  S.Struct({
    EnaSrdEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("enaSrdEnabled"),
      T.Ec2QueryName("EnaSrdEnabled"),
    ),
    EnaSrdUdpSpecification: S.optional(LaunchTemplateEnaSrdUdpSpecification)
      .pipe(
        T.XmlName("enaSrdUdpSpecification"),
        T.Ec2QueryName("EnaSrdUdpSpecification"),
      )
      .annotate({ identifier: "LaunchTemplateEnaSrdUdpSpecification" }),
  }),
).annotate({
  identifier: "LaunchTemplateEnaSrdSpecification",
}) as any as S.Schema<LaunchTemplateEnaSrdSpecification>;
export interface ConnectionTrackingSpecification {
  TcpEstablishedTimeout?: number;
  UdpTimeout?: number;
  UdpStreamTimeout?: number;
}
export const ConnectionTrackingSpecification = S.suspend(() =>
  S.Struct({
    TcpEstablishedTimeout: S.optional(S.Number).pipe(
      T.XmlName("tcpEstablishedTimeout"),
      T.Ec2QueryName("TcpEstablishedTimeout"),
    ),
    UdpTimeout: S.optional(S.Number).pipe(
      T.XmlName("udpTimeout"),
      T.Ec2QueryName("UdpTimeout"),
    ),
    UdpStreamTimeout: S.optional(S.Number).pipe(
      T.XmlName("udpStreamTimeout"),
      T.Ec2QueryName("UdpStreamTimeout"),
    ),
  }),
).annotate({
  identifier: "ConnectionTrackingSpecification",
}) as any as S.Schema<ConnectionTrackingSpecification>;
export interface LaunchTemplateInstanceNetworkInterfaceSpecification {
  AssociateCarrierIpAddress?: boolean;
  AssociatePublicIpAddress?: boolean;
  DeleteOnTermination?: boolean;
  Description?: string;
  DeviceIndex?: number;
  Groups?: string[];
  InterfaceType?: string;
  Ipv6AddressCount?: number;
  Ipv6Addresses?: InstanceIpv6Address[];
  NetworkInterfaceId?: string;
  PrivateIpAddress?: string;
  PrivateIpAddresses?: PrivateIpAddressSpecification[];
  SecondaryPrivateIpAddressCount?: number;
  SubnetId?: string;
  NetworkCardIndex?: number;
  Ipv4Prefixes?: Ipv4PrefixSpecificationResponse[];
  Ipv4PrefixCount?: number;
  Ipv6Prefixes?: Ipv6PrefixSpecificationResponse[];
  Ipv6PrefixCount?: number;
  PrimaryIpv6?: boolean;
  EnaSrdSpecification?: LaunchTemplateEnaSrdSpecification;
  ConnectionTrackingSpecification?: ConnectionTrackingSpecification;
  EnaQueueCount?: number;
}
export const LaunchTemplateInstanceNetworkInterfaceSpecification = S.suspend(
  () =>
    S.Struct({
      AssociateCarrierIpAddress: S.optional(S.Boolean).pipe(
        T.XmlName("associateCarrierIpAddress"),
        T.Ec2QueryName("AssociateCarrierIpAddress"),
      ),
      AssociatePublicIpAddress: S.optional(S.Boolean).pipe(
        T.XmlName("associatePublicIpAddress"),
        T.Ec2QueryName("AssociatePublicIpAddress"),
      ),
      DeleteOnTermination: S.optional(S.Boolean).pipe(
        T.XmlName("deleteOnTermination"),
        T.Ec2QueryName("DeleteOnTermination"),
      ),
      Description: S.optional(S.String).pipe(
        T.XmlName("description"),
        T.Ec2QueryName("Description"),
      ),
      DeviceIndex: S.optional(S.Number).pipe(
        T.XmlName("deviceIndex"),
        T.Ec2QueryName("DeviceIndex"),
      ),
      Groups: S.optional(GroupIdStringList).pipe(
        T.XmlName("groupSet"),
        T.Ec2QueryName("GroupSet"),
      ),
      InterfaceType: S.optional(S.String).pipe(
        T.XmlName("interfaceType"),
        T.Ec2QueryName("InterfaceType"),
      ),
      Ipv6AddressCount: S.optional(S.Number).pipe(
        T.XmlName("ipv6AddressCount"),
        T.Ec2QueryName("Ipv6AddressCount"),
      ),
      Ipv6Addresses: S.optional(InstanceIpv6AddressList).pipe(
        T.XmlName("ipv6AddressesSet"),
        T.Ec2QueryName("Ipv6AddressesSet"),
      ),
      NetworkInterfaceId: S.optional(S.String).pipe(
        T.XmlName("networkInterfaceId"),
        T.Ec2QueryName("NetworkInterfaceId"),
      ),
      PrivateIpAddress: S.optional(S.String).pipe(
        T.XmlName("privateIpAddress"),
        T.Ec2QueryName("PrivateIpAddress"),
      ),
      PrivateIpAddresses: S.optional(PrivateIpAddressSpecificationList).pipe(
        T.XmlName("privateIpAddressesSet"),
        T.Ec2QueryName("PrivateIpAddressesSet"),
      ),
      SecondaryPrivateIpAddressCount: S.optional(S.Number).pipe(
        T.XmlName("secondaryPrivateIpAddressCount"),
        T.Ec2QueryName("SecondaryPrivateIpAddressCount"),
      ),
      SubnetId: S.optional(S.String).pipe(
        T.XmlName("subnetId"),
        T.Ec2QueryName("SubnetId"),
      ),
      NetworkCardIndex: S.optional(S.Number).pipe(
        T.XmlName("networkCardIndex"),
        T.Ec2QueryName("NetworkCardIndex"),
      ),
      Ipv4Prefixes: S.optional(Ipv4PrefixListResponse).pipe(
        T.XmlName("ipv4PrefixSet"),
        T.Ec2QueryName("Ipv4PrefixSet"),
      ),
      Ipv4PrefixCount: S.optional(S.Number).pipe(
        T.XmlName("ipv4PrefixCount"),
        T.Ec2QueryName("Ipv4PrefixCount"),
      ),
      Ipv6Prefixes: S.optional(Ipv6PrefixListResponse).pipe(
        T.XmlName("ipv6PrefixSet"),
        T.Ec2QueryName("Ipv6PrefixSet"),
      ),
      Ipv6PrefixCount: S.optional(S.Number).pipe(
        T.XmlName("ipv6PrefixCount"),
        T.Ec2QueryName("Ipv6PrefixCount"),
      ),
      PrimaryIpv6: S.optional(S.Boolean).pipe(
        T.XmlName("primaryIpv6"),
        T.Ec2QueryName("PrimaryIpv6"),
      ),
      EnaSrdSpecification: S.optional(LaunchTemplateEnaSrdSpecification)
        .pipe(
          T.XmlName("enaSrdSpecification"),
          T.Ec2QueryName("EnaSrdSpecification"),
        )
        .annotate({ identifier: "LaunchTemplateEnaSrdSpecification" }),
      ConnectionTrackingSpecification: S.optional(
        ConnectionTrackingSpecification,
      )
        .pipe(
          T.XmlName("connectionTrackingSpecification"),
          T.Ec2QueryName("ConnectionTrackingSpecification"),
        )
        .annotate({ identifier: "ConnectionTrackingSpecification" }),
      EnaQueueCount: S.optional(S.Number).pipe(
        T.XmlName("enaQueueCount"),
        T.Ec2QueryName("EnaQueueCount"),
      ),
    }),
).annotate({
  identifier: "LaunchTemplateInstanceNetworkInterfaceSpecification",
}) as any as S.Schema<LaunchTemplateInstanceNetworkInterfaceSpecification>;
export type LaunchTemplateInstanceNetworkInterfaceSpecificationList =
  LaunchTemplateInstanceNetworkInterfaceSpecification[];
export const LaunchTemplateInstanceNetworkInterfaceSpecificationList = S.Array(
  LaunchTemplateInstanceNetworkInterfaceSpecification.pipe(
    T.XmlName("item"),
  ).annotate({
    identifier: "LaunchTemplateInstanceNetworkInterfaceSpecification",
  }),
);
export interface LaunchTemplatesMonitoring {
  Enabled?: boolean;
}
export const LaunchTemplatesMonitoring = S.suspend(() =>
  S.Struct({
    Enabled: S.optional(S.Boolean).pipe(
      T.XmlName("enabled"),
      T.Ec2QueryName("Enabled"),
    ),
  }),
).annotate({
  identifier: "LaunchTemplatesMonitoring",
}) as any as S.Schema<LaunchTemplatesMonitoring>;
export interface LaunchTemplatePlacement {
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  Affinity?: string;
  GroupName?: string;
  HostId?: string;
  Tenancy?: Tenancy;
  SpreadDomain?: string;
  HostResourceGroupArn?: string;
  PartitionNumber?: number;
  GroupId?: string;
}
export const LaunchTemplatePlacement = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    Affinity: S.optional(S.String).pipe(
      T.XmlName("affinity"),
      T.Ec2QueryName("Affinity"),
    ),
    GroupName: S.optional(S.String).pipe(
      T.XmlName("groupName"),
      T.Ec2QueryName("GroupName"),
    ),
    HostId: S.optional(S.String).pipe(
      T.XmlName("hostId"),
      T.Ec2QueryName("HostId"),
    ),
    Tenancy: S.optional(Tenancy).pipe(
      T.XmlName("tenancy"),
      T.Ec2QueryName("Tenancy"),
    ),
    SpreadDomain: S.optional(S.String).pipe(
      T.XmlName("spreadDomain"),
      T.Ec2QueryName("SpreadDomain"),
    ),
    HostResourceGroupArn: S.optional(S.String).pipe(
      T.XmlName("hostResourceGroupArn"),
      T.Ec2QueryName("HostResourceGroupArn"),
    ),
    PartitionNumber: S.optional(S.Number).pipe(
      T.XmlName("partitionNumber"),
      T.Ec2QueryName("PartitionNumber"),
    ),
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
  }),
).annotate({
  identifier: "LaunchTemplatePlacement",
}) as any as S.Schema<LaunchTemplatePlacement>;
export interface LaunchTemplateTagSpecification {
  ResourceType?: ResourceType;
  Tags?: Tag[];
}
export const LaunchTemplateTagSpecification = S.suspend(() =>
  S.Struct({
    ResourceType: S.optional(ResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "LaunchTemplateTagSpecification",
}) as any as S.Schema<LaunchTemplateTagSpecification>;
export type LaunchTemplateTagSpecificationList =
  LaunchTemplateTagSpecification[];
export const LaunchTemplateTagSpecificationList = S.Array(
  LaunchTemplateTagSpecification.pipe(T.XmlName("item")).annotate({
    identifier: "LaunchTemplateTagSpecification",
  }),
);
export interface ElasticGpuSpecificationResponse {
  Type?: string;
}
export const ElasticGpuSpecificationResponse = S.suspend(() =>
  S.Struct({
    Type: S.optional(S.String).pipe(T.XmlName("type"), T.Ec2QueryName("Type")),
  }),
).annotate({
  identifier: "ElasticGpuSpecificationResponse",
}) as any as S.Schema<ElasticGpuSpecificationResponse>;
export type ElasticGpuSpecificationResponseList =
  ElasticGpuSpecificationResponse[];
export const ElasticGpuSpecificationResponseList = S.Array(
  ElasticGpuSpecificationResponse.pipe(T.XmlName("item")).annotate({
    identifier: "ElasticGpuSpecificationResponse",
  }),
);
export interface LaunchTemplateElasticInferenceAcceleratorResponse {
  Type?: string;
  Count?: number;
}
export const LaunchTemplateElasticInferenceAcceleratorResponse = S.suspend(() =>
  S.Struct({
    Type: S.optional(S.String).pipe(T.XmlName("type"), T.Ec2QueryName("Type")),
    Count: S.optional(S.Number).pipe(
      T.XmlName("count"),
      T.Ec2QueryName("Count"),
    ),
  }),
).annotate({
  identifier: "LaunchTemplateElasticInferenceAcceleratorResponse",
}) as any as S.Schema<LaunchTemplateElasticInferenceAcceleratorResponse>;
export type LaunchTemplateElasticInferenceAcceleratorResponseList =
  LaunchTemplateElasticInferenceAcceleratorResponse[];
export const LaunchTemplateElasticInferenceAcceleratorResponseList = S.Array(
  LaunchTemplateElasticInferenceAcceleratorResponse.pipe(
    T.XmlName("item"),
  ).annotate({
    identifier: "LaunchTemplateElasticInferenceAcceleratorResponse",
  }),
);
export interface LaunchTemplateSpotMarketOptions {
  MaxPrice?: string;
  SpotInstanceType?: SpotInstanceType;
  BlockDurationMinutes?: number;
  ValidUntil?: Date;
  InstanceInterruptionBehavior?: InstanceInterruptionBehavior;
}
export const LaunchTemplateSpotMarketOptions = S.suspend(() =>
  S.Struct({
    MaxPrice: S.optional(S.String).pipe(
      T.XmlName("maxPrice"),
      T.Ec2QueryName("MaxPrice"),
    ),
    SpotInstanceType: S.optional(SpotInstanceType).pipe(
      T.XmlName("spotInstanceType"),
      T.Ec2QueryName("SpotInstanceType"),
    ),
    BlockDurationMinutes: S.optional(S.Number).pipe(
      T.XmlName("blockDurationMinutes"),
      T.Ec2QueryName("BlockDurationMinutes"),
    ),
    ValidUntil: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("validUntil"), T.Ec2QueryName("ValidUntil")),
    InstanceInterruptionBehavior: S.optional(InstanceInterruptionBehavior).pipe(
      T.XmlName("instanceInterruptionBehavior"),
      T.Ec2QueryName("InstanceInterruptionBehavior"),
    ),
  }),
).annotate({
  identifier: "LaunchTemplateSpotMarketOptions",
}) as any as S.Schema<LaunchTemplateSpotMarketOptions>;
export interface LaunchTemplateInstanceMarketOptions {
  MarketType?: MarketType;
  SpotOptions?: LaunchTemplateSpotMarketOptions;
}
export const LaunchTemplateInstanceMarketOptions = S.suspend(() =>
  S.Struct({
    MarketType: S.optional(MarketType).pipe(
      T.XmlName("marketType"),
      T.Ec2QueryName("MarketType"),
    ),
    SpotOptions: S.optional(LaunchTemplateSpotMarketOptions)
      .pipe(T.XmlName("spotOptions"), T.Ec2QueryName("SpotOptions"))
      .annotate({ identifier: "LaunchTemplateSpotMarketOptions" }),
  }),
).annotate({
  identifier: "LaunchTemplateInstanceMarketOptions",
}) as any as S.Schema<LaunchTemplateInstanceMarketOptions>;
export interface CreditSpecification {
  CpuCredits?: string;
}
export const CreditSpecification = S.suspend(() =>
  S.Struct({
    CpuCredits: S.optional(S.String).pipe(
      T.XmlName("cpuCredits"),
      T.Ec2QueryName("CpuCredits"),
    ),
  }),
).annotate({
  identifier: "CreditSpecification",
}) as any as S.Schema<CreditSpecification>;
export interface LaunchTemplateCpuOptions {
  CoreCount?: number;
  ThreadsPerCore?: number;
  AmdSevSnp?: AmdSevSnpSpecification;
  NestedVirtualization?: NestedVirtualizationSpecification;
}
export const LaunchTemplateCpuOptions = S.suspend(() =>
  S.Struct({
    CoreCount: S.optional(S.Number).pipe(
      T.XmlName("coreCount"),
      T.Ec2QueryName("CoreCount"),
    ),
    ThreadsPerCore: S.optional(S.Number).pipe(
      T.XmlName("threadsPerCore"),
      T.Ec2QueryName("ThreadsPerCore"),
    ),
    AmdSevSnp: S.optional(AmdSevSnpSpecification).pipe(
      T.XmlName("amdSevSnp"),
      T.Ec2QueryName("AmdSevSnp"),
    ),
    NestedVirtualization: S.optional(NestedVirtualizationSpecification).pipe(
      T.XmlName("nestedVirtualization"),
      T.Ec2QueryName("NestedVirtualization"),
    ),
  }),
).annotate({
  identifier: "LaunchTemplateCpuOptions",
}) as any as S.Schema<LaunchTemplateCpuOptions>;
export interface CapacityReservationTargetResponse {
  CapacityReservationId?: string;
  CapacityReservationResourceGroupArn?: string;
}
export const CapacityReservationTargetResponse = S.suspend(() =>
  S.Struct({
    CapacityReservationId: S.optional(S.String).pipe(
      T.XmlName("capacityReservationId"),
      T.Ec2QueryName("CapacityReservationId"),
    ),
    CapacityReservationResourceGroupArn: S.optional(S.String).pipe(
      T.XmlName("capacityReservationResourceGroupArn"),
      T.Ec2QueryName("CapacityReservationResourceGroupArn"),
    ),
  }),
).annotate({
  identifier: "CapacityReservationTargetResponse",
}) as any as S.Schema<CapacityReservationTargetResponse>;
export interface LaunchTemplateCapacityReservationSpecificationResponse {
  CapacityReservationPreference?: CapacityReservationPreference;
  CapacityReservationTarget?: CapacityReservationTargetResponse;
}
export const LaunchTemplateCapacityReservationSpecificationResponse = S.suspend(
  () =>
    S.Struct({
      CapacityReservationPreference: S.optional(
        CapacityReservationPreference,
      ).pipe(
        T.XmlName("capacityReservationPreference"),
        T.Ec2QueryName("CapacityReservationPreference"),
      ),
      CapacityReservationTarget: S.optional(CapacityReservationTargetResponse)
        .pipe(
          T.XmlName("capacityReservationTarget"),
          T.Ec2QueryName("CapacityReservationTarget"),
        )
        .annotate({ identifier: "CapacityReservationTargetResponse" }),
    }),
).annotate({
  identifier: "LaunchTemplateCapacityReservationSpecificationResponse",
}) as any as S.Schema<LaunchTemplateCapacityReservationSpecificationResponse>;
export interface LaunchTemplateLicenseConfiguration {
  LicenseConfigurationArn?: string;
}
export const LaunchTemplateLicenseConfiguration = S.suspend(() =>
  S.Struct({
    LicenseConfigurationArn: S.optional(S.String).pipe(
      T.XmlName("licenseConfigurationArn"),
      T.Ec2QueryName("LicenseConfigurationArn"),
    ),
  }),
).annotate({
  identifier: "LaunchTemplateLicenseConfiguration",
}) as any as S.Schema<LaunchTemplateLicenseConfiguration>;
export type LaunchTemplateLicenseList = LaunchTemplateLicenseConfiguration[];
export const LaunchTemplateLicenseList = S.Array(
  LaunchTemplateLicenseConfiguration.pipe(T.XmlName("item")).annotate({
    identifier: "LaunchTemplateLicenseConfiguration",
  }),
);
export interface LaunchTemplateHibernationOptions {
  Configured?: boolean;
}
export const LaunchTemplateHibernationOptions = S.suspend(() =>
  S.Struct({
    Configured: S.optional(S.Boolean).pipe(
      T.XmlName("configured"),
      T.Ec2QueryName("Configured"),
    ),
  }),
).annotate({
  identifier: "LaunchTemplateHibernationOptions",
}) as any as S.Schema<LaunchTemplateHibernationOptions>;
export type LaunchTemplateInstanceMetadataOptionsState =
  | "pending"
  | "applied"
  | (string & {});
export const LaunchTemplateInstanceMetadataOptionsState = S.String;
export interface LaunchTemplateInstanceMetadataOptions {
  State?: LaunchTemplateInstanceMetadataOptionsState;
  HttpTokens?: LaunchTemplateHttpTokensState;
  HttpPutResponseHopLimit?: number;
  HttpEndpoint?: LaunchTemplateInstanceMetadataEndpointState;
  HttpProtocolIpv6?: LaunchTemplateInstanceMetadataProtocolIpv6;
  InstanceMetadataTags?: LaunchTemplateInstanceMetadataTagsState;
}
export const LaunchTemplateInstanceMetadataOptions = S.suspend(() =>
  S.Struct({
    State: S.optional(LaunchTemplateInstanceMetadataOptionsState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    HttpTokens: S.optional(LaunchTemplateHttpTokensState).pipe(
      T.XmlName("httpTokens"),
      T.Ec2QueryName("HttpTokens"),
    ),
    HttpPutResponseHopLimit: S.optional(S.Number).pipe(
      T.XmlName("httpPutResponseHopLimit"),
      T.Ec2QueryName("HttpPutResponseHopLimit"),
    ),
    HttpEndpoint: S.optional(LaunchTemplateInstanceMetadataEndpointState).pipe(
      T.XmlName("httpEndpoint"),
      T.Ec2QueryName("HttpEndpoint"),
    ),
    HttpProtocolIpv6: S.optional(
      LaunchTemplateInstanceMetadataProtocolIpv6,
    ).pipe(T.XmlName("httpProtocolIpv6"), T.Ec2QueryName("HttpProtocolIpv6")),
    InstanceMetadataTags: S.optional(
      LaunchTemplateInstanceMetadataTagsState,
    ).pipe(
      T.XmlName("instanceMetadataTags"),
      T.Ec2QueryName("InstanceMetadataTags"),
    ),
  }),
).annotate({
  identifier: "LaunchTemplateInstanceMetadataOptions",
}) as any as S.Schema<LaunchTemplateInstanceMetadataOptions>;
export interface LaunchTemplateEnclaveOptions {
  Enabled?: boolean;
}
export const LaunchTemplateEnclaveOptions = S.suspend(() =>
  S.Struct({
    Enabled: S.optional(S.Boolean).pipe(
      T.XmlName("enabled"),
      T.Ec2QueryName("Enabled"),
    ),
  }),
).annotate({
  identifier: "LaunchTemplateEnclaveOptions",
}) as any as S.Schema<LaunchTemplateEnclaveOptions>;
export interface LaunchTemplatePrivateDnsNameOptions {
  HostnameType?: HostnameType;
  EnableResourceNameDnsARecord?: boolean;
  EnableResourceNameDnsAAAARecord?: boolean;
}
export const LaunchTemplatePrivateDnsNameOptions = S.suspend(() =>
  S.Struct({
    HostnameType: S.optional(HostnameType).pipe(
      T.XmlName("hostnameType"),
      T.Ec2QueryName("HostnameType"),
    ),
    EnableResourceNameDnsARecord: S.optional(S.Boolean).pipe(
      T.XmlName("enableResourceNameDnsARecord"),
      T.Ec2QueryName("EnableResourceNameDnsARecord"),
    ),
    EnableResourceNameDnsAAAARecord: S.optional(S.Boolean).pipe(
      T.XmlName("enableResourceNameDnsAAAARecord"),
      T.Ec2QueryName("EnableResourceNameDnsAAAARecord"),
    ),
  }),
).annotate({
  identifier: "LaunchTemplatePrivateDnsNameOptions",
}) as any as S.Schema<LaunchTemplatePrivateDnsNameOptions>;
export interface LaunchTemplateInstanceMaintenanceOptions {
  AutoRecovery?: LaunchTemplateAutoRecoveryState;
}
export const LaunchTemplateInstanceMaintenanceOptions = S.suspend(() =>
  S.Struct({
    AutoRecovery: S.optional(LaunchTemplateAutoRecoveryState).pipe(
      T.XmlName("autoRecovery"),
      T.Ec2QueryName("AutoRecovery"),
    ),
  }),
).annotate({
  identifier: "LaunchTemplateInstanceMaintenanceOptions",
}) as any as S.Schema<LaunchTemplateInstanceMaintenanceOptions>;
export interface LaunchTemplateNetworkPerformanceOptions {
  BandwidthWeighting?: InstanceBandwidthWeighting;
}
export const LaunchTemplateNetworkPerformanceOptions = S.suspend(() =>
  S.Struct({
    BandwidthWeighting: S.optional(InstanceBandwidthWeighting).pipe(
      T.XmlName("bandwidthWeighting"),
      T.Ec2QueryName("BandwidthWeighting"),
    ),
  }),
).annotate({
  identifier: "LaunchTemplateNetworkPerformanceOptions",
}) as any as S.Schema<LaunchTemplateNetworkPerformanceOptions>;
export interface SecondaryInterfacePrivateIpAddressSpecification {
  PrivateIpAddress?: string;
}
export const SecondaryInterfacePrivateIpAddressSpecification = S.suspend(() =>
  S.Struct({
    PrivateIpAddress: S.optional(S.String).pipe(
      T.XmlName("privateIpAddress"),
      T.Ec2QueryName("PrivateIpAddress"),
    ),
  }),
).annotate({
  identifier: "SecondaryInterfacePrivateIpAddressSpecification",
}) as any as S.Schema<SecondaryInterfacePrivateIpAddressSpecification>;
export type SecondaryInterfacePrivateIpAddressSpecificationList =
  SecondaryInterfacePrivateIpAddressSpecification[];
export const SecondaryInterfacePrivateIpAddressSpecificationList = S.Array(
  SecondaryInterfacePrivateIpAddressSpecification.pipe(
    T.XmlName("item"),
  ).annotate({ identifier: "SecondaryInterfacePrivateIpAddressSpecification" }),
);
export interface LaunchTemplateInstanceSecondaryInterfaceSpecification {
  DeleteOnTermination?: boolean;
  DeviceIndex?: number;
  PrivateIpAddresses?: SecondaryInterfacePrivateIpAddressSpecification[];
  PrivateIpAddressCount?: number;
  SecondarySubnetId?: string;
  InterfaceType?: SecondaryInterfaceType;
  NetworkCardIndex?: number;
}
export const LaunchTemplateInstanceSecondaryInterfaceSpecification = S.suspend(
  () =>
    S.Struct({
      DeleteOnTermination: S.optional(S.Boolean).pipe(
        T.XmlName("deleteOnTermination"),
        T.Ec2QueryName("DeleteOnTermination"),
      ),
      DeviceIndex: S.optional(S.Number).pipe(
        T.XmlName("deviceIndex"),
        T.Ec2QueryName("DeviceIndex"),
      ),
      PrivateIpAddresses: S.optional(
        SecondaryInterfacePrivateIpAddressSpecificationList,
      ).pipe(
        T.XmlName("privateIpAddressesSet"),
        T.Ec2QueryName("PrivateIpAddressesSet"),
      ),
      PrivateIpAddressCount: S.optional(S.Number).pipe(
        T.XmlName("privateIpAddressCount"),
        T.Ec2QueryName("PrivateIpAddressCount"),
      ),
      SecondarySubnetId: S.optional(S.String).pipe(
        T.XmlName("secondarySubnetId"),
        T.Ec2QueryName("SecondarySubnetId"),
      ),
      InterfaceType: S.optional(SecondaryInterfaceType).pipe(
        T.XmlName("interfaceType"),
        T.Ec2QueryName("InterfaceType"),
      ),
      NetworkCardIndex: S.optional(S.Number).pipe(
        T.XmlName("networkCardIndex"),
        T.Ec2QueryName("NetworkCardIndex"),
      ),
    }),
).annotate({
  identifier: "LaunchTemplateInstanceSecondaryInterfaceSpecification",
}) as any as S.Schema<LaunchTemplateInstanceSecondaryInterfaceSpecification>;
export type LaunchTemplateInstanceSecondaryInterfaceSpecificationList =
  LaunchTemplateInstanceSecondaryInterfaceSpecification[];
export const LaunchTemplateInstanceSecondaryInterfaceSpecificationList =
  S.Array(
    LaunchTemplateInstanceSecondaryInterfaceSpecification.pipe(
      T.XmlName("item"),
    ).annotate({
      identifier: "LaunchTemplateInstanceSecondaryInterfaceSpecification",
    }),
  );
export interface ResponseLaunchTemplateData {
  KernelId?: string;
  EbsOptimized?: boolean;
  IamInstanceProfile?: LaunchTemplateIamInstanceProfileSpecification;
  BlockDeviceMappings?: LaunchTemplateBlockDeviceMapping[];
  NetworkInterfaces?: LaunchTemplateInstanceNetworkInterfaceSpecification[];
  ImageId?: string;
  InstanceType?: InstanceType;
  KeyName?: string;
  Monitoring?: LaunchTemplatesMonitoring;
  Placement?: LaunchTemplatePlacement;
  RamDiskId?: string;
  DisableApiTermination?: boolean;
  InstanceInitiatedShutdownBehavior?: ShutdownBehavior;
  UserData?: string | redacted.Redacted<string>;
  TagSpecifications?: LaunchTemplateTagSpecification[];
  ElasticGpuSpecifications?: ElasticGpuSpecificationResponse[];
  ElasticInferenceAccelerators?: LaunchTemplateElasticInferenceAcceleratorResponse[];
  SecurityGroupIds?: string[];
  SecurityGroups?: string[];
  InstanceMarketOptions?: LaunchTemplateInstanceMarketOptions;
  CreditSpecification?: CreditSpecification;
  CpuOptions?: LaunchTemplateCpuOptions;
  CapacityReservationSpecification?: LaunchTemplateCapacityReservationSpecificationResponse;
  LicenseSpecifications?: LaunchTemplateLicenseConfiguration[];
  HibernationOptions?: LaunchTemplateHibernationOptions;
  MetadataOptions?: LaunchTemplateInstanceMetadataOptions;
  EnclaveOptions?: LaunchTemplateEnclaveOptions;
  InstanceRequirements?: InstanceRequirements;
  PrivateDnsNameOptions?: LaunchTemplatePrivateDnsNameOptions;
  MaintenanceOptions?: LaunchTemplateInstanceMaintenanceOptions;
  DisableApiStop?: boolean;
  Operator?: OperatorResponse;
  NetworkPerformanceOptions?: LaunchTemplateNetworkPerformanceOptions;
  SecondaryInterfaces?: LaunchTemplateInstanceSecondaryInterfaceSpecification[];
}
export const ResponseLaunchTemplateData = S.suspend(() =>
  S.Struct({
    KernelId: S.optional(S.String).pipe(
      T.XmlName("kernelId"),
      T.Ec2QueryName("KernelId"),
    ),
    EbsOptimized: S.optional(S.Boolean).pipe(
      T.XmlName("ebsOptimized"),
      T.Ec2QueryName("EbsOptimized"),
    ),
    IamInstanceProfile: S.optional(
      LaunchTemplateIamInstanceProfileSpecification,
    )
      .pipe(
        T.XmlName("iamInstanceProfile"),
        T.Ec2QueryName("IamInstanceProfile"),
      )
      .annotate({
        identifier: "LaunchTemplateIamInstanceProfileSpecification",
      }),
    BlockDeviceMappings: S.optional(LaunchTemplateBlockDeviceMappingList).pipe(
      T.XmlName("blockDeviceMappingSet"),
      T.Ec2QueryName("BlockDeviceMappingSet"),
    ),
    NetworkInterfaces: S.optional(
      LaunchTemplateInstanceNetworkInterfaceSpecificationList,
    ).pipe(
      T.XmlName("networkInterfaceSet"),
      T.Ec2QueryName("NetworkInterfaceSet"),
    ),
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    InstanceType: S.optional(InstanceType).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    KeyName: S.optional(S.String).pipe(
      T.XmlName("keyName"),
      T.Ec2QueryName("KeyName"),
    ),
    Monitoring: S.optional(LaunchTemplatesMonitoring)
      .pipe(T.XmlName("monitoring"), T.Ec2QueryName("Monitoring"))
      .annotate({ identifier: "LaunchTemplatesMonitoring" }),
    Placement: S.optional(LaunchTemplatePlacement)
      .pipe(T.XmlName("placement"), T.Ec2QueryName("Placement"))
      .annotate({ identifier: "LaunchTemplatePlacement" }),
    RamDiskId: S.optional(S.String).pipe(
      T.XmlName("ramDiskId"),
      T.Ec2QueryName("RamDiskId"),
    ),
    DisableApiTermination: S.optional(S.Boolean).pipe(
      T.XmlName("disableApiTermination"),
      T.Ec2QueryName("DisableApiTermination"),
    ),
    InstanceInitiatedShutdownBehavior: S.optional(ShutdownBehavior).pipe(
      T.XmlName("instanceInitiatedShutdownBehavior"),
      T.Ec2QueryName("InstanceInitiatedShutdownBehavior"),
    ),
    UserData: S.optional(SensitiveString).pipe(
      T.XmlName("userData"),
      T.Ec2QueryName("UserData"),
    ),
    TagSpecifications: S.optional(LaunchTemplateTagSpecificationList).pipe(
      T.XmlName("tagSpecificationSet"),
      T.Ec2QueryName("TagSpecificationSet"),
    ),
    ElasticGpuSpecifications: S.optional(
      ElasticGpuSpecificationResponseList,
    ).pipe(
      T.XmlName("elasticGpuSpecificationSet"),
      T.Ec2QueryName("ElasticGpuSpecificationSet"),
    ),
    ElasticInferenceAccelerators: S.optional(
      LaunchTemplateElasticInferenceAcceleratorResponseList,
    ).pipe(
      T.XmlName("elasticInferenceAcceleratorSet"),
      T.Ec2QueryName("ElasticInferenceAcceleratorSet"),
    ),
    SecurityGroupIds: S.optional(ValueStringList).pipe(
      T.XmlName("securityGroupIdSet"),
      T.Ec2QueryName("SecurityGroupIdSet"),
    ),
    SecurityGroups: S.optional(ValueStringList).pipe(
      T.XmlName("securityGroupSet"),
      T.Ec2QueryName("SecurityGroupSet"),
    ),
    InstanceMarketOptions: S.optional(LaunchTemplateInstanceMarketOptions)
      .pipe(
        T.XmlName("instanceMarketOptions"),
        T.Ec2QueryName("InstanceMarketOptions"),
      )
      .annotate({ identifier: "LaunchTemplateInstanceMarketOptions" }),
    CreditSpecification: S.optional(CreditSpecification)
      .pipe(
        T.XmlName("creditSpecification"),
        T.Ec2QueryName("CreditSpecification"),
      )
      .annotate({ identifier: "CreditSpecification" }),
    CpuOptions: S.optional(LaunchTemplateCpuOptions)
      .pipe(T.XmlName("cpuOptions"), T.Ec2QueryName("CpuOptions"))
      .annotate({ identifier: "LaunchTemplateCpuOptions" }),
    CapacityReservationSpecification: S.optional(
      LaunchTemplateCapacityReservationSpecificationResponse,
    )
      .pipe(
        T.XmlName("capacityReservationSpecification"),
        T.Ec2QueryName("CapacityReservationSpecification"),
      )
      .annotate({
        identifier: "LaunchTemplateCapacityReservationSpecificationResponse",
      }),
    LicenseSpecifications: S.optional(LaunchTemplateLicenseList).pipe(
      T.XmlName("licenseSet"),
      T.Ec2QueryName("LicenseSet"),
    ),
    HibernationOptions: S.optional(LaunchTemplateHibernationOptions)
      .pipe(
        T.XmlName("hibernationOptions"),
        T.Ec2QueryName("HibernationOptions"),
      )
      .annotate({ identifier: "LaunchTemplateHibernationOptions" }),
    MetadataOptions: S.optional(LaunchTemplateInstanceMetadataOptions)
      .pipe(T.XmlName("metadataOptions"), T.Ec2QueryName("MetadataOptions"))
      .annotate({ identifier: "LaunchTemplateInstanceMetadataOptions" }),
    EnclaveOptions: S.optional(LaunchTemplateEnclaveOptions)
      .pipe(T.XmlName("enclaveOptions"), T.Ec2QueryName("EnclaveOptions"))
      .annotate({ identifier: "LaunchTemplateEnclaveOptions" }),
    InstanceRequirements: S.optional(InstanceRequirements)
      .pipe(
        T.XmlName("instanceRequirements"),
        T.Ec2QueryName("InstanceRequirements"),
      )
      .annotate({ identifier: "InstanceRequirements" }),
    PrivateDnsNameOptions: S.optional(LaunchTemplatePrivateDnsNameOptions)
      .pipe(
        T.XmlName("privateDnsNameOptions"),
        T.Ec2QueryName("PrivateDnsNameOptions"),
      )
      .annotate({ identifier: "LaunchTemplatePrivateDnsNameOptions" }),
    MaintenanceOptions: S.optional(LaunchTemplateInstanceMaintenanceOptions)
      .pipe(
        T.XmlName("maintenanceOptions"),
        T.Ec2QueryName("MaintenanceOptions"),
      )
      .annotate({ identifier: "LaunchTemplateInstanceMaintenanceOptions" }),
    DisableApiStop: S.optional(S.Boolean).pipe(
      T.XmlName("disableApiStop"),
      T.Ec2QueryName("DisableApiStop"),
    ),
    Operator: S.optional(OperatorResponse)
      .pipe(T.XmlName("operator"), T.Ec2QueryName("Operator"))
      .annotate({ identifier: "OperatorResponse" }),
    NetworkPerformanceOptions: S.optional(
      LaunchTemplateNetworkPerformanceOptions,
    )
      .pipe(
        T.XmlName("networkPerformanceOptions"),
        T.Ec2QueryName("NetworkPerformanceOptions"),
      )
      .annotate({ identifier: "LaunchTemplateNetworkPerformanceOptions" }),
    SecondaryInterfaces: S.optional(
      LaunchTemplateInstanceSecondaryInterfaceSpecificationList,
    ).pipe(
      T.XmlName("secondaryInterfaceSet"),
      T.Ec2QueryName("SecondaryInterfaceSet"),
    ),
  }),
).annotate({
  identifier: "ResponseLaunchTemplateData",
}) as any as S.Schema<ResponseLaunchTemplateData>;
export interface LaunchTemplateVersion {
  LaunchTemplateId?: string;
  LaunchTemplateName?: string;
  VersionNumber?: number;
  VersionDescription?: string;
  CreateTime?: Date;
  CreatedBy?: string;
  DefaultVersion?: boolean;
  LaunchTemplateData?: ResponseLaunchTemplateData;
  Operator?: OperatorResponse;
}
export const LaunchTemplateVersion = S.suspend(() =>
  S.Struct({
    LaunchTemplateId: S.optional(S.String).pipe(
      T.XmlName("launchTemplateId"),
      T.Ec2QueryName("LaunchTemplateId"),
    ),
    LaunchTemplateName: S.optional(S.String).pipe(
      T.XmlName("launchTemplateName"),
      T.Ec2QueryName("LaunchTemplateName"),
    ),
    VersionNumber: S.optional(S.Number).pipe(
      T.XmlName("versionNumber"),
      T.Ec2QueryName("VersionNumber"),
    ),
    VersionDescription: S.optional(S.String).pipe(
      T.XmlName("versionDescription"),
      T.Ec2QueryName("VersionDescription"),
    ),
    CreateTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createTime"), T.Ec2QueryName("CreateTime")),
    CreatedBy: S.optional(S.String).pipe(
      T.XmlName("createdBy"),
      T.Ec2QueryName("CreatedBy"),
    ),
    DefaultVersion: S.optional(S.Boolean).pipe(
      T.XmlName("defaultVersion"),
      T.Ec2QueryName("DefaultVersion"),
    ),
    LaunchTemplateData: S.optional(ResponseLaunchTemplateData)
      .pipe(
        T.XmlName("launchTemplateData"),
        T.Ec2QueryName("LaunchTemplateData"),
      )
      .annotate({ identifier: "ResponseLaunchTemplateData" }),
    Operator: S.optional(OperatorResponse)
      .pipe(T.XmlName("operator"), T.Ec2QueryName("Operator"))
      .annotate({ identifier: "OperatorResponse" }),
  }),
).annotate({
  identifier: "LaunchTemplateVersion",
}) as any as S.Schema<LaunchTemplateVersion>;
export interface CreateLaunchTemplateVersionResult {
  LaunchTemplateVersion?: LaunchTemplateVersion;
  Warning?: ValidationWarning;
}
export const CreateLaunchTemplateVersionResult = S.suspend(() =>
  S.Struct({
    LaunchTemplateVersion: S.optional(LaunchTemplateVersion)
      .pipe(
        T.XmlName("launchTemplateVersion"),
        T.Ec2QueryName("LaunchTemplateVersion"),
      )
      .annotate({ identifier: "LaunchTemplateVersion" }),
    Warning: S.optional(ValidationWarning)
      .pipe(T.XmlName("warning"), T.Ec2QueryName("Warning"))
      .annotate({ identifier: "ValidationWarning" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateLaunchTemplateVersionResult",
}) as any as S.Schema<CreateLaunchTemplateVersionResult>;
export interface CreateLocalGatewayRouteRequest {
  DestinationCidrBlock?: string;
  LocalGatewayRouteTableId?: string;
  LocalGatewayVirtualInterfaceGroupId?: string;
  DryRun?: boolean;
  NetworkInterfaceId?: string;
  DestinationPrefixListId?: string;
}
export const CreateLocalGatewayRouteRequest = S.suspend(() =>
  S.Struct({
    DestinationCidrBlock: S.optional(S.String),
    LocalGatewayRouteTableId: S.optional(S.String),
    LocalGatewayVirtualInterfaceGroupId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    NetworkInterfaceId: S.optional(S.String),
    DestinationPrefixListId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateLocalGatewayRouteRequest",
}) as any as S.Schema<CreateLocalGatewayRouteRequest>;
export type LocalGatewayRouteType = "static" | "propagated" | (string & {});
export const LocalGatewayRouteType = S.String;
export type LocalGatewayRouteState =
  | "pending"
  | "active"
  | "blackhole"
  | "deleting"
  | "deleted"
  | (string & {});
export const LocalGatewayRouteState = S.String;
export interface LocalGatewayRoute {
  DestinationCidrBlock?: string;
  LocalGatewayVirtualInterfaceGroupId?: string;
  Type?: LocalGatewayRouteType;
  State?: LocalGatewayRouteState;
  LocalGatewayRouteTableId?: string;
  LocalGatewayRouteTableArn?: string;
  OwnerId?: string;
  SubnetId?: string;
  CoipPoolId?: string;
  NetworkInterfaceId?: string;
  DestinationPrefixListId?: string;
}
export const LocalGatewayRoute = S.suspend(() =>
  S.Struct({
    DestinationCidrBlock: S.optional(S.String).pipe(
      T.XmlName("destinationCidrBlock"),
      T.Ec2QueryName("DestinationCidrBlock"),
    ),
    LocalGatewayVirtualInterfaceGroupId: S.optional(S.String).pipe(
      T.XmlName("localGatewayVirtualInterfaceGroupId"),
      T.Ec2QueryName("LocalGatewayVirtualInterfaceGroupId"),
    ),
    Type: S.optional(LocalGatewayRouteType).pipe(
      T.XmlName("type"),
      T.Ec2QueryName("Type"),
    ),
    State: S.optional(LocalGatewayRouteState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    LocalGatewayRouteTableId: S.optional(S.String).pipe(
      T.XmlName("localGatewayRouteTableId"),
      T.Ec2QueryName("LocalGatewayRouteTableId"),
    ),
    LocalGatewayRouteTableArn: S.optional(S.String).pipe(
      T.XmlName("localGatewayRouteTableArn"),
      T.Ec2QueryName("LocalGatewayRouteTableArn"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    CoipPoolId: S.optional(S.String).pipe(
      T.XmlName("coipPoolId"),
      T.Ec2QueryName("CoipPoolId"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    DestinationPrefixListId: S.optional(S.String).pipe(
      T.XmlName("destinationPrefixListId"),
      T.Ec2QueryName("DestinationPrefixListId"),
    ),
  }),
).annotate({
  identifier: "LocalGatewayRoute",
}) as any as S.Schema<LocalGatewayRoute>;
export interface CreateLocalGatewayRouteResult {
  Route?: LocalGatewayRoute;
}
export const CreateLocalGatewayRouteResult = S.suspend(() =>
  S.Struct({
    Route: S.optional(LocalGatewayRoute)
      .pipe(T.XmlName("route"), T.Ec2QueryName("Route"))
      .annotate({ identifier: "LocalGatewayRoute" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateLocalGatewayRouteResult",
}) as any as S.Schema<CreateLocalGatewayRouteResult>;
export type LocalGatewayRouteTableMode =
  | "direct-vpc-routing"
  | "coip"
  | (string & {});
export const LocalGatewayRouteTableMode = S.String;
export interface CreateLocalGatewayRouteTableRequest {
  LocalGatewayId?: string;
  Mode?: LocalGatewayRouteTableMode;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateLocalGatewayRouteTableRequest = S.suspend(() =>
  S.Struct({
    LocalGatewayId: S.optional(S.String),
    Mode: S.optional(LocalGatewayRouteTableMode),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateLocalGatewayRouteTableRequest",
}) as any as S.Schema<CreateLocalGatewayRouteTableRequest>;
export interface StateReason {
  Code?: string;
  Message?: string;
}
export const StateReason = S.suspend(() =>
  S.Struct({
    Code: S.optional(S.String).pipe(T.XmlName("code"), T.Ec2QueryName("Code")),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({ identifier: "StateReason" }) as any as S.Schema<StateReason>;
export interface LocalGatewayRouteTable {
  LocalGatewayRouteTableId?: string;
  LocalGatewayRouteTableArn?: string;
  LocalGatewayId?: string;
  OutpostArn?: string;
  OwnerId?: string;
  State?: string;
  Tags?: Tag[];
  Mode?: LocalGatewayRouteTableMode;
  StateReason?: StateReason;
}
export const LocalGatewayRouteTable = S.suspend(() =>
  S.Struct({
    LocalGatewayRouteTableId: S.optional(S.String).pipe(
      T.XmlName("localGatewayRouteTableId"),
      T.Ec2QueryName("LocalGatewayRouteTableId"),
    ),
    LocalGatewayRouteTableArn: S.optional(S.String).pipe(
      T.XmlName("localGatewayRouteTableArn"),
      T.Ec2QueryName("LocalGatewayRouteTableArn"),
    ),
    LocalGatewayId: S.optional(S.String).pipe(
      T.XmlName("localGatewayId"),
      T.Ec2QueryName("LocalGatewayId"),
    ),
    OutpostArn: S.optional(S.String).pipe(
      T.XmlName("outpostArn"),
      T.Ec2QueryName("OutpostArn"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    State: S.optional(S.String).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    Mode: S.optional(LocalGatewayRouteTableMode).pipe(
      T.XmlName("mode"),
      T.Ec2QueryName("Mode"),
    ),
    StateReason: S.optional(StateReason)
      .pipe(T.XmlName("stateReason"), T.Ec2QueryName("StateReason"))
      .annotate({ identifier: "StateReason" }),
  }),
).annotate({
  identifier: "LocalGatewayRouteTable",
}) as any as S.Schema<LocalGatewayRouteTable>;
export interface CreateLocalGatewayRouteTableResult {
  LocalGatewayRouteTable?: LocalGatewayRouteTable;
}
export const CreateLocalGatewayRouteTableResult = S.suspend(() =>
  S.Struct({
    LocalGatewayRouteTable: S.optional(LocalGatewayRouteTable)
      .pipe(
        T.XmlName("localGatewayRouteTable"),
        T.Ec2QueryName("LocalGatewayRouteTable"),
      )
      .annotate({ identifier: "LocalGatewayRouteTable" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateLocalGatewayRouteTableResult",
}) as any as S.Schema<CreateLocalGatewayRouteTableResult>;
export interface CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest {
  LocalGatewayRouteTableId?: string;
  LocalGatewayVirtualInterfaceGroupId?: string;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest =
  S.suspend(() =>
    S.Struct({
      LocalGatewayRouteTableId: S.optional(S.String),
      LocalGatewayVirtualInterfaceGroupId: S.optional(S.String),
      TagSpecifications: S.optional(TagSpecificationList).pipe(
        T.XmlName("TagSpecification"),
      ),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
  ).annotate({
    identifier:
      "CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest",
  }) as any as S.Schema<CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest>;
export interface LocalGatewayRouteTableVirtualInterfaceGroupAssociation {
  LocalGatewayRouteTableVirtualInterfaceGroupAssociationId?: string;
  LocalGatewayVirtualInterfaceGroupId?: string;
  LocalGatewayId?: string;
  LocalGatewayRouteTableId?: string;
  LocalGatewayRouteTableArn?: string;
  OwnerId?: string;
  State?: string;
  Tags?: Tag[];
}
export const LocalGatewayRouteTableVirtualInterfaceGroupAssociation = S.suspend(
  () =>
    S.Struct({
      LocalGatewayRouteTableVirtualInterfaceGroupAssociationId: S.optional(
        S.String,
      ).pipe(
        T.XmlName("localGatewayRouteTableVirtualInterfaceGroupAssociationId"),
        T.Ec2QueryName(
          "LocalGatewayRouteTableVirtualInterfaceGroupAssociationId",
        ),
      ),
      LocalGatewayVirtualInterfaceGroupId: S.optional(S.String).pipe(
        T.XmlName("localGatewayVirtualInterfaceGroupId"),
        T.Ec2QueryName("LocalGatewayVirtualInterfaceGroupId"),
      ),
      LocalGatewayId: S.optional(S.String).pipe(
        T.XmlName("localGatewayId"),
        T.Ec2QueryName("LocalGatewayId"),
      ),
      LocalGatewayRouteTableId: S.optional(S.String).pipe(
        T.XmlName("localGatewayRouteTableId"),
        T.Ec2QueryName("LocalGatewayRouteTableId"),
      ),
      LocalGatewayRouteTableArn: S.optional(S.String).pipe(
        T.XmlName("localGatewayRouteTableArn"),
        T.Ec2QueryName("LocalGatewayRouteTableArn"),
      ),
      OwnerId: S.optional(S.String).pipe(
        T.XmlName("ownerId"),
        T.Ec2QueryName("OwnerId"),
      ),
      State: S.optional(S.String).pipe(
        T.XmlName("state"),
        T.Ec2QueryName("State"),
      ),
      Tags: S.optional(TagList).pipe(
        T.XmlName("tagSet"),
        T.Ec2QueryName("TagSet"),
      ),
    }),
).annotate({
  identifier: "LocalGatewayRouteTableVirtualInterfaceGroupAssociation",
}) as any as S.Schema<LocalGatewayRouteTableVirtualInterfaceGroupAssociation>;
export interface CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult {
  LocalGatewayRouteTableVirtualInterfaceGroupAssociation?: LocalGatewayRouteTableVirtualInterfaceGroupAssociation;
}
export const CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult =
  S.suspend(() =>
    S.Struct({
      LocalGatewayRouteTableVirtualInterfaceGroupAssociation: S.optional(
        LocalGatewayRouteTableVirtualInterfaceGroupAssociation,
      )
        .pipe(
          T.XmlName("localGatewayRouteTableVirtualInterfaceGroupAssociation"),
          T.Ec2QueryName(
            "LocalGatewayRouteTableVirtualInterfaceGroupAssociation",
          ),
        )
        .annotate({
          identifier: "LocalGatewayRouteTableVirtualInterfaceGroupAssociation",
        }),
    }).pipe(ns),
  ).annotate({
    identifier:
      "CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult",
  }) as any as S.Schema<CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult>;
export interface CreateLocalGatewayRouteTableVpcAssociationRequest {
  LocalGatewayRouteTableId?: string;
  VpcId?: string;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateLocalGatewayRouteTableVpcAssociationRequest = S.suspend(() =>
  S.Struct({
    LocalGatewayRouteTableId: S.optional(S.String),
    VpcId: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateLocalGatewayRouteTableVpcAssociationRequest",
}) as any as S.Schema<CreateLocalGatewayRouteTableVpcAssociationRequest>;
export interface LocalGatewayRouteTableVpcAssociation {
  LocalGatewayRouteTableVpcAssociationId?: string;
  LocalGatewayRouteTableId?: string;
  LocalGatewayRouteTableArn?: string;
  LocalGatewayId?: string;
  VpcId?: string;
  OwnerId?: string;
  State?: string;
  Tags?: Tag[];
}
export const LocalGatewayRouteTableVpcAssociation = S.suspend(() =>
  S.Struct({
    LocalGatewayRouteTableVpcAssociationId: S.optional(S.String).pipe(
      T.XmlName("localGatewayRouteTableVpcAssociationId"),
      T.Ec2QueryName("LocalGatewayRouteTableVpcAssociationId"),
    ),
    LocalGatewayRouteTableId: S.optional(S.String).pipe(
      T.XmlName("localGatewayRouteTableId"),
      T.Ec2QueryName("LocalGatewayRouteTableId"),
    ),
    LocalGatewayRouteTableArn: S.optional(S.String).pipe(
      T.XmlName("localGatewayRouteTableArn"),
      T.Ec2QueryName("LocalGatewayRouteTableArn"),
    ),
    LocalGatewayId: S.optional(S.String).pipe(
      T.XmlName("localGatewayId"),
      T.Ec2QueryName("LocalGatewayId"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    State: S.optional(S.String).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "LocalGatewayRouteTableVpcAssociation",
}) as any as S.Schema<LocalGatewayRouteTableVpcAssociation>;
export interface CreateLocalGatewayRouteTableVpcAssociationResult {
  LocalGatewayRouteTableVpcAssociation?: LocalGatewayRouteTableVpcAssociation;
}
export const CreateLocalGatewayRouteTableVpcAssociationResult = S.suspend(() =>
  S.Struct({
    LocalGatewayRouteTableVpcAssociation: S.optional(
      LocalGatewayRouteTableVpcAssociation,
    )
      .pipe(
        T.XmlName("localGatewayRouteTableVpcAssociation"),
        T.Ec2QueryName("LocalGatewayRouteTableVpcAssociation"),
      )
      .annotate({ identifier: "LocalGatewayRouteTableVpcAssociation" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateLocalGatewayRouteTableVpcAssociationResult",
}) as any as S.Schema<CreateLocalGatewayRouteTableVpcAssociationResult>;
export interface CreateLocalGatewayVirtualInterfaceRequest {
  LocalGatewayVirtualInterfaceGroupId?: string;
  OutpostLagId?: string;
  Vlan?: number;
  LocalAddress?: string;
  PeerAddress?: string;
  PeerBgpAsn?: number;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
  PeerBgpAsnExtended?: number;
}
export const CreateLocalGatewayVirtualInterfaceRequest = S.suspend(() =>
  S.Struct({
    LocalGatewayVirtualInterfaceGroupId: S.optional(S.String),
    OutpostLagId: S.optional(S.String),
    Vlan: S.optional(S.Number),
    LocalAddress: S.optional(S.String),
    PeerAddress: S.optional(S.String),
    PeerBgpAsn: S.optional(S.Number),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
    PeerBgpAsnExtended: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateLocalGatewayVirtualInterfaceRequest",
}) as any as S.Schema<CreateLocalGatewayVirtualInterfaceRequest>;
export type LocalGatewayVirtualInterfaceConfigurationState =
  | "pending"
  | "available"
  | "deleting"
  | "deleted"
  | (string & {});
export const LocalGatewayVirtualInterfaceConfigurationState = S.String;
export interface LocalGatewayVirtualInterface {
  LocalGatewayVirtualInterfaceId?: string;
  LocalGatewayId?: string;
  LocalGatewayVirtualInterfaceGroupId?: string;
  LocalGatewayVirtualInterfaceArn?: string;
  OutpostLagId?: string;
  Vlan?: number;
  LocalAddress?: string;
  PeerAddress?: string;
  LocalBgpAsn?: number;
  PeerBgpAsn?: number;
  PeerBgpAsnExtended?: number;
  OwnerId?: string;
  Tags?: Tag[];
  ConfigurationState?: LocalGatewayVirtualInterfaceConfigurationState;
}
export const LocalGatewayVirtualInterface = S.suspend(() =>
  S.Struct({
    LocalGatewayVirtualInterfaceId: S.optional(S.String).pipe(
      T.XmlName("localGatewayVirtualInterfaceId"),
      T.Ec2QueryName("LocalGatewayVirtualInterfaceId"),
    ),
    LocalGatewayId: S.optional(S.String).pipe(
      T.XmlName("localGatewayId"),
      T.Ec2QueryName("LocalGatewayId"),
    ),
    LocalGatewayVirtualInterfaceGroupId: S.optional(S.String).pipe(
      T.XmlName("localGatewayVirtualInterfaceGroupId"),
      T.Ec2QueryName("LocalGatewayVirtualInterfaceGroupId"),
    ),
    LocalGatewayVirtualInterfaceArn: S.optional(S.String).pipe(
      T.XmlName("localGatewayVirtualInterfaceArn"),
      T.Ec2QueryName("LocalGatewayVirtualInterfaceArn"),
    ),
    OutpostLagId: S.optional(S.String).pipe(
      T.XmlName("outpostLagId"),
      T.Ec2QueryName("OutpostLagId"),
    ),
    Vlan: S.optional(S.Number).pipe(T.XmlName("vlan"), T.Ec2QueryName("Vlan")),
    LocalAddress: S.optional(S.String).pipe(
      T.XmlName("localAddress"),
      T.Ec2QueryName("LocalAddress"),
    ),
    PeerAddress: S.optional(S.String).pipe(
      T.XmlName("peerAddress"),
      T.Ec2QueryName("PeerAddress"),
    ),
    LocalBgpAsn: S.optional(S.Number).pipe(
      T.XmlName("localBgpAsn"),
      T.Ec2QueryName("LocalBgpAsn"),
    ),
    PeerBgpAsn: S.optional(S.Number).pipe(
      T.XmlName("peerBgpAsn"),
      T.Ec2QueryName("PeerBgpAsn"),
    ),
    PeerBgpAsnExtended: S.optional(S.Number).pipe(
      T.XmlName("peerBgpAsnExtended"),
      T.Ec2QueryName("PeerBgpAsnExtended"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    ConfigurationState: S.optional(
      LocalGatewayVirtualInterfaceConfigurationState,
    ).pipe(
      T.XmlName("configurationState"),
      T.Ec2QueryName("ConfigurationState"),
    ),
  }),
).annotate({
  identifier: "LocalGatewayVirtualInterface",
}) as any as S.Schema<LocalGatewayVirtualInterface>;
export interface CreateLocalGatewayVirtualInterfaceResult {
  LocalGatewayVirtualInterface?: LocalGatewayVirtualInterface;
}
export const CreateLocalGatewayVirtualInterfaceResult = S.suspend(() =>
  S.Struct({
    LocalGatewayVirtualInterface: S.optional(LocalGatewayVirtualInterface)
      .pipe(
        T.XmlName("localGatewayVirtualInterface"),
        T.Ec2QueryName("LocalGatewayVirtualInterface"),
      )
      .annotate({ identifier: "LocalGatewayVirtualInterface" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateLocalGatewayVirtualInterfaceResult",
}) as any as S.Schema<CreateLocalGatewayVirtualInterfaceResult>;
export interface CreateLocalGatewayVirtualInterfaceGroupRequest {
  LocalGatewayId?: string;
  LocalBgpAsn?: number;
  LocalBgpAsnExtended?: number;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateLocalGatewayVirtualInterfaceGroupRequest = S.suspend(() =>
  S.Struct({
    LocalGatewayId: S.optional(S.String),
    LocalBgpAsn: S.optional(S.Number),
    LocalBgpAsnExtended: S.optional(S.Number),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateLocalGatewayVirtualInterfaceGroupRequest",
}) as any as S.Schema<CreateLocalGatewayVirtualInterfaceGroupRequest>;
export type LocalGatewayVirtualInterfaceIdSet = string[];
export const LocalGatewayVirtualInterfaceIdSet = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export type LocalGatewayVirtualInterfaceGroupConfigurationState =
  | "pending"
  | "incomplete"
  | "available"
  | "deleting"
  | "deleted"
  | (string & {});
export const LocalGatewayVirtualInterfaceGroupConfigurationState = S.String;
export interface LocalGatewayVirtualInterfaceGroup {
  LocalGatewayVirtualInterfaceGroupId?: string;
  LocalGatewayVirtualInterfaceIds?: string[];
  LocalGatewayId?: string;
  OwnerId?: string;
  LocalBgpAsn?: number;
  LocalBgpAsnExtended?: number;
  LocalGatewayVirtualInterfaceGroupArn?: string;
  Tags?: Tag[];
  ConfigurationState?: LocalGatewayVirtualInterfaceGroupConfigurationState;
}
export const LocalGatewayVirtualInterfaceGroup = S.suspend(() =>
  S.Struct({
    LocalGatewayVirtualInterfaceGroupId: S.optional(S.String).pipe(
      T.XmlName("localGatewayVirtualInterfaceGroupId"),
      T.Ec2QueryName("LocalGatewayVirtualInterfaceGroupId"),
    ),
    LocalGatewayVirtualInterfaceIds: S.optional(
      LocalGatewayVirtualInterfaceIdSet,
    ).pipe(
      T.XmlName("localGatewayVirtualInterfaceIdSet"),
      T.Ec2QueryName("LocalGatewayVirtualInterfaceIdSet"),
    ),
    LocalGatewayId: S.optional(S.String).pipe(
      T.XmlName("localGatewayId"),
      T.Ec2QueryName("LocalGatewayId"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    LocalBgpAsn: S.optional(S.Number).pipe(
      T.XmlName("localBgpAsn"),
      T.Ec2QueryName("LocalBgpAsn"),
    ),
    LocalBgpAsnExtended: S.optional(S.Number).pipe(
      T.XmlName("localBgpAsnExtended"),
      T.Ec2QueryName("LocalBgpAsnExtended"),
    ),
    LocalGatewayVirtualInterfaceGroupArn: S.optional(S.String).pipe(
      T.XmlName("localGatewayVirtualInterfaceGroupArn"),
      T.Ec2QueryName("LocalGatewayVirtualInterfaceGroupArn"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    ConfigurationState: S.optional(
      LocalGatewayVirtualInterfaceGroupConfigurationState,
    ).pipe(
      T.XmlName("configurationState"),
      T.Ec2QueryName("ConfigurationState"),
    ),
  }),
).annotate({
  identifier: "LocalGatewayVirtualInterfaceGroup",
}) as any as S.Schema<LocalGatewayVirtualInterfaceGroup>;
export interface CreateLocalGatewayVirtualInterfaceGroupResult {
  LocalGatewayVirtualInterfaceGroup?: LocalGatewayVirtualInterfaceGroup;
}
export const CreateLocalGatewayVirtualInterfaceGroupResult = S.suspend(() =>
  S.Struct({
    LocalGatewayVirtualInterfaceGroup: S.optional(
      LocalGatewayVirtualInterfaceGroup,
    )
      .pipe(
        T.XmlName("localGatewayVirtualInterfaceGroup"),
        T.Ec2QueryName("LocalGatewayVirtualInterfaceGroup"),
      )
      .annotate({ identifier: "LocalGatewayVirtualInterfaceGroup" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateLocalGatewayVirtualInterfaceGroupResult",
}) as any as S.Schema<CreateLocalGatewayVirtualInterfaceGroupResult>;
export interface MacSystemIntegrityProtectionConfigurationRequest {
  AppleInternal?: MacSystemIntegrityProtectionSettingStatus;
  BaseSystem?: MacSystemIntegrityProtectionSettingStatus;
  DebuggingRestrictions?: MacSystemIntegrityProtectionSettingStatus;
  DTraceRestrictions?: MacSystemIntegrityProtectionSettingStatus;
  FilesystemProtections?: MacSystemIntegrityProtectionSettingStatus;
  KextSigning?: MacSystemIntegrityProtectionSettingStatus;
  NvramProtections?: MacSystemIntegrityProtectionSettingStatus;
}
export const MacSystemIntegrityProtectionConfigurationRequest = S.suspend(() =>
  S.Struct({
    AppleInternal: S.optional(MacSystemIntegrityProtectionSettingStatus),
    BaseSystem: S.optional(MacSystemIntegrityProtectionSettingStatus),
    DebuggingRestrictions: S.optional(
      MacSystemIntegrityProtectionSettingStatus,
    ),
    DTraceRestrictions: S.optional(MacSystemIntegrityProtectionSettingStatus),
    FilesystemProtections: S.optional(
      MacSystemIntegrityProtectionSettingStatus,
    ),
    KextSigning: S.optional(MacSystemIntegrityProtectionSettingStatus),
    NvramProtections: S.optional(MacSystemIntegrityProtectionSettingStatus),
  }),
).annotate({
  identifier: "MacSystemIntegrityProtectionConfigurationRequest",
}) as any as S.Schema<MacSystemIntegrityProtectionConfigurationRequest>;
export interface CreateMacSystemIntegrityProtectionModificationTaskRequest {
  ClientToken?: string;
  DryRun?: boolean;
  InstanceId?: string;
  MacCredentials?: string | redacted.Redacted<string>;
  MacSystemIntegrityProtectionConfiguration?: MacSystemIntegrityProtectionConfigurationRequest;
  MacSystemIntegrityProtectionStatus?: MacSystemIntegrityProtectionSettingStatus;
  TagSpecifications?: TagSpecification[];
}
export const CreateMacSystemIntegrityProtectionModificationTaskRequest =
  S.suspend(() =>
    S.Struct({
      ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
      DryRun: S.optional(S.Boolean),
      InstanceId: S.optional(S.String),
      MacCredentials: S.optional(SensitiveString),
      MacSystemIntegrityProtectionConfiguration: S.optional(
        MacSystemIntegrityProtectionConfigurationRequest,
      ),
      MacSystemIntegrityProtectionStatus: S.optional(
        MacSystemIntegrityProtectionSettingStatus,
      ),
      TagSpecifications: S.optional(TagSpecificationList).pipe(
        T.XmlName("TagSpecification"),
      ),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
  ).annotate({
    identifier: "CreateMacSystemIntegrityProtectionModificationTaskRequest",
  }) as any as S.Schema<CreateMacSystemIntegrityProtectionModificationTaskRequest>;
export interface CreateMacSystemIntegrityProtectionModificationTaskResult {
  MacModificationTask?: MacModificationTask;
}
export const CreateMacSystemIntegrityProtectionModificationTaskResult =
  S.suspend(() =>
    S.Struct({
      MacModificationTask: S.optional(MacModificationTask)
        .pipe(
          T.XmlName("macModificationTask"),
          T.Ec2QueryName("MacModificationTask"),
        )
        .annotate({ identifier: "MacModificationTask" }),
    }).pipe(ns),
  ).annotate({
    identifier: "CreateMacSystemIntegrityProtectionModificationTaskResult",
  }) as any as S.Schema<CreateMacSystemIntegrityProtectionModificationTaskResult>;
export interface AddPrefixListEntry {
  Cidr?: string;
  Description?: string;
}
export const AddPrefixListEntry = S.suspend(() =>
  S.Struct({ Cidr: S.optional(S.String), Description: S.optional(S.String) }),
).annotate({
  identifier: "AddPrefixListEntry",
}) as any as S.Schema<AddPrefixListEntry>;
export type AddPrefixListEntries = AddPrefixListEntry[];
export const AddPrefixListEntries = S.Array(AddPrefixListEntry);
export interface CreateManagedPrefixListRequest {
  DryRun?: boolean;
  PrefixListName?: string;
  Entries?: AddPrefixListEntry[];
  MaxEntries?: number;
  TagSpecifications?: TagSpecification[];
  AddressFamily?: string;
  ClientToken?: string;
}
export const CreateManagedPrefixListRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    PrefixListName: S.optional(S.String),
    Entries: S.optional(AddPrefixListEntries).pipe(T.XmlName("Entry")),
    MaxEntries: S.optional(S.Number),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    AddressFamily: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateManagedPrefixListRequest",
}) as any as S.Schema<CreateManagedPrefixListRequest>;
export type PrefixListState =
  | "create-in-progress"
  | "create-complete"
  | "create-failed"
  | "modify-in-progress"
  | "modify-complete"
  | "modify-failed"
  | "restore-in-progress"
  | "restore-complete"
  | "restore-failed"
  | "delete-in-progress"
  | "delete-complete"
  | "delete-failed"
  | (string & {});
export const PrefixListState = S.String;
export interface ManagedPrefixList {
  PrefixListId?: string;
  AddressFamily?: string;
  State?: PrefixListState;
  StateMessage?: string;
  PrefixListArn?: string;
  PrefixListName?: string;
  MaxEntries?: number;
  Version?: number;
  Tags?: Tag[];
  OwnerId?: string;
  IpamPrefixListResolverTargetId?: string;
  IpamPrefixListResolverSyncEnabled?: boolean;
}
export const ManagedPrefixList = S.suspend(() =>
  S.Struct({
    PrefixListId: S.optional(S.String).pipe(
      T.XmlName("prefixListId"),
      T.Ec2QueryName("PrefixListId"),
    ),
    AddressFamily: S.optional(S.String).pipe(
      T.XmlName("addressFamily"),
      T.Ec2QueryName("AddressFamily"),
    ),
    State: S.optional(PrefixListState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StateMessage: S.optional(S.String).pipe(
      T.XmlName("stateMessage"),
      T.Ec2QueryName("StateMessage"),
    ),
    PrefixListArn: S.optional(S.String).pipe(
      T.XmlName("prefixListArn"),
      T.Ec2QueryName("PrefixListArn"),
    ),
    PrefixListName: S.optional(S.String).pipe(
      T.XmlName("prefixListName"),
      T.Ec2QueryName("PrefixListName"),
    ),
    MaxEntries: S.optional(S.Number).pipe(
      T.XmlName("maxEntries"),
      T.Ec2QueryName("MaxEntries"),
    ),
    Version: S.optional(S.Number).pipe(
      T.XmlName("version"),
      T.Ec2QueryName("Version"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    IpamPrefixListResolverTargetId: S.optional(S.String).pipe(
      T.XmlName("ipamPrefixListResolverTargetId"),
      T.Ec2QueryName("IpamPrefixListResolverTargetId"),
    ),
    IpamPrefixListResolverSyncEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("ipamPrefixListResolverSyncEnabled"),
      T.Ec2QueryName("IpamPrefixListResolverSyncEnabled"),
    ),
  }),
).annotate({
  identifier: "ManagedPrefixList",
}) as any as S.Schema<ManagedPrefixList>;
export interface CreateManagedPrefixListResult {
  PrefixList?: ManagedPrefixList;
}
export const CreateManagedPrefixListResult = S.suspend(() =>
  S.Struct({
    PrefixList: S.optional(ManagedPrefixList)
      .pipe(T.XmlName("prefixList"), T.Ec2QueryName("PrefixList"))
      .annotate({ identifier: "ManagedPrefixList" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateManagedPrefixListResult",
}) as any as S.Schema<CreateManagedPrefixListResult>;
export type AvailabilityMode = "zonal" | "regional" | (string & {});
export const AvailabilityMode = S.String;
export interface AvailabilityZoneAddress {
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  AllocationIds?: string[];
}
export const AvailabilityZoneAddress = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String),
    AvailabilityZoneId: S.optional(S.String),
    AllocationIds: S.optional(AllocationIdList).pipe(T.XmlName("AllocationId")),
  }),
).annotate({
  identifier: "AvailabilityZoneAddress",
}) as any as S.Schema<AvailabilityZoneAddress>;
export type AvailabilityZoneAddresses = AvailabilityZoneAddress[];
export const AvailabilityZoneAddresses = S.Array(
  AvailabilityZoneAddress.pipe(T.XmlName("AvailabilityZoneAddress")).annotate({
    identifier: "AvailabilityZoneAddress",
  }),
);
export type ConnectivityType = "private" | "public" | (string & {});
export const ConnectivityType = S.String;
export interface CreateNatGatewayRequest {
  AvailabilityMode?: AvailabilityMode;
  AllocationId?: string;
  ClientToken?: string;
  DryRun?: boolean;
  SubnetId?: string;
  VpcId?: string;
  AvailabilityZoneAddresses?: AvailabilityZoneAddress[];
  TagSpecifications?: TagSpecification[];
  ConnectivityType?: ConnectivityType;
  PrivateIpAddress?: string;
  SecondaryAllocationIds?: string[];
  SecondaryPrivateIpAddresses?: string[];
  SecondaryPrivateIpAddressCount?: number;
}
export const CreateNatGatewayRequest = S.suspend(() =>
  S.Struct({
    AvailabilityMode: S.optional(AvailabilityMode),
    AllocationId: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
    SubnetId: S.optional(S.String),
    VpcId: S.optional(S.String),
    AvailabilityZoneAddresses: S.optional(AvailabilityZoneAddresses).pipe(
      T.XmlName("AvailabilityZoneAddress"),
    ),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ConnectivityType: S.optional(ConnectivityType),
    PrivateIpAddress: S.optional(S.String),
    SecondaryAllocationIds: S.optional(AllocationIdList).pipe(
      T.XmlName("SecondaryAllocationId"),
    ),
    SecondaryPrivateIpAddresses: S.optional(IpList).pipe(
      T.XmlName("SecondaryPrivateIpAddress"),
    ),
    SecondaryPrivateIpAddressCount: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateNatGatewayRequest",
}) as any as S.Schema<CreateNatGatewayRequest>;
export interface ProvisionedBandwidth {
  ProvisionTime?: Date;
  Provisioned?: string;
  RequestTime?: Date;
  Requested?: string;
  Status?: string;
}
export const ProvisionedBandwidth = S.suspend(() =>
  S.Struct({
    ProvisionTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("provisionTime"), T.Ec2QueryName("ProvisionTime")),
    Provisioned: S.optional(S.String).pipe(
      T.XmlName("provisioned"),
      T.Ec2QueryName("Provisioned"),
    ),
    RequestTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("requestTime"), T.Ec2QueryName("RequestTime")),
    Requested: S.optional(S.String).pipe(
      T.XmlName("requested"),
      T.Ec2QueryName("Requested"),
    ),
    Status: S.optional(S.String).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
  }),
).annotate({
  identifier: "ProvisionedBandwidth",
}) as any as S.Schema<ProvisionedBandwidth>;
export type NatGatewayState =
  | "pending"
  | "failed"
  | "available"
  | "deleting"
  | "deleted"
  | (string & {});
export const NatGatewayState = S.String;
export type AutoScalingIpsState = "enabled" | "disabled" | (string & {});
export const AutoScalingIpsState = S.String;
export type AutoProvisionZonesState = "enabled" | "disabled" | (string & {});
export const AutoProvisionZonesState = S.String;
export type NatGatewayApplianceType = "network-firewall-proxy" | (string & {});
export const NatGatewayApplianceType = S.String;
export type NatGatewayApplianceState =
  | "attaching"
  | "attached"
  | "detaching"
  | "detached"
  | "attach-failed"
  | "detach-failed"
  | (string & {});
export const NatGatewayApplianceState = S.String;
export type NatGatewayApplianceModifyState =
  | "modifying"
  | "completed"
  | "failed"
  | (string & {});
export const NatGatewayApplianceModifyState = S.String;
export interface NatGatewayAttachedAppliance {
  Type?: NatGatewayApplianceType;
  ApplianceArn?: string;
  VpcEndpointId?: string;
  AttachmentState?: NatGatewayApplianceState;
  ModificationState?: NatGatewayApplianceModifyState;
  FailureCode?: string;
  FailureMessage?: string;
}
export const NatGatewayAttachedAppliance = S.suspend(() =>
  S.Struct({
    Type: S.optional(NatGatewayApplianceType).pipe(
      T.XmlName("type"),
      T.Ec2QueryName("Type"),
    ),
    ApplianceArn: S.optional(S.String).pipe(
      T.XmlName("applianceArn"),
      T.Ec2QueryName("ApplianceArn"),
    ),
    VpcEndpointId: S.optional(S.String).pipe(
      T.XmlName("vpcEndpointId"),
      T.Ec2QueryName("VpcEndpointId"),
    ),
    AttachmentState: S.optional(NatGatewayApplianceState).pipe(
      T.XmlName("attachmentState"),
      T.Ec2QueryName("AttachmentState"),
    ),
    ModificationState: S.optional(NatGatewayApplianceModifyState).pipe(
      T.XmlName("modificationState"),
      T.Ec2QueryName("ModificationState"),
    ),
    FailureCode: S.optional(S.String).pipe(
      T.XmlName("failureCode"),
      T.Ec2QueryName("FailureCode"),
    ),
    FailureMessage: S.optional(S.String).pipe(
      T.XmlName("failureMessage"),
      T.Ec2QueryName("FailureMessage"),
    ),
  }),
).annotate({
  identifier: "NatGatewayAttachedAppliance",
}) as any as S.Schema<NatGatewayAttachedAppliance>;
export type NatGatewayAttachedApplianceList = NatGatewayAttachedAppliance[];
export const NatGatewayAttachedApplianceList = S.Array(
  NatGatewayAttachedAppliance.pipe(T.XmlName("item")).annotate({
    identifier: "NatGatewayAttachedAppliance",
  }),
);
export interface NatGateway {
  CreateTime?: Date;
  DeleteTime?: Date;
  FailureCode?: string;
  FailureMessage?: string;
  NatGatewayAddresses?: NatGatewayAddress[];
  NatGatewayId?: string;
  ProvisionedBandwidth?: ProvisionedBandwidth;
  State?: NatGatewayState;
  SubnetId?: string;
  VpcId?: string;
  Tags?: Tag[];
  ConnectivityType?: ConnectivityType;
  AvailabilityMode?: AvailabilityMode;
  AutoScalingIps?: AutoScalingIpsState;
  AutoProvisionZones?: AutoProvisionZonesState;
  AttachedAppliances?: NatGatewayAttachedAppliance[];
  RouteTableId?: string;
}
export const NatGateway = S.suspend(() =>
  S.Struct({
    CreateTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createTime"), T.Ec2QueryName("CreateTime")),
    DeleteTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("deleteTime"), T.Ec2QueryName("DeleteTime")),
    FailureCode: S.optional(S.String).pipe(
      T.XmlName("failureCode"),
      T.Ec2QueryName("FailureCode"),
    ),
    FailureMessage: S.optional(S.String).pipe(
      T.XmlName("failureMessage"),
      T.Ec2QueryName("FailureMessage"),
    ),
    NatGatewayAddresses: S.optional(NatGatewayAddressList).pipe(
      T.XmlName("natGatewayAddressSet"),
      T.Ec2QueryName("NatGatewayAddressSet"),
    ),
    NatGatewayId: S.optional(S.String).pipe(
      T.XmlName("natGatewayId"),
      T.Ec2QueryName("NatGatewayId"),
    ),
    ProvisionedBandwidth: S.optional(ProvisionedBandwidth)
      .pipe(
        T.XmlName("provisionedBandwidth"),
        T.Ec2QueryName("ProvisionedBandwidth"),
      )
      .annotate({ identifier: "ProvisionedBandwidth" }),
    State: S.optional(NatGatewayState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    ConnectivityType: S.optional(ConnectivityType).pipe(
      T.XmlName("connectivityType"),
      T.Ec2QueryName("ConnectivityType"),
    ),
    AvailabilityMode: S.optional(AvailabilityMode).pipe(
      T.XmlName("availabilityMode"),
      T.Ec2QueryName("AvailabilityMode"),
    ),
    AutoScalingIps: S.optional(AutoScalingIpsState).pipe(
      T.XmlName("autoScalingIps"),
      T.Ec2QueryName("AutoScalingIps"),
    ),
    AutoProvisionZones: S.optional(AutoProvisionZonesState).pipe(
      T.XmlName("autoProvisionZones"),
      T.Ec2QueryName("AutoProvisionZones"),
    ),
    AttachedAppliances: S.optional(NatGatewayAttachedApplianceList).pipe(
      T.XmlName("attachedApplianceSet"),
      T.Ec2QueryName("AttachedApplianceSet"),
    ),
    RouteTableId: S.optional(S.String).pipe(
      T.XmlName("routeTableId"),
      T.Ec2QueryName("RouteTableId"),
    ),
  }),
).annotate({ identifier: "NatGateway" }) as any as S.Schema<NatGateway>;
export interface CreateNatGatewayResult {
  ClientToken?: string;
  NatGateway?: NatGateway;
}
export const CreateNatGatewayResult = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
    NatGateway: S.optional(NatGateway)
      .pipe(T.XmlName("natGateway"), T.Ec2QueryName("NatGateway"))
      .annotate({ identifier: "NatGateway" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateNatGatewayResult",
}) as any as S.Schema<CreateNatGatewayResult>;
export interface CreateNetworkAclRequest {
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
  DryRun?: boolean;
  VpcId?: string;
}
export const CreateNetworkAclRequest = S.suspend(() =>
  S.Struct({
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateNetworkAclRequest",
}) as any as S.Schema<CreateNetworkAclRequest>;
export interface NetworkAclAssociation {
  NetworkAclAssociationId?: string;
  NetworkAclId?: string;
  SubnetId?: string;
}
export const NetworkAclAssociation = S.suspend(() =>
  S.Struct({
    NetworkAclAssociationId: S.optional(S.String).pipe(
      T.XmlName("networkAclAssociationId"),
      T.Ec2QueryName("NetworkAclAssociationId"),
    ),
    NetworkAclId: S.optional(S.String).pipe(
      T.XmlName("networkAclId"),
      T.Ec2QueryName("NetworkAclId"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
  }),
).annotate({
  identifier: "NetworkAclAssociation",
}) as any as S.Schema<NetworkAclAssociation>;
export type NetworkAclAssociationList = NetworkAclAssociation[];
export const NetworkAclAssociationList = S.Array(
  NetworkAclAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "NetworkAclAssociation",
  }),
);
export interface IcmpTypeCode {
  Code?: number;
  Type?: number;
}
export const IcmpTypeCode = S.suspend(() =>
  S.Struct({
    Code: S.optional(S.Number).pipe(T.XmlName("code"), T.Ec2QueryName("Code")),
    Type: S.optional(S.Number).pipe(T.XmlName("type"), T.Ec2QueryName("Type")),
  }),
).annotate({ identifier: "IcmpTypeCode" }) as any as S.Schema<IcmpTypeCode>;
export interface PortRange {
  From?: number;
  To?: number;
}
export const PortRange = S.suspend(() =>
  S.Struct({
    From: S.optional(S.Number).pipe(T.XmlName("from"), T.Ec2QueryName("From")),
    To: S.optional(S.Number).pipe(T.XmlName("to"), T.Ec2QueryName("To")),
  }),
).annotate({ identifier: "PortRange" }) as any as S.Schema<PortRange>;
export type RuleAction = "allow" | "deny" | (string & {});
export const RuleAction = S.String;
export interface NetworkAclEntry {
  CidrBlock?: string;
  Egress?: boolean;
  IcmpTypeCode?: IcmpTypeCode;
  Ipv6CidrBlock?: string;
  PortRange?: PortRange;
  Protocol?: string;
  RuleAction?: RuleAction;
  RuleNumber?: number;
}
export const NetworkAclEntry = S.suspend(() =>
  S.Struct({
    CidrBlock: S.optional(S.String).pipe(
      T.XmlName("cidrBlock"),
      T.Ec2QueryName("CidrBlock"),
    ),
    Egress: S.optional(S.Boolean).pipe(
      T.XmlName("egress"),
      T.Ec2QueryName("Egress"),
    ),
    IcmpTypeCode: S.optional(IcmpTypeCode)
      .pipe(T.XmlName("icmpTypeCode"), T.Ec2QueryName("IcmpTypeCode"))
      .annotate({ identifier: "IcmpTypeCode" }),
    Ipv6CidrBlock: S.optional(S.String).pipe(
      T.XmlName("ipv6CidrBlock"),
      T.Ec2QueryName("Ipv6CidrBlock"),
    ),
    PortRange: S.optional(PortRange)
      .pipe(T.XmlName("portRange"), T.Ec2QueryName("PortRange"))
      .annotate({ identifier: "PortRange" }),
    Protocol: S.optional(S.String).pipe(
      T.XmlName("protocol"),
      T.Ec2QueryName("Protocol"),
    ),
    RuleAction: S.optional(RuleAction).pipe(
      T.XmlName("ruleAction"),
      T.Ec2QueryName("RuleAction"),
    ),
    RuleNumber: S.optional(S.Number).pipe(
      T.XmlName("ruleNumber"),
      T.Ec2QueryName("RuleNumber"),
    ),
  }),
).annotate({
  identifier: "NetworkAclEntry",
}) as any as S.Schema<NetworkAclEntry>;
export type NetworkAclEntryList = NetworkAclEntry[];
export const NetworkAclEntryList = S.Array(
  NetworkAclEntry.pipe(T.XmlName("item")).annotate({
    identifier: "NetworkAclEntry",
  }),
);
export interface NetworkAcl {
  Associations?: NetworkAclAssociation[];
  Entries?: NetworkAclEntry[];
  IsDefault?: boolean;
  NetworkAclId?: string;
  Tags?: Tag[];
  VpcId?: string;
  OwnerId?: string;
}
export const NetworkAcl = S.suspend(() =>
  S.Struct({
    Associations: S.optional(NetworkAclAssociationList).pipe(
      T.XmlName("associationSet"),
      T.Ec2QueryName("AssociationSet"),
    ),
    Entries: S.optional(NetworkAclEntryList).pipe(
      T.XmlName("entrySet"),
      T.Ec2QueryName("EntrySet"),
    ),
    IsDefault: S.optional(S.Boolean).pipe(
      T.XmlName("default"),
      T.Ec2QueryName("Default"),
    ),
    NetworkAclId: S.optional(S.String).pipe(
      T.XmlName("networkAclId"),
      T.Ec2QueryName("NetworkAclId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
  }),
).annotate({ identifier: "NetworkAcl" }) as any as S.Schema<NetworkAcl>;
export interface CreateNetworkAclResult {
  NetworkAcl?: NetworkAcl;
  ClientToken?: string;
}
export const CreateNetworkAclResult = S.suspend(() =>
  S.Struct({
    NetworkAcl: S.optional(NetworkAcl)
      .pipe(T.XmlName("networkAcl"), T.Ec2QueryName("NetworkAcl"))
      .annotate({ identifier: "NetworkAcl" }),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateNetworkAclResult",
}) as any as S.Schema<CreateNetworkAclResult>;
export interface CreateNetworkAclEntryRequest {
  DryRun?: boolean;
  NetworkAclId?: string;
  RuleNumber?: number;
  Protocol?: string;
  RuleAction?: RuleAction;
  Egress?: boolean;
  CidrBlock?: string;
  Ipv6CidrBlock?: string;
  IcmpTypeCode?: IcmpTypeCode;
  PortRange?: PortRange;
}
export const CreateNetworkAclEntryRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    NetworkAclId: S.optional(S.String).pipe(
      T.XmlName("networkAclId"),
      T.Ec2QueryName("NetworkAclId"),
    ),
    RuleNumber: S.optional(S.Number).pipe(
      T.XmlName("ruleNumber"),
      T.Ec2QueryName("RuleNumber"),
    ),
    Protocol: S.optional(S.String).pipe(
      T.XmlName("protocol"),
      T.Ec2QueryName("Protocol"),
    ),
    RuleAction: S.optional(RuleAction).pipe(
      T.XmlName("ruleAction"),
      T.Ec2QueryName("RuleAction"),
    ),
    Egress: S.optional(S.Boolean).pipe(
      T.XmlName("egress"),
      T.Ec2QueryName("Egress"),
    ),
    CidrBlock: S.optional(S.String).pipe(
      T.XmlName("cidrBlock"),
      T.Ec2QueryName("CidrBlock"),
    ),
    Ipv6CidrBlock: S.optional(S.String).pipe(
      T.XmlName("ipv6CidrBlock"),
      T.Ec2QueryName("Ipv6CidrBlock"),
    ),
    IcmpTypeCode: S.optional(IcmpTypeCode)
      .pipe(T.XmlName("Icmp"))
      .annotate({ identifier: "IcmpTypeCode" }),
    PortRange: S.optional(PortRange)
      .pipe(T.XmlName("portRange"), T.Ec2QueryName("PortRange"))
      .annotate({ identifier: "PortRange" }),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateNetworkAclEntryRequest",
}) as any as S.Schema<CreateNetworkAclEntryRequest>;
export interface CreateNetworkAclEntryResponse {}
export const CreateNetworkAclEntryResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "CreateNetworkAclEntryResponse",
}) as any as S.Schema<CreateNetworkAclEntryResponse>;
export type Protocol = "tcp" | "udp" | (string & {});
export const Protocol = S.String;
export type ProtocolList = Protocol[];
export const ProtocolList = S.Array(Protocol.pipe(T.XmlName("item")));
export interface PacketHeaderStatementRequest {
  SourceAddresses?: string[];
  DestinationAddresses?: string[];
  SourcePorts?: string[];
  DestinationPorts?: string[];
  SourcePrefixLists?: string[];
  DestinationPrefixLists?: string[];
  Protocols?: Protocol[];
}
export const PacketHeaderStatementRequest = S.suspend(() =>
  S.Struct({
    SourceAddresses: S.optional(ValueStringList).pipe(
      T.XmlName("SourceAddress"),
    ),
    DestinationAddresses: S.optional(ValueStringList).pipe(
      T.XmlName("DestinationAddress"),
    ),
    SourcePorts: S.optional(ValueStringList).pipe(T.XmlName("SourcePort")),
    DestinationPorts: S.optional(ValueStringList).pipe(
      T.XmlName("DestinationPort"),
    ),
    SourcePrefixLists: S.optional(ValueStringList).pipe(
      T.XmlName("SourcePrefixList"),
    ),
    DestinationPrefixLists: S.optional(ValueStringList).pipe(
      T.XmlName("DestinationPrefixList"),
    ),
    Protocols: S.optional(ProtocolList).pipe(T.XmlName("Protocol")),
  }),
).annotate({
  identifier: "PacketHeaderStatementRequest",
}) as any as S.Schema<PacketHeaderStatementRequest>;
export interface ResourceStatementRequest {
  Resources?: string[];
  ResourceTypes?: string[];
}
export const ResourceStatementRequest = S.suspend(() =>
  S.Struct({
    Resources: S.optional(ValueStringList).pipe(T.XmlName("Resource")),
    ResourceTypes: S.optional(ValueStringList).pipe(T.XmlName("ResourceType")),
  }),
).annotate({
  identifier: "ResourceStatementRequest",
}) as any as S.Schema<ResourceStatementRequest>;
export interface PathStatementRequest {
  PacketHeaderStatement?: PacketHeaderStatementRequest;
  ResourceStatement?: ResourceStatementRequest;
}
export const PathStatementRequest = S.suspend(() =>
  S.Struct({
    PacketHeaderStatement: S.optional(PacketHeaderStatementRequest),
    ResourceStatement: S.optional(ResourceStatementRequest),
  }),
).annotate({
  identifier: "PathStatementRequest",
}) as any as S.Schema<PathStatementRequest>;
export interface ThroughResourcesStatementRequest {
  ResourceStatement?: ResourceStatementRequest;
}
export const ThroughResourcesStatementRequest = S.suspend(() =>
  S.Struct({ ResourceStatement: S.optional(ResourceStatementRequest) }),
).annotate({
  identifier: "ThroughResourcesStatementRequest",
}) as any as S.Schema<ThroughResourcesStatementRequest>;
export type ThroughResourcesStatementRequestList =
  ThroughResourcesStatementRequest[];
export const ThroughResourcesStatementRequestList = S.Array(
  ThroughResourcesStatementRequest.pipe(T.XmlName("item")).annotate({
    identifier: "ThroughResourcesStatementRequest",
  }),
);
export interface AccessScopePathRequest {
  Source?: PathStatementRequest;
  Destination?: PathStatementRequest;
  ThroughResources?: ThroughResourcesStatementRequest[];
}
export const AccessScopePathRequest = S.suspend(() =>
  S.Struct({
    Source: S.optional(PathStatementRequest),
    Destination: S.optional(PathStatementRequest),
    ThroughResources: S.optional(ThroughResourcesStatementRequestList).pipe(
      T.XmlName("ThroughResource"),
    ),
  }),
).annotate({
  identifier: "AccessScopePathRequest",
}) as any as S.Schema<AccessScopePathRequest>;
export type AccessScopePathListRequest = AccessScopePathRequest[];
export const AccessScopePathListRequest = S.Array(
  AccessScopePathRequest.pipe(T.XmlName("item")).annotate({
    identifier: "AccessScopePathRequest",
  }),
);
export interface CreateNetworkInsightsAccessScopeRequest {
  MatchPaths?: AccessScopePathRequest[];
  ExcludePaths?: AccessScopePathRequest[];
  ClientToken?: string;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateNetworkInsightsAccessScopeRequest = S.suspend(() =>
  S.Struct({
    MatchPaths: S.optional(AccessScopePathListRequest).pipe(
      T.XmlName("MatchPath"),
    ),
    ExcludePaths: S.optional(AccessScopePathListRequest).pipe(
      T.XmlName("ExcludePath"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateNetworkInsightsAccessScopeRequest",
}) as any as S.Schema<CreateNetworkInsightsAccessScopeRequest>;
export interface NetworkInsightsAccessScope {
  NetworkInsightsAccessScopeId?: string;
  NetworkInsightsAccessScopeArn?: string;
  CreatedDate?: Date;
  UpdatedDate?: Date;
  Tags?: Tag[];
}
export const NetworkInsightsAccessScope = S.suspend(() =>
  S.Struct({
    NetworkInsightsAccessScopeId: S.optional(S.String).pipe(
      T.XmlName("networkInsightsAccessScopeId"),
      T.Ec2QueryName("NetworkInsightsAccessScopeId"),
    ),
    NetworkInsightsAccessScopeArn: S.optional(S.String).pipe(
      T.XmlName("networkInsightsAccessScopeArn"),
      T.Ec2QueryName("NetworkInsightsAccessScopeArn"),
    ),
    CreatedDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createdDate"), T.Ec2QueryName("CreatedDate")),
    UpdatedDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("updatedDate"), T.Ec2QueryName("UpdatedDate")),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "NetworkInsightsAccessScope",
}) as any as S.Schema<NetworkInsightsAccessScope>;
export interface PacketHeaderStatement {
  SourceAddresses?: string[];
  DestinationAddresses?: string[];
  SourcePorts?: string[];
  DestinationPorts?: string[];
  SourcePrefixLists?: string[];
  DestinationPrefixLists?: string[];
  Protocols?: Protocol[];
}
export const PacketHeaderStatement = S.suspend(() =>
  S.Struct({
    SourceAddresses: S.optional(ValueStringList).pipe(
      T.XmlName("sourceAddressSet"),
      T.Ec2QueryName("SourceAddressSet"),
    ),
    DestinationAddresses: S.optional(ValueStringList).pipe(
      T.XmlName("destinationAddressSet"),
      T.Ec2QueryName("DestinationAddressSet"),
    ),
    SourcePorts: S.optional(ValueStringList).pipe(
      T.XmlName("sourcePortSet"),
      T.Ec2QueryName("SourcePortSet"),
    ),
    DestinationPorts: S.optional(ValueStringList).pipe(
      T.XmlName("destinationPortSet"),
      T.Ec2QueryName("DestinationPortSet"),
    ),
    SourcePrefixLists: S.optional(ValueStringList).pipe(
      T.XmlName("sourcePrefixListSet"),
      T.Ec2QueryName("SourcePrefixListSet"),
    ),
    DestinationPrefixLists: S.optional(ValueStringList).pipe(
      T.XmlName("destinationPrefixListSet"),
      T.Ec2QueryName("DestinationPrefixListSet"),
    ),
    Protocols: S.optional(ProtocolList).pipe(
      T.XmlName("protocolSet"),
      T.Ec2QueryName("ProtocolSet"),
    ),
  }),
).annotate({
  identifier: "PacketHeaderStatement",
}) as any as S.Schema<PacketHeaderStatement>;
export interface ResourceStatement {
  Resources?: string[];
  ResourceTypes?: string[];
}
export const ResourceStatement = S.suspend(() =>
  S.Struct({
    Resources: S.optional(ValueStringList).pipe(
      T.XmlName("resourceSet"),
      T.Ec2QueryName("ResourceSet"),
    ),
    ResourceTypes: S.optional(ValueStringList).pipe(
      T.XmlName("resourceTypeSet"),
      T.Ec2QueryName("ResourceTypeSet"),
    ),
  }),
).annotate({
  identifier: "ResourceStatement",
}) as any as S.Schema<ResourceStatement>;
export interface PathStatement {
  PacketHeaderStatement?: PacketHeaderStatement;
  ResourceStatement?: ResourceStatement;
}
export const PathStatement = S.suspend(() =>
  S.Struct({
    PacketHeaderStatement: S.optional(PacketHeaderStatement)
      .pipe(
        T.XmlName("packetHeaderStatement"),
        T.Ec2QueryName("PacketHeaderStatement"),
      )
      .annotate({ identifier: "PacketHeaderStatement" }),
    ResourceStatement: S.optional(ResourceStatement)
      .pipe(T.XmlName("resourceStatement"), T.Ec2QueryName("ResourceStatement"))
      .annotate({ identifier: "ResourceStatement" }),
  }),
).annotate({ identifier: "PathStatement" }) as any as S.Schema<PathStatement>;
export interface ThroughResourcesStatement {
  ResourceStatement?: ResourceStatement;
}
export const ThroughResourcesStatement = S.suspend(() =>
  S.Struct({
    ResourceStatement: S.optional(ResourceStatement)
      .pipe(T.XmlName("resourceStatement"), T.Ec2QueryName("ResourceStatement"))
      .annotate({ identifier: "ResourceStatement" }),
  }),
).annotate({
  identifier: "ThroughResourcesStatement",
}) as any as S.Schema<ThroughResourcesStatement>;
export type ThroughResourcesStatementList = ThroughResourcesStatement[];
export const ThroughResourcesStatementList = S.Array(
  ThroughResourcesStatement.pipe(T.XmlName("item")).annotate({
    identifier: "ThroughResourcesStatement",
  }),
);
export interface AccessScopePath {
  Source?: PathStatement;
  Destination?: PathStatement;
  ThroughResources?: ThroughResourcesStatement[];
}
export const AccessScopePath = S.suspend(() =>
  S.Struct({
    Source: S.optional(PathStatement)
      .pipe(T.XmlName("source"), T.Ec2QueryName("Source"))
      .annotate({ identifier: "PathStatement" }),
    Destination: S.optional(PathStatement)
      .pipe(T.XmlName("destination"), T.Ec2QueryName("Destination"))
      .annotate({ identifier: "PathStatement" }),
    ThroughResources: S.optional(ThroughResourcesStatementList).pipe(
      T.XmlName("throughResourceSet"),
      T.Ec2QueryName("ThroughResourceSet"),
    ),
  }),
).annotate({
  identifier: "AccessScopePath",
}) as any as S.Schema<AccessScopePath>;
export type AccessScopePathList = AccessScopePath[];
export const AccessScopePathList = S.Array(
  AccessScopePath.pipe(T.XmlName("item")).annotate({
    identifier: "AccessScopePath",
  }),
);
export interface NetworkInsightsAccessScopeContent {
  NetworkInsightsAccessScopeId?: string;
  MatchPaths?: AccessScopePath[];
  ExcludePaths?: AccessScopePath[];
}
export const NetworkInsightsAccessScopeContent = S.suspend(() =>
  S.Struct({
    NetworkInsightsAccessScopeId: S.optional(S.String).pipe(
      T.XmlName("networkInsightsAccessScopeId"),
      T.Ec2QueryName("NetworkInsightsAccessScopeId"),
    ),
    MatchPaths: S.optional(AccessScopePathList).pipe(
      T.XmlName("matchPathSet"),
      T.Ec2QueryName("MatchPathSet"),
    ),
    ExcludePaths: S.optional(AccessScopePathList).pipe(
      T.XmlName("excludePathSet"),
      T.Ec2QueryName("ExcludePathSet"),
    ),
  }),
).annotate({
  identifier: "NetworkInsightsAccessScopeContent",
}) as any as S.Schema<NetworkInsightsAccessScopeContent>;
export interface CreateNetworkInsightsAccessScopeResult {
  NetworkInsightsAccessScope?: NetworkInsightsAccessScope;
  NetworkInsightsAccessScopeContent?: NetworkInsightsAccessScopeContent;
}
export const CreateNetworkInsightsAccessScopeResult = S.suspend(() =>
  S.Struct({
    NetworkInsightsAccessScope: S.optional(NetworkInsightsAccessScope)
      .pipe(
        T.XmlName("networkInsightsAccessScope"),
        T.Ec2QueryName("NetworkInsightsAccessScope"),
      )
      .annotate({ identifier: "NetworkInsightsAccessScope" }),
    NetworkInsightsAccessScopeContent: S.optional(
      NetworkInsightsAccessScopeContent,
    )
      .pipe(
        T.XmlName("networkInsightsAccessScopeContent"),
        T.Ec2QueryName("NetworkInsightsAccessScopeContent"),
      )
      .annotate({ identifier: "NetworkInsightsAccessScopeContent" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateNetworkInsightsAccessScopeResult",
}) as any as S.Schema<CreateNetworkInsightsAccessScopeResult>;
export interface RequestFilterPortRange {
  FromPort?: number;
  ToPort?: number;
}
export const RequestFilterPortRange = S.suspend(() =>
  S.Struct({ FromPort: S.optional(S.Number), ToPort: S.optional(S.Number) }),
).annotate({
  identifier: "RequestFilterPortRange",
}) as any as S.Schema<RequestFilterPortRange>;
export interface PathRequestFilter {
  SourceAddress?: string;
  SourcePortRange?: RequestFilterPortRange;
  DestinationAddress?: string;
  DestinationPortRange?: RequestFilterPortRange;
}
export const PathRequestFilter = S.suspend(() =>
  S.Struct({
    SourceAddress: S.optional(S.String),
    SourcePortRange: S.optional(RequestFilterPortRange),
    DestinationAddress: S.optional(S.String),
    DestinationPortRange: S.optional(RequestFilterPortRange),
  }),
).annotate({
  identifier: "PathRequestFilter",
}) as any as S.Schema<PathRequestFilter>;
export interface CreateNetworkInsightsPathRequest {
  SourceIp?: string;
  DestinationIp?: string;
  Source?: string;
  Destination?: string;
  Protocol?: Protocol;
  DestinationPort?: number;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
  ClientToken?: string;
  FilterAtSource?: PathRequestFilter;
  FilterAtDestination?: PathRequestFilter;
}
export const CreateNetworkInsightsPathRequest = S.suspend(() =>
  S.Struct({
    SourceIp: S.optional(S.String),
    DestinationIp: S.optional(S.String),
    Source: S.optional(S.String),
    Destination: S.optional(S.String),
    Protocol: S.optional(Protocol),
    DestinationPort: S.optional(S.Number),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    FilterAtSource: S.optional(PathRequestFilter),
    FilterAtDestination: S.optional(PathRequestFilter),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateNetworkInsightsPathRequest",
}) as any as S.Schema<CreateNetworkInsightsPathRequest>;
export interface FilterPortRange {
  FromPort?: number;
  ToPort?: number;
}
export const FilterPortRange = S.suspend(() =>
  S.Struct({
    FromPort: S.optional(S.Number).pipe(
      T.XmlName("fromPort"),
      T.Ec2QueryName("FromPort"),
    ),
    ToPort: S.optional(S.Number).pipe(
      T.XmlName("toPort"),
      T.Ec2QueryName("ToPort"),
    ),
  }),
).annotate({
  identifier: "FilterPortRange",
}) as any as S.Schema<FilterPortRange>;
export interface PathFilter {
  SourceAddress?: string;
  SourcePortRange?: FilterPortRange;
  DestinationAddress?: string;
  DestinationPortRange?: FilterPortRange;
}
export const PathFilter = S.suspend(() =>
  S.Struct({
    SourceAddress: S.optional(S.String).pipe(
      T.XmlName("sourceAddress"),
      T.Ec2QueryName("SourceAddress"),
    ),
    SourcePortRange: S.optional(FilterPortRange)
      .pipe(T.XmlName("sourcePortRange"), T.Ec2QueryName("SourcePortRange"))
      .annotate({ identifier: "FilterPortRange" }),
    DestinationAddress: S.optional(S.String).pipe(
      T.XmlName("destinationAddress"),
      T.Ec2QueryName("DestinationAddress"),
    ),
    DestinationPortRange: S.optional(FilterPortRange)
      .pipe(
        T.XmlName("destinationPortRange"),
        T.Ec2QueryName("DestinationPortRange"),
      )
      .annotate({ identifier: "FilterPortRange" }),
  }),
).annotate({ identifier: "PathFilter" }) as any as S.Schema<PathFilter>;
export interface NetworkInsightsPath {
  NetworkInsightsPathId?: string;
  NetworkInsightsPathArn?: string;
  CreatedDate?: Date;
  Source?: string;
  Destination?: string;
  SourceArn?: string;
  DestinationArn?: string;
  SourceIp?: string;
  DestinationIp?: string;
  Protocol?: Protocol;
  DestinationPort?: number;
  Tags?: Tag[];
  FilterAtSource?: PathFilter;
  FilterAtDestination?: PathFilter;
}
export const NetworkInsightsPath = S.suspend(() =>
  S.Struct({
    NetworkInsightsPathId: S.optional(S.String).pipe(
      T.XmlName("networkInsightsPathId"),
      T.Ec2QueryName("NetworkInsightsPathId"),
    ),
    NetworkInsightsPathArn: S.optional(S.String).pipe(
      T.XmlName("networkInsightsPathArn"),
      T.Ec2QueryName("NetworkInsightsPathArn"),
    ),
    CreatedDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createdDate"), T.Ec2QueryName("CreatedDate")),
    Source: S.optional(S.String).pipe(
      T.XmlName("source"),
      T.Ec2QueryName("Source"),
    ),
    Destination: S.optional(S.String).pipe(
      T.XmlName("destination"),
      T.Ec2QueryName("Destination"),
    ),
    SourceArn: S.optional(S.String).pipe(
      T.XmlName("sourceArn"),
      T.Ec2QueryName("SourceArn"),
    ),
    DestinationArn: S.optional(S.String).pipe(
      T.XmlName("destinationArn"),
      T.Ec2QueryName("DestinationArn"),
    ),
    SourceIp: S.optional(S.String).pipe(
      T.XmlName("sourceIp"),
      T.Ec2QueryName("SourceIp"),
    ),
    DestinationIp: S.optional(S.String).pipe(
      T.XmlName("destinationIp"),
      T.Ec2QueryName("DestinationIp"),
    ),
    Protocol: S.optional(Protocol).pipe(
      T.XmlName("protocol"),
      T.Ec2QueryName("Protocol"),
    ),
    DestinationPort: S.optional(S.Number).pipe(
      T.XmlName("destinationPort"),
      T.Ec2QueryName("DestinationPort"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    FilterAtSource: S.optional(PathFilter)
      .pipe(T.XmlName("filterAtSource"), T.Ec2QueryName("FilterAtSource"))
      .annotate({ identifier: "PathFilter" }),
    FilterAtDestination: S.optional(PathFilter)
      .pipe(
        T.XmlName("filterAtDestination"),
        T.Ec2QueryName("FilterAtDestination"),
      )
      .annotate({ identifier: "PathFilter" }),
  }),
).annotate({
  identifier: "NetworkInsightsPath",
}) as any as S.Schema<NetworkInsightsPath>;
export interface CreateNetworkInsightsPathResult {
  NetworkInsightsPath?: NetworkInsightsPath;
}
export const CreateNetworkInsightsPathResult = S.suspend(() =>
  S.Struct({
    NetworkInsightsPath: S.optional(NetworkInsightsPath)
      .pipe(
        T.XmlName("networkInsightsPath"),
        T.Ec2QueryName("NetworkInsightsPath"),
      )
      .annotate({ identifier: "NetworkInsightsPath" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateNetworkInsightsPathResult",
}) as any as S.Schema<CreateNetworkInsightsPathResult>;
export type NetworkInterfaceCreationType =
  | "efa"
  | "efa-only"
  | "branch"
  | "trunk"
  | (string & {});
export const NetworkInterfaceCreationType = S.String;
export interface CreateNetworkInterfaceRequest {
  Ipv4Prefixes?: Ipv4PrefixSpecificationRequest[];
  Ipv4PrefixCount?: number;
  Ipv6Prefixes?: Ipv6PrefixSpecificationRequest[];
  Ipv6PrefixCount?: number;
  InterfaceType?: NetworkInterfaceCreationType;
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
  EnablePrimaryIpv6?: boolean;
  ConnectionTrackingSpecification?: ConnectionTrackingSpecificationRequest;
  Operator?: OperatorRequest;
  SubnetId?: string;
  Description?: string;
  PrivateIpAddress?: string;
  Groups?: string[];
  PrivateIpAddresses?: PrivateIpAddressSpecification[];
  SecondaryPrivateIpAddressCount?: number;
  Ipv6Addresses?: InstanceIpv6Address[];
  Ipv6AddressCount?: number;
  DryRun?: boolean;
}
export const CreateNetworkInterfaceRequest = S.suspend(() =>
  S.Struct({
    Ipv4Prefixes: S.optional(Ipv4PrefixList).pipe(T.XmlName("Ipv4Prefix")),
    Ipv4PrefixCount: S.optional(S.Number),
    Ipv6Prefixes: S.optional(Ipv6PrefixList).pipe(T.XmlName("Ipv6Prefix")),
    Ipv6PrefixCount: S.optional(S.Number),
    InterfaceType: S.optional(NetworkInterfaceCreationType),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    EnablePrimaryIpv6: S.optional(S.Boolean),
    ConnectionTrackingSpecification: S.optional(
      ConnectionTrackingSpecificationRequest,
    ),
    Operator: S.optional(OperatorRequest),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    PrivateIpAddress: S.optional(S.String).pipe(
      T.XmlName("privateIpAddress"),
      T.Ec2QueryName("PrivateIpAddress"),
    ),
    Groups: S.optional(SecurityGroupIdStringList).pipe(
      T.XmlName("SecurityGroupId"),
    ),
    PrivateIpAddresses: S.optional(PrivateIpAddressSpecificationList).pipe(
      T.XmlName("privateIpAddresses"),
      T.Ec2QueryName("PrivateIpAddresses"),
    ),
    SecondaryPrivateIpAddressCount: S.optional(S.Number).pipe(
      T.XmlName("secondaryPrivateIpAddressCount"),
      T.Ec2QueryName("SecondaryPrivateIpAddressCount"),
    ),
    Ipv6Addresses: S.optional(InstanceIpv6AddressList).pipe(
      T.XmlName("ipv6Addresses"),
      T.Ec2QueryName("Ipv6Addresses"),
    ),
    Ipv6AddressCount: S.optional(S.Number).pipe(
      T.XmlName("ipv6AddressCount"),
      T.Ec2QueryName("Ipv6AddressCount"),
    ),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateNetworkInterfaceRequest",
}) as any as S.Schema<CreateNetworkInterfaceRequest>;
export interface NetworkInterfaceAssociation {
  AllocationId?: string;
  AssociationId?: string;
  IpOwnerId?: string;
  PublicDnsName?: string;
  PublicIp?: string;
  CustomerOwnedIp?: string;
  CarrierIp?: string;
}
export const NetworkInterfaceAssociation = S.suspend(() =>
  S.Struct({
    AllocationId: S.optional(S.String).pipe(
      T.XmlName("allocationId"),
      T.Ec2QueryName("AllocationId"),
    ),
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
    IpOwnerId: S.optional(S.String).pipe(
      T.XmlName("ipOwnerId"),
      T.Ec2QueryName("IpOwnerId"),
    ),
    PublicDnsName: S.optional(S.String).pipe(
      T.XmlName("publicDnsName"),
      T.Ec2QueryName("PublicDnsName"),
    ),
    PublicIp: S.optional(S.String).pipe(
      T.XmlName("publicIp"),
      T.Ec2QueryName("PublicIp"),
    ),
    CustomerOwnedIp: S.optional(S.String).pipe(
      T.XmlName("customerOwnedIp"),
      T.Ec2QueryName("CustomerOwnedIp"),
    ),
    CarrierIp: S.optional(S.String).pipe(
      T.XmlName("carrierIp"),
      T.Ec2QueryName("CarrierIp"),
    ),
  }),
).annotate({
  identifier: "NetworkInterfaceAssociation",
}) as any as S.Schema<NetworkInterfaceAssociation>;
export interface AttachmentEnaSrdUdpSpecification {
  EnaSrdUdpEnabled?: boolean;
}
export const AttachmentEnaSrdUdpSpecification = S.suspend(() =>
  S.Struct({
    EnaSrdUdpEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("enaSrdUdpEnabled"),
      T.Ec2QueryName("EnaSrdUdpEnabled"),
    ),
  }),
).annotate({
  identifier: "AttachmentEnaSrdUdpSpecification",
}) as any as S.Schema<AttachmentEnaSrdUdpSpecification>;
export interface AttachmentEnaSrdSpecification {
  EnaSrdEnabled?: boolean;
  EnaSrdUdpSpecification?: AttachmentEnaSrdUdpSpecification;
}
export const AttachmentEnaSrdSpecification = S.suspend(() =>
  S.Struct({
    EnaSrdEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("enaSrdEnabled"),
      T.Ec2QueryName("EnaSrdEnabled"),
    ),
    EnaSrdUdpSpecification: S.optional(AttachmentEnaSrdUdpSpecification)
      .pipe(
        T.XmlName("enaSrdUdpSpecification"),
        T.Ec2QueryName("EnaSrdUdpSpecification"),
      )
      .annotate({ identifier: "AttachmentEnaSrdUdpSpecification" }),
  }),
).annotate({
  identifier: "AttachmentEnaSrdSpecification",
}) as any as S.Schema<AttachmentEnaSrdSpecification>;
export interface NetworkInterfaceAttachment {
  AttachTime?: Date;
  AttachmentId?: string;
  DeleteOnTermination?: boolean;
  DeviceIndex?: number;
  NetworkCardIndex?: number;
  InstanceId?: string;
  InstanceOwnerId?: string;
  Status?: AttachmentStatus;
  EnaSrdSpecification?: AttachmentEnaSrdSpecification;
  EnaQueueCount?: number;
}
export const NetworkInterfaceAttachment = S.suspend(() =>
  S.Struct({
    AttachTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("attachTime"), T.Ec2QueryName("AttachTime")),
    AttachmentId: S.optional(S.String).pipe(
      T.XmlName("attachmentId"),
      T.Ec2QueryName("AttachmentId"),
    ),
    DeleteOnTermination: S.optional(S.Boolean).pipe(
      T.XmlName("deleteOnTermination"),
      T.Ec2QueryName("DeleteOnTermination"),
    ),
    DeviceIndex: S.optional(S.Number).pipe(
      T.XmlName("deviceIndex"),
      T.Ec2QueryName("DeviceIndex"),
    ),
    NetworkCardIndex: S.optional(S.Number).pipe(
      T.XmlName("networkCardIndex"),
      T.Ec2QueryName("NetworkCardIndex"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    InstanceOwnerId: S.optional(S.String).pipe(
      T.XmlName("instanceOwnerId"),
      T.Ec2QueryName("InstanceOwnerId"),
    ),
    Status: S.optional(AttachmentStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    EnaSrdSpecification: S.optional(AttachmentEnaSrdSpecification)
      .pipe(
        T.XmlName("enaSrdSpecification"),
        T.Ec2QueryName("EnaSrdSpecification"),
      )
      .annotate({ identifier: "AttachmentEnaSrdSpecification" }),
    EnaQueueCount: S.optional(S.Number).pipe(
      T.XmlName("enaQueueCount"),
      T.Ec2QueryName("EnaQueueCount"),
    ),
  }),
).annotate({
  identifier: "NetworkInterfaceAttachment",
}) as any as S.Schema<NetworkInterfaceAttachment>;
export interface ConnectionTrackingConfiguration {
  TcpEstablishedTimeout?: number;
  UdpStreamTimeout?: number;
  UdpTimeout?: number;
}
export const ConnectionTrackingConfiguration = S.suspend(() =>
  S.Struct({
    TcpEstablishedTimeout: S.optional(S.Number).pipe(
      T.XmlName("tcpEstablishedTimeout"),
      T.Ec2QueryName("TcpEstablishedTimeout"),
    ),
    UdpStreamTimeout: S.optional(S.Number).pipe(
      T.XmlName("udpStreamTimeout"),
      T.Ec2QueryName("UdpStreamTimeout"),
    ),
    UdpTimeout: S.optional(S.Number).pipe(
      T.XmlName("udpTimeout"),
      T.Ec2QueryName("UdpTimeout"),
    ),
  }),
).annotate({
  identifier: "ConnectionTrackingConfiguration",
}) as any as S.Schema<ConnectionTrackingConfiguration>;
export interface GroupIdentifier {
  GroupId?: string;
  GroupName?: string;
}
export const GroupIdentifier = S.suspend(() =>
  S.Struct({
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
    GroupName: S.optional(S.String).pipe(
      T.XmlName("groupName"),
      T.Ec2QueryName("GroupName"),
    ),
  }),
).annotate({
  identifier: "GroupIdentifier",
}) as any as S.Schema<GroupIdentifier>;
export type GroupIdentifierList = GroupIdentifier[];
export const GroupIdentifierList = S.Array(
  GroupIdentifier.pipe(T.XmlName("item")).annotate({
    identifier: "GroupIdentifier",
  }),
);
export type NetworkInterfaceType =
  | "interface"
  | "natGateway"
  | "efa"
  | "efa-only"
  | "trunk"
  | "load_balancer"
  | "network_load_balancer"
  | "vpc_endpoint"
  | "branch"
  | "transit_gateway"
  | "lambda"
  | "quicksight"
  | "global_accelerator_managed"
  | "api_gateway_managed"
  | "gateway_load_balancer"
  | "gateway_load_balancer_endpoint"
  | "iot_rules_managed"
  | "aws_codestar_connections_managed"
  | (string & {});
export const NetworkInterfaceType = S.String;
export interface NetworkInterfaceIpv6Address {
  Ipv6Address?: string;
  PublicIpv6DnsName?: string;
  IsPrimaryIpv6?: boolean;
}
export const NetworkInterfaceIpv6Address = S.suspend(() =>
  S.Struct({
    Ipv6Address: S.optional(S.String).pipe(
      T.XmlName("ipv6Address"),
      T.Ec2QueryName("Ipv6Address"),
    ),
    PublicIpv6DnsName: S.optional(S.String).pipe(
      T.XmlName("publicIpv6DnsName"),
      T.Ec2QueryName("PublicIpv6DnsName"),
    ),
    IsPrimaryIpv6: S.optional(S.Boolean).pipe(
      T.XmlName("isPrimaryIpv6"),
      T.Ec2QueryName("IsPrimaryIpv6"),
    ),
  }),
).annotate({
  identifier: "NetworkInterfaceIpv6Address",
}) as any as S.Schema<NetworkInterfaceIpv6Address>;
export type NetworkInterfaceIpv6AddressesList = NetworkInterfaceIpv6Address[];
export const NetworkInterfaceIpv6AddressesList = S.Array(
  NetworkInterfaceIpv6Address.pipe(T.XmlName("item")).annotate({
    identifier: "NetworkInterfaceIpv6Address",
  }),
);
export interface PublicIpDnsNameOptions {
  DnsHostnameType?: string;
  PublicIpv4DnsName?: string;
  PublicIpv6DnsName?: string;
  PublicDualStackDnsName?: string;
}
export const PublicIpDnsNameOptions = S.suspend(() =>
  S.Struct({
    DnsHostnameType: S.optional(S.String).pipe(
      T.XmlName("dnsHostnameType"),
      T.Ec2QueryName("DnsHostnameType"),
    ),
    PublicIpv4DnsName: S.optional(S.String).pipe(
      T.XmlName("publicIpv4DnsName"),
      T.Ec2QueryName("PublicIpv4DnsName"),
    ),
    PublicIpv6DnsName: S.optional(S.String).pipe(
      T.XmlName("publicIpv6DnsName"),
      T.Ec2QueryName("PublicIpv6DnsName"),
    ),
    PublicDualStackDnsName: S.optional(S.String).pipe(
      T.XmlName("publicDualStackDnsName"),
      T.Ec2QueryName("PublicDualStackDnsName"),
    ),
  }),
).annotate({
  identifier: "PublicIpDnsNameOptions",
}) as any as S.Schema<PublicIpDnsNameOptions>;
export interface NetworkInterfacePrivateIpAddress {
  Association?: NetworkInterfaceAssociation;
  Primary?: boolean;
  PrivateDnsName?: string;
  PrivateIpAddress?: string;
}
export const NetworkInterfacePrivateIpAddress = S.suspend(() =>
  S.Struct({
    Association: S.optional(NetworkInterfaceAssociation)
      .pipe(T.XmlName("association"), T.Ec2QueryName("Association"))
      .annotate({ identifier: "NetworkInterfaceAssociation" }),
    Primary: S.optional(S.Boolean).pipe(
      T.XmlName("primary"),
      T.Ec2QueryName("Primary"),
    ),
    PrivateDnsName: S.optional(S.String).pipe(
      T.XmlName("privateDnsName"),
      T.Ec2QueryName("PrivateDnsName"),
    ),
    PrivateIpAddress: S.optional(S.String).pipe(
      T.XmlName("privateIpAddress"),
      T.Ec2QueryName("PrivateIpAddress"),
    ),
  }),
).annotate({
  identifier: "NetworkInterfacePrivateIpAddress",
}) as any as S.Schema<NetworkInterfacePrivateIpAddress>;
export type NetworkInterfacePrivateIpAddressList =
  NetworkInterfacePrivateIpAddress[];
export const NetworkInterfacePrivateIpAddressList = S.Array(
  NetworkInterfacePrivateIpAddress.pipe(T.XmlName("item")).annotate({
    identifier: "NetworkInterfacePrivateIpAddress",
  }),
);
export interface Ipv6PrefixSpecification {
  Ipv6Prefix?: string;
}
export const Ipv6PrefixSpecification = S.suspend(() =>
  S.Struct({
    Ipv6Prefix: S.optional(S.String).pipe(
      T.XmlName("ipv6Prefix"),
      T.Ec2QueryName("Ipv6Prefix"),
    ),
  }),
).annotate({
  identifier: "Ipv6PrefixSpecification",
}) as any as S.Schema<Ipv6PrefixSpecification>;
export type Ipv6PrefixesList = Ipv6PrefixSpecification[];
export const Ipv6PrefixesList = S.Array(
  Ipv6PrefixSpecification.pipe(T.XmlName("item")).annotate({
    identifier: "Ipv6PrefixSpecification",
  }),
);
export type NetworkInterfaceStatus =
  | "available"
  | "associated"
  | "attaching"
  | "in-use"
  | "detaching"
  | (string & {});
export const NetworkInterfaceStatus = S.String;
export type AssociatedSubnetList = string[];
export const AssociatedSubnetList = S.Array(S.String.pipe(T.XmlName("item")));
export interface NetworkInterface {
  Association?: NetworkInterfaceAssociation;
  Attachment?: NetworkInterfaceAttachment;
  AvailabilityZone?: string;
  ConnectionTrackingConfiguration?: ConnectionTrackingConfiguration;
  Description?: string;
  Groups?: GroupIdentifier[];
  InterfaceType?: NetworkInterfaceType;
  Ipv6Addresses?: NetworkInterfaceIpv6Address[];
  MacAddress?: string;
  NetworkInterfaceId?: string;
  OutpostArn?: string;
  OwnerId?: string;
  PrivateDnsName?: string;
  PublicDnsName?: string;
  PublicIpDnsNameOptions?: PublicIpDnsNameOptions;
  PrivateIpAddress?: string;
  PrivateIpAddresses?: NetworkInterfacePrivateIpAddress[];
  Ipv4Prefixes?: Ipv4PrefixSpecification[];
  Ipv6Prefixes?: Ipv6PrefixSpecification[];
  RequesterId?: string;
  RequesterManaged?: boolean;
  SourceDestCheck?: boolean;
  Status?: NetworkInterfaceStatus;
  SubnetId?: string;
  TagSet?: Tag[];
  VpcId?: string;
  DenyAllIgwTraffic?: boolean;
  Ipv6Native?: boolean;
  Ipv6Address?: string;
  Operator?: OperatorResponse;
  AssociatedSubnets?: string[];
  AvailabilityZoneId?: string;
}
export const NetworkInterface = S.suspend(() =>
  S.Struct({
    Association: S.optional(NetworkInterfaceAssociation)
      .pipe(T.XmlName("association"), T.Ec2QueryName("Association"))
      .annotate({ identifier: "NetworkInterfaceAssociation" }),
    Attachment: S.optional(NetworkInterfaceAttachment)
      .pipe(T.XmlName("attachment"), T.Ec2QueryName("Attachment"))
      .annotate({ identifier: "NetworkInterfaceAttachment" }),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    ConnectionTrackingConfiguration: S.optional(ConnectionTrackingConfiguration)
      .pipe(
        T.XmlName("connectionTrackingConfiguration"),
        T.Ec2QueryName("ConnectionTrackingConfiguration"),
      )
      .annotate({ identifier: "ConnectionTrackingConfiguration" }),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    Groups: S.optional(GroupIdentifierList).pipe(
      T.XmlName("groupSet"),
      T.Ec2QueryName("GroupSet"),
    ),
    InterfaceType: S.optional(NetworkInterfaceType).pipe(
      T.XmlName("interfaceType"),
      T.Ec2QueryName("InterfaceType"),
    ),
    Ipv6Addresses: S.optional(NetworkInterfaceIpv6AddressesList).pipe(
      T.XmlName("ipv6AddressesSet"),
      T.Ec2QueryName("Ipv6AddressesSet"),
    ),
    MacAddress: S.optional(S.String).pipe(
      T.XmlName("macAddress"),
      T.Ec2QueryName("MacAddress"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    OutpostArn: S.optional(S.String).pipe(
      T.XmlName("outpostArn"),
      T.Ec2QueryName("OutpostArn"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    PrivateDnsName: S.optional(S.String).pipe(
      T.XmlName("privateDnsName"),
      T.Ec2QueryName("PrivateDnsName"),
    ),
    PublicDnsName: S.optional(S.String).pipe(
      T.XmlName("publicDnsName"),
      T.Ec2QueryName("PublicDnsName"),
    ),
    PublicIpDnsNameOptions: S.optional(PublicIpDnsNameOptions)
      .pipe(
        T.XmlName("publicIpDnsNameOptions"),
        T.Ec2QueryName("PublicIpDnsNameOptions"),
      )
      .annotate({ identifier: "PublicIpDnsNameOptions" }),
    PrivateIpAddress: S.optional(S.String).pipe(
      T.XmlName("privateIpAddress"),
      T.Ec2QueryName("PrivateIpAddress"),
    ),
    PrivateIpAddresses: S.optional(NetworkInterfacePrivateIpAddressList).pipe(
      T.XmlName("privateIpAddressesSet"),
      T.Ec2QueryName("PrivateIpAddressesSet"),
    ),
    Ipv4Prefixes: S.optional(Ipv4PrefixesList).pipe(
      T.XmlName("ipv4PrefixSet"),
      T.Ec2QueryName("Ipv4PrefixSet"),
    ),
    Ipv6Prefixes: S.optional(Ipv6PrefixesList).pipe(
      T.XmlName("ipv6PrefixSet"),
      T.Ec2QueryName("Ipv6PrefixSet"),
    ),
    RequesterId: S.optional(S.String).pipe(
      T.XmlName("requesterId"),
      T.Ec2QueryName("RequesterId"),
    ),
    RequesterManaged: S.optional(S.Boolean).pipe(
      T.XmlName("requesterManaged"),
      T.Ec2QueryName("RequesterManaged"),
    ),
    SourceDestCheck: S.optional(S.Boolean).pipe(
      T.XmlName("sourceDestCheck"),
      T.Ec2QueryName("SourceDestCheck"),
    ),
    Status: S.optional(NetworkInterfaceStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    TagSet: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    DenyAllIgwTraffic: S.optional(S.Boolean).pipe(
      T.XmlName("denyAllIgwTraffic"),
      T.Ec2QueryName("DenyAllIgwTraffic"),
    ),
    Ipv6Native: S.optional(S.Boolean).pipe(
      T.XmlName("ipv6Native"),
      T.Ec2QueryName("Ipv6Native"),
    ),
    Ipv6Address: S.optional(S.String).pipe(
      T.XmlName("ipv6Address"),
      T.Ec2QueryName("Ipv6Address"),
    ),
    Operator: S.optional(OperatorResponse)
      .pipe(T.XmlName("operator"), T.Ec2QueryName("Operator"))
      .annotate({ identifier: "OperatorResponse" }),
    AssociatedSubnets: S.optional(AssociatedSubnetList).pipe(
      T.XmlName("associatedSubnetSet"),
      T.Ec2QueryName("AssociatedSubnetSet"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
  }),
).annotate({
  identifier: "NetworkInterface",
}) as any as S.Schema<NetworkInterface>;
export interface CreateNetworkInterfaceResult {
  NetworkInterface?: NetworkInterface;
  ClientToken?: string;
}
export const CreateNetworkInterfaceResult = S.suspend(() =>
  S.Struct({
    NetworkInterface: S.optional(NetworkInterface)
      .pipe(T.XmlName("networkInterface"), T.Ec2QueryName("NetworkInterface"))
      .annotate({ identifier: "NetworkInterface" }),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateNetworkInterfaceResult",
}) as any as S.Schema<CreateNetworkInterfaceResult>;
export type InterfacePermissionType =
  | "INSTANCE-ATTACH"
  | "EIP-ASSOCIATE"
  | (string & {});
export const InterfacePermissionType = S.String;
export interface CreateNetworkInterfacePermissionRequest {
  NetworkInterfaceId?: string;
  AwsAccountId?: string;
  AwsService?: string;
  Permission?: InterfacePermissionType;
  DryRun?: boolean;
}
export const CreateNetworkInterfacePermissionRequest = S.suspend(() =>
  S.Struct({
    NetworkInterfaceId: S.optional(S.String),
    AwsAccountId: S.optional(S.String),
    AwsService: S.optional(S.String),
    Permission: S.optional(InterfacePermissionType),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateNetworkInterfacePermissionRequest",
}) as any as S.Schema<CreateNetworkInterfacePermissionRequest>;
export type NetworkInterfacePermissionStateCode =
  | "pending"
  | "granted"
  | "revoking"
  | "revoked"
  | (string & {});
export const NetworkInterfacePermissionStateCode = S.String;
export interface NetworkInterfacePermissionState {
  State?: NetworkInterfacePermissionStateCode;
  StatusMessage?: string;
}
export const NetworkInterfacePermissionState = S.suspend(() =>
  S.Struct({
    State: S.optional(NetworkInterfacePermissionStateCode).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
  }),
).annotate({
  identifier: "NetworkInterfacePermissionState",
}) as any as S.Schema<NetworkInterfacePermissionState>;
export interface NetworkInterfacePermission {
  NetworkInterfacePermissionId?: string;
  NetworkInterfaceId?: string;
  AwsAccountId?: string;
  AwsService?: string;
  Permission?: InterfacePermissionType;
  PermissionState?: NetworkInterfacePermissionState;
}
export const NetworkInterfacePermission = S.suspend(() =>
  S.Struct({
    NetworkInterfacePermissionId: S.optional(S.String).pipe(
      T.XmlName("networkInterfacePermissionId"),
      T.Ec2QueryName("NetworkInterfacePermissionId"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    AwsAccountId: S.optional(S.String).pipe(
      T.XmlName("awsAccountId"),
      T.Ec2QueryName("AwsAccountId"),
    ),
    AwsService: S.optional(S.String).pipe(
      T.XmlName("awsService"),
      T.Ec2QueryName("AwsService"),
    ),
    Permission: S.optional(InterfacePermissionType).pipe(
      T.XmlName("permission"),
      T.Ec2QueryName("Permission"),
    ),
    PermissionState: S.optional(NetworkInterfacePermissionState)
      .pipe(T.XmlName("permissionState"), T.Ec2QueryName("PermissionState"))
      .annotate({ identifier: "NetworkInterfacePermissionState" }),
  }),
).annotate({
  identifier: "NetworkInterfacePermission",
}) as any as S.Schema<NetworkInterfacePermission>;
export interface CreateNetworkInterfacePermissionResult {
  InterfacePermission?: NetworkInterfacePermission;
}
export const CreateNetworkInterfacePermissionResult = S.suspend(() =>
  S.Struct({
    InterfacePermission: S.optional(NetworkInterfacePermission)
      .pipe(
        T.XmlName("interfacePermission"),
        T.Ec2QueryName("InterfacePermission"),
      )
      .annotate({ identifier: "NetworkInterfacePermission" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateNetworkInterfacePermissionResult",
}) as any as S.Schema<CreateNetworkInterfacePermissionResult>;
export type SpreadLevel = "host" | "rack" | (string & {});
export const SpreadLevel = S.String;
export type PlacementStrategy =
  | "cluster"
  | "spread"
  | "partition"
  | (string & {});
export const PlacementStrategy = S.String;
export interface CreatePlacementGroupRequest {
  PartitionCount?: number;
  TagSpecifications?: TagSpecification[];
  SpreadLevel?: SpreadLevel;
  LinkedGroupId?: string;
  Operator?: OperatorRequest;
  DryRun?: boolean;
  GroupName?: string;
  Strategy?: PlacementStrategy;
}
export const CreatePlacementGroupRequest = S.suspend(() =>
  S.Struct({
    PartitionCount: S.optional(S.Number),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    SpreadLevel: S.optional(SpreadLevel),
    LinkedGroupId: S.optional(S.String),
    Operator: S.optional(OperatorRequest),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    GroupName: S.optional(S.String).pipe(
      T.XmlName("groupName"),
      T.Ec2QueryName("GroupName"),
    ),
    Strategy: S.optional(PlacementStrategy).pipe(
      T.XmlName("strategy"),
      T.Ec2QueryName("Strategy"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreatePlacementGroupRequest",
}) as any as S.Schema<CreatePlacementGroupRequest>;
export type PlacementGroupState =
  | "pending"
  | "available"
  | "deleting"
  | "deleted"
  | (string & {});
export const PlacementGroupState = S.String;
export interface PlacementGroup {
  GroupName?: string;
  State?: PlacementGroupState;
  Strategy?: PlacementStrategy;
  PartitionCount?: number;
  GroupId?: string;
  Tags?: Tag[];
  GroupArn?: string;
  SpreadLevel?: SpreadLevel;
  LinkedGroupId?: string;
  Operator?: OperatorResponse;
}
export const PlacementGroup = S.suspend(() =>
  S.Struct({
    GroupName: S.optional(S.String).pipe(
      T.XmlName("groupName"),
      T.Ec2QueryName("GroupName"),
    ),
    State: S.optional(PlacementGroupState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Strategy: S.optional(PlacementStrategy).pipe(
      T.XmlName("strategy"),
      T.Ec2QueryName("Strategy"),
    ),
    PartitionCount: S.optional(S.Number).pipe(
      T.XmlName("partitionCount"),
      T.Ec2QueryName("PartitionCount"),
    ),
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    GroupArn: S.optional(S.String).pipe(
      T.XmlName("groupArn"),
      T.Ec2QueryName("GroupArn"),
    ),
    SpreadLevel: S.optional(SpreadLevel).pipe(
      T.XmlName("spreadLevel"),
      T.Ec2QueryName("SpreadLevel"),
    ),
    LinkedGroupId: S.optional(S.String).pipe(
      T.XmlName("linkedGroupId"),
      T.Ec2QueryName("LinkedGroupId"),
    ),
    Operator: S.optional(OperatorResponse)
      .pipe(T.XmlName("operator"), T.Ec2QueryName("Operator"))
      .annotate({ identifier: "OperatorResponse" }),
  }),
).annotate({ identifier: "PlacementGroup" }) as any as S.Schema<PlacementGroup>;
export interface CreatePlacementGroupResult {
  PlacementGroup?: PlacementGroup;
}
export const CreatePlacementGroupResult = S.suspend(() =>
  S.Struct({
    PlacementGroup: S.optional(PlacementGroup)
      .pipe(T.XmlName("placementGroup"), T.Ec2QueryName("PlacementGroup"))
      .annotate({ identifier: "PlacementGroup" }),
  }).pipe(ns),
).annotate({
  identifier: "CreatePlacementGroupResult",
}) as any as S.Schema<CreatePlacementGroupResult>;
export interface CreatePublicIpv4PoolRequest {
  DryRun?: boolean;
  TagSpecifications?: TagSpecification[];
  NetworkBorderGroup?: string;
}
export const CreatePublicIpv4PoolRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    NetworkBorderGroup: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreatePublicIpv4PoolRequest",
}) as any as S.Schema<CreatePublicIpv4PoolRequest>;
export interface CreatePublicIpv4PoolResult {
  PoolId?: string;
}
export const CreatePublicIpv4PoolResult = S.suspend(() =>
  S.Struct({
    PoolId: S.optional(S.String).pipe(
      T.XmlName("poolId"),
      T.Ec2QueryName("PoolId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreatePublicIpv4PoolResult",
}) as any as S.Schema<CreatePublicIpv4PoolResult>;
export interface CreateReplaceRootVolumeTaskRequest {
  InstanceId?: string;
  SnapshotId?: string;
  ClientToken?: string;
  DryRun?: boolean;
  TagSpecifications?: TagSpecification[];
  ImageId?: string;
  DeleteReplacedRootVolume?: boolean;
  VolumeInitializationRate?: number;
}
export const CreateReplaceRootVolumeTaskRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    SnapshotId: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ImageId: S.optional(S.String),
    DeleteReplacedRootVolume: S.optional(S.Boolean),
    VolumeInitializationRate: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateReplaceRootVolumeTaskRequest",
}) as any as S.Schema<CreateReplaceRootVolumeTaskRequest>;
export type ReplaceRootVolumeTaskState =
  | "pending"
  | "in-progress"
  | "failing"
  | "succeeded"
  | "failed"
  | "failed-detached"
  | (string & {});
export const ReplaceRootVolumeTaskState = S.String;
export interface ReplaceRootVolumeTask {
  ReplaceRootVolumeTaskId?: string;
  InstanceId?: string;
  TaskState?: ReplaceRootVolumeTaskState;
  StartTime?: string;
  CompleteTime?: string;
  Tags?: Tag[];
  ImageId?: string;
  SnapshotId?: string;
  DeleteReplacedRootVolume?: boolean;
}
export const ReplaceRootVolumeTask = S.suspend(() =>
  S.Struct({
    ReplaceRootVolumeTaskId: S.optional(S.String).pipe(
      T.XmlName("replaceRootVolumeTaskId"),
      T.Ec2QueryName("ReplaceRootVolumeTaskId"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    TaskState: S.optional(ReplaceRootVolumeTaskState).pipe(
      T.XmlName("taskState"),
      T.Ec2QueryName("TaskState"),
    ),
    StartTime: S.optional(S.String).pipe(
      T.XmlName("startTime"),
      T.Ec2QueryName("StartTime"),
    ),
    CompleteTime: S.optional(S.String).pipe(
      T.XmlName("completeTime"),
      T.Ec2QueryName("CompleteTime"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    DeleteReplacedRootVolume: S.optional(S.Boolean).pipe(
      T.XmlName("deleteReplacedRootVolume"),
      T.Ec2QueryName("DeleteReplacedRootVolume"),
    ),
  }),
).annotate({
  identifier: "ReplaceRootVolumeTask",
}) as any as S.Schema<ReplaceRootVolumeTask>;
export interface CreateReplaceRootVolumeTaskResult {
  ReplaceRootVolumeTask?: ReplaceRootVolumeTask;
}
export const CreateReplaceRootVolumeTaskResult = S.suspend(() =>
  S.Struct({
    ReplaceRootVolumeTask: S.optional(ReplaceRootVolumeTask)
      .pipe(
        T.XmlName("replaceRootVolumeTask"),
        T.Ec2QueryName("ReplaceRootVolumeTask"),
      )
      .annotate({ identifier: "ReplaceRootVolumeTask" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateReplaceRootVolumeTaskResult",
}) as any as S.Schema<CreateReplaceRootVolumeTaskResult>;
export interface PriceScheduleSpecification {
  Term?: number;
  Price?: number;
  CurrencyCode?: CurrencyCodeValues;
}
export const PriceScheduleSpecification = S.suspend(() =>
  S.Struct({
    Term: S.optional(S.Number).pipe(T.XmlName("term"), T.Ec2QueryName("Term")),
    Price: S.optional(S.Number).pipe(
      T.XmlName("price"),
      T.Ec2QueryName("Price"),
    ),
    CurrencyCode: S.optional(CurrencyCodeValues).pipe(
      T.XmlName("currencyCode"),
      T.Ec2QueryName("CurrencyCode"),
    ),
  }),
).annotate({
  identifier: "PriceScheduleSpecification",
}) as any as S.Schema<PriceScheduleSpecification>;
export type PriceScheduleSpecificationList = PriceScheduleSpecification[];
export const PriceScheduleSpecificationList = S.Array(
  PriceScheduleSpecification.pipe(T.XmlName("item")).annotate({
    identifier: "PriceScheduleSpecification",
  }),
);
export interface CreateReservedInstancesListingRequest {
  ReservedInstancesId?: string;
  InstanceCount?: number;
  PriceSchedules?: PriceScheduleSpecification[];
  ClientToken?: string;
}
export const CreateReservedInstancesListingRequest = S.suspend(() =>
  S.Struct({
    ReservedInstancesId: S.optional(S.String).pipe(
      T.XmlName("reservedInstancesId"),
      T.Ec2QueryName("ReservedInstancesId"),
    ),
    InstanceCount: S.optional(S.Number).pipe(
      T.XmlName("instanceCount"),
      T.Ec2QueryName("InstanceCount"),
    ),
    PriceSchedules: S.optional(PriceScheduleSpecificationList).pipe(
      T.XmlName("priceSchedules"),
      T.Ec2QueryName("PriceSchedules"),
    ),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateReservedInstancesListingRequest",
}) as any as S.Schema<CreateReservedInstancesListingRequest>;
export interface CreateReservedInstancesListingResult {
  ReservedInstancesListings?: ReservedInstancesListing[];
}
export const CreateReservedInstancesListingResult = S.suspend(() =>
  S.Struct({
    ReservedInstancesListings: S.optional(ReservedInstancesListingList).pipe(
      T.XmlName("reservedInstancesListingsSet"),
      T.Ec2QueryName("ReservedInstancesListingsSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateReservedInstancesListingResult",
}) as any as S.Schema<CreateReservedInstancesListingResult>;
export interface CreateRestoreImageTaskRequest {
  Bucket?: string;
  ObjectKey?: string;
  Name?: string;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateRestoreImageTaskRequest = S.suspend(() =>
  S.Struct({
    Bucket: S.optional(S.String),
    ObjectKey: S.optional(S.String),
    Name: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateRestoreImageTaskRequest",
}) as any as S.Schema<CreateRestoreImageTaskRequest>;
export interface CreateRestoreImageTaskResult {
  ImageId?: string;
}
export const CreateRestoreImageTaskResult = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateRestoreImageTaskResult",
}) as any as S.Schema<CreateRestoreImageTaskResult>;
export interface CreateRouteRequest {
  DestinationPrefixListId?: string;
  VpcEndpointId?: string;
  TransitGatewayId?: string;
  LocalGatewayId?: string;
  CarrierGatewayId?: string;
  CoreNetworkArn?: string;
  OdbNetworkArn?: string;
  DryRun?: boolean;
  RouteTableId?: string;
  DestinationCidrBlock?: string;
  GatewayId?: string;
  DestinationIpv6CidrBlock?: string;
  EgressOnlyInternetGatewayId?: string;
  InstanceId?: string;
  NetworkInterfaceId?: string;
  VpcPeeringConnectionId?: string;
  NatGatewayId?: string;
}
export const CreateRouteRequest = S.suspend(() =>
  S.Struct({
    DestinationPrefixListId: S.optional(S.String),
    VpcEndpointId: S.optional(S.String),
    TransitGatewayId: S.optional(S.String),
    LocalGatewayId: S.optional(S.String),
    CarrierGatewayId: S.optional(S.String),
    CoreNetworkArn: S.optional(S.String),
    OdbNetworkArn: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    RouteTableId: S.optional(S.String).pipe(
      T.XmlName("routeTableId"),
      T.Ec2QueryName("RouteTableId"),
    ),
    DestinationCidrBlock: S.optional(S.String).pipe(
      T.XmlName("destinationCidrBlock"),
      T.Ec2QueryName("DestinationCidrBlock"),
    ),
    GatewayId: S.optional(S.String).pipe(
      T.XmlName("gatewayId"),
      T.Ec2QueryName("GatewayId"),
    ),
    DestinationIpv6CidrBlock: S.optional(S.String).pipe(
      T.XmlName("destinationIpv6CidrBlock"),
      T.Ec2QueryName("DestinationIpv6CidrBlock"),
    ),
    EgressOnlyInternetGatewayId: S.optional(S.String).pipe(
      T.XmlName("egressOnlyInternetGatewayId"),
      T.Ec2QueryName("EgressOnlyInternetGatewayId"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    VpcPeeringConnectionId: S.optional(S.String).pipe(
      T.XmlName("vpcPeeringConnectionId"),
      T.Ec2QueryName("VpcPeeringConnectionId"),
    ),
    NatGatewayId: S.optional(S.String).pipe(
      T.XmlName("natGatewayId"),
      T.Ec2QueryName("NatGatewayId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateRouteRequest",
}) as any as S.Schema<CreateRouteRequest>;
export interface CreateRouteResult {
  Return?: boolean;
}
export const CreateRouteResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateRouteResult",
}) as any as S.Schema<CreateRouteResult>;
export type RouteServerPersistRoutesAction =
  | "enable"
  | "disable"
  | "reset"
  | (string & {});
export const RouteServerPersistRoutesAction = S.String;
export interface CreateRouteServerRequest {
  AmazonSideAsn?: number;
  ClientToken?: string;
  DryRun?: boolean;
  PersistRoutes?: RouteServerPersistRoutesAction;
  PersistRoutesDuration?: number;
  SnsNotificationsEnabled?: boolean;
  TagSpecifications?: TagSpecification[];
}
export const CreateRouteServerRequest = S.suspend(() =>
  S.Struct({
    AmazonSideAsn: S.optional(S.Number),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
    PersistRoutes: S.optional(RouteServerPersistRoutesAction),
    PersistRoutesDuration: S.optional(S.Number),
    SnsNotificationsEnabled: S.optional(S.Boolean),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateRouteServerRequest",
}) as any as S.Schema<CreateRouteServerRequest>;
export type RouteServerState =
  | "pending"
  | "available"
  | "modifying"
  | "deleting"
  | "deleted"
  | (string & {});
export const RouteServerState = S.String;
export type RouteServerPersistRoutesState =
  | "enabling"
  | "enabled"
  | "resetting"
  | "disabling"
  | "disabled"
  | "modifying"
  | (string & {});
export const RouteServerPersistRoutesState = S.String;
export interface RouteServer {
  RouteServerId?: string;
  AmazonSideAsn?: number;
  State?: RouteServerState;
  Tags?: Tag[];
  PersistRoutesState?: RouteServerPersistRoutesState;
  PersistRoutesDuration?: number;
  SnsNotificationsEnabled?: boolean;
  SnsTopicArn?: string;
}
export const RouteServer = S.suspend(() =>
  S.Struct({
    RouteServerId: S.optional(S.String).pipe(
      T.XmlName("routeServerId"),
      T.Ec2QueryName("RouteServerId"),
    ),
    AmazonSideAsn: S.optional(S.Number).pipe(
      T.XmlName("amazonSideAsn"),
      T.Ec2QueryName("AmazonSideAsn"),
    ),
    State: S.optional(RouteServerState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    PersistRoutesState: S.optional(RouteServerPersistRoutesState).pipe(
      T.XmlName("persistRoutesState"),
      T.Ec2QueryName("PersistRoutesState"),
    ),
    PersistRoutesDuration: S.optional(S.Number).pipe(
      T.XmlName("persistRoutesDuration"),
      T.Ec2QueryName("PersistRoutesDuration"),
    ),
    SnsNotificationsEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("snsNotificationsEnabled"),
      T.Ec2QueryName("SnsNotificationsEnabled"),
    ),
    SnsTopicArn: S.optional(S.String).pipe(
      T.XmlName("snsTopicArn"),
      T.Ec2QueryName("SnsTopicArn"),
    ),
  }),
).annotate({ identifier: "RouteServer" }) as any as S.Schema<RouteServer>;
export interface CreateRouteServerResult {
  RouteServer?: RouteServer;
}
export const CreateRouteServerResult = S.suspend(() =>
  S.Struct({
    RouteServer: S.optional(RouteServer)
      .pipe(T.XmlName("routeServer"), T.Ec2QueryName("RouteServer"))
      .annotate({ identifier: "RouteServer" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateRouteServerResult",
}) as any as S.Schema<CreateRouteServerResult>;
export interface CreateRouteServerEndpointRequest {
  RouteServerId?: string;
  SubnetId?: string;
  ClientToken?: string;
  DryRun?: boolean;
  TagSpecifications?: TagSpecification[];
}
export const CreateRouteServerEndpointRequest = S.suspend(() =>
  S.Struct({
    RouteServerId: S.optional(S.String),
    SubnetId: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateRouteServerEndpointRequest",
}) as any as S.Schema<CreateRouteServerEndpointRequest>;
export type RouteServerEndpointState =
  | "pending"
  | "available"
  | "deleting"
  | "deleted"
  | "failing"
  | "failed"
  | "delete-failed"
  | (string & {});
export const RouteServerEndpointState = S.String;
export interface RouteServerEndpoint {
  RouteServerId?: string;
  RouteServerEndpointId?: string;
  VpcId?: string;
  SubnetId?: string;
  EniId?: string;
  EniAddress?: string;
  State?: RouteServerEndpointState;
  FailureReason?: string;
  Tags?: Tag[];
}
export const RouteServerEndpoint = S.suspend(() =>
  S.Struct({
    RouteServerId: S.optional(S.String).pipe(
      T.XmlName("routeServerId"),
      T.Ec2QueryName("RouteServerId"),
    ),
    RouteServerEndpointId: S.optional(S.String).pipe(
      T.XmlName("routeServerEndpointId"),
      T.Ec2QueryName("RouteServerEndpointId"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    EniId: S.optional(S.String).pipe(
      T.XmlName("eniId"),
      T.Ec2QueryName("EniId"),
    ),
    EniAddress: S.optional(S.String).pipe(
      T.XmlName("eniAddress"),
      T.Ec2QueryName("EniAddress"),
    ),
    State: S.optional(RouteServerEndpointState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    FailureReason: S.optional(S.String).pipe(
      T.XmlName("failureReason"),
      T.Ec2QueryName("FailureReason"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "RouteServerEndpoint",
}) as any as S.Schema<RouteServerEndpoint>;
export interface CreateRouteServerEndpointResult {
  RouteServerEndpoint?: RouteServerEndpoint;
}
export const CreateRouteServerEndpointResult = S.suspend(() =>
  S.Struct({
    RouteServerEndpoint: S.optional(RouteServerEndpoint)
      .pipe(
        T.XmlName("routeServerEndpoint"),
        T.Ec2QueryName("RouteServerEndpoint"),
      )
      .annotate({ identifier: "RouteServerEndpoint" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateRouteServerEndpointResult",
}) as any as S.Schema<CreateRouteServerEndpointResult>;
export type RouteServerPeerLivenessMode =
  | "bfd"
  | "bgp-keepalive"
  | (string & {});
export const RouteServerPeerLivenessMode = S.String;
export interface RouteServerBgpOptionsRequest {
  PeerAsn?: number;
  PeerLivenessDetection?: RouteServerPeerLivenessMode;
}
export const RouteServerBgpOptionsRequest = S.suspend(() =>
  S.Struct({
    PeerAsn: S.optional(S.Number),
    PeerLivenessDetection: S.optional(RouteServerPeerLivenessMode),
  }),
).annotate({
  identifier: "RouteServerBgpOptionsRequest",
}) as any as S.Schema<RouteServerBgpOptionsRequest>;
export interface CreateRouteServerPeerRequest {
  RouteServerEndpointId?: string;
  PeerAddress?: string;
  BgpOptions?: RouteServerBgpOptionsRequest;
  DryRun?: boolean;
  TagSpecifications?: TagSpecification[];
}
export const CreateRouteServerPeerRequest = S.suspend(() =>
  S.Struct({
    RouteServerEndpointId: S.optional(S.String),
    PeerAddress: S.optional(S.String),
    BgpOptions: S.optional(RouteServerBgpOptionsRequest),
    DryRun: S.optional(S.Boolean),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateRouteServerPeerRequest",
}) as any as S.Schema<CreateRouteServerPeerRequest>;
export type RouteServerPeerState =
  | "pending"
  | "available"
  | "deleting"
  | "deleted"
  | "failing"
  | "failed"
  | (string & {});
export const RouteServerPeerState = S.String;
export interface RouteServerBgpOptions {
  PeerAsn?: number;
  PeerLivenessDetection?: RouteServerPeerLivenessMode;
}
export const RouteServerBgpOptions = S.suspend(() =>
  S.Struct({
    PeerAsn: S.optional(S.Number).pipe(
      T.XmlName("peerAsn"),
      T.Ec2QueryName("PeerAsn"),
    ),
    PeerLivenessDetection: S.optional(RouteServerPeerLivenessMode).pipe(
      T.XmlName("peerLivenessDetection"),
      T.Ec2QueryName("PeerLivenessDetection"),
    ),
  }),
).annotate({
  identifier: "RouteServerBgpOptions",
}) as any as S.Schema<RouteServerBgpOptions>;
export type RouteServerBgpState = "up" | "down" | (string & {});
export const RouteServerBgpState = S.String;
export interface RouteServerBgpStatus {
  Status?: RouteServerBgpState;
}
export const RouteServerBgpStatus = S.suspend(() =>
  S.Struct({
    Status: S.optional(RouteServerBgpState).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
  }),
).annotate({
  identifier: "RouteServerBgpStatus",
}) as any as S.Schema<RouteServerBgpStatus>;
export type RouteServerBfdState = "up" | "down" | (string & {});
export const RouteServerBfdState = S.String;
export interface RouteServerBfdStatus {
  Status?: RouteServerBfdState;
}
export const RouteServerBfdStatus = S.suspend(() =>
  S.Struct({
    Status: S.optional(RouteServerBfdState).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
  }),
).annotate({
  identifier: "RouteServerBfdStatus",
}) as any as S.Schema<RouteServerBfdStatus>;
export interface RouteServerPeer {
  RouteServerPeerId?: string;
  RouteServerEndpointId?: string;
  RouteServerId?: string;
  VpcId?: string;
  SubnetId?: string;
  State?: RouteServerPeerState;
  FailureReason?: string;
  EndpointEniId?: string;
  EndpointEniAddress?: string;
  PeerAddress?: string;
  BgpOptions?: RouteServerBgpOptions;
  BgpStatus?: RouteServerBgpStatus;
  BfdStatus?: RouteServerBfdStatus;
  Tags?: Tag[];
}
export const RouteServerPeer = S.suspend(() =>
  S.Struct({
    RouteServerPeerId: S.optional(S.String).pipe(
      T.XmlName("routeServerPeerId"),
      T.Ec2QueryName("RouteServerPeerId"),
    ),
    RouteServerEndpointId: S.optional(S.String).pipe(
      T.XmlName("routeServerEndpointId"),
      T.Ec2QueryName("RouteServerEndpointId"),
    ),
    RouteServerId: S.optional(S.String).pipe(
      T.XmlName("routeServerId"),
      T.Ec2QueryName("RouteServerId"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    State: S.optional(RouteServerPeerState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    FailureReason: S.optional(S.String).pipe(
      T.XmlName("failureReason"),
      T.Ec2QueryName("FailureReason"),
    ),
    EndpointEniId: S.optional(S.String).pipe(
      T.XmlName("endpointEniId"),
      T.Ec2QueryName("EndpointEniId"),
    ),
    EndpointEniAddress: S.optional(S.String).pipe(
      T.XmlName("endpointEniAddress"),
      T.Ec2QueryName("EndpointEniAddress"),
    ),
    PeerAddress: S.optional(S.String).pipe(
      T.XmlName("peerAddress"),
      T.Ec2QueryName("PeerAddress"),
    ),
    BgpOptions: S.optional(RouteServerBgpOptions)
      .pipe(T.XmlName("bgpOptions"), T.Ec2QueryName("BgpOptions"))
      .annotate({ identifier: "RouteServerBgpOptions" }),
    BgpStatus: S.optional(RouteServerBgpStatus)
      .pipe(T.XmlName("bgpStatus"), T.Ec2QueryName("BgpStatus"))
      .annotate({ identifier: "RouteServerBgpStatus" }),
    BfdStatus: S.optional(RouteServerBfdStatus)
      .pipe(T.XmlName("bfdStatus"), T.Ec2QueryName("BfdStatus"))
      .annotate({ identifier: "RouteServerBfdStatus" }),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "RouteServerPeer",
}) as any as S.Schema<RouteServerPeer>;
export interface CreateRouteServerPeerResult {
  RouteServerPeer?: RouteServerPeer;
}
export const CreateRouteServerPeerResult = S.suspend(() =>
  S.Struct({
    RouteServerPeer: S.optional(RouteServerPeer)
      .pipe(T.XmlName("routeServerPeer"), T.Ec2QueryName("RouteServerPeer"))
      .annotate({ identifier: "RouteServerPeer" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateRouteServerPeerResult",
}) as any as S.Schema<CreateRouteServerPeerResult>;
export interface CreateRouteTableRequest {
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
  DryRun?: boolean;
  VpcId?: string;
}
export const CreateRouteTableRequest = S.suspend(() =>
  S.Struct({
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateRouteTableRequest",
}) as any as S.Schema<CreateRouteTableRequest>;
export interface RouteTableAssociation {
  Main?: boolean;
  RouteTableAssociationId?: string;
  RouteTableId?: string;
  SubnetId?: string;
  GatewayId?: string;
  PublicIpv4Pool?: string;
  AssociationState?: RouteTableAssociationState;
}
export const RouteTableAssociation = S.suspend(() =>
  S.Struct({
    Main: S.optional(S.Boolean).pipe(T.XmlName("main"), T.Ec2QueryName("Main")),
    RouteTableAssociationId: S.optional(S.String).pipe(
      T.XmlName("routeTableAssociationId"),
      T.Ec2QueryName("RouteTableAssociationId"),
    ),
    RouteTableId: S.optional(S.String).pipe(
      T.XmlName("routeTableId"),
      T.Ec2QueryName("RouteTableId"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    GatewayId: S.optional(S.String).pipe(
      T.XmlName("gatewayId"),
      T.Ec2QueryName("GatewayId"),
    ),
    PublicIpv4Pool: S.optional(S.String).pipe(
      T.XmlName("publicIpv4Pool"),
      T.Ec2QueryName("PublicIpv4Pool"),
    ),
    AssociationState: S.optional(RouteTableAssociationState)
      .pipe(T.XmlName("associationState"), T.Ec2QueryName("AssociationState"))
      .annotate({ identifier: "RouteTableAssociationState" }),
  }),
).annotate({
  identifier: "RouteTableAssociation",
}) as any as S.Schema<RouteTableAssociation>;
export type RouteTableAssociationList = RouteTableAssociation[];
export const RouteTableAssociationList = S.Array(
  RouteTableAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "RouteTableAssociation",
  }),
);
export interface PropagatingVgw {
  GatewayId?: string;
}
export const PropagatingVgw = S.suspend(() =>
  S.Struct({
    GatewayId: S.optional(S.String).pipe(
      T.XmlName("gatewayId"),
      T.Ec2QueryName("GatewayId"),
    ),
  }),
).annotate({ identifier: "PropagatingVgw" }) as any as S.Schema<PropagatingVgw>;
export type PropagatingVgwList = PropagatingVgw[];
export const PropagatingVgwList = S.Array(
  PropagatingVgw.pipe(T.XmlName("item")).annotate({
    identifier: "PropagatingVgw",
  }),
);
export type RouteOrigin =
  | "CreateRouteTable"
  | "CreateRoute"
  | "EnableVgwRoutePropagation"
  | "Advertisement"
  | (string & {});
export const RouteOrigin = S.String;
export type RouteState = "active" | "blackhole" | "filtered" | (string & {});
export const RouteState = S.String;
export interface Route {
  DestinationCidrBlock?: string;
  DestinationIpv6CidrBlock?: string;
  DestinationPrefixListId?: string;
  EgressOnlyInternetGatewayId?: string;
  GatewayId?: string;
  InstanceId?: string;
  InstanceOwnerId?: string;
  NatGatewayId?: string;
  TransitGatewayId?: string;
  LocalGatewayId?: string;
  CarrierGatewayId?: string;
  NetworkInterfaceId?: string;
  Origin?: RouteOrigin;
  State?: RouteState;
  VpcPeeringConnectionId?: string;
  CoreNetworkArn?: string;
  OdbNetworkArn?: string;
  IpAddress?: string;
}
export const Route = S.suspend(() =>
  S.Struct({
    DestinationCidrBlock: S.optional(S.String).pipe(
      T.XmlName("destinationCidrBlock"),
      T.Ec2QueryName("DestinationCidrBlock"),
    ),
    DestinationIpv6CidrBlock: S.optional(S.String).pipe(
      T.XmlName("destinationIpv6CidrBlock"),
      T.Ec2QueryName("DestinationIpv6CidrBlock"),
    ),
    DestinationPrefixListId: S.optional(S.String).pipe(
      T.XmlName("destinationPrefixListId"),
      T.Ec2QueryName("DestinationPrefixListId"),
    ),
    EgressOnlyInternetGatewayId: S.optional(S.String).pipe(
      T.XmlName("egressOnlyInternetGatewayId"),
      T.Ec2QueryName("EgressOnlyInternetGatewayId"),
    ),
    GatewayId: S.optional(S.String).pipe(
      T.XmlName("gatewayId"),
      T.Ec2QueryName("GatewayId"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    InstanceOwnerId: S.optional(S.String).pipe(
      T.XmlName("instanceOwnerId"),
      T.Ec2QueryName("InstanceOwnerId"),
    ),
    NatGatewayId: S.optional(S.String).pipe(
      T.XmlName("natGatewayId"),
      T.Ec2QueryName("NatGatewayId"),
    ),
    TransitGatewayId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayId"),
      T.Ec2QueryName("TransitGatewayId"),
    ),
    LocalGatewayId: S.optional(S.String).pipe(
      T.XmlName("localGatewayId"),
      T.Ec2QueryName("LocalGatewayId"),
    ),
    CarrierGatewayId: S.optional(S.String).pipe(
      T.XmlName("carrierGatewayId"),
      T.Ec2QueryName("CarrierGatewayId"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    Origin: S.optional(RouteOrigin).pipe(
      T.XmlName("origin"),
      T.Ec2QueryName("Origin"),
    ),
    State: S.optional(RouteState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    VpcPeeringConnectionId: S.optional(S.String).pipe(
      T.XmlName("vpcPeeringConnectionId"),
      T.Ec2QueryName("VpcPeeringConnectionId"),
    ),
    CoreNetworkArn: S.optional(S.String).pipe(
      T.XmlName("coreNetworkArn"),
      T.Ec2QueryName("CoreNetworkArn"),
    ),
    OdbNetworkArn: S.optional(S.String).pipe(
      T.XmlName("odbNetworkArn"),
      T.Ec2QueryName("OdbNetworkArn"),
    ),
    IpAddress: S.optional(S.String).pipe(
      T.XmlName("ipAddress"),
      T.Ec2QueryName("IpAddress"),
    ),
  }),
).annotate({ identifier: "Route" }) as any as S.Schema<Route>;
export type RouteList = Route[];
export const RouteList = S.Array(
  Route.pipe(T.XmlName("item")).annotate({ identifier: "Route" }),
);
export interface RouteTable {
  Associations?: RouteTableAssociation[];
  PropagatingVgws?: PropagatingVgw[];
  RouteTableId?: string;
  Routes?: Route[];
  Tags?: Tag[];
  VpcId?: string;
  OwnerId?: string;
}
export const RouteTable = S.suspend(() =>
  S.Struct({
    Associations: S.optional(RouteTableAssociationList).pipe(
      T.XmlName("associationSet"),
      T.Ec2QueryName("AssociationSet"),
    ),
    PropagatingVgws: S.optional(PropagatingVgwList).pipe(
      T.XmlName("propagatingVgwSet"),
      T.Ec2QueryName("PropagatingVgwSet"),
    ),
    RouteTableId: S.optional(S.String).pipe(
      T.XmlName("routeTableId"),
      T.Ec2QueryName("RouteTableId"),
    ),
    Routes: S.optional(RouteList).pipe(
      T.XmlName("routeSet"),
      T.Ec2QueryName("RouteSet"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
  }),
).annotate({ identifier: "RouteTable" }) as any as S.Schema<RouteTable>;
export interface CreateRouteTableResult {
  RouteTable?: RouteTable;
  ClientToken?: string;
}
export const CreateRouteTableResult = S.suspend(() =>
  S.Struct({
    RouteTable: S.optional(RouteTable)
      .pipe(T.XmlName("routeTable"), T.Ec2QueryName("RouteTable"))
      .annotate({ identifier: "RouteTable" }),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateRouteTableResult",
}) as any as S.Schema<CreateRouteTableResult>;
export type SecondaryNetworkType = "rdma" | (string & {});
export const SecondaryNetworkType = S.String;
export interface CreateSecondaryNetworkRequest {
  ClientToken?: string;
  DryRun?: boolean;
  Ipv4CidrBlock?: string;
  NetworkType?: SecondaryNetworkType;
  TagSpecifications?: TagSpecification[];
}
export const CreateSecondaryNetworkRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
    Ipv4CidrBlock: S.optional(S.String),
    NetworkType: S.optional(SecondaryNetworkType),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateSecondaryNetworkRequest",
}) as any as S.Schema<CreateSecondaryNetworkRequest>;
export type SecondaryNetworkState =
  | "create-in-progress"
  | "create-complete"
  | "create-failed"
  | "delete-in-progress"
  | "delete-complete"
  | "delete-failed"
  | (string & {});
export const SecondaryNetworkState = S.String;
export type SecondaryNetworkCidrBlockAssociationState =
  | "associating"
  | "associated"
  | "association-failed"
  | "disassociating"
  | "disassociated"
  | "disassociation-failed"
  | (string & {});
export const SecondaryNetworkCidrBlockAssociationState = S.String;
export interface SecondaryNetworkIpv4CidrBlockAssociation {
  AssociationId?: string;
  CidrBlock?: string;
  State?: SecondaryNetworkCidrBlockAssociationState;
  StateReason?: string;
}
export const SecondaryNetworkIpv4CidrBlockAssociation = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
    CidrBlock: S.optional(S.String).pipe(
      T.XmlName("cidrBlock"),
      T.Ec2QueryName("CidrBlock"),
    ),
    State: S.optional(SecondaryNetworkCidrBlockAssociationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StateReason: S.optional(S.String).pipe(
      T.XmlName("stateReason"),
      T.Ec2QueryName("StateReason"),
    ),
  }),
).annotate({
  identifier: "SecondaryNetworkIpv4CidrBlockAssociation",
}) as any as S.Schema<SecondaryNetworkIpv4CidrBlockAssociation>;
export type SecondaryNetworkIpv4CidrBlockAssociationList =
  SecondaryNetworkIpv4CidrBlockAssociation[];
export const SecondaryNetworkIpv4CidrBlockAssociationList = S.Array(
  SecondaryNetworkIpv4CidrBlockAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "SecondaryNetworkIpv4CidrBlockAssociation",
  }),
);
export interface SecondaryNetwork {
  SecondaryNetworkId?: string;
  SecondaryNetworkArn?: string;
  OwnerId?: string;
  Type?: SecondaryNetworkType;
  State?: SecondaryNetworkState;
  StateReason?: string;
  Ipv4CidrBlockAssociations?: SecondaryNetworkIpv4CidrBlockAssociation[];
  Tags?: Tag[];
}
export const SecondaryNetwork = S.suspend(() =>
  S.Struct({
    SecondaryNetworkId: S.optional(S.String).pipe(
      T.XmlName("secondaryNetworkId"),
      T.Ec2QueryName("SecondaryNetworkId"),
    ),
    SecondaryNetworkArn: S.optional(S.String).pipe(
      T.XmlName("secondaryNetworkArn"),
      T.Ec2QueryName("SecondaryNetworkArn"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    Type: S.optional(SecondaryNetworkType).pipe(
      T.XmlName("type"),
      T.Ec2QueryName("Type"),
    ),
    State: S.optional(SecondaryNetworkState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StateReason: S.optional(S.String).pipe(
      T.XmlName("stateReason"),
      T.Ec2QueryName("StateReason"),
    ),
    Ipv4CidrBlockAssociations: S.optional(
      SecondaryNetworkIpv4CidrBlockAssociationList,
    ).pipe(
      T.XmlName("ipv4CidrBlockAssociationSet"),
      T.Ec2QueryName("Ipv4CidrBlockAssociationSet"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "SecondaryNetwork",
}) as any as S.Schema<SecondaryNetwork>;
export interface CreateSecondaryNetworkResult {
  SecondaryNetwork?: SecondaryNetwork;
  ClientToken?: string;
}
export const CreateSecondaryNetworkResult = S.suspend(() =>
  S.Struct({
    SecondaryNetwork: S.optional(SecondaryNetwork)
      .pipe(T.XmlName("secondaryNetwork"), T.Ec2QueryName("SecondaryNetwork"))
      .annotate({ identifier: "SecondaryNetwork" }),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateSecondaryNetworkResult",
}) as any as S.Schema<CreateSecondaryNetworkResult>;
export interface CreateSecondarySubnetRequest {
  ClientToken?: string;
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  DryRun?: boolean;
  Ipv4CidrBlock?: string;
  SecondaryNetworkId?: string;
  TagSpecifications?: TagSpecification[];
}
export const CreateSecondarySubnetRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    AvailabilityZone: S.optional(S.String),
    AvailabilityZoneId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    Ipv4CidrBlock: S.optional(S.String),
    SecondaryNetworkId: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateSecondarySubnetRequest",
}) as any as S.Schema<CreateSecondarySubnetRequest>;
export type SecondarySubnetCidrBlockAssociationState =
  | "associating"
  | "associated"
  | "association-failed"
  | "disassociating"
  | "disassociated"
  | "disassociation-failed"
  | (string & {});
export const SecondarySubnetCidrBlockAssociationState = S.String;
export interface SecondarySubnetIpv4CidrBlockAssociation {
  AssociationId?: string;
  CidrBlock?: string;
  State?: SecondarySubnetCidrBlockAssociationState;
  StateReason?: string;
}
export const SecondarySubnetIpv4CidrBlockAssociation = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
    CidrBlock: S.optional(S.String).pipe(
      T.XmlName("cidrBlock"),
      T.Ec2QueryName("CidrBlock"),
    ),
    State: S.optional(SecondarySubnetCidrBlockAssociationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StateReason: S.optional(S.String).pipe(
      T.XmlName("stateReason"),
      T.Ec2QueryName("StateReason"),
    ),
  }),
).annotate({
  identifier: "SecondarySubnetIpv4CidrBlockAssociation",
}) as any as S.Schema<SecondarySubnetIpv4CidrBlockAssociation>;
export type SecondarySubnetIpv4CidrBlockAssociationList =
  SecondarySubnetIpv4CidrBlockAssociation[];
export const SecondarySubnetIpv4CidrBlockAssociationList = S.Array(
  SecondarySubnetIpv4CidrBlockAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "SecondarySubnetIpv4CidrBlockAssociation",
  }),
);
export type SecondarySubnetState =
  | "create-in-progress"
  | "create-complete"
  | "create-failed"
  | "delete-in-progress"
  | "delete-complete"
  | "delete-failed"
  | (string & {});
export const SecondarySubnetState = S.String;
export interface SecondarySubnet {
  SecondarySubnetId?: string;
  SecondarySubnetArn?: string;
  SecondaryNetworkId?: string;
  SecondaryNetworkType?: SecondaryNetworkType;
  OwnerId?: string;
  AvailabilityZoneId?: string;
  AvailabilityZone?: string;
  Ipv4CidrBlockAssociations?: SecondarySubnetIpv4CidrBlockAssociation[];
  State?: SecondarySubnetState;
  StateReason?: string;
  Tags?: Tag[];
}
export const SecondarySubnet = S.suspend(() =>
  S.Struct({
    SecondarySubnetId: S.optional(S.String).pipe(
      T.XmlName("secondarySubnetId"),
      T.Ec2QueryName("SecondarySubnetId"),
    ),
    SecondarySubnetArn: S.optional(S.String).pipe(
      T.XmlName("secondarySubnetArn"),
      T.Ec2QueryName("SecondarySubnetArn"),
    ),
    SecondaryNetworkId: S.optional(S.String).pipe(
      T.XmlName("secondaryNetworkId"),
      T.Ec2QueryName("SecondaryNetworkId"),
    ),
    SecondaryNetworkType: S.optional(SecondaryNetworkType).pipe(
      T.XmlName("secondaryNetworkType"),
      T.Ec2QueryName("SecondaryNetworkType"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    Ipv4CidrBlockAssociations: S.optional(
      SecondarySubnetIpv4CidrBlockAssociationList,
    ).pipe(
      T.XmlName("ipv4CidrBlockAssociationSet"),
      T.Ec2QueryName("Ipv4CidrBlockAssociationSet"),
    ),
    State: S.optional(SecondarySubnetState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StateReason: S.optional(S.String).pipe(
      T.XmlName("stateReason"),
      T.Ec2QueryName("StateReason"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "SecondarySubnet",
}) as any as S.Schema<SecondarySubnet>;
export interface CreateSecondarySubnetResult {
  SecondarySubnet?: SecondarySubnet;
  ClientToken?: string;
}
export const CreateSecondarySubnetResult = S.suspend(() =>
  S.Struct({
    SecondarySubnet: S.optional(SecondarySubnet)
      .pipe(T.XmlName("secondarySubnet"), T.Ec2QueryName("SecondarySubnet"))
      .annotate({ identifier: "SecondarySubnet" }),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateSecondarySubnetResult",
}) as any as S.Schema<CreateSecondarySubnetResult>;
export interface CreateSecurityGroupRequest {
  Description?: string;
  GroupName?: string;
  VpcId?: string;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateSecurityGroupRequest = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String).pipe(T.XmlName("GroupDescription")),
    GroupName: S.optional(S.String),
    VpcId: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateSecurityGroupRequest",
}) as any as S.Schema<CreateSecurityGroupRequest>;
export interface CreateSecurityGroupResult {
  GroupId?: string;
  Tags?: Tag[];
  SecurityGroupArn?: string;
}
export const CreateSecurityGroupResult = S.suspend(() =>
  S.Struct({
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    SecurityGroupArn: S.optional(S.String).pipe(
      T.XmlName("securityGroupArn"),
      T.Ec2QueryName("SecurityGroupArn"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateSecurityGroupResult",
}) as any as S.Schema<CreateSecurityGroupResult>;
export interface CreateSnapshotRequest {
  Description?: string;
  OutpostArn?: string;
  VolumeId?: string;
  TagSpecifications?: TagSpecification[];
  Location?: SnapshotLocationEnum;
  DryRun?: boolean;
}
export const CreateSnapshotRequest = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String),
    OutpostArn: S.optional(S.String),
    VolumeId: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    Location: S.optional(SnapshotLocationEnum),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateSnapshotRequest",
}) as any as S.Schema<CreateSnapshotRequest>;
export type StorageTier = "archive" | "standard" | (string & {});
export const StorageTier = S.String;
export type TransferType = "time-based" | "standard" | (string & {});
export const TransferType = S.String;
export type SnapshotState =
  | "pending"
  | "completed"
  | "error"
  | "recoverable"
  | "recovering"
  | (string & {});
export const SnapshotState = S.String;
export interface Snapshot {
  OwnerAlias?: string;
  OutpostArn?: string;
  Tags?: Tag[];
  StorageTier?: StorageTier;
  RestoreExpiryTime?: Date;
  SseType?: SSEType;
  AvailabilityZone?: string;
  TransferType?: TransferType;
  CompletionDurationMinutes?: number;
  CompletionTime?: Date;
  FullSnapshotSizeInBytes?: number;
  SnapshotId?: string;
  VolumeId?: string;
  State?: SnapshotState;
  StateMessage?: string;
  StartTime?: Date;
  Progress?: string;
  OwnerId?: string;
  Description?: string;
  VolumeSize?: number;
  Encrypted?: boolean;
  KmsKeyId?: string;
  DataEncryptionKeyId?: string;
}
export const Snapshot = S.suspend(() =>
  S.Struct({
    OwnerAlias: S.optional(S.String).pipe(
      T.XmlName("ownerAlias"),
      T.Ec2QueryName("OwnerAlias"),
    ),
    OutpostArn: S.optional(S.String).pipe(
      T.XmlName("outpostArn"),
      T.Ec2QueryName("OutpostArn"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    StorageTier: S.optional(StorageTier).pipe(
      T.XmlName("storageTier"),
      T.Ec2QueryName("StorageTier"),
    ),
    RestoreExpiryTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("restoreExpiryTime"), T.Ec2QueryName("RestoreExpiryTime")),
    SseType: S.optional(SSEType).pipe(
      T.XmlName("sseType"),
      T.Ec2QueryName("SseType"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    TransferType: S.optional(TransferType).pipe(
      T.XmlName("transferType"),
      T.Ec2QueryName("TransferType"),
    ),
    CompletionDurationMinutes: S.optional(S.Number).pipe(
      T.XmlName("completionDurationMinutes"),
      T.Ec2QueryName("CompletionDurationMinutes"),
    ),
    CompletionTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("completionTime"), T.Ec2QueryName("CompletionTime")),
    FullSnapshotSizeInBytes: S.optional(S.Number).pipe(
      T.XmlName("fullSnapshotSizeInBytes"),
      T.Ec2QueryName("FullSnapshotSizeInBytes"),
    ),
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    VolumeId: S.optional(S.String).pipe(
      T.XmlName("volumeId"),
      T.Ec2QueryName("VolumeId"),
    ),
    State: S.optional(SnapshotState).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    StateMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startTime"), T.Ec2QueryName("StartTime")),
    Progress: S.optional(S.String).pipe(
      T.XmlName("progress"),
      T.Ec2QueryName("Progress"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    VolumeSize: S.optional(S.Number).pipe(
      T.XmlName("volumeSize"),
      T.Ec2QueryName("VolumeSize"),
    ),
    Encrypted: S.optional(S.Boolean).pipe(
      T.XmlName("encrypted"),
      T.Ec2QueryName("Encrypted"),
    ),
    KmsKeyId: S.optional(S.String).pipe(
      T.XmlName("kmsKeyId"),
      T.Ec2QueryName("KmsKeyId"),
    ),
    DataEncryptionKeyId: S.optional(S.String).pipe(
      T.XmlName("dataEncryptionKeyId"),
      T.Ec2QueryName("DataEncryptionKeyId"),
    ),
  }).pipe(ns),
).annotate({ identifier: "Snapshot" }) as any as S.Schema<Snapshot>;
export type VolumeIdStringList = string[];
export const VolumeIdStringList = S.Array(S.String.pipe(T.XmlName("VolumeId")));
export interface InstanceSpecification {
  InstanceId?: string;
  ExcludeBootVolume?: boolean;
  ExcludeDataVolumeIds?: string[];
}
export const InstanceSpecification = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    ExcludeBootVolume: S.optional(S.Boolean),
    ExcludeDataVolumeIds: S.optional(VolumeIdStringList).pipe(
      T.XmlName("ExcludeDataVolumeId"),
    ),
  }),
).annotate({
  identifier: "InstanceSpecification",
}) as any as S.Schema<InstanceSpecification>;
export type CopyTagsFromSource = "volume" | (string & {});
export const CopyTagsFromSource = S.String;
export interface CreateSnapshotsRequest {
  Description?: string;
  InstanceSpecification?: InstanceSpecification;
  OutpostArn?: string;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
  CopyTagsFromSource?: CopyTagsFromSource;
  Location?: SnapshotLocationEnum;
}
export const CreateSnapshotsRequest = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String),
    InstanceSpecification: S.optional(InstanceSpecification),
    OutpostArn: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
    CopyTagsFromSource: S.optional(CopyTagsFromSource),
    Location: S.optional(SnapshotLocationEnum),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateSnapshotsRequest",
}) as any as S.Schema<CreateSnapshotsRequest>;
export interface SnapshotInfo {
  Description?: string;
  Tags?: Tag[];
  Encrypted?: boolean;
  VolumeId?: string;
  State?: SnapshotState;
  VolumeSize?: number;
  StartTime?: Date;
  Progress?: string;
  OwnerId?: string;
  SnapshotId?: string;
  OutpostArn?: string;
  SseType?: SSEType;
  AvailabilityZone?: string;
}
export const SnapshotInfo = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    Encrypted: S.optional(S.Boolean).pipe(
      T.XmlName("encrypted"),
      T.Ec2QueryName("Encrypted"),
    ),
    VolumeId: S.optional(S.String).pipe(
      T.XmlName("volumeId"),
      T.Ec2QueryName("VolumeId"),
    ),
    State: S.optional(SnapshotState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    VolumeSize: S.optional(S.Number).pipe(
      T.XmlName("volumeSize"),
      T.Ec2QueryName("VolumeSize"),
    ),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startTime"), T.Ec2QueryName("StartTime")),
    Progress: S.optional(S.String).pipe(
      T.XmlName("progress"),
      T.Ec2QueryName("Progress"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    OutpostArn: S.optional(S.String).pipe(
      T.XmlName("outpostArn"),
      T.Ec2QueryName("OutpostArn"),
    ),
    SseType: S.optional(SSEType).pipe(
      T.XmlName("sseType"),
      T.Ec2QueryName("SseType"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
  }),
).annotate({ identifier: "SnapshotInfo" }) as any as S.Schema<SnapshotInfo>;
export type SnapshotSet = SnapshotInfo[];
export const SnapshotSet = S.Array(
  SnapshotInfo.pipe(T.XmlName("item")).annotate({ identifier: "SnapshotInfo" }),
);
export interface CreateSnapshotsResult {
  Snapshots?: SnapshotInfo[];
}
export const CreateSnapshotsResult = S.suspend(() =>
  S.Struct({
    Snapshots: S.optional(SnapshotSet).pipe(
      T.XmlName("snapshotSet"),
      T.Ec2QueryName("SnapshotSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateSnapshotsResult",
}) as any as S.Schema<CreateSnapshotsResult>;
export interface CreateSpotDatafeedSubscriptionRequest {
  DryRun?: boolean;
  Bucket?: string;
  Prefix?: string;
}
export const CreateSpotDatafeedSubscriptionRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Bucket: S.optional(S.String).pipe(
      T.XmlName("bucket"),
      T.Ec2QueryName("Bucket"),
    ),
    Prefix: S.optional(S.String).pipe(
      T.XmlName("prefix"),
      T.Ec2QueryName("Prefix"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateSpotDatafeedSubscriptionRequest",
}) as any as S.Schema<CreateSpotDatafeedSubscriptionRequest>;
export interface SpotInstanceStateFault {
  Code?: string;
  Message?: string;
}
export const SpotInstanceStateFault = S.suspend(() =>
  S.Struct({
    Code: S.optional(S.String).pipe(T.XmlName("code"), T.Ec2QueryName("Code")),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "SpotInstanceStateFault",
}) as any as S.Schema<SpotInstanceStateFault>;
export type DatafeedSubscriptionState = "Active" | "Inactive" | (string & {});
export const DatafeedSubscriptionState = S.String;
export interface SpotDatafeedSubscription {
  Bucket?: string;
  Fault?: SpotInstanceStateFault;
  OwnerId?: string;
  Prefix?: string;
  State?: DatafeedSubscriptionState;
}
export const SpotDatafeedSubscription = S.suspend(() =>
  S.Struct({
    Bucket: S.optional(S.String).pipe(
      T.XmlName("bucket"),
      T.Ec2QueryName("Bucket"),
    ),
    Fault: S.optional(SpotInstanceStateFault)
      .pipe(T.XmlName("fault"), T.Ec2QueryName("Fault"))
      .annotate({ identifier: "SpotInstanceStateFault" }),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    Prefix: S.optional(S.String).pipe(
      T.XmlName("prefix"),
      T.Ec2QueryName("Prefix"),
    ),
    State: S.optional(DatafeedSubscriptionState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({
  identifier: "SpotDatafeedSubscription",
}) as any as S.Schema<SpotDatafeedSubscription>;
export interface CreateSpotDatafeedSubscriptionResult {
  SpotDatafeedSubscription?: SpotDatafeedSubscription;
}
export const CreateSpotDatafeedSubscriptionResult = S.suspend(() =>
  S.Struct({
    SpotDatafeedSubscription: S.optional(SpotDatafeedSubscription)
      .pipe(
        T.XmlName("spotDatafeedSubscription"),
        T.Ec2QueryName("SpotDatafeedSubscription"),
      )
      .annotate({ identifier: "SpotDatafeedSubscription" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateSpotDatafeedSubscriptionResult",
}) as any as S.Schema<CreateSpotDatafeedSubscriptionResult>;
export interface S3ObjectTag {
  Key?: string;
  Value?: string;
}
export const S3ObjectTag = S.suspend(() =>
  S.Struct({ Key: S.optional(S.String), Value: S.optional(S.String) }),
).annotate({ identifier: "S3ObjectTag" }) as any as S.Schema<S3ObjectTag>;
export type S3ObjectTagList = S3ObjectTag[];
export const S3ObjectTagList = S.Array(
  S3ObjectTag.pipe(T.XmlName("item")).annotate({ identifier: "S3ObjectTag" }),
);
export interface CreateStoreImageTaskRequest {
  ImageId?: string;
  Bucket?: string;
  S3ObjectTags?: S3ObjectTag[];
  DryRun?: boolean;
}
export const CreateStoreImageTaskRequest = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String),
    Bucket: S.optional(S.String),
    S3ObjectTags: S.optional(S3ObjectTagList).pipe(T.XmlName("S3ObjectTag")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateStoreImageTaskRequest",
}) as any as S.Schema<CreateStoreImageTaskRequest>;
export interface CreateStoreImageTaskResult {
  ObjectKey?: string;
}
export const CreateStoreImageTaskResult = S.suspend(() =>
  S.Struct({
    ObjectKey: S.optional(S.String).pipe(
      T.XmlName("objectKey"),
      T.Ec2QueryName("ObjectKey"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateStoreImageTaskResult",
}) as any as S.Schema<CreateStoreImageTaskResult>;
export interface CreateSubnetRequest {
  TagSpecifications?: TagSpecification[];
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  CidrBlock?: string;
  Ipv6CidrBlock?: string;
  OutpostArn?: string;
  VpcId?: string;
  Ipv6Native?: boolean;
  Ipv4IpamPoolId?: string;
  Ipv4NetmaskLength?: number;
  Ipv6IpamPoolId?: string;
  Ipv6NetmaskLength?: number;
  DryRun?: boolean;
}
export const CreateSubnetRequest = S.suspend(() =>
  S.Struct({
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    AvailabilityZone: S.optional(S.String),
    AvailabilityZoneId: S.optional(S.String),
    CidrBlock: S.optional(S.String),
    Ipv6CidrBlock: S.optional(S.String),
    OutpostArn: S.optional(S.String),
    VpcId: S.optional(S.String),
    Ipv6Native: S.optional(S.Boolean),
    Ipv4IpamPoolId: S.optional(S.String),
    Ipv4NetmaskLength: S.optional(S.Number),
    Ipv6IpamPoolId: S.optional(S.String),
    Ipv6NetmaskLength: S.optional(S.Number),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateSubnetRequest",
}) as any as S.Schema<CreateSubnetRequest>;
export interface CreateSubnetResult {
  Subnet?: Subnet;
}
export const CreateSubnetResult = S.suspend(() =>
  S.Struct({
    Subnet: S.optional(Subnet)
      .pipe(T.XmlName("subnet"), T.Ec2QueryName("Subnet"))
      .annotate({ identifier: "Subnet" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateSubnetResult",
}) as any as S.Schema<CreateSubnetResult>;
export type SubnetCidrReservationType = "prefix" | "explicit" | (string & {});
export const SubnetCidrReservationType = S.String;
export interface CreateSubnetCidrReservationRequest {
  SubnetId?: string;
  Cidr?: string;
  ReservationType?: SubnetCidrReservationType;
  Description?: string;
  DryRun?: boolean;
  TagSpecifications?: TagSpecification[];
}
export const CreateSubnetCidrReservationRequest = S.suspend(() =>
  S.Struct({
    SubnetId: S.optional(S.String),
    Cidr: S.optional(S.String),
    ReservationType: S.optional(SubnetCidrReservationType),
    Description: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateSubnetCidrReservationRequest",
}) as any as S.Schema<CreateSubnetCidrReservationRequest>;
export interface SubnetCidrReservation {
  SubnetCidrReservationId?: string;
  SubnetId?: string;
  Cidr?: string;
  ReservationType?: SubnetCidrReservationType;
  OwnerId?: string;
  Description?: string;
  Tags?: Tag[];
}
export const SubnetCidrReservation = S.suspend(() =>
  S.Struct({
    SubnetCidrReservationId: S.optional(S.String).pipe(
      T.XmlName("subnetCidrReservationId"),
      T.Ec2QueryName("SubnetCidrReservationId"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    Cidr: S.optional(S.String).pipe(T.XmlName("cidr"), T.Ec2QueryName("Cidr")),
    ReservationType: S.optional(SubnetCidrReservationType).pipe(
      T.XmlName("reservationType"),
      T.Ec2QueryName("ReservationType"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "SubnetCidrReservation",
}) as any as S.Schema<SubnetCidrReservation>;
export interface CreateSubnetCidrReservationResult {
  SubnetCidrReservation?: SubnetCidrReservation;
}
export const CreateSubnetCidrReservationResult = S.suspend(() =>
  S.Struct({
    SubnetCidrReservation: S.optional(SubnetCidrReservation)
      .pipe(
        T.XmlName("subnetCidrReservation"),
        T.Ec2QueryName("SubnetCidrReservation"),
      )
      .annotate({ identifier: "SubnetCidrReservation" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateSubnetCidrReservationResult",
}) as any as S.Schema<CreateSubnetCidrReservationResult>;
export type ResourceIdList = string[];
export const ResourceIdList = S.Array(S.String);
export interface CreateTagsRequest {
  DryRun?: boolean;
  Resources?: string[];
  Tags?: Tag[];
}
export const CreateTagsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Resources: S.optional(ResourceIdList).pipe(T.XmlName("ResourceId")),
    Tags: S.optional(TagList).pipe(T.XmlName("Tag")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTagsRequest",
}) as any as S.Schema<CreateTagsRequest>;
export interface CreateTagsResponse {}
export const CreateTagsResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "CreateTagsResponse",
}) as any as S.Schema<CreateTagsResponse>;
export interface CreateTrafficMirrorFilterRequest {
  Description?: string;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
  ClientToken?: string;
}
export const CreateTrafficMirrorFilterRequest = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTrafficMirrorFilterRequest",
}) as any as S.Schema<CreateTrafficMirrorFilterRequest>;
export type TrafficDirection = "ingress" | "egress" | (string & {});
export const TrafficDirection = S.String;
export type TrafficMirrorRuleAction = "accept" | "reject" | (string & {});
export const TrafficMirrorRuleAction = S.String;
export interface TrafficMirrorPortRange {
  FromPort?: number;
  ToPort?: number;
}
export const TrafficMirrorPortRange = S.suspend(() =>
  S.Struct({
    FromPort: S.optional(S.Number).pipe(
      T.XmlName("fromPort"),
      T.Ec2QueryName("FromPort"),
    ),
    ToPort: S.optional(S.Number).pipe(
      T.XmlName("toPort"),
      T.Ec2QueryName("ToPort"),
    ),
  }),
).annotate({
  identifier: "TrafficMirrorPortRange",
}) as any as S.Schema<TrafficMirrorPortRange>;
export interface TrafficMirrorFilterRule {
  TrafficMirrorFilterRuleId?: string;
  TrafficMirrorFilterId?: string;
  TrafficDirection?: TrafficDirection;
  RuleNumber?: number;
  RuleAction?: TrafficMirrorRuleAction;
  Protocol?: number;
  DestinationPortRange?: TrafficMirrorPortRange;
  SourcePortRange?: TrafficMirrorPortRange;
  DestinationCidrBlock?: string;
  SourceCidrBlock?: string;
  Description?: string;
  Tags?: Tag[];
}
export const TrafficMirrorFilterRule = S.suspend(() =>
  S.Struct({
    TrafficMirrorFilterRuleId: S.optional(S.String).pipe(
      T.XmlName("trafficMirrorFilterRuleId"),
      T.Ec2QueryName("TrafficMirrorFilterRuleId"),
    ),
    TrafficMirrorFilterId: S.optional(S.String).pipe(
      T.XmlName("trafficMirrorFilterId"),
      T.Ec2QueryName("TrafficMirrorFilterId"),
    ),
    TrafficDirection: S.optional(TrafficDirection).pipe(
      T.XmlName("trafficDirection"),
      T.Ec2QueryName("TrafficDirection"),
    ),
    RuleNumber: S.optional(S.Number).pipe(
      T.XmlName("ruleNumber"),
      T.Ec2QueryName("RuleNumber"),
    ),
    RuleAction: S.optional(TrafficMirrorRuleAction).pipe(
      T.XmlName("ruleAction"),
      T.Ec2QueryName("RuleAction"),
    ),
    Protocol: S.optional(S.Number).pipe(
      T.XmlName("protocol"),
      T.Ec2QueryName("Protocol"),
    ),
    DestinationPortRange: S.optional(TrafficMirrorPortRange)
      .pipe(
        T.XmlName("destinationPortRange"),
        T.Ec2QueryName("DestinationPortRange"),
      )
      .annotate({ identifier: "TrafficMirrorPortRange" }),
    SourcePortRange: S.optional(TrafficMirrorPortRange)
      .pipe(T.XmlName("sourcePortRange"), T.Ec2QueryName("SourcePortRange"))
      .annotate({ identifier: "TrafficMirrorPortRange" }),
    DestinationCidrBlock: S.optional(S.String).pipe(
      T.XmlName("destinationCidrBlock"),
      T.Ec2QueryName("DestinationCidrBlock"),
    ),
    SourceCidrBlock: S.optional(S.String).pipe(
      T.XmlName("sourceCidrBlock"),
      T.Ec2QueryName("SourceCidrBlock"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "TrafficMirrorFilterRule",
}) as any as S.Schema<TrafficMirrorFilterRule>;
export type TrafficMirrorFilterRuleList = TrafficMirrorFilterRule[];
export const TrafficMirrorFilterRuleList = S.Array(
  TrafficMirrorFilterRule.pipe(T.XmlName("item")).annotate({
    identifier: "TrafficMirrorFilterRule",
  }),
);
export type TrafficMirrorNetworkService = "amazon-dns" | (string & {});
export const TrafficMirrorNetworkService = S.String;
export type TrafficMirrorNetworkServiceList = TrafficMirrorNetworkService[];
export const TrafficMirrorNetworkServiceList = S.Array(
  TrafficMirrorNetworkService.pipe(T.XmlName("item")),
);
export interface TrafficMirrorFilter {
  TrafficMirrorFilterId?: string;
  IngressFilterRules?: TrafficMirrorFilterRule[];
  EgressFilterRules?: TrafficMirrorFilterRule[];
  NetworkServices?: TrafficMirrorNetworkService[];
  Description?: string;
  Tags?: Tag[];
}
export const TrafficMirrorFilter = S.suspend(() =>
  S.Struct({
    TrafficMirrorFilterId: S.optional(S.String).pipe(
      T.XmlName("trafficMirrorFilterId"),
      T.Ec2QueryName("TrafficMirrorFilterId"),
    ),
    IngressFilterRules: S.optional(TrafficMirrorFilterRuleList).pipe(
      T.XmlName("ingressFilterRuleSet"),
      T.Ec2QueryName("IngressFilterRuleSet"),
    ),
    EgressFilterRules: S.optional(TrafficMirrorFilterRuleList).pipe(
      T.XmlName("egressFilterRuleSet"),
      T.Ec2QueryName("EgressFilterRuleSet"),
    ),
    NetworkServices: S.optional(TrafficMirrorNetworkServiceList).pipe(
      T.XmlName("networkServiceSet"),
      T.Ec2QueryName("NetworkServiceSet"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "TrafficMirrorFilter",
}) as any as S.Schema<TrafficMirrorFilter>;
export interface CreateTrafficMirrorFilterResult {
  TrafficMirrorFilter?: TrafficMirrorFilter;
  ClientToken?: string;
}
export const CreateTrafficMirrorFilterResult = S.suspend(() =>
  S.Struct({
    TrafficMirrorFilter: S.optional(TrafficMirrorFilter)
      .pipe(
        T.XmlName("trafficMirrorFilter"),
        T.Ec2QueryName("TrafficMirrorFilter"),
      )
      .annotate({ identifier: "TrafficMirrorFilter" }),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateTrafficMirrorFilterResult",
}) as any as S.Schema<CreateTrafficMirrorFilterResult>;
export interface TrafficMirrorPortRangeRequest {
  FromPort?: number;
  ToPort?: number;
}
export const TrafficMirrorPortRangeRequest = S.suspend(() =>
  S.Struct({ FromPort: S.optional(S.Number), ToPort: S.optional(S.Number) }),
).annotate({
  identifier: "TrafficMirrorPortRangeRequest",
}) as any as S.Schema<TrafficMirrorPortRangeRequest>;
export interface CreateTrafficMirrorFilterRuleRequest {
  TrafficMirrorFilterId?: string;
  TrafficDirection?: TrafficDirection;
  RuleNumber?: number;
  RuleAction?: TrafficMirrorRuleAction;
  DestinationPortRange?: TrafficMirrorPortRangeRequest;
  SourcePortRange?: TrafficMirrorPortRangeRequest;
  Protocol?: number;
  DestinationCidrBlock?: string;
  SourceCidrBlock?: string;
  Description?: string;
  DryRun?: boolean;
  ClientToken?: string;
  TagSpecifications?: TagSpecification[];
}
export const CreateTrafficMirrorFilterRuleRequest = S.suspend(() =>
  S.Struct({
    TrafficMirrorFilterId: S.optional(S.String),
    TrafficDirection: S.optional(TrafficDirection),
    RuleNumber: S.optional(S.Number),
    RuleAction: S.optional(TrafficMirrorRuleAction),
    DestinationPortRange: S.optional(TrafficMirrorPortRangeRequest),
    SourcePortRange: S.optional(TrafficMirrorPortRangeRequest),
    Protocol: S.optional(S.Number),
    DestinationCidrBlock: S.optional(S.String),
    SourceCidrBlock: S.optional(S.String),
    Description: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTrafficMirrorFilterRuleRequest",
}) as any as S.Schema<CreateTrafficMirrorFilterRuleRequest>;
export interface CreateTrafficMirrorFilterRuleResult {
  TrafficMirrorFilterRule?: TrafficMirrorFilterRule;
  ClientToken?: string;
}
export const CreateTrafficMirrorFilterRuleResult = S.suspend(() =>
  S.Struct({
    TrafficMirrorFilterRule: S.optional(TrafficMirrorFilterRule)
      .pipe(
        T.XmlName("trafficMirrorFilterRule"),
        T.Ec2QueryName("TrafficMirrorFilterRule"),
      )
      .annotate({ identifier: "TrafficMirrorFilterRule" }),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateTrafficMirrorFilterRuleResult",
}) as any as S.Schema<CreateTrafficMirrorFilterRuleResult>;
export interface CreateTrafficMirrorSessionRequest {
  NetworkInterfaceId?: string;
  TrafficMirrorTargetId?: string;
  TrafficMirrorFilterId?: string;
  PacketLength?: number;
  SessionNumber?: number;
  VirtualNetworkId?: number;
  Description?: string;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
  ClientToken?: string;
}
export const CreateTrafficMirrorSessionRequest = S.suspend(() =>
  S.Struct({
    NetworkInterfaceId: S.optional(S.String),
    TrafficMirrorTargetId: S.optional(S.String),
    TrafficMirrorFilterId: S.optional(S.String),
    PacketLength: S.optional(S.Number),
    SessionNumber: S.optional(S.Number),
    VirtualNetworkId: S.optional(S.Number),
    Description: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTrafficMirrorSessionRequest",
}) as any as S.Schema<CreateTrafficMirrorSessionRequest>;
export interface TrafficMirrorSession {
  TrafficMirrorSessionId?: string;
  TrafficMirrorTargetId?: string;
  TrafficMirrorFilterId?: string;
  NetworkInterfaceId?: string;
  OwnerId?: string;
  PacketLength?: number;
  SessionNumber?: number;
  VirtualNetworkId?: number;
  Description?: string;
  Tags?: Tag[];
}
export const TrafficMirrorSession = S.suspend(() =>
  S.Struct({
    TrafficMirrorSessionId: S.optional(S.String).pipe(
      T.XmlName("trafficMirrorSessionId"),
      T.Ec2QueryName("TrafficMirrorSessionId"),
    ),
    TrafficMirrorTargetId: S.optional(S.String).pipe(
      T.XmlName("trafficMirrorTargetId"),
      T.Ec2QueryName("TrafficMirrorTargetId"),
    ),
    TrafficMirrorFilterId: S.optional(S.String).pipe(
      T.XmlName("trafficMirrorFilterId"),
      T.Ec2QueryName("TrafficMirrorFilterId"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    PacketLength: S.optional(S.Number).pipe(
      T.XmlName("packetLength"),
      T.Ec2QueryName("PacketLength"),
    ),
    SessionNumber: S.optional(S.Number).pipe(
      T.XmlName("sessionNumber"),
      T.Ec2QueryName("SessionNumber"),
    ),
    VirtualNetworkId: S.optional(S.Number).pipe(
      T.XmlName("virtualNetworkId"),
      T.Ec2QueryName("VirtualNetworkId"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "TrafficMirrorSession",
}) as any as S.Schema<TrafficMirrorSession>;
export interface CreateTrafficMirrorSessionResult {
  TrafficMirrorSession?: TrafficMirrorSession;
  ClientToken?: string;
}
export const CreateTrafficMirrorSessionResult = S.suspend(() =>
  S.Struct({
    TrafficMirrorSession: S.optional(TrafficMirrorSession)
      .pipe(
        T.XmlName("trafficMirrorSession"),
        T.Ec2QueryName("TrafficMirrorSession"),
      )
      .annotate({ identifier: "TrafficMirrorSession" }),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateTrafficMirrorSessionResult",
}) as any as S.Schema<CreateTrafficMirrorSessionResult>;
export interface CreateTrafficMirrorTargetRequest {
  NetworkInterfaceId?: string;
  NetworkLoadBalancerArn?: string;
  Description?: string;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
  ClientToken?: string;
  GatewayLoadBalancerEndpointId?: string;
}
export const CreateTrafficMirrorTargetRequest = S.suspend(() =>
  S.Struct({
    NetworkInterfaceId: S.optional(S.String),
    NetworkLoadBalancerArn: S.optional(S.String),
    Description: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    GatewayLoadBalancerEndpointId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTrafficMirrorTargetRequest",
}) as any as S.Schema<CreateTrafficMirrorTargetRequest>;
export type TrafficMirrorTargetType =
  | "network-interface"
  | "network-load-balancer"
  | "gateway-load-balancer-endpoint"
  | (string & {});
export const TrafficMirrorTargetType = S.String;
export interface TrafficMirrorTarget {
  TrafficMirrorTargetId?: string;
  NetworkInterfaceId?: string;
  NetworkLoadBalancerArn?: string;
  Type?: TrafficMirrorTargetType;
  Description?: string;
  OwnerId?: string;
  Tags?: Tag[];
  GatewayLoadBalancerEndpointId?: string;
}
export const TrafficMirrorTarget = S.suspend(() =>
  S.Struct({
    TrafficMirrorTargetId: S.optional(S.String).pipe(
      T.XmlName("trafficMirrorTargetId"),
      T.Ec2QueryName("TrafficMirrorTargetId"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    NetworkLoadBalancerArn: S.optional(S.String).pipe(
      T.XmlName("networkLoadBalancerArn"),
      T.Ec2QueryName("NetworkLoadBalancerArn"),
    ),
    Type: S.optional(TrafficMirrorTargetType).pipe(
      T.XmlName("type"),
      T.Ec2QueryName("Type"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    GatewayLoadBalancerEndpointId: S.optional(S.String).pipe(
      T.XmlName("gatewayLoadBalancerEndpointId"),
      T.Ec2QueryName("GatewayLoadBalancerEndpointId"),
    ),
  }),
).annotate({
  identifier: "TrafficMirrorTarget",
}) as any as S.Schema<TrafficMirrorTarget>;
export interface CreateTrafficMirrorTargetResult {
  TrafficMirrorTarget?: TrafficMirrorTarget;
  ClientToken?: string;
}
export const CreateTrafficMirrorTargetResult = S.suspend(() =>
  S.Struct({
    TrafficMirrorTarget: S.optional(TrafficMirrorTarget)
      .pipe(
        T.XmlName("trafficMirrorTarget"),
        T.Ec2QueryName("TrafficMirrorTarget"),
      )
      .annotate({ identifier: "TrafficMirrorTarget" }),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateTrafficMirrorTargetResult",
}) as any as S.Schema<CreateTrafficMirrorTargetResult>;
export type AutoAcceptSharedAttachmentsValue =
  | "enable"
  | "disable"
  | (string & {});
export const AutoAcceptSharedAttachmentsValue = S.String;
export type DefaultRouteTableAssociationValue =
  | "enable"
  | "disable"
  | (string & {});
export const DefaultRouteTableAssociationValue = S.String;
export type DefaultRouteTablePropagationValue =
  | "enable"
  | "disable"
  | (string & {});
export const DefaultRouteTablePropagationValue = S.String;
export type VpnEcmpSupportValue = "enable" | "disable" | (string & {});
export const VpnEcmpSupportValue = S.String;
export type MulticastSupportValue = "enable" | "disable" | (string & {});
export const MulticastSupportValue = S.String;
export type TransitGatewayCidrBlockStringList = string[];
export const TransitGatewayCidrBlockStringList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface TransitGatewayRequestOptions {
  AmazonSideAsn?: number;
  AutoAcceptSharedAttachments?: AutoAcceptSharedAttachmentsValue;
  DefaultRouteTableAssociation?: DefaultRouteTableAssociationValue;
  DefaultRouteTablePropagation?: DefaultRouteTablePropagationValue;
  VpnEcmpSupport?: VpnEcmpSupportValue;
  DnsSupport?: DnsSupportValue;
  SecurityGroupReferencingSupport?: SecurityGroupReferencingSupportValue;
  MulticastSupport?: MulticastSupportValue;
  TransitGatewayCidrBlocks?: string[];
}
export const TransitGatewayRequestOptions = S.suspend(() =>
  S.Struct({
    AmazonSideAsn: S.optional(S.Number),
    AutoAcceptSharedAttachments: S.optional(AutoAcceptSharedAttachmentsValue),
    DefaultRouteTableAssociation: S.optional(DefaultRouteTableAssociationValue),
    DefaultRouteTablePropagation: S.optional(DefaultRouteTablePropagationValue),
    VpnEcmpSupport: S.optional(VpnEcmpSupportValue),
    DnsSupport: S.optional(DnsSupportValue),
    SecurityGroupReferencingSupport: S.optional(
      SecurityGroupReferencingSupportValue,
    ),
    MulticastSupport: S.optional(MulticastSupportValue),
    TransitGatewayCidrBlocks: S.optional(TransitGatewayCidrBlockStringList),
  }),
).annotate({
  identifier: "TransitGatewayRequestOptions",
}) as any as S.Schema<TransitGatewayRequestOptions>;
export interface CreateTransitGatewayRequest {
  Description?: string;
  Options?: TransitGatewayRequestOptions;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateTransitGatewayRequest = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String),
    Options: S.optional(TransitGatewayRequestOptions),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTransitGatewayRequest",
}) as any as S.Schema<CreateTransitGatewayRequest>;
export type TransitGatewayState =
  | "pending"
  | "available"
  | "modifying"
  | "deleting"
  | "deleted"
  | (string & {});
export const TransitGatewayState = S.String;
export type EncryptionStateValue =
  | "enabling"
  | "enabled"
  | "disabling"
  | "disabled"
  | (string & {});
export const EncryptionStateValue = S.String;
export interface EncryptionSupport {
  EncryptionState?: EncryptionStateValue;
  StateMessage?: string;
}
export const EncryptionSupport = S.suspend(() =>
  S.Struct({
    EncryptionState: S.optional(EncryptionStateValue).pipe(
      T.XmlName("encryptionState"),
      T.Ec2QueryName("EncryptionState"),
    ),
    StateMessage: S.optional(S.String).pipe(
      T.XmlName("stateMessage"),
      T.Ec2QueryName("StateMessage"),
    ),
  }),
).annotate({
  identifier: "EncryptionSupport",
}) as any as S.Schema<EncryptionSupport>;
export interface TransitGatewayOptions {
  AmazonSideAsn?: number;
  TransitGatewayCidrBlocks?: string[];
  AutoAcceptSharedAttachments?: AutoAcceptSharedAttachmentsValue;
  DefaultRouteTableAssociation?: DefaultRouteTableAssociationValue;
  AssociationDefaultRouteTableId?: string;
  DefaultRouteTablePropagation?: DefaultRouteTablePropagationValue;
  PropagationDefaultRouteTableId?: string;
  VpnEcmpSupport?: VpnEcmpSupportValue;
  DnsSupport?: DnsSupportValue;
  SecurityGroupReferencingSupport?: SecurityGroupReferencingSupportValue;
  MulticastSupport?: MulticastSupportValue;
  EncryptionSupport?: EncryptionSupport;
}
export const TransitGatewayOptions = S.suspend(() =>
  S.Struct({
    AmazonSideAsn: S.optional(S.Number).pipe(
      T.XmlName("amazonSideAsn"),
      T.Ec2QueryName("AmazonSideAsn"),
    ),
    TransitGatewayCidrBlocks: S.optional(ValueStringList).pipe(
      T.XmlName("transitGatewayCidrBlocks"),
      T.Ec2QueryName("TransitGatewayCidrBlocks"),
    ),
    AutoAcceptSharedAttachments: S.optional(
      AutoAcceptSharedAttachmentsValue,
    ).pipe(
      T.XmlName("autoAcceptSharedAttachments"),
      T.Ec2QueryName("AutoAcceptSharedAttachments"),
    ),
    DefaultRouteTableAssociation: S.optional(
      DefaultRouteTableAssociationValue,
    ).pipe(
      T.XmlName("defaultRouteTableAssociation"),
      T.Ec2QueryName("DefaultRouteTableAssociation"),
    ),
    AssociationDefaultRouteTableId: S.optional(S.String).pipe(
      T.XmlName("associationDefaultRouteTableId"),
      T.Ec2QueryName("AssociationDefaultRouteTableId"),
    ),
    DefaultRouteTablePropagation: S.optional(
      DefaultRouteTablePropagationValue,
    ).pipe(
      T.XmlName("defaultRouteTablePropagation"),
      T.Ec2QueryName("DefaultRouteTablePropagation"),
    ),
    PropagationDefaultRouteTableId: S.optional(S.String).pipe(
      T.XmlName("propagationDefaultRouteTableId"),
      T.Ec2QueryName("PropagationDefaultRouteTableId"),
    ),
    VpnEcmpSupport: S.optional(VpnEcmpSupportValue).pipe(
      T.XmlName("vpnEcmpSupport"),
      T.Ec2QueryName("VpnEcmpSupport"),
    ),
    DnsSupport: S.optional(DnsSupportValue).pipe(
      T.XmlName("dnsSupport"),
      T.Ec2QueryName("DnsSupport"),
    ),
    SecurityGroupReferencingSupport: S.optional(
      SecurityGroupReferencingSupportValue,
    ).pipe(
      T.XmlName("securityGroupReferencingSupport"),
      T.Ec2QueryName("SecurityGroupReferencingSupport"),
    ),
    MulticastSupport: S.optional(MulticastSupportValue).pipe(
      T.XmlName("multicastSupport"),
      T.Ec2QueryName("MulticastSupport"),
    ),
    EncryptionSupport: S.optional(EncryptionSupport)
      .pipe(T.XmlName("encryptionSupport"), T.Ec2QueryName("EncryptionSupport"))
      .annotate({ identifier: "EncryptionSupport" }),
  }),
).annotate({
  identifier: "TransitGatewayOptions",
}) as any as S.Schema<TransitGatewayOptions>;
export interface TransitGateway {
  TransitGatewayId?: string;
  TransitGatewayArn?: string;
  State?: TransitGatewayState;
  OwnerId?: string;
  Description?: string;
  CreationTime?: Date;
  Options?: TransitGatewayOptions;
  Tags?: Tag[];
}
export const TransitGateway = S.suspend(() =>
  S.Struct({
    TransitGatewayId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayId"),
      T.Ec2QueryName("TransitGatewayId"),
    ),
    TransitGatewayArn: S.optional(S.String).pipe(
      T.XmlName("transitGatewayArn"),
      T.Ec2QueryName("TransitGatewayArn"),
    ),
    State: S.optional(TransitGatewayState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    CreationTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("creationTime"), T.Ec2QueryName("CreationTime")),
    Options: S.optional(TransitGatewayOptions)
      .pipe(T.XmlName("options"), T.Ec2QueryName("Options"))
      .annotate({ identifier: "TransitGatewayOptions" }),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({ identifier: "TransitGateway" }) as any as S.Schema<TransitGateway>;
export interface CreateTransitGatewayResult {
  TransitGateway?: TransitGateway;
}
export const CreateTransitGatewayResult = S.suspend(() =>
  S.Struct({
    TransitGateway: S.optional(TransitGateway)
      .pipe(T.XmlName("transitGateway"), T.Ec2QueryName("TransitGateway"))
      .annotate({ identifier: "TransitGateway" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateTransitGatewayResult",
}) as any as S.Schema<CreateTransitGatewayResult>;
export type ProtocolValue = "gre" | (string & {});
export const ProtocolValue = S.String;
export interface CreateTransitGatewayConnectRequestOptions {
  Protocol?: ProtocolValue;
}
export const CreateTransitGatewayConnectRequestOptions = S.suspend(() =>
  S.Struct({ Protocol: S.optional(ProtocolValue) }),
).annotate({
  identifier: "CreateTransitGatewayConnectRequestOptions",
}) as any as S.Schema<CreateTransitGatewayConnectRequestOptions>;
export interface CreateTransitGatewayConnectRequest {
  TransportTransitGatewayAttachmentId?: string;
  Options?: CreateTransitGatewayConnectRequestOptions;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateTransitGatewayConnectRequest = S.suspend(() =>
  S.Struct({
    TransportTransitGatewayAttachmentId: S.optional(S.String),
    Options: S.optional(CreateTransitGatewayConnectRequestOptions),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTransitGatewayConnectRequest",
}) as any as S.Schema<CreateTransitGatewayConnectRequest>;
export interface TransitGatewayConnectOptions {
  Protocol?: ProtocolValue;
}
export const TransitGatewayConnectOptions = S.suspend(() =>
  S.Struct({
    Protocol: S.optional(ProtocolValue).pipe(
      T.XmlName("protocol"),
      T.Ec2QueryName("Protocol"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayConnectOptions",
}) as any as S.Schema<TransitGatewayConnectOptions>;
export interface TransitGatewayConnect {
  TransitGatewayAttachmentId?: string;
  TransportTransitGatewayAttachmentId?: string;
  TransitGatewayId?: string;
  State?: TransitGatewayAttachmentState;
  CreationTime?: Date;
  Options?: TransitGatewayConnectOptions;
  Tags?: Tag[];
}
export const TransitGatewayConnect = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayAttachmentId"),
      T.Ec2QueryName("TransitGatewayAttachmentId"),
    ),
    TransportTransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("transportTransitGatewayAttachmentId"),
      T.Ec2QueryName("TransportTransitGatewayAttachmentId"),
    ),
    TransitGatewayId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayId"),
      T.Ec2QueryName("TransitGatewayId"),
    ),
    State: S.optional(TransitGatewayAttachmentState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    CreationTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("creationTime"), T.Ec2QueryName("CreationTime")),
    Options: S.optional(TransitGatewayConnectOptions)
      .pipe(T.XmlName("options"), T.Ec2QueryName("Options"))
      .annotate({ identifier: "TransitGatewayConnectOptions" }),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayConnect",
}) as any as S.Schema<TransitGatewayConnect>;
export interface CreateTransitGatewayConnectResult {
  TransitGatewayConnect?: TransitGatewayConnect;
}
export const CreateTransitGatewayConnectResult = S.suspend(() =>
  S.Struct({
    TransitGatewayConnect: S.optional(TransitGatewayConnect)
      .pipe(
        T.XmlName("transitGatewayConnect"),
        T.Ec2QueryName("TransitGatewayConnect"),
      )
      .annotate({ identifier: "TransitGatewayConnect" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateTransitGatewayConnectResult",
}) as any as S.Schema<CreateTransitGatewayConnectResult>;
export interface TransitGatewayConnectRequestBgpOptions {
  PeerAsn?: number;
}
export const TransitGatewayConnectRequestBgpOptions = S.suspend(() =>
  S.Struct({ PeerAsn: S.optional(S.Number) }),
).annotate({
  identifier: "TransitGatewayConnectRequestBgpOptions",
}) as any as S.Schema<TransitGatewayConnectRequestBgpOptions>;
export type InsideCidrBlocksStringList = string[];
export const InsideCidrBlocksStringList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface CreateTransitGatewayConnectPeerRequest {
  TransitGatewayAttachmentId?: string;
  TransitGatewayAddress?: string;
  PeerAddress?: string;
  BgpOptions?: TransitGatewayConnectRequestBgpOptions;
  InsideCidrBlocks?: string[];
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateTransitGatewayConnectPeerRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String),
    TransitGatewayAddress: S.optional(S.String),
    PeerAddress: S.optional(S.String),
    BgpOptions: S.optional(TransitGatewayConnectRequestBgpOptions),
    InsideCidrBlocks: S.optional(InsideCidrBlocksStringList),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTransitGatewayConnectPeerRequest",
}) as any as S.Schema<CreateTransitGatewayConnectPeerRequest>;
export type TransitGatewayConnectPeerState =
  | "pending"
  | "available"
  | "deleting"
  | "deleted"
  | (string & {});
export const TransitGatewayConnectPeerState = S.String;
export type BgpStatus = "up" | "down" | (string & {});
export const BgpStatus = S.String;
export interface TransitGatewayAttachmentBgpConfiguration {
  TransitGatewayAsn?: number;
  PeerAsn?: number;
  TransitGatewayAddress?: string;
  PeerAddress?: string;
  BgpStatus?: BgpStatus;
}
export const TransitGatewayAttachmentBgpConfiguration = S.suspend(() =>
  S.Struct({
    TransitGatewayAsn: S.optional(S.Number).pipe(
      T.XmlName("transitGatewayAsn"),
      T.Ec2QueryName("TransitGatewayAsn"),
    ),
    PeerAsn: S.optional(S.Number).pipe(
      T.XmlName("peerAsn"),
      T.Ec2QueryName("PeerAsn"),
    ),
    TransitGatewayAddress: S.optional(S.String).pipe(
      T.XmlName("transitGatewayAddress"),
      T.Ec2QueryName("TransitGatewayAddress"),
    ),
    PeerAddress: S.optional(S.String).pipe(
      T.XmlName("peerAddress"),
      T.Ec2QueryName("PeerAddress"),
    ),
    BgpStatus: S.optional(BgpStatus).pipe(
      T.XmlName("bgpStatus"),
      T.Ec2QueryName("BgpStatus"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayAttachmentBgpConfiguration",
}) as any as S.Schema<TransitGatewayAttachmentBgpConfiguration>;
export type TransitGatewayAttachmentBgpConfigurationList =
  TransitGatewayAttachmentBgpConfiguration[];
export const TransitGatewayAttachmentBgpConfigurationList = S.Array(
  TransitGatewayAttachmentBgpConfiguration.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayAttachmentBgpConfiguration",
  }),
);
export interface TransitGatewayConnectPeerConfiguration {
  TransitGatewayAddress?: string;
  PeerAddress?: string;
  InsideCidrBlocks?: string[];
  Protocol?: ProtocolValue;
  BgpConfigurations?: TransitGatewayAttachmentBgpConfiguration[];
}
export const TransitGatewayConnectPeerConfiguration = S.suspend(() =>
  S.Struct({
    TransitGatewayAddress: S.optional(S.String).pipe(
      T.XmlName("transitGatewayAddress"),
      T.Ec2QueryName("TransitGatewayAddress"),
    ),
    PeerAddress: S.optional(S.String).pipe(
      T.XmlName("peerAddress"),
      T.Ec2QueryName("PeerAddress"),
    ),
    InsideCidrBlocks: S.optional(InsideCidrBlocksStringList).pipe(
      T.XmlName("insideCidrBlocks"),
      T.Ec2QueryName("InsideCidrBlocks"),
    ),
    Protocol: S.optional(ProtocolValue).pipe(
      T.XmlName("protocol"),
      T.Ec2QueryName("Protocol"),
    ),
    BgpConfigurations: S.optional(
      TransitGatewayAttachmentBgpConfigurationList,
    ).pipe(T.XmlName("bgpConfigurations"), T.Ec2QueryName("BgpConfigurations")),
  }),
).annotate({
  identifier: "TransitGatewayConnectPeerConfiguration",
}) as any as S.Schema<TransitGatewayConnectPeerConfiguration>;
export interface TransitGatewayConnectPeer {
  TransitGatewayAttachmentId?: string;
  TransitGatewayConnectPeerId?: string;
  State?: TransitGatewayConnectPeerState;
  CreationTime?: Date;
  ConnectPeerConfiguration?: TransitGatewayConnectPeerConfiguration;
  Tags?: Tag[];
}
export const TransitGatewayConnectPeer = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayAttachmentId"),
      T.Ec2QueryName("TransitGatewayAttachmentId"),
    ),
    TransitGatewayConnectPeerId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayConnectPeerId"),
      T.Ec2QueryName("TransitGatewayConnectPeerId"),
    ),
    State: S.optional(TransitGatewayConnectPeerState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    CreationTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("creationTime"), T.Ec2QueryName("CreationTime")),
    ConnectPeerConfiguration: S.optional(TransitGatewayConnectPeerConfiguration)
      .pipe(
        T.XmlName("connectPeerConfiguration"),
        T.Ec2QueryName("ConnectPeerConfiguration"),
      )
      .annotate({ identifier: "TransitGatewayConnectPeerConfiguration" }),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayConnectPeer",
}) as any as S.Schema<TransitGatewayConnectPeer>;
export interface CreateTransitGatewayConnectPeerResult {
  TransitGatewayConnectPeer?: TransitGatewayConnectPeer;
}
export const CreateTransitGatewayConnectPeerResult = S.suspend(() =>
  S.Struct({
    TransitGatewayConnectPeer: S.optional(TransitGatewayConnectPeer)
      .pipe(
        T.XmlName("transitGatewayConnectPeer"),
        T.Ec2QueryName("TransitGatewayConnectPeer"),
      )
      .annotate({ identifier: "TransitGatewayConnectPeer" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateTransitGatewayConnectPeerResult",
}) as any as S.Schema<CreateTransitGatewayConnectPeerResult>;
export type TransitGatewayAttachmentIdStringList = string[];
export const TransitGatewayAttachmentIdStringList = S.Array(S.String);
export interface CreateTransitGatewayMeteringPolicyRequest {
  TransitGatewayId?: string;
  MiddleboxAttachmentIds?: string[];
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateTransitGatewayMeteringPolicyRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayId: S.optional(S.String),
    MiddleboxAttachmentIds: S.optional(
      TransitGatewayAttachmentIdStringList,
    ).pipe(T.XmlName("MiddleboxAttachmentId")),
    TagSpecifications: S.optional(TagSpecificationList),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTransitGatewayMeteringPolicyRequest",
}) as any as S.Schema<CreateTransitGatewayMeteringPolicyRequest>;
export type TransitGatewayMeteringPolicyState =
  | "available"
  | "deleted"
  | "pending"
  | "modifying"
  | "deleting"
  | (string & {});
export const TransitGatewayMeteringPolicyState = S.String;
export interface TransitGatewayMeteringPolicy {
  TransitGatewayMeteringPolicyId?: string;
  TransitGatewayId?: string;
  MiddleboxAttachmentIds?: string[];
  State?: TransitGatewayMeteringPolicyState;
  UpdateEffectiveAt?: Date;
  Tags?: Tag[];
}
export const TransitGatewayMeteringPolicy = S.suspend(() =>
  S.Struct({
    TransitGatewayMeteringPolicyId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayMeteringPolicyId"),
      T.Ec2QueryName("TransitGatewayMeteringPolicyId"),
    ),
    TransitGatewayId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayId"),
      T.Ec2QueryName("TransitGatewayId"),
    ),
    MiddleboxAttachmentIds: S.optional(ValueStringList).pipe(
      T.XmlName("middleboxAttachmentIdSet"),
      T.Ec2QueryName("MiddleboxAttachmentIdSet"),
    ),
    State: S.optional(TransitGatewayMeteringPolicyState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    UpdateEffectiveAt: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("updateEffectiveAt"), T.Ec2QueryName("UpdateEffectiveAt")),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayMeteringPolicy",
}) as any as S.Schema<TransitGatewayMeteringPolicy>;
export interface CreateTransitGatewayMeteringPolicyResult {
  TransitGatewayMeteringPolicy?: TransitGatewayMeteringPolicy;
}
export const CreateTransitGatewayMeteringPolicyResult = S.suspend(() =>
  S.Struct({
    TransitGatewayMeteringPolicy: S.optional(TransitGatewayMeteringPolicy)
      .pipe(
        T.XmlName("transitGatewayMeteringPolicy"),
        T.Ec2QueryName("TransitGatewayMeteringPolicy"),
      )
      .annotate({ identifier: "TransitGatewayMeteringPolicy" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateTransitGatewayMeteringPolicyResult",
}) as any as S.Schema<CreateTransitGatewayMeteringPolicyResult>;
export type TransitGatewayMeteringPayerType =
  | "source-attachment-owner"
  | "destination-attachment-owner"
  | "transit-gateway-owner"
  | (string & {});
export const TransitGatewayMeteringPayerType = S.String;
export interface CreateTransitGatewayMeteringPolicyEntryRequest {
  TransitGatewayMeteringPolicyId?: string;
  PolicyRuleNumber?: number;
  SourceTransitGatewayAttachmentId?: string;
  SourceTransitGatewayAttachmentType?: TransitGatewayAttachmentResourceType;
  SourceCidrBlock?: string;
  SourcePortRange?: string;
  DestinationTransitGatewayAttachmentId?: string;
  DestinationTransitGatewayAttachmentType?: TransitGatewayAttachmentResourceType;
  DestinationCidrBlock?: string;
  DestinationPortRange?: string;
  Protocol?: string;
  MeteredAccount?: TransitGatewayMeteringPayerType;
  DryRun?: boolean;
}
export const CreateTransitGatewayMeteringPolicyEntryRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayMeteringPolicyId: S.optional(S.String),
    PolicyRuleNumber: S.optional(S.Number),
    SourceTransitGatewayAttachmentId: S.optional(S.String),
    SourceTransitGatewayAttachmentType: S.optional(
      TransitGatewayAttachmentResourceType,
    ),
    SourceCidrBlock: S.optional(S.String),
    SourcePortRange: S.optional(S.String),
    DestinationTransitGatewayAttachmentId: S.optional(S.String),
    DestinationTransitGatewayAttachmentType: S.optional(
      TransitGatewayAttachmentResourceType,
    ),
    DestinationCidrBlock: S.optional(S.String),
    DestinationPortRange: S.optional(S.String),
    Protocol: S.optional(S.String),
    MeteredAccount: S.optional(TransitGatewayMeteringPayerType),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTransitGatewayMeteringPolicyEntryRequest",
}) as any as S.Schema<CreateTransitGatewayMeteringPolicyEntryRequest>;
export type TransitGatewayMeteringPolicyEntryState =
  | "available"
  | "deleted"
  | (string & {});
export const TransitGatewayMeteringPolicyEntryState = S.String;
export interface TransitGatewayMeteringPolicyRule {
  SourceTransitGatewayAttachmentId?: string;
  SourceTransitGatewayAttachmentType?: TransitGatewayAttachmentResourceType;
  SourceCidrBlock?: string;
  SourcePortRange?: string;
  DestinationTransitGatewayAttachmentId?: string;
  DestinationTransitGatewayAttachmentType?: TransitGatewayAttachmentResourceType;
  DestinationCidrBlock?: string;
  DestinationPortRange?: string;
  Protocol?: string;
}
export const TransitGatewayMeteringPolicyRule = S.suspend(() =>
  S.Struct({
    SourceTransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("sourceTransitGatewayAttachmentId"),
      T.Ec2QueryName("SourceTransitGatewayAttachmentId"),
    ),
    SourceTransitGatewayAttachmentType: S.optional(
      TransitGatewayAttachmentResourceType,
    ).pipe(
      T.XmlName("sourceTransitGatewayAttachmentType"),
      T.Ec2QueryName("SourceTransitGatewayAttachmentType"),
    ),
    SourceCidrBlock: S.optional(S.String).pipe(
      T.XmlName("sourceCidrBlock"),
      T.Ec2QueryName("SourceCidrBlock"),
    ),
    SourcePortRange: S.optional(S.String).pipe(
      T.XmlName("sourcePortRange"),
      T.Ec2QueryName("SourcePortRange"),
    ),
    DestinationTransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("destinationTransitGatewayAttachmentId"),
      T.Ec2QueryName("DestinationTransitGatewayAttachmentId"),
    ),
    DestinationTransitGatewayAttachmentType: S.optional(
      TransitGatewayAttachmentResourceType,
    ).pipe(
      T.XmlName("destinationTransitGatewayAttachmentType"),
      T.Ec2QueryName("DestinationTransitGatewayAttachmentType"),
    ),
    DestinationCidrBlock: S.optional(S.String).pipe(
      T.XmlName("destinationCidrBlock"),
      T.Ec2QueryName("DestinationCidrBlock"),
    ),
    DestinationPortRange: S.optional(S.String).pipe(
      T.XmlName("destinationPortRange"),
      T.Ec2QueryName("DestinationPortRange"),
    ),
    Protocol: S.optional(S.String).pipe(
      T.XmlName("protocol"),
      T.Ec2QueryName("Protocol"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayMeteringPolicyRule",
}) as any as S.Schema<TransitGatewayMeteringPolicyRule>;
export interface TransitGatewayMeteringPolicyEntry {
  PolicyRuleNumber?: string;
  MeteredAccount?: TransitGatewayMeteringPayerType;
  State?: TransitGatewayMeteringPolicyEntryState;
  UpdatedAt?: Date;
  UpdateEffectiveAt?: Date;
  MeteringPolicyRule?: TransitGatewayMeteringPolicyRule;
}
export const TransitGatewayMeteringPolicyEntry = S.suspend(() =>
  S.Struct({
    PolicyRuleNumber: S.optional(S.String).pipe(
      T.XmlName("policyRuleNumber"),
      T.Ec2QueryName("PolicyRuleNumber"),
    ),
    MeteredAccount: S.optional(TransitGatewayMeteringPayerType).pipe(
      T.XmlName("meteredAccount"),
      T.Ec2QueryName("MeteredAccount"),
    ),
    State: S.optional(TransitGatewayMeteringPolicyEntryState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    UpdatedAt: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("updatedAt"), T.Ec2QueryName("UpdatedAt")),
    UpdateEffectiveAt: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("updateEffectiveAt"), T.Ec2QueryName("UpdateEffectiveAt")),
    MeteringPolicyRule: S.optional(TransitGatewayMeteringPolicyRule)
      .pipe(
        T.XmlName("meteringPolicyRule"),
        T.Ec2QueryName("MeteringPolicyRule"),
      )
      .annotate({ identifier: "TransitGatewayMeteringPolicyRule" }),
  }),
).annotate({
  identifier: "TransitGatewayMeteringPolicyEntry",
}) as any as S.Schema<TransitGatewayMeteringPolicyEntry>;
export interface CreateTransitGatewayMeteringPolicyEntryResult {
  TransitGatewayMeteringPolicyEntry?: TransitGatewayMeteringPolicyEntry;
}
export const CreateTransitGatewayMeteringPolicyEntryResult = S.suspend(() =>
  S.Struct({
    TransitGatewayMeteringPolicyEntry: S.optional(
      TransitGatewayMeteringPolicyEntry,
    )
      .pipe(
        T.XmlName("transitGatewayMeteringPolicyEntry"),
        T.Ec2QueryName("TransitGatewayMeteringPolicyEntry"),
      )
      .annotate({ identifier: "TransitGatewayMeteringPolicyEntry" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateTransitGatewayMeteringPolicyEntryResult",
}) as any as S.Schema<CreateTransitGatewayMeteringPolicyEntryResult>;
export type Igmpv2SupportValue = "enable" | "disable" | (string & {});
export const Igmpv2SupportValue = S.String;
export type StaticSourcesSupportValue = "enable" | "disable" | (string & {});
export const StaticSourcesSupportValue = S.String;
export type AutoAcceptSharedAssociationsValue =
  | "enable"
  | "disable"
  | (string & {});
export const AutoAcceptSharedAssociationsValue = S.String;
export interface CreateTransitGatewayMulticastDomainRequestOptions {
  Igmpv2Support?: Igmpv2SupportValue;
  StaticSourcesSupport?: StaticSourcesSupportValue;
  AutoAcceptSharedAssociations?: AutoAcceptSharedAssociationsValue;
}
export const CreateTransitGatewayMulticastDomainRequestOptions = S.suspend(() =>
  S.Struct({
    Igmpv2Support: S.optional(Igmpv2SupportValue),
    StaticSourcesSupport: S.optional(StaticSourcesSupportValue),
    AutoAcceptSharedAssociations: S.optional(AutoAcceptSharedAssociationsValue),
  }),
).annotate({
  identifier: "CreateTransitGatewayMulticastDomainRequestOptions",
}) as any as S.Schema<CreateTransitGatewayMulticastDomainRequestOptions>;
export interface CreateTransitGatewayMulticastDomainRequest {
  TransitGatewayId?: string;
  Options?: CreateTransitGatewayMulticastDomainRequestOptions;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateTransitGatewayMulticastDomainRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayId: S.optional(S.String),
    Options: S.optional(CreateTransitGatewayMulticastDomainRequestOptions),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTransitGatewayMulticastDomainRequest",
}) as any as S.Schema<CreateTransitGatewayMulticastDomainRequest>;
export interface TransitGatewayMulticastDomainOptions {
  Igmpv2Support?: Igmpv2SupportValue;
  StaticSourcesSupport?: StaticSourcesSupportValue;
  AutoAcceptSharedAssociations?: AutoAcceptSharedAssociationsValue;
}
export const TransitGatewayMulticastDomainOptions = S.suspend(() =>
  S.Struct({
    Igmpv2Support: S.optional(Igmpv2SupportValue).pipe(
      T.XmlName("igmpv2Support"),
      T.Ec2QueryName("Igmpv2Support"),
    ),
    StaticSourcesSupport: S.optional(StaticSourcesSupportValue).pipe(
      T.XmlName("staticSourcesSupport"),
      T.Ec2QueryName("StaticSourcesSupport"),
    ),
    AutoAcceptSharedAssociations: S.optional(
      AutoAcceptSharedAssociationsValue,
    ).pipe(
      T.XmlName("autoAcceptSharedAssociations"),
      T.Ec2QueryName("AutoAcceptSharedAssociations"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayMulticastDomainOptions",
}) as any as S.Schema<TransitGatewayMulticastDomainOptions>;
export type TransitGatewayMulticastDomainState =
  | "pending"
  | "available"
  | "deleting"
  | "deleted"
  | (string & {});
export const TransitGatewayMulticastDomainState = S.String;
export interface TransitGatewayMulticastDomain {
  TransitGatewayMulticastDomainId?: string;
  TransitGatewayId?: string;
  TransitGatewayMulticastDomainArn?: string;
  OwnerId?: string;
  Options?: TransitGatewayMulticastDomainOptions;
  State?: TransitGatewayMulticastDomainState;
  CreationTime?: Date;
  Tags?: Tag[];
}
export const TransitGatewayMulticastDomain = S.suspend(() =>
  S.Struct({
    TransitGatewayMulticastDomainId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayMulticastDomainId"),
      T.Ec2QueryName("TransitGatewayMulticastDomainId"),
    ),
    TransitGatewayId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayId"),
      T.Ec2QueryName("TransitGatewayId"),
    ),
    TransitGatewayMulticastDomainArn: S.optional(S.String).pipe(
      T.XmlName("transitGatewayMulticastDomainArn"),
      T.Ec2QueryName("TransitGatewayMulticastDomainArn"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    Options: S.optional(TransitGatewayMulticastDomainOptions)
      .pipe(T.XmlName("options"), T.Ec2QueryName("Options"))
      .annotate({ identifier: "TransitGatewayMulticastDomainOptions" }),
    State: S.optional(TransitGatewayMulticastDomainState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    CreationTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("creationTime"), T.Ec2QueryName("CreationTime")),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayMulticastDomain",
}) as any as S.Schema<TransitGatewayMulticastDomain>;
export interface CreateTransitGatewayMulticastDomainResult {
  TransitGatewayMulticastDomain?: TransitGatewayMulticastDomain;
}
export const CreateTransitGatewayMulticastDomainResult = S.suspend(() =>
  S.Struct({
    TransitGatewayMulticastDomain: S.optional(TransitGatewayMulticastDomain)
      .pipe(
        T.XmlName("transitGatewayMulticastDomain"),
        T.Ec2QueryName("TransitGatewayMulticastDomain"),
      )
      .annotate({ identifier: "TransitGatewayMulticastDomain" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateTransitGatewayMulticastDomainResult",
}) as any as S.Schema<CreateTransitGatewayMulticastDomainResult>;
export interface CreateTransitGatewayPeeringAttachmentRequestOptions {
  DynamicRouting?: DynamicRoutingValue;
}
export const CreateTransitGatewayPeeringAttachmentRequestOptions = S.suspend(
  () => S.Struct({ DynamicRouting: S.optional(DynamicRoutingValue) }),
).annotate({
  identifier: "CreateTransitGatewayPeeringAttachmentRequestOptions",
}) as any as S.Schema<CreateTransitGatewayPeeringAttachmentRequestOptions>;
export interface CreateTransitGatewayPeeringAttachmentRequest {
  TransitGatewayId?: string;
  PeerTransitGatewayId?: string;
  PeerAccountId?: string;
  PeerRegion?: string;
  Options?: CreateTransitGatewayPeeringAttachmentRequestOptions;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateTransitGatewayPeeringAttachmentRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayId: S.optional(S.String),
    PeerTransitGatewayId: S.optional(S.String),
    PeerAccountId: S.optional(S.String),
    PeerRegion: S.optional(S.String),
    Options: S.optional(CreateTransitGatewayPeeringAttachmentRequestOptions),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTransitGatewayPeeringAttachmentRequest",
}) as any as S.Schema<CreateTransitGatewayPeeringAttachmentRequest>;
export interface CreateTransitGatewayPeeringAttachmentResult {
  TransitGatewayPeeringAttachment?: TransitGatewayPeeringAttachment;
}
export const CreateTransitGatewayPeeringAttachmentResult = S.suspend(() =>
  S.Struct({
    TransitGatewayPeeringAttachment: S.optional(TransitGatewayPeeringAttachment)
      .pipe(
        T.XmlName("transitGatewayPeeringAttachment"),
        T.Ec2QueryName("TransitGatewayPeeringAttachment"),
      )
      .annotate({ identifier: "TransitGatewayPeeringAttachment" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateTransitGatewayPeeringAttachmentResult",
}) as any as S.Schema<CreateTransitGatewayPeeringAttachmentResult>;
export interface CreateTransitGatewayPolicyTableRequest {
  TransitGatewayId?: string;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateTransitGatewayPolicyTableRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayId: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTransitGatewayPolicyTableRequest",
}) as any as S.Schema<CreateTransitGatewayPolicyTableRequest>;
export type TransitGatewayPolicyTableState =
  | "pending"
  | "available"
  | "deleting"
  | "deleted"
  | (string & {});
export const TransitGatewayPolicyTableState = S.String;
export interface TransitGatewayPolicyTable {
  TransitGatewayPolicyTableId?: string;
  TransitGatewayId?: string;
  State?: TransitGatewayPolicyTableState;
  CreationTime?: Date;
  Tags?: Tag[];
}
export const TransitGatewayPolicyTable = S.suspend(() =>
  S.Struct({
    TransitGatewayPolicyTableId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayPolicyTableId"),
      T.Ec2QueryName("TransitGatewayPolicyTableId"),
    ),
    TransitGatewayId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayId"),
      T.Ec2QueryName("TransitGatewayId"),
    ),
    State: S.optional(TransitGatewayPolicyTableState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    CreationTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("creationTime"), T.Ec2QueryName("CreationTime")),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayPolicyTable",
}) as any as S.Schema<TransitGatewayPolicyTable>;
export interface CreateTransitGatewayPolicyTableResult {
  TransitGatewayPolicyTable?: TransitGatewayPolicyTable;
}
export const CreateTransitGatewayPolicyTableResult = S.suspend(() =>
  S.Struct({
    TransitGatewayPolicyTable: S.optional(TransitGatewayPolicyTable)
      .pipe(
        T.XmlName("transitGatewayPolicyTable"),
        T.Ec2QueryName("TransitGatewayPolicyTable"),
      )
      .annotate({ identifier: "TransitGatewayPolicyTable" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateTransitGatewayPolicyTableResult",
}) as any as S.Schema<CreateTransitGatewayPolicyTableResult>;
export interface CreateTransitGatewayPrefixListReferenceRequest {
  TransitGatewayRouteTableId?: string;
  PrefixListId?: string;
  TransitGatewayAttachmentId?: string;
  Blackhole?: boolean;
  DryRun?: boolean;
}
export const CreateTransitGatewayPrefixListReferenceRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String),
    PrefixListId: S.optional(S.String),
    TransitGatewayAttachmentId: S.optional(S.String),
    Blackhole: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTransitGatewayPrefixListReferenceRequest",
}) as any as S.Schema<CreateTransitGatewayPrefixListReferenceRequest>;
export type TransitGatewayPrefixListReferenceState =
  | "pending"
  | "available"
  | "modifying"
  | "deleting"
  | (string & {});
export const TransitGatewayPrefixListReferenceState = S.String;
export interface TransitGatewayPrefixListAttachment {
  TransitGatewayAttachmentId?: string;
  ResourceType?: TransitGatewayAttachmentResourceType;
  ResourceId?: string;
}
export const TransitGatewayPrefixListAttachment = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayAttachmentId"),
      T.Ec2QueryName("TransitGatewayAttachmentId"),
    ),
    ResourceType: S.optional(TransitGatewayAttachmentResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayPrefixListAttachment",
}) as any as S.Schema<TransitGatewayPrefixListAttachment>;
export interface TransitGatewayPrefixListReference {
  TransitGatewayRouteTableId?: string;
  PrefixListId?: string;
  PrefixListOwnerId?: string;
  State?: TransitGatewayPrefixListReferenceState;
  Blackhole?: boolean;
  TransitGatewayAttachment?: TransitGatewayPrefixListAttachment;
}
export const TransitGatewayPrefixListReference = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayRouteTableId"),
      T.Ec2QueryName("TransitGatewayRouteTableId"),
    ),
    PrefixListId: S.optional(S.String).pipe(
      T.XmlName("prefixListId"),
      T.Ec2QueryName("PrefixListId"),
    ),
    PrefixListOwnerId: S.optional(S.String).pipe(
      T.XmlName("prefixListOwnerId"),
      T.Ec2QueryName("PrefixListOwnerId"),
    ),
    State: S.optional(TransitGatewayPrefixListReferenceState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Blackhole: S.optional(S.Boolean).pipe(
      T.XmlName("blackhole"),
      T.Ec2QueryName("Blackhole"),
    ),
    TransitGatewayAttachment: S.optional(TransitGatewayPrefixListAttachment)
      .pipe(
        T.XmlName("transitGatewayAttachment"),
        T.Ec2QueryName("TransitGatewayAttachment"),
      )
      .annotate({ identifier: "TransitGatewayPrefixListAttachment" }),
  }),
).annotate({
  identifier: "TransitGatewayPrefixListReference",
}) as any as S.Schema<TransitGatewayPrefixListReference>;
export interface CreateTransitGatewayPrefixListReferenceResult {
  TransitGatewayPrefixListReference?: TransitGatewayPrefixListReference;
}
export const CreateTransitGatewayPrefixListReferenceResult = S.suspend(() =>
  S.Struct({
    TransitGatewayPrefixListReference: S.optional(
      TransitGatewayPrefixListReference,
    )
      .pipe(
        T.XmlName("transitGatewayPrefixListReference"),
        T.Ec2QueryName("TransitGatewayPrefixListReference"),
      )
      .annotate({ identifier: "TransitGatewayPrefixListReference" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateTransitGatewayPrefixListReferenceResult",
}) as any as S.Schema<CreateTransitGatewayPrefixListReferenceResult>;
export interface CreateTransitGatewayRouteRequest {
  DestinationCidrBlock?: string;
  TransitGatewayRouteTableId?: string;
  TransitGatewayAttachmentId?: string;
  Blackhole?: boolean;
  DryRun?: boolean;
}
export const CreateTransitGatewayRouteRequest = S.suspend(() =>
  S.Struct({
    DestinationCidrBlock: S.optional(S.String),
    TransitGatewayRouteTableId: S.optional(S.String),
    TransitGatewayAttachmentId: S.optional(S.String),
    Blackhole: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTransitGatewayRouteRequest",
}) as any as S.Schema<CreateTransitGatewayRouteRequest>;
export interface TransitGatewayRouteAttachment {
  ResourceId?: string;
  TransitGatewayAttachmentId?: string;
  ResourceType?: TransitGatewayAttachmentResourceType;
}
export const TransitGatewayRouteAttachment = S.suspend(() =>
  S.Struct({
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    TransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayAttachmentId"),
      T.Ec2QueryName("TransitGatewayAttachmentId"),
    ),
    ResourceType: S.optional(TransitGatewayAttachmentResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayRouteAttachment",
}) as any as S.Schema<TransitGatewayRouteAttachment>;
export type TransitGatewayRouteAttachmentList = TransitGatewayRouteAttachment[];
export const TransitGatewayRouteAttachmentList = S.Array(
  TransitGatewayRouteAttachment.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayRouteAttachment",
  }),
);
export type TransitGatewayRouteType = "static" | "propagated" | (string & {});
export const TransitGatewayRouteType = S.String;
export type TransitGatewayRouteState =
  | "pending"
  | "active"
  | "blackhole"
  | "deleting"
  | "deleted"
  | (string & {});
export const TransitGatewayRouteState = S.String;
export interface TransitGatewayRoute {
  DestinationCidrBlock?: string;
  PrefixListId?: string;
  TransitGatewayRouteTableAnnouncementId?: string;
  TransitGatewayAttachments?: TransitGatewayRouteAttachment[];
  Type?: TransitGatewayRouteType;
  State?: TransitGatewayRouteState;
}
export const TransitGatewayRoute = S.suspend(() =>
  S.Struct({
    DestinationCidrBlock: S.optional(S.String).pipe(
      T.XmlName("destinationCidrBlock"),
      T.Ec2QueryName("DestinationCidrBlock"),
    ),
    PrefixListId: S.optional(S.String).pipe(
      T.XmlName("prefixListId"),
      T.Ec2QueryName("PrefixListId"),
    ),
    TransitGatewayRouteTableAnnouncementId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayRouteTableAnnouncementId"),
      T.Ec2QueryName("TransitGatewayRouteTableAnnouncementId"),
    ),
    TransitGatewayAttachments: S.optional(
      TransitGatewayRouteAttachmentList,
    ).pipe(
      T.XmlName("transitGatewayAttachments"),
      T.Ec2QueryName("TransitGatewayAttachments"),
    ),
    Type: S.optional(TransitGatewayRouteType).pipe(
      T.XmlName("type"),
      T.Ec2QueryName("Type"),
    ),
    State: S.optional(TransitGatewayRouteState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayRoute",
}) as any as S.Schema<TransitGatewayRoute>;
export interface CreateTransitGatewayRouteResult {
  Route?: TransitGatewayRoute;
}
export const CreateTransitGatewayRouteResult = S.suspend(() =>
  S.Struct({
    Route: S.optional(TransitGatewayRoute)
      .pipe(T.XmlName("route"), T.Ec2QueryName("Route"))
      .annotate({ identifier: "TransitGatewayRoute" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateTransitGatewayRouteResult",
}) as any as S.Schema<CreateTransitGatewayRouteResult>;
export interface CreateTransitGatewayRouteTableRequest {
  TransitGatewayId?: string;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateTransitGatewayRouteTableRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayId: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTransitGatewayRouteTableRequest",
}) as any as S.Schema<CreateTransitGatewayRouteTableRequest>;
export type TransitGatewayRouteTableState =
  | "pending"
  | "available"
  | "deleting"
  | "deleted"
  | (string & {});
export const TransitGatewayRouteTableState = S.String;
export interface TransitGatewayRouteTable {
  TransitGatewayRouteTableId?: string;
  TransitGatewayId?: string;
  State?: TransitGatewayRouteTableState;
  DefaultAssociationRouteTable?: boolean;
  DefaultPropagationRouteTable?: boolean;
  CreationTime?: Date;
  Tags?: Tag[];
}
export const TransitGatewayRouteTable = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayRouteTableId"),
      T.Ec2QueryName("TransitGatewayRouteTableId"),
    ),
    TransitGatewayId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayId"),
      T.Ec2QueryName("TransitGatewayId"),
    ),
    State: S.optional(TransitGatewayRouteTableState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    DefaultAssociationRouteTable: S.optional(S.Boolean).pipe(
      T.XmlName("defaultAssociationRouteTable"),
      T.Ec2QueryName("DefaultAssociationRouteTable"),
    ),
    DefaultPropagationRouteTable: S.optional(S.Boolean).pipe(
      T.XmlName("defaultPropagationRouteTable"),
      T.Ec2QueryName("DefaultPropagationRouteTable"),
    ),
    CreationTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("creationTime"), T.Ec2QueryName("CreationTime")),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayRouteTable",
}) as any as S.Schema<TransitGatewayRouteTable>;
export interface CreateTransitGatewayRouteTableResult {
  TransitGatewayRouteTable?: TransitGatewayRouteTable;
}
export const CreateTransitGatewayRouteTableResult = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTable: S.optional(TransitGatewayRouteTable)
      .pipe(
        T.XmlName("transitGatewayRouteTable"),
        T.Ec2QueryName("TransitGatewayRouteTable"),
      )
      .annotate({ identifier: "TransitGatewayRouteTable" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateTransitGatewayRouteTableResult",
}) as any as S.Schema<CreateTransitGatewayRouteTableResult>;
export interface CreateTransitGatewayRouteTableAnnouncementRequest {
  TransitGatewayRouteTableId?: string;
  PeeringAttachmentId?: string;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateTransitGatewayRouteTableAnnouncementRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String),
    PeeringAttachmentId: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTransitGatewayRouteTableAnnouncementRequest",
}) as any as S.Schema<CreateTransitGatewayRouteTableAnnouncementRequest>;
export type TransitGatewayRouteTableAnnouncementDirection =
  | "outgoing"
  | "incoming"
  | (string & {});
export const TransitGatewayRouteTableAnnouncementDirection = S.String;
export type TransitGatewayRouteTableAnnouncementState =
  | "available"
  | "pending"
  | "failing"
  | "failed"
  | "deleting"
  | "deleted"
  | (string & {});
export const TransitGatewayRouteTableAnnouncementState = S.String;
export interface TransitGatewayRouteTableAnnouncement {
  TransitGatewayRouteTableAnnouncementId?: string;
  TransitGatewayId?: string;
  CoreNetworkId?: string;
  PeerTransitGatewayId?: string;
  PeerCoreNetworkId?: string;
  PeeringAttachmentId?: string;
  AnnouncementDirection?: TransitGatewayRouteTableAnnouncementDirection;
  TransitGatewayRouteTableId?: string;
  State?: TransitGatewayRouteTableAnnouncementState;
  CreationTime?: Date;
  Tags?: Tag[];
}
export const TransitGatewayRouteTableAnnouncement = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableAnnouncementId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayRouteTableAnnouncementId"),
      T.Ec2QueryName("TransitGatewayRouteTableAnnouncementId"),
    ),
    TransitGatewayId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayId"),
      T.Ec2QueryName("TransitGatewayId"),
    ),
    CoreNetworkId: S.optional(S.String).pipe(
      T.XmlName("coreNetworkId"),
      T.Ec2QueryName("CoreNetworkId"),
    ),
    PeerTransitGatewayId: S.optional(S.String).pipe(
      T.XmlName("peerTransitGatewayId"),
      T.Ec2QueryName("PeerTransitGatewayId"),
    ),
    PeerCoreNetworkId: S.optional(S.String).pipe(
      T.XmlName("peerCoreNetworkId"),
      T.Ec2QueryName("PeerCoreNetworkId"),
    ),
    PeeringAttachmentId: S.optional(S.String).pipe(
      T.XmlName("peeringAttachmentId"),
      T.Ec2QueryName("PeeringAttachmentId"),
    ),
    AnnouncementDirection: S.optional(
      TransitGatewayRouteTableAnnouncementDirection,
    ).pipe(
      T.XmlName("announcementDirection"),
      T.Ec2QueryName("AnnouncementDirection"),
    ),
    TransitGatewayRouteTableId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayRouteTableId"),
      T.Ec2QueryName("TransitGatewayRouteTableId"),
    ),
    State: S.optional(TransitGatewayRouteTableAnnouncementState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    CreationTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("creationTime"), T.Ec2QueryName("CreationTime")),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayRouteTableAnnouncement",
}) as any as S.Schema<TransitGatewayRouteTableAnnouncement>;
export interface CreateTransitGatewayRouteTableAnnouncementResult {
  TransitGatewayRouteTableAnnouncement?: TransitGatewayRouteTableAnnouncement;
}
export const CreateTransitGatewayRouteTableAnnouncementResult = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableAnnouncement: S.optional(
      TransitGatewayRouteTableAnnouncement,
    )
      .pipe(
        T.XmlName("transitGatewayRouteTableAnnouncement"),
        T.Ec2QueryName("TransitGatewayRouteTableAnnouncement"),
      )
      .annotate({ identifier: "TransitGatewayRouteTableAnnouncement" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateTransitGatewayRouteTableAnnouncementResult",
}) as any as S.Schema<CreateTransitGatewayRouteTableAnnouncementResult>;
export interface CreateTransitGatewayVpcAttachmentRequestOptions {
  DnsSupport?: DnsSupportValue;
  SecurityGroupReferencingSupport?: SecurityGroupReferencingSupportValue;
  Ipv6Support?: Ipv6SupportValue;
  ApplianceModeSupport?: ApplianceModeSupportValue;
}
export const CreateTransitGatewayVpcAttachmentRequestOptions = S.suspend(() =>
  S.Struct({
    DnsSupport: S.optional(DnsSupportValue),
    SecurityGroupReferencingSupport: S.optional(
      SecurityGroupReferencingSupportValue,
    ),
    Ipv6Support: S.optional(Ipv6SupportValue),
    ApplianceModeSupport: S.optional(ApplianceModeSupportValue),
  }),
).annotate({
  identifier: "CreateTransitGatewayVpcAttachmentRequestOptions",
}) as any as S.Schema<CreateTransitGatewayVpcAttachmentRequestOptions>;
export interface CreateTransitGatewayVpcAttachmentRequest {
  TransitGatewayId?: string;
  VpcId?: string;
  SubnetIds?: string[];
  Options?: CreateTransitGatewayVpcAttachmentRequestOptions;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateTransitGatewayVpcAttachmentRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayId: S.optional(S.String),
    VpcId: S.optional(S.String),
    SubnetIds: S.optional(TransitGatewaySubnetIdList),
    Options: S.optional(CreateTransitGatewayVpcAttachmentRequestOptions),
    TagSpecifications: S.optional(TagSpecificationList),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTransitGatewayVpcAttachmentRequest",
}) as any as S.Schema<CreateTransitGatewayVpcAttachmentRequest>;
export interface CreateTransitGatewayVpcAttachmentResult {
  TransitGatewayVpcAttachment?: TransitGatewayVpcAttachment;
}
export const CreateTransitGatewayVpcAttachmentResult = S.suspend(() =>
  S.Struct({
    TransitGatewayVpcAttachment: S.optional(TransitGatewayVpcAttachment)
      .pipe(
        T.XmlName("transitGatewayVpcAttachment"),
        T.Ec2QueryName("TransitGatewayVpcAttachment"),
      )
      .annotate({ identifier: "TransitGatewayVpcAttachment" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateTransitGatewayVpcAttachmentResult",
}) as any as S.Schema<CreateTransitGatewayVpcAttachmentResult>;
export type VerifiedAccessEndpointType =
  | "load-balancer"
  | "network-interface"
  | "rds"
  | "cidr"
  | (string & {});
export const VerifiedAccessEndpointType = S.String;
export type VerifiedAccessEndpointAttachmentType = "vpc" | (string & {});
export const VerifiedAccessEndpointAttachmentType = S.String;
export type SecurityGroupIdList = string[];
export const SecurityGroupIdList = S.Array(S.String.pipe(T.XmlName("item")));
export type VerifiedAccessEndpointProtocol =
  | "http"
  | "https"
  | "tcp"
  | (string & {});
export const VerifiedAccessEndpointProtocol = S.String;
export type CreateVerifiedAccessEndpointSubnetIdList = string[];
export const CreateVerifiedAccessEndpointSubnetIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface CreateVerifiedAccessEndpointPortRange {
  FromPort?: number;
  ToPort?: number;
}
export const CreateVerifiedAccessEndpointPortRange = S.suspend(() =>
  S.Struct({ FromPort: S.optional(S.Number), ToPort: S.optional(S.Number) }),
).annotate({
  identifier: "CreateVerifiedAccessEndpointPortRange",
}) as any as S.Schema<CreateVerifiedAccessEndpointPortRange>;
export type CreateVerifiedAccessEndpointPortRangeList =
  CreateVerifiedAccessEndpointPortRange[];
export const CreateVerifiedAccessEndpointPortRangeList = S.Array(
  CreateVerifiedAccessEndpointPortRange.pipe(T.XmlName("item")).annotate({
    identifier: "CreateVerifiedAccessEndpointPortRange",
  }),
);
export interface CreateVerifiedAccessEndpointLoadBalancerOptions {
  Protocol?: VerifiedAccessEndpointProtocol;
  Port?: number;
  LoadBalancerArn?: string;
  SubnetIds?: string[];
  PortRanges?: CreateVerifiedAccessEndpointPortRange[];
}
export const CreateVerifiedAccessEndpointLoadBalancerOptions = S.suspend(() =>
  S.Struct({
    Protocol: S.optional(VerifiedAccessEndpointProtocol),
    Port: S.optional(S.Number),
    LoadBalancerArn: S.optional(S.String),
    SubnetIds: S.optional(CreateVerifiedAccessEndpointSubnetIdList).pipe(
      T.XmlName("SubnetId"),
    ),
    PortRanges: S.optional(CreateVerifiedAccessEndpointPortRangeList).pipe(
      T.XmlName("PortRange"),
    ),
  }),
).annotate({
  identifier: "CreateVerifiedAccessEndpointLoadBalancerOptions",
}) as any as S.Schema<CreateVerifiedAccessEndpointLoadBalancerOptions>;
export interface CreateVerifiedAccessEndpointEniOptions {
  NetworkInterfaceId?: string;
  Protocol?: VerifiedAccessEndpointProtocol;
  Port?: number;
  PortRanges?: CreateVerifiedAccessEndpointPortRange[];
}
export const CreateVerifiedAccessEndpointEniOptions = S.suspend(() =>
  S.Struct({
    NetworkInterfaceId: S.optional(S.String),
    Protocol: S.optional(VerifiedAccessEndpointProtocol),
    Port: S.optional(S.Number),
    PortRanges: S.optional(CreateVerifiedAccessEndpointPortRangeList).pipe(
      T.XmlName("PortRange"),
    ),
  }),
).annotate({
  identifier: "CreateVerifiedAccessEndpointEniOptions",
}) as any as S.Schema<CreateVerifiedAccessEndpointEniOptions>;
export interface VerifiedAccessSseSpecificationRequest {
  CustomerManagedKeyEnabled?: boolean;
  KmsKeyArn?: string;
}
export const VerifiedAccessSseSpecificationRequest = S.suspend(() =>
  S.Struct({
    CustomerManagedKeyEnabled: S.optional(S.Boolean),
    KmsKeyArn: S.optional(S.String),
  }),
).annotate({
  identifier: "VerifiedAccessSseSpecificationRequest",
}) as any as S.Schema<VerifiedAccessSseSpecificationRequest>;
export interface CreateVerifiedAccessEndpointRdsOptions {
  Protocol?: VerifiedAccessEndpointProtocol;
  Port?: number;
  RdsDbInstanceArn?: string;
  RdsDbClusterArn?: string;
  RdsDbProxyArn?: string;
  RdsEndpoint?: string;
  SubnetIds?: string[];
}
export const CreateVerifiedAccessEndpointRdsOptions = S.suspend(() =>
  S.Struct({
    Protocol: S.optional(VerifiedAccessEndpointProtocol),
    Port: S.optional(S.Number),
    RdsDbInstanceArn: S.optional(S.String),
    RdsDbClusterArn: S.optional(S.String),
    RdsDbProxyArn: S.optional(S.String),
    RdsEndpoint: S.optional(S.String),
    SubnetIds: S.optional(CreateVerifiedAccessEndpointSubnetIdList).pipe(
      T.XmlName("SubnetId"),
    ),
  }),
).annotate({
  identifier: "CreateVerifiedAccessEndpointRdsOptions",
}) as any as S.Schema<CreateVerifiedAccessEndpointRdsOptions>;
export interface CreateVerifiedAccessEndpointCidrOptions {
  Protocol?: VerifiedAccessEndpointProtocol;
  SubnetIds?: string[];
  Cidr?: string;
  PortRanges?: CreateVerifiedAccessEndpointPortRange[];
}
export const CreateVerifiedAccessEndpointCidrOptions = S.suspend(() =>
  S.Struct({
    Protocol: S.optional(VerifiedAccessEndpointProtocol),
    SubnetIds: S.optional(CreateVerifiedAccessEndpointSubnetIdList).pipe(
      T.XmlName("SubnetId"),
    ),
    Cidr: S.optional(S.String),
    PortRanges: S.optional(CreateVerifiedAccessEndpointPortRangeList).pipe(
      T.XmlName("PortRange"),
    ),
  }),
).annotate({
  identifier: "CreateVerifiedAccessEndpointCidrOptions",
}) as any as S.Schema<CreateVerifiedAccessEndpointCidrOptions>;
export interface CreateVerifiedAccessEndpointRequest {
  VerifiedAccessGroupId?: string;
  EndpointType?: VerifiedAccessEndpointType;
  AttachmentType?: VerifiedAccessEndpointAttachmentType;
  DomainCertificateArn?: string;
  ApplicationDomain?: string;
  EndpointDomainPrefix?: string;
  SecurityGroupIds?: string[];
  LoadBalancerOptions?: CreateVerifiedAccessEndpointLoadBalancerOptions;
  NetworkInterfaceOptions?: CreateVerifiedAccessEndpointEniOptions;
  Description?: string;
  PolicyDocument?: string;
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
  DryRun?: boolean;
  SseSpecification?: VerifiedAccessSseSpecificationRequest;
  RdsOptions?: CreateVerifiedAccessEndpointRdsOptions;
  CidrOptions?: CreateVerifiedAccessEndpointCidrOptions;
}
export const CreateVerifiedAccessEndpointRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessGroupId: S.optional(S.String),
    EndpointType: S.optional(VerifiedAccessEndpointType),
    AttachmentType: S.optional(VerifiedAccessEndpointAttachmentType),
    DomainCertificateArn: S.optional(S.String),
    ApplicationDomain: S.optional(S.String),
    EndpointDomainPrefix: S.optional(S.String),
    SecurityGroupIds: S.optional(SecurityGroupIdList).pipe(
      T.XmlName("SecurityGroupId"),
    ),
    LoadBalancerOptions: S.optional(
      CreateVerifiedAccessEndpointLoadBalancerOptions,
    ),
    NetworkInterfaceOptions: S.optional(CreateVerifiedAccessEndpointEniOptions),
    Description: S.optional(S.String),
    PolicyDocument: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
    SseSpecification: S.optional(VerifiedAccessSseSpecificationRequest),
    RdsOptions: S.optional(CreateVerifiedAccessEndpointRdsOptions),
    CidrOptions: S.optional(CreateVerifiedAccessEndpointCidrOptions),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateVerifiedAccessEndpointRequest",
}) as any as S.Schema<CreateVerifiedAccessEndpointRequest>;
export type VerifiedAccessEndpointSubnetIdList = string[];
export const VerifiedAccessEndpointSubnetIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface VerifiedAccessEndpointPortRange {
  FromPort?: number;
  ToPort?: number;
}
export const VerifiedAccessEndpointPortRange = S.suspend(() =>
  S.Struct({
    FromPort: S.optional(S.Number).pipe(
      T.XmlName("fromPort"),
      T.Ec2QueryName("FromPort"),
    ),
    ToPort: S.optional(S.Number).pipe(
      T.XmlName("toPort"),
      T.Ec2QueryName("ToPort"),
    ),
  }),
).annotate({
  identifier: "VerifiedAccessEndpointPortRange",
}) as any as S.Schema<VerifiedAccessEndpointPortRange>;
export type VerifiedAccessEndpointPortRangeList =
  VerifiedAccessEndpointPortRange[];
export const VerifiedAccessEndpointPortRangeList = S.Array(
  VerifiedAccessEndpointPortRange.pipe(T.XmlName("item")).annotate({
    identifier: "VerifiedAccessEndpointPortRange",
  }),
);
export interface VerifiedAccessEndpointLoadBalancerOptions {
  Protocol?: VerifiedAccessEndpointProtocol;
  Port?: number;
  LoadBalancerArn?: string;
  SubnetIds?: string[];
  PortRanges?: VerifiedAccessEndpointPortRange[];
}
export const VerifiedAccessEndpointLoadBalancerOptions = S.suspend(() =>
  S.Struct({
    Protocol: S.optional(VerifiedAccessEndpointProtocol).pipe(
      T.XmlName("protocol"),
      T.Ec2QueryName("Protocol"),
    ),
    Port: S.optional(S.Number).pipe(T.XmlName("port"), T.Ec2QueryName("Port")),
    LoadBalancerArn: S.optional(S.String).pipe(
      T.XmlName("loadBalancerArn"),
      T.Ec2QueryName("LoadBalancerArn"),
    ),
    SubnetIds: S.optional(VerifiedAccessEndpointSubnetIdList).pipe(
      T.XmlName("subnetIdSet"),
      T.Ec2QueryName("SubnetIdSet"),
    ),
    PortRanges: S.optional(VerifiedAccessEndpointPortRangeList).pipe(
      T.XmlName("portRangeSet"),
      T.Ec2QueryName("PortRangeSet"),
    ),
  }),
).annotate({
  identifier: "VerifiedAccessEndpointLoadBalancerOptions",
}) as any as S.Schema<VerifiedAccessEndpointLoadBalancerOptions>;
export interface VerifiedAccessEndpointEniOptions {
  NetworkInterfaceId?: string;
  Protocol?: VerifiedAccessEndpointProtocol;
  Port?: number;
  PortRanges?: VerifiedAccessEndpointPortRange[];
}
export const VerifiedAccessEndpointEniOptions = S.suspend(() =>
  S.Struct({
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    Protocol: S.optional(VerifiedAccessEndpointProtocol).pipe(
      T.XmlName("protocol"),
      T.Ec2QueryName("Protocol"),
    ),
    Port: S.optional(S.Number).pipe(T.XmlName("port"), T.Ec2QueryName("Port")),
    PortRanges: S.optional(VerifiedAccessEndpointPortRangeList).pipe(
      T.XmlName("portRangeSet"),
      T.Ec2QueryName("PortRangeSet"),
    ),
  }),
).annotate({
  identifier: "VerifiedAccessEndpointEniOptions",
}) as any as S.Schema<VerifiedAccessEndpointEniOptions>;
export type VerifiedAccessEndpointStatusCode =
  | "pending"
  | "active"
  | "updating"
  | "deleting"
  | "deleted"
  | (string & {});
export const VerifiedAccessEndpointStatusCode = S.String;
export interface VerifiedAccessEndpointStatus {
  Code?: VerifiedAccessEndpointStatusCode;
  Message?: string;
}
export const VerifiedAccessEndpointStatus = S.suspend(() =>
  S.Struct({
    Code: S.optional(VerifiedAccessEndpointStatusCode).pipe(
      T.XmlName("code"),
      T.Ec2QueryName("Code"),
    ),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "VerifiedAccessEndpointStatus",
}) as any as S.Schema<VerifiedAccessEndpointStatus>;
export interface VerifiedAccessEndpointRdsOptions {
  Protocol?: VerifiedAccessEndpointProtocol;
  Port?: number;
  RdsDbInstanceArn?: string;
  RdsDbClusterArn?: string;
  RdsDbProxyArn?: string;
  RdsEndpoint?: string;
  SubnetIds?: string[];
}
export const VerifiedAccessEndpointRdsOptions = S.suspend(() =>
  S.Struct({
    Protocol: S.optional(VerifiedAccessEndpointProtocol).pipe(
      T.XmlName("protocol"),
      T.Ec2QueryName("Protocol"),
    ),
    Port: S.optional(S.Number).pipe(T.XmlName("port"), T.Ec2QueryName("Port")),
    RdsDbInstanceArn: S.optional(S.String).pipe(
      T.XmlName("rdsDbInstanceArn"),
      T.Ec2QueryName("RdsDbInstanceArn"),
    ),
    RdsDbClusterArn: S.optional(S.String).pipe(
      T.XmlName("rdsDbClusterArn"),
      T.Ec2QueryName("RdsDbClusterArn"),
    ),
    RdsDbProxyArn: S.optional(S.String).pipe(
      T.XmlName("rdsDbProxyArn"),
      T.Ec2QueryName("RdsDbProxyArn"),
    ),
    RdsEndpoint: S.optional(S.String).pipe(
      T.XmlName("rdsEndpoint"),
      T.Ec2QueryName("RdsEndpoint"),
    ),
    SubnetIds: S.optional(VerifiedAccessEndpointSubnetIdList).pipe(
      T.XmlName("subnetIdSet"),
      T.Ec2QueryName("SubnetIdSet"),
    ),
  }),
).annotate({
  identifier: "VerifiedAccessEndpointRdsOptions",
}) as any as S.Schema<VerifiedAccessEndpointRdsOptions>;
export interface VerifiedAccessEndpointCidrOptions {
  Cidr?: string;
  PortRanges?: VerifiedAccessEndpointPortRange[];
  Protocol?: VerifiedAccessEndpointProtocol;
  SubnetIds?: string[];
}
export const VerifiedAccessEndpointCidrOptions = S.suspend(() =>
  S.Struct({
    Cidr: S.optional(S.String).pipe(T.XmlName("cidr"), T.Ec2QueryName("Cidr")),
    PortRanges: S.optional(VerifiedAccessEndpointPortRangeList).pipe(
      T.XmlName("portRangeSet"),
      T.Ec2QueryName("PortRangeSet"),
    ),
    Protocol: S.optional(VerifiedAccessEndpointProtocol).pipe(
      T.XmlName("protocol"),
      T.Ec2QueryName("Protocol"),
    ),
    SubnetIds: S.optional(VerifiedAccessEndpointSubnetIdList).pipe(
      T.XmlName("subnetIdSet"),
      T.Ec2QueryName("SubnetIdSet"),
    ),
  }),
).annotate({
  identifier: "VerifiedAccessEndpointCidrOptions",
}) as any as S.Schema<VerifiedAccessEndpointCidrOptions>;
export interface VerifiedAccessEndpoint {
  VerifiedAccessInstanceId?: string;
  VerifiedAccessGroupId?: string;
  VerifiedAccessEndpointId?: string;
  ApplicationDomain?: string;
  EndpointType?: VerifiedAccessEndpointType;
  AttachmentType?: VerifiedAccessEndpointAttachmentType;
  DomainCertificateArn?: string;
  EndpointDomain?: string;
  DeviceValidationDomain?: string;
  SecurityGroupIds?: string[];
  LoadBalancerOptions?: VerifiedAccessEndpointLoadBalancerOptions;
  NetworkInterfaceOptions?: VerifiedAccessEndpointEniOptions;
  Status?: VerifiedAccessEndpointStatus;
  Description?: string;
  CreationTime?: string;
  LastUpdatedTime?: string;
  DeletionTime?: string;
  Tags?: Tag[];
  SseSpecification?: VerifiedAccessSseSpecificationResponse;
  RdsOptions?: VerifiedAccessEndpointRdsOptions;
  CidrOptions?: VerifiedAccessEndpointCidrOptions;
}
export const VerifiedAccessEndpoint = S.suspend(() =>
  S.Struct({
    VerifiedAccessInstanceId: S.optional(S.String).pipe(
      T.XmlName("verifiedAccessInstanceId"),
      T.Ec2QueryName("VerifiedAccessInstanceId"),
    ),
    VerifiedAccessGroupId: S.optional(S.String).pipe(
      T.XmlName("verifiedAccessGroupId"),
      T.Ec2QueryName("VerifiedAccessGroupId"),
    ),
    VerifiedAccessEndpointId: S.optional(S.String).pipe(
      T.XmlName("verifiedAccessEndpointId"),
      T.Ec2QueryName("VerifiedAccessEndpointId"),
    ),
    ApplicationDomain: S.optional(S.String).pipe(
      T.XmlName("applicationDomain"),
      T.Ec2QueryName("ApplicationDomain"),
    ),
    EndpointType: S.optional(VerifiedAccessEndpointType).pipe(
      T.XmlName("endpointType"),
      T.Ec2QueryName("EndpointType"),
    ),
    AttachmentType: S.optional(VerifiedAccessEndpointAttachmentType).pipe(
      T.XmlName("attachmentType"),
      T.Ec2QueryName("AttachmentType"),
    ),
    DomainCertificateArn: S.optional(S.String).pipe(
      T.XmlName("domainCertificateArn"),
      T.Ec2QueryName("DomainCertificateArn"),
    ),
    EndpointDomain: S.optional(S.String).pipe(
      T.XmlName("endpointDomain"),
      T.Ec2QueryName("EndpointDomain"),
    ),
    DeviceValidationDomain: S.optional(S.String).pipe(
      T.XmlName("deviceValidationDomain"),
      T.Ec2QueryName("DeviceValidationDomain"),
    ),
    SecurityGroupIds: S.optional(SecurityGroupIdList).pipe(
      T.XmlName("securityGroupIdSet"),
      T.Ec2QueryName("SecurityGroupIdSet"),
    ),
    LoadBalancerOptions: S.optional(VerifiedAccessEndpointLoadBalancerOptions)
      .pipe(
        T.XmlName("loadBalancerOptions"),
        T.Ec2QueryName("LoadBalancerOptions"),
      )
      .annotate({ identifier: "VerifiedAccessEndpointLoadBalancerOptions" }),
    NetworkInterfaceOptions: S.optional(VerifiedAccessEndpointEniOptions)
      .pipe(
        T.XmlName("networkInterfaceOptions"),
        T.Ec2QueryName("NetworkInterfaceOptions"),
      )
      .annotate({ identifier: "VerifiedAccessEndpointEniOptions" }),
    Status: S.optional(VerifiedAccessEndpointStatus)
      .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
      .annotate({ identifier: "VerifiedAccessEndpointStatus" }),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    CreationTime: S.optional(S.String).pipe(
      T.XmlName("creationTime"),
      T.Ec2QueryName("CreationTime"),
    ),
    LastUpdatedTime: S.optional(S.String).pipe(
      T.XmlName("lastUpdatedTime"),
      T.Ec2QueryName("LastUpdatedTime"),
    ),
    DeletionTime: S.optional(S.String).pipe(
      T.XmlName("deletionTime"),
      T.Ec2QueryName("DeletionTime"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    SseSpecification: S.optional(VerifiedAccessSseSpecificationResponse)
      .pipe(T.XmlName("sseSpecification"), T.Ec2QueryName("SseSpecification"))
      .annotate({ identifier: "VerifiedAccessSseSpecificationResponse" }),
    RdsOptions: S.optional(VerifiedAccessEndpointRdsOptions)
      .pipe(T.XmlName("rdsOptions"), T.Ec2QueryName("RdsOptions"))
      .annotate({ identifier: "VerifiedAccessEndpointRdsOptions" }),
    CidrOptions: S.optional(VerifiedAccessEndpointCidrOptions)
      .pipe(T.XmlName("cidrOptions"), T.Ec2QueryName("CidrOptions"))
      .annotate({ identifier: "VerifiedAccessEndpointCidrOptions" }),
  }),
).annotate({
  identifier: "VerifiedAccessEndpoint",
}) as any as S.Schema<VerifiedAccessEndpoint>;
export interface CreateVerifiedAccessEndpointResult {
  VerifiedAccessEndpoint?: VerifiedAccessEndpoint;
}
export const CreateVerifiedAccessEndpointResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessEndpoint: S.optional(VerifiedAccessEndpoint)
      .pipe(
        T.XmlName("verifiedAccessEndpoint"),
        T.Ec2QueryName("VerifiedAccessEndpoint"),
      )
      .annotate({ identifier: "VerifiedAccessEndpoint" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateVerifiedAccessEndpointResult",
}) as any as S.Schema<CreateVerifiedAccessEndpointResult>;
export interface CreateVerifiedAccessGroupRequest {
  VerifiedAccessInstanceId?: string;
  Description?: string;
  PolicyDocument?: string;
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
  DryRun?: boolean;
  SseSpecification?: VerifiedAccessSseSpecificationRequest;
}
export const CreateVerifiedAccessGroupRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessInstanceId: S.optional(S.String),
    Description: S.optional(S.String),
    PolicyDocument: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
    SseSpecification: S.optional(VerifiedAccessSseSpecificationRequest),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateVerifiedAccessGroupRequest",
}) as any as S.Schema<CreateVerifiedAccessGroupRequest>;
export interface VerifiedAccessGroup {
  VerifiedAccessGroupId?: string;
  VerifiedAccessInstanceId?: string;
  Description?: string;
  Owner?: string;
  VerifiedAccessGroupArn?: string;
  CreationTime?: string;
  LastUpdatedTime?: string;
  DeletionTime?: string;
  Tags?: Tag[];
  SseSpecification?: VerifiedAccessSseSpecificationResponse;
}
export const VerifiedAccessGroup = S.suspend(() =>
  S.Struct({
    VerifiedAccessGroupId: S.optional(S.String).pipe(
      T.XmlName("verifiedAccessGroupId"),
      T.Ec2QueryName("VerifiedAccessGroupId"),
    ),
    VerifiedAccessInstanceId: S.optional(S.String).pipe(
      T.XmlName("verifiedAccessInstanceId"),
      T.Ec2QueryName("VerifiedAccessInstanceId"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    Owner: S.optional(S.String).pipe(
      T.XmlName("owner"),
      T.Ec2QueryName("Owner"),
    ),
    VerifiedAccessGroupArn: S.optional(S.String).pipe(
      T.XmlName("verifiedAccessGroupArn"),
      T.Ec2QueryName("VerifiedAccessGroupArn"),
    ),
    CreationTime: S.optional(S.String).pipe(
      T.XmlName("creationTime"),
      T.Ec2QueryName("CreationTime"),
    ),
    LastUpdatedTime: S.optional(S.String).pipe(
      T.XmlName("lastUpdatedTime"),
      T.Ec2QueryName("LastUpdatedTime"),
    ),
    DeletionTime: S.optional(S.String).pipe(
      T.XmlName("deletionTime"),
      T.Ec2QueryName("DeletionTime"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    SseSpecification: S.optional(VerifiedAccessSseSpecificationResponse)
      .pipe(T.XmlName("sseSpecification"), T.Ec2QueryName("SseSpecification"))
      .annotate({ identifier: "VerifiedAccessSseSpecificationResponse" }),
  }),
).annotate({
  identifier: "VerifiedAccessGroup",
}) as any as S.Schema<VerifiedAccessGroup>;
export interface CreateVerifiedAccessGroupResult {
  VerifiedAccessGroup?: VerifiedAccessGroup;
}
export const CreateVerifiedAccessGroupResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessGroup: S.optional(VerifiedAccessGroup)
      .pipe(
        T.XmlName("verifiedAccessGroup"),
        T.Ec2QueryName("VerifiedAccessGroup"),
      )
      .annotate({ identifier: "VerifiedAccessGroup" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateVerifiedAccessGroupResult",
}) as any as S.Schema<CreateVerifiedAccessGroupResult>;
export interface CreateVerifiedAccessInstanceRequest {
  Description?: string;
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
  DryRun?: boolean;
  FIPSEnabled?: boolean;
  CidrEndpointsCustomSubDomain?: string;
}
export const CreateVerifiedAccessInstanceRequest = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
    FIPSEnabled: S.optional(S.Boolean),
    CidrEndpointsCustomSubDomain: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateVerifiedAccessInstanceRequest",
}) as any as S.Schema<CreateVerifiedAccessInstanceRequest>;
export interface CreateVerifiedAccessInstanceResult {
  VerifiedAccessInstance?: VerifiedAccessInstance;
}
export const CreateVerifiedAccessInstanceResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessInstance: S.optional(VerifiedAccessInstance)
      .pipe(
        T.XmlName("verifiedAccessInstance"),
        T.Ec2QueryName("VerifiedAccessInstance"),
      )
      .annotate({ identifier: "VerifiedAccessInstance" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateVerifiedAccessInstanceResult",
}) as any as S.Schema<CreateVerifiedAccessInstanceResult>;
export interface CreateVerifiedAccessTrustProviderOidcOptions {
  Issuer?: string;
  AuthorizationEndpoint?: string;
  TokenEndpoint?: string;
  UserInfoEndpoint?: string;
  ClientId?: string;
  ClientSecret?: string | redacted.Redacted<string>;
  Scope?: string;
}
export const CreateVerifiedAccessTrustProviderOidcOptions = S.suspend(() =>
  S.Struct({
    Issuer: S.optional(S.String),
    AuthorizationEndpoint: S.optional(S.String),
    TokenEndpoint: S.optional(S.String),
    UserInfoEndpoint: S.optional(S.String),
    ClientId: S.optional(S.String),
    ClientSecret: S.optional(SensitiveString),
    Scope: S.optional(S.String),
  }),
).annotate({
  identifier: "CreateVerifiedAccessTrustProviderOidcOptions",
}) as any as S.Schema<CreateVerifiedAccessTrustProviderOidcOptions>;
export interface CreateVerifiedAccessTrustProviderDeviceOptions {
  TenantId?: string;
  PublicSigningKeyUrl?: string;
}
export const CreateVerifiedAccessTrustProviderDeviceOptions = S.suspend(() =>
  S.Struct({
    TenantId: S.optional(S.String),
    PublicSigningKeyUrl: S.optional(S.String),
  }),
).annotate({
  identifier: "CreateVerifiedAccessTrustProviderDeviceOptions",
}) as any as S.Schema<CreateVerifiedAccessTrustProviderDeviceOptions>;
export interface CreateVerifiedAccessNativeApplicationOidcOptions {
  PublicSigningKeyEndpoint?: string;
  Issuer?: string;
  AuthorizationEndpoint?: string;
  TokenEndpoint?: string;
  UserInfoEndpoint?: string;
  ClientId?: string;
  ClientSecret?: string | redacted.Redacted<string>;
  Scope?: string;
}
export const CreateVerifiedAccessNativeApplicationOidcOptions = S.suspend(() =>
  S.Struct({
    PublicSigningKeyEndpoint: S.optional(S.String),
    Issuer: S.optional(S.String),
    AuthorizationEndpoint: S.optional(S.String),
    TokenEndpoint: S.optional(S.String),
    UserInfoEndpoint: S.optional(S.String),
    ClientId: S.optional(S.String),
    ClientSecret: S.optional(SensitiveString),
    Scope: S.optional(S.String),
  }),
).annotate({
  identifier: "CreateVerifiedAccessNativeApplicationOidcOptions",
}) as any as S.Schema<CreateVerifiedAccessNativeApplicationOidcOptions>;
export interface CreateVerifiedAccessTrustProviderRequest {
  TrustProviderType?: TrustProviderType;
  UserTrustProviderType?: UserTrustProviderType;
  DeviceTrustProviderType?: DeviceTrustProviderType;
  OidcOptions?: CreateVerifiedAccessTrustProviderOidcOptions;
  DeviceOptions?: CreateVerifiedAccessTrustProviderDeviceOptions;
  PolicyReferenceName?: string;
  Description?: string;
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
  DryRun?: boolean;
  SseSpecification?: VerifiedAccessSseSpecificationRequest;
  NativeApplicationOidcOptions?: CreateVerifiedAccessNativeApplicationOidcOptions;
}
export const CreateVerifiedAccessTrustProviderRequest = S.suspend(() =>
  S.Struct({
    TrustProviderType: S.optional(TrustProviderType),
    UserTrustProviderType: S.optional(UserTrustProviderType),
    DeviceTrustProviderType: S.optional(DeviceTrustProviderType),
    OidcOptions: S.optional(CreateVerifiedAccessTrustProviderOidcOptions),
    DeviceOptions: S.optional(CreateVerifiedAccessTrustProviderDeviceOptions),
    PolicyReferenceName: S.optional(S.String),
    Description: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
    SseSpecification: S.optional(VerifiedAccessSseSpecificationRequest),
    NativeApplicationOidcOptions: S.optional(
      CreateVerifiedAccessNativeApplicationOidcOptions,
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateVerifiedAccessTrustProviderRequest",
}) as any as S.Schema<CreateVerifiedAccessTrustProviderRequest>;
export interface CreateVerifiedAccessTrustProviderResult {
  VerifiedAccessTrustProvider?: VerifiedAccessTrustProvider;
}
export const CreateVerifiedAccessTrustProviderResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessTrustProvider: S.optional(VerifiedAccessTrustProvider)
      .pipe(
        T.XmlName("verifiedAccessTrustProvider"),
        T.Ec2QueryName("VerifiedAccessTrustProvider"),
      )
      .annotate({ identifier: "VerifiedAccessTrustProvider" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateVerifiedAccessTrustProviderResult",
}) as any as S.Schema<CreateVerifiedAccessTrustProviderResult>;
export interface CreateVolumeRequest {
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  Encrypted?: boolean;
  Iops?: number;
  KmsKeyId?: string;
  OutpostArn?: string;
  Size?: number;
  SnapshotId?: string;
  VolumeType?: VolumeType;
  TagSpecifications?: TagSpecification[];
  MultiAttachEnabled?: boolean;
  Throughput?: number;
  ClientToken?: string;
  VolumeInitializationRate?: number;
  Operator?: OperatorRequest;
  DryRun?: boolean;
}
export const CreateVolumeRequest = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String),
    AvailabilityZoneId: S.optional(S.String),
    Encrypted: S.optional(S.Boolean).pipe(
      T.XmlName("encrypted"),
      T.Ec2QueryName("Encrypted"),
    ),
    Iops: S.optional(S.Number),
    KmsKeyId: S.optional(S.String),
    OutpostArn: S.optional(S.String),
    Size: S.optional(S.Number),
    SnapshotId: S.optional(S.String),
    VolumeType: S.optional(VolumeType),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    MultiAttachEnabled: S.optional(S.Boolean),
    Throughput: S.optional(S.Number),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    VolumeInitializationRate: S.optional(S.Number),
    Operator: S.optional(OperatorRequest),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateVolumeRequest",
}) as any as S.Schema<CreateVolumeRequest>;
export type VpcEncryptionControlExclusionStateInput =
  | "enable"
  | "disable"
  | (string & {});
export const VpcEncryptionControlExclusionStateInput = S.String;
export interface VpcEncryptionControlConfiguration {
  Mode?: VpcEncryptionControlMode;
  InternetGatewayExclusion?: VpcEncryptionControlExclusionStateInput;
  EgressOnlyInternetGatewayExclusion?: VpcEncryptionControlExclusionStateInput;
  NatGatewayExclusion?: VpcEncryptionControlExclusionStateInput;
  VirtualPrivateGatewayExclusion?: VpcEncryptionControlExclusionStateInput;
  VpcPeeringExclusion?: VpcEncryptionControlExclusionStateInput;
  LambdaExclusion?: VpcEncryptionControlExclusionStateInput;
  VpcLatticeExclusion?: VpcEncryptionControlExclusionStateInput;
  ElasticFileSystemExclusion?: VpcEncryptionControlExclusionStateInput;
}
export const VpcEncryptionControlConfiguration = S.suspend(() =>
  S.Struct({
    Mode: S.optional(VpcEncryptionControlMode),
    InternetGatewayExclusion: S.optional(
      VpcEncryptionControlExclusionStateInput,
    ),
    EgressOnlyInternetGatewayExclusion: S.optional(
      VpcEncryptionControlExclusionStateInput,
    ),
    NatGatewayExclusion: S.optional(VpcEncryptionControlExclusionStateInput),
    VirtualPrivateGatewayExclusion: S.optional(
      VpcEncryptionControlExclusionStateInput,
    ),
    VpcPeeringExclusion: S.optional(VpcEncryptionControlExclusionStateInput),
    LambdaExclusion: S.optional(VpcEncryptionControlExclusionStateInput),
    VpcLatticeExclusion: S.optional(VpcEncryptionControlExclusionStateInput),
    ElasticFileSystemExclusion: S.optional(
      VpcEncryptionControlExclusionStateInput,
    ),
  }),
).annotate({
  identifier: "VpcEncryptionControlConfiguration",
}) as any as S.Schema<VpcEncryptionControlConfiguration>;
export interface CreateVpcRequest {
  CidrBlock?: string;
  Ipv6Pool?: string;
  Ipv6CidrBlock?: string;
  Ipv4IpamPoolId?: string;
  Ipv4NetmaskLength?: number;
  Ipv6IpamPoolId?: string;
  Ipv6NetmaskLength?: number;
  Ipv6CidrBlockNetworkBorderGroup?: string;
  VpcEncryptionControl?: VpcEncryptionControlConfiguration;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
  InstanceTenancy?: Tenancy;
  AmazonProvidedIpv6CidrBlock?: boolean;
}
export const CreateVpcRequest = S.suspend(() =>
  S.Struct({
    CidrBlock: S.optional(S.String),
    Ipv6Pool: S.optional(S.String),
    Ipv6CidrBlock: S.optional(S.String),
    Ipv4IpamPoolId: S.optional(S.String),
    Ipv4NetmaskLength: S.optional(S.Number),
    Ipv6IpamPoolId: S.optional(S.String),
    Ipv6NetmaskLength: S.optional(S.Number),
    Ipv6CidrBlockNetworkBorderGroup: S.optional(S.String),
    VpcEncryptionControl: S.optional(VpcEncryptionControlConfiguration),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    InstanceTenancy: S.optional(Tenancy).pipe(
      T.XmlName("instanceTenancy"),
      T.Ec2QueryName("InstanceTenancy"),
    ),
    AmazonProvidedIpv6CidrBlock: S.optional(S.Boolean).pipe(
      T.XmlName("amazonProvidedIpv6CidrBlock"),
      T.Ec2QueryName("AmazonProvidedIpv6CidrBlock"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateVpcRequest",
}) as any as S.Schema<CreateVpcRequest>;
export interface CreateVpcResult {
  Vpc?: Vpc;
}
export const CreateVpcResult = S.suspend(() =>
  S.Struct({
    Vpc: S.optional(Vpc)
      .pipe(T.XmlName("vpc"), T.Ec2QueryName("Vpc"))
      .annotate({ identifier: "Vpc" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateVpcResult",
}) as any as S.Schema<CreateVpcResult>;
export type InternetGatewayExclusionMode =
  | "allow-bidirectional"
  | "allow-egress"
  | (string & {});
export const InternetGatewayExclusionMode = S.String;
export interface CreateVpcBlockPublicAccessExclusionRequest {
  DryRun?: boolean;
  SubnetId?: string;
  VpcId?: string;
  InternetGatewayExclusionMode?: InternetGatewayExclusionMode;
  TagSpecifications?: TagSpecification[];
}
export const CreateVpcBlockPublicAccessExclusionRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    SubnetId: S.optional(S.String),
    VpcId: S.optional(S.String),
    InternetGatewayExclusionMode: S.optional(InternetGatewayExclusionMode),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateVpcBlockPublicAccessExclusionRequest",
}) as any as S.Schema<CreateVpcBlockPublicAccessExclusionRequest>;
export type VpcBlockPublicAccessExclusionState =
  | "create-in-progress"
  | "create-complete"
  | "create-failed"
  | "update-in-progress"
  | "update-complete"
  | "update-failed"
  | "delete-in-progress"
  | "delete-complete"
  | "disable-in-progress"
  | "disable-complete"
  | (string & {});
export const VpcBlockPublicAccessExclusionState = S.String;
export interface VpcBlockPublicAccessExclusion {
  ExclusionId?: string;
  InternetGatewayExclusionMode?: InternetGatewayExclusionMode;
  ResourceArn?: string;
  State?: VpcBlockPublicAccessExclusionState;
  Reason?: string;
  CreationTimestamp?: Date;
  LastUpdateTimestamp?: Date;
  DeletionTimestamp?: Date;
  Tags?: Tag[];
}
export const VpcBlockPublicAccessExclusion = S.suspend(() =>
  S.Struct({
    ExclusionId: S.optional(S.String).pipe(
      T.XmlName("exclusionId"),
      T.Ec2QueryName("ExclusionId"),
    ),
    InternetGatewayExclusionMode: S.optional(InternetGatewayExclusionMode).pipe(
      T.XmlName("internetGatewayExclusionMode"),
      T.Ec2QueryName("InternetGatewayExclusionMode"),
    ),
    ResourceArn: S.optional(S.String).pipe(
      T.XmlName("resourceArn"),
      T.Ec2QueryName("ResourceArn"),
    ),
    State: S.optional(VpcBlockPublicAccessExclusionState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Reason: S.optional(S.String).pipe(
      T.XmlName("reason"),
      T.Ec2QueryName("Reason"),
    ),
    CreationTimestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("creationTimestamp"), T.Ec2QueryName("CreationTimestamp")),
    LastUpdateTimestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("lastUpdateTimestamp"),
      T.Ec2QueryName("LastUpdateTimestamp"),
    ),
    DeletionTimestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("deletionTimestamp"), T.Ec2QueryName("DeletionTimestamp")),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "VpcBlockPublicAccessExclusion",
}) as any as S.Schema<VpcBlockPublicAccessExclusion>;
export interface CreateVpcBlockPublicAccessExclusionResult {
  VpcBlockPublicAccessExclusion?: VpcBlockPublicAccessExclusion;
}
export const CreateVpcBlockPublicAccessExclusionResult = S.suspend(() =>
  S.Struct({
    VpcBlockPublicAccessExclusion: S.optional(VpcBlockPublicAccessExclusion)
      .pipe(
        T.XmlName("vpcBlockPublicAccessExclusion"),
        T.Ec2QueryName("VpcBlockPublicAccessExclusion"),
      )
      .annotate({ identifier: "VpcBlockPublicAccessExclusion" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateVpcBlockPublicAccessExclusionResult",
}) as any as S.Schema<CreateVpcBlockPublicAccessExclusionResult>;
export interface CreateVpcEncryptionControlRequest {
  DryRun?: boolean;
  VpcId?: string;
  TagSpecifications?: TagSpecification[];
}
export const CreateVpcEncryptionControlRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    VpcId: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateVpcEncryptionControlRequest",
}) as any as S.Schema<CreateVpcEncryptionControlRequest>;
export interface CreateVpcEncryptionControlResult {
  VpcEncryptionControl?: VpcEncryptionControl;
}
export const CreateVpcEncryptionControlResult = S.suspend(() =>
  S.Struct({
    VpcEncryptionControl: S.optional(VpcEncryptionControl)
      .pipe(
        T.XmlName("vpcEncryptionControl"),
        T.Ec2QueryName("VpcEncryptionControl"),
      )
      .annotate({ identifier: "VpcEncryptionControl" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateVpcEncryptionControlResult",
}) as any as S.Schema<CreateVpcEncryptionControlResult>;
export type VpcEndpointType =
  | "Interface"
  | "Gateway"
  | "GatewayLoadBalancer"
  | "Resource"
  | "ServiceNetwork"
  | (string & {});
export const VpcEndpointType = S.String;
export type VpcEndpointRouteTableIdList = string[];
export const VpcEndpointRouteTableIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export type VpcEndpointSubnetIdList = string[];
export const VpcEndpointSubnetIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export type VpcEndpointSecurityGroupIdList = string[];
export const VpcEndpointSecurityGroupIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export type DnsRecordIpType =
  | "ipv4"
  | "dualstack"
  | "ipv6"
  | "service-defined"
  | (string & {});
export const DnsRecordIpType = S.String;
export type PrivateDnsSpecifiedDomainSet = string[];
export const PrivateDnsSpecifiedDomainSet = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DnsOptionsSpecification {
  DnsRecordIpType?: DnsRecordIpType;
  PrivateDnsOnlyForInboundResolverEndpoint?: boolean;
  PrivateDnsPreference?: string;
  PrivateDnsSpecifiedDomains?: string[];
}
export const DnsOptionsSpecification = S.suspend(() =>
  S.Struct({
    DnsRecordIpType: S.optional(DnsRecordIpType),
    PrivateDnsOnlyForInboundResolverEndpoint: S.optional(S.Boolean),
    PrivateDnsPreference: S.optional(S.String),
    PrivateDnsSpecifiedDomains: S.optional(PrivateDnsSpecifiedDomainSet).pipe(
      T.XmlName("PrivateDnsSpecifiedDomain"),
    ),
  }),
).annotate({
  identifier: "DnsOptionsSpecification",
}) as any as S.Schema<DnsOptionsSpecification>;
export interface SubnetConfiguration {
  SubnetId?: string;
  Ipv4?: string;
  Ipv6?: string;
}
export const SubnetConfiguration = S.suspend(() =>
  S.Struct({
    SubnetId: S.optional(S.String),
    Ipv4: S.optional(S.String),
    Ipv6: S.optional(S.String),
  }),
).annotate({
  identifier: "SubnetConfiguration",
}) as any as S.Schema<SubnetConfiguration>;
export type SubnetConfigurationsList = SubnetConfiguration[];
export const SubnetConfigurationsList = S.Array(
  SubnetConfiguration.pipe(T.XmlName("item")).annotate({
    identifier: "SubnetConfiguration",
  }),
);
export interface CreateVpcEndpointRequest {
  DryRun?: boolean;
  VpcEndpointType?: VpcEndpointType;
  VpcId?: string;
  ServiceName?: string;
  PolicyDocument?: string;
  RouteTableIds?: string[];
  SubnetIds?: string[];
  SecurityGroupIds?: string[];
  IpAddressType?: IpAddressType;
  DnsOptions?: DnsOptionsSpecification;
  ClientToken?: string;
  PrivateDnsEnabled?: boolean;
  TagSpecifications?: TagSpecification[];
  SubnetConfigurations?: SubnetConfiguration[];
  ServiceNetworkArn?: string;
  ResourceConfigurationArn?: string;
  ServiceRegion?: string;
}
export const CreateVpcEndpointRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    VpcEndpointType: S.optional(VpcEndpointType),
    VpcId: S.optional(S.String),
    ServiceName: S.optional(S.String),
    PolicyDocument: S.optional(S.String),
    RouteTableIds: S.optional(VpcEndpointRouteTableIdList).pipe(
      T.XmlName("RouteTableId"),
    ),
    SubnetIds: S.optional(VpcEndpointSubnetIdList).pipe(T.XmlName("SubnetId")),
    SecurityGroupIds: S.optional(VpcEndpointSecurityGroupIdList).pipe(
      T.XmlName("SecurityGroupId"),
    ),
    IpAddressType: S.optional(IpAddressType),
    DnsOptions: S.optional(DnsOptionsSpecification),
    ClientToken: S.optional(S.String),
    PrivateDnsEnabled: S.optional(S.Boolean),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    SubnetConfigurations: S.optional(SubnetConfigurationsList).pipe(
      T.XmlName("SubnetConfiguration"),
    ),
    ServiceNetworkArn: S.optional(S.String),
    ResourceConfigurationArn: S.optional(S.String),
    ServiceRegion: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateVpcEndpointRequest",
}) as any as S.Schema<CreateVpcEndpointRequest>;
export type State =
  | "PendingAcceptance"
  | "Pending"
  | "Available"
  | "Deleting"
  | "Deleted"
  | "Rejected"
  | "Failed"
  | "Expired"
  | "Partial"
  | (string & {});
export const State = S.String;
export interface SecurityGroupIdentifier {
  GroupId?: string;
  GroupName?: string;
}
export const SecurityGroupIdentifier = S.suspend(() =>
  S.Struct({
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
    GroupName: S.optional(S.String).pipe(
      T.XmlName("groupName"),
      T.Ec2QueryName("GroupName"),
    ),
  }),
).annotate({
  identifier: "SecurityGroupIdentifier",
}) as any as S.Schema<SecurityGroupIdentifier>;
export type GroupIdentifierSet = SecurityGroupIdentifier[];
export const GroupIdentifierSet = S.Array(
  SecurityGroupIdentifier.pipe(T.XmlName("item")).annotate({
    identifier: "SecurityGroupIdentifier",
  }),
);
export interface DnsOptions {
  DnsRecordIpType?: DnsRecordIpType;
  PrivateDnsOnlyForInboundResolverEndpoint?: boolean;
  PrivateDnsPreference?: string;
  PrivateDnsSpecifiedDomains?: string[];
}
export const DnsOptions = S.suspend(() =>
  S.Struct({
    DnsRecordIpType: S.optional(DnsRecordIpType).pipe(
      T.XmlName("dnsRecordIpType"),
      T.Ec2QueryName("DnsRecordIpType"),
    ),
    PrivateDnsOnlyForInboundResolverEndpoint: S.optional(S.Boolean).pipe(
      T.XmlName("privateDnsOnlyForInboundResolverEndpoint"),
      T.Ec2QueryName("PrivateDnsOnlyForInboundResolverEndpoint"),
    ),
    PrivateDnsPreference: S.optional(S.String).pipe(
      T.XmlName("privateDnsPreference"),
      T.Ec2QueryName("PrivateDnsPreference"),
    ),
    PrivateDnsSpecifiedDomains: S.optional(PrivateDnsSpecifiedDomainSet).pipe(
      T.XmlName("privateDnsSpecifiedDomainSet"),
      T.Ec2QueryName("PrivateDnsSpecifiedDomainSet"),
    ),
  }),
).annotate({ identifier: "DnsOptions" }) as any as S.Schema<DnsOptions>;
export interface DnsEntry {
  DnsName?: string;
  HostedZoneId?: string;
}
export const DnsEntry = S.suspend(() =>
  S.Struct({
    DnsName: S.optional(S.String).pipe(
      T.XmlName("dnsName"),
      T.Ec2QueryName("DnsName"),
    ),
    HostedZoneId: S.optional(S.String).pipe(
      T.XmlName("hostedZoneId"),
      T.Ec2QueryName("HostedZoneId"),
    ),
  }),
).annotate({ identifier: "DnsEntry" }) as any as S.Schema<DnsEntry>;
export type DnsEntrySet = DnsEntry[];
export const DnsEntrySet = S.Array(
  DnsEntry.pipe(T.XmlName("item")).annotate({ identifier: "DnsEntry" }),
);
export interface LastError {
  Message?: string;
  Code?: string;
}
export const LastError = S.suspend(() =>
  S.Struct({
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
    Code: S.optional(S.String).pipe(T.XmlName("code"), T.Ec2QueryName("Code")),
  }),
).annotate({ identifier: "LastError" }) as any as S.Schema<LastError>;
export interface SubnetIpPrefixes {
  SubnetId?: string;
  IpPrefixes?: string[];
}
export const SubnetIpPrefixes = S.suspend(() =>
  S.Struct({
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    IpPrefixes: S.optional(ValueStringList).pipe(
      T.XmlName("ipPrefixSet"),
      T.Ec2QueryName("IpPrefixSet"),
    ),
  }),
).annotate({
  identifier: "SubnetIpPrefixes",
}) as any as S.Schema<SubnetIpPrefixes>;
export type SubnetIpPrefixesList = SubnetIpPrefixes[];
export const SubnetIpPrefixesList = S.Array(
  SubnetIpPrefixes.pipe(T.XmlName("item")).annotate({
    identifier: "SubnetIpPrefixes",
  }),
);
export interface VpcEndpoint {
  VpcEndpointId?: string;
  VpcEndpointType?: VpcEndpointType;
  VpcId?: string;
  ServiceName?: string;
  State?: State;
  PolicyDocument?: string;
  RouteTableIds?: string[];
  SubnetIds?: string[];
  Groups?: SecurityGroupIdentifier[];
  IpAddressType?: IpAddressType;
  DnsOptions?: DnsOptions;
  PrivateDnsEnabled?: boolean;
  RequesterManaged?: boolean;
  NetworkInterfaceIds?: string[];
  DnsEntries?: DnsEntry[];
  CreationTimestamp?: Date;
  Tags?: Tag[];
  OwnerId?: string;
  LastError?: LastError;
  Ipv4Prefixes?: SubnetIpPrefixes[];
  Ipv6Prefixes?: SubnetIpPrefixes[];
  FailureReason?: string;
  ServiceNetworkArn?: string;
  ResourceConfigurationArn?: string;
  ServiceRegion?: string;
}
export const VpcEndpoint = S.suspend(() =>
  S.Struct({
    VpcEndpointId: S.optional(S.String).pipe(
      T.XmlName("vpcEndpointId"),
      T.Ec2QueryName("VpcEndpointId"),
    ),
    VpcEndpointType: S.optional(VpcEndpointType).pipe(
      T.XmlName("vpcEndpointType"),
      T.Ec2QueryName("VpcEndpointType"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    ServiceName: S.optional(S.String).pipe(
      T.XmlName("serviceName"),
      T.Ec2QueryName("ServiceName"),
    ),
    State: S.optional(State).pipe(T.XmlName("state"), T.Ec2QueryName("State")),
    PolicyDocument: S.optional(S.String).pipe(
      T.XmlName("policyDocument"),
      T.Ec2QueryName("PolicyDocument"),
    ),
    RouteTableIds: S.optional(ValueStringList).pipe(
      T.XmlName("routeTableIdSet"),
      T.Ec2QueryName("RouteTableIdSet"),
    ),
    SubnetIds: S.optional(ValueStringList).pipe(
      T.XmlName("subnetIdSet"),
      T.Ec2QueryName("SubnetIdSet"),
    ),
    Groups: S.optional(GroupIdentifierSet).pipe(
      T.XmlName("groupSet"),
      T.Ec2QueryName("GroupSet"),
    ),
    IpAddressType: S.optional(IpAddressType).pipe(
      T.XmlName("ipAddressType"),
      T.Ec2QueryName("IpAddressType"),
    ),
    DnsOptions: S.optional(DnsOptions)
      .pipe(T.XmlName("dnsOptions"), T.Ec2QueryName("DnsOptions"))
      .annotate({ identifier: "DnsOptions" }),
    PrivateDnsEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("privateDnsEnabled"),
      T.Ec2QueryName("PrivateDnsEnabled"),
    ),
    RequesterManaged: S.optional(S.Boolean).pipe(
      T.XmlName("requesterManaged"),
      T.Ec2QueryName("RequesterManaged"),
    ),
    NetworkInterfaceIds: S.optional(ValueStringList).pipe(
      T.XmlName("networkInterfaceIdSet"),
      T.Ec2QueryName("NetworkInterfaceIdSet"),
    ),
    DnsEntries: S.optional(DnsEntrySet).pipe(
      T.XmlName("dnsEntrySet"),
      T.Ec2QueryName("DnsEntrySet"),
    ),
    CreationTimestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("creationTimestamp"), T.Ec2QueryName("CreationTimestamp")),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    LastError: S.optional(LastError)
      .pipe(T.XmlName("lastError"), T.Ec2QueryName("LastError"))
      .annotate({ identifier: "LastError" }),
    Ipv4Prefixes: S.optional(SubnetIpPrefixesList).pipe(
      T.XmlName("ipv4PrefixSet"),
      T.Ec2QueryName("Ipv4PrefixSet"),
    ),
    Ipv6Prefixes: S.optional(SubnetIpPrefixesList).pipe(
      T.XmlName("ipv6PrefixSet"),
      T.Ec2QueryName("Ipv6PrefixSet"),
    ),
    FailureReason: S.optional(S.String).pipe(
      T.XmlName("failureReason"),
      T.Ec2QueryName("FailureReason"),
    ),
    ServiceNetworkArn: S.optional(S.String).pipe(
      T.XmlName("serviceNetworkArn"),
      T.Ec2QueryName("ServiceNetworkArn"),
    ),
    ResourceConfigurationArn: S.optional(S.String).pipe(
      T.XmlName("resourceConfigurationArn"),
      T.Ec2QueryName("ResourceConfigurationArn"),
    ),
    ServiceRegion: S.optional(S.String).pipe(
      T.XmlName("serviceRegion"),
      T.Ec2QueryName("ServiceRegion"),
    ),
  }),
).annotate({ identifier: "VpcEndpoint" }) as any as S.Schema<VpcEndpoint>;
export interface CreateVpcEndpointResult {
  VpcEndpoint?: VpcEndpoint;
  ClientToken?: string;
}
export const CreateVpcEndpointResult = S.suspend(() =>
  S.Struct({
    VpcEndpoint: S.optional(VpcEndpoint)
      .pipe(T.XmlName("vpcEndpoint"), T.Ec2QueryName("VpcEndpoint"))
      .annotate({ identifier: "VpcEndpoint" }),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateVpcEndpointResult",
}) as any as S.Schema<CreateVpcEndpointResult>;
export interface CreateVpcEndpointConnectionNotificationRequest {
  DryRun?: boolean;
  ServiceId?: string;
  VpcEndpointId?: string;
  ConnectionNotificationArn?: string;
  ConnectionEvents?: string[];
  ClientToken?: string;
}
export const CreateVpcEndpointConnectionNotificationRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ServiceId: S.optional(S.String),
    VpcEndpointId: S.optional(S.String),
    ConnectionNotificationArn: S.optional(S.String),
    ConnectionEvents: S.optional(ValueStringList),
    ClientToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateVpcEndpointConnectionNotificationRequest",
}) as any as S.Schema<CreateVpcEndpointConnectionNotificationRequest>;
export type ConnectionNotificationType = "Topic" | (string & {});
export const ConnectionNotificationType = S.String;
export type ConnectionNotificationState =
  | "Enabled"
  | "Disabled"
  | (string & {});
export const ConnectionNotificationState = S.String;
export interface ConnectionNotification {
  ConnectionNotificationId?: string;
  ServiceId?: string;
  VpcEndpointId?: string;
  ConnectionNotificationType?: ConnectionNotificationType;
  ConnectionNotificationArn?: string;
  ConnectionEvents?: string[];
  ConnectionNotificationState?: ConnectionNotificationState;
  ServiceRegion?: string;
}
export const ConnectionNotification = S.suspend(() =>
  S.Struct({
    ConnectionNotificationId: S.optional(S.String).pipe(
      T.XmlName("connectionNotificationId"),
      T.Ec2QueryName("ConnectionNotificationId"),
    ),
    ServiceId: S.optional(S.String).pipe(
      T.XmlName("serviceId"),
      T.Ec2QueryName("ServiceId"),
    ),
    VpcEndpointId: S.optional(S.String).pipe(
      T.XmlName("vpcEndpointId"),
      T.Ec2QueryName("VpcEndpointId"),
    ),
    ConnectionNotificationType: S.optional(ConnectionNotificationType).pipe(
      T.XmlName("connectionNotificationType"),
      T.Ec2QueryName("ConnectionNotificationType"),
    ),
    ConnectionNotificationArn: S.optional(S.String).pipe(
      T.XmlName("connectionNotificationArn"),
      T.Ec2QueryName("ConnectionNotificationArn"),
    ),
    ConnectionEvents: S.optional(ValueStringList).pipe(
      T.XmlName("connectionEvents"),
      T.Ec2QueryName("ConnectionEvents"),
    ),
    ConnectionNotificationState: S.optional(ConnectionNotificationState).pipe(
      T.XmlName("connectionNotificationState"),
      T.Ec2QueryName("ConnectionNotificationState"),
    ),
    ServiceRegion: S.optional(S.String).pipe(
      T.XmlName("serviceRegion"),
      T.Ec2QueryName("ServiceRegion"),
    ),
  }),
).annotate({
  identifier: "ConnectionNotification",
}) as any as S.Schema<ConnectionNotification>;
export interface CreateVpcEndpointConnectionNotificationResult {
  ConnectionNotification?: ConnectionNotification;
  ClientToken?: string;
}
export const CreateVpcEndpointConnectionNotificationResult = S.suspend(() =>
  S.Struct({
    ConnectionNotification: S.optional(ConnectionNotification)
      .pipe(
        T.XmlName("connectionNotification"),
        T.Ec2QueryName("ConnectionNotification"),
      )
      .annotate({ identifier: "ConnectionNotification" }),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateVpcEndpointConnectionNotificationResult",
}) as any as S.Schema<CreateVpcEndpointConnectionNotificationResult>;
export interface CreateVpcEndpointServiceConfigurationRequest {
  DryRun?: boolean;
  AcceptanceRequired?: boolean;
  PrivateDnsName?: string;
  NetworkLoadBalancerArns?: string[];
  GatewayLoadBalancerArns?: string[];
  SupportedIpAddressTypes?: string[];
  SupportedRegions?: string[];
  ClientToken?: string;
  TagSpecifications?: TagSpecification[];
}
export const CreateVpcEndpointServiceConfigurationRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    AcceptanceRequired: S.optional(S.Boolean),
    PrivateDnsName: S.optional(S.String),
    NetworkLoadBalancerArns: S.optional(ValueStringList).pipe(
      T.XmlName("NetworkLoadBalancerArn"),
    ),
    GatewayLoadBalancerArns: S.optional(ValueStringList).pipe(
      T.XmlName("GatewayLoadBalancerArn"),
    ),
    SupportedIpAddressTypes: S.optional(ValueStringList).pipe(
      T.XmlName("SupportedIpAddressType"),
    ),
    SupportedRegions: S.optional(ValueStringList).pipe(
      T.XmlName("SupportedRegion"),
    ),
    ClientToken: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateVpcEndpointServiceConfigurationRequest",
}) as any as S.Schema<CreateVpcEndpointServiceConfigurationRequest>;
export type ServiceType =
  | "Interface"
  | "Gateway"
  | "GatewayLoadBalancer"
  | (string & {});
export const ServiceType = S.String;
export interface ServiceTypeDetail {
  ServiceType?: ServiceType;
}
export const ServiceTypeDetail = S.suspend(() =>
  S.Struct({
    ServiceType: S.optional(ServiceType).pipe(
      T.XmlName("serviceType"),
      T.Ec2QueryName("ServiceType"),
    ),
  }),
).annotate({
  identifier: "ServiceTypeDetail",
}) as any as S.Schema<ServiceTypeDetail>;
export type ServiceTypeDetailSet = ServiceTypeDetail[];
export const ServiceTypeDetailSet = S.Array(
  ServiceTypeDetail.pipe(T.XmlName("item")).annotate({
    identifier: "ServiceTypeDetail",
  }),
);
export type ServiceState =
  | "Pending"
  | "Available"
  | "Deleting"
  | "Deleted"
  | "Failed"
  | (string & {});
export const ServiceState = S.String;
export type ServiceConnectivityType = "ipv4" | "ipv6" | (string & {});
export const ServiceConnectivityType = S.String;
export type SupportedIpAddressTypes = ServiceConnectivityType[];
export const SupportedIpAddressTypes = S.Array(
  ServiceConnectivityType.pipe(T.XmlName("item")),
);
export type DnsNameState =
  | "pendingVerification"
  | "verified"
  | "failed"
  | (string & {});
export const DnsNameState = S.String;
export interface PrivateDnsNameConfiguration {
  State?: DnsNameState;
  Type?: string;
  Value?: string;
  Name?: string;
}
export const PrivateDnsNameConfiguration = S.suspend(() =>
  S.Struct({
    State: S.optional(DnsNameState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Type: S.optional(S.String).pipe(T.XmlName("type"), T.Ec2QueryName("Type")),
    Value: S.optional(S.String).pipe(
      T.XmlName("value"),
      T.Ec2QueryName("Value"),
    ),
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
  }),
).annotate({
  identifier: "PrivateDnsNameConfiguration",
}) as any as S.Schema<PrivateDnsNameConfiguration>;
export type PayerResponsibility = "ServiceOwner" | (string & {});
export const PayerResponsibility = S.String;
export interface SupportedRegionDetail {
  Region?: string;
  ServiceState?: string;
}
export const SupportedRegionDetail = S.suspend(() =>
  S.Struct({
    Region: S.optional(S.String).pipe(
      T.XmlName("region"),
      T.Ec2QueryName("Region"),
    ),
    ServiceState: S.optional(S.String).pipe(
      T.XmlName("serviceState"),
      T.Ec2QueryName("ServiceState"),
    ),
  }),
).annotate({
  identifier: "SupportedRegionDetail",
}) as any as S.Schema<SupportedRegionDetail>;
export type SupportedRegionSet = SupportedRegionDetail[];
export const SupportedRegionSet = S.Array(
  SupportedRegionDetail.pipe(T.XmlName("item")).annotate({
    identifier: "SupportedRegionDetail",
  }),
);
export interface ServiceConfiguration {
  ServiceType?: ServiceTypeDetail[];
  ServiceId?: string;
  ServiceName?: string;
  ServiceState?: ServiceState;
  AvailabilityZoneIds?: string[];
  AvailabilityZones?: string[];
  AcceptanceRequired?: boolean;
  ManagesVpcEndpoints?: boolean;
  NetworkLoadBalancerArns?: string[];
  GatewayLoadBalancerArns?: string[];
  SupportedIpAddressTypes?: ServiceConnectivityType[];
  BaseEndpointDnsNames?: string[];
  PrivateDnsName?: string;
  PrivateDnsNameConfiguration?: PrivateDnsNameConfiguration;
  PayerResponsibility?: PayerResponsibility;
  Tags?: Tag[];
  SupportedRegions?: SupportedRegionDetail[];
  RemoteAccessEnabled?: boolean;
}
export const ServiceConfiguration = S.suspend(() =>
  S.Struct({
    ServiceType: S.optional(ServiceTypeDetailSet).pipe(
      T.XmlName("serviceType"),
      T.Ec2QueryName("ServiceType"),
    ),
    ServiceId: S.optional(S.String).pipe(
      T.XmlName("serviceId"),
      T.Ec2QueryName("ServiceId"),
    ),
    ServiceName: S.optional(S.String).pipe(
      T.XmlName("serviceName"),
      T.Ec2QueryName("ServiceName"),
    ),
    ServiceState: S.optional(ServiceState).pipe(
      T.XmlName("serviceState"),
      T.Ec2QueryName("ServiceState"),
    ),
    AvailabilityZoneIds: S.optional(ValueStringList).pipe(
      T.XmlName("availabilityZoneIdSet"),
      T.Ec2QueryName("AvailabilityZoneIdSet"),
    ),
    AvailabilityZones: S.optional(ValueStringList).pipe(
      T.XmlName("availabilityZoneSet"),
      T.Ec2QueryName("AvailabilityZoneSet"),
    ),
    AcceptanceRequired: S.optional(S.Boolean).pipe(
      T.XmlName("acceptanceRequired"),
      T.Ec2QueryName("AcceptanceRequired"),
    ),
    ManagesVpcEndpoints: S.optional(S.Boolean).pipe(
      T.XmlName("managesVpcEndpoints"),
      T.Ec2QueryName("ManagesVpcEndpoints"),
    ),
    NetworkLoadBalancerArns: S.optional(ValueStringList).pipe(
      T.XmlName("networkLoadBalancerArnSet"),
      T.Ec2QueryName("NetworkLoadBalancerArnSet"),
    ),
    GatewayLoadBalancerArns: S.optional(ValueStringList).pipe(
      T.XmlName("gatewayLoadBalancerArnSet"),
      T.Ec2QueryName("GatewayLoadBalancerArnSet"),
    ),
    SupportedIpAddressTypes: S.optional(SupportedIpAddressTypes).pipe(
      T.XmlName("supportedIpAddressTypeSet"),
      T.Ec2QueryName("SupportedIpAddressTypeSet"),
    ),
    BaseEndpointDnsNames: S.optional(ValueStringList).pipe(
      T.XmlName("baseEndpointDnsNameSet"),
      T.Ec2QueryName("BaseEndpointDnsNameSet"),
    ),
    PrivateDnsName: S.optional(S.String).pipe(
      T.XmlName("privateDnsName"),
      T.Ec2QueryName("PrivateDnsName"),
    ),
    PrivateDnsNameConfiguration: S.optional(PrivateDnsNameConfiguration)
      .pipe(
        T.XmlName("privateDnsNameConfiguration"),
        T.Ec2QueryName("PrivateDnsNameConfiguration"),
      )
      .annotate({ identifier: "PrivateDnsNameConfiguration" }),
    PayerResponsibility: S.optional(PayerResponsibility).pipe(
      T.XmlName("payerResponsibility"),
      T.Ec2QueryName("PayerResponsibility"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    SupportedRegions: S.optional(SupportedRegionSet).pipe(
      T.XmlName("supportedRegionSet"),
      T.Ec2QueryName("SupportedRegionSet"),
    ),
    RemoteAccessEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("remoteAccessEnabled"),
      T.Ec2QueryName("RemoteAccessEnabled"),
    ),
  }),
).annotate({
  identifier: "ServiceConfiguration",
}) as any as S.Schema<ServiceConfiguration>;
export interface CreateVpcEndpointServiceConfigurationResult {
  ServiceConfiguration?: ServiceConfiguration;
  ClientToken?: string;
}
export const CreateVpcEndpointServiceConfigurationResult = S.suspend(() =>
  S.Struct({
    ServiceConfiguration: S.optional(ServiceConfiguration)
      .pipe(
        T.XmlName("serviceConfiguration"),
        T.Ec2QueryName("ServiceConfiguration"),
      )
      .annotate({ identifier: "ServiceConfiguration" }),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "CreateVpcEndpointServiceConfigurationResult",
}) as any as S.Schema<CreateVpcEndpointServiceConfigurationResult>;
export interface CreateVpcPeeringConnectionRequest {
  PeerRegion?: string;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
  VpcId?: string;
  PeerVpcId?: string;
  PeerOwnerId?: string;
}
export const CreateVpcPeeringConnectionRequest = S.suspend(() =>
  S.Struct({
    PeerRegion: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    PeerVpcId: S.optional(S.String).pipe(
      T.XmlName("peerVpcId"),
      T.Ec2QueryName("PeerVpcId"),
    ),
    PeerOwnerId: S.optional(S.String).pipe(
      T.XmlName("peerOwnerId"),
      T.Ec2QueryName("PeerOwnerId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateVpcPeeringConnectionRequest",
}) as any as S.Schema<CreateVpcPeeringConnectionRequest>;
export interface CreateVpcPeeringConnectionResult {
  VpcPeeringConnection?: VpcPeeringConnection;
}
export const CreateVpcPeeringConnectionResult = S.suspend(() =>
  S.Struct({
    VpcPeeringConnection: S.optional(VpcPeeringConnection)
      .pipe(
        T.XmlName("vpcPeeringConnection"),
        T.Ec2QueryName("VpcPeeringConnection"),
      )
      .annotate({ identifier: "VpcPeeringConnection" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateVpcPeeringConnectionResult",
}) as any as S.Schema<CreateVpcPeeringConnectionResult>;
export type VpnConcentratorType = "ipsec.1" | (string & {});
export const VpnConcentratorType = S.String;
export interface CreateVpnConcentratorRequest {
  Type?: VpnConcentratorType;
  TransitGatewayId?: string;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export const CreateVpnConcentratorRequest = S.suspend(() =>
  S.Struct({
    Type: S.optional(VpnConcentratorType),
    TransitGatewayId: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateVpnConcentratorRequest",
}) as any as S.Schema<CreateVpnConcentratorRequest>;
export interface VpnConcentrator {
  VpnConcentratorId?: string;
  State?: string;
  TransitGatewayId?: string;
  TransitGatewayAttachmentId?: string;
  Type?: string;
  Tags?: Tag[];
}
export const VpnConcentrator = S.suspend(() =>
  S.Struct({
    VpnConcentratorId: S.optional(S.String).pipe(
      T.XmlName("vpnConcentratorId"),
      T.Ec2QueryName("VpnConcentratorId"),
    ),
    State: S.optional(S.String).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    TransitGatewayId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayId"),
      T.Ec2QueryName("TransitGatewayId"),
    ),
    TransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayAttachmentId"),
      T.Ec2QueryName("TransitGatewayAttachmentId"),
    ),
    Type: S.optional(S.String).pipe(T.XmlName("type"), T.Ec2QueryName("Type")),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "VpnConcentrator",
}) as any as S.Schema<VpnConcentrator>;
export interface CreateVpnConcentratorResult {
  VpnConcentrator?: VpnConcentrator;
}
export const CreateVpnConcentratorResult = S.suspend(() =>
  S.Struct({
    VpnConcentrator: S.optional(VpnConcentrator)
      .pipe(T.XmlName("vpnConcentrator"), T.Ec2QueryName("VpnConcentrator"))
      .annotate({ identifier: "VpnConcentrator" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateVpnConcentratorResult",
}) as any as S.Schema<CreateVpnConcentratorResult>;
export type TunnelInsideIpVersion = "ipv4" | "ipv6" | (string & {});
export const TunnelInsideIpVersion = S.String;
export interface Phase1EncryptionAlgorithmsRequestListValue {
  Value?: string;
}
export const Phase1EncryptionAlgorithmsRequestListValue = S.suspend(() =>
  S.Struct({ Value: S.optional(S.String) }),
).annotate({
  identifier: "Phase1EncryptionAlgorithmsRequestListValue",
}) as any as S.Schema<Phase1EncryptionAlgorithmsRequestListValue>;
export type Phase1EncryptionAlgorithmsRequestList =
  Phase1EncryptionAlgorithmsRequestListValue[];
export const Phase1EncryptionAlgorithmsRequestList = S.Array(
  Phase1EncryptionAlgorithmsRequestListValue.pipe(T.XmlName("item")).annotate({
    identifier: "Phase1EncryptionAlgorithmsRequestListValue",
  }),
);
export interface Phase2EncryptionAlgorithmsRequestListValue {
  Value?: string;
}
export const Phase2EncryptionAlgorithmsRequestListValue = S.suspend(() =>
  S.Struct({ Value: S.optional(S.String) }),
).annotate({
  identifier: "Phase2EncryptionAlgorithmsRequestListValue",
}) as any as S.Schema<Phase2EncryptionAlgorithmsRequestListValue>;
export type Phase2EncryptionAlgorithmsRequestList =
  Phase2EncryptionAlgorithmsRequestListValue[];
export const Phase2EncryptionAlgorithmsRequestList = S.Array(
  Phase2EncryptionAlgorithmsRequestListValue.pipe(T.XmlName("item")).annotate({
    identifier: "Phase2EncryptionAlgorithmsRequestListValue",
  }),
);
export interface Phase1IntegrityAlgorithmsRequestListValue {
  Value?: string;
}
export const Phase1IntegrityAlgorithmsRequestListValue = S.suspend(() =>
  S.Struct({ Value: S.optional(S.String) }),
).annotate({
  identifier: "Phase1IntegrityAlgorithmsRequestListValue",
}) as any as S.Schema<Phase1IntegrityAlgorithmsRequestListValue>;
export type Phase1IntegrityAlgorithmsRequestList =
  Phase1IntegrityAlgorithmsRequestListValue[];
export const Phase1IntegrityAlgorithmsRequestList = S.Array(
  Phase1IntegrityAlgorithmsRequestListValue.pipe(T.XmlName("item")).annotate({
    identifier: "Phase1IntegrityAlgorithmsRequestListValue",
  }),
);
export interface Phase2IntegrityAlgorithmsRequestListValue {
  Value?: string;
}
export const Phase2IntegrityAlgorithmsRequestListValue = S.suspend(() =>
  S.Struct({ Value: S.optional(S.String) }),
).annotate({
  identifier: "Phase2IntegrityAlgorithmsRequestListValue",
}) as any as S.Schema<Phase2IntegrityAlgorithmsRequestListValue>;
export type Phase2IntegrityAlgorithmsRequestList =
  Phase2IntegrityAlgorithmsRequestListValue[];
export const Phase2IntegrityAlgorithmsRequestList = S.Array(
  Phase2IntegrityAlgorithmsRequestListValue.pipe(T.XmlName("item")).annotate({
    identifier: "Phase2IntegrityAlgorithmsRequestListValue",
  }),
);
export interface Phase1DHGroupNumbersRequestListValue {
  Value?: number;
}
export const Phase1DHGroupNumbersRequestListValue = S.suspend(() =>
  S.Struct({ Value: S.optional(S.Number) }),
).annotate({
  identifier: "Phase1DHGroupNumbersRequestListValue",
}) as any as S.Schema<Phase1DHGroupNumbersRequestListValue>;
export type Phase1DHGroupNumbersRequestList =
  Phase1DHGroupNumbersRequestListValue[];
export const Phase1DHGroupNumbersRequestList = S.Array(
  Phase1DHGroupNumbersRequestListValue.pipe(T.XmlName("item")).annotate({
    identifier: "Phase1DHGroupNumbersRequestListValue",
  }),
);
export interface Phase2DHGroupNumbersRequestListValue {
  Value?: number;
}
export const Phase2DHGroupNumbersRequestListValue = S.suspend(() =>
  S.Struct({ Value: S.optional(S.Number) }),
).annotate({
  identifier: "Phase2DHGroupNumbersRequestListValue",
}) as any as S.Schema<Phase2DHGroupNumbersRequestListValue>;
export type Phase2DHGroupNumbersRequestList =
  Phase2DHGroupNumbersRequestListValue[];
export const Phase2DHGroupNumbersRequestList = S.Array(
  Phase2DHGroupNumbersRequestListValue.pipe(T.XmlName("item")).annotate({
    identifier: "Phase2DHGroupNumbersRequestListValue",
  }),
);
export interface IKEVersionsRequestListValue {
  Value?: string;
}
export const IKEVersionsRequestListValue = S.suspend(() =>
  S.Struct({ Value: S.optional(S.String) }),
).annotate({
  identifier: "IKEVersionsRequestListValue",
}) as any as S.Schema<IKEVersionsRequestListValue>;
export type IKEVersionsRequestList = IKEVersionsRequestListValue[];
export const IKEVersionsRequestList = S.Array(
  IKEVersionsRequestListValue.pipe(T.XmlName("item")).annotate({
    identifier: "IKEVersionsRequestListValue",
  }),
);
export interface CloudWatchLogOptionsSpecification {
  LogEnabled?: boolean;
  LogGroupArn?: string;
  LogOutputFormat?: string;
  BgpLogEnabled?: boolean;
  BgpLogGroupArn?: string;
  BgpLogOutputFormat?: string;
}
export const CloudWatchLogOptionsSpecification = S.suspend(() =>
  S.Struct({
    LogEnabled: S.optional(S.Boolean),
    LogGroupArn: S.optional(S.String),
    LogOutputFormat: S.optional(S.String),
    BgpLogEnabled: S.optional(S.Boolean),
    BgpLogGroupArn: S.optional(S.String),
    BgpLogOutputFormat: S.optional(S.String),
  }),
).annotate({
  identifier: "CloudWatchLogOptionsSpecification",
}) as any as S.Schema<CloudWatchLogOptionsSpecification>;
export interface VpnTunnelLogOptionsSpecification {
  CloudWatchLogOptions?: CloudWatchLogOptionsSpecification;
}
export const VpnTunnelLogOptionsSpecification = S.suspend(() =>
  S.Struct({
    CloudWatchLogOptions: S.optional(CloudWatchLogOptionsSpecification),
  }),
).annotate({
  identifier: "VpnTunnelLogOptionsSpecification",
}) as any as S.Schema<VpnTunnelLogOptionsSpecification>;
export interface VpnTunnelOptionsSpecification {
  TunnelInsideCidr?: string;
  TunnelInsideIpv6Cidr?: string;
  PreSharedKey?: string | redacted.Redacted<string>;
  Phase1LifetimeSeconds?: number;
  Phase2LifetimeSeconds?: number;
  RekeyMarginTimeSeconds?: number;
  RekeyFuzzPercentage?: number;
  ReplayWindowSize?: number;
  DPDTimeoutSeconds?: number;
  DPDTimeoutAction?: string;
  Phase1EncryptionAlgorithms?: Phase1EncryptionAlgorithmsRequestListValue[];
  Phase2EncryptionAlgorithms?: Phase2EncryptionAlgorithmsRequestListValue[];
  Phase1IntegrityAlgorithms?: Phase1IntegrityAlgorithmsRequestListValue[];
  Phase2IntegrityAlgorithms?: Phase2IntegrityAlgorithmsRequestListValue[];
  Phase1DHGroupNumbers?: Phase1DHGroupNumbersRequestListValue[];
  Phase2DHGroupNumbers?: Phase2DHGroupNumbersRequestListValue[];
  IKEVersions?: IKEVersionsRequestListValue[];
  StartupAction?: string;
  LogOptions?: VpnTunnelLogOptionsSpecification;
  EnableTunnelLifecycleControl?: boolean;
}
export const VpnTunnelOptionsSpecification = S.suspend(() =>
  S.Struct({
    TunnelInsideCidr: S.optional(S.String),
    TunnelInsideIpv6Cidr: S.optional(S.String),
    PreSharedKey: S.optional(SensitiveString),
    Phase1LifetimeSeconds: S.optional(S.Number),
    Phase2LifetimeSeconds: S.optional(S.Number),
    RekeyMarginTimeSeconds: S.optional(S.Number),
    RekeyFuzzPercentage: S.optional(S.Number),
    ReplayWindowSize: S.optional(S.Number),
    DPDTimeoutSeconds: S.optional(S.Number),
    DPDTimeoutAction: S.optional(S.String),
    Phase1EncryptionAlgorithms: S.optional(
      Phase1EncryptionAlgorithmsRequestList,
    ).pipe(T.XmlName("Phase1EncryptionAlgorithm")),
    Phase2EncryptionAlgorithms: S.optional(
      Phase2EncryptionAlgorithmsRequestList,
    ).pipe(T.XmlName("Phase2EncryptionAlgorithm")),
    Phase1IntegrityAlgorithms: S.optional(
      Phase1IntegrityAlgorithmsRequestList,
    ).pipe(T.XmlName("Phase1IntegrityAlgorithm")),
    Phase2IntegrityAlgorithms: S.optional(
      Phase2IntegrityAlgorithmsRequestList,
    ).pipe(T.XmlName("Phase2IntegrityAlgorithm")),
    Phase1DHGroupNumbers: S.optional(Phase1DHGroupNumbersRequestList).pipe(
      T.XmlName("Phase1DHGroupNumber"),
    ),
    Phase2DHGroupNumbers: S.optional(Phase2DHGroupNumbersRequestList).pipe(
      T.XmlName("Phase2DHGroupNumber"),
    ),
    IKEVersions: S.optional(IKEVersionsRequestList).pipe(
      T.XmlName("IKEVersion"),
    ),
    StartupAction: S.optional(S.String),
    LogOptions: S.optional(VpnTunnelLogOptionsSpecification),
    EnableTunnelLifecycleControl: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "VpnTunnelOptionsSpecification",
}) as any as S.Schema<VpnTunnelOptionsSpecification>;
export type VpnTunnelOptionsSpecificationsList =
  VpnTunnelOptionsSpecification[];
export const VpnTunnelOptionsSpecificationsList = S.Array(
  VpnTunnelOptionsSpecification,
);
export type VpnTunnelBandwidth = "standard" | "large" | (string & {});
export const VpnTunnelBandwidth = S.String;
export interface VpnConnectionOptionsSpecification {
  EnableAcceleration?: boolean;
  TunnelInsideIpVersion?: TunnelInsideIpVersion;
  TunnelOptions?: VpnTunnelOptionsSpecification[];
  LocalIpv4NetworkCidr?: string;
  RemoteIpv4NetworkCidr?: string;
  LocalIpv6NetworkCidr?: string;
  RemoteIpv6NetworkCidr?: string;
  OutsideIpAddressType?: string;
  TransportTransitGatewayAttachmentId?: string;
  TunnelBandwidth?: VpnTunnelBandwidth;
  StaticRoutesOnly?: boolean;
}
export const VpnConnectionOptionsSpecification = S.suspend(() =>
  S.Struct({
    EnableAcceleration: S.optional(S.Boolean),
    TunnelInsideIpVersion: S.optional(TunnelInsideIpVersion),
    TunnelOptions: S.optional(VpnTunnelOptionsSpecificationsList),
    LocalIpv4NetworkCidr: S.optional(S.String),
    RemoteIpv4NetworkCidr: S.optional(S.String),
    LocalIpv6NetworkCidr: S.optional(S.String),
    RemoteIpv6NetworkCidr: S.optional(S.String),
    OutsideIpAddressType: S.optional(S.String),
    TransportTransitGatewayAttachmentId: S.optional(S.String),
    TunnelBandwidth: S.optional(VpnTunnelBandwidth),
    StaticRoutesOnly: S.optional(S.Boolean).pipe(
      T.XmlName("staticRoutesOnly"),
      T.Ec2QueryName("StaticRoutesOnly"),
    ),
  }),
).annotate({
  identifier: "VpnConnectionOptionsSpecification",
}) as any as S.Schema<VpnConnectionOptionsSpecification>;
export interface CreateVpnConnectionRequest {
  CustomerGatewayId?: string;
  Type?: string;
  VpnGatewayId?: string;
  TransitGatewayId?: string;
  VpnConcentratorId?: string;
  TagSpecifications?: TagSpecification[];
  PreSharedKeyStorage?: string;
  DryRun?: boolean;
  Options?: VpnConnectionOptionsSpecification;
}
export const CreateVpnConnectionRequest = S.suspend(() =>
  S.Struct({
    CustomerGatewayId: S.optional(S.String),
    Type: S.optional(S.String),
    VpnGatewayId: S.optional(S.String),
    TransitGatewayId: S.optional(S.String),
    VpnConcentratorId: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    PreSharedKeyStorage: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Options: S.optional(VpnConnectionOptionsSpecification)
      .pipe(T.XmlName("options"), T.Ec2QueryName("Options"))
      .annotate({ identifier: "VpnConnectionOptionsSpecification" }),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateVpnConnectionRequest",
}) as any as S.Schema<CreateVpnConnectionRequest>;
export type GatewayAssociationState =
  | "associated"
  | "not-associated"
  | "associating"
  | "disassociating"
  | (string & {});
export const GatewayAssociationState = S.String;
export interface Phase1EncryptionAlgorithmsListValue {
  Value?: string;
}
export const Phase1EncryptionAlgorithmsListValue = S.suspend(() =>
  S.Struct({
    Value: S.optional(S.String).pipe(
      T.XmlName("value"),
      T.Ec2QueryName("Value"),
    ),
  }),
).annotate({
  identifier: "Phase1EncryptionAlgorithmsListValue",
}) as any as S.Schema<Phase1EncryptionAlgorithmsListValue>;
export type Phase1EncryptionAlgorithmsList =
  Phase1EncryptionAlgorithmsListValue[];
export const Phase1EncryptionAlgorithmsList = S.Array(
  Phase1EncryptionAlgorithmsListValue.pipe(T.XmlName("item")).annotate({
    identifier: "Phase1EncryptionAlgorithmsListValue",
  }),
);
export interface Phase2EncryptionAlgorithmsListValue {
  Value?: string;
}
export const Phase2EncryptionAlgorithmsListValue = S.suspend(() =>
  S.Struct({
    Value: S.optional(S.String).pipe(
      T.XmlName("value"),
      T.Ec2QueryName("Value"),
    ),
  }),
).annotate({
  identifier: "Phase2EncryptionAlgorithmsListValue",
}) as any as S.Schema<Phase2EncryptionAlgorithmsListValue>;
export type Phase2EncryptionAlgorithmsList =
  Phase2EncryptionAlgorithmsListValue[];
export const Phase2EncryptionAlgorithmsList = S.Array(
  Phase2EncryptionAlgorithmsListValue.pipe(T.XmlName("item")).annotate({
    identifier: "Phase2EncryptionAlgorithmsListValue",
  }),
);
export interface Phase1IntegrityAlgorithmsListValue {
  Value?: string;
}
export const Phase1IntegrityAlgorithmsListValue = S.suspend(() =>
  S.Struct({
    Value: S.optional(S.String).pipe(
      T.XmlName("value"),
      T.Ec2QueryName("Value"),
    ),
  }),
).annotate({
  identifier: "Phase1IntegrityAlgorithmsListValue",
}) as any as S.Schema<Phase1IntegrityAlgorithmsListValue>;
export type Phase1IntegrityAlgorithmsList =
  Phase1IntegrityAlgorithmsListValue[];
export const Phase1IntegrityAlgorithmsList = S.Array(
  Phase1IntegrityAlgorithmsListValue.pipe(T.XmlName("item")).annotate({
    identifier: "Phase1IntegrityAlgorithmsListValue",
  }),
);
export interface Phase2IntegrityAlgorithmsListValue {
  Value?: string;
}
export const Phase2IntegrityAlgorithmsListValue = S.suspend(() =>
  S.Struct({
    Value: S.optional(S.String).pipe(
      T.XmlName("value"),
      T.Ec2QueryName("Value"),
    ),
  }),
).annotate({
  identifier: "Phase2IntegrityAlgorithmsListValue",
}) as any as S.Schema<Phase2IntegrityAlgorithmsListValue>;
export type Phase2IntegrityAlgorithmsList =
  Phase2IntegrityAlgorithmsListValue[];
export const Phase2IntegrityAlgorithmsList = S.Array(
  Phase2IntegrityAlgorithmsListValue.pipe(T.XmlName("item")).annotate({
    identifier: "Phase2IntegrityAlgorithmsListValue",
  }),
);
export interface Phase1DHGroupNumbersListValue {
  Value?: number;
}
export const Phase1DHGroupNumbersListValue = S.suspend(() =>
  S.Struct({
    Value: S.optional(S.Number).pipe(
      T.XmlName("value"),
      T.Ec2QueryName("Value"),
    ),
  }),
).annotate({
  identifier: "Phase1DHGroupNumbersListValue",
}) as any as S.Schema<Phase1DHGroupNumbersListValue>;
export type Phase1DHGroupNumbersList = Phase1DHGroupNumbersListValue[];
export const Phase1DHGroupNumbersList = S.Array(
  Phase1DHGroupNumbersListValue.pipe(T.XmlName("item")).annotate({
    identifier: "Phase1DHGroupNumbersListValue",
  }),
);
export interface Phase2DHGroupNumbersListValue {
  Value?: number;
}
export const Phase2DHGroupNumbersListValue = S.suspend(() =>
  S.Struct({
    Value: S.optional(S.Number).pipe(
      T.XmlName("value"),
      T.Ec2QueryName("Value"),
    ),
  }),
).annotate({
  identifier: "Phase2DHGroupNumbersListValue",
}) as any as S.Schema<Phase2DHGroupNumbersListValue>;
export type Phase2DHGroupNumbersList = Phase2DHGroupNumbersListValue[];
export const Phase2DHGroupNumbersList = S.Array(
  Phase2DHGroupNumbersListValue.pipe(T.XmlName("item")).annotate({
    identifier: "Phase2DHGroupNumbersListValue",
  }),
);
export interface IKEVersionsListValue {
  Value?: string;
}
export const IKEVersionsListValue = S.suspend(() =>
  S.Struct({
    Value: S.optional(S.String).pipe(
      T.XmlName("value"),
      T.Ec2QueryName("Value"),
    ),
  }),
).annotate({
  identifier: "IKEVersionsListValue",
}) as any as S.Schema<IKEVersionsListValue>;
export type IKEVersionsList = IKEVersionsListValue[];
export const IKEVersionsList = S.Array(
  IKEVersionsListValue.pipe(T.XmlName("item")).annotate({
    identifier: "IKEVersionsListValue",
  }),
);
export interface CloudWatchLogOptions {
  LogEnabled?: boolean;
  LogGroupArn?: string;
  LogOutputFormat?: string;
  BgpLogEnabled?: boolean;
  BgpLogGroupArn?: string;
  BgpLogOutputFormat?: string;
}
export const CloudWatchLogOptions = S.suspend(() =>
  S.Struct({
    LogEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("logEnabled"),
      T.Ec2QueryName("LogEnabled"),
    ),
    LogGroupArn: S.optional(S.String).pipe(
      T.XmlName("logGroupArn"),
      T.Ec2QueryName("LogGroupArn"),
    ),
    LogOutputFormat: S.optional(S.String).pipe(
      T.XmlName("logOutputFormat"),
      T.Ec2QueryName("LogOutputFormat"),
    ),
    BgpLogEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("bgpLogEnabled"),
      T.Ec2QueryName("BgpLogEnabled"),
    ),
    BgpLogGroupArn: S.optional(S.String).pipe(
      T.XmlName("bgpLogGroupArn"),
      T.Ec2QueryName("BgpLogGroupArn"),
    ),
    BgpLogOutputFormat: S.optional(S.String).pipe(
      T.XmlName("bgpLogOutputFormat"),
      T.Ec2QueryName("BgpLogOutputFormat"),
    ),
  }),
).annotate({
  identifier: "CloudWatchLogOptions",
}) as any as S.Schema<CloudWatchLogOptions>;
export interface VpnTunnelLogOptions {
  CloudWatchLogOptions?: CloudWatchLogOptions;
}
export const VpnTunnelLogOptions = S.suspend(() =>
  S.Struct({
    CloudWatchLogOptions: S.optional(CloudWatchLogOptions)
      .pipe(
        T.XmlName("cloudWatchLogOptions"),
        T.Ec2QueryName("CloudWatchLogOptions"),
      )
      .annotate({ identifier: "CloudWatchLogOptions" }),
  }),
).annotate({
  identifier: "VpnTunnelLogOptions",
}) as any as S.Schema<VpnTunnelLogOptions>;
export interface TunnelOption {
  OutsideIpAddress?: string;
  TunnelInsideCidr?: string;
  TunnelInsideIpv6Cidr?: string;
  PreSharedKey?: string | redacted.Redacted<string>;
  Phase1LifetimeSeconds?: number;
  Phase2LifetimeSeconds?: number;
  RekeyMarginTimeSeconds?: number;
  RekeyFuzzPercentage?: number;
  ReplayWindowSize?: number;
  DpdTimeoutSeconds?: number;
  DpdTimeoutAction?: string;
  Phase1EncryptionAlgorithms?: Phase1EncryptionAlgorithmsListValue[];
  Phase2EncryptionAlgorithms?: Phase2EncryptionAlgorithmsListValue[];
  Phase1IntegrityAlgorithms?: Phase1IntegrityAlgorithmsListValue[];
  Phase2IntegrityAlgorithms?: Phase2IntegrityAlgorithmsListValue[];
  Phase1DHGroupNumbers?: Phase1DHGroupNumbersListValue[];
  Phase2DHGroupNumbers?: Phase2DHGroupNumbersListValue[];
  IkeVersions?: IKEVersionsListValue[];
  StartupAction?: string;
  LogOptions?: VpnTunnelLogOptions;
  EnableTunnelLifecycleControl?: boolean;
}
export const TunnelOption = S.suspend(() =>
  S.Struct({
    OutsideIpAddress: S.optional(S.String).pipe(
      T.XmlName("outsideIpAddress"),
      T.Ec2QueryName("OutsideIpAddress"),
    ),
    TunnelInsideCidr: S.optional(S.String).pipe(
      T.XmlName("tunnelInsideCidr"),
      T.Ec2QueryName("TunnelInsideCidr"),
    ),
    TunnelInsideIpv6Cidr: S.optional(S.String).pipe(
      T.XmlName("tunnelInsideIpv6Cidr"),
      T.Ec2QueryName("TunnelInsideIpv6Cidr"),
    ),
    PreSharedKey: S.optional(SensitiveString).pipe(
      T.XmlName("preSharedKey"),
      T.Ec2QueryName("PreSharedKey"),
    ),
    Phase1LifetimeSeconds: S.optional(S.Number).pipe(
      T.XmlName("phase1LifetimeSeconds"),
      T.Ec2QueryName("Phase1LifetimeSeconds"),
    ),
    Phase2LifetimeSeconds: S.optional(S.Number).pipe(
      T.XmlName("phase2LifetimeSeconds"),
      T.Ec2QueryName("Phase2LifetimeSeconds"),
    ),
    RekeyMarginTimeSeconds: S.optional(S.Number).pipe(
      T.XmlName("rekeyMarginTimeSeconds"),
      T.Ec2QueryName("RekeyMarginTimeSeconds"),
    ),
    RekeyFuzzPercentage: S.optional(S.Number).pipe(
      T.XmlName("rekeyFuzzPercentage"),
      T.Ec2QueryName("RekeyFuzzPercentage"),
    ),
    ReplayWindowSize: S.optional(S.Number).pipe(
      T.XmlName("replayWindowSize"),
      T.Ec2QueryName("ReplayWindowSize"),
    ),
    DpdTimeoutSeconds: S.optional(S.Number).pipe(
      T.XmlName("dpdTimeoutSeconds"),
      T.Ec2QueryName("DpdTimeoutSeconds"),
    ),
    DpdTimeoutAction: S.optional(S.String).pipe(
      T.XmlName("dpdTimeoutAction"),
      T.Ec2QueryName("DpdTimeoutAction"),
    ),
    Phase1EncryptionAlgorithms: S.optional(Phase1EncryptionAlgorithmsList).pipe(
      T.XmlName("phase1EncryptionAlgorithmSet"),
      T.Ec2QueryName("Phase1EncryptionAlgorithmSet"),
    ),
    Phase2EncryptionAlgorithms: S.optional(Phase2EncryptionAlgorithmsList).pipe(
      T.XmlName("phase2EncryptionAlgorithmSet"),
      T.Ec2QueryName("Phase2EncryptionAlgorithmSet"),
    ),
    Phase1IntegrityAlgorithms: S.optional(Phase1IntegrityAlgorithmsList).pipe(
      T.XmlName("phase1IntegrityAlgorithmSet"),
      T.Ec2QueryName("Phase1IntegrityAlgorithmSet"),
    ),
    Phase2IntegrityAlgorithms: S.optional(Phase2IntegrityAlgorithmsList).pipe(
      T.XmlName("phase2IntegrityAlgorithmSet"),
      T.Ec2QueryName("Phase2IntegrityAlgorithmSet"),
    ),
    Phase1DHGroupNumbers: S.optional(Phase1DHGroupNumbersList).pipe(
      T.XmlName("phase1DHGroupNumberSet"),
      T.Ec2QueryName("Phase1DHGroupNumberSet"),
    ),
    Phase2DHGroupNumbers: S.optional(Phase2DHGroupNumbersList).pipe(
      T.XmlName("phase2DHGroupNumberSet"),
      T.Ec2QueryName("Phase2DHGroupNumberSet"),
    ),
    IkeVersions: S.optional(IKEVersionsList).pipe(
      T.XmlName("ikeVersionSet"),
      T.Ec2QueryName("IkeVersionSet"),
    ),
    StartupAction: S.optional(S.String).pipe(
      T.XmlName("startupAction"),
      T.Ec2QueryName("StartupAction"),
    ),
    LogOptions: S.optional(VpnTunnelLogOptions)
      .pipe(T.XmlName("logOptions"), T.Ec2QueryName("LogOptions"))
      .annotate({ identifier: "VpnTunnelLogOptions" }),
    EnableTunnelLifecycleControl: S.optional(S.Boolean).pipe(
      T.XmlName("enableTunnelLifecycleControl"),
      T.Ec2QueryName("EnableTunnelLifecycleControl"),
    ),
  }),
).annotate({ identifier: "TunnelOption" }) as any as S.Schema<TunnelOption>;
export type TunnelOptionsList = TunnelOption[];
export const TunnelOptionsList = S.Array(
  TunnelOption.pipe(T.XmlName("item")).annotate({ identifier: "TunnelOption" }),
);
export interface VpnConnectionOptions {
  EnableAcceleration?: boolean;
  StaticRoutesOnly?: boolean;
  LocalIpv4NetworkCidr?: string;
  RemoteIpv4NetworkCidr?: string;
  LocalIpv6NetworkCidr?: string;
  RemoteIpv6NetworkCidr?: string;
  OutsideIpAddressType?: string;
  TransportTransitGatewayAttachmentId?: string;
  TunnelInsideIpVersion?: TunnelInsideIpVersion;
  TunnelOptions?: TunnelOption[];
  TunnelBandwidth?: VpnTunnelBandwidth;
}
export const VpnConnectionOptions = S.suspend(() =>
  S.Struct({
    EnableAcceleration: S.optional(S.Boolean).pipe(
      T.XmlName("enableAcceleration"),
      T.Ec2QueryName("EnableAcceleration"),
    ),
    StaticRoutesOnly: S.optional(S.Boolean).pipe(
      T.XmlName("staticRoutesOnly"),
      T.Ec2QueryName("StaticRoutesOnly"),
    ),
    LocalIpv4NetworkCidr: S.optional(S.String).pipe(
      T.XmlName("localIpv4NetworkCidr"),
      T.Ec2QueryName("LocalIpv4NetworkCidr"),
    ),
    RemoteIpv4NetworkCidr: S.optional(S.String).pipe(
      T.XmlName("remoteIpv4NetworkCidr"),
      T.Ec2QueryName("RemoteIpv4NetworkCidr"),
    ),
    LocalIpv6NetworkCidr: S.optional(S.String).pipe(
      T.XmlName("localIpv6NetworkCidr"),
      T.Ec2QueryName("LocalIpv6NetworkCidr"),
    ),
    RemoteIpv6NetworkCidr: S.optional(S.String).pipe(
      T.XmlName("remoteIpv6NetworkCidr"),
      T.Ec2QueryName("RemoteIpv6NetworkCidr"),
    ),
    OutsideIpAddressType: S.optional(S.String).pipe(
      T.XmlName("outsideIpAddressType"),
      T.Ec2QueryName("OutsideIpAddressType"),
    ),
    TransportTransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("transportTransitGatewayAttachmentId"),
      T.Ec2QueryName("TransportTransitGatewayAttachmentId"),
    ),
    TunnelInsideIpVersion: S.optional(TunnelInsideIpVersion).pipe(
      T.XmlName("tunnelInsideIpVersion"),
      T.Ec2QueryName("TunnelInsideIpVersion"),
    ),
    TunnelOptions: S.optional(TunnelOptionsList).pipe(
      T.XmlName("tunnelOptionSet"),
      T.Ec2QueryName("TunnelOptionSet"),
    ),
    TunnelBandwidth: S.optional(VpnTunnelBandwidth).pipe(
      T.XmlName("tunnelBandwidth"),
      T.Ec2QueryName("TunnelBandwidth"),
    ),
  }),
).annotate({
  identifier: "VpnConnectionOptions",
}) as any as S.Schema<VpnConnectionOptions>;
export type VpnStaticRouteSource = "Static" | (string & {});
export const VpnStaticRouteSource = S.String;
export type VpnState =
  | "pending"
  | "available"
  | "deleting"
  | "deleted"
  | (string & {});
export const VpnState = S.String;
export interface VpnStaticRoute {
  DestinationCidrBlock?: string;
  Source?: VpnStaticRouteSource;
  State?: VpnState;
}
export const VpnStaticRoute = S.suspend(() =>
  S.Struct({
    DestinationCidrBlock: S.optional(S.String).pipe(
      T.XmlName("destinationCidrBlock"),
      T.Ec2QueryName("DestinationCidrBlock"),
    ),
    Source: S.optional(VpnStaticRouteSource).pipe(
      T.XmlName("source"),
      T.Ec2QueryName("Source"),
    ),
    State: S.optional(VpnState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({ identifier: "VpnStaticRoute" }) as any as S.Schema<VpnStaticRoute>;
export type VpnStaticRouteList = VpnStaticRoute[];
export const VpnStaticRouteList = S.Array(
  VpnStaticRoute.pipe(T.XmlName("item")).annotate({
    identifier: "VpnStaticRoute",
  }),
);
export type TelemetryStatus = "UP" | "DOWN" | (string & {});
export const TelemetryStatus = S.String;
export interface VgwTelemetry {
  AcceptedRouteCount?: number;
  LastStatusChange?: Date;
  OutsideIpAddress?: string;
  Status?: TelemetryStatus;
  StatusMessage?: string;
  CertificateArn?: string;
}
export const VgwTelemetry = S.suspend(() =>
  S.Struct({
    AcceptedRouteCount: S.optional(S.Number).pipe(
      T.XmlName("acceptedRouteCount"),
      T.Ec2QueryName("AcceptedRouteCount"),
    ),
    LastStatusChange: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("lastStatusChange"), T.Ec2QueryName("LastStatusChange")),
    OutsideIpAddress: S.optional(S.String).pipe(
      T.XmlName("outsideIpAddress"),
      T.Ec2QueryName("OutsideIpAddress"),
    ),
    Status: S.optional(TelemetryStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    CertificateArn: S.optional(S.String).pipe(
      T.XmlName("certificateArn"),
      T.Ec2QueryName("CertificateArn"),
    ),
  }),
).annotate({ identifier: "VgwTelemetry" }) as any as S.Schema<VgwTelemetry>;
export type VgwTelemetryList = VgwTelemetry[];
export const VgwTelemetryList = S.Array(
  VgwTelemetry.pipe(T.XmlName("item")).annotate({ identifier: "VgwTelemetry" }),
);
export interface VpnConnection {
  Category?: string;
  TransitGatewayId?: string;
  VpnConcentratorId?: string;
  CoreNetworkArn?: string;
  CoreNetworkAttachmentArn?: string;
  GatewayAssociationState?: GatewayAssociationState;
  Options?: VpnConnectionOptions;
  Routes?: VpnStaticRoute[];
  Tags?: Tag[];
  VgwTelemetry?: VgwTelemetry[];
  PreSharedKeyArn?: string;
  VpnConnectionId?: string;
  State?: VpnState;
  CustomerGatewayConfiguration?: string | redacted.Redacted<string>;
  Type?: GatewayType;
  CustomerGatewayId?: string;
  VpnGatewayId?: string;
}
export const VpnConnection = S.suspend(() =>
  S.Struct({
    Category: S.optional(S.String).pipe(
      T.XmlName("category"),
      T.Ec2QueryName("Category"),
    ),
    TransitGatewayId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayId"),
      T.Ec2QueryName("TransitGatewayId"),
    ),
    VpnConcentratorId: S.optional(S.String).pipe(
      T.XmlName("vpnConcentratorId"),
      T.Ec2QueryName("VpnConcentratorId"),
    ),
    CoreNetworkArn: S.optional(S.String).pipe(
      T.XmlName("coreNetworkArn"),
      T.Ec2QueryName("CoreNetworkArn"),
    ),
    CoreNetworkAttachmentArn: S.optional(S.String).pipe(
      T.XmlName("coreNetworkAttachmentArn"),
      T.Ec2QueryName("CoreNetworkAttachmentArn"),
    ),
    GatewayAssociationState: S.optional(GatewayAssociationState).pipe(
      T.XmlName("gatewayAssociationState"),
      T.Ec2QueryName("GatewayAssociationState"),
    ),
    Options: S.optional(VpnConnectionOptions)
      .pipe(T.XmlName("options"), T.Ec2QueryName("Options"))
      .annotate({ identifier: "VpnConnectionOptions" }),
    Routes: S.optional(VpnStaticRouteList).pipe(
      T.XmlName("routes"),
      T.Ec2QueryName("Routes"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    VgwTelemetry: S.optional(VgwTelemetryList).pipe(
      T.XmlName("vgwTelemetry"),
      T.Ec2QueryName("VgwTelemetry"),
    ),
    PreSharedKeyArn: S.optional(S.String).pipe(
      T.XmlName("preSharedKeyArn"),
      T.Ec2QueryName("PreSharedKeyArn"),
    ),
    VpnConnectionId: S.optional(S.String).pipe(
      T.XmlName("vpnConnectionId"),
      T.Ec2QueryName("VpnConnectionId"),
    ),
    State: S.optional(VpnState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    CustomerGatewayConfiguration: S.optional(SensitiveString).pipe(
      T.XmlName("customerGatewayConfiguration"),
      T.Ec2QueryName("CustomerGatewayConfiguration"),
    ),
    Type: S.optional(GatewayType).pipe(
      T.XmlName("type"),
      T.Ec2QueryName("Type"),
    ),
    CustomerGatewayId: S.optional(S.String).pipe(
      T.XmlName("customerGatewayId"),
      T.Ec2QueryName("CustomerGatewayId"),
    ),
    VpnGatewayId: S.optional(S.String).pipe(
      T.XmlName("vpnGatewayId"),
      T.Ec2QueryName("VpnGatewayId"),
    ),
  }),
).annotate({ identifier: "VpnConnection" }) as any as S.Schema<VpnConnection>;
export interface CreateVpnConnectionResult {
  VpnConnection?: VpnConnection;
}
export const CreateVpnConnectionResult = S.suspend(() =>
  S.Struct({
    VpnConnection: S.optional(VpnConnection)
      .pipe(T.XmlName("vpnConnection"), T.Ec2QueryName("VpnConnection"))
      .annotate({ identifier: "VpnConnection" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateVpnConnectionResult",
}) as any as S.Schema<CreateVpnConnectionResult>;
export interface CreateVpnConnectionRouteRequest {
  DestinationCidrBlock?: string;
  VpnConnectionId?: string;
}
export const CreateVpnConnectionRouteRequest = S.suspend(() =>
  S.Struct({
    DestinationCidrBlock: S.optional(S.String),
    VpnConnectionId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateVpnConnectionRouteRequest",
}) as any as S.Schema<CreateVpnConnectionRouteRequest>;
export interface CreateVpnConnectionRouteResponse {}
export const CreateVpnConnectionRouteResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "CreateVpnConnectionRouteResponse",
}) as any as S.Schema<CreateVpnConnectionRouteResponse>;
export interface CreateVpnGatewayRequest {
  AvailabilityZone?: string;
  Type?: GatewayType;
  TagSpecifications?: TagSpecification[];
  AmazonSideAsn?: number;
  DryRun?: boolean;
}
export const CreateVpnGatewayRequest = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String),
    Type: S.optional(GatewayType),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    AmazonSideAsn: S.optional(S.Number),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateVpnGatewayRequest",
}) as any as S.Schema<CreateVpnGatewayRequest>;
export type VpcAttachmentList = VpcAttachment[];
export const VpcAttachmentList = S.Array(
  VpcAttachment.pipe(T.XmlName("item")).annotate({
    identifier: "VpcAttachment",
  }),
);
export interface VpnGateway {
  AmazonSideAsn?: number;
  Tags?: Tag[];
  VpnGatewayId?: string;
  State?: VpnState;
  Type?: GatewayType;
  AvailabilityZone?: string;
  VpcAttachments?: VpcAttachment[];
}
export const VpnGateway = S.suspend(() =>
  S.Struct({
    AmazonSideAsn: S.optional(S.Number).pipe(
      T.XmlName("amazonSideAsn"),
      T.Ec2QueryName("AmazonSideAsn"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    VpnGatewayId: S.optional(S.String).pipe(
      T.XmlName("vpnGatewayId"),
      T.Ec2QueryName("VpnGatewayId"),
    ),
    State: S.optional(VpnState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Type: S.optional(GatewayType).pipe(
      T.XmlName("type"),
      T.Ec2QueryName("Type"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    VpcAttachments: S.optional(VpcAttachmentList).pipe(
      T.XmlName("attachments"),
      T.Ec2QueryName("Attachments"),
    ),
  }),
).annotate({ identifier: "VpnGateway" }) as any as S.Schema<VpnGateway>;
export interface CreateVpnGatewayResult {
  VpnGateway?: VpnGateway;
}
export const CreateVpnGatewayResult = S.suspend(() =>
  S.Struct({
    VpnGateway: S.optional(VpnGateway)
      .pipe(T.XmlName("vpnGateway"), T.Ec2QueryName("VpnGateway"))
      .annotate({ identifier: "VpnGateway" }),
  }).pipe(ns),
).annotate({
  identifier: "CreateVpnGatewayResult",
}) as any as S.Schema<CreateVpnGatewayResult>;
export interface DeleteCapacityManagerDataExportRequest {
  CapacityManagerDataExportId?: string;
  DryRun?: boolean;
}
export const DeleteCapacityManagerDataExportRequest = S.suspend(() =>
  S.Struct({
    CapacityManagerDataExportId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteCapacityManagerDataExportRequest",
}) as any as S.Schema<DeleteCapacityManagerDataExportRequest>;
export interface DeleteCapacityManagerDataExportResult {
  CapacityManagerDataExportId?: string;
}
export const DeleteCapacityManagerDataExportResult = S.suspend(() =>
  S.Struct({
    CapacityManagerDataExportId: S.optional(S.String).pipe(
      T.XmlName("capacityManagerDataExportId"),
      T.Ec2QueryName("CapacityManagerDataExportId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteCapacityManagerDataExportResult",
}) as any as S.Schema<DeleteCapacityManagerDataExportResult>;
export interface DeleteCarrierGatewayRequest {
  CarrierGatewayId?: string;
  DryRun?: boolean;
}
export const DeleteCarrierGatewayRequest = S.suspend(() =>
  S.Struct({
    CarrierGatewayId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteCarrierGatewayRequest",
}) as any as S.Schema<DeleteCarrierGatewayRequest>;
export interface DeleteCarrierGatewayResult {
  CarrierGateway?: CarrierGateway;
}
export const DeleteCarrierGatewayResult = S.suspend(() =>
  S.Struct({
    CarrierGateway: S.optional(CarrierGateway)
      .pipe(T.XmlName("carrierGateway"), T.Ec2QueryName("CarrierGateway"))
      .annotate({ identifier: "CarrierGateway" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteCarrierGatewayResult",
}) as any as S.Schema<DeleteCarrierGatewayResult>;
export interface DeleteClientVpnEndpointRequest {
  ClientVpnEndpointId?: string;
  DryRun?: boolean;
}
export const DeleteClientVpnEndpointRequest = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteClientVpnEndpointRequest",
}) as any as S.Schema<DeleteClientVpnEndpointRequest>;
export interface DeleteClientVpnEndpointResult {
  Status?: ClientVpnEndpointStatus;
}
export const DeleteClientVpnEndpointResult = S.suspend(() =>
  S.Struct({
    Status: S.optional(ClientVpnEndpointStatus)
      .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
      .annotate({ identifier: "ClientVpnEndpointStatus" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteClientVpnEndpointResult",
}) as any as S.Schema<DeleteClientVpnEndpointResult>;
export interface DeleteClientVpnRouteRequest {
  ClientVpnEndpointId?: string;
  TargetVpcSubnetId?: string;
  DestinationCidrBlock?: string;
  DryRun?: boolean;
}
export const DeleteClientVpnRouteRequest = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String),
    TargetVpcSubnetId: S.optional(S.String),
    DestinationCidrBlock: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteClientVpnRouteRequest",
}) as any as S.Schema<DeleteClientVpnRouteRequest>;
export interface DeleteClientVpnRouteResult {
  Status?: ClientVpnRouteStatus;
}
export const DeleteClientVpnRouteResult = S.suspend(() =>
  S.Struct({
    Status: S.optional(ClientVpnRouteStatus)
      .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
      .annotate({ identifier: "ClientVpnRouteStatus" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteClientVpnRouteResult",
}) as any as S.Schema<DeleteClientVpnRouteResult>;
export interface DeleteCoipCidrRequest {
  Cidr?: string;
  CoipPoolId?: string;
  DryRun?: boolean;
}
export const DeleteCoipCidrRequest = S.suspend(() =>
  S.Struct({
    Cidr: S.optional(S.String),
    CoipPoolId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteCoipCidrRequest",
}) as any as S.Schema<DeleteCoipCidrRequest>;
export interface DeleteCoipCidrResult {
  CoipCidr?: CoipCidr;
}
export const DeleteCoipCidrResult = S.suspend(() =>
  S.Struct({
    CoipCidr: S.optional(CoipCidr)
      .pipe(T.XmlName("coipCidr"), T.Ec2QueryName("CoipCidr"))
      .annotate({ identifier: "CoipCidr" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteCoipCidrResult",
}) as any as S.Schema<DeleteCoipCidrResult>;
export interface DeleteCoipPoolRequest {
  CoipPoolId?: string;
  DryRun?: boolean;
}
export const DeleteCoipPoolRequest = S.suspend(() =>
  S.Struct({
    CoipPoolId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteCoipPoolRequest",
}) as any as S.Schema<DeleteCoipPoolRequest>;
export interface DeleteCoipPoolResult {
  CoipPool?: CoipPool;
}
export const DeleteCoipPoolResult = S.suspend(() =>
  S.Struct({
    CoipPool: S.optional(CoipPool)
      .pipe(T.XmlName("coipPool"), T.Ec2QueryName("CoipPool"))
      .annotate({ identifier: "CoipPool" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteCoipPoolResult",
}) as any as S.Schema<DeleteCoipPoolResult>;
export interface DeleteCustomerGatewayRequest {
  CustomerGatewayId?: string;
  DryRun?: boolean;
}
export const DeleteCustomerGatewayRequest = S.suspend(() =>
  S.Struct({
    CustomerGatewayId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteCustomerGatewayRequest",
}) as any as S.Schema<DeleteCustomerGatewayRequest>;
export interface DeleteCustomerGatewayResponse {}
export const DeleteCustomerGatewayResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteCustomerGatewayResponse",
}) as any as S.Schema<DeleteCustomerGatewayResponse>;
export interface DeleteDhcpOptionsRequest {
  DhcpOptionsId?: string;
  DryRun?: boolean;
}
export const DeleteDhcpOptionsRequest = S.suspend(() =>
  S.Struct({
    DhcpOptionsId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteDhcpOptionsRequest",
}) as any as S.Schema<DeleteDhcpOptionsRequest>;
export interface DeleteDhcpOptionsResponse {}
export const DeleteDhcpOptionsResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteDhcpOptionsResponse",
}) as any as S.Schema<DeleteDhcpOptionsResponse>;
export interface DeleteEgressOnlyInternetGatewayRequest {
  DryRun?: boolean;
  EgressOnlyInternetGatewayId?: string;
}
export const DeleteEgressOnlyInternetGatewayRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    EgressOnlyInternetGatewayId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteEgressOnlyInternetGatewayRequest",
}) as any as S.Schema<DeleteEgressOnlyInternetGatewayRequest>;
export interface DeleteEgressOnlyInternetGatewayResult {
  ReturnCode?: boolean;
}
export const DeleteEgressOnlyInternetGatewayResult = S.suspend(() =>
  S.Struct({
    ReturnCode: S.optional(S.Boolean).pipe(
      T.XmlName("returnCode"),
      T.Ec2QueryName("ReturnCode"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteEgressOnlyInternetGatewayResult",
}) as any as S.Schema<DeleteEgressOnlyInternetGatewayResult>;
export type FleetIdSet = string[];
export const FleetIdSet = S.Array(S.String);
export interface DeleteFleetsRequest {
  DryRun?: boolean;
  FleetIds?: string[];
  TerminateInstances?: boolean;
}
export const DeleteFleetsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    FleetIds: S.optional(FleetIdSet).pipe(T.XmlName("FleetId")),
    TerminateInstances: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteFleetsRequest",
}) as any as S.Schema<DeleteFleetsRequest>;
export type FleetStateCode =
  | "submitted"
  | "active"
  | "deleted"
  | "failed"
  | "deleted_running"
  | "deleted_terminating"
  | "modifying"
  | (string & {});
export const FleetStateCode = S.String;
export interface DeleteFleetSuccessItem {
  CurrentFleetState?: FleetStateCode;
  PreviousFleetState?: FleetStateCode;
  FleetId?: string;
}
export const DeleteFleetSuccessItem = S.suspend(() =>
  S.Struct({
    CurrentFleetState: S.optional(FleetStateCode).pipe(
      T.XmlName("currentFleetState"),
      T.Ec2QueryName("CurrentFleetState"),
    ),
    PreviousFleetState: S.optional(FleetStateCode).pipe(
      T.XmlName("previousFleetState"),
      T.Ec2QueryName("PreviousFleetState"),
    ),
    FleetId: S.optional(S.String).pipe(
      T.XmlName("fleetId"),
      T.Ec2QueryName("FleetId"),
    ),
  }),
).annotate({
  identifier: "DeleteFleetSuccessItem",
}) as any as S.Schema<DeleteFleetSuccessItem>;
export type DeleteFleetSuccessSet = DeleteFleetSuccessItem[];
export const DeleteFleetSuccessSet = S.Array(
  DeleteFleetSuccessItem.pipe(T.XmlName("item")).annotate({
    identifier: "DeleteFleetSuccessItem",
  }),
);
export type DeleteFleetErrorCode =
  | "fleetIdDoesNotExist"
  | "fleetIdMalformed"
  | "fleetNotInDeletableState"
  | "unexpectedError"
  | (string & {});
export const DeleteFleetErrorCode = S.String;
export interface DeleteFleetError {
  Code?: DeleteFleetErrorCode;
  Message?: string;
}
export const DeleteFleetError = S.suspend(() =>
  S.Struct({
    Code: S.optional(DeleteFleetErrorCode).pipe(
      T.XmlName("code"),
      T.Ec2QueryName("Code"),
    ),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "DeleteFleetError",
}) as any as S.Schema<DeleteFleetError>;
export interface DeleteFleetErrorItem {
  Error?: DeleteFleetError;
  FleetId?: string;
}
export const DeleteFleetErrorItem = S.suspend(() =>
  S.Struct({
    Error: S.optional(DeleteFleetError)
      .pipe(T.XmlName("error"), T.Ec2QueryName("Error"))
      .annotate({ identifier: "DeleteFleetError" }),
    FleetId: S.optional(S.String).pipe(
      T.XmlName("fleetId"),
      T.Ec2QueryName("FleetId"),
    ),
  }),
).annotate({
  identifier: "DeleteFleetErrorItem",
}) as any as S.Schema<DeleteFleetErrorItem>;
export type DeleteFleetErrorSet = DeleteFleetErrorItem[];
export const DeleteFleetErrorSet = S.Array(
  DeleteFleetErrorItem.pipe(T.XmlName("item")).annotate({
    identifier: "DeleteFleetErrorItem",
  }),
);
export interface DeleteFleetsResult {
  SuccessfulFleetDeletions?: DeleteFleetSuccessItem[];
  UnsuccessfulFleetDeletions?: DeleteFleetErrorItem[];
}
export const DeleteFleetsResult = S.suspend(() =>
  S.Struct({
    SuccessfulFleetDeletions: S.optional(DeleteFleetSuccessSet).pipe(
      T.XmlName("successfulFleetDeletionSet"),
      T.Ec2QueryName("SuccessfulFleetDeletionSet"),
    ),
    UnsuccessfulFleetDeletions: S.optional(DeleteFleetErrorSet).pipe(
      T.XmlName("unsuccessfulFleetDeletionSet"),
      T.Ec2QueryName("UnsuccessfulFleetDeletionSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteFleetsResult",
}) as any as S.Schema<DeleteFleetsResult>;
export type FlowLogIdList = string[];
export const FlowLogIdList = S.Array(S.String.pipe(T.XmlName("item")));
export interface DeleteFlowLogsRequest {
  DryRun?: boolean;
  FlowLogIds?: string[];
}
export const DeleteFlowLogsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    FlowLogIds: S.optional(FlowLogIdList).pipe(T.XmlName("FlowLogId")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteFlowLogsRequest",
}) as any as S.Schema<DeleteFlowLogsRequest>;
export interface DeleteFlowLogsResult {
  Unsuccessful?: UnsuccessfulItem[];
}
export const DeleteFlowLogsResult = S.suspend(() =>
  S.Struct({
    Unsuccessful: S.optional(UnsuccessfulItemSet).pipe(
      T.XmlName("unsuccessful"),
      T.Ec2QueryName("Unsuccessful"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteFlowLogsResult",
}) as any as S.Schema<DeleteFlowLogsResult>;
export interface DeleteFpgaImageRequest {
  DryRun?: boolean;
  FpgaImageId?: string;
}
export const DeleteFpgaImageRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    FpgaImageId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteFpgaImageRequest",
}) as any as S.Schema<DeleteFpgaImageRequest>;
export interface DeleteFpgaImageResult {
  Return?: boolean;
}
export const DeleteFpgaImageResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteFpgaImageResult",
}) as any as S.Schema<DeleteFpgaImageResult>;
export interface DeleteImageUsageReportRequest {
  ReportId?: string;
  DryRun?: boolean;
}
export const DeleteImageUsageReportRequest = S.suspend(() =>
  S.Struct({
    ReportId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteImageUsageReportRequest",
}) as any as S.Schema<DeleteImageUsageReportRequest>;
export interface DeleteImageUsageReportResult {
  Return?: boolean;
}
export const DeleteImageUsageReportResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteImageUsageReportResult",
}) as any as S.Schema<DeleteImageUsageReportResult>;
export interface DeleteInstanceConnectEndpointRequest {
  DryRun?: boolean;
  InstanceConnectEndpointId?: string;
}
export const DeleteInstanceConnectEndpointRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    InstanceConnectEndpointId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteInstanceConnectEndpointRequest",
}) as any as S.Schema<DeleteInstanceConnectEndpointRequest>;
export interface DeleteInstanceConnectEndpointResult {
  InstanceConnectEndpoint?: Ec2InstanceConnectEndpoint;
}
export const DeleteInstanceConnectEndpointResult = S.suspend(() =>
  S.Struct({
    InstanceConnectEndpoint: S.optional(Ec2InstanceConnectEndpoint)
      .pipe(
        T.XmlName("instanceConnectEndpoint"),
        T.Ec2QueryName("InstanceConnectEndpoint"),
      )
      .annotate({ identifier: "Ec2InstanceConnectEndpoint" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteInstanceConnectEndpointResult",
}) as any as S.Schema<DeleteInstanceConnectEndpointResult>;
export interface DeleteInstanceEventWindowRequest {
  DryRun?: boolean;
  ForceDelete?: boolean;
  InstanceEventWindowId?: string;
}
export const DeleteInstanceEventWindowRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ForceDelete: S.optional(S.Boolean),
    InstanceEventWindowId: S.optional(S.String).pipe(
      T.XmlName("InstanceEventWindowId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteInstanceEventWindowRequest",
}) as any as S.Schema<DeleteInstanceEventWindowRequest>;
export interface InstanceEventWindowStateChange {
  InstanceEventWindowId?: string;
  State?: InstanceEventWindowState;
}
export const InstanceEventWindowStateChange = S.suspend(() =>
  S.Struct({
    InstanceEventWindowId: S.optional(S.String).pipe(
      T.XmlName("instanceEventWindowId"),
      T.Ec2QueryName("InstanceEventWindowId"),
    ),
    State: S.optional(InstanceEventWindowState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({
  identifier: "InstanceEventWindowStateChange",
}) as any as S.Schema<InstanceEventWindowStateChange>;
export interface DeleteInstanceEventWindowResult {
  InstanceEventWindowState?: InstanceEventWindowStateChange;
}
export const DeleteInstanceEventWindowResult = S.suspend(() =>
  S.Struct({
    InstanceEventWindowState: S.optional(InstanceEventWindowStateChange)
      .pipe(
        T.XmlName("instanceEventWindowState"),
        T.Ec2QueryName("InstanceEventWindowState"),
      )
      .annotate({ identifier: "InstanceEventWindowStateChange" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteInstanceEventWindowResult",
}) as any as S.Schema<DeleteInstanceEventWindowResult>;
export interface DeleteInternetGatewayRequest {
  DryRun?: boolean;
  InternetGatewayId?: string;
}
export const DeleteInternetGatewayRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    InternetGatewayId: S.optional(S.String).pipe(
      T.XmlName("internetGatewayId"),
      T.Ec2QueryName("InternetGatewayId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteInternetGatewayRequest",
}) as any as S.Schema<DeleteInternetGatewayRequest>;
export interface DeleteInternetGatewayResponse {}
export const DeleteInternetGatewayResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteInternetGatewayResponse",
}) as any as S.Schema<DeleteInternetGatewayResponse>;
export interface DeleteIpamRequest {
  DryRun?: boolean;
  IpamId?: string;
  Cascade?: boolean;
}
export const DeleteIpamRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamId: S.optional(S.String),
    Cascade: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteIpamRequest",
}) as any as S.Schema<DeleteIpamRequest>;
export interface DeleteIpamResult {
  Ipam?: Ipam;
}
export const DeleteIpamResult = S.suspend(() =>
  S.Struct({
    Ipam: S.optional(Ipam)
      .pipe(T.XmlName("ipam"), T.Ec2QueryName("Ipam"))
      .annotate({ identifier: "Ipam" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteIpamResult",
}) as any as S.Schema<DeleteIpamResult>;
export interface DeleteIpamExternalResourceVerificationTokenRequest {
  DryRun?: boolean;
  IpamExternalResourceVerificationTokenId?: string;
}
export const DeleteIpamExternalResourceVerificationTokenRequest = S.suspend(
  () =>
    S.Struct({
      DryRun: S.optional(S.Boolean),
      IpamExternalResourceVerificationTokenId: S.optional(S.String),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "DeleteIpamExternalResourceVerificationTokenRequest",
}) as any as S.Schema<DeleteIpamExternalResourceVerificationTokenRequest>;
export interface DeleteIpamExternalResourceVerificationTokenResult {
  IpamExternalResourceVerificationToken?: IpamExternalResourceVerificationToken;
}
export const DeleteIpamExternalResourceVerificationTokenResult = S.suspend(() =>
  S.Struct({
    IpamExternalResourceVerificationToken: S.optional(
      IpamExternalResourceVerificationToken,
    )
      .pipe(
        T.XmlName("ipamExternalResourceVerificationToken"),
        T.Ec2QueryName("IpamExternalResourceVerificationToken"),
      )
      .annotate({ identifier: "IpamExternalResourceVerificationToken" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteIpamExternalResourceVerificationTokenResult",
}) as any as S.Schema<DeleteIpamExternalResourceVerificationTokenResult>;
export interface DeleteIpamPolicyRequest {
  DryRun?: boolean;
  IpamPolicyId?: string;
}
export const DeleteIpamPolicyRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPolicyId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteIpamPolicyRequest",
}) as any as S.Schema<DeleteIpamPolicyRequest>;
export interface DeleteIpamPolicyResult {
  IpamPolicy?: IpamPolicy;
}
export const DeleteIpamPolicyResult = S.suspend(() =>
  S.Struct({
    IpamPolicy: S.optional(IpamPolicy)
      .pipe(T.XmlName("ipamPolicy"), T.Ec2QueryName("IpamPolicy"))
      .annotate({ identifier: "IpamPolicy" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteIpamPolicyResult",
}) as any as S.Schema<DeleteIpamPolicyResult>;
export interface DeleteIpamPoolRequest {
  DryRun?: boolean;
  IpamPoolId?: string;
  Cascade?: boolean;
}
export const DeleteIpamPoolRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPoolId: S.optional(S.String),
    Cascade: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteIpamPoolRequest",
}) as any as S.Schema<DeleteIpamPoolRequest>;
export interface DeleteIpamPoolResult {
  IpamPool?: IpamPool;
}
export const DeleteIpamPoolResult = S.suspend(() =>
  S.Struct({
    IpamPool: S.optional(IpamPool)
      .pipe(T.XmlName("ipamPool"), T.Ec2QueryName("IpamPool"))
      .annotate({ identifier: "IpamPool" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteIpamPoolResult",
}) as any as S.Schema<DeleteIpamPoolResult>;
export interface DeleteIpamPrefixListResolverRequest {
  DryRun?: boolean;
  IpamPrefixListResolverId?: string;
}
export const DeleteIpamPrefixListResolverRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPrefixListResolverId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteIpamPrefixListResolverRequest",
}) as any as S.Schema<DeleteIpamPrefixListResolverRequest>;
export interface DeleteIpamPrefixListResolverResult {
  IpamPrefixListResolver?: IpamPrefixListResolver;
}
export const DeleteIpamPrefixListResolverResult = S.suspend(() =>
  S.Struct({
    IpamPrefixListResolver: S.optional(IpamPrefixListResolver)
      .pipe(
        T.XmlName("ipamPrefixListResolver"),
        T.Ec2QueryName("IpamPrefixListResolver"),
      )
      .annotate({ identifier: "IpamPrefixListResolver" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteIpamPrefixListResolverResult",
}) as any as S.Schema<DeleteIpamPrefixListResolverResult>;
export interface DeleteIpamPrefixListResolverTargetRequest {
  DryRun?: boolean;
  IpamPrefixListResolverTargetId?: string;
}
export const DeleteIpamPrefixListResolverTargetRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPrefixListResolverTargetId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteIpamPrefixListResolverTargetRequest",
}) as any as S.Schema<DeleteIpamPrefixListResolverTargetRequest>;
export interface DeleteIpamPrefixListResolverTargetResult {
  IpamPrefixListResolverTarget?: IpamPrefixListResolverTarget;
}
export const DeleteIpamPrefixListResolverTargetResult = S.suspend(() =>
  S.Struct({
    IpamPrefixListResolverTarget: S.optional(IpamPrefixListResolverTarget)
      .pipe(
        T.XmlName("ipamPrefixListResolverTarget"),
        T.Ec2QueryName("IpamPrefixListResolverTarget"),
      )
      .annotate({ identifier: "IpamPrefixListResolverTarget" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteIpamPrefixListResolverTargetResult",
}) as any as S.Schema<DeleteIpamPrefixListResolverTargetResult>;
export interface DeleteIpamResourceDiscoveryRequest {
  DryRun?: boolean;
  IpamResourceDiscoveryId?: string;
}
export const DeleteIpamResourceDiscoveryRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamResourceDiscoveryId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteIpamResourceDiscoveryRequest",
}) as any as S.Schema<DeleteIpamResourceDiscoveryRequest>;
export interface DeleteIpamResourceDiscoveryResult {
  IpamResourceDiscovery?: IpamResourceDiscovery;
}
export const DeleteIpamResourceDiscoveryResult = S.suspend(() =>
  S.Struct({
    IpamResourceDiscovery: S.optional(IpamResourceDiscovery)
      .pipe(
        T.XmlName("ipamResourceDiscovery"),
        T.Ec2QueryName("IpamResourceDiscovery"),
      )
      .annotate({ identifier: "IpamResourceDiscovery" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteIpamResourceDiscoveryResult",
}) as any as S.Schema<DeleteIpamResourceDiscoveryResult>;
export interface DeleteIpamScopeRequest {
  DryRun?: boolean;
  IpamScopeId?: string;
}
export const DeleteIpamScopeRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamScopeId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteIpamScopeRequest",
}) as any as S.Schema<DeleteIpamScopeRequest>;
export interface DeleteIpamScopeResult {
  IpamScope?: IpamScope;
}
export const DeleteIpamScopeResult = S.suspend(() =>
  S.Struct({
    IpamScope: S.optional(IpamScope)
      .pipe(T.XmlName("ipamScope"), T.Ec2QueryName("IpamScope"))
      .annotate({ identifier: "IpamScope" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteIpamScopeResult",
}) as any as S.Schema<DeleteIpamScopeResult>;
export interface DeleteKeyPairRequest {
  KeyName?: string;
  KeyPairId?: string;
  DryRun?: boolean;
}
export const DeleteKeyPairRequest = S.suspend(() =>
  S.Struct({
    KeyName: S.optional(S.String),
    KeyPairId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteKeyPairRequest",
}) as any as S.Schema<DeleteKeyPairRequest>;
export interface DeleteKeyPairResult {
  Return?: boolean;
  KeyPairId?: string;
}
export const DeleteKeyPairResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
    KeyPairId: S.optional(S.String).pipe(
      T.XmlName("keyPairId"),
      T.Ec2QueryName("KeyPairId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteKeyPairResult",
}) as any as S.Schema<DeleteKeyPairResult>;
export interface DeleteLaunchTemplateRequest {
  DryRun?: boolean;
  LaunchTemplateId?: string;
  LaunchTemplateName?: string;
}
export const DeleteLaunchTemplateRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    LaunchTemplateId: S.optional(S.String),
    LaunchTemplateName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteLaunchTemplateRequest",
}) as any as S.Schema<DeleteLaunchTemplateRequest>;
export interface DeleteLaunchTemplateResult {
  LaunchTemplate?: LaunchTemplate;
}
export const DeleteLaunchTemplateResult = S.suspend(() =>
  S.Struct({
    LaunchTemplate: S.optional(LaunchTemplate)
      .pipe(T.XmlName("launchTemplate"), T.Ec2QueryName("LaunchTemplate"))
      .annotate({ identifier: "LaunchTemplate" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteLaunchTemplateResult",
}) as any as S.Schema<DeleteLaunchTemplateResult>;
export type VersionStringList = string[];
export const VersionStringList = S.Array(S.String.pipe(T.XmlName("item")));
export interface DeleteLaunchTemplateVersionsRequest {
  DryRun?: boolean;
  LaunchTemplateId?: string;
  LaunchTemplateName?: string;
  Versions?: string[];
}
export const DeleteLaunchTemplateVersionsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    LaunchTemplateId: S.optional(S.String),
    LaunchTemplateName: S.optional(S.String),
    Versions: S.optional(VersionStringList).pipe(
      T.XmlName("LaunchTemplateVersion"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteLaunchTemplateVersionsRequest",
}) as any as S.Schema<DeleteLaunchTemplateVersionsRequest>;
export interface DeleteLaunchTemplateVersionsResponseSuccessItem {
  LaunchTemplateId?: string;
  LaunchTemplateName?: string;
  VersionNumber?: number;
}
export const DeleteLaunchTemplateVersionsResponseSuccessItem = S.suspend(() =>
  S.Struct({
    LaunchTemplateId: S.optional(S.String).pipe(
      T.XmlName("launchTemplateId"),
      T.Ec2QueryName("LaunchTemplateId"),
    ),
    LaunchTemplateName: S.optional(S.String).pipe(
      T.XmlName("launchTemplateName"),
      T.Ec2QueryName("LaunchTemplateName"),
    ),
    VersionNumber: S.optional(S.Number).pipe(
      T.XmlName("versionNumber"),
      T.Ec2QueryName("VersionNumber"),
    ),
  }),
).annotate({
  identifier: "DeleteLaunchTemplateVersionsResponseSuccessItem",
}) as any as S.Schema<DeleteLaunchTemplateVersionsResponseSuccessItem>;
export type DeleteLaunchTemplateVersionsResponseSuccessSet =
  DeleteLaunchTemplateVersionsResponseSuccessItem[];
export const DeleteLaunchTemplateVersionsResponseSuccessSet = S.Array(
  DeleteLaunchTemplateVersionsResponseSuccessItem.pipe(
    T.XmlName("item"),
  ).annotate({ identifier: "DeleteLaunchTemplateVersionsResponseSuccessItem" }),
);
export type LaunchTemplateErrorCode =
  | "launchTemplateIdDoesNotExist"
  | "launchTemplateIdMalformed"
  | "launchTemplateNameDoesNotExist"
  | "launchTemplateNameMalformed"
  | "launchTemplateVersionDoesNotExist"
  | "unexpectedError"
  | (string & {});
export const LaunchTemplateErrorCode = S.String;
export interface ResponseError {
  Code?: LaunchTemplateErrorCode;
  Message?: string;
}
export const ResponseError = S.suspend(() =>
  S.Struct({
    Code: S.optional(LaunchTemplateErrorCode).pipe(
      T.XmlName("code"),
      T.Ec2QueryName("Code"),
    ),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({ identifier: "ResponseError" }) as any as S.Schema<ResponseError>;
export interface DeleteLaunchTemplateVersionsResponseErrorItem {
  LaunchTemplateId?: string;
  LaunchTemplateName?: string;
  VersionNumber?: number;
  ResponseError?: ResponseError;
}
export const DeleteLaunchTemplateVersionsResponseErrorItem = S.suspend(() =>
  S.Struct({
    LaunchTemplateId: S.optional(S.String).pipe(
      T.XmlName("launchTemplateId"),
      T.Ec2QueryName("LaunchTemplateId"),
    ),
    LaunchTemplateName: S.optional(S.String).pipe(
      T.XmlName("launchTemplateName"),
      T.Ec2QueryName("LaunchTemplateName"),
    ),
    VersionNumber: S.optional(S.Number).pipe(
      T.XmlName("versionNumber"),
      T.Ec2QueryName("VersionNumber"),
    ),
    ResponseError: S.optional(ResponseError)
      .pipe(T.XmlName("responseError"), T.Ec2QueryName("ResponseError"))
      .annotate({ identifier: "ResponseError" }),
  }),
).annotate({
  identifier: "DeleteLaunchTemplateVersionsResponseErrorItem",
}) as any as S.Schema<DeleteLaunchTemplateVersionsResponseErrorItem>;
export type DeleteLaunchTemplateVersionsResponseErrorSet =
  DeleteLaunchTemplateVersionsResponseErrorItem[];
export const DeleteLaunchTemplateVersionsResponseErrorSet = S.Array(
  DeleteLaunchTemplateVersionsResponseErrorItem.pipe(
    T.XmlName("item"),
  ).annotate({ identifier: "DeleteLaunchTemplateVersionsResponseErrorItem" }),
);
export interface DeleteLaunchTemplateVersionsResult {
  SuccessfullyDeletedLaunchTemplateVersions?: DeleteLaunchTemplateVersionsResponseSuccessItem[];
  UnsuccessfullyDeletedLaunchTemplateVersions?: DeleteLaunchTemplateVersionsResponseErrorItem[];
}
export const DeleteLaunchTemplateVersionsResult = S.suspend(() =>
  S.Struct({
    SuccessfullyDeletedLaunchTemplateVersions: S.optional(
      DeleteLaunchTemplateVersionsResponseSuccessSet,
    ).pipe(
      T.XmlName("successfullyDeletedLaunchTemplateVersionSet"),
      T.Ec2QueryName("SuccessfullyDeletedLaunchTemplateVersionSet"),
    ),
    UnsuccessfullyDeletedLaunchTemplateVersions: S.optional(
      DeleteLaunchTemplateVersionsResponseErrorSet,
    ).pipe(
      T.XmlName("unsuccessfullyDeletedLaunchTemplateVersionSet"),
      T.Ec2QueryName("UnsuccessfullyDeletedLaunchTemplateVersionSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteLaunchTemplateVersionsResult",
}) as any as S.Schema<DeleteLaunchTemplateVersionsResult>;
export interface DeleteLocalGatewayRouteRequest {
  DestinationCidrBlock?: string;
  LocalGatewayRouteTableId?: string;
  DryRun?: boolean;
  DestinationPrefixListId?: string;
}
export const DeleteLocalGatewayRouteRequest = S.suspend(() =>
  S.Struct({
    DestinationCidrBlock: S.optional(S.String),
    LocalGatewayRouteTableId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    DestinationPrefixListId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteLocalGatewayRouteRequest",
}) as any as S.Schema<DeleteLocalGatewayRouteRequest>;
export interface DeleteLocalGatewayRouteResult {
  Route?: LocalGatewayRoute;
}
export const DeleteLocalGatewayRouteResult = S.suspend(() =>
  S.Struct({
    Route: S.optional(LocalGatewayRoute)
      .pipe(T.XmlName("route"), T.Ec2QueryName("Route"))
      .annotate({ identifier: "LocalGatewayRoute" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteLocalGatewayRouteResult",
}) as any as S.Schema<DeleteLocalGatewayRouteResult>;
export interface DeleteLocalGatewayRouteTableRequest {
  LocalGatewayRouteTableId?: string;
  DryRun?: boolean;
}
export const DeleteLocalGatewayRouteTableRequest = S.suspend(() =>
  S.Struct({
    LocalGatewayRouteTableId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteLocalGatewayRouteTableRequest",
}) as any as S.Schema<DeleteLocalGatewayRouteTableRequest>;
export interface DeleteLocalGatewayRouteTableResult {
  LocalGatewayRouteTable?: LocalGatewayRouteTable;
}
export const DeleteLocalGatewayRouteTableResult = S.suspend(() =>
  S.Struct({
    LocalGatewayRouteTable: S.optional(LocalGatewayRouteTable)
      .pipe(
        T.XmlName("localGatewayRouteTable"),
        T.Ec2QueryName("LocalGatewayRouteTable"),
      )
      .annotate({ identifier: "LocalGatewayRouteTable" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteLocalGatewayRouteTableResult",
}) as any as S.Schema<DeleteLocalGatewayRouteTableResult>;
export interface DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest {
  LocalGatewayRouteTableVirtualInterfaceGroupAssociationId?: string;
  DryRun?: boolean;
}
export const DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest =
  S.suspend(() =>
    S.Struct({
      LocalGatewayRouteTableVirtualInterfaceGroupAssociationId: S.optional(
        S.String,
      ),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
  ).annotate({
    identifier:
      "DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest",
  }) as any as S.Schema<DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest>;
export interface DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult {
  LocalGatewayRouteTableVirtualInterfaceGroupAssociation?: LocalGatewayRouteTableVirtualInterfaceGroupAssociation;
}
export const DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult =
  S.suspend(() =>
    S.Struct({
      LocalGatewayRouteTableVirtualInterfaceGroupAssociation: S.optional(
        LocalGatewayRouteTableVirtualInterfaceGroupAssociation,
      )
        .pipe(
          T.XmlName("localGatewayRouteTableVirtualInterfaceGroupAssociation"),
          T.Ec2QueryName(
            "LocalGatewayRouteTableVirtualInterfaceGroupAssociation",
          ),
        )
        .annotate({
          identifier: "LocalGatewayRouteTableVirtualInterfaceGroupAssociation",
        }),
    }).pipe(ns),
  ).annotate({
    identifier:
      "DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult",
  }) as any as S.Schema<DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult>;
export interface DeleteLocalGatewayRouteTableVpcAssociationRequest {
  LocalGatewayRouteTableVpcAssociationId?: string;
  DryRun?: boolean;
}
export const DeleteLocalGatewayRouteTableVpcAssociationRequest = S.suspend(() =>
  S.Struct({
    LocalGatewayRouteTableVpcAssociationId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteLocalGatewayRouteTableVpcAssociationRequest",
}) as any as S.Schema<DeleteLocalGatewayRouteTableVpcAssociationRequest>;
export interface DeleteLocalGatewayRouteTableVpcAssociationResult {
  LocalGatewayRouteTableVpcAssociation?: LocalGatewayRouteTableVpcAssociation;
}
export const DeleteLocalGatewayRouteTableVpcAssociationResult = S.suspend(() =>
  S.Struct({
    LocalGatewayRouteTableVpcAssociation: S.optional(
      LocalGatewayRouteTableVpcAssociation,
    )
      .pipe(
        T.XmlName("localGatewayRouteTableVpcAssociation"),
        T.Ec2QueryName("LocalGatewayRouteTableVpcAssociation"),
      )
      .annotate({ identifier: "LocalGatewayRouteTableVpcAssociation" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteLocalGatewayRouteTableVpcAssociationResult",
}) as any as S.Schema<DeleteLocalGatewayRouteTableVpcAssociationResult>;
export interface DeleteLocalGatewayVirtualInterfaceRequest {
  LocalGatewayVirtualInterfaceId?: string;
  DryRun?: boolean;
}
export const DeleteLocalGatewayVirtualInterfaceRequest = S.suspend(() =>
  S.Struct({
    LocalGatewayVirtualInterfaceId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteLocalGatewayVirtualInterfaceRequest",
}) as any as S.Schema<DeleteLocalGatewayVirtualInterfaceRequest>;
export interface DeleteLocalGatewayVirtualInterfaceResult {
  LocalGatewayVirtualInterface?: LocalGatewayVirtualInterface;
}
export const DeleteLocalGatewayVirtualInterfaceResult = S.suspend(() =>
  S.Struct({
    LocalGatewayVirtualInterface: S.optional(LocalGatewayVirtualInterface)
      .pipe(
        T.XmlName("localGatewayVirtualInterface"),
        T.Ec2QueryName("LocalGatewayVirtualInterface"),
      )
      .annotate({ identifier: "LocalGatewayVirtualInterface" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteLocalGatewayVirtualInterfaceResult",
}) as any as S.Schema<DeleteLocalGatewayVirtualInterfaceResult>;
export interface DeleteLocalGatewayVirtualInterfaceGroupRequest {
  LocalGatewayVirtualInterfaceGroupId?: string;
  DryRun?: boolean;
}
export const DeleteLocalGatewayVirtualInterfaceGroupRequest = S.suspend(() =>
  S.Struct({
    LocalGatewayVirtualInterfaceGroupId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteLocalGatewayVirtualInterfaceGroupRequest",
}) as any as S.Schema<DeleteLocalGatewayVirtualInterfaceGroupRequest>;
export interface DeleteLocalGatewayVirtualInterfaceGroupResult {
  LocalGatewayVirtualInterfaceGroup?: LocalGatewayVirtualInterfaceGroup;
}
export const DeleteLocalGatewayVirtualInterfaceGroupResult = S.suspend(() =>
  S.Struct({
    LocalGatewayVirtualInterfaceGroup: S.optional(
      LocalGatewayVirtualInterfaceGroup,
    )
      .pipe(
        T.XmlName("localGatewayVirtualInterfaceGroup"),
        T.Ec2QueryName("LocalGatewayVirtualInterfaceGroup"),
      )
      .annotate({ identifier: "LocalGatewayVirtualInterfaceGroup" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteLocalGatewayVirtualInterfaceGroupResult",
}) as any as S.Schema<DeleteLocalGatewayVirtualInterfaceGroupResult>;
export interface DeleteManagedPrefixListRequest {
  DryRun?: boolean;
  PrefixListId?: string;
}
export const DeleteManagedPrefixListRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    PrefixListId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteManagedPrefixListRequest",
}) as any as S.Schema<DeleteManagedPrefixListRequest>;
export interface DeleteManagedPrefixListResult {
  PrefixList?: ManagedPrefixList;
}
export const DeleteManagedPrefixListResult = S.suspend(() =>
  S.Struct({
    PrefixList: S.optional(ManagedPrefixList)
      .pipe(T.XmlName("prefixList"), T.Ec2QueryName("PrefixList"))
      .annotate({ identifier: "ManagedPrefixList" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteManagedPrefixListResult",
}) as any as S.Schema<DeleteManagedPrefixListResult>;
export interface DeleteNatGatewayRequest {
  DryRun?: boolean;
  NatGatewayId?: string;
}
export const DeleteNatGatewayRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    NatGatewayId: S.optional(S.String).pipe(T.XmlName("NatGatewayId")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteNatGatewayRequest",
}) as any as S.Schema<DeleteNatGatewayRequest>;
export interface DeleteNatGatewayResult {
  NatGatewayId?: string;
}
export const DeleteNatGatewayResult = S.suspend(() =>
  S.Struct({
    NatGatewayId: S.optional(S.String).pipe(
      T.XmlName("natGatewayId"),
      T.Ec2QueryName("NatGatewayId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteNatGatewayResult",
}) as any as S.Schema<DeleteNatGatewayResult>;
export interface DeleteNetworkAclRequest {
  DryRun?: boolean;
  NetworkAclId?: string;
}
export const DeleteNetworkAclRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    NetworkAclId: S.optional(S.String).pipe(
      T.XmlName("networkAclId"),
      T.Ec2QueryName("NetworkAclId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteNetworkAclRequest",
}) as any as S.Schema<DeleteNetworkAclRequest>;
export interface DeleteNetworkAclResponse {}
export const DeleteNetworkAclResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteNetworkAclResponse",
}) as any as S.Schema<DeleteNetworkAclResponse>;
export interface DeleteNetworkAclEntryRequest {
  DryRun?: boolean;
  NetworkAclId?: string;
  RuleNumber?: number;
  Egress?: boolean;
}
export const DeleteNetworkAclEntryRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    NetworkAclId: S.optional(S.String).pipe(
      T.XmlName("networkAclId"),
      T.Ec2QueryName("NetworkAclId"),
    ),
    RuleNumber: S.optional(S.Number).pipe(
      T.XmlName("ruleNumber"),
      T.Ec2QueryName("RuleNumber"),
    ),
    Egress: S.optional(S.Boolean).pipe(
      T.XmlName("egress"),
      T.Ec2QueryName("Egress"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteNetworkAclEntryRequest",
}) as any as S.Schema<DeleteNetworkAclEntryRequest>;
export interface DeleteNetworkAclEntryResponse {}
export const DeleteNetworkAclEntryResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteNetworkAclEntryResponse",
}) as any as S.Schema<DeleteNetworkAclEntryResponse>;
export interface DeleteNetworkInsightsAccessScopeRequest {
  DryRun?: boolean;
  NetworkInsightsAccessScopeId?: string;
}
export const DeleteNetworkInsightsAccessScopeRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    NetworkInsightsAccessScopeId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteNetworkInsightsAccessScopeRequest",
}) as any as S.Schema<DeleteNetworkInsightsAccessScopeRequest>;
export interface DeleteNetworkInsightsAccessScopeResult {
  NetworkInsightsAccessScopeId?: string;
}
export const DeleteNetworkInsightsAccessScopeResult = S.suspend(() =>
  S.Struct({
    NetworkInsightsAccessScopeId: S.optional(S.String).pipe(
      T.XmlName("networkInsightsAccessScopeId"),
      T.Ec2QueryName("NetworkInsightsAccessScopeId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteNetworkInsightsAccessScopeResult",
}) as any as S.Schema<DeleteNetworkInsightsAccessScopeResult>;
export interface DeleteNetworkInsightsAccessScopeAnalysisRequest {
  NetworkInsightsAccessScopeAnalysisId?: string;
  DryRun?: boolean;
}
export const DeleteNetworkInsightsAccessScopeAnalysisRequest = S.suspend(() =>
  S.Struct({
    NetworkInsightsAccessScopeAnalysisId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteNetworkInsightsAccessScopeAnalysisRequest",
}) as any as S.Schema<DeleteNetworkInsightsAccessScopeAnalysisRequest>;
export interface DeleteNetworkInsightsAccessScopeAnalysisResult {
  NetworkInsightsAccessScopeAnalysisId?: string;
}
export const DeleteNetworkInsightsAccessScopeAnalysisResult = S.suspend(() =>
  S.Struct({
    NetworkInsightsAccessScopeAnalysisId: S.optional(S.String).pipe(
      T.XmlName("networkInsightsAccessScopeAnalysisId"),
      T.Ec2QueryName("NetworkInsightsAccessScopeAnalysisId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteNetworkInsightsAccessScopeAnalysisResult",
}) as any as S.Schema<DeleteNetworkInsightsAccessScopeAnalysisResult>;
export interface DeleteNetworkInsightsAnalysisRequest {
  DryRun?: boolean;
  NetworkInsightsAnalysisId?: string;
}
export const DeleteNetworkInsightsAnalysisRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    NetworkInsightsAnalysisId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteNetworkInsightsAnalysisRequest",
}) as any as S.Schema<DeleteNetworkInsightsAnalysisRequest>;
export interface DeleteNetworkInsightsAnalysisResult {
  NetworkInsightsAnalysisId?: string;
}
export const DeleteNetworkInsightsAnalysisResult = S.suspend(() =>
  S.Struct({
    NetworkInsightsAnalysisId: S.optional(S.String).pipe(
      T.XmlName("networkInsightsAnalysisId"),
      T.Ec2QueryName("NetworkInsightsAnalysisId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteNetworkInsightsAnalysisResult",
}) as any as S.Schema<DeleteNetworkInsightsAnalysisResult>;
export interface DeleteNetworkInsightsPathRequest {
  DryRun?: boolean;
  NetworkInsightsPathId?: string;
}
export const DeleteNetworkInsightsPathRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    NetworkInsightsPathId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteNetworkInsightsPathRequest",
}) as any as S.Schema<DeleteNetworkInsightsPathRequest>;
export interface DeleteNetworkInsightsPathResult {
  NetworkInsightsPathId?: string;
}
export const DeleteNetworkInsightsPathResult = S.suspend(() =>
  S.Struct({
    NetworkInsightsPathId: S.optional(S.String).pipe(
      T.XmlName("networkInsightsPathId"),
      T.Ec2QueryName("NetworkInsightsPathId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteNetworkInsightsPathResult",
}) as any as S.Schema<DeleteNetworkInsightsPathResult>;
export interface DeleteNetworkInterfaceRequest {
  DryRun?: boolean;
  NetworkInterfaceId?: string;
}
export const DeleteNetworkInterfaceRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteNetworkInterfaceRequest",
}) as any as S.Schema<DeleteNetworkInterfaceRequest>;
export interface DeleteNetworkInterfaceResponse {}
export const DeleteNetworkInterfaceResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteNetworkInterfaceResponse",
}) as any as S.Schema<DeleteNetworkInterfaceResponse>;
export interface DeleteNetworkInterfacePermissionRequest {
  NetworkInterfacePermissionId?: string;
  Force?: boolean;
  DryRun?: boolean;
}
export const DeleteNetworkInterfacePermissionRequest = S.suspend(() =>
  S.Struct({
    NetworkInterfacePermissionId: S.optional(S.String),
    Force: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteNetworkInterfacePermissionRequest",
}) as any as S.Schema<DeleteNetworkInterfacePermissionRequest>;
export interface DeleteNetworkInterfacePermissionResult {
  Return?: boolean;
}
export const DeleteNetworkInterfacePermissionResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteNetworkInterfacePermissionResult",
}) as any as S.Schema<DeleteNetworkInterfacePermissionResult>;
export interface DeletePlacementGroupRequest {
  DryRun?: boolean;
  GroupName?: string;
}
export const DeletePlacementGroupRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    GroupName: S.optional(S.String).pipe(
      T.XmlName("groupName"),
      T.Ec2QueryName("GroupName"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeletePlacementGroupRequest",
}) as any as S.Schema<DeletePlacementGroupRequest>;
export interface DeletePlacementGroupResponse {}
export const DeletePlacementGroupResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeletePlacementGroupResponse",
}) as any as S.Schema<DeletePlacementGroupResponse>;
export interface DeletePublicIpv4PoolRequest {
  DryRun?: boolean;
  PoolId?: string;
  NetworkBorderGroup?: string;
}
export const DeletePublicIpv4PoolRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    PoolId: S.optional(S.String),
    NetworkBorderGroup: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeletePublicIpv4PoolRequest",
}) as any as S.Schema<DeletePublicIpv4PoolRequest>;
export interface DeletePublicIpv4PoolResult {
  ReturnValue?: boolean;
}
export const DeletePublicIpv4PoolResult = S.suspend(() =>
  S.Struct({
    ReturnValue: S.optional(S.Boolean).pipe(
      T.XmlName("returnValue"),
      T.Ec2QueryName("ReturnValue"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeletePublicIpv4PoolResult",
}) as any as S.Schema<DeletePublicIpv4PoolResult>;
export type DeleteQueuedReservedInstancesIdList = string[];
export const DeleteQueuedReservedInstancesIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DeleteQueuedReservedInstancesRequest {
  DryRun?: boolean;
  ReservedInstancesIds?: string[];
}
export const DeleteQueuedReservedInstancesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ReservedInstancesIds: S.optional(DeleteQueuedReservedInstancesIdList).pipe(
      T.XmlName("ReservedInstancesId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteQueuedReservedInstancesRequest",
}) as any as S.Schema<DeleteQueuedReservedInstancesRequest>;
export interface SuccessfulQueuedPurchaseDeletion {
  ReservedInstancesId?: string;
}
export const SuccessfulQueuedPurchaseDeletion = S.suspend(() =>
  S.Struct({
    ReservedInstancesId: S.optional(S.String).pipe(
      T.XmlName("reservedInstancesId"),
      T.Ec2QueryName("ReservedInstancesId"),
    ),
  }),
).annotate({
  identifier: "SuccessfulQueuedPurchaseDeletion",
}) as any as S.Schema<SuccessfulQueuedPurchaseDeletion>;
export type SuccessfulQueuedPurchaseDeletionSet =
  SuccessfulQueuedPurchaseDeletion[];
export const SuccessfulQueuedPurchaseDeletionSet = S.Array(
  SuccessfulQueuedPurchaseDeletion.pipe(T.XmlName("item")).annotate({
    identifier: "SuccessfulQueuedPurchaseDeletion",
  }),
);
export type DeleteQueuedReservedInstancesErrorCode =
  | "reserved-instances-id-invalid"
  | "reserved-instances-not-in-queued-state"
  | "unexpected-error"
  | (string & {});
export const DeleteQueuedReservedInstancesErrorCode = S.String;
export interface DeleteQueuedReservedInstancesError_ {
  Code?: DeleteQueuedReservedInstancesErrorCode;
  Message?: string;
}
export const DeleteQueuedReservedInstancesError_ = S.suspend(() =>
  S.Struct({
    Code: S.optional(DeleteQueuedReservedInstancesErrorCode).pipe(
      T.XmlName("code"),
      T.Ec2QueryName("Code"),
    ),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "DeleteQueuedReservedInstancesError",
}) as any as S.Schema<DeleteQueuedReservedInstancesError_>;
export interface FailedQueuedPurchaseDeletion {
  Error?: DeleteQueuedReservedInstancesError_;
  ReservedInstancesId?: string;
}
export const FailedQueuedPurchaseDeletion = S.suspend(() =>
  S.Struct({
    Error: S.optional(DeleteQueuedReservedInstancesError_)
      .pipe(T.XmlName("error"), T.Ec2QueryName("Error"))
      .annotate({ identifier: "DeleteQueuedReservedInstancesError" }),
    ReservedInstancesId: S.optional(S.String).pipe(
      T.XmlName("reservedInstancesId"),
      T.Ec2QueryName("ReservedInstancesId"),
    ),
  }),
).annotate({
  identifier: "FailedQueuedPurchaseDeletion",
}) as any as S.Schema<FailedQueuedPurchaseDeletion>;
export type FailedQueuedPurchaseDeletionSet = FailedQueuedPurchaseDeletion[];
export const FailedQueuedPurchaseDeletionSet = S.Array(
  FailedQueuedPurchaseDeletion.pipe(T.XmlName("item")).annotate({
    identifier: "FailedQueuedPurchaseDeletion",
  }),
);
export interface DeleteQueuedReservedInstancesResult {
  SuccessfulQueuedPurchaseDeletions?: SuccessfulQueuedPurchaseDeletion[];
  FailedQueuedPurchaseDeletions?: FailedQueuedPurchaseDeletion[];
}
export const DeleteQueuedReservedInstancesResult = S.suspend(() =>
  S.Struct({
    SuccessfulQueuedPurchaseDeletions: S.optional(
      SuccessfulQueuedPurchaseDeletionSet,
    ).pipe(
      T.XmlName("successfulQueuedPurchaseDeletionSet"),
      T.Ec2QueryName("SuccessfulQueuedPurchaseDeletionSet"),
    ),
    FailedQueuedPurchaseDeletions: S.optional(
      FailedQueuedPurchaseDeletionSet,
    ).pipe(
      T.XmlName("failedQueuedPurchaseDeletionSet"),
      T.Ec2QueryName("FailedQueuedPurchaseDeletionSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteQueuedReservedInstancesResult",
}) as any as S.Schema<DeleteQueuedReservedInstancesResult>;
export interface DeleteRouteRequest {
  DestinationPrefixListId?: string;
  DryRun?: boolean;
  RouteTableId?: string;
  DestinationCidrBlock?: string;
  DestinationIpv6CidrBlock?: string;
}
export const DeleteRouteRequest = S.suspend(() =>
  S.Struct({
    DestinationPrefixListId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    RouteTableId: S.optional(S.String).pipe(
      T.XmlName("routeTableId"),
      T.Ec2QueryName("RouteTableId"),
    ),
    DestinationCidrBlock: S.optional(S.String).pipe(
      T.XmlName("destinationCidrBlock"),
      T.Ec2QueryName("DestinationCidrBlock"),
    ),
    DestinationIpv6CidrBlock: S.optional(S.String).pipe(
      T.XmlName("destinationIpv6CidrBlock"),
      T.Ec2QueryName("DestinationIpv6CidrBlock"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteRouteRequest",
}) as any as S.Schema<DeleteRouteRequest>;
export interface DeleteRouteResponse {}
export const DeleteRouteResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteRouteResponse",
}) as any as S.Schema<DeleteRouteResponse>;
export interface DeleteRouteServerRequest {
  RouteServerId?: string;
  DryRun?: boolean;
}
export const DeleteRouteServerRequest = S.suspend(() =>
  S.Struct({
    RouteServerId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteRouteServerRequest",
}) as any as S.Schema<DeleteRouteServerRequest>;
export interface DeleteRouteServerResult {
  RouteServer?: RouteServer;
}
export const DeleteRouteServerResult = S.suspend(() =>
  S.Struct({
    RouteServer: S.optional(RouteServer)
      .pipe(T.XmlName("routeServer"), T.Ec2QueryName("RouteServer"))
      .annotate({ identifier: "RouteServer" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteRouteServerResult",
}) as any as S.Schema<DeleteRouteServerResult>;
export interface DeleteRouteServerEndpointRequest {
  RouteServerEndpointId?: string;
  DryRun?: boolean;
}
export const DeleteRouteServerEndpointRequest = S.suspend(() =>
  S.Struct({
    RouteServerEndpointId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteRouteServerEndpointRequest",
}) as any as S.Schema<DeleteRouteServerEndpointRequest>;
export interface DeleteRouteServerEndpointResult {
  RouteServerEndpoint?: RouteServerEndpoint;
}
export const DeleteRouteServerEndpointResult = S.suspend(() =>
  S.Struct({
    RouteServerEndpoint: S.optional(RouteServerEndpoint)
      .pipe(
        T.XmlName("routeServerEndpoint"),
        T.Ec2QueryName("RouteServerEndpoint"),
      )
      .annotate({ identifier: "RouteServerEndpoint" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteRouteServerEndpointResult",
}) as any as S.Schema<DeleteRouteServerEndpointResult>;
export interface DeleteRouteServerPeerRequest {
  RouteServerPeerId?: string;
  DryRun?: boolean;
}
export const DeleteRouteServerPeerRequest = S.suspend(() =>
  S.Struct({
    RouteServerPeerId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteRouteServerPeerRequest",
}) as any as S.Schema<DeleteRouteServerPeerRequest>;
export interface DeleteRouteServerPeerResult {
  RouteServerPeer?: RouteServerPeer;
}
export const DeleteRouteServerPeerResult = S.suspend(() =>
  S.Struct({
    RouteServerPeer: S.optional(RouteServerPeer)
      .pipe(T.XmlName("routeServerPeer"), T.Ec2QueryName("RouteServerPeer"))
      .annotate({ identifier: "RouteServerPeer" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteRouteServerPeerResult",
}) as any as S.Schema<DeleteRouteServerPeerResult>;
export interface DeleteRouteTableRequest {
  DryRun?: boolean;
  RouteTableId?: string;
}
export const DeleteRouteTableRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    RouteTableId: S.optional(S.String).pipe(
      T.XmlName("routeTableId"),
      T.Ec2QueryName("RouteTableId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteRouteTableRequest",
}) as any as S.Schema<DeleteRouteTableRequest>;
export interface DeleteRouteTableResponse {}
export const DeleteRouteTableResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteRouteTableResponse",
}) as any as S.Schema<DeleteRouteTableResponse>;
export interface DeleteSecondaryNetworkRequest {
  ClientToken?: string;
  DryRun?: boolean;
  SecondaryNetworkId?: string;
}
export const DeleteSecondaryNetworkRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
    SecondaryNetworkId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteSecondaryNetworkRequest",
}) as any as S.Schema<DeleteSecondaryNetworkRequest>;
export interface DeleteSecondaryNetworkResult {
  SecondaryNetwork?: SecondaryNetwork;
  ClientToken?: string;
}
export const DeleteSecondaryNetworkResult = S.suspend(() =>
  S.Struct({
    SecondaryNetwork: S.optional(SecondaryNetwork)
      .pipe(T.XmlName("secondaryNetwork"), T.Ec2QueryName("SecondaryNetwork"))
      .annotate({ identifier: "SecondaryNetwork" }),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteSecondaryNetworkResult",
}) as any as S.Schema<DeleteSecondaryNetworkResult>;
export interface DeleteSecondarySubnetRequest {
  ClientToken?: string;
  DryRun?: boolean;
  SecondarySubnetId?: string;
}
export const DeleteSecondarySubnetRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
    SecondarySubnetId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteSecondarySubnetRequest",
}) as any as S.Schema<DeleteSecondarySubnetRequest>;
export interface DeleteSecondarySubnetResult {
  SecondarySubnet?: SecondarySubnet;
  ClientToken?: string;
}
export const DeleteSecondarySubnetResult = S.suspend(() =>
  S.Struct({
    SecondarySubnet: S.optional(SecondarySubnet)
      .pipe(T.XmlName("secondarySubnet"), T.Ec2QueryName("SecondarySubnet"))
      .annotate({ identifier: "SecondarySubnet" }),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteSecondarySubnetResult",
}) as any as S.Schema<DeleteSecondarySubnetResult>;
export interface DeleteSecurityGroupRequest {
  GroupId?: string;
  GroupName?: string;
  DryRun?: boolean;
}
export const DeleteSecurityGroupRequest = S.suspend(() =>
  S.Struct({
    GroupId: S.optional(S.String),
    GroupName: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteSecurityGroupRequest",
}) as any as S.Schema<DeleteSecurityGroupRequest>;
export interface DeleteSecurityGroupResult {
  Return?: boolean;
  GroupId?: string;
}
export const DeleteSecurityGroupResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteSecurityGroupResult",
}) as any as S.Schema<DeleteSecurityGroupResult>;
export interface DeleteSnapshotRequest {
  SnapshotId?: string;
  DryRun?: boolean;
}
export const DeleteSnapshotRequest = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteSnapshotRequest",
}) as any as S.Schema<DeleteSnapshotRequest>;
export interface DeleteSnapshotResponse {}
export const DeleteSnapshotResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteSnapshotResponse",
}) as any as S.Schema<DeleteSnapshotResponse>;
export interface DeleteSpotDatafeedSubscriptionRequest {
  DryRun?: boolean;
}
export const DeleteSpotDatafeedSubscriptionRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteSpotDatafeedSubscriptionRequest",
}) as any as S.Schema<DeleteSpotDatafeedSubscriptionRequest>;
export interface DeleteSpotDatafeedSubscriptionResponse {}
export const DeleteSpotDatafeedSubscriptionResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteSpotDatafeedSubscriptionResponse",
}) as any as S.Schema<DeleteSpotDatafeedSubscriptionResponse>;
export interface DeleteSubnetRequest {
  SubnetId?: string;
  DryRun?: boolean;
}
export const DeleteSubnetRequest = S.suspend(() =>
  S.Struct({
    SubnetId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteSubnetRequest",
}) as any as S.Schema<DeleteSubnetRequest>;
export interface DeleteSubnetResponse {}
export const DeleteSubnetResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteSubnetResponse",
}) as any as S.Schema<DeleteSubnetResponse>;
export interface DeleteSubnetCidrReservationRequest {
  SubnetCidrReservationId?: string;
  DryRun?: boolean;
}
export const DeleteSubnetCidrReservationRequest = S.suspend(() =>
  S.Struct({
    SubnetCidrReservationId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteSubnetCidrReservationRequest",
}) as any as S.Schema<DeleteSubnetCidrReservationRequest>;
export interface DeleteSubnetCidrReservationResult {
  DeletedSubnetCidrReservation?: SubnetCidrReservation;
}
export const DeleteSubnetCidrReservationResult = S.suspend(() =>
  S.Struct({
    DeletedSubnetCidrReservation: S.optional(SubnetCidrReservation)
      .pipe(
        T.XmlName("deletedSubnetCidrReservation"),
        T.Ec2QueryName("DeletedSubnetCidrReservation"),
      )
      .annotate({ identifier: "SubnetCidrReservation" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteSubnetCidrReservationResult",
}) as any as S.Schema<DeleteSubnetCidrReservationResult>;
export interface DeleteTagsRequest {
  DryRun?: boolean;
  Resources?: string[];
  Tags?: Tag[];
}
export const DeleteTagsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Resources: S.optional(ResourceIdList).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    Tags: S.optional(TagList).pipe(T.XmlName("tag"), T.Ec2QueryName("Tag")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTagsRequest",
}) as any as S.Schema<DeleteTagsRequest>;
export interface DeleteTagsResponse {}
export const DeleteTagsResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteTagsResponse",
}) as any as S.Schema<DeleteTagsResponse>;
export interface DeleteTrafficMirrorFilterRequest {
  TrafficMirrorFilterId?: string;
  DryRun?: boolean;
}
export const DeleteTrafficMirrorFilterRequest = S.suspend(() =>
  S.Struct({
    TrafficMirrorFilterId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTrafficMirrorFilterRequest",
}) as any as S.Schema<DeleteTrafficMirrorFilterRequest>;
export interface DeleteTrafficMirrorFilterResult {
  TrafficMirrorFilterId?: string;
}
export const DeleteTrafficMirrorFilterResult = S.suspend(() =>
  S.Struct({
    TrafficMirrorFilterId: S.optional(S.String).pipe(
      T.XmlName("trafficMirrorFilterId"),
      T.Ec2QueryName("TrafficMirrorFilterId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteTrafficMirrorFilterResult",
}) as any as S.Schema<DeleteTrafficMirrorFilterResult>;
export interface DeleteTrafficMirrorFilterRuleRequest {
  TrafficMirrorFilterRuleId?: string;
  DryRun?: boolean;
}
export const DeleteTrafficMirrorFilterRuleRequest = S.suspend(() =>
  S.Struct({
    TrafficMirrorFilterRuleId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTrafficMirrorFilterRuleRequest",
}) as any as S.Schema<DeleteTrafficMirrorFilterRuleRequest>;
export interface DeleteTrafficMirrorFilterRuleResult {
  TrafficMirrorFilterRuleId?: string;
}
export const DeleteTrafficMirrorFilterRuleResult = S.suspend(() =>
  S.Struct({
    TrafficMirrorFilterRuleId: S.optional(S.String).pipe(
      T.XmlName("trafficMirrorFilterRuleId"),
      T.Ec2QueryName("TrafficMirrorFilterRuleId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteTrafficMirrorFilterRuleResult",
}) as any as S.Schema<DeleteTrafficMirrorFilterRuleResult>;
export interface DeleteTrafficMirrorSessionRequest {
  TrafficMirrorSessionId?: string;
  DryRun?: boolean;
}
export const DeleteTrafficMirrorSessionRequest = S.suspend(() =>
  S.Struct({
    TrafficMirrorSessionId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTrafficMirrorSessionRequest",
}) as any as S.Schema<DeleteTrafficMirrorSessionRequest>;
export interface DeleteTrafficMirrorSessionResult {
  TrafficMirrorSessionId?: string;
}
export const DeleteTrafficMirrorSessionResult = S.suspend(() =>
  S.Struct({
    TrafficMirrorSessionId: S.optional(S.String).pipe(
      T.XmlName("trafficMirrorSessionId"),
      T.Ec2QueryName("TrafficMirrorSessionId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteTrafficMirrorSessionResult",
}) as any as S.Schema<DeleteTrafficMirrorSessionResult>;
export interface DeleteTrafficMirrorTargetRequest {
  TrafficMirrorTargetId?: string;
  DryRun?: boolean;
}
export const DeleteTrafficMirrorTargetRequest = S.suspend(() =>
  S.Struct({
    TrafficMirrorTargetId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTrafficMirrorTargetRequest",
}) as any as S.Schema<DeleteTrafficMirrorTargetRequest>;
export interface DeleteTrafficMirrorTargetResult {
  TrafficMirrorTargetId?: string;
}
export const DeleteTrafficMirrorTargetResult = S.suspend(() =>
  S.Struct({
    TrafficMirrorTargetId: S.optional(S.String).pipe(
      T.XmlName("trafficMirrorTargetId"),
      T.Ec2QueryName("TrafficMirrorTargetId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteTrafficMirrorTargetResult",
}) as any as S.Schema<DeleteTrafficMirrorTargetResult>;
export interface DeleteTransitGatewayRequest {
  TransitGatewayId?: string;
  DryRun?: boolean;
}
export const DeleteTransitGatewayRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTransitGatewayRequest",
}) as any as S.Schema<DeleteTransitGatewayRequest>;
export interface DeleteTransitGatewayResult {
  TransitGateway?: TransitGateway;
}
export const DeleteTransitGatewayResult = S.suspend(() =>
  S.Struct({
    TransitGateway: S.optional(TransitGateway)
      .pipe(T.XmlName("transitGateway"), T.Ec2QueryName("TransitGateway"))
      .annotate({ identifier: "TransitGateway" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteTransitGatewayResult",
}) as any as S.Schema<DeleteTransitGatewayResult>;
export interface DeleteTransitGatewayConnectRequest {
  TransitGatewayAttachmentId?: string;
  DryRun?: boolean;
}
export const DeleteTransitGatewayConnectRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTransitGatewayConnectRequest",
}) as any as S.Schema<DeleteTransitGatewayConnectRequest>;
export interface DeleteTransitGatewayConnectResult {
  TransitGatewayConnect?: TransitGatewayConnect;
}
export const DeleteTransitGatewayConnectResult = S.suspend(() =>
  S.Struct({
    TransitGatewayConnect: S.optional(TransitGatewayConnect)
      .pipe(
        T.XmlName("transitGatewayConnect"),
        T.Ec2QueryName("TransitGatewayConnect"),
      )
      .annotate({ identifier: "TransitGatewayConnect" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteTransitGatewayConnectResult",
}) as any as S.Schema<DeleteTransitGatewayConnectResult>;
export interface DeleteTransitGatewayConnectPeerRequest {
  TransitGatewayConnectPeerId?: string;
  DryRun?: boolean;
}
export const DeleteTransitGatewayConnectPeerRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayConnectPeerId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTransitGatewayConnectPeerRequest",
}) as any as S.Schema<DeleteTransitGatewayConnectPeerRequest>;
export interface DeleteTransitGatewayConnectPeerResult {
  TransitGatewayConnectPeer?: TransitGatewayConnectPeer;
}
export const DeleteTransitGatewayConnectPeerResult = S.suspend(() =>
  S.Struct({
    TransitGatewayConnectPeer: S.optional(TransitGatewayConnectPeer)
      .pipe(
        T.XmlName("transitGatewayConnectPeer"),
        T.Ec2QueryName("TransitGatewayConnectPeer"),
      )
      .annotate({ identifier: "TransitGatewayConnectPeer" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteTransitGatewayConnectPeerResult",
}) as any as S.Schema<DeleteTransitGatewayConnectPeerResult>;
export interface DeleteTransitGatewayMeteringPolicyRequest {
  TransitGatewayMeteringPolicyId?: string;
  DryRun?: boolean;
}
export const DeleteTransitGatewayMeteringPolicyRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayMeteringPolicyId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTransitGatewayMeteringPolicyRequest",
}) as any as S.Schema<DeleteTransitGatewayMeteringPolicyRequest>;
export interface DeleteTransitGatewayMeteringPolicyResult {
  TransitGatewayMeteringPolicy?: TransitGatewayMeteringPolicy;
}
export const DeleteTransitGatewayMeteringPolicyResult = S.suspend(() =>
  S.Struct({
    TransitGatewayMeteringPolicy: S.optional(TransitGatewayMeteringPolicy)
      .pipe(
        T.XmlName("transitGatewayMeteringPolicy"),
        T.Ec2QueryName("TransitGatewayMeteringPolicy"),
      )
      .annotate({ identifier: "TransitGatewayMeteringPolicy" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteTransitGatewayMeteringPolicyResult",
}) as any as S.Schema<DeleteTransitGatewayMeteringPolicyResult>;
export interface DeleteTransitGatewayMeteringPolicyEntryRequest {
  TransitGatewayMeteringPolicyId?: string;
  PolicyRuleNumber?: number;
  DryRun?: boolean;
}
export const DeleteTransitGatewayMeteringPolicyEntryRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayMeteringPolicyId: S.optional(S.String),
    PolicyRuleNumber: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTransitGatewayMeteringPolicyEntryRequest",
}) as any as S.Schema<DeleteTransitGatewayMeteringPolicyEntryRequest>;
export interface DeleteTransitGatewayMeteringPolicyEntryResult {
  TransitGatewayMeteringPolicyEntry?: TransitGatewayMeteringPolicyEntry;
}
export const DeleteTransitGatewayMeteringPolicyEntryResult = S.suspend(() =>
  S.Struct({
    TransitGatewayMeteringPolicyEntry: S.optional(
      TransitGatewayMeteringPolicyEntry,
    )
      .pipe(
        T.XmlName("transitGatewayMeteringPolicyEntry"),
        T.Ec2QueryName("TransitGatewayMeteringPolicyEntry"),
      )
      .annotate({ identifier: "TransitGatewayMeteringPolicyEntry" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteTransitGatewayMeteringPolicyEntryResult",
}) as any as S.Schema<DeleteTransitGatewayMeteringPolicyEntryResult>;
export interface DeleteTransitGatewayMulticastDomainRequest {
  TransitGatewayMulticastDomainId?: string;
  DryRun?: boolean;
}
export const DeleteTransitGatewayMulticastDomainRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayMulticastDomainId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTransitGatewayMulticastDomainRequest",
}) as any as S.Schema<DeleteTransitGatewayMulticastDomainRequest>;
export interface DeleteTransitGatewayMulticastDomainResult {
  TransitGatewayMulticastDomain?: TransitGatewayMulticastDomain;
}
export const DeleteTransitGatewayMulticastDomainResult = S.suspend(() =>
  S.Struct({
    TransitGatewayMulticastDomain: S.optional(TransitGatewayMulticastDomain)
      .pipe(
        T.XmlName("transitGatewayMulticastDomain"),
        T.Ec2QueryName("TransitGatewayMulticastDomain"),
      )
      .annotate({ identifier: "TransitGatewayMulticastDomain" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteTransitGatewayMulticastDomainResult",
}) as any as S.Schema<DeleteTransitGatewayMulticastDomainResult>;
export interface DeleteTransitGatewayPeeringAttachmentRequest {
  TransitGatewayAttachmentId?: string;
  DryRun?: boolean;
}
export const DeleteTransitGatewayPeeringAttachmentRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTransitGatewayPeeringAttachmentRequest",
}) as any as S.Schema<DeleteTransitGatewayPeeringAttachmentRequest>;
export interface DeleteTransitGatewayPeeringAttachmentResult {
  TransitGatewayPeeringAttachment?: TransitGatewayPeeringAttachment;
}
export const DeleteTransitGatewayPeeringAttachmentResult = S.suspend(() =>
  S.Struct({
    TransitGatewayPeeringAttachment: S.optional(TransitGatewayPeeringAttachment)
      .pipe(
        T.XmlName("transitGatewayPeeringAttachment"),
        T.Ec2QueryName("TransitGatewayPeeringAttachment"),
      )
      .annotate({ identifier: "TransitGatewayPeeringAttachment" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteTransitGatewayPeeringAttachmentResult",
}) as any as S.Schema<DeleteTransitGatewayPeeringAttachmentResult>;
export interface DeleteTransitGatewayPolicyTableRequest {
  TransitGatewayPolicyTableId?: string;
  DryRun?: boolean;
}
export const DeleteTransitGatewayPolicyTableRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayPolicyTableId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTransitGatewayPolicyTableRequest",
}) as any as S.Schema<DeleteTransitGatewayPolicyTableRequest>;
export interface DeleteTransitGatewayPolicyTableResult {
  TransitGatewayPolicyTable?: TransitGatewayPolicyTable;
}
export const DeleteTransitGatewayPolicyTableResult = S.suspend(() =>
  S.Struct({
    TransitGatewayPolicyTable: S.optional(TransitGatewayPolicyTable)
      .pipe(
        T.XmlName("transitGatewayPolicyTable"),
        T.Ec2QueryName("TransitGatewayPolicyTable"),
      )
      .annotate({ identifier: "TransitGatewayPolicyTable" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteTransitGatewayPolicyTableResult",
}) as any as S.Schema<DeleteTransitGatewayPolicyTableResult>;
export interface DeleteTransitGatewayPrefixListReferenceRequest {
  TransitGatewayRouteTableId?: string;
  PrefixListId?: string;
  DryRun?: boolean;
}
export const DeleteTransitGatewayPrefixListReferenceRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String),
    PrefixListId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTransitGatewayPrefixListReferenceRequest",
}) as any as S.Schema<DeleteTransitGatewayPrefixListReferenceRequest>;
export interface DeleteTransitGatewayPrefixListReferenceResult {
  TransitGatewayPrefixListReference?: TransitGatewayPrefixListReference;
}
export const DeleteTransitGatewayPrefixListReferenceResult = S.suspend(() =>
  S.Struct({
    TransitGatewayPrefixListReference: S.optional(
      TransitGatewayPrefixListReference,
    )
      .pipe(
        T.XmlName("transitGatewayPrefixListReference"),
        T.Ec2QueryName("TransitGatewayPrefixListReference"),
      )
      .annotate({ identifier: "TransitGatewayPrefixListReference" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteTransitGatewayPrefixListReferenceResult",
}) as any as S.Schema<DeleteTransitGatewayPrefixListReferenceResult>;
export interface DeleteTransitGatewayRouteRequest {
  TransitGatewayRouteTableId?: string;
  DestinationCidrBlock?: string;
  DryRun?: boolean;
}
export const DeleteTransitGatewayRouteRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String),
    DestinationCidrBlock: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTransitGatewayRouteRequest",
}) as any as S.Schema<DeleteTransitGatewayRouteRequest>;
export interface DeleteTransitGatewayRouteResult {
  Route?: TransitGatewayRoute;
}
export const DeleteTransitGatewayRouteResult = S.suspend(() =>
  S.Struct({
    Route: S.optional(TransitGatewayRoute)
      .pipe(T.XmlName("route"), T.Ec2QueryName("Route"))
      .annotate({ identifier: "TransitGatewayRoute" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteTransitGatewayRouteResult",
}) as any as S.Schema<DeleteTransitGatewayRouteResult>;
export interface DeleteTransitGatewayRouteTableRequest {
  TransitGatewayRouteTableId?: string;
  DryRun?: boolean;
}
export const DeleteTransitGatewayRouteTableRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTransitGatewayRouteTableRequest",
}) as any as S.Schema<DeleteTransitGatewayRouteTableRequest>;
export interface DeleteTransitGatewayRouteTableResult {
  TransitGatewayRouteTable?: TransitGatewayRouteTable;
}
export const DeleteTransitGatewayRouteTableResult = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTable: S.optional(TransitGatewayRouteTable)
      .pipe(
        T.XmlName("transitGatewayRouteTable"),
        T.Ec2QueryName("TransitGatewayRouteTable"),
      )
      .annotate({ identifier: "TransitGatewayRouteTable" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteTransitGatewayRouteTableResult",
}) as any as S.Schema<DeleteTransitGatewayRouteTableResult>;
export interface DeleteTransitGatewayRouteTableAnnouncementRequest {
  TransitGatewayRouteTableAnnouncementId?: string;
  DryRun?: boolean;
}
export const DeleteTransitGatewayRouteTableAnnouncementRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableAnnouncementId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTransitGatewayRouteTableAnnouncementRequest",
}) as any as S.Schema<DeleteTransitGatewayRouteTableAnnouncementRequest>;
export interface DeleteTransitGatewayRouteTableAnnouncementResult {
  TransitGatewayRouteTableAnnouncement?: TransitGatewayRouteTableAnnouncement;
}
export const DeleteTransitGatewayRouteTableAnnouncementResult = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableAnnouncement: S.optional(
      TransitGatewayRouteTableAnnouncement,
    )
      .pipe(
        T.XmlName("transitGatewayRouteTableAnnouncement"),
        T.Ec2QueryName("TransitGatewayRouteTableAnnouncement"),
      )
      .annotate({ identifier: "TransitGatewayRouteTableAnnouncement" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteTransitGatewayRouteTableAnnouncementResult",
}) as any as S.Schema<DeleteTransitGatewayRouteTableAnnouncementResult>;
export interface DeleteTransitGatewayVpcAttachmentRequest {
  TransitGatewayAttachmentId?: string;
  DryRun?: boolean;
}
export const DeleteTransitGatewayVpcAttachmentRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTransitGatewayVpcAttachmentRequest",
}) as any as S.Schema<DeleteTransitGatewayVpcAttachmentRequest>;
export interface DeleteTransitGatewayVpcAttachmentResult {
  TransitGatewayVpcAttachment?: TransitGatewayVpcAttachment;
}
export const DeleteTransitGatewayVpcAttachmentResult = S.suspend(() =>
  S.Struct({
    TransitGatewayVpcAttachment: S.optional(TransitGatewayVpcAttachment)
      .pipe(
        T.XmlName("transitGatewayVpcAttachment"),
        T.Ec2QueryName("TransitGatewayVpcAttachment"),
      )
      .annotate({ identifier: "TransitGatewayVpcAttachment" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteTransitGatewayVpcAttachmentResult",
}) as any as S.Schema<DeleteTransitGatewayVpcAttachmentResult>;
export interface DeleteVerifiedAccessEndpointRequest {
  VerifiedAccessEndpointId?: string;
  ClientToken?: string;
  DryRun?: boolean;
}
export const DeleteVerifiedAccessEndpointRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessEndpointId: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteVerifiedAccessEndpointRequest",
}) as any as S.Schema<DeleteVerifiedAccessEndpointRequest>;
export interface DeleteVerifiedAccessEndpointResult {
  VerifiedAccessEndpoint?: VerifiedAccessEndpoint;
}
export const DeleteVerifiedAccessEndpointResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessEndpoint: S.optional(VerifiedAccessEndpoint)
      .pipe(
        T.XmlName("verifiedAccessEndpoint"),
        T.Ec2QueryName("VerifiedAccessEndpoint"),
      )
      .annotate({ identifier: "VerifiedAccessEndpoint" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteVerifiedAccessEndpointResult",
}) as any as S.Schema<DeleteVerifiedAccessEndpointResult>;
export interface DeleteVerifiedAccessGroupRequest {
  VerifiedAccessGroupId?: string;
  ClientToken?: string;
  DryRun?: boolean;
}
export const DeleteVerifiedAccessGroupRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessGroupId: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteVerifiedAccessGroupRequest",
}) as any as S.Schema<DeleteVerifiedAccessGroupRequest>;
export interface DeleteVerifiedAccessGroupResult {
  VerifiedAccessGroup?: VerifiedAccessGroup;
}
export const DeleteVerifiedAccessGroupResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessGroup: S.optional(VerifiedAccessGroup)
      .pipe(
        T.XmlName("verifiedAccessGroup"),
        T.Ec2QueryName("VerifiedAccessGroup"),
      )
      .annotate({ identifier: "VerifiedAccessGroup" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteVerifiedAccessGroupResult",
}) as any as S.Schema<DeleteVerifiedAccessGroupResult>;
export interface DeleteVerifiedAccessInstanceRequest {
  VerifiedAccessInstanceId?: string;
  DryRun?: boolean;
  ClientToken?: string;
}
export const DeleteVerifiedAccessInstanceRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessInstanceId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteVerifiedAccessInstanceRequest",
}) as any as S.Schema<DeleteVerifiedAccessInstanceRequest>;
export interface DeleteVerifiedAccessInstanceResult {
  VerifiedAccessInstance?: VerifiedAccessInstance;
}
export const DeleteVerifiedAccessInstanceResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessInstance: S.optional(VerifiedAccessInstance)
      .pipe(
        T.XmlName("verifiedAccessInstance"),
        T.Ec2QueryName("VerifiedAccessInstance"),
      )
      .annotate({ identifier: "VerifiedAccessInstance" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteVerifiedAccessInstanceResult",
}) as any as S.Schema<DeleteVerifiedAccessInstanceResult>;
export interface DeleteVerifiedAccessTrustProviderRequest {
  VerifiedAccessTrustProviderId?: string;
  DryRun?: boolean;
  ClientToken?: string;
}
export const DeleteVerifiedAccessTrustProviderRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessTrustProviderId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteVerifiedAccessTrustProviderRequest",
}) as any as S.Schema<DeleteVerifiedAccessTrustProviderRequest>;
export interface DeleteVerifiedAccessTrustProviderResult {
  VerifiedAccessTrustProvider?: VerifiedAccessTrustProvider;
}
export const DeleteVerifiedAccessTrustProviderResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessTrustProvider: S.optional(VerifiedAccessTrustProvider)
      .pipe(
        T.XmlName("verifiedAccessTrustProvider"),
        T.Ec2QueryName("VerifiedAccessTrustProvider"),
      )
      .annotate({ identifier: "VerifiedAccessTrustProvider" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteVerifiedAccessTrustProviderResult",
}) as any as S.Schema<DeleteVerifiedAccessTrustProviderResult>;
export interface DeleteVolumeRequest {
  VolumeId?: string;
  DryRun?: boolean;
}
export const DeleteVolumeRequest = S.suspend(() =>
  S.Struct({
    VolumeId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteVolumeRequest",
}) as any as S.Schema<DeleteVolumeRequest>;
export interface DeleteVolumeResponse {}
export const DeleteVolumeResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteVolumeResponse",
}) as any as S.Schema<DeleteVolumeResponse>;
export interface DeleteVpcRequest {
  VpcId?: string;
  DryRun?: boolean;
}
export const DeleteVpcRequest = S.suspend(() =>
  S.Struct({
    VpcId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteVpcRequest",
}) as any as S.Schema<DeleteVpcRequest>;
export interface DeleteVpcResponse {}
export const DeleteVpcResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteVpcResponse",
}) as any as S.Schema<DeleteVpcResponse>;
export interface DeleteVpcBlockPublicAccessExclusionRequest {
  DryRun?: boolean;
  ExclusionId?: string;
}
export const DeleteVpcBlockPublicAccessExclusionRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ExclusionId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteVpcBlockPublicAccessExclusionRequest",
}) as any as S.Schema<DeleteVpcBlockPublicAccessExclusionRequest>;
export interface DeleteVpcBlockPublicAccessExclusionResult {
  VpcBlockPublicAccessExclusion?: VpcBlockPublicAccessExclusion;
}
export const DeleteVpcBlockPublicAccessExclusionResult = S.suspend(() =>
  S.Struct({
    VpcBlockPublicAccessExclusion: S.optional(VpcBlockPublicAccessExclusion)
      .pipe(
        T.XmlName("vpcBlockPublicAccessExclusion"),
        T.Ec2QueryName("VpcBlockPublicAccessExclusion"),
      )
      .annotate({ identifier: "VpcBlockPublicAccessExclusion" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteVpcBlockPublicAccessExclusionResult",
}) as any as S.Schema<DeleteVpcBlockPublicAccessExclusionResult>;
export interface DeleteVpcEncryptionControlRequest {
  DryRun?: boolean;
  VpcEncryptionControlId?: string;
}
export const DeleteVpcEncryptionControlRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    VpcEncryptionControlId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteVpcEncryptionControlRequest",
}) as any as S.Schema<DeleteVpcEncryptionControlRequest>;
export interface DeleteVpcEncryptionControlResult {
  VpcEncryptionControl?: VpcEncryptionControl;
}
export const DeleteVpcEncryptionControlResult = S.suspend(() =>
  S.Struct({
    VpcEncryptionControl: S.optional(VpcEncryptionControl)
      .pipe(
        T.XmlName("vpcEncryptionControl"),
        T.Ec2QueryName("VpcEncryptionControl"),
      )
      .annotate({ identifier: "VpcEncryptionControl" }),
  }).pipe(ns),
).annotate({
  identifier: "DeleteVpcEncryptionControlResult",
}) as any as S.Schema<DeleteVpcEncryptionControlResult>;
export type ConnectionNotificationIdsList = string[];
export const ConnectionNotificationIdsList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DeleteVpcEndpointConnectionNotificationsRequest {
  DryRun?: boolean;
  ConnectionNotificationIds?: string[];
}
export const DeleteVpcEndpointConnectionNotificationsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ConnectionNotificationIds: S.optional(ConnectionNotificationIdsList).pipe(
      T.XmlName("ConnectionNotificationId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteVpcEndpointConnectionNotificationsRequest",
}) as any as S.Schema<DeleteVpcEndpointConnectionNotificationsRequest>;
export interface DeleteVpcEndpointConnectionNotificationsResult {
  Unsuccessful?: UnsuccessfulItem[];
}
export const DeleteVpcEndpointConnectionNotificationsResult = S.suspend(() =>
  S.Struct({
    Unsuccessful: S.optional(UnsuccessfulItemSet).pipe(
      T.XmlName("unsuccessful"),
      T.Ec2QueryName("Unsuccessful"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteVpcEndpointConnectionNotificationsResult",
}) as any as S.Schema<DeleteVpcEndpointConnectionNotificationsResult>;
export interface DeleteVpcEndpointsRequest {
  DryRun?: boolean;
  VpcEndpointIds?: string[];
}
export const DeleteVpcEndpointsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    VpcEndpointIds: S.optional(VpcEndpointIdList).pipe(
      T.XmlName("VpcEndpointId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteVpcEndpointsRequest",
}) as any as S.Schema<DeleteVpcEndpointsRequest>;
export interface DeleteVpcEndpointsResult {
  Unsuccessful?: UnsuccessfulItem[];
}
export const DeleteVpcEndpointsResult = S.suspend(() =>
  S.Struct({
    Unsuccessful: S.optional(UnsuccessfulItemSet).pipe(
      T.XmlName("unsuccessful"),
      T.Ec2QueryName("Unsuccessful"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteVpcEndpointsResult",
}) as any as S.Schema<DeleteVpcEndpointsResult>;
export type VpcEndpointServiceIdList = string[];
export const VpcEndpointServiceIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DeleteVpcEndpointServiceConfigurationsRequest {
  DryRun?: boolean;
  ServiceIds?: string[];
}
export const DeleteVpcEndpointServiceConfigurationsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ServiceIds: S.optional(VpcEndpointServiceIdList).pipe(
      T.XmlName("ServiceId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteVpcEndpointServiceConfigurationsRequest",
}) as any as S.Schema<DeleteVpcEndpointServiceConfigurationsRequest>;
export interface DeleteVpcEndpointServiceConfigurationsResult {
  Unsuccessful?: UnsuccessfulItem[];
}
export const DeleteVpcEndpointServiceConfigurationsResult = S.suspend(() =>
  S.Struct({
    Unsuccessful: S.optional(UnsuccessfulItemSet).pipe(
      T.XmlName("unsuccessful"),
      T.Ec2QueryName("Unsuccessful"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteVpcEndpointServiceConfigurationsResult",
}) as any as S.Schema<DeleteVpcEndpointServiceConfigurationsResult>;
export interface DeleteVpcPeeringConnectionRequest {
  DryRun?: boolean;
  VpcPeeringConnectionId?: string;
}
export const DeleteVpcPeeringConnectionRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    VpcPeeringConnectionId: S.optional(S.String).pipe(
      T.XmlName("vpcPeeringConnectionId"),
      T.Ec2QueryName("VpcPeeringConnectionId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteVpcPeeringConnectionRequest",
}) as any as S.Schema<DeleteVpcPeeringConnectionRequest>;
export interface DeleteVpcPeeringConnectionResult {
  Return?: boolean;
}
export const DeleteVpcPeeringConnectionResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteVpcPeeringConnectionResult",
}) as any as S.Schema<DeleteVpcPeeringConnectionResult>;
export interface DeleteVpnConcentratorRequest {
  VpnConcentratorId?: string;
  DryRun?: boolean;
}
export const DeleteVpnConcentratorRequest = S.suspend(() =>
  S.Struct({
    VpnConcentratorId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteVpnConcentratorRequest",
}) as any as S.Schema<DeleteVpnConcentratorRequest>;
export interface DeleteVpnConcentratorResult {
  Return?: boolean;
}
export const DeleteVpnConcentratorResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeleteVpnConcentratorResult",
}) as any as S.Schema<DeleteVpnConcentratorResult>;
export interface DeleteVpnConnectionRequest {
  VpnConnectionId?: string;
  DryRun?: boolean;
}
export const DeleteVpnConnectionRequest = S.suspend(() =>
  S.Struct({
    VpnConnectionId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteVpnConnectionRequest",
}) as any as S.Schema<DeleteVpnConnectionRequest>;
export interface DeleteVpnConnectionResponse {}
export const DeleteVpnConnectionResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteVpnConnectionResponse",
}) as any as S.Schema<DeleteVpnConnectionResponse>;
export interface DeleteVpnConnectionRouteRequest {
  DestinationCidrBlock?: string;
  VpnConnectionId?: string;
}
export const DeleteVpnConnectionRouteRequest = S.suspend(() =>
  S.Struct({
    DestinationCidrBlock: S.optional(S.String),
    VpnConnectionId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteVpnConnectionRouteRequest",
}) as any as S.Schema<DeleteVpnConnectionRouteRequest>;
export interface DeleteVpnConnectionRouteResponse {}
export const DeleteVpnConnectionRouteResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteVpnConnectionRouteResponse",
}) as any as S.Schema<DeleteVpnConnectionRouteResponse>;
export interface DeleteVpnGatewayRequest {
  VpnGatewayId?: string;
  DryRun?: boolean;
}
export const DeleteVpnGatewayRequest = S.suspend(() =>
  S.Struct({
    VpnGatewayId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteVpnGatewayRequest",
}) as any as S.Schema<DeleteVpnGatewayRequest>;
export interface DeleteVpnGatewayResponse {}
export const DeleteVpnGatewayResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteVpnGatewayResponse",
}) as any as S.Schema<DeleteVpnGatewayResponse>;
export interface DeprovisionByoipCidrRequest {
  Cidr?: string;
  DryRun?: boolean;
}
export const DeprovisionByoipCidrRequest = S.suspend(() =>
  S.Struct({ Cidr: S.optional(S.String), DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeprovisionByoipCidrRequest",
}) as any as S.Schema<DeprovisionByoipCidrRequest>;
export interface DeprovisionByoipCidrResult {
  ByoipCidr?: ByoipCidr;
}
export const DeprovisionByoipCidrResult = S.suspend(() =>
  S.Struct({
    ByoipCidr: S.optional(ByoipCidr)
      .pipe(T.XmlName("byoipCidr"), T.Ec2QueryName("ByoipCidr"))
      .annotate({ identifier: "ByoipCidr" }),
  }).pipe(ns),
).annotate({
  identifier: "DeprovisionByoipCidrResult",
}) as any as S.Schema<DeprovisionByoipCidrResult>;
export interface DeprovisionIpamByoasnRequest {
  DryRun?: boolean;
  IpamId?: string;
  Asn?: string;
}
export const DeprovisionIpamByoasnRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamId: S.optional(S.String),
    Asn: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeprovisionIpamByoasnRequest",
}) as any as S.Schema<DeprovisionIpamByoasnRequest>;
export type AsnState =
  | "deprovisioned"
  | "failed-deprovision"
  | "failed-provision"
  | "pending-deprovision"
  | "pending-provision"
  | "provisioned"
  | (string & {});
export const AsnState = S.String;
export interface Byoasn {
  Asn?: string;
  IpamId?: string;
  StatusMessage?: string;
  State?: AsnState;
}
export const Byoasn = S.suspend(() =>
  S.Struct({
    Asn: S.optional(S.String).pipe(T.XmlName("asn"), T.Ec2QueryName("Asn")),
    IpamId: S.optional(S.String).pipe(
      T.XmlName("ipamId"),
      T.Ec2QueryName("IpamId"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    State: S.optional(AsnState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({ identifier: "Byoasn" }) as any as S.Schema<Byoasn>;
export interface DeprovisionIpamByoasnResult {
  Byoasn?: Byoasn;
}
export const DeprovisionIpamByoasnResult = S.suspend(() =>
  S.Struct({
    Byoasn: S.optional(Byoasn)
      .pipe(T.XmlName("byoasn"), T.Ec2QueryName("Byoasn"))
      .annotate({ identifier: "Byoasn" }),
  }).pipe(ns),
).annotate({
  identifier: "DeprovisionIpamByoasnResult",
}) as any as S.Schema<DeprovisionIpamByoasnResult>;
export interface DeprovisionIpamPoolCidrRequest {
  DryRun?: boolean;
  IpamPoolId?: string;
  Cidr?: string;
}
export const DeprovisionIpamPoolCidrRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPoolId: S.optional(S.String),
    Cidr: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeprovisionIpamPoolCidrRequest",
}) as any as S.Schema<DeprovisionIpamPoolCidrRequest>;
export type IpamPoolCidrState =
  | "pending-provision"
  | "provisioned"
  | "failed-provision"
  | "pending-deprovision"
  | "deprovisioned"
  | "failed-deprovision"
  | "pending-import"
  | "failed-import"
  | (string & {});
export const IpamPoolCidrState = S.String;
export type IpamPoolCidrFailureCode =
  | "cidr-not-available"
  | "limit-exceeded"
  | (string & {});
export const IpamPoolCidrFailureCode = S.String;
export interface IpamPoolCidrFailureReason {
  Code?: IpamPoolCidrFailureCode;
  Message?: string;
}
export const IpamPoolCidrFailureReason = S.suspend(() =>
  S.Struct({
    Code: S.optional(IpamPoolCidrFailureCode).pipe(
      T.XmlName("code"),
      T.Ec2QueryName("Code"),
    ),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "IpamPoolCidrFailureReason",
}) as any as S.Schema<IpamPoolCidrFailureReason>;
export interface IpamPoolCidr {
  Cidr?: string;
  State?: IpamPoolCidrState;
  FailureReason?: IpamPoolCidrFailureReason;
  IpamPoolCidrId?: string;
  NetmaskLength?: number;
}
export const IpamPoolCidr = S.suspend(() =>
  S.Struct({
    Cidr: S.optional(S.String).pipe(T.XmlName("cidr"), T.Ec2QueryName("Cidr")),
    State: S.optional(IpamPoolCidrState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    FailureReason: S.optional(IpamPoolCidrFailureReason)
      .pipe(T.XmlName("failureReason"), T.Ec2QueryName("FailureReason"))
      .annotate({ identifier: "IpamPoolCidrFailureReason" }),
    IpamPoolCidrId: S.optional(S.String).pipe(
      T.XmlName("ipamPoolCidrId"),
      T.Ec2QueryName("IpamPoolCidrId"),
    ),
    NetmaskLength: S.optional(S.Number).pipe(
      T.XmlName("netmaskLength"),
      T.Ec2QueryName("NetmaskLength"),
    ),
  }),
).annotate({ identifier: "IpamPoolCidr" }) as any as S.Schema<IpamPoolCidr>;
export interface DeprovisionIpamPoolCidrResult {
  IpamPoolCidr?: IpamPoolCidr;
}
export const DeprovisionIpamPoolCidrResult = S.suspend(() =>
  S.Struct({
    IpamPoolCidr: S.optional(IpamPoolCidr)
      .pipe(T.XmlName("ipamPoolCidr"), T.Ec2QueryName("IpamPoolCidr"))
      .annotate({ identifier: "IpamPoolCidr" }),
  }).pipe(ns),
).annotate({
  identifier: "DeprovisionIpamPoolCidrResult",
}) as any as S.Schema<DeprovisionIpamPoolCidrResult>;
export interface DeprovisionPublicIpv4PoolCidrRequest {
  DryRun?: boolean;
  PoolId?: string;
  Cidr?: string;
}
export const DeprovisionPublicIpv4PoolCidrRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    PoolId: S.optional(S.String),
    Cidr: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeprovisionPublicIpv4PoolCidrRequest",
}) as any as S.Schema<DeprovisionPublicIpv4PoolCidrRequest>;
export type DeprovisionedAddressSet = string[];
export const DeprovisionedAddressSet = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DeprovisionPublicIpv4PoolCidrResult {
  PoolId?: string;
  DeprovisionedAddresses?: string[];
}
export const DeprovisionPublicIpv4PoolCidrResult = S.suspend(() =>
  S.Struct({
    PoolId: S.optional(S.String).pipe(
      T.XmlName("poolId"),
      T.Ec2QueryName("PoolId"),
    ),
    DeprovisionedAddresses: S.optional(DeprovisionedAddressSet).pipe(
      T.XmlName("deprovisionedAddressSet"),
      T.Ec2QueryName("DeprovisionedAddressSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeprovisionPublicIpv4PoolCidrResult",
}) as any as S.Schema<DeprovisionPublicIpv4PoolCidrResult>;
export interface DeregisterImageRequest {
  ImageId?: string;
  DeleteAssociatedSnapshots?: boolean;
  DryRun?: boolean;
}
export const DeregisterImageRequest = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String),
    DeleteAssociatedSnapshots: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeregisterImageRequest",
}) as any as S.Schema<DeregisterImageRequest>;
export type SnapshotReturnCodes =
  | "success"
  | "skipped"
  | "missing-permissions"
  | "internal-error"
  | "client-error"
  | (string & {});
export const SnapshotReturnCodes = S.String;
export interface DeleteSnapshotReturnCode {
  SnapshotId?: string;
  ReturnCode?: SnapshotReturnCodes;
}
export const DeleteSnapshotReturnCode = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    ReturnCode: S.optional(SnapshotReturnCodes).pipe(
      T.XmlName("returnCode"),
      T.Ec2QueryName("ReturnCode"),
    ),
  }),
).annotate({
  identifier: "DeleteSnapshotReturnCode",
}) as any as S.Schema<DeleteSnapshotReturnCode>;
export type DeleteSnapshotResultSet = DeleteSnapshotReturnCode[];
export const DeleteSnapshotResultSet = S.Array(
  DeleteSnapshotReturnCode.pipe(T.XmlName("item")).annotate({
    identifier: "DeleteSnapshotReturnCode",
  }),
);
export interface DeregisterImageResult {
  Return?: boolean;
  DeleteSnapshotResults?: DeleteSnapshotReturnCode[];
}
export const DeregisterImageResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
    DeleteSnapshotResults: S.optional(DeleteSnapshotResultSet).pipe(
      T.XmlName("deleteSnapshotResultSet"),
      T.Ec2QueryName("DeleteSnapshotResultSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DeregisterImageResult",
}) as any as S.Schema<DeregisterImageResult>;
export type InstanceTagKeySet = string[];
export const InstanceTagKeySet = S.Array(S.String.pipe(T.XmlName("item")));
export interface DeregisterInstanceTagAttributeRequest {
  IncludeAllTagsOfInstance?: boolean;
  InstanceTagKeys?: string[];
}
export const DeregisterInstanceTagAttributeRequest = S.suspend(() =>
  S.Struct({
    IncludeAllTagsOfInstance: S.optional(S.Boolean),
    InstanceTagKeys: S.optional(InstanceTagKeySet).pipe(
      T.XmlName("InstanceTagKey"),
    ),
  }),
).annotate({
  identifier: "DeregisterInstanceTagAttributeRequest",
}) as any as S.Schema<DeregisterInstanceTagAttributeRequest>;
export interface DeregisterInstanceEventNotificationAttributesRequest {
  DryRun?: boolean;
  InstanceTagAttribute?: DeregisterInstanceTagAttributeRequest;
}
export const DeregisterInstanceEventNotificationAttributesRequest = S.suspend(
  () =>
    S.Struct({
      DryRun: S.optional(S.Boolean),
      InstanceTagAttribute: S.optional(DeregisterInstanceTagAttributeRequest),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "DeregisterInstanceEventNotificationAttributesRequest",
}) as any as S.Schema<DeregisterInstanceEventNotificationAttributesRequest>;
export interface InstanceTagNotificationAttribute {
  InstanceTagKeys?: string[];
  IncludeAllTagsOfInstance?: boolean;
}
export const InstanceTagNotificationAttribute = S.suspend(() =>
  S.Struct({
    InstanceTagKeys: S.optional(InstanceTagKeySet).pipe(
      T.XmlName("instanceTagKeySet"),
      T.Ec2QueryName("InstanceTagKeySet"),
    ),
    IncludeAllTagsOfInstance: S.optional(S.Boolean).pipe(
      T.XmlName("includeAllTagsOfInstance"),
      T.Ec2QueryName("IncludeAllTagsOfInstance"),
    ),
  }),
).annotate({
  identifier: "InstanceTagNotificationAttribute",
}) as any as S.Schema<InstanceTagNotificationAttribute>;
export interface DeregisterInstanceEventNotificationAttributesResult {
  InstanceTagAttribute?: InstanceTagNotificationAttribute;
}
export const DeregisterInstanceEventNotificationAttributesResult = S.suspend(
  () =>
    S.Struct({
      InstanceTagAttribute: S.optional(InstanceTagNotificationAttribute)
        .pipe(
          T.XmlName("instanceTagAttribute"),
          T.Ec2QueryName("InstanceTagAttribute"),
        )
        .annotate({ identifier: "InstanceTagNotificationAttribute" }),
    }).pipe(ns),
).annotate({
  identifier: "DeregisterInstanceEventNotificationAttributesResult",
}) as any as S.Schema<DeregisterInstanceEventNotificationAttributesResult>;
export type TransitGatewayNetworkInterfaceIdList = string[];
export const TransitGatewayNetworkInterfaceIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DeregisterTransitGatewayMulticastGroupMembersRequest {
  TransitGatewayMulticastDomainId?: string;
  GroupIpAddress?: string;
  NetworkInterfaceIds?: string[];
  DryRun?: boolean;
}
export const DeregisterTransitGatewayMulticastGroupMembersRequest = S.suspend(
  () =>
    S.Struct({
      TransitGatewayMulticastDomainId: S.optional(S.String),
      GroupIpAddress: S.optional(S.String),
      NetworkInterfaceIds: S.optional(TransitGatewayNetworkInterfaceIdList),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "DeregisterTransitGatewayMulticastGroupMembersRequest",
}) as any as S.Schema<DeregisterTransitGatewayMulticastGroupMembersRequest>;
export interface TransitGatewayMulticastDeregisteredGroupMembers {
  TransitGatewayMulticastDomainId?: string;
  DeregisteredNetworkInterfaceIds?: string[];
  GroupIpAddress?: string;
}
export const TransitGatewayMulticastDeregisteredGroupMembers = S.suspend(() =>
  S.Struct({
    TransitGatewayMulticastDomainId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayMulticastDomainId"),
      T.Ec2QueryName("TransitGatewayMulticastDomainId"),
    ),
    DeregisteredNetworkInterfaceIds: S.optional(ValueStringList).pipe(
      T.XmlName("deregisteredNetworkInterfaceIds"),
      T.Ec2QueryName("DeregisteredNetworkInterfaceIds"),
    ),
    GroupIpAddress: S.optional(S.String).pipe(
      T.XmlName("groupIpAddress"),
      T.Ec2QueryName("GroupIpAddress"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayMulticastDeregisteredGroupMembers",
}) as any as S.Schema<TransitGatewayMulticastDeregisteredGroupMembers>;
export interface DeregisterTransitGatewayMulticastGroupMembersResult {
  DeregisteredMulticastGroupMembers?: TransitGatewayMulticastDeregisteredGroupMembers;
}
export const DeregisterTransitGatewayMulticastGroupMembersResult = S.suspend(
  () =>
    S.Struct({
      DeregisteredMulticastGroupMembers: S.optional(
        TransitGatewayMulticastDeregisteredGroupMembers,
      )
        .pipe(
          T.XmlName("deregisteredMulticastGroupMembers"),
          T.Ec2QueryName("DeregisteredMulticastGroupMembers"),
        )
        .annotate({
          identifier: "TransitGatewayMulticastDeregisteredGroupMembers",
        }),
    }).pipe(ns),
).annotate({
  identifier: "DeregisterTransitGatewayMulticastGroupMembersResult",
}) as any as S.Schema<DeregisterTransitGatewayMulticastGroupMembersResult>;
export interface DeregisterTransitGatewayMulticastGroupSourcesRequest {
  TransitGatewayMulticastDomainId?: string;
  GroupIpAddress?: string;
  NetworkInterfaceIds?: string[];
  DryRun?: boolean;
}
export const DeregisterTransitGatewayMulticastGroupSourcesRequest = S.suspend(
  () =>
    S.Struct({
      TransitGatewayMulticastDomainId: S.optional(S.String),
      GroupIpAddress: S.optional(S.String),
      NetworkInterfaceIds: S.optional(TransitGatewayNetworkInterfaceIdList),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "DeregisterTransitGatewayMulticastGroupSourcesRequest",
}) as any as S.Schema<DeregisterTransitGatewayMulticastGroupSourcesRequest>;
export interface TransitGatewayMulticastDeregisteredGroupSources {
  TransitGatewayMulticastDomainId?: string;
  DeregisteredNetworkInterfaceIds?: string[];
  GroupIpAddress?: string;
}
export const TransitGatewayMulticastDeregisteredGroupSources = S.suspend(() =>
  S.Struct({
    TransitGatewayMulticastDomainId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayMulticastDomainId"),
      T.Ec2QueryName("TransitGatewayMulticastDomainId"),
    ),
    DeregisteredNetworkInterfaceIds: S.optional(ValueStringList).pipe(
      T.XmlName("deregisteredNetworkInterfaceIds"),
      T.Ec2QueryName("DeregisteredNetworkInterfaceIds"),
    ),
    GroupIpAddress: S.optional(S.String).pipe(
      T.XmlName("groupIpAddress"),
      T.Ec2QueryName("GroupIpAddress"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayMulticastDeregisteredGroupSources",
}) as any as S.Schema<TransitGatewayMulticastDeregisteredGroupSources>;
export interface DeregisterTransitGatewayMulticastGroupSourcesResult {
  DeregisteredMulticastGroupSources?: TransitGatewayMulticastDeregisteredGroupSources;
}
export const DeregisterTransitGatewayMulticastGroupSourcesResult = S.suspend(
  () =>
    S.Struct({
      DeregisteredMulticastGroupSources: S.optional(
        TransitGatewayMulticastDeregisteredGroupSources,
      )
        .pipe(
          T.XmlName("deregisteredMulticastGroupSources"),
          T.Ec2QueryName("DeregisteredMulticastGroupSources"),
        )
        .annotate({
          identifier: "TransitGatewayMulticastDeregisteredGroupSources",
        }),
    }).pipe(ns),
).annotate({
  identifier: "DeregisterTransitGatewayMulticastGroupSourcesResult",
}) as any as S.Schema<DeregisterTransitGatewayMulticastGroupSourcesResult>;
export type AccountAttributeName =
  | "supported-platforms"
  | "default-vpc"
  | (string & {});
export const AccountAttributeName = S.String;
export type AccountAttributeNameStringList = AccountAttributeName[];
export const AccountAttributeNameStringList = S.Array(
  AccountAttributeName.pipe(T.XmlName("attributeName")),
);
export interface DescribeAccountAttributesRequest {
  DryRun?: boolean;
  AttributeNames?: AccountAttributeName[];
}
export const DescribeAccountAttributesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    AttributeNames: S.optional(AccountAttributeNameStringList).pipe(
      T.XmlName("attributeName"),
      T.Ec2QueryName("AttributeName"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeAccountAttributesRequest",
}) as any as S.Schema<DescribeAccountAttributesRequest>;
export interface AccountAttributeValue {
  AttributeValue?: string;
}
export const AccountAttributeValue = S.suspend(() =>
  S.Struct({
    AttributeValue: S.optional(S.String).pipe(
      T.XmlName("attributeValue"),
      T.Ec2QueryName("AttributeValue"),
    ),
  }),
).annotate({
  identifier: "AccountAttributeValue",
}) as any as S.Schema<AccountAttributeValue>;
export type AccountAttributeValueList = AccountAttributeValue[];
export const AccountAttributeValueList = S.Array(
  AccountAttributeValue.pipe(T.XmlName("item")).annotate({
    identifier: "AccountAttributeValue",
  }),
);
export interface AccountAttribute {
  AttributeName?: string;
  AttributeValues?: AccountAttributeValue[];
}
export const AccountAttribute = S.suspend(() =>
  S.Struct({
    AttributeName: S.optional(S.String).pipe(
      T.XmlName("attributeName"),
      T.Ec2QueryName("AttributeName"),
    ),
    AttributeValues: S.optional(AccountAttributeValueList).pipe(
      T.XmlName("attributeValueSet"),
      T.Ec2QueryName("AttributeValueSet"),
    ),
  }),
).annotate({
  identifier: "AccountAttribute",
}) as any as S.Schema<AccountAttribute>;
export type AccountAttributeList = AccountAttribute[];
export const AccountAttributeList = S.Array(
  AccountAttribute.pipe(T.XmlName("item")).annotate({
    identifier: "AccountAttribute",
  }),
);
export interface DescribeAccountAttributesResult {
  AccountAttributes?: AccountAttribute[];
}
export const DescribeAccountAttributesResult = S.suspend(() =>
  S.Struct({
    AccountAttributes: S.optional(AccountAttributeList).pipe(
      T.XmlName("accountAttributeSet"),
      T.Ec2QueryName("AccountAttributeSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeAccountAttributesResult",
}) as any as S.Schema<DescribeAccountAttributesResult>;
export type PublicIpStringList = string[];
export const PublicIpStringList = S.Array(S.String.pipe(T.XmlName("PublicIp")));
export interface Filter {
  Name?: string;
  Values?: string[];
}
export const Filter = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Values: S.optional(ValueStringList).pipe(T.XmlName("Value")),
  }),
).annotate({ identifier: "Filter" }) as any as S.Schema<Filter>;
export type FilterList = Filter[];
export const FilterList = S.Array(
  Filter.pipe(T.XmlName("Filter")).annotate({ identifier: "Filter" }),
);
export interface DescribeAddressesRequest {
  PublicIps?: string[];
  DryRun?: boolean;
  Filters?: Filter[];
  AllocationIds?: string[];
}
export const DescribeAddressesRequest = S.suspend(() =>
  S.Struct({
    PublicIps: S.optional(PublicIpStringList).pipe(T.XmlName("PublicIp")),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    AllocationIds: S.optional(AllocationIdList).pipe(T.XmlName("AllocationId")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeAddressesRequest",
}) as any as S.Schema<DescribeAddressesRequest>;
export type ServiceManaged = "alb" | "nlb" | "rnat" | "rds" | (string & {});
export const ServiceManaged = S.String;
export interface Address {
  AllocationId?: string;
  AssociationId?: string;
  Domain?: DomainType;
  NetworkInterfaceId?: string;
  NetworkInterfaceOwnerId?: string;
  PrivateIpAddress?: string;
  Tags?: Tag[];
  PublicIpv4Pool?: string;
  NetworkBorderGroup?: string;
  CustomerOwnedIp?: string;
  CustomerOwnedIpv4Pool?: string;
  CarrierIp?: string;
  SubnetId?: string;
  ServiceManaged?: ServiceManaged;
  InstanceId?: string;
  PublicIp?: string;
}
export const Address = S.suspend(() =>
  S.Struct({
    AllocationId: S.optional(S.String).pipe(
      T.XmlName("allocationId"),
      T.Ec2QueryName("AllocationId"),
    ),
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
    Domain: S.optional(DomainType).pipe(
      T.XmlName("domain"),
      T.Ec2QueryName("Domain"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    NetworkInterfaceOwnerId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceOwnerId"),
      T.Ec2QueryName("NetworkInterfaceOwnerId"),
    ),
    PrivateIpAddress: S.optional(S.String).pipe(
      T.XmlName("privateIpAddress"),
      T.Ec2QueryName("PrivateIpAddress"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    PublicIpv4Pool: S.optional(S.String).pipe(
      T.XmlName("publicIpv4Pool"),
      T.Ec2QueryName("PublicIpv4Pool"),
    ),
    NetworkBorderGroup: S.optional(S.String).pipe(
      T.XmlName("networkBorderGroup"),
      T.Ec2QueryName("NetworkBorderGroup"),
    ),
    CustomerOwnedIp: S.optional(S.String).pipe(
      T.XmlName("customerOwnedIp"),
      T.Ec2QueryName("CustomerOwnedIp"),
    ),
    CustomerOwnedIpv4Pool: S.optional(S.String).pipe(
      T.XmlName("customerOwnedIpv4Pool"),
      T.Ec2QueryName("CustomerOwnedIpv4Pool"),
    ),
    CarrierIp: S.optional(S.String).pipe(
      T.XmlName("carrierIp"),
      T.Ec2QueryName("CarrierIp"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    ServiceManaged: S.optional(ServiceManaged).pipe(
      T.XmlName("serviceManaged"),
      T.Ec2QueryName("ServiceManaged"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    PublicIp: S.optional(S.String).pipe(
      T.XmlName("publicIp"),
      T.Ec2QueryName("PublicIp"),
    ),
  }),
).annotate({ identifier: "Address" }) as any as S.Schema<Address>;
export type AddressList = Address[];
export const AddressList = S.Array(
  Address.pipe(T.XmlName("item")).annotate({ identifier: "Address" }),
);
export interface DescribeAddressesResult {
  Addresses?: Address[];
}
export const DescribeAddressesResult = S.suspend(() =>
  S.Struct({
    Addresses: S.optional(AddressList).pipe(
      T.XmlName("addressesSet"),
      T.Ec2QueryName("AddressesSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeAddressesResult",
}) as any as S.Schema<DescribeAddressesResult>;
export type AllocationIds = string[];
export const AllocationIds = S.Array(S.String.pipe(T.XmlName("item")));
export type AddressAttributeName = "domain-name" | (string & {});
export const AddressAttributeName = S.String;
export interface DescribeAddressesAttributeRequest {
  AllocationIds?: string[];
  Attribute?: AddressAttributeName;
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
}
export const DescribeAddressesAttributeRequest = S.suspend(() =>
  S.Struct({
    AllocationIds: S.optional(AllocationIds).pipe(T.XmlName("AllocationId")),
    Attribute: S.optional(AddressAttributeName),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeAddressesAttributeRequest",
}) as any as S.Schema<DescribeAddressesAttributeRequest>;
export interface PtrUpdateStatus {
  Value?: string;
  Status?: string;
  Reason?: string;
}
export const PtrUpdateStatus = S.suspend(() =>
  S.Struct({
    Value: S.optional(S.String).pipe(
      T.XmlName("value"),
      T.Ec2QueryName("Value"),
    ),
    Status: S.optional(S.String).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    Reason: S.optional(S.String).pipe(
      T.XmlName("reason"),
      T.Ec2QueryName("Reason"),
    ),
  }),
).annotate({
  identifier: "PtrUpdateStatus",
}) as any as S.Schema<PtrUpdateStatus>;
export interface AddressAttribute {
  PublicIp?: string;
  AllocationId?: string;
  PtrRecord?: string;
  PtrRecordUpdate?: PtrUpdateStatus;
}
export const AddressAttribute = S.suspend(() =>
  S.Struct({
    PublicIp: S.optional(S.String).pipe(
      T.XmlName("publicIp"),
      T.Ec2QueryName("PublicIp"),
    ),
    AllocationId: S.optional(S.String).pipe(
      T.XmlName("allocationId"),
      T.Ec2QueryName("AllocationId"),
    ),
    PtrRecord: S.optional(S.String).pipe(
      T.XmlName("ptrRecord"),
      T.Ec2QueryName("PtrRecord"),
    ),
    PtrRecordUpdate: S.optional(PtrUpdateStatus)
      .pipe(T.XmlName("ptrRecordUpdate"), T.Ec2QueryName("PtrRecordUpdate"))
      .annotate({ identifier: "PtrUpdateStatus" }),
  }),
).annotate({
  identifier: "AddressAttribute",
}) as any as S.Schema<AddressAttribute>;
export type AddressSet = AddressAttribute[];
export const AddressSet = S.Array(
  AddressAttribute.pipe(T.XmlName("item")).annotate({
    identifier: "AddressAttribute",
  }),
);
export interface DescribeAddressesAttributeResult {
  Addresses?: AddressAttribute[];
  NextToken?: string;
}
export const DescribeAddressesAttributeResult = S.suspend(() =>
  S.Struct({
    Addresses: S.optional(AddressSet).pipe(
      T.XmlName("addressSet"),
      T.Ec2QueryName("AddressSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeAddressesAttributeResult",
}) as any as S.Schema<DescribeAddressesAttributeResult>;
export interface DescribeAddressTransfersRequest {
  AllocationIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
}
export const DescribeAddressTransfersRequest = S.suspend(() =>
  S.Struct({
    AllocationIds: S.optional(AllocationIdList).pipe(T.XmlName("AllocationId")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeAddressTransfersRequest",
}) as any as S.Schema<DescribeAddressTransfersRequest>;
export type AddressTransferList = AddressTransfer[];
export const AddressTransferList = S.Array(
  AddressTransfer.pipe(T.XmlName("item")).annotate({
    identifier: "AddressTransfer",
  }),
);
export interface DescribeAddressTransfersResult {
  AddressTransfers?: AddressTransfer[];
  NextToken?: string;
}
export const DescribeAddressTransfersResult = S.suspend(() =>
  S.Struct({
    AddressTransfers: S.optional(AddressTransferList).pipe(
      T.XmlName("addressTransferSet"),
      T.Ec2QueryName("AddressTransferSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeAddressTransfersResult",
}) as any as S.Schema<DescribeAddressTransfersResult>;
export interface DescribeAggregateIdFormatRequest {
  DryRun?: boolean;
}
export const DescribeAggregateIdFormatRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeAggregateIdFormatRequest",
}) as any as S.Schema<DescribeAggregateIdFormatRequest>;
export interface IdFormat {
  Deadline?: Date;
  Resource?: string;
  UseLongIds?: boolean;
}
export const IdFormat = S.suspend(() =>
  S.Struct({
    Deadline: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("deadline"), T.Ec2QueryName("Deadline")),
    Resource: S.optional(S.String).pipe(
      T.XmlName("resource"),
      T.Ec2QueryName("Resource"),
    ),
    UseLongIds: S.optional(S.Boolean).pipe(
      T.XmlName("useLongIds"),
      T.Ec2QueryName("UseLongIds"),
    ),
  }),
).annotate({ identifier: "IdFormat" }) as any as S.Schema<IdFormat>;
export type IdFormatList = IdFormat[];
export const IdFormatList = S.Array(
  IdFormat.pipe(T.XmlName("item")).annotate({ identifier: "IdFormat" }),
);
export interface DescribeAggregateIdFormatResult {
  UseLongIdsAggregated?: boolean;
  Statuses?: IdFormat[];
}
export const DescribeAggregateIdFormatResult = S.suspend(() =>
  S.Struct({
    UseLongIdsAggregated: S.optional(S.Boolean).pipe(
      T.XmlName("useLongIdsAggregated"),
      T.Ec2QueryName("UseLongIdsAggregated"),
    ),
    Statuses: S.optional(IdFormatList).pipe(
      T.XmlName("statusSet"),
      T.Ec2QueryName("StatusSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeAggregateIdFormatResult",
}) as any as S.Schema<DescribeAggregateIdFormatResult>;
export type ZoneNameStringList = string[];
export const ZoneNameStringList = S.Array(S.String.pipe(T.XmlName("ZoneName")));
export type ZoneIdStringList = string[];
export const ZoneIdStringList = S.Array(S.String.pipe(T.XmlName("ZoneId")));
export interface DescribeAvailabilityZonesRequest {
  ZoneNames?: string[];
  ZoneIds?: string[];
  AllAvailabilityZones?: boolean;
  DryRun?: boolean;
  Filters?: Filter[];
}
export const DescribeAvailabilityZonesRequest = S.suspend(() =>
  S.Struct({
    ZoneNames: S.optional(ZoneNameStringList).pipe(T.XmlName("ZoneName")),
    ZoneIds: S.optional(ZoneIdStringList).pipe(T.XmlName("ZoneId")),
    AllAvailabilityZones: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeAvailabilityZonesRequest",
}) as any as S.Schema<DescribeAvailabilityZonesRequest>;
export type AvailabilityZoneOptInStatus =
  | "opt-in-not-required"
  | "opted-in"
  | "not-opted-in"
  | (string & {});
export const AvailabilityZoneOptInStatus = S.String;
export interface AvailabilityZoneMessage {
  Message?: string;
}
export const AvailabilityZoneMessage = S.suspend(() =>
  S.Struct({
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "AvailabilityZoneMessage",
}) as any as S.Schema<AvailabilityZoneMessage>;
export type AvailabilityZoneMessageList = AvailabilityZoneMessage[];
export const AvailabilityZoneMessageList = S.Array(
  AvailabilityZoneMessage.pipe(T.XmlName("item")).annotate({
    identifier: "AvailabilityZoneMessage",
  }),
);
export interface AvailabilityZoneGeography {
  Name?: string;
}
export const AvailabilityZoneGeography = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
  }),
).annotate({
  identifier: "AvailabilityZoneGeography",
}) as any as S.Schema<AvailabilityZoneGeography>;
export type AvailabilityZoneGeographyList = AvailabilityZoneGeography[];
export const AvailabilityZoneGeographyList = S.Array(
  AvailabilityZoneGeography.pipe(T.XmlName("item")).annotate({
    identifier: "AvailabilityZoneGeography",
  }),
);
export interface AvailabilityZoneSubGeography {
  Name?: string;
}
export const AvailabilityZoneSubGeography = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
  }),
).annotate({
  identifier: "AvailabilityZoneSubGeography",
}) as any as S.Schema<AvailabilityZoneSubGeography>;
export type AvailabilityZoneSubGeographyList = AvailabilityZoneSubGeography[];
export const AvailabilityZoneSubGeographyList = S.Array(
  AvailabilityZoneSubGeography.pipe(T.XmlName("item")).annotate({
    identifier: "AvailabilityZoneSubGeography",
  }),
);
export type AvailabilityZoneState =
  | "available"
  | "information"
  | "impaired"
  | "unavailable"
  | "constrained"
  | (string & {});
export const AvailabilityZoneState = S.String;
export interface AvailabilityZone {
  OptInStatus?: AvailabilityZoneOptInStatus;
  Messages?: AvailabilityZoneMessage[];
  RegionName?: string;
  ZoneName?: string;
  ZoneId?: string;
  GroupName?: string;
  NetworkBorderGroup?: string;
  ZoneType?: string;
  ParentZoneName?: string;
  ParentZoneId?: string;
  GroupLongName?: string;
  Geography?: AvailabilityZoneGeography[];
  SubGeography?: AvailabilityZoneSubGeography[];
  State?: AvailabilityZoneState;
}
export const AvailabilityZone = S.suspend(() =>
  S.Struct({
    OptInStatus: S.optional(AvailabilityZoneOptInStatus).pipe(
      T.XmlName("optInStatus"),
      T.Ec2QueryName("OptInStatus"),
    ),
    Messages: S.optional(AvailabilityZoneMessageList).pipe(
      T.XmlName("messageSet"),
      T.Ec2QueryName("MessageSet"),
    ),
    RegionName: S.optional(S.String).pipe(
      T.XmlName("regionName"),
      T.Ec2QueryName("RegionName"),
    ),
    ZoneName: S.optional(S.String).pipe(
      T.XmlName("zoneName"),
      T.Ec2QueryName("ZoneName"),
    ),
    ZoneId: S.optional(S.String).pipe(
      T.XmlName("zoneId"),
      T.Ec2QueryName("ZoneId"),
    ),
    GroupName: S.optional(S.String).pipe(
      T.XmlName("groupName"),
      T.Ec2QueryName("GroupName"),
    ),
    NetworkBorderGroup: S.optional(S.String).pipe(
      T.XmlName("networkBorderGroup"),
      T.Ec2QueryName("NetworkBorderGroup"),
    ),
    ZoneType: S.optional(S.String).pipe(
      T.XmlName("zoneType"),
      T.Ec2QueryName("ZoneType"),
    ),
    ParentZoneName: S.optional(S.String).pipe(
      T.XmlName("parentZoneName"),
      T.Ec2QueryName("ParentZoneName"),
    ),
    ParentZoneId: S.optional(S.String).pipe(
      T.XmlName("parentZoneId"),
      T.Ec2QueryName("ParentZoneId"),
    ),
    GroupLongName: S.optional(S.String).pipe(
      T.XmlName("groupLongName"),
      T.Ec2QueryName("GroupLongName"),
    ),
    Geography: S.optional(AvailabilityZoneGeographyList).pipe(
      T.XmlName("geographySet"),
      T.Ec2QueryName("GeographySet"),
    ),
    SubGeography: S.optional(AvailabilityZoneSubGeographyList).pipe(
      T.XmlName("subGeographySet"),
      T.Ec2QueryName("SubGeographySet"),
    ),
    State: S.optional(AvailabilityZoneState).pipe(
      T.XmlName("zoneState"),
      T.Ec2QueryName("ZoneState"),
    ),
  }),
).annotate({
  identifier: "AvailabilityZone",
}) as any as S.Schema<AvailabilityZone>;
export type AvailabilityZoneList = AvailabilityZone[];
export const AvailabilityZoneList = S.Array(
  AvailabilityZone.pipe(T.XmlName("item")).annotate({
    identifier: "AvailabilityZone",
  }),
);
export interface DescribeAvailabilityZonesResult {
  AvailabilityZones?: AvailabilityZone[];
}
export const DescribeAvailabilityZonesResult = S.suspend(() =>
  S.Struct({
    AvailabilityZones: S.optional(AvailabilityZoneList).pipe(
      T.XmlName("availabilityZoneInfo"),
      T.Ec2QueryName("AvailabilityZoneInfo"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeAvailabilityZonesResult",
}) as any as S.Schema<DescribeAvailabilityZonesResult>;
export interface DescribeAwsNetworkPerformanceMetricSubscriptionsRequest {
  MaxResults?: number;
  NextToken?: string;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeAwsNetworkPerformanceMetricSubscriptionsRequest =
  S.suspend(() =>
    S.Struct({
      MaxResults: S.optional(S.Number),
      NextToken: S.optional(S.String),
      Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
  ).annotate({
    identifier: "DescribeAwsNetworkPerformanceMetricSubscriptionsRequest",
  }) as any as S.Schema<DescribeAwsNetworkPerformanceMetricSubscriptionsRequest>;
export type MetricType = "aggregate-latency" | (string & {});
export const MetricType = S.String;
export type StatisticType = "p50" | (string & {});
export const StatisticType = S.String;
export type PeriodType =
  | "five-minutes"
  | "fifteen-minutes"
  | "one-hour"
  | "three-hours"
  | "one-day"
  | "one-week"
  | (string & {});
export const PeriodType = S.String;
export interface Subscription {
  Source?: string;
  Destination?: string;
  Metric?: MetricType;
  Statistic?: StatisticType;
  Period?: PeriodType;
}
export const Subscription = S.suspend(() =>
  S.Struct({
    Source: S.optional(S.String).pipe(
      T.XmlName("source"),
      T.Ec2QueryName("Source"),
    ),
    Destination: S.optional(S.String).pipe(
      T.XmlName("destination"),
      T.Ec2QueryName("Destination"),
    ),
    Metric: S.optional(MetricType).pipe(
      T.XmlName("metric"),
      T.Ec2QueryName("Metric"),
    ),
    Statistic: S.optional(StatisticType).pipe(
      T.XmlName("statistic"),
      T.Ec2QueryName("Statistic"),
    ),
    Period: S.optional(PeriodType).pipe(
      T.XmlName("period"),
      T.Ec2QueryName("Period"),
    ),
  }),
).annotate({ identifier: "Subscription" }) as any as S.Schema<Subscription>;
export type SubscriptionList = Subscription[];
export const SubscriptionList = S.Array(
  Subscription.pipe(T.XmlName("item")).annotate({ identifier: "Subscription" }),
);
export interface DescribeAwsNetworkPerformanceMetricSubscriptionsResult {
  NextToken?: string;
  Subscriptions?: Subscription[];
}
export const DescribeAwsNetworkPerformanceMetricSubscriptionsResult = S.suspend(
  () =>
    S.Struct({
      NextToken: S.optional(S.String).pipe(
        T.XmlName("nextToken"),
        T.Ec2QueryName("NextToken"),
      ),
      Subscriptions: S.optional(SubscriptionList).pipe(
        T.XmlName("subscriptionSet"),
        T.Ec2QueryName("SubscriptionSet"),
      ),
    }).pipe(ns),
).annotate({
  identifier: "DescribeAwsNetworkPerformanceMetricSubscriptionsResult",
}) as any as S.Schema<DescribeAwsNetworkPerformanceMetricSubscriptionsResult>;
export type BundleIdStringList = string[];
export const BundleIdStringList = S.Array(S.String.pipe(T.XmlName("BundleId")));
export interface DescribeBundleTasksRequest {
  BundleIds?: string[];
  DryRun?: boolean;
  Filters?: Filter[];
}
export const DescribeBundleTasksRequest = S.suspend(() =>
  S.Struct({
    BundleIds: S.optional(BundleIdStringList).pipe(T.XmlName("BundleId")),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeBundleTasksRequest",
}) as any as S.Schema<DescribeBundleTasksRequest>;
export type BundleTaskList = BundleTask[];
export const BundleTaskList = S.Array(
  BundleTask.pipe(T.XmlName("item")).annotate({ identifier: "BundleTask" }),
);
export interface DescribeBundleTasksResult {
  BundleTasks?: BundleTask[];
}
export const DescribeBundleTasksResult = S.suspend(() =>
  S.Struct({
    BundleTasks: S.optional(BundleTaskList).pipe(
      T.XmlName("bundleInstanceTasksSet"),
      T.Ec2QueryName("BundleInstanceTasksSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeBundleTasksResult",
}) as any as S.Schema<DescribeBundleTasksResult>;
export interface DescribeByoipCidrsRequest {
  DryRun?: boolean;
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeByoipCidrsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeByoipCidrsRequest",
}) as any as S.Schema<DescribeByoipCidrsRequest>;
export type ByoipCidrSet = ByoipCidr[];
export const ByoipCidrSet = S.Array(
  ByoipCidr.pipe(T.XmlName("item")).annotate({ identifier: "ByoipCidr" }),
);
export interface DescribeByoipCidrsResult {
  ByoipCidrs?: ByoipCidr[];
  NextToken?: string;
}
export const DescribeByoipCidrsResult = S.suspend(() =>
  S.Struct({
    ByoipCidrs: S.optional(ByoipCidrSet).pipe(
      T.XmlName("byoipCidrSet"),
      T.Ec2QueryName("ByoipCidrSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeByoipCidrsResult",
}) as any as S.Schema<DescribeByoipCidrsResult>;
export type CapacityReservationIdSet = string[];
export const CapacityReservationIdSet = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeCapacityBlockExtensionHistoryRequest {
  CapacityReservationIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeCapacityBlockExtensionHistoryRequest = S.suspend(() =>
  S.Struct({
    CapacityReservationIds: S.optional(CapacityReservationIdSet).pipe(
      T.XmlName("CapacityReservationId"),
    ),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeCapacityBlockExtensionHistoryRequest",
}) as any as S.Schema<DescribeCapacityBlockExtensionHistoryRequest>;
export type CapacityBlockExtensionStatus =
  | "payment-pending"
  | "payment-failed"
  | "payment-succeeded"
  | (string & {});
export const CapacityBlockExtensionStatus = S.String;
export interface CapacityBlockExtension {
  CapacityReservationId?: string;
  InstanceType?: string;
  InstanceCount?: number;
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  CapacityBlockExtensionOfferingId?: string;
  CapacityBlockExtensionDurationHours?: number;
  CapacityBlockExtensionStatus?: CapacityBlockExtensionStatus;
  CapacityBlockExtensionPurchaseDate?: Date;
  CapacityBlockExtensionStartDate?: Date;
  CapacityBlockExtensionEndDate?: Date;
  UpfrontFee?: string;
  CurrencyCode?: string;
  ZoneType?: string;
}
export const CapacityBlockExtension = S.suspend(() =>
  S.Struct({
    CapacityReservationId: S.optional(S.String).pipe(
      T.XmlName("capacityReservationId"),
      T.Ec2QueryName("CapacityReservationId"),
    ),
    InstanceType: S.optional(S.String).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    InstanceCount: S.optional(S.Number).pipe(
      T.XmlName("instanceCount"),
      T.Ec2QueryName("InstanceCount"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    CapacityBlockExtensionOfferingId: S.optional(S.String).pipe(
      T.XmlName("capacityBlockExtensionOfferingId"),
      T.Ec2QueryName("CapacityBlockExtensionOfferingId"),
    ),
    CapacityBlockExtensionDurationHours: S.optional(S.Number).pipe(
      T.XmlName("capacityBlockExtensionDurationHours"),
      T.Ec2QueryName("CapacityBlockExtensionDurationHours"),
    ),
    CapacityBlockExtensionStatus: S.optional(CapacityBlockExtensionStatus).pipe(
      T.XmlName("capacityBlockExtensionStatus"),
      T.Ec2QueryName("CapacityBlockExtensionStatus"),
    ),
    CapacityBlockExtensionPurchaseDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("capacityBlockExtensionPurchaseDate"),
      T.Ec2QueryName("CapacityBlockExtensionPurchaseDate"),
    ),
    CapacityBlockExtensionStartDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("capacityBlockExtensionStartDate"),
      T.Ec2QueryName("CapacityBlockExtensionStartDate"),
    ),
    CapacityBlockExtensionEndDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("capacityBlockExtensionEndDate"),
      T.Ec2QueryName("CapacityBlockExtensionEndDate"),
    ),
    UpfrontFee: S.optional(S.String).pipe(
      T.XmlName("upfrontFee"),
      T.Ec2QueryName("UpfrontFee"),
    ),
    CurrencyCode: S.optional(S.String).pipe(
      T.XmlName("currencyCode"),
      T.Ec2QueryName("CurrencyCode"),
    ),
    ZoneType: S.optional(S.String).pipe(
      T.XmlName("zoneType"),
      T.Ec2QueryName("ZoneType"),
    ),
  }),
).annotate({
  identifier: "CapacityBlockExtension",
}) as any as S.Schema<CapacityBlockExtension>;
export type CapacityBlockExtensionSet = CapacityBlockExtension[];
export const CapacityBlockExtensionSet = S.Array(
  CapacityBlockExtension.pipe(T.XmlName("item")).annotate({
    identifier: "CapacityBlockExtension",
  }),
);
export interface DescribeCapacityBlockExtensionHistoryResult {
  CapacityBlockExtensions?: CapacityBlockExtension[];
  NextToken?: string;
}
export const DescribeCapacityBlockExtensionHistoryResult = S.suspend(() =>
  S.Struct({
    CapacityBlockExtensions: S.optional(CapacityBlockExtensionSet).pipe(
      T.XmlName("capacityBlockExtensionSet"),
      T.Ec2QueryName("CapacityBlockExtensionSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeCapacityBlockExtensionHistoryResult",
}) as any as S.Schema<DescribeCapacityBlockExtensionHistoryResult>;
export interface DescribeCapacityBlockExtensionOfferingsRequest {
  DryRun?: boolean;
  CapacityBlockExtensionDurationHours?: number;
  CapacityReservationId?: string;
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeCapacityBlockExtensionOfferingsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    CapacityBlockExtensionDurationHours: S.optional(S.Number),
    CapacityReservationId: S.optional(S.String),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeCapacityBlockExtensionOfferingsRequest",
}) as any as S.Schema<DescribeCapacityBlockExtensionOfferingsRequest>;
export interface CapacityBlockExtensionOffering {
  CapacityBlockExtensionOfferingId?: string;
  InstanceType?: string;
  InstanceCount?: number;
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  StartDate?: Date;
  CapacityBlockExtensionStartDate?: Date;
  CapacityBlockExtensionEndDate?: Date;
  CapacityBlockExtensionDurationHours?: number;
  UpfrontFee?: string;
  CurrencyCode?: string;
  Tenancy?: CapacityReservationTenancy;
  ZoneType?: string;
}
export const CapacityBlockExtensionOffering = S.suspend(() =>
  S.Struct({
    CapacityBlockExtensionOfferingId: S.optional(S.String).pipe(
      T.XmlName("capacityBlockExtensionOfferingId"),
      T.Ec2QueryName("CapacityBlockExtensionOfferingId"),
    ),
    InstanceType: S.optional(S.String).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    InstanceCount: S.optional(S.Number).pipe(
      T.XmlName("instanceCount"),
      T.Ec2QueryName("InstanceCount"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    StartDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startDate"), T.Ec2QueryName("StartDate")),
    CapacityBlockExtensionStartDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("capacityBlockExtensionStartDate"),
      T.Ec2QueryName("CapacityBlockExtensionStartDate"),
    ),
    CapacityBlockExtensionEndDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("capacityBlockExtensionEndDate"),
      T.Ec2QueryName("CapacityBlockExtensionEndDate"),
    ),
    CapacityBlockExtensionDurationHours: S.optional(S.Number).pipe(
      T.XmlName("capacityBlockExtensionDurationHours"),
      T.Ec2QueryName("CapacityBlockExtensionDurationHours"),
    ),
    UpfrontFee: S.optional(S.String).pipe(
      T.XmlName("upfrontFee"),
      T.Ec2QueryName("UpfrontFee"),
    ),
    CurrencyCode: S.optional(S.String).pipe(
      T.XmlName("currencyCode"),
      T.Ec2QueryName("CurrencyCode"),
    ),
    Tenancy: S.optional(CapacityReservationTenancy).pipe(
      T.XmlName("tenancy"),
      T.Ec2QueryName("Tenancy"),
    ),
    ZoneType: S.optional(S.String).pipe(
      T.XmlName("zoneType"),
      T.Ec2QueryName("ZoneType"),
    ),
  }),
).annotate({
  identifier: "CapacityBlockExtensionOffering",
}) as any as S.Schema<CapacityBlockExtensionOffering>;
export type CapacityBlockExtensionOfferingSet =
  CapacityBlockExtensionOffering[];
export const CapacityBlockExtensionOfferingSet = S.Array(
  CapacityBlockExtensionOffering.pipe(T.XmlName("item")).annotate({
    identifier: "CapacityBlockExtensionOffering",
  }),
);
export interface DescribeCapacityBlockExtensionOfferingsResult {
  CapacityBlockExtensionOfferings?: CapacityBlockExtensionOffering[];
  NextToken?: string;
}
export const DescribeCapacityBlockExtensionOfferingsResult = S.suspend(() =>
  S.Struct({
    CapacityBlockExtensionOfferings: S.optional(
      CapacityBlockExtensionOfferingSet,
    ).pipe(
      T.XmlName("capacityBlockExtensionOfferingSet"),
      T.Ec2QueryName("CapacityBlockExtensionOfferingSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeCapacityBlockExtensionOfferingsResult",
}) as any as S.Schema<DescribeCapacityBlockExtensionOfferingsResult>;
export interface DescribeCapacityBlockOfferingsRequest {
  DryRun?: boolean;
  InstanceType?: string;
  InstanceCount?: number;
  StartDateRange?: Date;
  EndDateRange?: Date;
  CapacityDurationHours?: number;
  NextToken?: string;
  MaxResults?: number;
  UltraserverType?: string;
  UltraserverCount?: number;
  AllAvailabilityZones?: boolean;
}
export const DescribeCapacityBlockOfferingsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    InstanceType: S.optional(S.String),
    InstanceCount: S.optional(S.Number),
    StartDateRange: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    EndDateRange: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    CapacityDurationHours: S.optional(S.Number),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    UltraserverType: S.optional(S.String),
    UltraserverCount: S.optional(S.Number),
    AllAvailabilityZones: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeCapacityBlockOfferingsRequest",
}) as any as S.Schema<DescribeCapacityBlockOfferingsRequest>;
export interface CapacityBlockOffering {
  CapacityBlockOfferingId?: string;
  InstanceType?: string;
  AvailabilityZone?: string;
  InstanceCount?: number;
  StartDate?: Date;
  EndDate?: Date;
  CapacityBlockDurationHours?: number;
  UpfrontFee?: string;
  CurrencyCode?: string;
  Tenancy?: CapacityReservationTenancy;
  UltraserverType?: string;
  UltraserverCount?: number;
  CapacityBlockDurationMinutes?: number;
  ZoneType?: string;
}
export const CapacityBlockOffering = S.suspend(() =>
  S.Struct({
    CapacityBlockOfferingId: S.optional(S.String).pipe(
      T.XmlName("capacityBlockOfferingId"),
      T.Ec2QueryName("CapacityBlockOfferingId"),
    ),
    InstanceType: S.optional(S.String).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    InstanceCount: S.optional(S.Number).pipe(
      T.XmlName("instanceCount"),
      T.Ec2QueryName("InstanceCount"),
    ),
    StartDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startDate"), T.Ec2QueryName("StartDate")),
    EndDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("endDate"), T.Ec2QueryName("EndDate")),
    CapacityBlockDurationHours: S.optional(S.Number).pipe(
      T.XmlName("capacityBlockDurationHours"),
      T.Ec2QueryName("CapacityBlockDurationHours"),
    ),
    UpfrontFee: S.optional(S.String).pipe(
      T.XmlName("upfrontFee"),
      T.Ec2QueryName("UpfrontFee"),
    ),
    CurrencyCode: S.optional(S.String).pipe(
      T.XmlName("currencyCode"),
      T.Ec2QueryName("CurrencyCode"),
    ),
    Tenancy: S.optional(CapacityReservationTenancy).pipe(
      T.XmlName("tenancy"),
      T.Ec2QueryName("Tenancy"),
    ),
    UltraserverType: S.optional(S.String).pipe(
      T.XmlName("ultraserverType"),
      T.Ec2QueryName("UltraserverType"),
    ),
    UltraserverCount: S.optional(S.Number).pipe(
      T.XmlName("ultraserverCount"),
      T.Ec2QueryName("UltraserverCount"),
    ),
    CapacityBlockDurationMinutes: S.optional(S.Number).pipe(
      T.XmlName("capacityBlockDurationMinutes"),
      T.Ec2QueryName("CapacityBlockDurationMinutes"),
    ),
    ZoneType: S.optional(S.String).pipe(
      T.XmlName("zoneType"),
      T.Ec2QueryName("ZoneType"),
    ),
  }),
).annotate({
  identifier: "CapacityBlockOffering",
}) as any as S.Schema<CapacityBlockOffering>;
export type CapacityBlockOfferingSet = CapacityBlockOffering[];
export const CapacityBlockOfferingSet = S.Array(
  CapacityBlockOffering.pipe(T.XmlName("item")).annotate({
    identifier: "CapacityBlockOffering",
  }),
);
export interface DescribeCapacityBlockOfferingsResult {
  CapacityBlockOfferings?: CapacityBlockOffering[];
  NextToken?: string;
}
export const DescribeCapacityBlockOfferingsResult = S.suspend(() =>
  S.Struct({
    CapacityBlockOfferings: S.optional(CapacityBlockOfferingSet).pipe(
      T.XmlName("capacityBlockOfferingSet"),
      T.Ec2QueryName("CapacityBlockOfferingSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeCapacityBlockOfferingsResult",
}) as any as S.Schema<DescribeCapacityBlockOfferingsResult>;
export type CapacityBlockIds = string[];
export const CapacityBlockIds = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeCapacityBlocksRequest {
  CapacityBlockIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeCapacityBlocksRequest = S.suspend(() =>
  S.Struct({
    CapacityBlockIds: S.optional(CapacityBlockIds).pipe(
      T.XmlName("CapacityBlockId"),
    ),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeCapacityBlocksRequest",
}) as any as S.Schema<DescribeCapacityBlocksRequest>;
export type CapacityBlockResourceState =
  | "active"
  | "expired"
  | "unavailable"
  | "cancelled"
  | "failed"
  | "scheduled"
  | "payment-pending"
  | "payment-failed"
  | (string & {});
export const CapacityBlockResourceState = S.String;
export interface CapacityBlock {
  CapacityBlockId?: string;
  UltraserverType?: string;
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  CapacityReservationIds?: string[];
  StartDate?: Date;
  EndDate?: Date;
  CreateDate?: Date;
  State?: CapacityBlockResourceState;
  Tags?: Tag[];
}
export const CapacityBlock = S.suspend(() =>
  S.Struct({
    CapacityBlockId: S.optional(S.String).pipe(
      T.XmlName("capacityBlockId"),
      T.Ec2QueryName("CapacityBlockId"),
    ),
    UltraserverType: S.optional(S.String).pipe(
      T.XmlName("ultraserverType"),
      T.Ec2QueryName("UltraserverType"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    CapacityReservationIds: S.optional(CapacityReservationIdSet).pipe(
      T.XmlName("capacityReservationIdSet"),
      T.Ec2QueryName("CapacityReservationIdSet"),
    ),
    StartDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startDate"), T.Ec2QueryName("StartDate")),
    EndDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("endDate"), T.Ec2QueryName("EndDate")),
    CreateDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createDate"), T.Ec2QueryName("CreateDate")),
    State: S.optional(CapacityBlockResourceState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({ identifier: "CapacityBlock" }) as any as S.Schema<CapacityBlock>;
export type CapacityBlockSet = CapacityBlock[];
export const CapacityBlockSet = S.Array(
  CapacityBlock.pipe(T.XmlName("item")).annotate({
    identifier: "CapacityBlock",
  }),
);
export interface DescribeCapacityBlocksResult {
  CapacityBlocks?: CapacityBlock[];
  NextToken?: string;
}
export const DescribeCapacityBlocksResult = S.suspend(() =>
  S.Struct({
    CapacityBlocks: S.optional(CapacityBlockSet).pipe(
      T.XmlName("capacityBlockSet"),
      T.Ec2QueryName("CapacityBlockSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeCapacityBlocksResult",
}) as any as S.Schema<DescribeCapacityBlocksResult>;
export interface DescribeCapacityBlockStatusRequest {
  CapacityBlockIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeCapacityBlockStatusRequest = S.suspend(() =>
  S.Struct({
    CapacityBlockIds: S.optional(CapacityBlockIds).pipe(
      T.XmlName("CapacityBlockId"),
    ),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeCapacityBlockStatusRequest",
}) as any as S.Schema<DescribeCapacityBlockStatusRequest>;
export type CapacityBlockInterconnectStatus =
  | "ok"
  | "impaired"
  | "insufficient-data"
  | (string & {});
export const CapacityBlockInterconnectStatus = S.String;
export interface CapacityReservationStatus {
  CapacityReservationId?: string;
  TotalCapacity?: number;
  TotalAvailableCapacity?: number;
  TotalUnavailableCapacity?: number;
}
export const CapacityReservationStatus = S.suspend(() =>
  S.Struct({
    CapacityReservationId: S.optional(S.String).pipe(
      T.XmlName("capacityReservationId"),
      T.Ec2QueryName("CapacityReservationId"),
    ),
    TotalCapacity: S.optional(S.Number).pipe(
      T.XmlName("totalCapacity"),
      T.Ec2QueryName("TotalCapacity"),
    ),
    TotalAvailableCapacity: S.optional(S.Number).pipe(
      T.XmlName("totalAvailableCapacity"),
      T.Ec2QueryName("TotalAvailableCapacity"),
    ),
    TotalUnavailableCapacity: S.optional(S.Number).pipe(
      T.XmlName("totalUnavailableCapacity"),
      T.Ec2QueryName("TotalUnavailableCapacity"),
    ),
  }),
).annotate({
  identifier: "CapacityReservationStatus",
}) as any as S.Schema<CapacityReservationStatus>;
export type CapacityReservationStatusSet = CapacityReservationStatus[];
export const CapacityReservationStatusSet = S.Array(
  CapacityReservationStatus.pipe(T.XmlName("item")).annotate({
    identifier: "CapacityReservationStatus",
  }),
);
export interface CapacityBlockStatus {
  CapacityBlockId?: string;
  InterconnectStatus?: CapacityBlockInterconnectStatus;
  TotalCapacity?: number;
  TotalAvailableCapacity?: number;
  TotalUnavailableCapacity?: number;
  CapacityReservationStatuses?: CapacityReservationStatus[];
}
export const CapacityBlockStatus = S.suspend(() =>
  S.Struct({
    CapacityBlockId: S.optional(S.String).pipe(
      T.XmlName("capacityBlockId"),
      T.Ec2QueryName("CapacityBlockId"),
    ),
    InterconnectStatus: S.optional(CapacityBlockInterconnectStatus).pipe(
      T.XmlName("interconnectStatus"),
      T.Ec2QueryName("InterconnectStatus"),
    ),
    TotalCapacity: S.optional(S.Number).pipe(
      T.XmlName("totalCapacity"),
      T.Ec2QueryName("TotalCapacity"),
    ),
    TotalAvailableCapacity: S.optional(S.Number).pipe(
      T.XmlName("totalAvailableCapacity"),
      T.Ec2QueryName("TotalAvailableCapacity"),
    ),
    TotalUnavailableCapacity: S.optional(S.Number).pipe(
      T.XmlName("totalUnavailableCapacity"),
      T.Ec2QueryName("TotalUnavailableCapacity"),
    ),
    CapacityReservationStatuses: S.optional(CapacityReservationStatusSet).pipe(
      T.XmlName("capacityReservationStatusSet"),
      T.Ec2QueryName("CapacityReservationStatusSet"),
    ),
  }),
).annotate({
  identifier: "CapacityBlockStatus",
}) as any as S.Schema<CapacityBlockStatus>;
export type CapacityBlockStatusSet = CapacityBlockStatus[];
export const CapacityBlockStatusSet = S.Array(
  CapacityBlockStatus.pipe(T.XmlName("item")).annotate({
    identifier: "CapacityBlockStatus",
  }),
);
export interface DescribeCapacityBlockStatusResult {
  CapacityBlockStatuses?: CapacityBlockStatus[];
  NextToken?: string;
}
export const DescribeCapacityBlockStatusResult = S.suspend(() =>
  S.Struct({
    CapacityBlockStatuses: S.optional(CapacityBlockStatusSet).pipe(
      T.XmlName("capacityBlockStatusSet"),
      T.Ec2QueryName("CapacityBlockStatusSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeCapacityBlockStatusResult",
}) as any as S.Schema<DescribeCapacityBlockStatusResult>;
export type CapacityManagerDataExportIdSet = string[];
export const CapacityManagerDataExportIdSet = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeCapacityManagerDataExportsRequest {
  CapacityManagerDataExportIds?: string[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
  Filters?: Filter[];
}
export const DescribeCapacityManagerDataExportsRequest = S.suspend(() =>
  S.Struct({
    CapacityManagerDataExportIds: S.optional(
      CapacityManagerDataExportIdSet,
    ).pipe(T.XmlName("CapacityManagerDataExportId")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeCapacityManagerDataExportsRequest",
}) as any as S.Schema<DescribeCapacityManagerDataExportsRequest>;
export type CapacityManagerDataExportStatus =
  | "pending"
  | "in-progress"
  | "delivered"
  | "failed"
  | (string & {});
export const CapacityManagerDataExportStatus = S.String;
export interface CapacityManagerDataExportResponse {
  CapacityManagerDataExportId?: string;
  S3BucketName?: string;
  S3BucketPrefix?: string;
  Schedule?: Schedule;
  OutputFormat?: OutputFormat;
  CreateTime?: Date;
  LatestDeliveryStatus?: CapacityManagerDataExportStatus;
  LatestDeliveryStatusMessage?: string;
  LatestDeliveryS3LocationUri?: string;
  LatestDeliveryTime?: Date;
  Tags?: Tag[];
}
export const CapacityManagerDataExportResponse = S.suspend(() =>
  S.Struct({
    CapacityManagerDataExportId: S.optional(S.String).pipe(
      T.XmlName("capacityManagerDataExportId"),
      T.Ec2QueryName("CapacityManagerDataExportId"),
    ),
    S3BucketName: S.optional(S.String).pipe(
      T.XmlName("s3BucketName"),
      T.Ec2QueryName("S3BucketName"),
    ),
    S3BucketPrefix: S.optional(S.String).pipe(
      T.XmlName("s3BucketPrefix"),
      T.Ec2QueryName("S3BucketPrefix"),
    ),
    Schedule: S.optional(Schedule).pipe(
      T.XmlName("schedule"),
      T.Ec2QueryName("Schedule"),
    ),
    OutputFormat: S.optional(OutputFormat).pipe(
      T.XmlName("outputFormat"),
      T.Ec2QueryName("OutputFormat"),
    ),
    CreateTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createTime"), T.Ec2QueryName("CreateTime")),
    LatestDeliveryStatus: S.optional(CapacityManagerDataExportStatus).pipe(
      T.XmlName("latestDeliveryStatus"),
      T.Ec2QueryName("LatestDeliveryStatus"),
    ),
    LatestDeliveryStatusMessage: S.optional(S.String).pipe(
      T.XmlName("latestDeliveryStatusMessage"),
      T.Ec2QueryName("LatestDeliveryStatusMessage"),
    ),
    LatestDeliveryS3LocationUri: S.optional(S.String).pipe(
      T.XmlName("latestDeliveryS3LocationUri"),
      T.Ec2QueryName("LatestDeliveryS3LocationUri"),
    ),
    LatestDeliveryTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("latestDeliveryTime"),
      T.Ec2QueryName("LatestDeliveryTime"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "CapacityManagerDataExportResponse",
}) as any as S.Schema<CapacityManagerDataExportResponse>;
export type CapacityManagerDataExportResponseSet =
  CapacityManagerDataExportResponse[];
export const CapacityManagerDataExportResponseSet = S.Array(
  CapacityManagerDataExportResponse.pipe(T.XmlName("item")).annotate({
    identifier: "CapacityManagerDataExportResponse",
  }),
);
export interface DescribeCapacityManagerDataExportsResult {
  CapacityManagerDataExports?: CapacityManagerDataExportResponse[];
  NextToken?: string;
}
export const DescribeCapacityManagerDataExportsResult = S.suspend(() =>
  S.Struct({
    CapacityManagerDataExports: S.optional(
      CapacityManagerDataExportResponseSet,
    ).pipe(
      T.XmlName("capacityManagerDataExportSet"),
      T.Ec2QueryName("CapacityManagerDataExportSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeCapacityManagerDataExportsResult",
}) as any as S.Schema<DescribeCapacityManagerDataExportsResult>;
export type CallerRole =
  | "odcr-owner"
  | "unused-reservation-billing-owner"
  | (string & {});
export const CallerRole = S.String;
export interface DescribeCapacityReservationBillingRequestsRequest {
  CapacityReservationIds?: string[];
  Role?: CallerRole;
  NextToken?: string;
  MaxResults?: number;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeCapacityReservationBillingRequestsRequest = S.suspend(() =>
  S.Struct({
    CapacityReservationIds: S.optional(CapacityReservationIdSet).pipe(
      T.XmlName("CapacityReservationId"),
    ),
    Role: S.optional(CallerRole),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeCapacityReservationBillingRequestsRequest",
}) as any as S.Schema<DescribeCapacityReservationBillingRequestsRequest>;
export type CapacityReservationBillingRequestStatus =
  | "pending"
  | "accepted"
  | "rejected"
  | "cancelled"
  | "revoked"
  | "expired"
  | (string & {});
export const CapacityReservationBillingRequestStatus = S.String;
export interface CapacityReservationInfo {
  InstanceType?: string;
  AvailabilityZone?: string;
  Tenancy?: CapacityReservationTenancy;
  AvailabilityZoneId?: string;
}
export const CapacityReservationInfo = S.suspend(() =>
  S.Struct({
    InstanceType: S.optional(S.String).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    Tenancy: S.optional(CapacityReservationTenancy).pipe(
      T.XmlName("tenancy"),
      T.Ec2QueryName("Tenancy"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
  }),
).annotate({
  identifier: "CapacityReservationInfo",
}) as any as S.Schema<CapacityReservationInfo>;
export interface CapacityReservationBillingRequest {
  CapacityReservationId?: string;
  RequestedBy?: string;
  UnusedReservationBillingOwnerId?: string;
  LastUpdateTime?: Date;
  Status?: CapacityReservationBillingRequestStatus;
  StatusMessage?: string;
  CapacityReservationInfo?: CapacityReservationInfo;
}
export const CapacityReservationBillingRequest = S.suspend(() =>
  S.Struct({
    CapacityReservationId: S.optional(S.String).pipe(
      T.XmlName("capacityReservationId"),
      T.Ec2QueryName("CapacityReservationId"),
    ),
    RequestedBy: S.optional(S.String).pipe(
      T.XmlName("requestedBy"),
      T.Ec2QueryName("RequestedBy"),
    ),
    UnusedReservationBillingOwnerId: S.optional(S.String).pipe(
      T.XmlName("unusedReservationBillingOwnerId"),
      T.Ec2QueryName("UnusedReservationBillingOwnerId"),
    ),
    LastUpdateTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("lastUpdateTime"), T.Ec2QueryName("LastUpdateTime")),
    Status: S.optional(CapacityReservationBillingRequestStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    CapacityReservationInfo: S.optional(CapacityReservationInfo)
      .pipe(
        T.XmlName("capacityReservationInfo"),
        T.Ec2QueryName("CapacityReservationInfo"),
      )
      .annotate({ identifier: "CapacityReservationInfo" }),
  }),
).annotate({
  identifier: "CapacityReservationBillingRequest",
}) as any as S.Schema<CapacityReservationBillingRequest>;
export type CapacityReservationBillingRequestSet =
  CapacityReservationBillingRequest[];
export const CapacityReservationBillingRequestSet = S.Array(
  CapacityReservationBillingRequest.pipe(T.XmlName("item")).annotate({
    identifier: "CapacityReservationBillingRequest",
  }),
);
export interface DescribeCapacityReservationBillingRequestsResult {
  NextToken?: string;
  CapacityReservationBillingRequests?: CapacityReservationBillingRequest[];
}
export const DescribeCapacityReservationBillingRequestsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    CapacityReservationBillingRequests: S.optional(
      CapacityReservationBillingRequestSet,
    ).pipe(
      T.XmlName("capacityReservationBillingRequestSet"),
      T.Ec2QueryName("CapacityReservationBillingRequestSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeCapacityReservationBillingRequestsResult",
}) as any as S.Schema<DescribeCapacityReservationBillingRequestsResult>;
export interface DescribeCapacityReservationFleetsRequest {
  CapacityReservationFleetIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeCapacityReservationFleetsRequest = S.suspend(() =>
  S.Struct({
    CapacityReservationFleetIds: S.optional(CapacityReservationFleetIdSet).pipe(
      T.XmlName("CapacityReservationFleetId"),
    ),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeCapacityReservationFleetsRequest",
}) as any as S.Schema<DescribeCapacityReservationFleetsRequest>;
export interface CapacityReservationFleet {
  CapacityReservationFleetId?: string;
  CapacityReservationFleetArn?: string;
  State?: CapacityReservationFleetState;
  TotalTargetCapacity?: number;
  TotalFulfilledCapacity?: number;
  Tenancy?: FleetCapacityReservationTenancy;
  EndDate?: Date;
  CreateTime?: Date;
  InstanceMatchCriteria?: FleetInstanceMatchCriteria;
  AllocationStrategy?: string;
  InstanceTypeSpecifications?: FleetCapacityReservation[];
  Tags?: Tag[];
}
export const CapacityReservationFleet = S.suspend(() =>
  S.Struct({
    CapacityReservationFleetId: S.optional(S.String).pipe(
      T.XmlName("capacityReservationFleetId"),
      T.Ec2QueryName("CapacityReservationFleetId"),
    ),
    CapacityReservationFleetArn: S.optional(S.String).pipe(
      T.XmlName("capacityReservationFleetArn"),
      T.Ec2QueryName("CapacityReservationFleetArn"),
    ),
    State: S.optional(CapacityReservationFleetState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    TotalTargetCapacity: S.optional(S.Number).pipe(
      T.XmlName("totalTargetCapacity"),
      T.Ec2QueryName("TotalTargetCapacity"),
    ),
    TotalFulfilledCapacity: S.optional(S.Number).pipe(
      T.XmlName("totalFulfilledCapacity"),
      T.Ec2QueryName("TotalFulfilledCapacity"),
    ),
    Tenancy: S.optional(FleetCapacityReservationTenancy).pipe(
      T.XmlName("tenancy"),
      T.Ec2QueryName("Tenancy"),
    ),
    EndDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("endDate"), T.Ec2QueryName("EndDate")),
    CreateTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createTime"), T.Ec2QueryName("CreateTime")),
    InstanceMatchCriteria: S.optional(FleetInstanceMatchCriteria).pipe(
      T.XmlName("instanceMatchCriteria"),
      T.Ec2QueryName("InstanceMatchCriteria"),
    ),
    AllocationStrategy: S.optional(S.String).pipe(
      T.XmlName("allocationStrategy"),
      T.Ec2QueryName("AllocationStrategy"),
    ),
    InstanceTypeSpecifications: S.optional(FleetCapacityReservationSet).pipe(
      T.XmlName("instanceTypeSpecificationSet"),
      T.Ec2QueryName("InstanceTypeSpecificationSet"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "CapacityReservationFleet",
}) as any as S.Schema<CapacityReservationFleet>;
export type CapacityReservationFleetSet = CapacityReservationFleet[];
export const CapacityReservationFleetSet = S.Array(
  CapacityReservationFleet.pipe(T.XmlName("item")).annotate({
    identifier: "CapacityReservationFleet",
  }),
);
export interface DescribeCapacityReservationFleetsResult {
  CapacityReservationFleets?: CapacityReservationFleet[];
  NextToken?: string;
}
export const DescribeCapacityReservationFleetsResult = S.suspend(() =>
  S.Struct({
    CapacityReservationFleets: S.optional(CapacityReservationFleetSet).pipe(
      T.XmlName("capacityReservationFleetSet"),
      T.Ec2QueryName("CapacityReservationFleetSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeCapacityReservationFleetsResult",
}) as any as S.Schema<DescribeCapacityReservationFleetsResult>;
export interface DescribeCapacityReservationsRequest {
  CapacityReservationIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeCapacityReservationsRequest = S.suspend(() =>
  S.Struct({
    CapacityReservationIds: S.optional(CapacityReservationIdSet).pipe(
      T.XmlName("CapacityReservationId"),
    ),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeCapacityReservationsRequest",
}) as any as S.Schema<DescribeCapacityReservationsRequest>;
export type CapacityReservationSet = CapacityReservation[];
export const CapacityReservationSet = S.Array(
  CapacityReservation.pipe(T.XmlName("item")).annotate({
    identifier: "CapacityReservation",
  }),
);
export interface DescribeCapacityReservationsResult {
  NextToken?: string;
  CapacityReservations?: CapacityReservation[];
}
export const DescribeCapacityReservationsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    CapacityReservations: S.optional(CapacityReservationSet).pipe(
      T.XmlName("capacityReservationSet"),
      T.Ec2QueryName("CapacityReservationSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeCapacityReservationsResult",
}) as any as S.Schema<DescribeCapacityReservationsResult>;
export interface DescribeCapacityReservationTopologyRequest {
  DryRun?: boolean;
  NextToken?: string;
  MaxResults?: number;
  CapacityReservationIds?: string[];
  Filters?: Filter[];
}
export const DescribeCapacityReservationTopologyRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    CapacityReservationIds: S.optional(CapacityReservationIdSet).pipe(
      T.XmlName("CapacityReservationId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeCapacityReservationTopologyRequest",
}) as any as S.Schema<DescribeCapacityReservationTopologyRequest>;
export type NetworkNodeSet = string[];
export const NetworkNodeSet = S.Array(S.String.pipe(T.XmlName("item")));
export interface CapacityReservationTopology {
  CapacityReservationId?: string;
  CapacityBlockId?: string;
  State?: string;
  InstanceType?: string;
  GroupName?: string;
  NetworkNodes?: string[];
  AvailabilityZoneId?: string;
  AvailabilityZone?: string;
}
export const CapacityReservationTopology = S.suspend(() =>
  S.Struct({
    CapacityReservationId: S.optional(S.String).pipe(
      T.XmlName("capacityReservationId"),
      T.Ec2QueryName("CapacityReservationId"),
    ),
    CapacityBlockId: S.optional(S.String).pipe(
      T.XmlName("capacityBlockId"),
      T.Ec2QueryName("CapacityBlockId"),
    ),
    State: S.optional(S.String).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    InstanceType: S.optional(S.String).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    GroupName: S.optional(S.String).pipe(
      T.XmlName("groupName"),
      T.Ec2QueryName("GroupName"),
    ),
    NetworkNodes: S.optional(NetworkNodeSet).pipe(
      T.XmlName("networkNodeSet"),
      T.Ec2QueryName("NetworkNodeSet"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
  }),
).annotate({
  identifier: "CapacityReservationTopology",
}) as any as S.Schema<CapacityReservationTopology>;
export type CapacityReservationTopologySet = CapacityReservationTopology[];
export const CapacityReservationTopologySet = S.Array(
  CapacityReservationTopology.pipe(T.XmlName("item")).annotate({
    identifier: "CapacityReservationTopology",
  }),
);
export interface DescribeCapacityReservationTopologyResult {
  NextToken?: string;
  CapacityReservations?: CapacityReservationTopology[];
}
export const DescribeCapacityReservationTopologyResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    CapacityReservations: S.optional(CapacityReservationTopologySet).pipe(
      T.XmlName("capacityReservationSet"),
      T.Ec2QueryName("CapacityReservationSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeCapacityReservationTopologyResult",
}) as any as S.Schema<DescribeCapacityReservationTopologyResult>;
export type CarrierGatewayIdSet = string[];
export const CarrierGatewayIdSet = S.Array(S.String);
export interface DescribeCarrierGatewaysRequest {
  CarrierGatewayIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeCarrierGatewaysRequest = S.suspend(() =>
  S.Struct({
    CarrierGatewayIds: S.optional(CarrierGatewayIdSet).pipe(
      T.XmlName("CarrierGatewayId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeCarrierGatewaysRequest",
}) as any as S.Schema<DescribeCarrierGatewaysRequest>;
export type CarrierGatewaySet = CarrierGateway[];
export const CarrierGatewaySet = S.Array(
  CarrierGateway.pipe(T.XmlName("item")).annotate({
    identifier: "CarrierGateway",
  }),
);
export interface DescribeCarrierGatewaysResult {
  CarrierGateways?: CarrierGateway[];
  NextToken?: string;
}
export const DescribeCarrierGatewaysResult = S.suspend(() =>
  S.Struct({
    CarrierGateways: S.optional(CarrierGatewaySet).pipe(
      T.XmlName("carrierGatewaySet"),
      T.Ec2QueryName("CarrierGatewaySet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeCarrierGatewaysResult",
}) as any as S.Schema<DescribeCarrierGatewaysResult>;
export type InstanceIdStringList = string[];
export const InstanceIdStringList = S.Array(
  S.String.pipe(T.XmlName("InstanceId")),
);
export interface DescribeClassicLinkInstancesRequest {
  DryRun?: boolean;
  InstanceIds?: string[];
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeClassicLinkInstancesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    InstanceIds: S.optional(InstanceIdStringList).pipe(T.XmlName("InstanceId")),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    MaxResults: S.optional(S.Number).pipe(
      T.XmlName("maxResults"),
      T.Ec2QueryName("MaxResults"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeClassicLinkInstancesRequest",
}) as any as S.Schema<DescribeClassicLinkInstancesRequest>;
export interface ClassicLinkInstance {
  Groups?: GroupIdentifier[];
  InstanceId?: string;
  Tags?: Tag[];
  VpcId?: string;
}
export const ClassicLinkInstance = S.suspend(() =>
  S.Struct({
    Groups: S.optional(GroupIdentifierList).pipe(
      T.XmlName("groupSet"),
      T.Ec2QueryName("GroupSet"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
  }),
).annotate({
  identifier: "ClassicLinkInstance",
}) as any as S.Schema<ClassicLinkInstance>;
export type ClassicLinkInstanceList = ClassicLinkInstance[];
export const ClassicLinkInstanceList = S.Array(
  ClassicLinkInstance.pipe(T.XmlName("item")).annotate({
    identifier: "ClassicLinkInstance",
  }),
);
export interface DescribeClassicLinkInstancesResult {
  Instances?: ClassicLinkInstance[];
  NextToken?: string;
}
export const DescribeClassicLinkInstancesResult = S.suspend(() =>
  S.Struct({
    Instances: S.optional(ClassicLinkInstanceList).pipe(
      T.XmlName("instancesSet"),
      T.Ec2QueryName("InstancesSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeClassicLinkInstancesResult",
}) as any as S.Schema<DescribeClassicLinkInstancesResult>;
export interface DescribeClientVpnAuthorizationRulesRequest {
  ClientVpnEndpointId?: string;
  DryRun?: boolean;
  NextToken?: string;
  Filters?: Filter[];
  MaxResults?: number;
}
export const DescribeClientVpnAuthorizationRulesRequest = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    NextToken: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeClientVpnAuthorizationRulesRequest",
}) as any as S.Schema<DescribeClientVpnAuthorizationRulesRequest>;
export interface AuthorizationRule {
  ClientVpnEndpointId?: string;
  Description?: string;
  GroupId?: string;
  AccessAll?: boolean;
  DestinationCidr?: string;
  Status?: ClientVpnAuthorizationRuleStatus;
}
export const AuthorizationRule = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String).pipe(
      T.XmlName("clientVpnEndpointId"),
      T.Ec2QueryName("ClientVpnEndpointId"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
    AccessAll: S.optional(S.Boolean).pipe(
      T.XmlName("accessAll"),
      T.Ec2QueryName("AccessAll"),
    ),
    DestinationCidr: S.optional(S.String).pipe(
      T.XmlName("destinationCidr"),
      T.Ec2QueryName("DestinationCidr"),
    ),
    Status: S.optional(ClientVpnAuthorizationRuleStatus)
      .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
      .annotate({ identifier: "ClientVpnAuthorizationRuleStatus" }),
  }),
).annotate({
  identifier: "AuthorizationRule",
}) as any as S.Schema<AuthorizationRule>;
export type AuthorizationRuleSet = AuthorizationRule[];
export const AuthorizationRuleSet = S.Array(
  AuthorizationRule.pipe(T.XmlName("item")).annotate({
    identifier: "AuthorizationRule",
  }),
);
export interface DescribeClientVpnAuthorizationRulesResult {
  AuthorizationRules?: AuthorizationRule[];
  NextToken?: string;
}
export const DescribeClientVpnAuthorizationRulesResult = S.suspend(() =>
  S.Struct({
    AuthorizationRules: S.optional(AuthorizationRuleSet).pipe(
      T.XmlName("authorizationRule"),
      T.Ec2QueryName("AuthorizationRule"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeClientVpnAuthorizationRulesResult",
}) as any as S.Schema<DescribeClientVpnAuthorizationRulesResult>;
export interface DescribeClientVpnConnectionsRequest {
  ClientVpnEndpointId?: string;
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
}
export const DescribeClientVpnConnectionsRequest = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeClientVpnConnectionsRequest",
}) as any as S.Schema<DescribeClientVpnConnectionsRequest>;
export type ClientVpnConnectionStatusCode =
  | "active"
  | "failed-to-terminate"
  | "terminating"
  | "terminated"
  | (string & {});
export const ClientVpnConnectionStatusCode = S.String;
export interface ClientVpnConnectionStatus {
  Code?: ClientVpnConnectionStatusCode;
  Message?: string;
}
export const ClientVpnConnectionStatus = S.suspend(() =>
  S.Struct({
    Code: S.optional(ClientVpnConnectionStatusCode).pipe(
      T.XmlName("code"),
      T.Ec2QueryName("Code"),
    ),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "ClientVpnConnectionStatus",
}) as any as S.Schema<ClientVpnConnectionStatus>;
export interface ClientVpnConnection {
  ClientVpnEndpointId?: string;
  Timestamp?: string;
  ConnectionId?: string;
  Username?: string;
  ConnectionEstablishedTime?: string;
  IngressBytes?: string;
  EgressBytes?: string;
  IngressPackets?: string;
  EgressPackets?: string;
  ClientIp?: string;
  ClientIpv6Address?: string;
  CommonName?: string;
  Status?: ClientVpnConnectionStatus;
  ConnectionEndTime?: string;
  PostureComplianceStatuses?: string[];
}
export const ClientVpnConnection = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String).pipe(
      T.XmlName("clientVpnEndpointId"),
      T.Ec2QueryName("ClientVpnEndpointId"),
    ),
    Timestamp: S.optional(S.String).pipe(
      T.XmlName("timestamp"),
      T.Ec2QueryName("Timestamp"),
    ),
    ConnectionId: S.optional(S.String).pipe(
      T.XmlName("connectionId"),
      T.Ec2QueryName("ConnectionId"),
    ),
    Username: S.optional(S.String).pipe(
      T.XmlName("username"),
      T.Ec2QueryName("Username"),
    ),
    ConnectionEstablishedTime: S.optional(S.String).pipe(
      T.XmlName("connectionEstablishedTime"),
      T.Ec2QueryName("ConnectionEstablishedTime"),
    ),
    IngressBytes: S.optional(S.String).pipe(
      T.XmlName("ingressBytes"),
      T.Ec2QueryName("IngressBytes"),
    ),
    EgressBytes: S.optional(S.String).pipe(
      T.XmlName("egressBytes"),
      T.Ec2QueryName("EgressBytes"),
    ),
    IngressPackets: S.optional(S.String).pipe(
      T.XmlName("ingressPackets"),
      T.Ec2QueryName("IngressPackets"),
    ),
    EgressPackets: S.optional(S.String).pipe(
      T.XmlName("egressPackets"),
      T.Ec2QueryName("EgressPackets"),
    ),
    ClientIp: S.optional(S.String).pipe(
      T.XmlName("clientIp"),
      T.Ec2QueryName("ClientIp"),
    ),
    ClientIpv6Address: S.optional(S.String).pipe(
      T.XmlName("clientIpv6Address"),
      T.Ec2QueryName("ClientIpv6Address"),
    ),
    CommonName: S.optional(S.String).pipe(
      T.XmlName("commonName"),
      T.Ec2QueryName("CommonName"),
    ),
    Status: S.optional(ClientVpnConnectionStatus)
      .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
      .annotate({ identifier: "ClientVpnConnectionStatus" }),
    ConnectionEndTime: S.optional(S.String).pipe(
      T.XmlName("connectionEndTime"),
      T.Ec2QueryName("ConnectionEndTime"),
    ),
    PostureComplianceStatuses: S.optional(ValueStringList).pipe(
      T.XmlName("postureComplianceStatusSet"),
      T.Ec2QueryName("PostureComplianceStatusSet"),
    ),
  }),
).annotate({
  identifier: "ClientVpnConnection",
}) as any as S.Schema<ClientVpnConnection>;
export type ClientVpnConnectionSet = ClientVpnConnection[];
export const ClientVpnConnectionSet = S.Array(
  ClientVpnConnection.pipe(T.XmlName("item")).annotate({
    identifier: "ClientVpnConnection",
  }),
);
export interface DescribeClientVpnConnectionsResult {
  Connections?: ClientVpnConnection[];
  NextToken?: string;
}
export const DescribeClientVpnConnectionsResult = S.suspend(() =>
  S.Struct({
    Connections: S.optional(ClientVpnConnectionSet).pipe(
      T.XmlName("connections"),
      T.Ec2QueryName("Connections"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeClientVpnConnectionsResult",
}) as any as S.Schema<DescribeClientVpnConnectionsResult>;
export type ClientVpnEndpointIdList = string[];
export const ClientVpnEndpointIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeClientVpnEndpointsRequest {
  ClientVpnEndpointIds?: string[];
  MaxResults?: number;
  NextToken?: string;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeClientVpnEndpointsRequest = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointIds: S.optional(ClientVpnEndpointIdList).pipe(
      T.XmlName("ClientVpnEndpointId"),
    ),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeClientVpnEndpointsRequest",
}) as any as S.Schema<DescribeClientVpnEndpointsRequest>;
export type VpnProtocol = "openvpn" | (string & {});
export const VpnProtocol = S.String;
export type AssociatedNetworkType = "vpc" | (string & {});
export const AssociatedNetworkType = S.String;
export interface AssociatedTargetNetwork {
  NetworkId?: string;
  NetworkType?: AssociatedNetworkType;
}
export const AssociatedTargetNetwork = S.suspend(() =>
  S.Struct({
    NetworkId: S.optional(S.String).pipe(
      T.XmlName("networkId"),
      T.Ec2QueryName("NetworkId"),
    ),
    NetworkType: S.optional(AssociatedNetworkType).pipe(
      T.XmlName("networkType"),
      T.Ec2QueryName("NetworkType"),
    ),
  }),
).annotate({
  identifier: "AssociatedTargetNetwork",
}) as any as S.Schema<AssociatedTargetNetwork>;
export type AssociatedTargetNetworkSet = AssociatedTargetNetwork[];
export const AssociatedTargetNetworkSet = S.Array(
  AssociatedTargetNetwork.pipe(T.XmlName("item")).annotate({
    identifier: "AssociatedTargetNetwork",
  }),
);
export interface DirectoryServiceAuthentication {
  DirectoryId?: string;
}
export const DirectoryServiceAuthentication = S.suspend(() =>
  S.Struct({
    DirectoryId: S.optional(S.String).pipe(
      T.XmlName("directoryId"),
      T.Ec2QueryName("DirectoryId"),
    ),
  }),
).annotate({
  identifier: "DirectoryServiceAuthentication",
}) as any as S.Schema<DirectoryServiceAuthentication>;
export interface CertificateAuthentication {
  ClientRootCertificateChain?: string;
}
export const CertificateAuthentication = S.suspend(() =>
  S.Struct({
    ClientRootCertificateChain: S.optional(S.String).pipe(
      T.XmlName("clientRootCertificateChain"),
      T.Ec2QueryName("ClientRootCertificateChain"),
    ),
  }),
).annotate({
  identifier: "CertificateAuthentication",
}) as any as S.Schema<CertificateAuthentication>;
export interface FederatedAuthentication {
  SamlProviderArn?: string;
  SelfServiceSamlProviderArn?: string;
}
export const FederatedAuthentication = S.suspend(() =>
  S.Struct({
    SamlProviderArn: S.optional(S.String).pipe(
      T.XmlName("samlProviderArn"),
      T.Ec2QueryName("SamlProviderArn"),
    ),
    SelfServiceSamlProviderArn: S.optional(S.String).pipe(
      T.XmlName("selfServiceSamlProviderArn"),
      T.Ec2QueryName("SelfServiceSamlProviderArn"),
    ),
  }),
).annotate({
  identifier: "FederatedAuthentication",
}) as any as S.Schema<FederatedAuthentication>;
export interface ClientVpnAuthentication {
  Type?: ClientVpnAuthenticationType;
  ActiveDirectory?: DirectoryServiceAuthentication;
  MutualAuthentication?: CertificateAuthentication;
  FederatedAuthentication?: FederatedAuthentication;
}
export const ClientVpnAuthentication = S.suspend(() =>
  S.Struct({
    Type: S.optional(ClientVpnAuthenticationType).pipe(
      T.XmlName("type"),
      T.Ec2QueryName("Type"),
    ),
    ActiveDirectory: S.optional(DirectoryServiceAuthentication)
      .pipe(T.XmlName("activeDirectory"), T.Ec2QueryName("ActiveDirectory"))
      .annotate({ identifier: "DirectoryServiceAuthentication" }),
    MutualAuthentication: S.optional(CertificateAuthentication)
      .pipe(
        T.XmlName("mutualAuthentication"),
        T.Ec2QueryName("MutualAuthentication"),
      )
      .annotate({ identifier: "CertificateAuthentication" }),
    FederatedAuthentication: S.optional(FederatedAuthentication)
      .pipe(
        T.XmlName("federatedAuthentication"),
        T.Ec2QueryName("FederatedAuthentication"),
      )
      .annotate({ identifier: "FederatedAuthentication" }),
  }),
).annotate({
  identifier: "ClientVpnAuthentication",
}) as any as S.Schema<ClientVpnAuthentication>;
export type ClientVpnAuthenticationList = ClientVpnAuthentication[];
export const ClientVpnAuthenticationList = S.Array(
  ClientVpnAuthentication.pipe(T.XmlName("item")).annotate({
    identifier: "ClientVpnAuthentication",
  }),
);
export interface ConnectionLogResponseOptions {
  Enabled?: boolean;
  CloudwatchLogGroup?: string;
  CloudwatchLogStream?: string;
}
export const ConnectionLogResponseOptions = S.suspend(() =>
  S.Struct({
    Enabled: S.optional(S.Boolean),
    CloudwatchLogGroup: S.optional(S.String),
    CloudwatchLogStream: S.optional(S.String),
  }),
).annotate({
  identifier: "ConnectionLogResponseOptions",
}) as any as S.Schema<ConnectionLogResponseOptions>;
export type ClientVpnEndpointAttributeStatusCode =
  | "applying"
  | "applied"
  | (string & {});
export const ClientVpnEndpointAttributeStatusCode = S.String;
export interface ClientVpnEndpointAttributeStatus {
  Code?: ClientVpnEndpointAttributeStatusCode;
  Message?: string;
}
export const ClientVpnEndpointAttributeStatus = S.suspend(() =>
  S.Struct({
    Code: S.optional(ClientVpnEndpointAttributeStatusCode).pipe(
      T.XmlName("code"),
      T.Ec2QueryName("Code"),
    ),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "ClientVpnEndpointAttributeStatus",
}) as any as S.Schema<ClientVpnEndpointAttributeStatus>;
export interface ClientConnectResponseOptions {
  Enabled?: boolean;
  LambdaFunctionArn?: string;
  Status?: ClientVpnEndpointAttributeStatus;
}
export const ClientConnectResponseOptions = S.suspend(() =>
  S.Struct({
    Enabled: S.optional(S.Boolean).pipe(
      T.XmlName("enabled"),
      T.Ec2QueryName("Enabled"),
    ),
    LambdaFunctionArn: S.optional(S.String).pipe(
      T.XmlName("lambdaFunctionArn"),
      T.Ec2QueryName("LambdaFunctionArn"),
    ),
    Status: S.optional(ClientVpnEndpointAttributeStatus)
      .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
      .annotate({ identifier: "ClientVpnEndpointAttributeStatus" }),
  }),
).annotate({
  identifier: "ClientConnectResponseOptions",
}) as any as S.Schema<ClientConnectResponseOptions>;
export interface ClientLoginBannerResponseOptions {
  Enabled?: boolean;
  BannerText?: string;
}
export const ClientLoginBannerResponseOptions = S.suspend(() =>
  S.Struct({
    Enabled: S.optional(S.Boolean).pipe(
      T.XmlName("enabled"),
      T.Ec2QueryName("Enabled"),
    ),
    BannerText: S.optional(S.String).pipe(
      T.XmlName("bannerText"),
      T.Ec2QueryName("BannerText"),
    ),
  }),
).annotate({
  identifier: "ClientLoginBannerResponseOptions",
}) as any as S.Schema<ClientLoginBannerResponseOptions>;
export interface ClientRouteEnforcementResponseOptions {
  Enforced?: boolean;
}
export const ClientRouteEnforcementResponseOptions = S.suspend(() =>
  S.Struct({
    Enforced: S.optional(S.Boolean).pipe(
      T.XmlName("enforced"),
      T.Ec2QueryName("Enforced"),
    ),
  }),
).annotate({
  identifier: "ClientRouteEnforcementResponseOptions",
}) as any as S.Schema<ClientRouteEnforcementResponseOptions>;
export interface ClientVpnEndpoint {
  ClientVpnEndpointId?: string;
  Description?: string;
  Status?: ClientVpnEndpointStatus;
  CreationTime?: string;
  DeletionTime?: string;
  DnsName?: string;
  ClientCidrBlock?: string;
  DnsServers?: string[];
  SplitTunnel?: boolean;
  VpnProtocol?: VpnProtocol;
  TransportProtocol?: TransportProtocol;
  VpnPort?: number;
  AssociatedTargetNetworks?: AssociatedTargetNetwork[];
  ServerCertificateArn?: string;
  AuthenticationOptions?: ClientVpnAuthentication[];
  ConnectionLogOptions?: ConnectionLogResponseOptions;
  Tags?: Tag[];
  SecurityGroupIds?: string[];
  VpcId?: string;
  SelfServicePortalUrl?: string;
  ClientConnectOptions?: ClientConnectResponseOptions;
  SessionTimeoutHours?: number;
  ClientLoginBannerOptions?: ClientLoginBannerResponseOptions;
  ClientRouteEnforcementOptions?: ClientRouteEnforcementResponseOptions;
  DisconnectOnSessionTimeout?: boolean;
  EndpointIpAddressType?: EndpointIpAddressType;
  TrafficIpAddressType?: TrafficIpAddressType;
}
export const ClientVpnEndpoint = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String).pipe(
      T.XmlName("clientVpnEndpointId"),
      T.Ec2QueryName("ClientVpnEndpointId"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    Status: S.optional(ClientVpnEndpointStatus)
      .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
      .annotate({ identifier: "ClientVpnEndpointStatus" }),
    CreationTime: S.optional(S.String).pipe(
      T.XmlName("creationTime"),
      T.Ec2QueryName("CreationTime"),
    ),
    DeletionTime: S.optional(S.String).pipe(
      T.XmlName("deletionTime"),
      T.Ec2QueryName("DeletionTime"),
    ),
    DnsName: S.optional(S.String).pipe(
      T.XmlName("dnsName"),
      T.Ec2QueryName("DnsName"),
    ),
    ClientCidrBlock: S.optional(S.String).pipe(
      T.XmlName("clientCidrBlock"),
      T.Ec2QueryName("ClientCidrBlock"),
    ),
    DnsServers: S.optional(ValueStringList).pipe(
      T.XmlName("dnsServer"),
      T.Ec2QueryName("DnsServer"),
    ),
    SplitTunnel: S.optional(S.Boolean).pipe(
      T.XmlName("splitTunnel"),
      T.Ec2QueryName("SplitTunnel"),
    ),
    VpnProtocol: S.optional(VpnProtocol).pipe(
      T.XmlName("vpnProtocol"),
      T.Ec2QueryName("VpnProtocol"),
    ),
    TransportProtocol: S.optional(TransportProtocol).pipe(
      T.XmlName("transportProtocol"),
      T.Ec2QueryName("TransportProtocol"),
    ),
    VpnPort: S.optional(S.Number).pipe(
      T.XmlName("vpnPort"),
      T.Ec2QueryName("VpnPort"),
    ),
    AssociatedTargetNetworks: S.optional(AssociatedTargetNetworkSet).pipe(
      T.XmlName("associatedTargetNetwork"),
      T.Ec2QueryName("AssociatedTargetNetwork"),
    ),
    ServerCertificateArn: S.optional(S.String).pipe(
      T.XmlName("serverCertificateArn"),
      T.Ec2QueryName("ServerCertificateArn"),
    ),
    AuthenticationOptions: S.optional(ClientVpnAuthenticationList).pipe(
      T.XmlName("authenticationOptions"),
      T.Ec2QueryName("AuthenticationOptions"),
    ),
    ConnectionLogOptions: S.optional(ConnectionLogResponseOptions)
      .pipe(
        T.XmlName("connectionLogOptions"),
        T.Ec2QueryName("ConnectionLogOptions"),
      )
      .annotate({ identifier: "ConnectionLogResponseOptions" }),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    SecurityGroupIds: S.optional(ClientVpnSecurityGroupIdSet).pipe(
      T.XmlName("securityGroupIdSet"),
      T.Ec2QueryName("SecurityGroupIdSet"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    SelfServicePortalUrl: S.optional(S.String).pipe(
      T.XmlName("selfServicePortalUrl"),
      T.Ec2QueryName("SelfServicePortalUrl"),
    ),
    ClientConnectOptions: S.optional(ClientConnectResponseOptions)
      .pipe(
        T.XmlName("clientConnectOptions"),
        T.Ec2QueryName("ClientConnectOptions"),
      )
      .annotate({ identifier: "ClientConnectResponseOptions" }),
    SessionTimeoutHours: S.optional(S.Number).pipe(
      T.XmlName("sessionTimeoutHours"),
      T.Ec2QueryName("SessionTimeoutHours"),
    ),
    ClientLoginBannerOptions: S.optional(ClientLoginBannerResponseOptions)
      .pipe(
        T.XmlName("clientLoginBannerOptions"),
        T.Ec2QueryName("ClientLoginBannerOptions"),
      )
      .annotate({ identifier: "ClientLoginBannerResponseOptions" }),
    ClientRouteEnforcementOptions: S.optional(
      ClientRouteEnforcementResponseOptions,
    )
      .pipe(
        T.XmlName("clientRouteEnforcementOptions"),
        T.Ec2QueryName("ClientRouteEnforcementOptions"),
      )
      .annotate({ identifier: "ClientRouteEnforcementResponseOptions" }),
    DisconnectOnSessionTimeout: S.optional(S.Boolean).pipe(
      T.XmlName("disconnectOnSessionTimeout"),
      T.Ec2QueryName("DisconnectOnSessionTimeout"),
    ),
    EndpointIpAddressType: S.optional(EndpointIpAddressType).pipe(
      T.XmlName("endpointIpAddressType"),
      T.Ec2QueryName("EndpointIpAddressType"),
    ),
    TrafficIpAddressType: S.optional(TrafficIpAddressType).pipe(
      T.XmlName("trafficIpAddressType"),
      T.Ec2QueryName("TrafficIpAddressType"),
    ),
  }),
).annotate({
  identifier: "ClientVpnEndpoint",
}) as any as S.Schema<ClientVpnEndpoint>;
export type EndpointSet = ClientVpnEndpoint[];
export const EndpointSet = S.Array(
  ClientVpnEndpoint.pipe(T.XmlName("item")).annotate({
    identifier: "ClientVpnEndpoint",
  }),
);
export interface DescribeClientVpnEndpointsResult {
  ClientVpnEndpoints?: ClientVpnEndpoint[];
  NextToken?: string;
}
export const DescribeClientVpnEndpointsResult = S.suspend(() =>
  S.Struct({
    ClientVpnEndpoints: S.optional(EndpointSet).pipe(
      T.XmlName("clientVpnEndpoint"),
      T.Ec2QueryName("ClientVpnEndpoint"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeClientVpnEndpointsResult",
}) as any as S.Schema<DescribeClientVpnEndpointsResult>;
export interface DescribeClientVpnRoutesRequest {
  ClientVpnEndpointId?: string;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeClientVpnRoutesRequest = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeClientVpnRoutesRequest",
}) as any as S.Schema<DescribeClientVpnRoutesRequest>;
export interface ClientVpnRoute {
  ClientVpnEndpointId?: string;
  DestinationCidr?: string;
  TargetSubnet?: string;
  Type?: string;
  Origin?: string;
  Status?: ClientVpnRouteStatus;
  Description?: string;
}
export const ClientVpnRoute = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String).pipe(
      T.XmlName("clientVpnEndpointId"),
      T.Ec2QueryName("ClientVpnEndpointId"),
    ),
    DestinationCidr: S.optional(S.String).pipe(
      T.XmlName("destinationCidr"),
      T.Ec2QueryName("DestinationCidr"),
    ),
    TargetSubnet: S.optional(S.String).pipe(
      T.XmlName("targetSubnet"),
      T.Ec2QueryName("TargetSubnet"),
    ),
    Type: S.optional(S.String).pipe(T.XmlName("type"), T.Ec2QueryName("Type")),
    Origin: S.optional(S.String).pipe(
      T.XmlName("origin"),
      T.Ec2QueryName("Origin"),
    ),
    Status: S.optional(ClientVpnRouteStatus)
      .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
      .annotate({ identifier: "ClientVpnRouteStatus" }),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
  }),
).annotate({ identifier: "ClientVpnRoute" }) as any as S.Schema<ClientVpnRoute>;
export type ClientVpnRouteSet = ClientVpnRoute[];
export const ClientVpnRouteSet = S.Array(
  ClientVpnRoute.pipe(T.XmlName("item")).annotate({
    identifier: "ClientVpnRoute",
  }),
);
export interface DescribeClientVpnRoutesResult {
  Routes?: ClientVpnRoute[];
  NextToken?: string;
}
export const DescribeClientVpnRoutesResult = S.suspend(() =>
  S.Struct({
    Routes: S.optional(ClientVpnRouteSet).pipe(
      T.XmlName("routes"),
      T.Ec2QueryName("Routes"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeClientVpnRoutesResult",
}) as any as S.Schema<DescribeClientVpnRoutesResult>;
export interface DescribeClientVpnTargetNetworksRequest {
  ClientVpnEndpointId?: string;
  AssociationIds?: string[];
  MaxResults?: number;
  NextToken?: string;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeClientVpnTargetNetworksRequest = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String),
    AssociationIds: S.optional(ValueStringList),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeClientVpnTargetNetworksRequest",
}) as any as S.Schema<DescribeClientVpnTargetNetworksRequest>;
export interface TargetNetwork {
  AssociationId?: string;
  VpcId?: string;
  TargetNetworkId?: string;
  ClientVpnEndpointId?: string;
  Status?: AssociationStatus;
  SecurityGroups?: string[];
}
export const TargetNetwork = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    TargetNetworkId: S.optional(S.String).pipe(
      T.XmlName("targetNetworkId"),
      T.Ec2QueryName("TargetNetworkId"),
    ),
    ClientVpnEndpointId: S.optional(S.String).pipe(
      T.XmlName("clientVpnEndpointId"),
      T.Ec2QueryName("ClientVpnEndpointId"),
    ),
    Status: S.optional(AssociationStatus)
      .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
      .annotate({ identifier: "AssociationStatus" }),
    SecurityGroups: S.optional(ValueStringList).pipe(
      T.XmlName("securityGroups"),
      T.Ec2QueryName("SecurityGroups"),
    ),
  }),
).annotate({ identifier: "TargetNetwork" }) as any as S.Schema<TargetNetwork>;
export type TargetNetworkSet = TargetNetwork[];
export const TargetNetworkSet = S.Array(
  TargetNetwork.pipe(T.XmlName("item")).annotate({
    identifier: "TargetNetwork",
  }),
);
export interface DescribeClientVpnTargetNetworksResult {
  ClientVpnTargetNetworks?: TargetNetwork[];
  NextToken?: string;
}
export const DescribeClientVpnTargetNetworksResult = S.suspend(() =>
  S.Struct({
    ClientVpnTargetNetworks: S.optional(TargetNetworkSet).pipe(
      T.XmlName("clientVpnTargetNetworks"),
      T.Ec2QueryName("ClientVpnTargetNetworks"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeClientVpnTargetNetworksResult",
}) as any as S.Schema<DescribeClientVpnTargetNetworksResult>;
export type CoipPoolIdSet = string[];
export const CoipPoolIdSet = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeCoipPoolsRequest {
  PoolIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeCoipPoolsRequest = S.suspend(() =>
  S.Struct({
    PoolIds: S.optional(CoipPoolIdSet).pipe(T.XmlName("PoolId")),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeCoipPoolsRequest",
}) as any as S.Schema<DescribeCoipPoolsRequest>;
export type CoipPoolSet = CoipPool[];
export const CoipPoolSet = S.Array(
  CoipPool.pipe(T.XmlName("item")).annotate({ identifier: "CoipPool" }),
);
export interface DescribeCoipPoolsResult {
  CoipPools?: CoipPool[];
  NextToken?: string;
}
export const DescribeCoipPoolsResult = S.suspend(() =>
  S.Struct({
    CoipPools: S.optional(CoipPoolSet).pipe(
      T.XmlName("coipPoolSet"),
      T.Ec2QueryName("CoipPoolSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeCoipPoolsResult",
}) as any as S.Schema<DescribeCoipPoolsResult>;
export type ConversionIdStringList = string[];
export const ConversionIdStringList = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeConversionTasksRequest {
  DryRun?: boolean;
  ConversionTaskIds?: string[];
}
export const DescribeConversionTasksRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    ConversionTaskIds: S.optional(ConversionIdStringList).pipe(
      T.XmlName("conversionTaskId"),
      T.Ec2QueryName("ConversionTaskId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeConversionTasksRequest",
}) as any as S.Schema<DescribeConversionTasksRequest>;
export interface DiskImageDescription {
  Checksum?: string;
  Format?: DiskImageFormat;
  ImportManifestUrl?: string | redacted.Redacted<string>;
  Size?: number;
}
export const DiskImageDescription = S.suspend(() =>
  S.Struct({
    Checksum: S.optional(S.String).pipe(
      T.XmlName("checksum"),
      T.Ec2QueryName("Checksum"),
    ),
    Format: S.optional(DiskImageFormat).pipe(
      T.XmlName("format"),
      T.Ec2QueryName("Format"),
    ),
    ImportManifestUrl: S.optional(SensitiveString).pipe(
      T.XmlName("importManifestUrl"),
      T.Ec2QueryName("ImportManifestUrl"),
    ),
    Size: S.optional(S.Number).pipe(T.XmlName("size"), T.Ec2QueryName("Size")),
  }),
).annotate({
  identifier: "DiskImageDescription",
}) as any as S.Schema<DiskImageDescription>;
export interface DiskImageVolumeDescription {
  Id?: string;
  Size?: number;
}
export const DiskImageVolumeDescription = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String).pipe(T.XmlName("id"), T.Ec2QueryName("Id")),
    Size: S.optional(S.Number).pipe(T.XmlName("size"), T.Ec2QueryName("Size")),
  }),
).annotate({
  identifier: "DiskImageVolumeDescription",
}) as any as S.Schema<DiskImageVolumeDescription>;
export interface ImportInstanceVolumeDetailItem {
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  BytesConverted?: number;
  Description?: string;
  Image?: DiskImageDescription;
  Status?: string;
  StatusMessage?: string;
  Volume?: DiskImageVolumeDescription;
}
export const ImportInstanceVolumeDetailItem = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    BytesConverted: S.optional(S.Number).pipe(
      T.XmlName("bytesConverted"),
      T.Ec2QueryName("BytesConverted"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    Image: S.optional(DiskImageDescription)
      .pipe(T.XmlName("image"), T.Ec2QueryName("Image"))
      .annotate({ identifier: "DiskImageDescription" }),
    Status: S.optional(S.String).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    Volume: S.optional(DiskImageVolumeDescription)
      .pipe(T.XmlName("volume"), T.Ec2QueryName("Volume"))
      .annotate({ identifier: "DiskImageVolumeDescription" }),
  }),
).annotate({
  identifier: "ImportInstanceVolumeDetailItem",
}) as any as S.Schema<ImportInstanceVolumeDetailItem>;
export type ImportInstanceVolumeDetailSet = ImportInstanceVolumeDetailItem[];
export const ImportInstanceVolumeDetailSet = S.Array(
  ImportInstanceVolumeDetailItem.pipe(T.XmlName("item")).annotate({
    identifier: "ImportInstanceVolumeDetailItem",
  }),
);
export interface ImportInstanceTaskDetails {
  Description?: string;
  InstanceId?: string;
  Platform?: PlatformValues;
  Volumes?: ImportInstanceVolumeDetailItem[];
}
export const ImportInstanceTaskDetails = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    Platform: S.optional(PlatformValues).pipe(
      T.XmlName("platform"),
      T.Ec2QueryName("Platform"),
    ),
    Volumes: S.optional(ImportInstanceVolumeDetailSet).pipe(
      T.XmlName("volumes"),
      T.Ec2QueryName("Volumes"),
    ),
  }),
).annotate({
  identifier: "ImportInstanceTaskDetails",
}) as any as S.Schema<ImportInstanceTaskDetails>;
export interface ImportVolumeTaskDetails {
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  BytesConverted?: number;
  Description?: string;
  Image?: DiskImageDescription;
  Volume?: DiskImageVolumeDescription;
}
export const ImportVolumeTaskDetails = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    BytesConverted: S.optional(S.Number).pipe(
      T.XmlName("bytesConverted"),
      T.Ec2QueryName("BytesConverted"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    Image: S.optional(DiskImageDescription)
      .pipe(T.XmlName("image"), T.Ec2QueryName("Image"))
      .annotate({ identifier: "DiskImageDescription" }),
    Volume: S.optional(DiskImageVolumeDescription)
      .pipe(T.XmlName("volume"), T.Ec2QueryName("Volume"))
      .annotate({ identifier: "DiskImageVolumeDescription" }),
  }),
).annotate({
  identifier: "ImportVolumeTaskDetails",
}) as any as S.Schema<ImportVolumeTaskDetails>;
export type ConversionTaskState =
  | "active"
  | "cancelling"
  | "cancelled"
  | "completed"
  | (string & {});
export const ConversionTaskState = S.String;
export interface ConversionTask {
  ConversionTaskId?: string;
  ExpirationTime?: string;
  ImportInstance?: ImportInstanceTaskDetails;
  ImportVolume?: ImportVolumeTaskDetails;
  State?: ConversionTaskState;
  StatusMessage?: string;
  Tags?: Tag[];
}
export const ConversionTask = S.suspend(() =>
  S.Struct({
    ConversionTaskId: S.optional(S.String).pipe(
      T.XmlName("conversionTaskId"),
      T.Ec2QueryName("ConversionTaskId"),
    ),
    ExpirationTime: S.optional(S.String).pipe(
      T.XmlName("expirationTime"),
      T.Ec2QueryName("ExpirationTime"),
    ),
    ImportInstance: S.optional(ImportInstanceTaskDetails)
      .pipe(T.XmlName("importInstance"), T.Ec2QueryName("ImportInstance"))
      .annotate({ identifier: "ImportInstanceTaskDetails" }),
    ImportVolume: S.optional(ImportVolumeTaskDetails)
      .pipe(T.XmlName("importVolume"), T.Ec2QueryName("ImportVolume"))
      .annotate({ identifier: "ImportVolumeTaskDetails" }),
    State: S.optional(ConversionTaskState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({ identifier: "ConversionTask" }) as any as S.Schema<ConversionTask>;
export type DescribeConversionTaskList = ConversionTask[];
export const DescribeConversionTaskList = S.Array(
  ConversionTask.pipe(T.XmlName("item")).annotate({
    identifier: "ConversionTask",
  }),
);
export interface DescribeConversionTasksResult {
  ConversionTasks?: ConversionTask[];
}
export const DescribeConversionTasksResult = S.suspend(() =>
  S.Struct({
    ConversionTasks: S.optional(DescribeConversionTaskList).pipe(
      T.XmlName("conversionTasks"),
      T.Ec2QueryName("ConversionTasks"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeConversionTasksResult",
}) as any as S.Schema<DescribeConversionTasksResult>;
export type CustomerGatewayIdStringList = string[];
export const CustomerGatewayIdStringList = S.Array(
  S.String.pipe(T.XmlName("CustomerGatewayId")),
);
export interface DescribeCustomerGatewaysRequest {
  CustomerGatewayIds?: string[];
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeCustomerGatewaysRequest = S.suspend(() =>
  S.Struct({
    CustomerGatewayIds: S.optional(CustomerGatewayIdStringList).pipe(
      T.XmlName("CustomerGatewayId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeCustomerGatewaysRequest",
}) as any as S.Schema<DescribeCustomerGatewaysRequest>;
export type CustomerGatewayList = CustomerGateway[];
export const CustomerGatewayList = S.Array(
  CustomerGateway.pipe(T.XmlName("item")).annotate({
    identifier: "CustomerGateway",
  }),
);
export interface DescribeCustomerGatewaysResult {
  CustomerGateways?: CustomerGateway[];
}
export const DescribeCustomerGatewaysResult = S.suspend(() =>
  S.Struct({
    CustomerGateways: S.optional(CustomerGatewayList).pipe(
      T.XmlName("customerGatewaySet"),
      T.Ec2QueryName("CustomerGatewaySet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeCustomerGatewaysResult",
}) as any as S.Schema<DescribeCustomerGatewaysResult>;
export interface DescribeDeclarativePoliciesReportsRequest {
  DryRun?: boolean;
  NextToken?: string;
  MaxResults?: number;
  ReportIds?: string[];
}
export const DescribeDeclarativePoliciesReportsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    ReportIds: S.optional(ValueStringList).pipe(T.XmlName("ReportId")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeDeclarativePoliciesReportsRequest",
}) as any as S.Schema<DescribeDeclarativePoliciesReportsRequest>;
export type ReportState =
  | "running"
  | "cancelled"
  | "complete"
  | "error"
  | (string & {});
export const ReportState = S.String;
export interface DeclarativePoliciesReport {
  ReportId?: string;
  S3Bucket?: string;
  S3Prefix?: string;
  TargetId?: string;
  StartTime?: Date;
  EndTime?: Date;
  Status?: ReportState;
  Tags?: Tag[];
}
export const DeclarativePoliciesReport = S.suspend(() =>
  S.Struct({
    ReportId: S.optional(S.String).pipe(
      T.XmlName("reportId"),
      T.Ec2QueryName("ReportId"),
    ),
    S3Bucket: S.optional(S.String).pipe(
      T.XmlName("s3Bucket"),
      T.Ec2QueryName("S3Bucket"),
    ),
    S3Prefix: S.optional(S.String).pipe(
      T.XmlName("s3Prefix"),
      T.Ec2QueryName("S3Prefix"),
    ),
    TargetId: S.optional(S.String).pipe(
      T.XmlName("targetId"),
      T.Ec2QueryName("TargetId"),
    ),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startTime"), T.Ec2QueryName("StartTime")),
    EndTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("endTime"), T.Ec2QueryName("EndTime")),
    Status: S.optional(ReportState).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "DeclarativePoliciesReport",
}) as any as S.Schema<DeclarativePoliciesReport>;
export type DeclarativePoliciesReportList = DeclarativePoliciesReport[];
export const DeclarativePoliciesReportList = S.Array(
  DeclarativePoliciesReport.pipe(T.XmlName("item")).annotate({
    identifier: "DeclarativePoliciesReport",
  }),
);
export interface DescribeDeclarativePoliciesReportsResult {
  NextToken?: string;
  Reports?: DeclarativePoliciesReport[];
}
export const DescribeDeclarativePoliciesReportsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    Reports: S.optional(DeclarativePoliciesReportList).pipe(
      T.XmlName("reportSet"),
      T.Ec2QueryName("ReportSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeDeclarativePoliciesReportsResult",
}) as any as S.Schema<DescribeDeclarativePoliciesReportsResult>;
export type DhcpOptionsIdStringList = string[];
export const DhcpOptionsIdStringList = S.Array(
  S.String.pipe(T.XmlName("DhcpOptionsId")),
);
export interface DescribeDhcpOptionsRequest {
  DhcpOptionsIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
  Filters?: Filter[];
}
export const DescribeDhcpOptionsRequest = S.suspend(() =>
  S.Struct({
    DhcpOptionsIds: S.optional(DhcpOptionsIdStringList).pipe(
      T.XmlName("DhcpOptionsId"),
    ),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeDhcpOptionsRequest",
}) as any as S.Schema<DescribeDhcpOptionsRequest>;
export type DhcpOptionsList = DhcpOptions[];
export const DhcpOptionsList = S.Array(
  DhcpOptions.pipe(T.XmlName("item")).annotate({ identifier: "DhcpOptions" }),
);
export interface DescribeDhcpOptionsResult {
  NextToken?: string;
  DhcpOptions?: DhcpOptions[];
}
export const DescribeDhcpOptionsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    DhcpOptions: S.optional(DhcpOptionsList).pipe(
      T.XmlName("dhcpOptionsSet"),
      T.Ec2QueryName("DhcpOptionsSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeDhcpOptionsResult",
}) as any as S.Schema<DescribeDhcpOptionsResult>;
export type EgressOnlyInternetGatewayIdList = string[];
export const EgressOnlyInternetGatewayIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeEgressOnlyInternetGatewaysRequest {
  DryRun?: boolean;
  EgressOnlyInternetGatewayIds?: string[];
  MaxResults?: number;
  NextToken?: string;
  Filters?: Filter[];
}
export const DescribeEgressOnlyInternetGatewaysRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    EgressOnlyInternetGatewayIds: S.optional(
      EgressOnlyInternetGatewayIdList,
    ).pipe(T.XmlName("EgressOnlyInternetGatewayId")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeEgressOnlyInternetGatewaysRequest",
}) as any as S.Schema<DescribeEgressOnlyInternetGatewaysRequest>;
export type EgressOnlyInternetGatewayList = EgressOnlyInternetGateway[];
export const EgressOnlyInternetGatewayList = S.Array(
  EgressOnlyInternetGateway.pipe(T.XmlName("item")).annotate({
    identifier: "EgressOnlyInternetGateway",
  }),
);
export interface DescribeEgressOnlyInternetGatewaysResult {
  EgressOnlyInternetGateways?: EgressOnlyInternetGateway[];
  NextToken?: string;
}
export const DescribeEgressOnlyInternetGatewaysResult = S.suspend(() =>
  S.Struct({
    EgressOnlyInternetGateways: S.optional(EgressOnlyInternetGatewayList).pipe(
      T.XmlName("egressOnlyInternetGatewaySet"),
      T.Ec2QueryName("EgressOnlyInternetGatewaySet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeEgressOnlyInternetGatewaysResult",
}) as any as S.Schema<DescribeEgressOnlyInternetGatewaysResult>;
export type ElasticGpuIdSet = string[];
export const ElasticGpuIdSet = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeElasticGpusRequest {
  ElasticGpuIds?: string[];
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeElasticGpusRequest = S.suspend(() =>
  S.Struct({
    ElasticGpuIds: S.optional(ElasticGpuIdSet).pipe(T.XmlName("ElasticGpuId")),
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeElasticGpusRequest",
}) as any as S.Schema<DescribeElasticGpusRequest>;
export type ElasticGpuStatus = "OK" | "IMPAIRED" | (string & {});
export const ElasticGpuStatus = S.String;
export interface ElasticGpuHealth {
  Status?: ElasticGpuStatus;
}
export const ElasticGpuHealth = S.suspend(() =>
  S.Struct({
    Status: S.optional(ElasticGpuStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
  }),
).annotate({
  identifier: "ElasticGpuHealth",
}) as any as S.Schema<ElasticGpuHealth>;
export type ElasticGpuState = "ATTACHED" | (string & {});
export const ElasticGpuState = S.String;
export interface ElasticGpus {
  ElasticGpuId?: string;
  AvailabilityZone?: string;
  ElasticGpuType?: string;
  ElasticGpuHealth?: ElasticGpuHealth;
  ElasticGpuState?: ElasticGpuState;
  InstanceId?: string;
  Tags?: Tag[];
}
export const ElasticGpus = S.suspend(() =>
  S.Struct({
    ElasticGpuId: S.optional(S.String).pipe(
      T.XmlName("elasticGpuId"),
      T.Ec2QueryName("ElasticGpuId"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    ElasticGpuType: S.optional(S.String).pipe(
      T.XmlName("elasticGpuType"),
      T.Ec2QueryName("ElasticGpuType"),
    ),
    ElasticGpuHealth: S.optional(ElasticGpuHealth)
      .pipe(T.XmlName("elasticGpuHealth"), T.Ec2QueryName("ElasticGpuHealth"))
      .annotate({ identifier: "ElasticGpuHealth" }),
    ElasticGpuState: S.optional(ElasticGpuState).pipe(
      T.XmlName("elasticGpuState"),
      T.Ec2QueryName("ElasticGpuState"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({ identifier: "ElasticGpus" }) as any as S.Schema<ElasticGpus>;
export type ElasticGpuSet = ElasticGpus[];
export const ElasticGpuSet = S.Array(
  ElasticGpus.pipe(T.XmlName("item")).annotate({ identifier: "ElasticGpus" }),
);
export interface DescribeElasticGpusResult {
  ElasticGpuSet?: ElasticGpus[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeElasticGpusResult = S.suspend(() =>
  S.Struct({
    ElasticGpuSet: S.optional(ElasticGpuSet).pipe(
      T.XmlName("elasticGpuSet"),
      T.Ec2QueryName("ElasticGpuSet"),
    ),
    MaxResults: S.optional(S.Number).pipe(
      T.XmlName("maxResults"),
      T.Ec2QueryName("MaxResults"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeElasticGpusResult",
}) as any as S.Schema<DescribeElasticGpusResult>;
export type ExportImageTaskIdList = string[];
export const ExportImageTaskIdList = S.Array(
  S.String.pipe(T.XmlName("ExportImageTaskId")),
);
export interface DescribeExportImageTasksRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  ExportImageTaskIds?: string[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeExportImageTasksRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    ExportImageTaskIds: S.optional(ExportImageTaskIdList).pipe(
      T.XmlName("ExportImageTaskId"),
    ),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeExportImageTasksRequest",
}) as any as S.Schema<DescribeExportImageTasksRequest>;
export interface ExportTaskS3Location {
  S3Bucket?: string;
  S3Prefix?: string;
}
export const ExportTaskS3Location = S.suspend(() =>
  S.Struct({
    S3Bucket: S.optional(S.String).pipe(
      T.XmlName("s3Bucket"),
      T.Ec2QueryName("S3Bucket"),
    ),
    S3Prefix: S.optional(S.String).pipe(
      T.XmlName("s3Prefix"),
      T.Ec2QueryName("S3Prefix"),
    ),
  }),
).annotate({
  identifier: "ExportTaskS3Location",
}) as any as S.Schema<ExportTaskS3Location>;
export interface ExportImageTask {
  Description?: string;
  ExportImageTaskId?: string;
  ImageId?: string;
  Progress?: string;
  S3ExportLocation?: ExportTaskS3Location;
  Status?: string;
  StatusMessage?: string;
  Tags?: Tag[];
}
export const ExportImageTask = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    ExportImageTaskId: S.optional(S.String).pipe(
      T.XmlName("exportImageTaskId"),
      T.Ec2QueryName("ExportImageTaskId"),
    ),
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    Progress: S.optional(S.String).pipe(
      T.XmlName("progress"),
      T.Ec2QueryName("Progress"),
    ),
    S3ExportLocation: S.optional(ExportTaskS3Location)
      .pipe(T.XmlName("s3ExportLocation"), T.Ec2QueryName("S3ExportLocation"))
      .annotate({ identifier: "ExportTaskS3Location" }),
    Status: S.optional(S.String).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "ExportImageTask",
}) as any as S.Schema<ExportImageTask>;
export type ExportImageTaskList = ExportImageTask[];
export const ExportImageTaskList = S.Array(
  ExportImageTask.pipe(T.XmlName("item")).annotate({
    identifier: "ExportImageTask",
  }),
);
export interface DescribeExportImageTasksResult {
  ExportImageTasks?: ExportImageTask[];
  NextToken?: string;
}
export const DescribeExportImageTasksResult = S.suspend(() =>
  S.Struct({
    ExportImageTasks: S.optional(ExportImageTaskList).pipe(
      T.XmlName("exportImageTaskSet"),
      T.Ec2QueryName("ExportImageTaskSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeExportImageTasksResult",
}) as any as S.Schema<DescribeExportImageTasksResult>;
export type ExportTaskIdStringList = string[];
export const ExportTaskIdStringList = S.Array(
  S.String.pipe(T.XmlName("ExportTaskId")),
);
export interface DescribeExportTasksRequest {
  Filters?: Filter[];
  ExportTaskIds?: string[];
}
export const DescribeExportTasksRequest = S.suspend(() =>
  S.Struct({
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    ExportTaskIds: S.optional(ExportTaskIdStringList).pipe(
      T.XmlName("exportTaskId"),
      T.Ec2QueryName("ExportTaskId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeExportTasksRequest",
}) as any as S.Schema<DescribeExportTasksRequest>;
export type ExportTaskList = ExportTask[];
export const ExportTaskList = S.Array(
  ExportTask.pipe(T.XmlName("item")).annotate({ identifier: "ExportTask" }),
);
export interface DescribeExportTasksResult {
  ExportTasks?: ExportTask[];
}
export const DescribeExportTasksResult = S.suspend(() =>
  S.Struct({
    ExportTasks: S.optional(ExportTaskList).pipe(
      T.XmlName("exportTaskSet"),
      T.Ec2QueryName("ExportTaskSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeExportTasksResult",
}) as any as S.Schema<DescribeExportTasksResult>;
export type FastLaunchImageIdList = string[];
export const FastLaunchImageIdList = S.Array(
  S.String.pipe(T.XmlName("ImageId")),
);
export interface DescribeFastLaunchImagesRequest {
  ImageIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeFastLaunchImagesRequest = S.suspend(() =>
  S.Struct({
    ImageIds: S.optional(FastLaunchImageIdList).pipe(T.XmlName("ImageId")),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeFastLaunchImagesRequest",
}) as any as S.Schema<DescribeFastLaunchImagesRequest>;
export type FastLaunchResourceType = "snapshot" | (string & {});
export const FastLaunchResourceType = S.String;
export interface FastLaunchSnapshotConfigurationResponse {
  TargetResourceCount?: number;
}
export const FastLaunchSnapshotConfigurationResponse = S.suspend(() =>
  S.Struct({
    TargetResourceCount: S.optional(S.Number).pipe(
      T.XmlName("targetResourceCount"),
      T.Ec2QueryName("TargetResourceCount"),
    ),
  }),
).annotate({
  identifier: "FastLaunchSnapshotConfigurationResponse",
}) as any as S.Schema<FastLaunchSnapshotConfigurationResponse>;
export interface FastLaunchLaunchTemplateSpecificationResponse {
  LaunchTemplateId?: string;
  LaunchTemplateName?: string;
  Version?: string;
}
export const FastLaunchLaunchTemplateSpecificationResponse = S.suspend(() =>
  S.Struct({
    LaunchTemplateId: S.optional(S.String).pipe(
      T.XmlName("launchTemplateId"),
      T.Ec2QueryName("LaunchTemplateId"),
    ),
    LaunchTemplateName: S.optional(S.String).pipe(
      T.XmlName("launchTemplateName"),
      T.Ec2QueryName("LaunchTemplateName"),
    ),
    Version: S.optional(S.String).pipe(
      T.XmlName("version"),
      T.Ec2QueryName("Version"),
    ),
  }),
).annotate({
  identifier: "FastLaunchLaunchTemplateSpecificationResponse",
}) as any as S.Schema<FastLaunchLaunchTemplateSpecificationResponse>;
export type FastLaunchStateCode =
  | "enabling"
  | "enabling-failed"
  | "enabled"
  | "enabled-failed"
  | "disabling"
  | "disabling-failed"
  | (string & {});
export const FastLaunchStateCode = S.String;
export interface DescribeFastLaunchImagesSuccessItem {
  ImageId?: string;
  ResourceType?: FastLaunchResourceType;
  SnapshotConfiguration?: FastLaunchSnapshotConfigurationResponse;
  LaunchTemplate?: FastLaunchLaunchTemplateSpecificationResponse;
  MaxParallelLaunches?: number;
  OwnerId?: string;
  State?: FastLaunchStateCode;
  StateTransitionReason?: string;
  StateTransitionTime?: Date;
}
export const DescribeFastLaunchImagesSuccessItem = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    ResourceType: S.optional(FastLaunchResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    SnapshotConfiguration: S.optional(FastLaunchSnapshotConfigurationResponse)
      .pipe(
        T.XmlName("snapshotConfiguration"),
        T.Ec2QueryName("SnapshotConfiguration"),
      )
      .annotate({ identifier: "FastLaunchSnapshotConfigurationResponse" }),
    LaunchTemplate: S.optional(FastLaunchLaunchTemplateSpecificationResponse)
      .pipe(T.XmlName("launchTemplate"), T.Ec2QueryName("LaunchTemplate"))
      .annotate({
        identifier: "FastLaunchLaunchTemplateSpecificationResponse",
      }),
    MaxParallelLaunches: S.optional(S.Number).pipe(
      T.XmlName("maxParallelLaunches"),
      T.Ec2QueryName("MaxParallelLaunches"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    State: S.optional(FastLaunchStateCode).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StateTransitionReason: S.optional(S.String).pipe(
      T.XmlName("stateTransitionReason"),
      T.Ec2QueryName("StateTransitionReason"),
    ),
    StateTransitionTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("stateTransitionTime"),
      T.Ec2QueryName("StateTransitionTime"),
    ),
  }),
).annotate({
  identifier: "DescribeFastLaunchImagesSuccessItem",
}) as any as S.Schema<DescribeFastLaunchImagesSuccessItem>;
export type DescribeFastLaunchImagesSuccessSet =
  DescribeFastLaunchImagesSuccessItem[];
export const DescribeFastLaunchImagesSuccessSet = S.Array(
  DescribeFastLaunchImagesSuccessItem.pipe(T.XmlName("item")).annotate({
    identifier: "DescribeFastLaunchImagesSuccessItem",
  }),
);
export interface DescribeFastLaunchImagesResult {
  FastLaunchImages?: DescribeFastLaunchImagesSuccessItem[];
  NextToken?: string;
}
export const DescribeFastLaunchImagesResult = S.suspend(() =>
  S.Struct({
    FastLaunchImages: S.optional(DescribeFastLaunchImagesSuccessSet).pipe(
      T.XmlName("fastLaunchImageSet"),
      T.Ec2QueryName("FastLaunchImageSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeFastLaunchImagesResult",
}) as any as S.Schema<DescribeFastLaunchImagesResult>;
export interface DescribeFastSnapshotRestoresRequest {
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeFastSnapshotRestoresRequest = S.suspend(() =>
  S.Struct({
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeFastSnapshotRestoresRequest",
}) as any as S.Schema<DescribeFastSnapshotRestoresRequest>;
export type FastSnapshotRestoreStateCode =
  | "enabling"
  | "optimizing"
  | "enabled"
  | "disabling"
  | "disabled"
  | (string & {});
export const FastSnapshotRestoreStateCode = S.String;
export interface DescribeFastSnapshotRestoreSuccessItem {
  SnapshotId?: string;
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  State?: FastSnapshotRestoreStateCode;
  StateTransitionReason?: string;
  OwnerId?: string;
  OwnerAlias?: string;
  EnablingTime?: Date;
  OptimizingTime?: Date;
  EnabledTime?: Date;
  DisablingTime?: Date;
  DisabledTime?: Date;
}
export const DescribeFastSnapshotRestoreSuccessItem = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    State: S.optional(FastSnapshotRestoreStateCode).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StateTransitionReason: S.optional(S.String).pipe(
      T.XmlName("stateTransitionReason"),
      T.Ec2QueryName("StateTransitionReason"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    OwnerAlias: S.optional(S.String).pipe(
      T.XmlName("ownerAlias"),
      T.Ec2QueryName("OwnerAlias"),
    ),
    EnablingTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("enablingTime"), T.Ec2QueryName("EnablingTime")),
    OptimizingTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("optimizingTime"), T.Ec2QueryName("OptimizingTime")),
    EnabledTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("enabledTime"), T.Ec2QueryName("EnabledTime")),
    DisablingTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("disablingTime"), T.Ec2QueryName("DisablingTime")),
    DisabledTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("disabledTime"), T.Ec2QueryName("DisabledTime")),
  }),
).annotate({
  identifier: "DescribeFastSnapshotRestoreSuccessItem",
}) as any as S.Schema<DescribeFastSnapshotRestoreSuccessItem>;
export type DescribeFastSnapshotRestoreSuccessSet =
  DescribeFastSnapshotRestoreSuccessItem[];
export const DescribeFastSnapshotRestoreSuccessSet = S.Array(
  DescribeFastSnapshotRestoreSuccessItem.pipe(T.XmlName("item")).annotate({
    identifier: "DescribeFastSnapshotRestoreSuccessItem",
  }),
);
export interface DescribeFastSnapshotRestoresResult {
  FastSnapshotRestores?: DescribeFastSnapshotRestoreSuccessItem[];
  NextToken?: string;
}
export const DescribeFastSnapshotRestoresResult = S.suspend(() =>
  S.Struct({
    FastSnapshotRestores: S.optional(
      DescribeFastSnapshotRestoreSuccessSet,
    ).pipe(
      T.XmlName("fastSnapshotRestoreSet"),
      T.Ec2QueryName("FastSnapshotRestoreSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeFastSnapshotRestoresResult",
}) as any as S.Schema<DescribeFastSnapshotRestoresResult>;
export type FleetEventType =
  | "instance-change"
  | "fleet-change"
  | "service-error"
  | (string & {});
export const FleetEventType = S.String;
export interface DescribeFleetHistoryRequest {
  DryRun?: boolean;
  EventType?: FleetEventType;
  MaxResults?: number;
  NextToken?: string;
  FleetId?: string;
  StartTime?: Date;
}
export const DescribeFleetHistoryRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    EventType: S.optional(FleetEventType),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    FleetId: S.optional(S.String),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeFleetHistoryRequest",
}) as any as S.Schema<DescribeFleetHistoryRequest>;
export interface EventInformation {
  EventDescription?: string;
  EventSubType?: string;
  InstanceId?: string;
}
export const EventInformation = S.suspend(() =>
  S.Struct({
    EventDescription: S.optional(S.String).pipe(
      T.XmlName("eventDescription"),
      T.Ec2QueryName("EventDescription"),
    ),
    EventSubType: S.optional(S.String).pipe(
      T.XmlName("eventSubType"),
      T.Ec2QueryName("EventSubType"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
  }),
).annotate({
  identifier: "EventInformation",
}) as any as S.Schema<EventInformation>;
export interface HistoryRecordEntry {
  EventInformation?: EventInformation;
  EventType?: FleetEventType;
  Timestamp?: Date;
}
export const HistoryRecordEntry = S.suspend(() =>
  S.Struct({
    EventInformation: S.optional(EventInformation)
      .pipe(T.XmlName("eventInformation"), T.Ec2QueryName("EventInformation"))
      .annotate({ identifier: "EventInformation" }),
    EventType: S.optional(FleetEventType).pipe(
      T.XmlName("eventType"),
      T.Ec2QueryName("EventType"),
    ),
    Timestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("timestamp"), T.Ec2QueryName("Timestamp")),
  }),
).annotate({
  identifier: "HistoryRecordEntry",
}) as any as S.Schema<HistoryRecordEntry>;
export type HistoryRecordSet = HistoryRecordEntry[];
export const HistoryRecordSet = S.Array(
  HistoryRecordEntry.pipe(T.XmlName("item")).annotate({
    identifier: "HistoryRecordEntry",
  }),
);
export interface DescribeFleetHistoryResult {
  HistoryRecords?: HistoryRecordEntry[];
  LastEvaluatedTime?: Date;
  NextToken?: string;
  FleetId?: string;
  StartTime?: Date;
}
export const DescribeFleetHistoryResult = S.suspend(() =>
  S.Struct({
    HistoryRecords: S.optional(HistoryRecordSet).pipe(
      T.XmlName("historyRecordSet"),
      T.Ec2QueryName("HistoryRecordSet"),
    ),
    LastEvaluatedTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("lastEvaluatedTime"), T.Ec2QueryName("LastEvaluatedTime")),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    FleetId: S.optional(S.String).pipe(
      T.XmlName("fleetId"),
      T.Ec2QueryName("FleetId"),
    ),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startTime"), T.Ec2QueryName("StartTime")),
  }).pipe(ns),
).annotate({
  identifier: "DescribeFleetHistoryResult",
}) as any as S.Schema<DescribeFleetHistoryResult>;
export interface DescribeFleetInstancesRequest {
  DryRun?: boolean;
  MaxResults?: number;
  NextToken?: string;
  FleetId?: string;
  Filters?: Filter[];
}
export const DescribeFleetInstancesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    FleetId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeFleetInstancesRequest",
}) as any as S.Schema<DescribeFleetInstancesRequest>;
export type InstanceHealthStatus = "healthy" | "unhealthy" | (string & {});
export const InstanceHealthStatus = S.String;
export interface ActiveInstance {
  InstanceId?: string;
  InstanceType?: string;
  SpotInstanceRequestId?: string;
  InstanceHealth?: InstanceHealthStatus;
}
export const ActiveInstance = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    InstanceType: S.optional(S.String).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    SpotInstanceRequestId: S.optional(S.String).pipe(
      T.XmlName("spotInstanceRequestId"),
      T.Ec2QueryName("SpotInstanceRequestId"),
    ),
    InstanceHealth: S.optional(InstanceHealthStatus).pipe(
      T.XmlName("instanceHealth"),
      T.Ec2QueryName("InstanceHealth"),
    ),
  }),
).annotate({ identifier: "ActiveInstance" }) as any as S.Schema<ActiveInstance>;
export type ActiveInstanceSet = ActiveInstance[];
export const ActiveInstanceSet = S.Array(
  ActiveInstance.pipe(T.XmlName("item")).annotate({
    identifier: "ActiveInstance",
  }),
);
export interface DescribeFleetInstancesResult {
  ActiveInstances?: ActiveInstance[];
  NextToken?: string;
  FleetId?: string;
}
export const DescribeFleetInstancesResult = S.suspend(() =>
  S.Struct({
    ActiveInstances: S.optional(ActiveInstanceSet).pipe(
      T.XmlName("activeInstanceSet"),
      T.Ec2QueryName("ActiveInstanceSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    FleetId: S.optional(S.String).pipe(
      T.XmlName("fleetId"),
      T.Ec2QueryName("FleetId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeFleetInstancesResult",
}) as any as S.Schema<DescribeFleetInstancesResult>;
export interface DescribeFleetsRequest {
  DryRun?: boolean;
  MaxResults?: number;
  NextToken?: string;
  FleetIds?: string[];
  Filters?: Filter[];
}
export const DescribeFleetsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    FleetIds: S.optional(FleetIdSet).pipe(T.XmlName("FleetId")),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeFleetsRequest",
}) as any as S.Schema<DescribeFleetsRequest>;
export type FleetActivityStatus =
  | "error"
  | "pending_fulfillment"
  | "pending_termination"
  | "fulfilled"
  | (string & {});
export const FleetActivityStatus = S.String;
export type FleetLaunchTemplateOverridesList = FleetLaunchTemplateOverrides[];
export const FleetLaunchTemplateOverridesList = S.Array(
  FleetLaunchTemplateOverrides.pipe(T.XmlName("item")).annotate({
    identifier: "FleetLaunchTemplateOverrides",
  }),
);
export interface FleetLaunchTemplateConfig {
  LaunchTemplateSpecification?: FleetLaunchTemplateSpecification;
  Overrides?: FleetLaunchTemplateOverrides[];
}
export const FleetLaunchTemplateConfig = S.suspend(() =>
  S.Struct({
    LaunchTemplateSpecification: S.optional(FleetLaunchTemplateSpecification)
      .pipe(
        T.XmlName("launchTemplateSpecification"),
        T.Ec2QueryName("LaunchTemplateSpecification"),
      )
      .annotate({ identifier: "FleetLaunchTemplateSpecification" }),
    Overrides: S.optional(FleetLaunchTemplateOverridesList).pipe(
      T.XmlName("overrides"),
      T.Ec2QueryName("Overrides"),
    ),
  }),
).annotate({
  identifier: "FleetLaunchTemplateConfig",
}) as any as S.Schema<FleetLaunchTemplateConfig>;
export type FleetLaunchTemplateConfigList = FleetLaunchTemplateConfig[];
export const FleetLaunchTemplateConfigList = S.Array(
  FleetLaunchTemplateConfig.pipe(T.XmlName("item")).annotate({
    identifier: "FleetLaunchTemplateConfig",
  }),
);
export interface TargetCapacitySpecification {
  TotalTargetCapacity?: number;
  OnDemandTargetCapacity?: number;
  SpotTargetCapacity?: number;
  DefaultTargetCapacityType?: DefaultTargetCapacityType;
  TargetCapacityUnitType?: TargetCapacityUnitType;
}
export const TargetCapacitySpecification = S.suspend(() =>
  S.Struct({
    TotalTargetCapacity: S.optional(S.Number).pipe(
      T.XmlName("totalTargetCapacity"),
      T.Ec2QueryName("TotalTargetCapacity"),
    ),
    OnDemandTargetCapacity: S.optional(S.Number).pipe(
      T.XmlName("onDemandTargetCapacity"),
      T.Ec2QueryName("OnDemandTargetCapacity"),
    ),
    SpotTargetCapacity: S.optional(S.Number).pipe(
      T.XmlName("spotTargetCapacity"),
      T.Ec2QueryName("SpotTargetCapacity"),
    ),
    DefaultTargetCapacityType: S.optional(DefaultTargetCapacityType).pipe(
      T.XmlName("defaultTargetCapacityType"),
      T.Ec2QueryName("DefaultTargetCapacityType"),
    ),
    TargetCapacityUnitType: S.optional(TargetCapacityUnitType).pipe(
      T.XmlName("targetCapacityUnitType"),
      T.Ec2QueryName("TargetCapacityUnitType"),
    ),
  }),
).annotate({
  identifier: "TargetCapacitySpecification",
}) as any as S.Schema<TargetCapacitySpecification>;
export interface FleetSpotCapacityRebalance {
  ReplacementStrategy?: FleetReplacementStrategy;
  TerminationDelay?: number;
}
export const FleetSpotCapacityRebalance = S.suspend(() =>
  S.Struct({
    ReplacementStrategy: S.optional(FleetReplacementStrategy).pipe(
      T.XmlName("replacementStrategy"),
      T.Ec2QueryName("ReplacementStrategy"),
    ),
    TerminationDelay: S.optional(S.Number).pipe(
      T.XmlName("terminationDelay"),
      T.Ec2QueryName("TerminationDelay"),
    ),
  }),
).annotate({
  identifier: "FleetSpotCapacityRebalance",
}) as any as S.Schema<FleetSpotCapacityRebalance>;
export interface FleetSpotMaintenanceStrategies {
  CapacityRebalance?: FleetSpotCapacityRebalance;
}
export const FleetSpotMaintenanceStrategies = S.suspend(() =>
  S.Struct({
    CapacityRebalance: S.optional(FleetSpotCapacityRebalance)
      .pipe(T.XmlName("capacityRebalance"), T.Ec2QueryName("CapacityRebalance"))
      .annotate({ identifier: "FleetSpotCapacityRebalance" }),
  }),
).annotate({
  identifier: "FleetSpotMaintenanceStrategies",
}) as any as S.Schema<FleetSpotMaintenanceStrategies>;
export interface SpotOptions {
  AllocationStrategy?: SpotAllocationStrategy;
  MaintenanceStrategies?: FleetSpotMaintenanceStrategies;
  InstanceInterruptionBehavior?: SpotInstanceInterruptionBehavior;
  InstancePoolsToUseCount?: number;
  SingleInstanceType?: boolean;
  SingleAvailabilityZone?: boolean;
  MinTargetCapacity?: number;
  MaxTotalPrice?: string;
}
export const SpotOptions = S.suspend(() =>
  S.Struct({
    AllocationStrategy: S.optional(SpotAllocationStrategy).pipe(
      T.XmlName("allocationStrategy"),
      T.Ec2QueryName("AllocationStrategy"),
    ),
    MaintenanceStrategies: S.optional(FleetSpotMaintenanceStrategies)
      .pipe(
        T.XmlName("maintenanceStrategies"),
        T.Ec2QueryName("MaintenanceStrategies"),
      )
      .annotate({ identifier: "FleetSpotMaintenanceStrategies" }),
    InstanceInterruptionBehavior: S.optional(
      SpotInstanceInterruptionBehavior,
    ).pipe(
      T.XmlName("instanceInterruptionBehavior"),
      T.Ec2QueryName("InstanceInterruptionBehavior"),
    ),
    InstancePoolsToUseCount: S.optional(S.Number).pipe(
      T.XmlName("instancePoolsToUseCount"),
      T.Ec2QueryName("InstancePoolsToUseCount"),
    ),
    SingleInstanceType: S.optional(S.Boolean).pipe(
      T.XmlName("singleInstanceType"),
      T.Ec2QueryName("SingleInstanceType"),
    ),
    SingleAvailabilityZone: S.optional(S.Boolean).pipe(
      T.XmlName("singleAvailabilityZone"),
      T.Ec2QueryName("SingleAvailabilityZone"),
    ),
    MinTargetCapacity: S.optional(S.Number).pipe(
      T.XmlName("minTargetCapacity"),
      T.Ec2QueryName("MinTargetCapacity"),
    ),
    MaxTotalPrice: S.optional(S.String).pipe(
      T.XmlName("maxTotalPrice"),
      T.Ec2QueryName("MaxTotalPrice"),
    ),
  }),
).annotate({ identifier: "SpotOptions" }) as any as S.Schema<SpotOptions>;
export interface CapacityReservationOptions {
  UsageStrategy?: FleetCapacityReservationUsageStrategy;
}
export const CapacityReservationOptions = S.suspend(() =>
  S.Struct({
    UsageStrategy: S.optional(FleetCapacityReservationUsageStrategy).pipe(
      T.XmlName("usageStrategy"),
      T.Ec2QueryName("UsageStrategy"),
    ),
  }),
).annotate({
  identifier: "CapacityReservationOptions",
}) as any as S.Schema<CapacityReservationOptions>;
export interface OnDemandOptions {
  AllocationStrategy?: FleetOnDemandAllocationStrategy;
  CapacityReservationOptions?: CapacityReservationOptions;
  SingleInstanceType?: boolean;
  SingleAvailabilityZone?: boolean;
  MinTargetCapacity?: number;
  MaxTotalPrice?: string;
}
export const OnDemandOptions = S.suspend(() =>
  S.Struct({
    AllocationStrategy: S.optional(FleetOnDemandAllocationStrategy).pipe(
      T.XmlName("allocationStrategy"),
      T.Ec2QueryName("AllocationStrategy"),
    ),
    CapacityReservationOptions: S.optional(CapacityReservationOptions)
      .pipe(
        T.XmlName("capacityReservationOptions"),
        T.Ec2QueryName("CapacityReservationOptions"),
      )
      .annotate({ identifier: "CapacityReservationOptions" }),
    SingleInstanceType: S.optional(S.Boolean).pipe(
      T.XmlName("singleInstanceType"),
      T.Ec2QueryName("SingleInstanceType"),
    ),
    SingleAvailabilityZone: S.optional(S.Boolean).pipe(
      T.XmlName("singleAvailabilityZone"),
      T.Ec2QueryName("SingleAvailabilityZone"),
    ),
    MinTargetCapacity: S.optional(S.Number).pipe(
      T.XmlName("minTargetCapacity"),
      T.Ec2QueryName("MinTargetCapacity"),
    ),
    MaxTotalPrice: S.optional(S.String).pipe(
      T.XmlName("maxTotalPrice"),
      T.Ec2QueryName("MaxTotalPrice"),
    ),
  }),
).annotate({
  identifier: "OnDemandOptions",
}) as any as S.Schema<OnDemandOptions>;
export interface DescribeFleetError {
  LaunchTemplateAndOverrides?: LaunchTemplateAndOverridesResponse;
  Lifecycle?: InstanceLifecycle;
  ErrorCode?: string;
  ErrorMessage?: string;
}
export const DescribeFleetError = S.suspend(() =>
  S.Struct({
    LaunchTemplateAndOverrides: S.optional(LaunchTemplateAndOverridesResponse)
      .pipe(
        T.XmlName("launchTemplateAndOverrides"),
        T.Ec2QueryName("LaunchTemplateAndOverrides"),
      )
      .annotate({ identifier: "LaunchTemplateAndOverridesResponse" }),
    Lifecycle: S.optional(InstanceLifecycle).pipe(
      T.XmlName("lifecycle"),
      T.Ec2QueryName("Lifecycle"),
    ),
    ErrorCode: S.optional(S.String).pipe(
      T.XmlName("errorCode"),
      T.Ec2QueryName("ErrorCode"),
    ),
    ErrorMessage: S.optional(S.String).pipe(
      T.XmlName("errorMessage"),
      T.Ec2QueryName("ErrorMessage"),
    ),
  }),
).annotate({
  identifier: "DescribeFleetError",
}) as any as S.Schema<DescribeFleetError>;
export type DescribeFleetsErrorSet = DescribeFleetError[];
export const DescribeFleetsErrorSet = S.Array(
  DescribeFleetError.pipe(T.XmlName("item")).annotate({
    identifier: "DescribeFleetError",
  }),
);
export interface DescribeFleetsInstances {
  LaunchTemplateAndOverrides?: LaunchTemplateAndOverridesResponse;
  Lifecycle?: InstanceLifecycle;
  InstanceIds?: string[];
  InstanceType?: InstanceType;
  Platform?: PlatformValues;
}
export const DescribeFleetsInstances = S.suspend(() =>
  S.Struct({
    LaunchTemplateAndOverrides: S.optional(LaunchTemplateAndOverridesResponse)
      .pipe(
        T.XmlName("launchTemplateAndOverrides"),
        T.Ec2QueryName("LaunchTemplateAndOverrides"),
      )
      .annotate({ identifier: "LaunchTemplateAndOverridesResponse" }),
    Lifecycle: S.optional(InstanceLifecycle).pipe(
      T.XmlName("lifecycle"),
      T.Ec2QueryName("Lifecycle"),
    ),
    InstanceIds: S.optional(InstanceIdsSet).pipe(
      T.XmlName("instanceIds"),
      T.Ec2QueryName("InstanceIds"),
    ),
    InstanceType: S.optional(InstanceType).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    Platform: S.optional(PlatformValues).pipe(
      T.XmlName("platform"),
      T.Ec2QueryName("Platform"),
    ),
  }),
).annotate({
  identifier: "DescribeFleetsInstances",
}) as any as S.Schema<DescribeFleetsInstances>;
export type DescribeFleetsInstancesSet = DescribeFleetsInstances[];
export const DescribeFleetsInstancesSet = S.Array(
  DescribeFleetsInstances.pipe(T.XmlName("item")).annotate({
    identifier: "DescribeFleetsInstances",
  }),
);
export interface FleetData {
  ActivityStatus?: FleetActivityStatus;
  CreateTime?: Date;
  FleetId?: string;
  FleetState?: FleetStateCode;
  ClientToken?: string;
  ExcessCapacityTerminationPolicy?: FleetExcessCapacityTerminationPolicy;
  FulfilledCapacity?: number;
  FulfilledOnDemandCapacity?: number;
  LaunchTemplateConfigs?: FleetLaunchTemplateConfig[];
  TargetCapacitySpecification?: TargetCapacitySpecification;
  TerminateInstancesWithExpiration?: boolean;
  Type?: FleetType;
  ValidFrom?: Date;
  ValidUntil?: Date;
  ReplaceUnhealthyInstances?: boolean;
  SpotOptions?: SpotOptions;
  OnDemandOptions?: OnDemandOptions;
  Tags?: Tag[];
  Errors?: DescribeFleetError[];
  Instances?: DescribeFleetsInstances[];
  Context?: string;
}
export const FleetData = S.suspend(() =>
  S.Struct({
    ActivityStatus: S.optional(FleetActivityStatus).pipe(
      T.XmlName("activityStatus"),
      T.Ec2QueryName("ActivityStatus"),
    ),
    CreateTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createTime"), T.Ec2QueryName("CreateTime")),
    FleetId: S.optional(S.String).pipe(
      T.XmlName("fleetId"),
      T.Ec2QueryName("FleetId"),
    ),
    FleetState: S.optional(FleetStateCode).pipe(
      T.XmlName("fleetState"),
      T.Ec2QueryName("FleetState"),
    ),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
    ExcessCapacityTerminationPolicy: S.optional(
      FleetExcessCapacityTerminationPolicy,
    ).pipe(
      T.XmlName("excessCapacityTerminationPolicy"),
      T.Ec2QueryName("ExcessCapacityTerminationPolicy"),
    ),
    FulfilledCapacity: S.optional(S.Number).pipe(
      T.XmlName("fulfilledCapacity"),
      T.Ec2QueryName("FulfilledCapacity"),
    ),
    FulfilledOnDemandCapacity: S.optional(S.Number).pipe(
      T.XmlName("fulfilledOnDemandCapacity"),
      T.Ec2QueryName("FulfilledOnDemandCapacity"),
    ),
    LaunchTemplateConfigs: S.optional(FleetLaunchTemplateConfigList).pipe(
      T.XmlName("launchTemplateConfigs"),
      T.Ec2QueryName("LaunchTemplateConfigs"),
    ),
    TargetCapacitySpecification: S.optional(TargetCapacitySpecification)
      .pipe(
        T.XmlName("targetCapacitySpecification"),
        T.Ec2QueryName("TargetCapacitySpecification"),
      )
      .annotate({ identifier: "TargetCapacitySpecification" }),
    TerminateInstancesWithExpiration: S.optional(S.Boolean).pipe(
      T.XmlName("terminateInstancesWithExpiration"),
      T.Ec2QueryName("TerminateInstancesWithExpiration"),
    ),
    Type: S.optional(FleetType).pipe(T.XmlName("type"), T.Ec2QueryName("Type")),
    ValidFrom: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("validFrom"), T.Ec2QueryName("ValidFrom")),
    ValidUntil: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("validUntil"), T.Ec2QueryName("ValidUntil")),
    ReplaceUnhealthyInstances: S.optional(S.Boolean).pipe(
      T.XmlName("replaceUnhealthyInstances"),
      T.Ec2QueryName("ReplaceUnhealthyInstances"),
    ),
    SpotOptions: S.optional(SpotOptions)
      .pipe(T.XmlName("spotOptions"), T.Ec2QueryName("SpotOptions"))
      .annotate({ identifier: "SpotOptions" }),
    OnDemandOptions: S.optional(OnDemandOptions)
      .pipe(T.XmlName("onDemandOptions"), T.Ec2QueryName("OnDemandOptions"))
      .annotate({ identifier: "OnDemandOptions" }),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    Errors: S.optional(DescribeFleetsErrorSet).pipe(
      T.XmlName("errorSet"),
      T.Ec2QueryName("ErrorSet"),
    ),
    Instances: S.optional(DescribeFleetsInstancesSet).pipe(
      T.XmlName("fleetInstanceSet"),
      T.Ec2QueryName("FleetInstanceSet"),
    ),
    Context: S.optional(S.String).pipe(
      T.XmlName("context"),
      T.Ec2QueryName("Context"),
    ),
  }),
).annotate({ identifier: "FleetData" }) as any as S.Schema<FleetData>;
export type FleetSet = FleetData[];
export const FleetSet = S.Array(
  FleetData.pipe(T.XmlName("item")).annotate({ identifier: "FleetData" }),
);
export interface DescribeFleetsResult {
  NextToken?: string;
  Fleets?: FleetData[];
}
export const DescribeFleetsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    Fleets: S.optional(FleetSet).pipe(
      T.XmlName("fleetSet"),
      T.Ec2QueryName("FleetSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeFleetsResult",
}) as any as S.Schema<DescribeFleetsResult>;
export interface DescribeFlowLogsRequest {
  DryRun?: boolean;
  Filter?: Filter[];
  FlowLogIds?: string[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeFlowLogsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filter: S.optional(FilterList),
    FlowLogIds: S.optional(FlowLogIdList).pipe(T.XmlName("FlowLogId")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeFlowLogsRequest",
}) as any as S.Schema<DescribeFlowLogsRequest>;
export interface DestinationOptionsResponse {
  FileFormat?: DestinationFileFormat;
  HiveCompatiblePartitions?: boolean;
  PerHourPartition?: boolean;
}
export const DestinationOptionsResponse = S.suspend(() =>
  S.Struct({
    FileFormat: S.optional(DestinationFileFormat).pipe(
      T.XmlName("fileFormat"),
      T.Ec2QueryName("FileFormat"),
    ),
    HiveCompatiblePartitions: S.optional(S.Boolean).pipe(
      T.XmlName("hiveCompatiblePartitions"),
      T.Ec2QueryName("HiveCompatiblePartitions"),
    ),
    PerHourPartition: S.optional(S.Boolean).pipe(
      T.XmlName("perHourPartition"),
      T.Ec2QueryName("PerHourPartition"),
    ),
  }),
).annotate({
  identifier: "DestinationOptionsResponse",
}) as any as S.Schema<DestinationOptionsResponse>;
export interface FlowLog {
  CreationTime?: Date;
  DeliverLogsErrorMessage?: string;
  DeliverLogsPermissionArn?: string;
  DeliverCrossAccountRole?: string;
  DeliverLogsStatus?: string;
  FlowLogId?: string;
  FlowLogStatus?: string;
  LogGroupName?: string;
  ResourceId?: string;
  TrafficType?: TrafficType;
  LogDestinationType?: LogDestinationType;
  LogDestination?: string;
  LogFormat?: string;
  Tags?: Tag[];
  MaxAggregationInterval?: number;
  DestinationOptions?: DestinationOptionsResponse;
}
export const FlowLog = S.suspend(() =>
  S.Struct({
    CreationTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("creationTime"), T.Ec2QueryName("CreationTime")),
    DeliverLogsErrorMessage: S.optional(S.String).pipe(
      T.XmlName("deliverLogsErrorMessage"),
      T.Ec2QueryName("DeliverLogsErrorMessage"),
    ),
    DeliverLogsPermissionArn: S.optional(S.String).pipe(
      T.XmlName("deliverLogsPermissionArn"),
      T.Ec2QueryName("DeliverLogsPermissionArn"),
    ),
    DeliverCrossAccountRole: S.optional(S.String).pipe(
      T.XmlName("deliverCrossAccountRole"),
      T.Ec2QueryName("DeliverCrossAccountRole"),
    ),
    DeliverLogsStatus: S.optional(S.String).pipe(
      T.XmlName("deliverLogsStatus"),
      T.Ec2QueryName("DeliverLogsStatus"),
    ),
    FlowLogId: S.optional(S.String).pipe(
      T.XmlName("flowLogId"),
      T.Ec2QueryName("FlowLogId"),
    ),
    FlowLogStatus: S.optional(S.String).pipe(
      T.XmlName("flowLogStatus"),
      T.Ec2QueryName("FlowLogStatus"),
    ),
    LogGroupName: S.optional(S.String).pipe(
      T.XmlName("logGroupName"),
      T.Ec2QueryName("LogGroupName"),
    ),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    TrafficType: S.optional(TrafficType).pipe(
      T.XmlName("trafficType"),
      T.Ec2QueryName("TrafficType"),
    ),
    LogDestinationType: S.optional(LogDestinationType).pipe(
      T.XmlName("logDestinationType"),
      T.Ec2QueryName("LogDestinationType"),
    ),
    LogDestination: S.optional(S.String).pipe(
      T.XmlName("logDestination"),
      T.Ec2QueryName("LogDestination"),
    ),
    LogFormat: S.optional(S.String).pipe(
      T.XmlName("logFormat"),
      T.Ec2QueryName("LogFormat"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    MaxAggregationInterval: S.optional(S.Number).pipe(
      T.XmlName("maxAggregationInterval"),
      T.Ec2QueryName("MaxAggregationInterval"),
    ),
    DestinationOptions: S.optional(DestinationOptionsResponse)
      .pipe(
        T.XmlName("destinationOptions"),
        T.Ec2QueryName("DestinationOptions"),
      )
      .annotate({ identifier: "DestinationOptionsResponse" }),
  }),
).annotate({ identifier: "FlowLog" }) as any as S.Schema<FlowLog>;
export type FlowLogSet = FlowLog[];
export const FlowLogSet = S.Array(
  FlowLog.pipe(T.XmlName("item")).annotate({ identifier: "FlowLog" }),
);
export interface DescribeFlowLogsResult {
  FlowLogs?: FlowLog[];
  NextToken?: string;
}
export const DescribeFlowLogsResult = S.suspend(() =>
  S.Struct({
    FlowLogs: S.optional(FlowLogSet).pipe(
      T.XmlName("flowLogSet"),
      T.Ec2QueryName("FlowLogSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeFlowLogsResult",
}) as any as S.Schema<DescribeFlowLogsResult>;
export type FpgaImageAttributeName =
  | "description"
  | "name"
  | "loadPermission"
  | "productCodes"
  | (string & {});
export const FpgaImageAttributeName = S.String;
export interface DescribeFpgaImageAttributeRequest {
  DryRun?: boolean;
  FpgaImageId?: string;
  Attribute?: FpgaImageAttributeName;
}
export const DescribeFpgaImageAttributeRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    FpgaImageId: S.optional(S.String),
    Attribute: S.optional(FpgaImageAttributeName),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeFpgaImageAttributeRequest",
}) as any as S.Schema<DescribeFpgaImageAttributeRequest>;
export type PermissionGroup = "all" | (string & {});
export const PermissionGroup = S.String;
export interface LoadPermission {
  UserId?: string;
  Group?: PermissionGroup;
}
export const LoadPermission = S.suspend(() =>
  S.Struct({
    UserId: S.optional(S.String).pipe(
      T.XmlName("userId"),
      T.Ec2QueryName("UserId"),
    ),
    Group: S.optional(PermissionGroup).pipe(
      T.XmlName("group"),
      T.Ec2QueryName("Group"),
    ),
  }),
).annotate({ identifier: "LoadPermission" }) as any as S.Schema<LoadPermission>;
export type LoadPermissionList = LoadPermission[];
export const LoadPermissionList = S.Array(
  LoadPermission.pipe(T.XmlName("item")).annotate({
    identifier: "LoadPermission",
  }),
);
export type ProductCodeValues = "devpay" | "marketplace" | (string & {});
export const ProductCodeValues = S.String;
export interface ProductCode {
  ProductCodeId?: string;
  ProductCodeType?: ProductCodeValues;
}
export const ProductCode = S.suspend(() =>
  S.Struct({
    ProductCodeId: S.optional(S.String).pipe(
      T.XmlName("productCode"),
      T.Ec2QueryName("ProductCode"),
    ),
    ProductCodeType: S.optional(ProductCodeValues).pipe(
      T.XmlName("type"),
      T.Ec2QueryName("Type"),
    ),
  }),
).annotate({ identifier: "ProductCode" }) as any as S.Schema<ProductCode>;
export type ProductCodeList = ProductCode[];
export const ProductCodeList = S.Array(
  ProductCode.pipe(T.XmlName("item")).annotate({ identifier: "ProductCode" }),
);
export interface FpgaImageAttribute {
  FpgaImageId?: string;
  Name?: string;
  Description?: string;
  LoadPermissions?: LoadPermission[];
  ProductCodes?: ProductCode[];
}
export const FpgaImageAttribute = S.suspend(() =>
  S.Struct({
    FpgaImageId: S.optional(S.String).pipe(
      T.XmlName("fpgaImageId"),
      T.Ec2QueryName("FpgaImageId"),
    ),
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    LoadPermissions: S.optional(LoadPermissionList).pipe(
      T.XmlName("loadPermissions"),
      T.Ec2QueryName("LoadPermissions"),
    ),
    ProductCodes: S.optional(ProductCodeList).pipe(
      T.XmlName("productCodes"),
      T.Ec2QueryName("ProductCodes"),
    ),
  }),
).annotate({
  identifier: "FpgaImageAttribute",
}) as any as S.Schema<FpgaImageAttribute>;
export interface DescribeFpgaImageAttributeResult {
  FpgaImageAttribute?: FpgaImageAttribute;
}
export const DescribeFpgaImageAttributeResult = S.suspend(() =>
  S.Struct({
    FpgaImageAttribute: S.optional(FpgaImageAttribute)
      .pipe(
        T.XmlName("fpgaImageAttribute"),
        T.Ec2QueryName("FpgaImageAttribute"),
      )
      .annotate({ identifier: "FpgaImageAttribute" }),
  }).pipe(ns),
).annotate({
  identifier: "DescribeFpgaImageAttributeResult",
}) as any as S.Schema<DescribeFpgaImageAttributeResult>;
export type FpgaImageIdList = string[];
export const FpgaImageIdList = S.Array(S.String.pipe(T.XmlName("item")));
export type OwnerStringList = string[];
export const OwnerStringList = S.Array(S.String.pipe(T.XmlName("Owner")));
export interface DescribeFpgaImagesRequest {
  DryRun?: boolean;
  FpgaImageIds?: string[];
  Owners?: string[];
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeFpgaImagesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    FpgaImageIds: S.optional(FpgaImageIdList).pipe(T.XmlName("FpgaImageId")),
    Owners: S.optional(OwnerStringList).pipe(T.XmlName("Owner")),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeFpgaImagesRequest",
}) as any as S.Schema<DescribeFpgaImagesRequest>;
export interface PciId {
  DeviceId?: string;
  VendorId?: string;
  SubsystemId?: string;
  SubsystemVendorId?: string;
}
export const PciId = S.suspend(() =>
  S.Struct({
    DeviceId: S.optional(S.String),
    VendorId: S.optional(S.String),
    SubsystemId: S.optional(S.String),
    SubsystemVendorId: S.optional(S.String),
  }),
).annotate({ identifier: "PciId" }) as any as S.Schema<PciId>;
export type FpgaImageStateCode =
  | "pending"
  | "failed"
  | "available"
  | "unavailable"
  | (string & {});
export const FpgaImageStateCode = S.String;
export interface FpgaImageState {
  Code?: FpgaImageStateCode;
  Message?: string;
}
export const FpgaImageState = S.suspend(() =>
  S.Struct({
    Code: S.optional(FpgaImageStateCode).pipe(
      T.XmlName("code"),
      T.Ec2QueryName("Code"),
    ),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({ identifier: "FpgaImageState" }) as any as S.Schema<FpgaImageState>;
export type InstanceTypesList = string[];
export const InstanceTypesList = S.Array(S.String.pipe(T.XmlName("item")));
export interface FpgaImage {
  FpgaImageId?: string;
  FpgaImageGlobalId?: string;
  Name?: string;
  Description?: string;
  ShellVersion?: string;
  PciId?: PciId;
  State?: FpgaImageState;
  CreateTime?: Date;
  UpdateTime?: Date;
  OwnerId?: string;
  OwnerAlias?: string;
  ProductCodes?: ProductCode[];
  Tags?: Tag[];
  Public?: boolean;
  DataRetentionSupport?: boolean;
  InstanceTypes?: string[];
}
export const FpgaImage = S.suspend(() =>
  S.Struct({
    FpgaImageId: S.optional(S.String).pipe(
      T.XmlName("fpgaImageId"),
      T.Ec2QueryName("FpgaImageId"),
    ),
    FpgaImageGlobalId: S.optional(S.String).pipe(
      T.XmlName("fpgaImageGlobalId"),
      T.Ec2QueryName("FpgaImageGlobalId"),
    ),
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    ShellVersion: S.optional(S.String).pipe(
      T.XmlName("shellVersion"),
      T.Ec2QueryName("ShellVersion"),
    ),
    PciId: S.optional(PciId)
      .pipe(T.XmlName("pciId"), T.Ec2QueryName("PciId"))
      .annotate({ identifier: "PciId" }),
    State: S.optional(FpgaImageState)
      .pipe(T.XmlName("state"), T.Ec2QueryName("State"))
      .annotate({ identifier: "FpgaImageState" }),
    CreateTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createTime"), T.Ec2QueryName("CreateTime")),
    UpdateTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("updateTime"), T.Ec2QueryName("UpdateTime")),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    OwnerAlias: S.optional(S.String).pipe(
      T.XmlName("ownerAlias"),
      T.Ec2QueryName("OwnerAlias"),
    ),
    ProductCodes: S.optional(ProductCodeList).pipe(
      T.XmlName("productCodes"),
      T.Ec2QueryName("ProductCodes"),
    ),
    Tags: S.optional(TagList).pipe(T.XmlName("tags"), T.Ec2QueryName("Tags")),
    Public: S.optional(S.Boolean).pipe(
      T.XmlName("public"),
      T.Ec2QueryName("Public"),
    ),
    DataRetentionSupport: S.optional(S.Boolean).pipe(
      T.XmlName("dataRetentionSupport"),
      T.Ec2QueryName("DataRetentionSupport"),
    ),
    InstanceTypes: S.optional(InstanceTypesList).pipe(
      T.XmlName("instanceTypes"),
      T.Ec2QueryName("InstanceTypes"),
    ),
  }),
).annotate({ identifier: "FpgaImage" }) as any as S.Schema<FpgaImage>;
export type FpgaImageList = FpgaImage[];
export const FpgaImageList = S.Array(
  FpgaImage.pipe(T.XmlName("item")).annotate({ identifier: "FpgaImage" }),
);
export interface DescribeFpgaImagesResult {
  FpgaImages?: FpgaImage[];
  NextToken?: string;
}
export const DescribeFpgaImagesResult = S.suspend(() =>
  S.Struct({
    FpgaImages: S.optional(FpgaImageList).pipe(
      T.XmlName("fpgaImageSet"),
      T.Ec2QueryName("FpgaImageSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeFpgaImagesResult",
}) as any as S.Schema<DescribeFpgaImagesResult>;
export interface DescribeHostReservationOfferingsRequest {
  Filter?: Filter[];
  MaxDuration?: number;
  MaxResults?: number;
  MinDuration?: number;
  NextToken?: string;
  OfferingId?: string;
}
export const DescribeHostReservationOfferingsRequest = S.suspend(() =>
  S.Struct({
    Filter: S.optional(FilterList),
    MaxDuration: S.optional(S.Number),
    MaxResults: S.optional(S.Number),
    MinDuration: S.optional(S.Number),
    NextToken: S.optional(S.String),
    OfferingId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeHostReservationOfferingsRequest",
}) as any as S.Schema<DescribeHostReservationOfferingsRequest>;
export type PaymentOption =
  | "AllUpfront"
  | "PartialUpfront"
  | "NoUpfront"
  | (string & {});
export const PaymentOption = S.String;
export interface HostOffering {
  CurrencyCode?: CurrencyCodeValues;
  Duration?: number;
  HourlyPrice?: string;
  InstanceFamily?: string;
  OfferingId?: string;
  PaymentOption?: PaymentOption;
  UpfrontPrice?: string;
}
export const HostOffering = S.suspend(() =>
  S.Struct({
    CurrencyCode: S.optional(CurrencyCodeValues).pipe(
      T.XmlName("currencyCode"),
      T.Ec2QueryName("CurrencyCode"),
    ),
    Duration: S.optional(S.Number).pipe(
      T.XmlName("duration"),
      T.Ec2QueryName("Duration"),
    ),
    HourlyPrice: S.optional(S.String).pipe(
      T.XmlName("hourlyPrice"),
      T.Ec2QueryName("HourlyPrice"),
    ),
    InstanceFamily: S.optional(S.String).pipe(
      T.XmlName("instanceFamily"),
      T.Ec2QueryName("InstanceFamily"),
    ),
    OfferingId: S.optional(S.String).pipe(
      T.XmlName("offeringId"),
      T.Ec2QueryName("OfferingId"),
    ),
    PaymentOption: S.optional(PaymentOption).pipe(
      T.XmlName("paymentOption"),
      T.Ec2QueryName("PaymentOption"),
    ),
    UpfrontPrice: S.optional(S.String).pipe(
      T.XmlName("upfrontPrice"),
      T.Ec2QueryName("UpfrontPrice"),
    ),
  }),
).annotate({ identifier: "HostOffering" }) as any as S.Schema<HostOffering>;
export type HostOfferingSet = HostOffering[];
export const HostOfferingSet = S.Array(
  HostOffering.pipe(T.XmlName("item")).annotate({ identifier: "HostOffering" }),
);
export interface DescribeHostReservationOfferingsResult {
  NextToken?: string;
  OfferingSet?: HostOffering[];
}
export const DescribeHostReservationOfferingsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    OfferingSet: S.optional(HostOfferingSet).pipe(
      T.XmlName("offeringSet"),
      T.Ec2QueryName("OfferingSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeHostReservationOfferingsResult",
}) as any as S.Schema<DescribeHostReservationOfferingsResult>;
export type HostReservationIdSet = string[];
export const HostReservationIdSet = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeHostReservationsRequest {
  Filter?: Filter[];
  HostReservationIdSet?: string[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeHostReservationsRequest = S.suspend(() =>
  S.Struct({
    Filter: S.optional(FilterList),
    HostReservationIdSet: S.optional(HostReservationIdSet),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeHostReservationsRequest",
}) as any as S.Schema<DescribeHostReservationsRequest>;
export type ResponseHostIdSet = string[];
export const ResponseHostIdSet = S.Array(S.String.pipe(T.XmlName("item")));
export type ReservationState =
  | "active"
  | "expired"
  | "cancelled"
  | "scheduled"
  | "pending"
  | "failed"
  | "delayed"
  | "unsupported"
  | "payment-pending"
  | "payment-failed"
  | "retired"
  | (string & {});
export const ReservationState = S.String;
export interface HostReservation {
  Count?: number;
  CurrencyCode?: CurrencyCodeValues;
  Duration?: number;
  End?: Date;
  HostIdSet?: string[];
  HostReservationId?: string;
  HourlyPrice?: string;
  InstanceFamily?: string;
  OfferingId?: string;
  PaymentOption?: PaymentOption;
  Start?: Date;
  State?: ReservationState;
  UpfrontPrice?: string;
  Tags?: Tag[];
}
export const HostReservation = S.suspend(() =>
  S.Struct({
    Count: S.optional(S.Number).pipe(
      T.XmlName("count"),
      T.Ec2QueryName("Count"),
    ),
    CurrencyCode: S.optional(CurrencyCodeValues).pipe(
      T.XmlName("currencyCode"),
      T.Ec2QueryName("CurrencyCode"),
    ),
    Duration: S.optional(S.Number).pipe(
      T.XmlName("duration"),
      T.Ec2QueryName("Duration"),
    ),
    End: S.optional(T.DateFromString.pipe(T.TimestampFormat("date-time"))).pipe(
      T.XmlName("end"),
      T.Ec2QueryName("End"),
    ),
    HostIdSet: S.optional(ResponseHostIdSet).pipe(
      T.XmlName("hostIdSet"),
      T.Ec2QueryName("HostIdSet"),
    ),
    HostReservationId: S.optional(S.String).pipe(
      T.XmlName("hostReservationId"),
      T.Ec2QueryName("HostReservationId"),
    ),
    HourlyPrice: S.optional(S.String).pipe(
      T.XmlName("hourlyPrice"),
      T.Ec2QueryName("HourlyPrice"),
    ),
    InstanceFamily: S.optional(S.String).pipe(
      T.XmlName("instanceFamily"),
      T.Ec2QueryName("InstanceFamily"),
    ),
    OfferingId: S.optional(S.String).pipe(
      T.XmlName("offeringId"),
      T.Ec2QueryName("OfferingId"),
    ),
    PaymentOption: S.optional(PaymentOption).pipe(
      T.XmlName("paymentOption"),
      T.Ec2QueryName("PaymentOption"),
    ),
    Start: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("start"), T.Ec2QueryName("Start")),
    State: S.optional(ReservationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    UpfrontPrice: S.optional(S.String).pipe(
      T.XmlName("upfrontPrice"),
      T.Ec2QueryName("UpfrontPrice"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "HostReservation",
}) as any as S.Schema<HostReservation>;
export type HostReservationSet = HostReservation[];
export const HostReservationSet = S.Array(
  HostReservation.pipe(T.XmlName("item")).annotate({
    identifier: "HostReservation",
  }),
);
export interface DescribeHostReservationsResult {
  HostReservationSet?: HostReservation[];
  NextToken?: string;
}
export const DescribeHostReservationsResult = S.suspend(() =>
  S.Struct({
    HostReservationSet: S.optional(HostReservationSet).pipe(
      T.XmlName("hostReservationSet"),
      T.Ec2QueryName("HostReservationSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeHostReservationsResult",
}) as any as S.Schema<DescribeHostReservationsResult>;
export type RequestHostIdList = string[];
export const RequestHostIdList = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeHostsRequest {
  HostIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  Filter?: Filter[];
}
export const DescribeHostsRequest = S.suspend(() =>
  S.Struct({
    HostIds: S.optional(RequestHostIdList).pipe(
      T.XmlName("hostId"),
      T.Ec2QueryName("HostId"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    MaxResults: S.optional(S.Number).pipe(
      T.XmlName("maxResults"),
      T.Ec2QueryName("MaxResults"),
    ),
    Filter: S.optional(FilterList).pipe(
      T.XmlName("filter"),
      T.Ec2QueryName("Filter"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeHostsRequest",
}) as any as S.Schema<DescribeHostsRequest>;
export interface InstanceCapacity {
  AvailableCapacity?: number;
  InstanceType?: string;
  TotalCapacity?: number;
}
export const InstanceCapacity = S.suspend(() =>
  S.Struct({
    AvailableCapacity: S.optional(S.Number).pipe(
      T.XmlName("availableCapacity"),
      T.Ec2QueryName("AvailableCapacity"),
    ),
    InstanceType: S.optional(S.String).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    TotalCapacity: S.optional(S.Number).pipe(
      T.XmlName("totalCapacity"),
      T.Ec2QueryName("TotalCapacity"),
    ),
  }),
).annotate({
  identifier: "InstanceCapacity",
}) as any as S.Schema<InstanceCapacity>;
export type AvailableInstanceCapacityList = InstanceCapacity[];
export const AvailableInstanceCapacityList = S.Array(
  InstanceCapacity.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceCapacity",
  }),
);
export interface AvailableCapacity {
  AvailableInstanceCapacity?: InstanceCapacity[];
  AvailableVCpus?: number;
}
export const AvailableCapacity = S.suspend(() =>
  S.Struct({
    AvailableInstanceCapacity: S.optional(AvailableInstanceCapacityList).pipe(
      T.XmlName("availableInstanceCapacity"),
      T.Ec2QueryName("AvailableInstanceCapacity"),
    ),
    AvailableVCpus: S.optional(S.Number).pipe(
      T.XmlName("availableVCpus"),
      T.Ec2QueryName("AvailableVCpus"),
    ),
  }),
).annotate({
  identifier: "AvailableCapacity",
}) as any as S.Schema<AvailableCapacity>;
export interface HostProperties {
  Cores?: number;
  InstanceType?: string;
  InstanceFamily?: string;
  Sockets?: number;
  TotalVCpus?: number;
}
export const HostProperties = S.suspend(() =>
  S.Struct({
    Cores: S.optional(S.Number).pipe(
      T.XmlName("cores"),
      T.Ec2QueryName("Cores"),
    ),
    InstanceType: S.optional(S.String).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    InstanceFamily: S.optional(S.String).pipe(
      T.XmlName("instanceFamily"),
      T.Ec2QueryName("InstanceFamily"),
    ),
    Sockets: S.optional(S.Number).pipe(
      T.XmlName("sockets"),
      T.Ec2QueryName("Sockets"),
    ),
    TotalVCpus: S.optional(S.Number).pipe(
      T.XmlName("totalVCpus"),
      T.Ec2QueryName("TotalVCpus"),
    ),
  }),
).annotate({ identifier: "HostProperties" }) as any as S.Schema<HostProperties>;
export interface HostInstance {
  InstanceId?: string;
  InstanceType?: string;
  OwnerId?: string;
}
export const HostInstance = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    InstanceType: S.optional(S.String).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
  }),
).annotate({ identifier: "HostInstance" }) as any as S.Schema<HostInstance>;
export type HostInstanceList = HostInstance[];
export const HostInstanceList = S.Array(
  HostInstance.pipe(T.XmlName("item")).annotate({ identifier: "HostInstance" }),
);
export type AllocationState =
  | "available"
  | "under-assessment"
  | "permanent-failure"
  | "released"
  | "released-permanent-failure"
  | "pending"
  | (string & {});
export const AllocationState = S.String;
export type AllowsMultipleInstanceTypes = "on" | "off" | (string & {});
export const AllowsMultipleInstanceTypes = S.String;
export interface Host {
  AutoPlacement?: AutoPlacement;
  AvailabilityZone?: string;
  AvailableCapacity?: AvailableCapacity;
  ClientToken?: string;
  HostId?: string;
  HostProperties?: HostProperties;
  HostReservationId?: string;
  Instances?: HostInstance[];
  State?: AllocationState;
  AllocationTime?: Date;
  ReleaseTime?: Date;
  Tags?: Tag[];
  HostRecovery?: HostRecovery;
  AllowsMultipleInstanceTypes?: AllowsMultipleInstanceTypes;
  OwnerId?: string;
  AvailabilityZoneId?: string;
  MemberOfServiceLinkedResourceGroup?: boolean;
  OutpostArn?: string;
  HostMaintenance?: HostMaintenance;
  AssetId?: string;
}
export const Host = S.suspend(() =>
  S.Struct({
    AutoPlacement: S.optional(AutoPlacement).pipe(
      T.XmlName("autoPlacement"),
      T.Ec2QueryName("AutoPlacement"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailableCapacity: S.optional(AvailableCapacity)
      .pipe(T.XmlName("availableCapacity"), T.Ec2QueryName("AvailableCapacity"))
      .annotate({ identifier: "AvailableCapacity" }),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
    HostId: S.optional(S.String).pipe(
      T.XmlName("hostId"),
      T.Ec2QueryName("HostId"),
    ),
    HostProperties: S.optional(HostProperties)
      .pipe(T.XmlName("hostProperties"), T.Ec2QueryName("HostProperties"))
      .annotate({ identifier: "HostProperties" }),
    HostReservationId: S.optional(S.String).pipe(
      T.XmlName("hostReservationId"),
      T.Ec2QueryName("HostReservationId"),
    ),
    Instances: S.optional(HostInstanceList).pipe(
      T.XmlName("instances"),
      T.Ec2QueryName("Instances"),
    ),
    State: S.optional(AllocationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    AllocationTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("allocationTime"), T.Ec2QueryName("AllocationTime")),
    ReleaseTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("releaseTime"), T.Ec2QueryName("ReleaseTime")),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    HostRecovery: S.optional(HostRecovery).pipe(
      T.XmlName("hostRecovery"),
      T.Ec2QueryName("HostRecovery"),
    ),
    AllowsMultipleInstanceTypes: S.optional(AllowsMultipleInstanceTypes).pipe(
      T.XmlName("allowsMultipleInstanceTypes"),
      T.Ec2QueryName("AllowsMultipleInstanceTypes"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    MemberOfServiceLinkedResourceGroup: S.optional(S.Boolean).pipe(
      T.XmlName("memberOfServiceLinkedResourceGroup"),
      T.Ec2QueryName("MemberOfServiceLinkedResourceGroup"),
    ),
    OutpostArn: S.optional(S.String).pipe(
      T.XmlName("outpostArn"),
      T.Ec2QueryName("OutpostArn"),
    ),
    HostMaintenance: S.optional(HostMaintenance).pipe(
      T.XmlName("hostMaintenance"),
      T.Ec2QueryName("HostMaintenance"),
    ),
    AssetId: S.optional(S.String).pipe(
      T.XmlName("assetId"),
      T.Ec2QueryName("AssetId"),
    ),
  }),
).annotate({ identifier: "Host" }) as any as S.Schema<Host>;
export type HostList = Host[];
export const HostList = S.Array(
  Host.pipe(T.XmlName("item")).annotate({ identifier: "Host" }),
);
export interface DescribeHostsResult {
  Hosts?: Host[];
  NextToken?: string;
}
export const DescribeHostsResult = S.suspend(() =>
  S.Struct({
    Hosts: S.optional(HostList).pipe(
      T.XmlName("hostSet"),
      T.Ec2QueryName("HostSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeHostsResult",
}) as any as S.Schema<DescribeHostsResult>;
export type AssociationIdList = string[];
export const AssociationIdList = S.Array(
  S.String.pipe(T.XmlName("AssociationId")),
);
export interface DescribeIamInstanceProfileAssociationsRequest {
  AssociationIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeIamInstanceProfileAssociationsRequest = S.suspend(() =>
  S.Struct({
    AssociationIds: S.optional(AssociationIdList).pipe(
      T.XmlName("AssociationId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeIamInstanceProfileAssociationsRequest",
}) as any as S.Schema<DescribeIamInstanceProfileAssociationsRequest>;
export type IamInstanceProfileAssociationSet = IamInstanceProfileAssociation[];
export const IamInstanceProfileAssociationSet = S.Array(
  IamInstanceProfileAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "IamInstanceProfileAssociation",
  }),
);
export interface DescribeIamInstanceProfileAssociationsResult {
  IamInstanceProfileAssociations?: IamInstanceProfileAssociation[];
  NextToken?: string;
}
export const DescribeIamInstanceProfileAssociationsResult = S.suspend(() =>
  S.Struct({
    IamInstanceProfileAssociations: S.optional(
      IamInstanceProfileAssociationSet,
    ).pipe(
      T.XmlName("iamInstanceProfileAssociationSet"),
      T.Ec2QueryName("IamInstanceProfileAssociationSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeIamInstanceProfileAssociationsResult",
}) as any as S.Schema<DescribeIamInstanceProfileAssociationsResult>;
export interface DescribeIdentityIdFormatRequest {
  Resource?: string;
  PrincipalArn?: string;
}
export const DescribeIdentityIdFormatRequest = S.suspend(() =>
  S.Struct({
    Resource: S.optional(S.String).pipe(
      T.XmlName("resource"),
      T.Ec2QueryName("Resource"),
    ),
    PrincipalArn: S.optional(S.String).pipe(
      T.XmlName("principalArn"),
      T.Ec2QueryName("PrincipalArn"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeIdentityIdFormatRequest",
}) as any as S.Schema<DescribeIdentityIdFormatRequest>;
export interface DescribeIdentityIdFormatResult {
  Statuses?: IdFormat[];
}
export const DescribeIdentityIdFormatResult = S.suspend(() =>
  S.Struct({
    Statuses: S.optional(IdFormatList).pipe(
      T.XmlName("statusSet"),
      T.Ec2QueryName("StatusSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeIdentityIdFormatResult",
}) as any as S.Schema<DescribeIdentityIdFormatResult>;
export interface DescribeIdFormatRequest {
  Resource?: string;
}
export const DescribeIdFormatRequest = S.suspend(() =>
  S.Struct({ Resource: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeIdFormatRequest",
}) as any as S.Schema<DescribeIdFormatRequest>;
export interface DescribeIdFormatResult {
  Statuses?: IdFormat[];
}
export const DescribeIdFormatResult = S.suspend(() =>
  S.Struct({
    Statuses: S.optional(IdFormatList).pipe(
      T.XmlName("statusSet"),
      T.Ec2QueryName("StatusSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeIdFormatResult",
}) as any as S.Schema<DescribeIdFormatResult>;
export type ImageAttributeName =
  | "description"
  | "kernel"
  | "ramdisk"
  | "launchPermission"
  | "productCodes"
  | "blockDeviceMapping"
  | "sriovNetSupport"
  | "bootMode"
  | "tpmSupport"
  | "uefiData"
  | "lastLaunchedTime"
  | "imdsSupport"
  | "deregistrationProtection"
  | (string & {});
export const ImageAttributeName = S.String;
export interface DescribeImageAttributeRequest {
  Attribute?: ImageAttributeName;
  ImageId?: string;
  DryRun?: boolean;
}
export const DescribeImageAttributeRequest = S.suspend(() =>
  S.Struct({
    Attribute: S.optional(ImageAttributeName),
    ImageId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeImageAttributeRequest",
}) as any as S.Schema<DescribeImageAttributeRequest>;
export interface LaunchPermission {
  OrganizationArn?: string;
  OrganizationalUnitArn?: string;
  UserId?: string;
  Group?: PermissionGroup;
}
export const LaunchPermission = S.suspend(() =>
  S.Struct({
    OrganizationArn: S.optional(S.String).pipe(
      T.XmlName("organizationArn"),
      T.Ec2QueryName("OrganizationArn"),
    ),
    OrganizationalUnitArn: S.optional(S.String).pipe(
      T.XmlName("organizationalUnitArn"),
      T.Ec2QueryName("OrganizationalUnitArn"),
    ),
    UserId: S.optional(S.String).pipe(
      T.XmlName("userId"),
      T.Ec2QueryName("UserId"),
    ),
    Group: S.optional(PermissionGroup).pipe(
      T.XmlName("group"),
      T.Ec2QueryName("Group"),
    ),
  }),
).annotate({
  identifier: "LaunchPermission",
}) as any as S.Schema<LaunchPermission>;
export type LaunchPermissionList = LaunchPermission[];
export const LaunchPermissionList = S.Array(
  LaunchPermission.pipe(T.XmlName("item")).annotate({
    identifier: "LaunchPermission",
  }),
);
export type BlockDeviceMappingList = BlockDeviceMapping[];
export const BlockDeviceMappingList = S.Array(
  BlockDeviceMapping.pipe(T.XmlName("item")).annotate({
    identifier: "BlockDeviceMapping",
  }),
);
export interface ImageAttribute {
  Description?: AttributeValue;
  KernelId?: AttributeValue;
  RamdiskId?: AttributeValue;
  SriovNetSupport?: AttributeValue;
  BootMode?: AttributeValue;
  TpmSupport?: AttributeValue;
  UefiData?: AttributeValue;
  LastLaunchedTime?: AttributeValue;
  ImdsSupport?: AttributeValue;
  DeregistrationProtection?: AttributeValue;
  ImageId?: string;
  LaunchPermissions?: LaunchPermission[];
  ProductCodes?: ProductCode[];
  BlockDeviceMappings?: BlockDeviceMapping[];
}
export const ImageAttribute = S.suspend(() =>
  S.Struct({
    Description: S.optional(AttributeValue)
      .pipe(T.XmlName("description"), T.Ec2QueryName("Description"))
      .annotate({ identifier: "AttributeValue" }),
    KernelId: S.optional(AttributeValue)
      .pipe(T.XmlName("kernel"), T.Ec2QueryName("Kernel"))
      .annotate({ identifier: "AttributeValue" }),
    RamdiskId: S.optional(AttributeValue)
      .pipe(T.XmlName("ramdisk"), T.Ec2QueryName("Ramdisk"))
      .annotate({ identifier: "AttributeValue" }),
    SriovNetSupport: S.optional(AttributeValue)
      .pipe(T.XmlName("sriovNetSupport"), T.Ec2QueryName("SriovNetSupport"))
      .annotate({ identifier: "AttributeValue" }),
    BootMode: S.optional(AttributeValue)
      .pipe(T.XmlName("bootMode"), T.Ec2QueryName("BootMode"))
      .annotate({ identifier: "AttributeValue" }),
    TpmSupport: S.optional(AttributeValue)
      .pipe(T.XmlName("tpmSupport"), T.Ec2QueryName("TpmSupport"))
      .annotate({ identifier: "AttributeValue" }),
    UefiData: S.optional(AttributeValue)
      .pipe(T.XmlName("uefiData"), T.Ec2QueryName("UefiData"))
      .annotate({ identifier: "AttributeValue" }),
    LastLaunchedTime: S.optional(AttributeValue)
      .pipe(T.XmlName("lastLaunchedTime"), T.Ec2QueryName("LastLaunchedTime"))
      .annotate({ identifier: "AttributeValue" }),
    ImdsSupport: S.optional(AttributeValue)
      .pipe(T.XmlName("imdsSupport"), T.Ec2QueryName("ImdsSupport"))
      .annotate({ identifier: "AttributeValue" }),
    DeregistrationProtection: S.optional(AttributeValue)
      .pipe(
        T.XmlName("deregistrationProtection"),
        T.Ec2QueryName("DeregistrationProtection"),
      )
      .annotate({ identifier: "AttributeValue" }),
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    LaunchPermissions: S.optional(LaunchPermissionList).pipe(
      T.XmlName("launchPermission"),
      T.Ec2QueryName("LaunchPermission"),
    ),
    ProductCodes: S.optional(ProductCodeList).pipe(
      T.XmlName("productCodes"),
      T.Ec2QueryName("ProductCodes"),
    ),
    BlockDeviceMappings: S.optional(BlockDeviceMappingList).pipe(
      T.XmlName("blockDeviceMapping"),
      T.Ec2QueryName("BlockDeviceMapping"),
    ),
  }).pipe(ns),
).annotate({ identifier: "ImageAttribute" }) as any as S.Schema<ImageAttribute>;
export type DescribeImageReferencesImageIdStringList = string[];
export const DescribeImageReferencesImageIdStringList = S.Array(S.String);
export type ImageReferenceResourceType =
  | "ec2:Instance"
  | "ec2:LaunchTemplate"
  | "ssm:Parameter"
  | "imagebuilder:ImageRecipe"
  | "imagebuilder:ContainerRecipe"
  | (string & {});
export const ImageReferenceResourceType = S.String;
export type ImageReferenceOptionName =
  | "state-name"
  | "version-depth"
  | (string & {});
export const ImageReferenceOptionName = S.String;
export type ResourceTypeOptionValuesList = string[];
export const ResourceTypeOptionValuesList = S.Array(S.String);
export interface ResourceTypeOption {
  OptionName?: ImageReferenceOptionName;
  OptionValues?: string[];
}
export const ResourceTypeOption = S.suspend(() =>
  S.Struct({
    OptionName: S.optional(ImageReferenceOptionName),
    OptionValues: S.optional(ResourceTypeOptionValuesList).pipe(
      T.XmlName("OptionValue"),
    ),
  }),
).annotate({
  identifier: "ResourceTypeOption",
}) as any as S.Schema<ResourceTypeOption>;
export type ResourceTypeOptionList = ResourceTypeOption[];
export const ResourceTypeOptionList = S.Array(ResourceTypeOption);
export interface ResourceTypeRequest {
  ResourceType?: ImageReferenceResourceType;
  ResourceTypeOptions?: ResourceTypeOption[];
}
export const ResourceTypeRequest = S.suspend(() =>
  S.Struct({
    ResourceType: S.optional(ImageReferenceResourceType),
    ResourceTypeOptions: S.optional(ResourceTypeOptionList).pipe(
      T.XmlName("ResourceTypeOption"),
    ),
  }),
).annotate({
  identifier: "ResourceTypeRequest",
}) as any as S.Schema<ResourceTypeRequest>;
export type ResourceTypeRequestList = ResourceTypeRequest[];
export const ResourceTypeRequestList = S.Array(ResourceTypeRequest);
export interface DescribeImageReferencesRequest {
  ImageIds?: string[];
  IncludeAllResourceTypes?: boolean;
  ResourceTypes?: ResourceTypeRequest[];
  NextToken?: string;
  DryRun?: boolean;
  MaxResults?: number;
}
export const DescribeImageReferencesRequest = S.suspend(() =>
  S.Struct({
    ImageIds: S.optional(DescribeImageReferencesImageIdStringList).pipe(
      T.XmlName("ImageId"),
    ),
    IncludeAllResourceTypes: S.optional(S.Boolean),
    ResourceTypes: S.optional(ResourceTypeRequestList).pipe(
      T.XmlName("ResourceType"),
    ),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeImageReferencesRequest",
}) as any as S.Schema<DescribeImageReferencesRequest>;
export interface ImageReference {
  ImageId?: string;
  ResourceType?: ImageReferenceResourceType;
  Arn?: string;
}
export const ImageReference = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    ResourceType: S.optional(ImageReferenceResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    Arn: S.optional(S.String).pipe(T.XmlName("arn"), T.Ec2QueryName("Arn")),
  }),
).annotate({ identifier: "ImageReference" }) as any as S.Schema<ImageReference>;
export type ImageReferenceList = ImageReference[];
export const ImageReferenceList = S.Array(
  ImageReference.pipe(T.XmlName("item")).annotate({
    identifier: "ImageReference",
  }),
);
export interface DescribeImageReferencesResult {
  NextToken?: string;
  ImageReferences?: ImageReference[];
}
export const DescribeImageReferencesResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    ImageReferences: S.optional(ImageReferenceList).pipe(
      T.XmlName("imageReferenceSet"),
      T.Ec2QueryName("ImageReferenceSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeImageReferencesResult",
}) as any as S.Schema<DescribeImageReferencesResult>;
export type ExecutableByStringList = string[];
export const ExecutableByStringList = S.Array(
  S.String.pipe(T.XmlName("ExecutableBy")),
);
export type ImageIdStringList = string[];
export const ImageIdStringList = S.Array(S.String.pipe(T.XmlName("ImageId")));
export interface DescribeImagesRequest {
  ExecutableUsers?: string[];
  ImageIds?: string[];
  Owners?: string[];
  IncludeDeprecated?: boolean;
  IncludeDisabled?: boolean;
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
  Filters?: Filter[];
}
export const DescribeImagesRequest = S.suspend(() =>
  S.Struct({
    ExecutableUsers: S.optional(ExecutableByStringList).pipe(
      T.XmlName("ExecutableBy"),
    ),
    ImageIds: S.optional(ImageIdStringList).pipe(T.XmlName("ImageId")),
    Owners: S.optional(OwnerStringList).pipe(T.XmlName("Owner")),
    IncludeDeprecated: S.optional(S.Boolean),
    IncludeDisabled: S.optional(S.Boolean),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeImagesRequest",
}) as any as S.Schema<DescribeImagesRequest>;
export type HypervisorType = "ovm" | "xen" | "nitro" | (string & {});
export const HypervisorType = S.String;
export type DeviceType = "ebs" | "instance-store" | (string & {});
export const DeviceType = S.String;
export type VirtualizationType =
  | "hvm"
  | "paravirtual"
  | "nested-virtualization"
  | (string & {});
export const VirtualizationType = S.String;
export type BootModeValues =
  | "legacy-bios"
  | "uefi"
  | "uefi-preferred"
  | (string & {});
export const BootModeValues = S.String;
export type TpmSupportValues = "v2.0" | (string & {});
export const TpmSupportValues = S.String;
export type ImdsSupportValues = "v2.0" | (string & {});
export const ImdsSupportValues = S.String;
export type ImageState =
  | "pending"
  | "available"
  | "invalid"
  | "deregistered"
  | "transient"
  | "failed"
  | "error"
  | "disabled"
  | (string & {});
export const ImageState = S.String;
export type ArchitectureValues =
  | "i386"
  | "x86_64"
  | "arm64"
  | "x86_64_mac"
  | "arm64_mac"
  | (string & {});
export const ArchitectureValues = S.String;
export type ImageTypeValues = "machine" | "kernel" | "ramdisk" | (string & {});
export const ImageTypeValues = S.String;
export interface Image {
  PlatformDetails?: string;
  UsageOperation?: string;
  BlockDeviceMappings?: BlockDeviceMapping[];
  Description?: string;
  EnaSupport?: boolean;
  Hypervisor?: HypervisorType;
  ImageOwnerAlias?: string;
  Name?: string;
  RootDeviceName?: string;
  RootDeviceType?: DeviceType;
  SriovNetSupport?: string;
  StateReason?: StateReason;
  Tags?: Tag[];
  VirtualizationType?: VirtualizationType;
  BootMode?: BootModeValues;
  TpmSupport?: TpmSupportValues;
  DeprecationTime?: string;
  ImdsSupport?: ImdsSupportValues;
  SourceInstanceId?: string;
  DeregistrationProtection?: string;
  LastLaunchedTime?: string;
  ImageAllowed?: boolean;
  SourceImageId?: string;
  SourceImageRegion?: string;
  FreeTierEligible?: boolean;
  ImageId?: string;
  ImageLocation?: string;
  State?: ImageState;
  OwnerId?: string;
  CreationDate?: string;
  Public?: boolean;
  ProductCodes?: ProductCode[];
  Architecture?: ArchitectureValues;
  ImageType?: ImageTypeValues;
  KernelId?: string;
  RamdiskId?: string;
  Platform?: PlatformValues;
}
export const Image = S.suspend(() =>
  S.Struct({
    PlatformDetails: S.optional(S.String).pipe(
      T.XmlName("platformDetails"),
      T.Ec2QueryName("PlatformDetails"),
    ),
    UsageOperation: S.optional(S.String).pipe(
      T.XmlName("usageOperation"),
      T.Ec2QueryName("UsageOperation"),
    ),
    BlockDeviceMappings: S.optional(BlockDeviceMappingList).pipe(
      T.XmlName("blockDeviceMapping"),
      T.Ec2QueryName("BlockDeviceMapping"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    EnaSupport: S.optional(S.Boolean).pipe(
      T.XmlName("enaSupport"),
      T.Ec2QueryName("EnaSupport"),
    ),
    Hypervisor: S.optional(HypervisorType).pipe(
      T.XmlName("hypervisor"),
      T.Ec2QueryName("Hypervisor"),
    ),
    ImageOwnerAlias: S.optional(S.String).pipe(
      T.XmlName("imageOwnerAlias"),
      T.Ec2QueryName("ImageOwnerAlias"),
    ),
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
    RootDeviceName: S.optional(S.String).pipe(
      T.XmlName("rootDeviceName"),
      T.Ec2QueryName("RootDeviceName"),
    ),
    RootDeviceType: S.optional(DeviceType).pipe(
      T.XmlName("rootDeviceType"),
      T.Ec2QueryName("RootDeviceType"),
    ),
    SriovNetSupport: S.optional(S.String).pipe(
      T.XmlName("sriovNetSupport"),
      T.Ec2QueryName("SriovNetSupport"),
    ),
    StateReason: S.optional(StateReason)
      .pipe(T.XmlName("stateReason"), T.Ec2QueryName("StateReason"))
      .annotate({ identifier: "StateReason" }),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    VirtualizationType: S.optional(VirtualizationType).pipe(
      T.XmlName("virtualizationType"),
      T.Ec2QueryName("VirtualizationType"),
    ),
    BootMode: S.optional(BootModeValues).pipe(
      T.XmlName("bootMode"),
      T.Ec2QueryName("BootMode"),
    ),
    TpmSupport: S.optional(TpmSupportValues).pipe(
      T.XmlName("tpmSupport"),
      T.Ec2QueryName("TpmSupport"),
    ),
    DeprecationTime: S.optional(S.String).pipe(
      T.XmlName("deprecationTime"),
      T.Ec2QueryName("DeprecationTime"),
    ),
    ImdsSupport: S.optional(ImdsSupportValues).pipe(
      T.XmlName("imdsSupport"),
      T.Ec2QueryName("ImdsSupport"),
    ),
    SourceInstanceId: S.optional(S.String).pipe(
      T.XmlName("sourceInstanceId"),
      T.Ec2QueryName("SourceInstanceId"),
    ),
    DeregistrationProtection: S.optional(S.String).pipe(
      T.XmlName("deregistrationProtection"),
      T.Ec2QueryName("DeregistrationProtection"),
    ),
    LastLaunchedTime: S.optional(S.String).pipe(
      T.XmlName("lastLaunchedTime"),
      T.Ec2QueryName("LastLaunchedTime"),
    ),
    ImageAllowed: S.optional(S.Boolean).pipe(
      T.XmlName("imageAllowed"),
      T.Ec2QueryName("ImageAllowed"),
    ),
    SourceImageId: S.optional(S.String).pipe(
      T.XmlName("sourceImageId"),
      T.Ec2QueryName("SourceImageId"),
    ),
    SourceImageRegion: S.optional(S.String).pipe(
      T.XmlName("sourceImageRegion"),
      T.Ec2QueryName("SourceImageRegion"),
    ),
    FreeTierEligible: S.optional(S.Boolean).pipe(
      T.XmlName("freeTierEligible"),
      T.Ec2QueryName("FreeTierEligible"),
    ),
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    ImageLocation: S.optional(S.String).pipe(
      T.XmlName("imageLocation"),
      T.Ec2QueryName("ImageLocation"),
    ),
    State: S.optional(ImageState).pipe(
      T.XmlName("imageState"),
      T.Ec2QueryName("ImageState"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("imageOwnerId"),
      T.Ec2QueryName("ImageOwnerId"),
    ),
    CreationDate: S.optional(S.String).pipe(
      T.XmlName("creationDate"),
      T.Ec2QueryName("CreationDate"),
    ),
    Public: S.optional(S.Boolean).pipe(
      T.XmlName("isPublic"),
      T.Ec2QueryName("IsPublic"),
    ),
    ProductCodes: S.optional(ProductCodeList).pipe(
      T.XmlName("productCodes"),
      T.Ec2QueryName("ProductCodes"),
    ),
    Architecture: S.optional(ArchitectureValues).pipe(
      T.XmlName("architecture"),
      T.Ec2QueryName("Architecture"),
    ),
    ImageType: S.optional(ImageTypeValues).pipe(
      T.XmlName("imageType"),
      T.Ec2QueryName("ImageType"),
    ),
    KernelId: S.optional(S.String).pipe(
      T.XmlName("kernelId"),
      T.Ec2QueryName("KernelId"),
    ),
    RamdiskId: S.optional(S.String).pipe(
      T.XmlName("ramdiskId"),
      T.Ec2QueryName("RamdiskId"),
    ),
    Platform: S.optional(PlatformValues).pipe(
      T.XmlName("platform"),
      T.Ec2QueryName("Platform"),
    ),
  }),
).annotate({ identifier: "Image" }) as any as S.Schema<Image>;
export type ImageList = Image[];
export const ImageList = S.Array(
  Image.pipe(T.XmlName("item")).annotate({ identifier: "Image" }),
);
export interface DescribeImagesResult {
  NextToken?: string;
  Images?: Image[];
}
export const DescribeImagesResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    Images: S.optional(ImageList).pipe(
      T.XmlName("imagesSet"),
      T.Ec2QueryName("ImagesSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeImagesResult",
}) as any as S.Schema<DescribeImagesResult>;
export type DescribeImageUsageReportsImageIdStringList = string[];
export const DescribeImageUsageReportsImageIdStringList = S.Array(S.String);
export type ImageUsageReportIdStringList = string[];
export const ImageUsageReportIdStringList = S.Array(S.String);
export interface DescribeImageUsageReportEntriesRequest {
  ImageIds?: string[];
  ReportIds?: string[];
  NextToken?: string;
  Filters?: Filter[];
  DryRun?: boolean;
  MaxResults?: number;
}
export const DescribeImageUsageReportEntriesRequest = S.suspend(() =>
  S.Struct({
    ImageIds: S.optional(DescribeImageUsageReportsImageIdStringList).pipe(
      T.XmlName("ImageId"),
    ),
    ReportIds: S.optional(ImageUsageReportIdStringList).pipe(
      T.XmlName("ReportId"),
    ),
    NextToken: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeImageUsageReportEntriesRequest",
}) as any as S.Schema<DescribeImageUsageReportEntriesRequest>;
export interface ImageUsageReportEntry {
  ResourceType?: string;
  ReportId?: string;
  UsageCount?: number;
  AccountId?: string;
  ImageId?: string;
  ReportCreationTime?: Date;
}
export const ImageUsageReportEntry = S.suspend(() =>
  S.Struct({
    ResourceType: S.optional(S.String).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    ReportId: S.optional(S.String).pipe(
      T.XmlName("reportId"),
      T.Ec2QueryName("ReportId"),
    ),
    UsageCount: S.optional(S.Number).pipe(
      T.XmlName("usageCount"),
      T.Ec2QueryName("UsageCount"),
    ),
    AccountId: S.optional(S.String).pipe(
      T.XmlName("accountId"),
      T.Ec2QueryName("AccountId"),
    ),
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    ReportCreationTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("reportCreationTime"),
      T.Ec2QueryName("ReportCreationTime"),
    ),
  }),
).annotate({
  identifier: "ImageUsageReportEntry",
}) as any as S.Schema<ImageUsageReportEntry>;
export type ImageUsageReportEntryList = ImageUsageReportEntry[];
export const ImageUsageReportEntryList = S.Array(
  ImageUsageReportEntry.pipe(T.XmlName("item")).annotate({
    identifier: "ImageUsageReportEntry",
  }),
);
export interface DescribeImageUsageReportEntriesResult {
  NextToken?: string;
  ImageUsageReportEntries?: ImageUsageReportEntry[];
}
export const DescribeImageUsageReportEntriesResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    ImageUsageReportEntries: S.optional(ImageUsageReportEntryList).pipe(
      T.XmlName("imageUsageReportEntrySet"),
      T.Ec2QueryName("ImageUsageReportEntrySet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeImageUsageReportEntriesResult",
}) as any as S.Schema<DescribeImageUsageReportEntriesResult>;
export interface DescribeImageUsageReportsRequest {
  ImageIds?: string[];
  ReportIds?: string[];
  NextToken?: string;
  Filters?: Filter[];
  DryRun?: boolean;
  MaxResults?: number;
}
export const DescribeImageUsageReportsRequest = S.suspend(() =>
  S.Struct({
    ImageIds: S.optional(DescribeImageUsageReportsImageIdStringList).pipe(
      T.XmlName("ImageId"),
    ),
    ReportIds: S.optional(ImageUsageReportIdStringList).pipe(
      T.XmlName("ReportId"),
    ),
    NextToken: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeImageUsageReportsRequest",
}) as any as S.Schema<DescribeImageUsageReportsRequest>;
export interface ImageUsageResourceTypeOption {
  OptionName?: string;
  OptionValues?: string[];
}
export const ImageUsageResourceTypeOption = S.suspend(() =>
  S.Struct({
    OptionName: S.optional(S.String).pipe(
      T.XmlName("optionName"),
      T.Ec2QueryName("OptionName"),
    ),
    OptionValues: S.optional(ImageUsageResourceTypeOptionValuesList).pipe(
      T.XmlName("optionValueSet"),
      T.Ec2QueryName("OptionValueSet"),
    ),
  }),
).annotate({
  identifier: "ImageUsageResourceTypeOption",
}) as any as S.Schema<ImageUsageResourceTypeOption>;
export type ImageUsageResourceTypeOptionList = ImageUsageResourceTypeOption[];
export const ImageUsageResourceTypeOptionList = S.Array(
  ImageUsageResourceTypeOption.pipe(T.XmlName("item")).annotate({
    identifier: "ImageUsageResourceTypeOption",
  }),
);
export interface ImageUsageResourceType {
  ResourceType?: string;
  ResourceTypeOptions?: ImageUsageResourceTypeOption[];
}
export const ImageUsageResourceType = S.suspend(() =>
  S.Struct({
    ResourceType: S.optional(S.String).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    ResourceTypeOptions: S.optional(ImageUsageResourceTypeOptionList).pipe(
      T.XmlName("resourceTypeOptionSet"),
      T.Ec2QueryName("ResourceTypeOptionSet"),
    ),
  }),
).annotate({
  identifier: "ImageUsageResourceType",
}) as any as S.Schema<ImageUsageResourceType>;
export type ImageUsageResourceTypeList = ImageUsageResourceType[];
export const ImageUsageResourceTypeList = S.Array(
  ImageUsageResourceType.pipe(T.XmlName("item")).annotate({
    identifier: "ImageUsageResourceType",
  }),
);
export type UserIdList = string[];
export const UserIdList = S.Array(S.String.pipe(T.XmlName("item")));
export interface ImageUsageReport {
  ImageId?: string;
  ReportId?: string;
  ResourceTypes?: ImageUsageResourceType[];
  AccountIds?: string[];
  State?: string;
  StateReason?: string;
  CreationTime?: Date;
  ExpirationTime?: Date;
  Tags?: Tag[];
}
export const ImageUsageReport = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    ReportId: S.optional(S.String).pipe(
      T.XmlName("reportId"),
      T.Ec2QueryName("ReportId"),
    ),
    ResourceTypes: S.optional(ImageUsageResourceTypeList).pipe(
      T.XmlName("resourceTypeSet"),
      T.Ec2QueryName("ResourceTypeSet"),
    ),
    AccountIds: S.optional(UserIdList).pipe(
      T.XmlName("accountIdSet"),
      T.Ec2QueryName("AccountIdSet"),
    ),
    State: S.optional(S.String).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StateReason: S.optional(S.String).pipe(
      T.XmlName("stateReason"),
      T.Ec2QueryName("StateReason"),
    ),
    CreationTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("creationTime"), T.Ec2QueryName("CreationTime")),
    ExpirationTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("expirationTime"), T.Ec2QueryName("ExpirationTime")),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "ImageUsageReport",
}) as any as S.Schema<ImageUsageReport>;
export type ImageUsageReportList = ImageUsageReport[];
export const ImageUsageReportList = S.Array(
  ImageUsageReport.pipe(T.XmlName("item")).annotate({
    identifier: "ImageUsageReport",
  }),
);
export interface DescribeImageUsageReportsResult {
  NextToken?: string;
  ImageUsageReports?: ImageUsageReport[];
}
export const DescribeImageUsageReportsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    ImageUsageReports: S.optional(ImageUsageReportList).pipe(
      T.XmlName("imageUsageReportSet"),
      T.Ec2QueryName("ImageUsageReportSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeImageUsageReportsResult",
}) as any as S.Schema<DescribeImageUsageReportsResult>;
export type ImportTaskIdList = string[];
export const ImportTaskIdList = S.Array(
  S.String.pipe(T.XmlName("ImportTaskId")),
);
export interface DescribeImportImageTasksRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  ImportTaskIds?: string[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeImportImageTasksRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filters")),
    ImportTaskIds: S.optional(ImportTaskIdList).pipe(T.XmlName("ImportTaskId")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeImportImageTasksRequest",
}) as any as S.Schema<DescribeImportImageTasksRequest>;
export interface UserBucketDetails {
  S3Bucket?: string;
  S3Key?: string;
}
export const UserBucketDetails = S.suspend(() =>
  S.Struct({
    S3Bucket: S.optional(S.String).pipe(
      T.XmlName("s3Bucket"),
      T.Ec2QueryName("S3Bucket"),
    ),
    S3Key: S.optional(S.String).pipe(
      T.XmlName("s3Key"),
      T.Ec2QueryName("S3Key"),
    ),
  }),
).annotate({
  identifier: "UserBucketDetails",
}) as any as S.Schema<UserBucketDetails>;
export interface SnapshotDetail {
  Description?: string;
  DeviceName?: string;
  DiskImageSize?: number;
  Format?: string;
  Progress?: string;
  SnapshotId?: string;
  Status?: string;
  StatusMessage?: string;
  Url?: string | redacted.Redacted<string>;
  UserBucket?: UserBucketDetails;
}
export const SnapshotDetail = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    DeviceName: S.optional(S.String).pipe(
      T.XmlName("deviceName"),
      T.Ec2QueryName("DeviceName"),
    ),
    DiskImageSize: S.optional(S.Number).pipe(
      T.XmlName("diskImageSize"),
      T.Ec2QueryName("DiskImageSize"),
    ),
    Format: S.optional(S.String).pipe(
      T.XmlName("format"),
      T.Ec2QueryName("Format"),
    ),
    Progress: S.optional(S.String).pipe(
      T.XmlName("progress"),
      T.Ec2QueryName("Progress"),
    ),
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    Status: S.optional(S.String).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    Url: S.optional(SensitiveString).pipe(
      T.XmlName("url"),
      T.Ec2QueryName("Url"),
    ),
    UserBucket: S.optional(UserBucketDetails)
      .pipe(T.XmlName("userBucket"), T.Ec2QueryName("UserBucket"))
      .annotate({ identifier: "UserBucketDetails" }),
  }),
).annotate({ identifier: "SnapshotDetail" }) as any as S.Schema<SnapshotDetail>;
export type SnapshotDetailList = SnapshotDetail[];
export const SnapshotDetailList = S.Array(
  SnapshotDetail.pipe(T.XmlName("item")).annotate({
    identifier: "SnapshotDetail",
  }),
);
export interface ImportImageLicenseConfigurationResponse {
  LicenseConfigurationArn?: string;
}
export const ImportImageLicenseConfigurationResponse = S.suspend(() =>
  S.Struct({
    LicenseConfigurationArn: S.optional(S.String).pipe(
      T.XmlName("licenseConfigurationArn"),
      T.Ec2QueryName("LicenseConfigurationArn"),
    ),
  }),
).annotate({
  identifier: "ImportImageLicenseConfigurationResponse",
}) as any as S.Schema<ImportImageLicenseConfigurationResponse>;
export type ImportImageLicenseSpecificationListResponse =
  ImportImageLicenseConfigurationResponse[];
export const ImportImageLicenseSpecificationListResponse = S.Array(
  ImportImageLicenseConfigurationResponse.pipe(T.XmlName("item")).annotate({
    identifier: "ImportImageLicenseConfigurationResponse",
  }),
);
export interface ImportImageTask {
  Architecture?: string;
  Description?: string;
  Encrypted?: boolean;
  Hypervisor?: string;
  ImageId?: string;
  ImportTaskId?: string;
  KmsKeyId?: string;
  LicenseType?: string;
  Platform?: string;
  Progress?: string;
  SnapshotDetails?: SnapshotDetail[];
  Status?: string;
  StatusMessage?: string;
  Tags?: Tag[];
  LicenseSpecifications?: ImportImageLicenseConfigurationResponse[];
  UsageOperation?: string;
  BootMode?: BootModeValues;
}
export const ImportImageTask = S.suspend(() =>
  S.Struct({
    Architecture: S.optional(S.String).pipe(
      T.XmlName("architecture"),
      T.Ec2QueryName("Architecture"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    Encrypted: S.optional(S.Boolean).pipe(
      T.XmlName("encrypted"),
      T.Ec2QueryName("Encrypted"),
    ),
    Hypervisor: S.optional(S.String).pipe(
      T.XmlName("hypervisor"),
      T.Ec2QueryName("Hypervisor"),
    ),
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    ImportTaskId: S.optional(S.String).pipe(
      T.XmlName("importTaskId"),
      T.Ec2QueryName("ImportTaskId"),
    ),
    KmsKeyId: S.optional(S.String).pipe(
      T.XmlName("kmsKeyId"),
      T.Ec2QueryName("KmsKeyId"),
    ),
    LicenseType: S.optional(S.String).pipe(
      T.XmlName("licenseType"),
      T.Ec2QueryName("LicenseType"),
    ),
    Platform: S.optional(S.String).pipe(
      T.XmlName("platform"),
      T.Ec2QueryName("Platform"),
    ),
    Progress: S.optional(S.String).pipe(
      T.XmlName("progress"),
      T.Ec2QueryName("Progress"),
    ),
    SnapshotDetails: S.optional(SnapshotDetailList).pipe(
      T.XmlName("snapshotDetailSet"),
      T.Ec2QueryName("SnapshotDetailSet"),
    ),
    Status: S.optional(S.String).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    LicenseSpecifications: S.optional(
      ImportImageLicenseSpecificationListResponse,
    ).pipe(
      T.XmlName("licenseSpecifications"),
      T.Ec2QueryName("LicenseSpecifications"),
    ),
    UsageOperation: S.optional(S.String).pipe(
      T.XmlName("usageOperation"),
      T.Ec2QueryName("UsageOperation"),
    ),
    BootMode: S.optional(BootModeValues).pipe(
      T.XmlName("bootMode"),
      T.Ec2QueryName("BootMode"),
    ),
  }),
).annotate({
  identifier: "ImportImageTask",
}) as any as S.Schema<ImportImageTask>;
export type ImportImageTaskList = ImportImageTask[];
export const ImportImageTaskList = S.Array(
  ImportImageTask.pipe(T.XmlName("item")).annotate({
    identifier: "ImportImageTask",
  }),
);
export interface DescribeImportImageTasksResult {
  ImportImageTasks?: ImportImageTask[];
  NextToken?: string;
}
export const DescribeImportImageTasksResult = S.suspend(() =>
  S.Struct({
    ImportImageTasks: S.optional(ImportImageTaskList).pipe(
      T.XmlName("importImageTaskSet"),
      T.Ec2QueryName("ImportImageTaskSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeImportImageTasksResult",
}) as any as S.Schema<DescribeImportImageTasksResult>;
export type ImportSnapshotTaskIdList = string[];
export const ImportSnapshotTaskIdList = S.Array(
  S.String.pipe(T.XmlName("ImportTaskId")),
);
export interface DescribeImportSnapshotTasksRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  ImportTaskIds?: string[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeImportSnapshotTasksRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filters")),
    ImportTaskIds: S.optional(ImportSnapshotTaskIdList).pipe(
      T.XmlName("ImportTaskId"),
    ),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeImportSnapshotTasksRequest",
}) as any as S.Schema<DescribeImportSnapshotTasksRequest>;
export interface SnapshotTaskDetail {
  Description?: string;
  DiskImageSize?: number;
  Encrypted?: boolean;
  Format?: string;
  KmsKeyId?: string;
  Progress?: string;
  SnapshotId?: string;
  Status?: string;
  StatusMessage?: string;
  Url?: string | redacted.Redacted<string>;
  UserBucket?: UserBucketDetails;
}
export const SnapshotTaskDetail = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    DiskImageSize: S.optional(S.Number).pipe(
      T.XmlName("diskImageSize"),
      T.Ec2QueryName("DiskImageSize"),
    ),
    Encrypted: S.optional(S.Boolean).pipe(
      T.XmlName("encrypted"),
      T.Ec2QueryName("Encrypted"),
    ),
    Format: S.optional(S.String).pipe(
      T.XmlName("format"),
      T.Ec2QueryName("Format"),
    ),
    KmsKeyId: S.optional(S.String).pipe(
      T.XmlName("kmsKeyId"),
      T.Ec2QueryName("KmsKeyId"),
    ),
    Progress: S.optional(S.String).pipe(
      T.XmlName("progress"),
      T.Ec2QueryName("Progress"),
    ),
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    Status: S.optional(S.String).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    Url: S.optional(SensitiveString).pipe(
      T.XmlName("url"),
      T.Ec2QueryName("Url"),
    ),
    UserBucket: S.optional(UserBucketDetails)
      .pipe(T.XmlName("userBucket"), T.Ec2QueryName("UserBucket"))
      .annotate({ identifier: "UserBucketDetails" }),
  }),
).annotate({
  identifier: "SnapshotTaskDetail",
}) as any as S.Schema<SnapshotTaskDetail>;
export interface ImportSnapshotTask {
  Description?: string;
  ImportTaskId?: string;
  SnapshotTaskDetail?: SnapshotTaskDetail;
  Tags?: Tag[];
}
export const ImportSnapshotTask = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    ImportTaskId: S.optional(S.String).pipe(
      T.XmlName("importTaskId"),
      T.Ec2QueryName("ImportTaskId"),
    ),
    SnapshotTaskDetail: S.optional(SnapshotTaskDetail)
      .pipe(
        T.XmlName("snapshotTaskDetail"),
        T.Ec2QueryName("SnapshotTaskDetail"),
      )
      .annotate({ identifier: "SnapshotTaskDetail" }),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "ImportSnapshotTask",
}) as any as S.Schema<ImportSnapshotTask>;
export type ImportSnapshotTaskList = ImportSnapshotTask[];
export const ImportSnapshotTaskList = S.Array(
  ImportSnapshotTask.pipe(T.XmlName("item")).annotate({
    identifier: "ImportSnapshotTask",
  }),
);
export interface DescribeImportSnapshotTasksResult {
  ImportSnapshotTasks?: ImportSnapshotTask[];
  NextToken?: string;
}
export const DescribeImportSnapshotTasksResult = S.suspend(() =>
  S.Struct({
    ImportSnapshotTasks: S.optional(ImportSnapshotTaskList).pipe(
      T.XmlName("importSnapshotTaskSet"),
      T.Ec2QueryName("ImportSnapshotTaskSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeImportSnapshotTasksResult",
}) as any as S.Schema<DescribeImportSnapshotTasksResult>;
export type InstanceAttributeName =
  | "instanceType"
  | "kernel"
  | "ramdisk"
  | "userData"
  | "disableApiTermination"
  | "instanceInitiatedShutdownBehavior"
  | "rootDeviceName"
  | "blockDeviceMapping"
  | "productCodes"
  | "sourceDestCheck"
  | "groupSet"
  | "ebsOptimized"
  | "sriovNetSupport"
  | "enaSupport"
  | "enclaveOptions"
  | "disableApiStop"
  | (string & {});
export const InstanceAttributeName = S.String;
export interface DescribeInstanceAttributeRequest {
  DryRun?: boolean;
  InstanceId?: string;
  Attribute?: InstanceAttributeName;
}
export const DescribeInstanceAttributeRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    Attribute: S.optional(InstanceAttributeName).pipe(
      T.XmlName("attribute"),
      T.Ec2QueryName("Attribute"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInstanceAttributeRequest",
}) as any as S.Schema<DescribeInstanceAttributeRequest>;
export interface EbsInstanceBlockDevice {
  AttachTime?: Date;
  DeleteOnTermination?: boolean;
  Status?: AttachmentStatus;
  VolumeId?: string;
  AssociatedResource?: string;
  VolumeOwnerId?: string;
  Operator?: OperatorResponse;
  EbsCardIndex?: number;
}
export const EbsInstanceBlockDevice = S.suspend(() =>
  S.Struct({
    AttachTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("attachTime"), T.Ec2QueryName("AttachTime")),
    DeleteOnTermination: S.optional(S.Boolean).pipe(
      T.XmlName("deleteOnTermination"),
      T.Ec2QueryName("DeleteOnTermination"),
    ),
    Status: S.optional(AttachmentStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    VolumeId: S.optional(S.String).pipe(
      T.XmlName("volumeId"),
      T.Ec2QueryName("VolumeId"),
    ),
    AssociatedResource: S.optional(S.String).pipe(
      T.XmlName("associatedResource"),
      T.Ec2QueryName("AssociatedResource"),
    ),
    VolumeOwnerId: S.optional(S.String).pipe(
      T.XmlName("volumeOwnerId"),
      T.Ec2QueryName("VolumeOwnerId"),
    ),
    Operator: S.optional(OperatorResponse)
      .pipe(T.XmlName("operator"), T.Ec2QueryName("Operator"))
      .annotate({ identifier: "OperatorResponse" }),
    EbsCardIndex: S.optional(S.Number).pipe(
      T.XmlName("ebsCardIndex"),
      T.Ec2QueryName("EbsCardIndex"),
    ),
  }),
).annotate({
  identifier: "EbsInstanceBlockDevice",
}) as any as S.Schema<EbsInstanceBlockDevice>;
export interface InstanceBlockDeviceMapping {
  DeviceName?: string;
  Ebs?: EbsInstanceBlockDevice;
}
export const InstanceBlockDeviceMapping = S.suspend(() =>
  S.Struct({
    DeviceName: S.optional(S.String).pipe(
      T.XmlName("deviceName"),
      T.Ec2QueryName("DeviceName"),
    ),
    Ebs: S.optional(EbsInstanceBlockDevice)
      .pipe(T.XmlName("ebs"), T.Ec2QueryName("Ebs"))
      .annotate({ identifier: "EbsInstanceBlockDevice" }),
  }),
).annotate({
  identifier: "InstanceBlockDeviceMapping",
}) as any as S.Schema<InstanceBlockDeviceMapping>;
export type InstanceBlockDeviceMappingList = InstanceBlockDeviceMapping[];
export const InstanceBlockDeviceMappingList = S.Array(
  InstanceBlockDeviceMapping.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceBlockDeviceMapping",
  }),
);
export interface AttributeBooleanValue {
  Value?: boolean;
}
export const AttributeBooleanValue = S.suspend(() =>
  S.Struct({
    Value: S.optional(S.Boolean).pipe(
      T.XmlName("value"),
      T.Ec2QueryName("Value"),
    ),
  }),
).annotate({
  identifier: "AttributeBooleanValue",
}) as any as S.Schema<AttributeBooleanValue>;
export interface EnclaveOptions {
  Enabled?: boolean;
}
export const EnclaveOptions = S.suspend(() =>
  S.Struct({
    Enabled: S.optional(S.Boolean).pipe(
      T.XmlName("enabled"),
      T.Ec2QueryName("Enabled"),
    ),
  }),
).annotate({ identifier: "EnclaveOptions" }) as any as S.Schema<EnclaveOptions>;
export interface InstanceAttribute {
  BlockDeviceMappings?: InstanceBlockDeviceMapping[];
  DisableApiTermination?: AttributeBooleanValue;
  EnaSupport?: AttributeBooleanValue;
  EnclaveOptions?: EnclaveOptions;
  EbsOptimized?: AttributeBooleanValue;
  InstanceId?: string;
  InstanceInitiatedShutdownBehavior?: AttributeValue;
  InstanceType?: AttributeValue;
  KernelId?: AttributeValue;
  ProductCodes?: ProductCode[];
  RamdiskId?: AttributeValue;
  RootDeviceName?: AttributeValue;
  SourceDestCheck?: AttributeBooleanValue;
  SriovNetSupport?: AttributeValue;
  UserData?: AttributeValue;
  DisableApiStop?: AttributeBooleanValue;
  Groups?: GroupIdentifier[];
}
export const InstanceAttribute = S.suspend(() =>
  S.Struct({
    BlockDeviceMappings: S.optional(InstanceBlockDeviceMappingList).pipe(
      T.XmlName("blockDeviceMapping"),
      T.Ec2QueryName("BlockDeviceMapping"),
    ),
    DisableApiTermination: S.optional(AttributeBooleanValue)
      .pipe(
        T.XmlName("disableApiTermination"),
        T.Ec2QueryName("DisableApiTermination"),
      )
      .annotate({ identifier: "AttributeBooleanValue" }),
    EnaSupport: S.optional(AttributeBooleanValue)
      .pipe(T.XmlName("enaSupport"), T.Ec2QueryName("EnaSupport"))
      .annotate({ identifier: "AttributeBooleanValue" }),
    EnclaveOptions: S.optional(EnclaveOptions)
      .pipe(T.XmlName("enclaveOptions"), T.Ec2QueryName("EnclaveOptions"))
      .annotate({ identifier: "EnclaveOptions" }),
    EbsOptimized: S.optional(AttributeBooleanValue)
      .pipe(T.XmlName("ebsOptimized"), T.Ec2QueryName("EbsOptimized"))
      .annotate({ identifier: "AttributeBooleanValue" }),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    InstanceInitiatedShutdownBehavior: S.optional(AttributeValue)
      .pipe(
        T.XmlName("instanceInitiatedShutdownBehavior"),
        T.Ec2QueryName("InstanceInitiatedShutdownBehavior"),
      )
      .annotate({ identifier: "AttributeValue" }),
    InstanceType: S.optional(AttributeValue)
      .pipe(T.XmlName("instanceType"), T.Ec2QueryName("InstanceType"))
      .annotate({ identifier: "AttributeValue" }),
    KernelId: S.optional(AttributeValue)
      .pipe(T.XmlName("kernel"), T.Ec2QueryName("Kernel"))
      .annotate({ identifier: "AttributeValue" }),
    ProductCodes: S.optional(ProductCodeList).pipe(
      T.XmlName("productCodes"),
      T.Ec2QueryName("ProductCodes"),
    ),
    RamdiskId: S.optional(AttributeValue)
      .pipe(T.XmlName("ramdisk"), T.Ec2QueryName("Ramdisk"))
      .annotate({ identifier: "AttributeValue" }),
    RootDeviceName: S.optional(AttributeValue)
      .pipe(T.XmlName("rootDeviceName"), T.Ec2QueryName("RootDeviceName"))
      .annotate({ identifier: "AttributeValue" }),
    SourceDestCheck: S.optional(AttributeBooleanValue)
      .pipe(T.XmlName("sourceDestCheck"), T.Ec2QueryName("SourceDestCheck"))
      .annotate({ identifier: "AttributeBooleanValue" }),
    SriovNetSupport: S.optional(AttributeValue)
      .pipe(T.XmlName("sriovNetSupport"), T.Ec2QueryName("SriovNetSupport"))
      .annotate({ identifier: "AttributeValue" }),
    UserData: S.optional(AttributeValue)
      .pipe(T.XmlName("userData"), T.Ec2QueryName("UserData"))
      .annotate({ identifier: "AttributeValue" }),
    DisableApiStop: S.optional(AttributeBooleanValue)
      .pipe(T.XmlName("disableApiStop"), T.Ec2QueryName("DisableApiStop"))
      .annotate({ identifier: "AttributeBooleanValue" }),
    Groups: S.optional(GroupIdentifierList).pipe(
      T.XmlName("groupSet"),
      T.Ec2QueryName("GroupSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "InstanceAttribute",
}) as any as S.Schema<InstanceAttribute>;
export interface DescribeInstanceConnectEndpointsRequest {
  DryRun?: boolean;
  MaxResults?: number;
  NextToken?: string;
  Filters?: Filter[];
  InstanceConnectEndpointIds?: string[];
}
export const DescribeInstanceConnectEndpointsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    InstanceConnectEndpointIds: S.optional(ValueStringList).pipe(
      T.XmlName("InstanceConnectEndpointId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInstanceConnectEndpointsRequest",
}) as any as S.Schema<DescribeInstanceConnectEndpointsRequest>;
export type InstanceConnectEndpointSet = Ec2InstanceConnectEndpoint[];
export const InstanceConnectEndpointSet = S.Array(
  Ec2InstanceConnectEndpoint.pipe(T.XmlName("item")).annotate({
    identifier: "Ec2InstanceConnectEndpoint",
  }),
);
export interface DescribeInstanceConnectEndpointsResult {
  InstanceConnectEndpoints?: Ec2InstanceConnectEndpoint[];
  NextToken?: string;
}
export const DescribeInstanceConnectEndpointsResult = S.suspend(() =>
  S.Struct({
    InstanceConnectEndpoints: S.optional(InstanceConnectEndpointSet).pipe(
      T.XmlName("instanceConnectEndpointSet"),
      T.Ec2QueryName("InstanceConnectEndpointSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeInstanceConnectEndpointsResult",
}) as any as S.Schema<DescribeInstanceConnectEndpointsResult>;
export interface DescribeInstanceCreditSpecificationsRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  InstanceIds?: string[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeInstanceCreditSpecificationsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    InstanceIds: S.optional(InstanceIdStringList).pipe(T.XmlName("InstanceId")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInstanceCreditSpecificationsRequest",
}) as any as S.Schema<DescribeInstanceCreditSpecificationsRequest>;
export interface InstanceCreditSpecification {
  InstanceId?: string;
  CpuCredits?: string;
}
export const InstanceCreditSpecification = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    CpuCredits: S.optional(S.String).pipe(
      T.XmlName("cpuCredits"),
      T.Ec2QueryName("CpuCredits"),
    ),
  }),
).annotate({
  identifier: "InstanceCreditSpecification",
}) as any as S.Schema<InstanceCreditSpecification>;
export type InstanceCreditSpecificationList = InstanceCreditSpecification[];
export const InstanceCreditSpecificationList = S.Array(
  InstanceCreditSpecification.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceCreditSpecification",
  }),
);
export interface DescribeInstanceCreditSpecificationsResult {
  InstanceCreditSpecifications?: InstanceCreditSpecification[];
  NextToken?: string;
}
export const DescribeInstanceCreditSpecificationsResult = S.suspend(() =>
  S.Struct({
    InstanceCreditSpecifications: S.optional(
      InstanceCreditSpecificationList,
    ).pipe(
      T.XmlName("instanceCreditSpecificationSet"),
      T.Ec2QueryName("InstanceCreditSpecificationSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeInstanceCreditSpecificationsResult",
}) as any as S.Schema<DescribeInstanceCreditSpecificationsResult>;
export interface DescribeInstanceEventNotificationAttributesRequest {
  DryRun?: boolean;
}
export const DescribeInstanceEventNotificationAttributesRequest = S.suspend(
  () =>
    S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "DescribeInstanceEventNotificationAttributesRequest",
}) as any as S.Schema<DescribeInstanceEventNotificationAttributesRequest>;
export interface DescribeInstanceEventNotificationAttributesResult {
  InstanceTagAttribute?: InstanceTagNotificationAttribute;
}
export const DescribeInstanceEventNotificationAttributesResult = S.suspend(() =>
  S.Struct({
    InstanceTagAttribute: S.optional(InstanceTagNotificationAttribute)
      .pipe(
        T.XmlName("instanceTagAttribute"),
        T.Ec2QueryName("InstanceTagAttribute"),
      )
      .annotate({ identifier: "InstanceTagNotificationAttribute" }),
  }).pipe(ns),
).annotate({
  identifier: "DescribeInstanceEventNotificationAttributesResult",
}) as any as S.Schema<DescribeInstanceEventNotificationAttributesResult>;
export type InstanceEventWindowIdSet = string[];
export const InstanceEventWindowIdSet = S.Array(
  S.String.pipe(T.XmlName("InstanceEventWindowId")),
);
export interface DescribeInstanceEventWindowsRequest {
  DryRun?: boolean;
  InstanceEventWindowIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeInstanceEventWindowsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    InstanceEventWindowIds: S.optional(InstanceEventWindowIdSet).pipe(
      T.XmlName("InstanceEventWindowId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInstanceEventWindowsRequest",
}) as any as S.Schema<DescribeInstanceEventWindowsRequest>;
export type InstanceEventWindowSet = InstanceEventWindow[];
export const InstanceEventWindowSet = S.Array(
  InstanceEventWindow.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceEventWindow",
  }),
);
export interface DescribeInstanceEventWindowsResult {
  InstanceEventWindows?: InstanceEventWindow[];
  NextToken?: string;
}
export const DescribeInstanceEventWindowsResult = S.suspend(() =>
  S.Struct({
    InstanceEventWindows: S.optional(InstanceEventWindowSet).pipe(
      T.XmlName("instanceEventWindowSet"),
      T.Ec2QueryName("InstanceEventWindowSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeInstanceEventWindowsResult",
}) as any as S.Schema<DescribeInstanceEventWindowsResult>;
export interface DescribeInstanceImageMetadataRequest {
  Filters?: Filter[];
  InstanceIds?: string[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeInstanceImageMetadataRequest = S.suspend(() =>
  S.Struct({
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    InstanceIds: S.optional(InstanceIdStringList).pipe(T.XmlName("InstanceId")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInstanceImageMetadataRequest",
}) as any as S.Schema<DescribeInstanceImageMetadataRequest>;
export type InstanceStateName =
  | "pending"
  | "running"
  | "shutting-down"
  | "terminated"
  | "stopping"
  | "stopped"
  | (string & {});
export const InstanceStateName = S.String;
export interface InstanceState {
  Code?: number;
  Name?: InstanceStateName;
}
export const InstanceState = S.suspend(() =>
  S.Struct({
    Code: S.optional(S.Number).pipe(T.XmlName("code"), T.Ec2QueryName("Code")),
    Name: S.optional(InstanceStateName).pipe(
      T.XmlName("name"),
      T.Ec2QueryName("Name"),
    ),
  }),
).annotate({ identifier: "InstanceState" }) as any as S.Schema<InstanceState>;
export interface ImageMetadata {
  ImageId?: string;
  Name?: string;
  OwnerId?: string;
  State?: ImageState;
  ImageOwnerAlias?: string;
  CreationDate?: string;
  DeprecationTime?: string;
  ImageAllowed?: boolean;
  IsPublic?: boolean;
}
export const ImageMetadata = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("imageOwnerId"),
      T.Ec2QueryName("ImageOwnerId"),
    ),
    State: S.optional(ImageState).pipe(
      T.XmlName("imageState"),
      T.Ec2QueryName("ImageState"),
    ),
    ImageOwnerAlias: S.optional(S.String).pipe(
      T.XmlName("imageOwnerAlias"),
      T.Ec2QueryName("ImageOwnerAlias"),
    ),
    CreationDate: S.optional(S.String).pipe(
      T.XmlName("creationDate"),
      T.Ec2QueryName("CreationDate"),
    ),
    DeprecationTime: S.optional(S.String).pipe(
      T.XmlName("deprecationTime"),
      T.Ec2QueryName("DeprecationTime"),
    ),
    ImageAllowed: S.optional(S.Boolean).pipe(
      T.XmlName("imageAllowed"),
      T.Ec2QueryName("ImageAllowed"),
    ),
    IsPublic: S.optional(S.Boolean).pipe(
      T.XmlName("isPublic"),
      T.Ec2QueryName("IsPublic"),
    ),
  }),
).annotate({ identifier: "ImageMetadata" }) as any as S.Schema<ImageMetadata>;
export interface InstanceImageMetadata {
  InstanceId?: string;
  InstanceType?: InstanceType;
  LaunchTime?: Date;
  AvailabilityZone?: string;
  ZoneId?: string;
  State?: InstanceState;
  OwnerId?: string;
  Tags?: Tag[];
  ImageMetadata?: ImageMetadata;
  Operator?: OperatorResponse;
}
export const InstanceImageMetadata = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    InstanceType: S.optional(InstanceType).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    LaunchTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("launchTime"), T.Ec2QueryName("LaunchTime")),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    ZoneId: S.optional(S.String).pipe(
      T.XmlName("zoneId"),
      T.Ec2QueryName("ZoneId"),
    ),
    State: S.optional(InstanceState)
      .pipe(T.XmlName("instanceState"), T.Ec2QueryName("InstanceState"))
      .annotate({ identifier: "InstanceState" }),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("instanceOwnerId"),
      T.Ec2QueryName("InstanceOwnerId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    ImageMetadata: S.optional(ImageMetadata)
      .pipe(T.XmlName("imageMetadata"), T.Ec2QueryName("ImageMetadata"))
      .annotate({ identifier: "ImageMetadata" }),
    Operator: S.optional(OperatorResponse)
      .pipe(T.XmlName("operator"), T.Ec2QueryName("Operator"))
      .annotate({ identifier: "OperatorResponse" }),
  }),
).annotate({
  identifier: "InstanceImageMetadata",
}) as any as S.Schema<InstanceImageMetadata>;
export type InstanceImageMetadataList = InstanceImageMetadata[];
export const InstanceImageMetadataList = S.Array(
  InstanceImageMetadata.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceImageMetadata",
  }),
);
export interface DescribeInstanceImageMetadataResult {
  InstanceImageMetadata?: InstanceImageMetadata[];
  NextToken?: string;
}
export const DescribeInstanceImageMetadataResult = S.suspend(() =>
  S.Struct({
    InstanceImageMetadata: S.optional(InstanceImageMetadataList).pipe(
      T.XmlName("instanceImageMetadataSet"),
      T.Ec2QueryName("InstanceImageMetadataSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeInstanceImageMetadataResult",
}) as any as S.Schema<DescribeInstanceImageMetadataResult>;
export interface DescribeInstancesRequest {
  InstanceIds?: string[];
  DryRun?: boolean;
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeInstancesRequest = S.suspend(() =>
  S.Struct({
    InstanceIds: S.optional(InstanceIdStringList).pipe(T.XmlName("InstanceId")),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    MaxResults: S.optional(S.Number).pipe(
      T.XmlName("maxResults"),
      T.Ec2QueryName("MaxResults"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInstancesRequest",
}) as any as S.Schema<DescribeInstancesRequest>;
export type InstanceLifecycleType =
  | "spot"
  | "scheduled"
  | "capacity-block"
  | "interruptible-capacity-reservation"
  | (string & {});
export const InstanceLifecycleType = S.String;
export interface ElasticGpuAssociation {
  ElasticGpuId?: string;
  ElasticGpuAssociationId?: string;
  ElasticGpuAssociationState?: string;
  ElasticGpuAssociationTime?: string;
}
export const ElasticGpuAssociation = S.suspend(() =>
  S.Struct({
    ElasticGpuId: S.optional(S.String).pipe(
      T.XmlName("elasticGpuId"),
      T.Ec2QueryName("ElasticGpuId"),
    ),
    ElasticGpuAssociationId: S.optional(S.String).pipe(
      T.XmlName("elasticGpuAssociationId"),
      T.Ec2QueryName("ElasticGpuAssociationId"),
    ),
    ElasticGpuAssociationState: S.optional(S.String).pipe(
      T.XmlName("elasticGpuAssociationState"),
      T.Ec2QueryName("ElasticGpuAssociationState"),
    ),
    ElasticGpuAssociationTime: S.optional(S.String).pipe(
      T.XmlName("elasticGpuAssociationTime"),
      T.Ec2QueryName("ElasticGpuAssociationTime"),
    ),
  }),
).annotate({
  identifier: "ElasticGpuAssociation",
}) as any as S.Schema<ElasticGpuAssociation>;
export type ElasticGpuAssociationList = ElasticGpuAssociation[];
export const ElasticGpuAssociationList = S.Array(
  ElasticGpuAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "ElasticGpuAssociation",
  }),
);
export interface ElasticInferenceAcceleratorAssociation {
  ElasticInferenceAcceleratorArn?: string;
  ElasticInferenceAcceleratorAssociationId?: string;
  ElasticInferenceAcceleratorAssociationState?: string;
  ElasticInferenceAcceleratorAssociationTime?: Date;
}
export const ElasticInferenceAcceleratorAssociation = S.suspend(() =>
  S.Struct({
    ElasticInferenceAcceleratorArn: S.optional(S.String).pipe(
      T.XmlName("elasticInferenceAcceleratorArn"),
      T.Ec2QueryName("ElasticInferenceAcceleratorArn"),
    ),
    ElasticInferenceAcceleratorAssociationId: S.optional(S.String).pipe(
      T.XmlName("elasticInferenceAcceleratorAssociationId"),
      T.Ec2QueryName("ElasticInferenceAcceleratorAssociationId"),
    ),
    ElasticInferenceAcceleratorAssociationState: S.optional(S.String).pipe(
      T.XmlName("elasticInferenceAcceleratorAssociationState"),
      T.Ec2QueryName("ElasticInferenceAcceleratorAssociationState"),
    ),
    ElasticInferenceAcceleratorAssociationTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("elasticInferenceAcceleratorAssociationTime"),
      T.Ec2QueryName("ElasticInferenceAcceleratorAssociationTime"),
    ),
  }),
).annotate({
  identifier: "ElasticInferenceAcceleratorAssociation",
}) as any as S.Schema<ElasticInferenceAcceleratorAssociation>;
export type ElasticInferenceAcceleratorAssociationList =
  ElasticInferenceAcceleratorAssociation[];
export const ElasticInferenceAcceleratorAssociationList = S.Array(
  ElasticInferenceAcceleratorAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "ElasticInferenceAcceleratorAssociation",
  }),
);
export interface InstanceNetworkInterfaceAssociation {
  CarrierIp?: string;
  CustomerOwnedIp?: string;
  IpOwnerId?: string;
  PublicDnsName?: string;
  PublicIp?: string;
}
export const InstanceNetworkInterfaceAssociation = S.suspend(() =>
  S.Struct({
    CarrierIp: S.optional(S.String).pipe(
      T.XmlName("carrierIp"),
      T.Ec2QueryName("CarrierIp"),
    ),
    CustomerOwnedIp: S.optional(S.String).pipe(
      T.XmlName("customerOwnedIp"),
      T.Ec2QueryName("CustomerOwnedIp"),
    ),
    IpOwnerId: S.optional(S.String).pipe(
      T.XmlName("ipOwnerId"),
      T.Ec2QueryName("IpOwnerId"),
    ),
    PublicDnsName: S.optional(S.String).pipe(
      T.XmlName("publicDnsName"),
      T.Ec2QueryName("PublicDnsName"),
    ),
    PublicIp: S.optional(S.String).pipe(
      T.XmlName("publicIp"),
      T.Ec2QueryName("PublicIp"),
    ),
  }),
).annotate({
  identifier: "InstanceNetworkInterfaceAssociation",
}) as any as S.Schema<InstanceNetworkInterfaceAssociation>;
export interface InstanceAttachmentEnaSrdUdpSpecification {
  EnaSrdUdpEnabled?: boolean;
}
export const InstanceAttachmentEnaSrdUdpSpecification = S.suspend(() =>
  S.Struct({
    EnaSrdUdpEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("enaSrdUdpEnabled"),
      T.Ec2QueryName("EnaSrdUdpEnabled"),
    ),
  }),
).annotate({
  identifier: "InstanceAttachmentEnaSrdUdpSpecification",
}) as any as S.Schema<InstanceAttachmentEnaSrdUdpSpecification>;
export interface InstanceAttachmentEnaSrdSpecification {
  EnaSrdEnabled?: boolean;
  EnaSrdUdpSpecification?: InstanceAttachmentEnaSrdUdpSpecification;
}
export const InstanceAttachmentEnaSrdSpecification = S.suspend(() =>
  S.Struct({
    EnaSrdEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("enaSrdEnabled"),
      T.Ec2QueryName("EnaSrdEnabled"),
    ),
    EnaSrdUdpSpecification: S.optional(InstanceAttachmentEnaSrdUdpSpecification)
      .pipe(
        T.XmlName("enaSrdUdpSpecification"),
        T.Ec2QueryName("EnaSrdUdpSpecification"),
      )
      .annotate({ identifier: "InstanceAttachmentEnaSrdUdpSpecification" }),
  }),
).annotate({
  identifier: "InstanceAttachmentEnaSrdSpecification",
}) as any as S.Schema<InstanceAttachmentEnaSrdSpecification>;
export interface InstanceNetworkInterfaceAttachment {
  AttachTime?: Date;
  AttachmentId?: string;
  DeleteOnTermination?: boolean;
  DeviceIndex?: number;
  Status?: AttachmentStatus;
  NetworkCardIndex?: number;
  EnaSrdSpecification?: InstanceAttachmentEnaSrdSpecification;
  EnaQueueCount?: number;
}
export const InstanceNetworkInterfaceAttachment = S.suspend(() =>
  S.Struct({
    AttachTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("attachTime"), T.Ec2QueryName("AttachTime")),
    AttachmentId: S.optional(S.String).pipe(
      T.XmlName("attachmentId"),
      T.Ec2QueryName("AttachmentId"),
    ),
    DeleteOnTermination: S.optional(S.Boolean).pipe(
      T.XmlName("deleteOnTermination"),
      T.Ec2QueryName("DeleteOnTermination"),
    ),
    DeviceIndex: S.optional(S.Number).pipe(
      T.XmlName("deviceIndex"),
      T.Ec2QueryName("DeviceIndex"),
    ),
    Status: S.optional(AttachmentStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    NetworkCardIndex: S.optional(S.Number).pipe(
      T.XmlName("networkCardIndex"),
      T.Ec2QueryName("NetworkCardIndex"),
    ),
    EnaSrdSpecification: S.optional(InstanceAttachmentEnaSrdSpecification)
      .pipe(
        T.XmlName("enaSrdSpecification"),
        T.Ec2QueryName("EnaSrdSpecification"),
      )
      .annotate({ identifier: "InstanceAttachmentEnaSrdSpecification" }),
    EnaQueueCount: S.optional(S.Number).pipe(
      T.XmlName("enaQueueCount"),
      T.Ec2QueryName("EnaQueueCount"),
    ),
  }),
).annotate({
  identifier: "InstanceNetworkInterfaceAttachment",
}) as any as S.Schema<InstanceNetworkInterfaceAttachment>;
export interface InstancePrivateIpAddress {
  Association?: InstanceNetworkInterfaceAssociation;
  Primary?: boolean;
  PrivateDnsName?: string;
  PrivateIpAddress?: string;
}
export const InstancePrivateIpAddress = S.suspend(() =>
  S.Struct({
    Association: S.optional(InstanceNetworkInterfaceAssociation)
      .pipe(T.XmlName("association"), T.Ec2QueryName("Association"))
      .annotate({ identifier: "InstanceNetworkInterfaceAssociation" }),
    Primary: S.optional(S.Boolean).pipe(
      T.XmlName("primary"),
      T.Ec2QueryName("Primary"),
    ),
    PrivateDnsName: S.optional(S.String).pipe(
      T.XmlName("privateDnsName"),
      T.Ec2QueryName("PrivateDnsName"),
    ),
    PrivateIpAddress: S.optional(S.String).pipe(
      T.XmlName("privateIpAddress"),
      T.Ec2QueryName("PrivateIpAddress"),
    ),
  }),
).annotate({
  identifier: "InstancePrivateIpAddress",
}) as any as S.Schema<InstancePrivateIpAddress>;
export type InstancePrivateIpAddressList = InstancePrivateIpAddress[];
export const InstancePrivateIpAddressList = S.Array(
  InstancePrivateIpAddress.pipe(T.XmlName("item")).annotate({
    identifier: "InstancePrivateIpAddress",
  }),
);
export interface InstanceIpv4Prefix {
  Ipv4Prefix?: string;
}
export const InstanceIpv4Prefix = S.suspend(() =>
  S.Struct({
    Ipv4Prefix: S.optional(S.String).pipe(
      T.XmlName("ipv4Prefix"),
      T.Ec2QueryName("Ipv4Prefix"),
    ),
  }),
).annotate({
  identifier: "InstanceIpv4Prefix",
}) as any as S.Schema<InstanceIpv4Prefix>;
export type InstanceIpv4PrefixList = InstanceIpv4Prefix[];
export const InstanceIpv4PrefixList = S.Array(
  InstanceIpv4Prefix.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceIpv4Prefix",
  }),
);
export interface InstanceIpv6Prefix {
  Ipv6Prefix?: string;
}
export const InstanceIpv6Prefix = S.suspend(() =>
  S.Struct({
    Ipv6Prefix: S.optional(S.String).pipe(
      T.XmlName("ipv6Prefix"),
      T.Ec2QueryName("Ipv6Prefix"),
    ),
  }),
).annotate({
  identifier: "InstanceIpv6Prefix",
}) as any as S.Schema<InstanceIpv6Prefix>;
export type InstanceIpv6PrefixList = InstanceIpv6Prefix[];
export const InstanceIpv6PrefixList = S.Array(
  InstanceIpv6Prefix.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceIpv6Prefix",
  }),
);
export interface ConnectionTrackingSpecificationResponse {
  TcpEstablishedTimeout?: number;
  UdpStreamTimeout?: number;
  UdpTimeout?: number;
}
export const ConnectionTrackingSpecificationResponse = S.suspend(() =>
  S.Struct({
    TcpEstablishedTimeout: S.optional(S.Number).pipe(
      T.XmlName("tcpEstablishedTimeout"),
      T.Ec2QueryName("TcpEstablishedTimeout"),
    ),
    UdpStreamTimeout: S.optional(S.Number).pipe(
      T.XmlName("udpStreamTimeout"),
      T.Ec2QueryName("UdpStreamTimeout"),
    ),
    UdpTimeout: S.optional(S.Number).pipe(
      T.XmlName("udpTimeout"),
      T.Ec2QueryName("UdpTimeout"),
    ),
  }),
).annotate({
  identifier: "ConnectionTrackingSpecificationResponse",
}) as any as S.Schema<ConnectionTrackingSpecificationResponse>;
export interface InstanceNetworkInterface {
  Association?: InstanceNetworkInterfaceAssociation;
  Attachment?: InstanceNetworkInterfaceAttachment;
  Description?: string;
  Groups?: GroupIdentifier[];
  Ipv6Addresses?: InstanceIpv6Address[];
  MacAddress?: string;
  NetworkInterfaceId?: string;
  OwnerId?: string;
  PrivateDnsName?: string;
  PrivateIpAddress?: string;
  PrivateIpAddresses?: InstancePrivateIpAddress[];
  SourceDestCheck?: boolean;
  Status?: NetworkInterfaceStatus;
  SubnetId?: string;
  VpcId?: string;
  InterfaceType?: string;
  Ipv4Prefixes?: InstanceIpv4Prefix[];
  Ipv6Prefixes?: InstanceIpv6Prefix[];
  ConnectionTrackingConfiguration?: ConnectionTrackingSpecificationResponse;
  Operator?: OperatorResponse;
}
export const InstanceNetworkInterface = S.suspend(() =>
  S.Struct({
    Association: S.optional(InstanceNetworkInterfaceAssociation)
      .pipe(T.XmlName("association"), T.Ec2QueryName("Association"))
      .annotate({ identifier: "InstanceNetworkInterfaceAssociation" }),
    Attachment: S.optional(InstanceNetworkInterfaceAttachment)
      .pipe(T.XmlName("attachment"), T.Ec2QueryName("Attachment"))
      .annotate({ identifier: "InstanceNetworkInterfaceAttachment" }),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    Groups: S.optional(GroupIdentifierList).pipe(
      T.XmlName("groupSet"),
      T.Ec2QueryName("GroupSet"),
    ),
    Ipv6Addresses: S.optional(InstanceIpv6AddressList).pipe(
      T.XmlName("ipv6AddressesSet"),
      T.Ec2QueryName("Ipv6AddressesSet"),
    ),
    MacAddress: S.optional(S.String).pipe(
      T.XmlName("macAddress"),
      T.Ec2QueryName("MacAddress"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    PrivateDnsName: S.optional(S.String).pipe(
      T.XmlName("privateDnsName"),
      T.Ec2QueryName("PrivateDnsName"),
    ),
    PrivateIpAddress: S.optional(S.String).pipe(
      T.XmlName("privateIpAddress"),
      T.Ec2QueryName("PrivateIpAddress"),
    ),
    PrivateIpAddresses: S.optional(InstancePrivateIpAddressList).pipe(
      T.XmlName("privateIpAddressesSet"),
      T.Ec2QueryName("PrivateIpAddressesSet"),
    ),
    SourceDestCheck: S.optional(S.Boolean).pipe(
      T.XmlName("sourceDestCheck"),
      T.Ec2QueryName("SourceDestCheck"),
    ),
    Status: S.optional(NetworkInterfaceStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    InterfaceType: S.optional(S.String).pipe(
      T.XmlName("interfaceType"),
      T.Ec2QueryName("InterfaceType"),
    ),
    Ipv4Prefixes: S.optional(InstanceIpv4PrefixList).pipe(
      T.XmlName("ipv4PrefixSet"),
      T.Ec2QueryName("Ipv4PrefixSet"),
    ),
    Ipv6Prefixes: S.optional(InstanceIpv6PrefixList).pipe(
      T.XmlName("ipv6PrefixSet"),
      T.Ec2QueryName("Ipv6PrefixSet"),
    ),
    ConnectionTrackingConfiguration: S.optional(
      ConnectionTrackingSpecificationResponse,
    )
      .pipe(
        T.XmlName("connectionTrackingConfiguration"),
        T.Ec2QueryName("ConnectionTrackingConfiguration"),
      )
      .annotate({ identifier: "ConnectionTrackingSpecificationResponse" }),
    Operator: S.optional(OperatorResponse)
      .pipe(T.XmlName("operator"), T.Ec2QueryName("Operator"))
      .annotate({ identifier: "OperatorResponse" }),
  }),
).annotate({
  identifier: "InstanceNetworkInterface",
}) as any as S.Schema<InstanceNetworkInterface>;
export type InstanceNetworkInterfaceList = InstanceNetworkInterface[];
export const InstanceNetworkInterfaceList = S.Array(
  InstanceNetworkInterface.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceNetworkInterface",
  }),
);
export interface CpuOptions {
  CoreCount?: number;
  ThreadsPerCore?: number;
  AmdSevSnp?: AmdSevSnpSpecification;
  NestedVirtualization?: NestedVirtualizationSpecification;
}
export const CpuOptions = S.suspend(() =>
  S.Struct({
    CoreCount: S.optional(S.Number).pipe(
      T.XmlName("coreCount"),
      T.Ec2QueryName("CoreCount"),
    ),
    ThreadsPerCore: S.optional(S.Number).pipe(
      T.XmlName("threadsPerCore"),
      T.Ec2QueryName("ThreadsPerCore"),
    ),
    AmdSevSnp: S.optional(AmdSevSnpSpecification).pipe(
      T.XmlName("amdSevSnp"),
      T.Ec2QueryName("AmdSevSnp"),
    ),
    NestedVirtualization: S.optional(NestedVirtualizationSpecification).pipe(
      T.XmlName("nestedVirtualization"),
      T.Ec2QueryName("NestedVirtualization"),
    ),
  }),
).annotate({ identifier: "CpuOptions" }) as any as S.Schema<CpuOptions>;
export interface CapacityReservationSpecificationResponse {
  CapacityReservationPreference?: CapacityReservationPreference;
  CapacityReservationTarget?: CapacityReservationTargetResponse;
}
export const CapacityReservationSpecificationResponse = S.suspend(() =>
  S.Struct({
    CapacityReservationPreference: S.optional(
      CapacityReservationPreference,
    ).pipe(
      T.XmlName("capacityReservationPreference"),
      T.Ec2QueryName("CapacityReservationPreference"),
    ),
    CapacityReservationTarget: S.optional(CapacityReservationTargetResponse)
      .pipe(
        T.XmlName("capacityReservationTarget"),
        T.Ec2QueryName("CapacityReservationTarget"),
      )
      .annotate({ identifier: "CapacityReservationTargetResponse" }),
  }),
).annotate({
  identifier: "CapacityReservationSpecificationResponse",
}) as any as S.Schema<CapacityReservationSpecificationResponse>;
export interface HibernationOptions {
  Configured?: boolean;
}
export const HibernationOptions = S.suspend(() =>
  S.Struct({
    Configured: S.optional(S.Boolean).pipe(
      T.XmlName("configured"),
      T.Ec2QueryName("Configured"),
    ),
  }),
).annotate({
  identifier: "HibernationOptions",
}) as any as S.Schema<HibernationOptions>;
export interface LicenseConfiguration {
  LicenseConfigurationArn?: string;
}
export const LicenseConfiguration = S.suspend(() =>
  S.Struct({
    LicenseConfigurationArn: S.optional(S.String).pipe(
      T.XmlName("licenseConfigurationArn"),
      T.Ec2QueryName("LicenseConfigurationArn"),
    ),
  }),
).annotate({
  identifier: "LicenseConfiguration",
}) as any as S.Schema<LicenseConfiguration>;
export type LicenseList = LicenseConfiguration[];
export const LicenseList = S.Array(
  LicenseConfiguration.pipe(T.XmlName("item")).annotate({
    identifier: "LicenseConfiguration",
  }),
);
export type InstanceMetadataOptionsState =
  | "pending"
  | "applied"
  | (string & {});
export const InstanceMetadataOptionsState = S.String;
export type HttpTokensState = "optional" | "required" | (string & {});
export const HttpTokensState = S.String;
export type InstanceMetadataEndpointState =
  | "disabled"
  | "enabled"
  | (string & {});
export const InstanceMetadataEndpointState = S.String;
export type InstanceMetadataProtocolState =
  | "disabled"
  | "enabled"
  | (string & {});
export const InstanceMetadataProtocolState = S.String;
export type InstanceMetadataTagsState = "disabled" | "enabled" | (string & {});
export const InstanceMetadataTagsState = S.String;
export interface InstanceMetadataOptionsResponse {
  State?: InstanceMetadataOptionsState;
  HttpTokens?: HttpTokensState;
  HttpPutResponseHopLimit?: number;
  HttpEndpoint?: InstanceMetadataEndpointState;
  HttpProtocolIpv6?: InstanceMetadataProtocolState;
  InstanceMetadataTags?: InstanceMetadataTagsState;
}
export const InstanceMetadataOptionsResponse = S.suspend(() =>
  S.Struct({
    State: S.optional(InstanceMetadataOptionsState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    HttpTokens: S.optional(HttpTokensState).pipe(
      T.XmlName("httpTokens"),
      T.Ec2QueryName("HttpTokens"),
    ),
    HttpPutResponseHopLimit: S.optional(S.Number).pipe(
      T.XmlName("httpPutResponseHopLimit"),
      T.Ec2QueryName("HttpPutResponseHopLimit"),
    ),
    HttpEndpoint: S.optional(InstanceMetadataEndpointState).pipe(
      T.XmlName("httpEndpoint"),
      T.Ec2QueryName("HttpEndpoint"),
    ),
    HttpProtocolIpv6: S.optional(InstanceMetadataProtocolState).pipe(
      T.XmlName("httpProtocolIpv6"),
      T.Ec2QueryName("HttpProtocolIpv6"),
    ),
    InstanceMetadataTags: S.optional(InstanceMetadataTagsState).pipe(
      T.XmlName("instanceMetadataTags"),
      T.Ec2QueryName("InstanceMetadataTags"),
    ),
  }),
).annotate({
  identifier: "InstanceMetadataOptionsResponse",
}) as any as S.Schema<InstanceMetadataOptionsResponse>;
export interface PrivateDnsNameOptionsResponse {
  HostnameType?: HostnameType;
  EnableResourceNameDnsARecord?: boolean;
  EnableResourceNameDnsAAAARecord?: boolean;
}
export const PrivateDnsNameOptionsResponse = S.suspend(() =>
  S.Struct({
    HostnameType: S.optional(HostnameType).pipe(
      T.XmlName("hostnameType"),
      T.Ec2QueryName("HostnameType"),
    ),
    EnableResourceNameDnsARecord: S.optional(S.Boolean).pipe(
      T.XmlName("enableResourceNameDnsARecord"),
      T.Ec2QueryName("EnableResourceNameDnsARecord"),
    ),
    EnableResourceNameDnsAAAARecord: S.optional(S.Boolean).pipe(
      T.XmlName("enableResourceNameDnsAAAARecord"),
      T.Ec2QueryName("EnableResourceNameDnsAAAARecord"),
    ),
  }),
).annotate({
  identifier: "PrivateDnsNameOptionsResponse",
}) as any as S.Schema<PrivateDnsNameOptionsResponse>;
export type InstanceAutoRecoveryState = "disabled" | "default" | (string & {});
export const InstanceAutoRecoveryState = S.String;
export type InstanceRebootMigrationState =
  | "disabled"
  | "default"
  | (string & {});
export const InstanceRebootMigrationState = S.String;
export interface InstanceMaintenanceOptions {
  AutoRecovery?: InstanceAutoRecoveryState;
  RebootMigration?: InstanceRebootMigrationState;
}
export const InstanceMaintenanceOptions = S.suspend(() =>
  S.Struct({
    AutoRecovery: S.optional(InstanceAutoRecoveryState).pipe(
      T.XmlName("autoRecovery"),
      T.Ec2QueryName("AutoRecovery"),
    ),
    RebootMigration: S.optional(InstanceRebootMigrationState).pipe(
      T.XmlName("rebootMigration"),
      T.Ec2QueryName("RebootMigration"),
    ),
  }),
).annotate({
  identifier: "InstanceMaintenanceOptions",
}) as any as S.Schema<InstanceMaintenanceOptions>;
export type InstanceBootModeValues = "legacy-bios" | "uefi" | (string & {});
export const InstanceBootModeValues = S.String;
export interface InstanceNetworkPerformanceOptions {
  BandwidthWeighting?: InstanceBandwidthWeighting;
}
export const InstanceNetworkPerformanceOptions = S.suspend(() =>
  S.Struct({
    BandwidthWeighting: S.optional(InstanceBandwidthWeighting).pipe(
      T.XmlName("bandwidthWeighting"),
      T.Ec2QueryName("BandwidthWeighting"),
    ),
  }),
).annotate({
  identifier: "InstanceNetworkPerformanceOptions",
}) as any as S.Schema<InstanceNetworkPerformanceOptions>;
export interface InstanceSecondaryInterfaceAttachment {
  AttachTime?: Date;
  AttachmentId?: string;
  DeleteOnTermination?: boolean;
  DeviceIndex?: number;
  Status?: AttachmentStatus;
  NetworkCardIndex?: number;
}
export const InstanceSecondaryInterfaceAttachment = S.suspend(() =>
  S.Struct({
    AttachTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("attachTime"), T.Ec2QueryName("AttachTime")),
    AttachmentId: S.optional(S.String).pipe(
      T.XmlName("attachmentId"),
      T.Ec2QueryName("AttachmentId"),
    ),
    DeleteOnTermination: S.optional(S.Boolean).pipe(
      T.XmlName("deleteOnTermination"),
      T.Ec2QueryName("DeleteOnTermination"),
    ),
    DeviceIndex: S.optional(S.Number).pipe(
      T.XmlName("deviceIndex"),
      T.Ec2QueryName("DeviceIndex"),
    ),
    Status: S.optional(AttachmentStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    NetworkCardIndex: S.optional(S.Number).pipe(
      T.XmlName("networkCardIndex"),
      T.Ec2QueryName("NetworkCardIndex"),
    ),
  }),
).annotate({
  identifier: "InstanceSecondaryInterfaceAttachment",
}) as any as S.Schema<InstanceSecondaryInterfaceAttachment>;
export interface InstanceSecondaryInterfacePrivateIpAddress {
  PrivateIpAddress?: string;
}
export const InstanceSecondaryInterfacePrivateIpAddress = S.suspend(() =>
  S.Struct({
    PrivateIpAddress: S.optional(S.String).pipe(
      T.XmlName("privateIpAddress"),
      T.Ec2QueryName("PrivateIpAddress"),
    ),
  }),
).annotate({
  identifier: "InstanceSecondaryInterfacePrivateIpAddress",
}) as any as S.Schema<InstanceSecondaryInterfacePrivateIpAddress>;
export type InstanceSecondaryInterfacePrivateIpAddressList =
  InstanceSecondaryInterfacePrivateIpAddress[];
export const InstanceSecondaryInterfacePrivateIpAddressList = S.Array(
  InstanceSecondaryInterfacePrivateIpAddress.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceSecondaryInterfacePrivateIpAddress",
  }),
);
export type SecondaryInterfaceStatus = "available" | "in-use" | (string & {});
export const SecondaryInterfaceStatus = S.String;
export interface InstanceSecondaryInterface {
  Attachment?: InstanceSecondaryInterfaceAttachment;
  MacAddress?: string;
  SecondaryInterfaceId?: string;
  OwnerId?: string;
  PrivateIpAddresses?: InstanceSecondaryInterfacePrivateIpAddress[];
  SourceDestCheck?: boolean;
  Status?: SecondaryInterfaceStatus;
  SecondarySubnetId?: string;
  SecondaryNetworkId?: string;
  InterfaceType?: SecondaryInterfaceType;
}
export const InstanceSecondaryInterface = S.suspend(() =>
  S.Struct({
    Attachment: S.optional(InstanceSecondaryInterfaceAttachment)
      .pipe(T.XmlName("attachment"), T.Ec2QueryName("Attachment"))
      .annotate({ identifier: "InstanceSecondaryInterfaceAttachment" }),
    MacAddress: S.optional(S.String).pipe(
      T.XmlName("macAddress"),
      T.Ec2QueryName("MacAddress"),
    ),
    SecondaryInterfaceId: S.optional(S.String).pipe(
      T.XmlName("secondaryInterfaceId"),
      T.Ec2QueryName("SecondaryInterfaceId"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    PrivateIpAddresses: S.optional(
      InstanceSecondaryInterfacePrivateIpAddressList,
    ).pipe(
      T.XmlName("privateIpAddressSet"),
      T.Ec2QueryName("PrivateIpAddressSet"),
    ),
    SourceDestCheck: S.optional(S.Boolean).pipe(
      T.XmlName("sourceDestCheck"),
      T.Ec2QueryName("SourceDestCheck"),
    ),
    Status: S.optional(SecondaryInterfaceStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    SecondarySubnetId: S.optional(S.String).pipe(
      T.XmlName("secondarySubnetId"),
      T.Ec2QueryName("SecondarySubnetId"),
    ),
    SecondaryNetworkId: S.optional(S.String).pipe(
      T.XmlName("secondaryNetworkId"),
      T.Ec2QueryName("SecondaryNetworkId"),
    ),
    InterfaceType: S.optional(SecondaryInterfaceType).pipe(
      T.XmlName("interfaceType"),
      T.Ec2QueryName("InterfaceType"),
    ),
  }),
).annotate({
  identifier: "InstanceSecondaryInterface",
}) as any as S.Schema<InstanceSecondaryInterface>;
export type InstanceSecondaryInterfaceList = InstanceSecondaryInterface[];
export const InstanceSecondaryInterfaceList = S.Array(
  InstanceSecondaryInterface.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceSecondaryInterface",
  }),
);
export type MonitoringState =
  | "disabled"
  | "disabling"
  | "enabled"
  | "pending"
  | (string & {});
export const MonitoringState = S.String;
export interface Monitoring {
  State?: MonitoringState;
}
export const Monitoring = S.suspend(() =>
  S.Struct({
    State: S.optional(MonitoringState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({ identifier: "Monitoring" }) as any as S.Schema<Monitoring>;
export interface Instance {
  Architecture?: ArchitectureValues;
  BlockDeviceMappings?: InstanceBlockDeviceMapping[];
  ClientToken?: string;
  EbsOptimized?: boolean;
  EnaSupport?: boolean;
  Hypervisor?: HypervisorType;
  IamInstanceProfile?: IamInstanceProfile;
  InstanceLifecycle?: InstanceLifecycleType;
  ElasticGpuAssociations?: ElasticGpuAssociation[];
  ElasticInferenceAcceleratorAssociations?: ElasticInferenceAcceleratorAssociation[];
  NetworkInterfaces?: InstanceNetworkInterface[];
  OutpostArn?: string;
  RootDeviceName?: string;
  RootDeviceType?: DeviceType;
  SecurityGroups?: GroupIdentifier[];
  SourceDestCheck?: boolean;
  SpotInstanceRequestId?: string;
  SriovNetSupport?: string;
  StateReason?: StateReason;
  Tags?: Tag[];
  VirtualizationType?: VirtualizationType;
  CpuOptions?: CpuOptions;
  CapacityBlockId?: string;
  CapacityReservationId?: string;
  CapacityReservationSpecification?: CapacityReservationSpecificationResponse;
  HibernationOptions?: HibernationOptions;
  Licenses?: LicenseConfiguration[];
  MetadataOptions?: InstanceMetadataOptionsResponse;
  EnclaveOptions?: EnclaveOptions;
  BootMode?: BootModeValues;
  PlatformDetails?: string;
  UsageOperation?: string;
  UsageOperationUpdateTime?: Date;
  PrivateDnsNameOptions?: PrivateDnsNameOptionsResponse;
  Ipv6Address?: string;
  TpmSupport?: string;
  MaintenanceOptions?: InstanceMaintenanceOptions;
  CurrentInstanceBootMode?: InstanceBootModeValues;
  NetworkPerformanceOptions?: InstanceNetworkPerformanceOptions;
  Operator?: OperatorResponse;
  SecondaryInterfaces?: InstanceSecondaryInterface[];
  InstanceId?: string;
  ImageId?: string;
  State?: InstanceState;
  PrivateDnsName?: string;
  PublicDnsName?: string;
  StateTransitionReason?: string;
  KeyName?: string;
  AmiLaunchIndex?: number;
  ProductCodes?: ProductCode[];
  InstanceType?: InstanceType;
  LaunchTime?: Date;
  Placement?: Placement;
  KernelId?: string;
  RamdiskId?: string;
  Platform?: PlatformValues;
  Monitoring?: Monitoring;
  SubnetId?: string;
  VpcId?: string;
  PrivateIpAddress?: string;
  PublicIpAddress?: string;
}
export const Instance = S.suspend(() =>
  S.Struct({
    Architecture: S.optional(ArchitectureValues).pipe(
      T.XmlName("architecture"),
      T.Ec2QueryName("Architecture"),
    ),
    BlockDeviceMappings: S.optional(InstanceBlockDeviceMappingList).pipe(
      T.XmlName("blockDeviceMapping"),
      T.Ec2QueryName("BlockDeviceMapping"),
    ),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
    EbsOptimized: S.optional(S.Boolean).pipe(
      T.XmlName("ebsOptimized"),
      T.Ec2QueryName("EbsOptimized"),
    ),
    EnaSupport: S.optional(S.Boolean).pipe(
      T.XmlName("enaSupport"),
      T.Ec2QueryName("EnaSupport"),
    ),
    Hypervisor: S.optional(HypervisorType).pipe(
      T.XmlName("hypervisor"),
      T.Ec2QueryName("Hypervisor"),
    ),
    IamInstanceProfile: S.optional(IamInstanceProfile)
      .pipe(
        T.XmlName("iamInstanceProfile"),
        T.Ec2QueryName("IamInstanceProfile"),
      )
      .annotate({ identifier: "IamInstanceProfile" }),
    InstanceLifecycle: S.optional(InstanceLifecycleType).pipe(
      T.XmlName("instanceLifecycle"),
      T.Ec2QueryName("InstanceLifecycle"),
    ),
    ElasticGpuAssociations: S.optional(ElasticGpuAssociationList).pipe(
      T.XmlName("elasticGpuAssociationSet"),
      T.Ec2QueryName("ElasticGpuAssociationSet"),
    ),
    ElasticInferenceAcceleratorAssociations: S.optional(
      ElasticInferenceAcceleratorAssociationList,
    ).pipe(
      T.XmlName("elasticInferenceAcceleratorAssociationSet"),
      T.Ec2QueryName("ElasticInferenceAcceleratorAssociationSet"),
    ),
    NetworkInterfaces: S.optional(InstanceNetworkInterfaceList).pipe(
      T.XmlName("networkInterfaceSet"),
      T.Ec2QueryName("NetworkInterfaceSet"),
    ),
    OutpostArn: S.optional(S.String).pipe(
      T.XmlName("outpostArn"),
      T.Ec2QueryName("OutpostArn"),
    ),
    RootDeviceName: S.optional(S.String).pipe(
      T.XmlName("rootDeviceName"),
      T.Ec2QueryName("RootDeviceName"),
    ),
    RootDeviceType: S.optional(DeviceType).pipe(
      T.XmlName("rootDeviceType"),
      T.Ec2QueryName("RootDeviceType"),
    ),
    SecurityGroups: S.optional(GroupIdentifierList).pipe(
      T.XmlName("groupSet"),
      T.Ec2QueryName("GroupSet"),
    ),
    SourceDestCheck: S.optional(S.Boolean).pipe(
      T.XmlName("sourceDestCheck"),
      T.Ec2QueryName("SourceDestCheck"),
    ),
    SpotInstanceRequestId: S.optional(S.String).pipe(
      T.XmlName("spotInstanceRequestId"),
      T.Ec2QueryName("SpotInstanceRequestId"),
    ),
    SriovNetSupport: S.optional(S.String).pipe(
      T.XmlName("sriovNetSupport"),
      T.Ec2QueryName("SriovNetSupport"),
    ),
    StateReason: S.optional(StateReason)
      .pipe(T.XmlName("stateReason"), T.Ec2QueryName("StateReason"))
      .annotate({ identifier: "StateReason" }),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    VirtualizationType: S.optional(VirtualizationType).pipe(
      T.XmlName("virtualizationType"),
      T.Ec2QueryName("VirtualizationType"),
    ),
    CpuOptions: S.optional(CpuOptions)
      .pipe(T.XmlName("cpuOptions"), T.Ec2QueryName("CpuOptions"))
      .annotate({ identifier: "CpuOptions" }),
    CapacityBlockId: S.optional(S.String).pipe(
      T.XmlName("capacityBlockId"),
      T.Ec2QueryName("CapacityBlockId"),
    ),
    CapacityReservationId: S.optional(S.String).pipe(
      T.XmlName("capacityReservationId"),
      T.Ec2QueryName("CapacityReservationId"),
    ),
    CapacityReservationSpecification: S.optional(
      CapacityReservationSpecificationResponse,
    )
      .pipe(
        T.XmlName("capacityReservationSpecification"),
        T.Ec2QueryName("CapacityReservationSpecification"),
      )
      .annotate({ identifier: "CapacityReservationSpecificationResponse" }),
    HibernationOptions: S.optional(HibernationOptions)
      .pipe(
        T.XmlName("hibernationOptions"),
        T.Ec2QueryName("HibernationOptions"),
      )
      .annotate({ identifier: "HibernationOptions" }),
    Licenses: S.optional(LicenseList).pipe(
      T.XmlName("licenseSet"),
      T.Ec2QueryName("LicenseSet"),
    ),
    MetadataOptions: S.optional(InstanceMetadataOptionsResponse)
      .pipe(T.XmlName("metadataOptions"), T.Ec2QueryName("MetadataOptions"))
      .annotate({ identifier: "InstanceMetadataOptionsResponse" }),
    EnclaveOptions: S.optional(EnclaveOptions)
      .pipe(T.XmlName("enclaveOptions"), T.Ec2QueryName("EnclaveOptions"))
      .annotate({ identifier: "EnclaveOptions" }),
    BootMode: S.optional(BootModeValues).pipe(
      T.XmlName("bootMode"),
      T.Ec2QueryName("BootMode"),
    ),
    PlatformDetails: S.optional(S.String).pipe(
      T.XmlName("platformDetails"),
      T.Ec2QueryName("PlatformDetails"),
    ),
    UsageOperation: S.optional(S.String).pipe(
      T.XmlName("usageOperation"),
      T.Ec2QueryName("UsageOperation"),
    ),
    UsageOperationUpdateTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("usageOperationUpdateTime"),
      T.Ec2QueryName("UsageOperationUpdateTime"),
    ),
    PrivateDnsNameOptions: S.optional(PrivateDnsNameOptionsResponse)
      .pipe(
        T.XmlName("privateDnsNameOptions"),
        T.Ec2QueryName("PrivateDnsNameOptions"),
      )
      .annotate({ identifier: "PrivateDnsNameOptionsResponse" }),
    Ipv6Address: S.optional(S.String).pipe(
      T.XmlName("ipv6Address"),
      T.Ec2QueryName("Ipv6Address"),
    ),
    TpmSupport: S.optional(S.String).pipe(
      T.XmlName("tpmSupport"),
      T.Ec2QueryName("TpmSupport"),
    ),
    MaintenanceOptions: S.optional(InstanceMaintenanceOptions)
      .pipe(
        T.XmlName("maintenanceOptions"),
        T.Ec2QueryName("MaintenanceOptions"),
      )
      .annotate({ identifier: "InstanceMaintenanceOptions" }),
    CurrentInstanceBootMode: S.optional(InstanceBootModeValues).pipe(
      T.XmlName("currentInstanceBootMode"),
      T.Ec2QueryName("CurrentInstanceBootMode"),
    ),
    NetworkPerformanceOptions: S.optional(InstanceNetworkPerformanceOptions)
      .pipe(
        T.XmlName("networkPerformanceOptions"),
        T.Ec2QueryName("NetworkPerformanceOptions"),
      )
      .annotate({ identifier: "InstanceNetworkPerformanceOptions" }),
    Operator: S.optional(OperatorResponse)
      .pipe(T.XmlName("operator"), T.Ec2QueryName("Operator"))
      .annotate({ identifier: "OperatorResponse" }),
    SecondaryInterfaces: S.optional(InstanceSecondaryInterfaceList).pipe(
      T.XmlName("secondaryInterfaceSet"),
      T.Ec2QueryName("SecondaryInterfaceSet"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    State: S.optional(InstanceState)
      .pipe(T.XmlName("instanceState"), T.Ec2QueryName("InstanceState"))
      .annotate({ identifier: "InstanceState" }),
    PrivateDnsName: S.optional(S.String).pipe(
      T.XmlName("privateDnsName"),
      T.Ec2QueryName("PrivateDnsName"),
    ),
    PublicDnsName: S.optional(S.String).pipe(
      T.XmlName("dnsName"),
      T.Ec2QueryName("DnsName"),
    ),
    StateTransitionReason: S.optional(S.String).pipe(
      T.XmlName("reason"),
      T.Ec2QueryName("Reason"),
    ),
    KeyName: S.optional(S.String).pipe(
      T.XmlName("keyName"),
      T.Ec2QueryName("KeyName"),
    ),
    AmiLaunchIndex: S.optional(S.Number).pipe(
      T.XmlName("amiLaunchIndex"),
      T.Ec2QueryName("AmiLaunchIndex"),
    ),
    ProductCodes: S.optional(ProductCodeList).pipe(
      T.XmlName("productCodes"),
      T.Ec2QueryName("ProductCodes"),
    ),
    InstanceType: S.optional(InstanceType).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    LaunchTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("launchTime"), T.Ec2QueryName("LaunchTime")),
    Placement: S.optional(Placement)
      .pipe(T.XmlName("placement"), T.Ec2QueryName("Placement"))
      .annotate({ identifier: "Placement" }),
    KernelId: S.optional(S.String).pipe(
      T.XmlName("kernelId"),
      T.Ec2QueryName("KernelId"),
    ),
    RamdiskId: S.optional(S.String).pipe(
      T.XmlName("ramdiskId"),
      T.Ec2QueryName("RamdiskId"),
    ),
    Platform: S.optional(PlatformValues).pipe(
      T.XmlName("platform"),
      T.Ec2QueryName("Platform"),
    ),
    Monitoring: S.optional(Monitoring)
      .pipe(T.XmlName("monitoring"), T.Ec2QueryName("Monitoring"))
      .annotate({ identifier: "Monitoring" }),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    PrivateIpAddress: S.optional(S.String).pipe(
      T.XmlName("privateIpAddress"),
      T.Ec2QueryName("PrivateIpAddress"),
    ),
    PublicIpAddress: S.optional(S.String).pipe(
      T.XmlName("ipAddress"),
      T.Ec2QueryName("IpAddress"),
    ),
  }),
).annotate({ identifier: "Instance" }) as any as S.Schema<Instance>;
export type InstanceList = Instance[];
export const InstanceList = S.Array(
  Instance.pipe(T.XmlName("item")).annotate({ identifier: "Instance" }),
);
export interface Reservation {
  ReservationId?: string;
  OwnerId?: string;
  RequesterId?: string;
  Groups?: GroupIdentifier[];
  Instances?: Instance[];
}
export const Reservation = S.suspend(() =>
  S.Struct({
    ReservationId: S.optional(S.String).pipe(
      T.XmlName("reservationId"),
      T.Ec2QueryName("ReservationId"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    RequesterId: S.optional(S.String).pipe(
      T.XmlName("requesterId"),
      T.Ec2QueryName("RequesterId"),
    ),
    Groups: S.optional(GroupIdentifierList).pipe(
      T.XmlName("groupSet"),
      T.Ec2QueryName("GroupSet"),
    ),
    Instances: S.optional(InstanceList).pipe(
      T.XmlName("instancesSet"),
      T.Ec2QueryName("InstancesSet"),
    ),
  }).pipe(ns),
).annotate({ identifier: "Reservation" }) as any as S.Schema<Reservation>;
export type ReservationList = Reservation[];
export const ReservationList = S.Array(
  Reservation.pipe(T.XmlName("item")).annotate({ identifier: "Reservation" }),
);
export interface DescribeInstancesResult {
  NextToken?: string;
  Reservations?: Reservation[];
}
export const DescribeInstancesResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    Reservations: S.optional(ReservationList).pipe(
      T.XmlName("reservationSet"),
      T.Ec2QueryName("ReservationSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeInstancesResult",
}) as any as S.Schema<DescribeInstancesResult>;
export interface DescribeInstanceSqlHaHistoryStatesRequest {
  InstanceIds?: string[];
  StartTime?: Date;
  EndTime?: Date;
  NextToken?: string;
  MaxResults?: number;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeInstanceSqlHaHistoryStatesRequest = S.suspend(() =>
  S.Struct({
    InstanceIds: S.optional(InstanceIdStringList).pipe(T.XmlName("InstanceId")),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    EndTime: S.optional(T.DateFromString.pipe(T.TimestampFormat("date-time"))),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInstanceSqlHaHistoryStatesRequest",
}) as any as S.Schema<DescribeInstanceSqlHaHistoryStatesRequest>;
export type SqlServerLicenseUsage = "full" | "waived" | (string & {});
export const SqlServerLicenseUsage = S.String;
export type HaStatus =
  | "processing"
  | "active"
  | "standby"
  | "invalid"
  | (string & {});
export const HaStatus = S.String;
export interface RegisteredInstance {
  InstanceId?: string;
  SqlServerLicenseUsage?: SqlServerLicenseUsage;
  HaStatus?: HaStatus;
  ProcessingStatus?: string;
  LastUpdatedTime?: Date;
  SqlServerCredentials?: string;
  Tags?: Tag[];
}
export const RegisteredInstance = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    SqlServerLicenseUsage: S.optional(SqlServerLicenseUsage).pipe(
      T.XmlName("sqlServerLicenseUsage"),
      T.Ec2QueryName("SqlServerLicenseUsage"),
    ),
    HaStatus: S.optional(HaStatus).pipe(
      T.XmlName("haStatus"),
      T.Ec2QueryName("HaStatus"),
    ),
    ProcessingStatus: S.optional(S.String).pipe(
      T.XmlName("processingStatus"),
      T.Ec2QueryName("ProcessingStatus"),
    ),
    LastUpdatedTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("lastUpdatedTime"), T.Ec2QueryName("LastUpdatedTime")),
    SqlServerCredentials: S.optional(S.String).pipe(
      T.XmlName("sqlServerCredentials"),
      T.Ec2QueryName("SqlServerCredentials"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "RegisteredInstance",
}) as any as S.Schema<RegisteredInstance>;
export type RegisteredInstanceList = RegisteredInstance[];
export const RegisteredInstanceList = S.Array(
  RegisteredInstance.pipe(T.XmlName("item")).annotate({
    identifier: "RegisteredInstance",
  }),
);
export interface DescribeInstanceSqlHaHistoryStatesResult {
  Instances?: RegisteredInstance[];
  NextToken?: string;
}
export const DescribeInstanceSqlHaHistoryStatesResult = S.suspend(() =>
  S.Struct({
    Instances: S.optional(RegisteredInstanceList).pipe(
      T.XmlName("instanceSet"),
      T.Ec2QueryName("InstanceSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeInstanceSqlHaHistoryStatesResult",
}) as any as S.Schema<DescribeInstanceSqlHaHistoryStatesResult>;
export interface DescribeInstanceSqlHaStatesRequest {
  InstanceIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeInstanceSqlHaStatesRequest = S.suspend(() =>
  S.Struct({
    InstanceIds: S.optional(InstanceIdStringList).pipe(T.XmlName("InstanceId")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInstanceSqlHaStatesRequest",
}) as any as S.Schema<DescribeInstanceSqlHaStatesRequest>;
export interface DescribeInstanceSqlHaStatesResult {
  Instances?: RegisteredInstance[];
  NextToken?: string;
}
export const DescribeInstanceSqlHaStatesResult = S.suspend(() =>
  S.Struct({
    Instances: S.optional(RegisteredInstanceList).pipe(
      T.XmlName("instanceSet"),
      T.Ec2QueryName("InstanceSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeInstanceSqlHaStatesResult",
}) as any as S.Schema<DescribeInstanceSqlHaStatesResult>;
export interface DescribeInstanceStatusRequest {
  InstanceIds?: string[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
  Filters?: Filter[];
  IncludeAllInstances?: boolean;
}
export const DescribeInstanceStatusRequest = S.suspend(() =>
  S.Struct({
    InstanceIds: S.optional(InstanceIdStringList).pipe(T.XmlName("InstanceId")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    IncludeAllInstances: S.optional(S.Boolean).pipe(
      T.XmlName("includeAllInstances"),
      T.Ec2QueryName("IncludeAllInstances"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInstanceStatusRequest",
}) as any as S.Schema<DescribeInstanceStatusRequest>;
export type EventCode =
  | "instance-reboot"
  | "system-reboot"
  | "system-maintenance"
  | "instance-retirement"
  | "instance-stop"
  | (string & {});
export const EventCode = S.String;
export interface InstanceStatusEvent {
  InstanceEventId?: string;
  Code?: EventCode;
  Description?: string;
  NotAfter?: Date;
  NotBefore?: Date;
  NotBeforeDeadline?: Date;
}
export const InstanceStatusEvent = S.suspend(() =>
  S.Struct({
    InstanceEventId: S.optional(S.String).pipe(
      T.XmlName("instanceEventId"),
      T.Ec2QueryName("InstanceEventId"),
    ),
    Code: S.optional(EventCode).pipe(T.XmlName("code"), T.Ec2QueryName("Code")),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    NotAfter: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("notAfter"), T.Ec2QueryName("NotAfter")),
    NotBefore: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("notBefore"), T.Ec2QueryName("NotBefore")),
    NotBeforeDeadline: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("notBeforeDeadline"), T.Ec2QueryName("NotBeforeDeadline")),
  }),
).annotate({
  identifier: "InstanceStatusEvent",
}) as any as S.Schema<InstanceStatusEvent>;
export type InstanceStatusEventList = InstanceStatusEvent[];
export const InstanceStatusEventList = S.Array(
  InstanceStatusEvent.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceStatusEvent",
  }),
);
export type StatusName = "reachability" | (string & {});
export const StatusName = S.String;
export type StatusType =
  | "passed"
  | "failed"
  | "insufficient-data"
  | "initializing"
  | (string & {});
export const StatusType = S.String;
export interface InstanceStatusDetails {
  ImpairedSince?: Date;
  Name?: StatusName;
  Status?: StatusType;
}
export const InstanceStatusDetails = S.suspend(() =>
  S.Struct({
    ImpairedSince: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("impairedSince"), T.Ec2QueryName("ImpairedSince")),
    Name: S.optional(StatusName).pipe(
      T.XmlName("name"),
      T.Ec2QueryName("Name"),
    ),
    Status: S.optional(StatusType).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
  }),
).annotate({
  identifier: "InstanceStatusDetails",
}) as any as S.Schema<InstanceStatusDetails>;
export type InstanceStatusDetailsList = InstanceStatusDetails[];
export const InstanceStatusDetailsList = S.Array(
  InstanceStatusDetails.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceStatusDetails",
  }),
);
export type SummaryStatus =
  | "ok"
  | "impaired"
  | "insufficient-data"
  | "not-applicable"
  | "initializing"
  | (string & {});
export const SummaryStatus = S.String;
export interface InstanceStatusSummary {
  Details?: InstanceStatusDetails[];
  Status?: SummaryStatus;
}
export const InstanceStatusSummary = S.suspend(() =>
  S.Struct({
    Details: S.optional(InstanceStatusDetailsList).pipe(
      T.XmlName("details"),
      T.Ec2QueryName("Details"),
    ),
    Status: S.optional(SummaryStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
  }),
).annotate({
  identifier: "InstanceStatusSummary",
}) as any as S.Schema<InstanceStatusSummary>;
export interface EbsStatusDetails {
  ImpairedSince?: Date;
  Name?: StatusName;
  Status?: StatusType;
}
export const EbsStatusDetails = S.suspend(() =>
  S.Struct({
    ImpairedSince: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("impairedSince"), T.Ec2QueryName("ImpairedSince")),
    Name: S.optional(StatusName).pipe(
      T.XmlName("name"),
      T.Ec2QueryName("Name"),
    ),
    Status: S.optional(StatusType).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
  }),
).annotate({
  identifier: "EbsStatusDetails",
}) as any as S.Schema<EbsStatusDetails>;
export type EbsStatusDetailsList = EbsStatusDetails[];
export const EbsStatusDetailsList = S.Array(
  EbsStatusDetails.pipe(T.XmlName("item")).annotate({
    identifier: "EbsStatusDetails",
  }),
);
export interface EbsStatusSummary {
  Details?: EbsStatusDetails[];
  Status?: SummaryStatus;
}
export const EbsStatusSummary = S.suspend(() =>
  S.Struct({
    Details: S.optional(EbsStatusDetailsList).pipe(
      T.XmlName("details"),
      T.Ec2QueryName("Details"),
    ),
    Status: S.optional(SummaryStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
  }),
).annotate({
  identifier: "EbsStatusSummary",
}) as any as S.Schema<EbsStatusSummary>;
export interface InstanceStatus {
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  OutpostArn?: string;
  Operator?: OperatorResponse;
  Events?: InstanceStatusEvent[];
  InstanceId?: string;
  InstanceState?: InstanceState;
  InstanceStatus?: InstanceStatusSummary;
  SystemStatus?: InstanceStatusSummary;
  AttachedEbsStatus?: EbsStatusSummary;
}
export const InstanceStatus = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    OutpostArn: S.optional(S.String).pipe(
      T.XmlName("outpostArn"),
      T.Ec2QueryName("OutpostArn"),
    ),
    Operator: S.optional(OperatorResponse)
      .pipe(T.XmlName("operator"), T.Ec2QueryName("Operator"))
      .annotate({ identifier: "OperatorResponse" }),
    Events: S.optional(InstanceStatusEventList).pipe(
      T.XmlName("eventsSet"),
      T.Ec2QueryName("EventsSet"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    InstanceState: S.optional(InstanceState)
      .pipe(T.XmlName("instanceState"), T.Ec2QueryName("InstanceState"))
      .annotate({ identifier: "InstanceState" }),
    InstanceStatus: S.optional(InstanceStatusSummary)
      .pipe(T.XmlName("instanceStatus"), T.Ec2QueryName("InstanceStatus"))
      .annotate({ identifier: "InstanceStatusSummary" }),
    SystemStatus: S.optional(InstanceStatusSummary)
      .pipe(T.XmlName("systemStatus"), T.Ec2QueryName("SystemStatus"))
      .annotate({ identifier: "InstanceStatusSummary" }),
    AttachedEbsStatus: S.optional(EbsStatusSummary)
      .pipe(T.XmlName("attachedEbsStatus"), T.Ec2QueryName("AttachedEbsStatus"))
      .annotate({ identifier: "EbsStatusSummary" }),
  }),
).annotate({ identifier: "InstanceStatus" }) as any as S.Schema<InstanceStatus>;
export type InstanceStatusList = InstanceStatus[];
export const InstanceStatusList = S.Array(
  InstanceStatus.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceStatus",
  }),
);
export interface DescribeInstanceStatusResult {
  InstanceStatuses?: InstanceStatus[];
  NextToken?: string;
}
export const DescribeInstanceStatusResult = S.suspend(() =>
  S.Struct({
    InstanceStatuses: S.optional(InstanceStatusList).pipe(
      T.XmlName("instanceStatusSet"),
      T.Ec2QueryName("InstanceStatusSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeInstanceStatusResult",
}) as any as S.Schema<DescribeInstanceStatusResult>;
export type DescribeInstanceTopologyInstanceIdSet = string[];
export const DescribeInstanceTopologyInstanceIdSet = S.Array(S.String);
export type DescribeInstanceTopologyGroupNameSet = string[];
export const DescribeInstanceTopologyGroupNameSet = S.Array(S.String);
export interface DescribeInstanceTopologyRequest {
  DryRun?: boolean;
  NextToken?: string;
  MaxResults?: number;
  InstanceIds?: string[];
  GroupNames?: string[];
  Filters?: Filter[];
}
export const DescribeInstanceTopologyRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    InstanceIds: S.optional(DescribeInstanceTopologyInstanceIdSet).pipe(
      T.XmlName("InstanceId"),
    ),
    GroupNames: S.optional(DescribeInstanceTopologyGroupNameSet).pipe(
      T.XmlName("GroupName"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInstanceTopologyRequest",
}) as any as S.Schema<DescribeInstanceTopologyRequest>;
export type NetworkNodesList = string[];
export const NetworkNodesList = S.Array(S.String.pipe(T.XmlName("item")));
export interface InstanceTopology {
  InstanceId?: string;
  InstanceType?: string;
  GroupName?: string;
  NetworkNodes?: string[];
  AvailabilityZone?: string;
  ZoneId?: string;
  CapacityBlockId?: string;
}
export const InstanceTopology = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    InstanceType: S.optional(S.String).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    GroupName: S.optional(S.String).pipe(
      T.XmlName("groupName"),
      T.Ec2QueryName("GroupName"),
    ),
    NetworkNodes: S.optional(NetworkNodesList).pipe(
      T.XmlName("networkNodeSet"),
      T.Ec2QueryName("NetworkNodeSet"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    ZoneId: S.optional(S.String).pipe(
      T.XmlName("zoneId"),
      T.Ec2QueryName("ZoneId"),
    ),
    CapacityBlockId: S.optional(S.String).pipe(
      T.XmlName("capacityBlockId"),
      T.Ec2QueryName("CapacityBlockId"),
    ),
  }),
).annotate({
  identifier: "InstanceTopology",
}) as any as S.Schema<InstanceTopology>;
export type InstanceSet = InstanceTopology[];
export const InstanceSet = S.Array(
  InstanceTopology.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceTopology",
  }),
);
export interface DescribeInstanceTopologyResult {
  Instances?: InstanceTopology[];
  NextToken?: string;
}
export const DescribeInstanceTopologyResult = S.suspend(() =>
  S.Struct({
    Instances: S.optional(InstanceSet).pipe(
      T.XmlName("instanceSet"),
      T.Ec2QueryName("InstanceSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeInstanceTopologyResult",
}) as any as S.Schema<DescribeInstanceTopologyResult>;
export type LocationType =
  | "region"
  | "availability-zone"
  | "availability-zone-id"
  | "outpost"
  | (string & {});
export const LocationType = S.String;
export interface DescribeInstanceTypeOfferingsRequest {
  DryRun?: boolean;
  LocationType?: LocationType;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeInstanceTypeOfferingsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    LocationType: S.optional(LocationType),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInstanceTypeOfferingsRequest",
}) as any as S.Schema<DescribeInstanceTypeOfferingsRequest>;
export interface InstanceTypeOffering {
  InstanceType?: InstanceType;
  LocationType?: LocationType;
  Location?: string;
}
export const InstanceTypeOffering = S.suspend(() =>
  S.Struct({
    InstanceType: S.optional(InstanceType).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    LocationType: S.optional(LocationType).pipe(
      T.XmlName("locationType"),
      T.Ec2QueryName("LocationType"),
    ),
    Location: S.optional(S.String).pipe(
      T.XmlName("location"),
      T.Ec2QueryName("Location"),
    ),
  }),
).annotate({
  identifier: "InstanceTypeOffering",
}) as any as S.Schema<InstanceTypeOffering>;
export type InstanceTypeOfferingsList = InstanceTypeOffering[];
export const InstanceTypeOfferingsList = S.Array(
  InstanceTypeOffering.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceTypeOffering",
  }),
);
export interface DescribeInstanceTypeOfferingsResult {
  InstanceTypeOfferings?: InstanceTypeOffering[];
  NextToken?: string;
}
export const DescribeInstanceTypeOfferingsResult = S.suspend(() =>
  S.Struct({
    InstanceTypeOfferings: S.optional(InstanceTypeOfferingsList).pipe(
      T.XmlName("instanceTypeOfferingSet"),
      T.Ec2QueryName("InstanceTypeOfferingSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeInstanceTypeOfferingsResult",
}) as any as S.Schema<DescribeInstanceTypeOfferingsResult>;
export type RequestInstanceTypeList = InstanceType[];
export const RequestInstanceTypeList = S.Array(InstanceType);
export interface DescribeInstanceTypesRequest {
  DryRun?: boolean;
  InstanceTypes?: InstanceType[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeInstanceTypesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    InstanceTypes: S.optional(RequestInstanceTypeList).pipe(
      T.XmlName("InstanceType"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInstanceTypesRequest",
}) as any as S.Schema<DescribeInstanceTypesRequest>;
export type UsageClassType =
  | "spot"
  | "on-demand"
  | "capacity-block"
  | (string & {});
export const UsageClassType = S.String;
export type UsageClassTypeList = UsageClassType[];
export const UsageClassTypeList = S.Array(
  UsageClassType.pipe(T.XmlName("item")),
);
export type RootDeviceType = "ebs" | "instance-store" | (string & {});
export const RootDeviceType = S.String;
export type RootDeviceTypeList = RootDeviceType[];
export const RootDeviceTypeList = S.Array(
  RootDeviceType.pipe(T.XmlName("item")),
);
export type VirtualizationTypeList = VirtualizationType[];
export const VirtualizationTypeList = S.Array(
  VirtualizationType.pipe(T.XmlName("item")),
);
export type InstanceTypeHypervisor = "nitro" | "xen" | (string & {});
export const InstanceTypeHypervisor = S.String;
export type ArchitectureType =
  | "i386"
  | "x86_64"
  | "arm64"
  | "x86_64_mac"
  | "arm64_mac"
  | (string & {});
export const ArchitectureType = S.String;
export type ArchitectureTypeList = ArchitectureType[];
export const ArchitectureTypeList = S.Array(
  ArchitectureType.pipe(T.XmlName("item")),
);
export type SupportedAdditionalProcessorFeature =
  | "amd-sev-snp"
  | "nested-virtualization"
  | (string & {});
export const SupportedAdditionalProcessorFeature = S.String;
export type SupportedAdditionalProcessorFeatureList =
  SupportedAdditionalProcessorFeature[];
export const SupportedAdditionalProcessorFeatureList = S.Array(
  SupportedAdditionalProcessorFeature.pipe(T.XmlName("item")),
);
export interface ProcessorInfo {
  SupportedArchitectures?: ArchitectureType[];
  SustainedClockSpeedInGhz?: number;
  SupportedFeatures?: SupportedAdditionalProcessorFeature[];
  Manufacturer?: string;
}
export const ProcessorInfo = S.suspend(() =>
  S.Struct({
    SupportedArchitectures: S.optional(ArchitectureTypeList).pipe(
      T.XmlName("supportedArchitectures"),
      T.Ec2QueryName("SupportedArchitectures"),
    ),
    SustainedClockSpeedInGhz: S.optional(S.Number).pipe(
      T.XmlName("sustainedClockSpeedInGhz"),
      T.Ec2QueryName("SustainedClockSpeedInGhz"),
    ),
    SupportedFeatures: S.optional(SupportedAdditionalProcessorFeatureList).pipe(
      T.XmlName("supportedFeatures"),
      T.Ec2QueryName("SupportedFeatures"),
    ),
    Manufacturer: S.optional(S.String).pipe(
      T.XmlName("manufacturer"),
      T.Ec2QueryName("Manufacturer"),
    ),
  }),
).annotate({ identifier: "ProcessorInfo" }) as any as S.Schema<ProcessorInfo>;
export type CoreCountList = number[];
export const CoreCountList = S.Array(S.Number.pipe(T.XmlName("item")));
export type ThreadsPerCoreList = number[];
export const ThreadsPerCoreList = S.Array(S.Number.pipe(T.XmlName("item")));
export interface VCpuInfo {
  DefaultVCpus?: number;
  DefaultCores?: number;
  DefaultThreadsPerCore?: number;
  ValidCores?: number[];
  ValidThreadsPerCore?: number[];
}
export const VCpuInfo = S.suspend(() =>
  S.Struct({
    DefaultVCpus: S.optional(S.Number).pipe(
      T.XmlName("defaultVCpus"),
      T.Ec2QueryName("DefaultVCpus"),
    ),
    DefaultCores: S.optional(S.Number).pipe(
      T.XmlName("defaultCores"),
      T.Ec2QueryName("DefaultCores"),
    ),
    DefaultThreadsPerCore: S.optional(S.Number).pipe(
      T.XmlName("defaultThreadsPerCore"),
      T.Ec2QueryName("DefaultThreadsPerCore"),
    ),
    ValidCores: S.optional(CoreCountList).pipe(
      T.XmlName("validCores"),
      T.Ec2QueryName("ValidCores"),
    ),
    ValidThreadsPerCore: S.optional(ThreadsPerCoreList).pipe(
      T.XmlName("validThreadsPerCore"),
      T.Ec2QueryName("ValidThreadsPerCore"),
    ),
  }),
).annotate({ identifier: "VCpuInfo" }) as any as S.Schema<VCpuInfo>;
export interface MemoryInfo {
  SizeInMiB?: number;
}
export const MemoryInfo = S.suspend(() =>
  S.Struct({
    SizeInMiB: S.optional(S.Number).pipe(
      T.XmlName("sizeInMiB"),
      T.Ec2QueryName("SizeInMiB"),
    ),
  }),
).annotate({ identifier: "MemoryInfo" }) as any as S.Schema<MemoryInfo>;
export type DiskType = "hdd" | "ssd" | (string & {});
export const DiskType = S.String;
export interface DiskInfo {
  SizeInGB?: number;
  Count?: number;
  Type?: DiskType;
}
export const DiskInfo = S.suspend(() =>
  S.Struct({
    SizeInGB: S.optional(S.Number).pipe(
      T.XmlName("sizeInGB"),
      T.Ec2QueryName("SizeInGB"),
    ),
    Count: S.optional(S.Number).pipe(
      T.XmlName("count"),
      T.Ec2QueryName("Count"),
    ),
    Type: S.optional(DiskType).pipe(T.XmlName("type"), T.Ec2QueryName("Type")),
  }),
).annotate({ identifier: "DiskInfo" }) as any as S.Schema<DiskInfo>;
export type DiskInfoList = DiskInfo[];
export const DiskInfoList = S.Array(
  DiskInfo.pipe(T.XmlName("item")).annotate({ identifier: "DiskInfo" }),
);
export type EphemeralNvmeSupport =
  | "unsupported"
  | "supported"
  | "required"
  | (string & {});
export const EphemeralNvmeSupport = S.String;
export type InstanceStorageEncryptionSupport =
  | "unsupported"
  | "required"
  | (string & {});
export const InstanceStorageEncryptionSupport = S.String;
export interface InstanceStorageInfo {
  TotalSizeInGB?: number;
  Disks?: DiskInfo[];
  NvmeSupport?: EphemeralNvmeSupport;
  EncryptionSupport?: InstanceStorageEncryptionSupport;
}
export const InstanceStorageInfo = S.suspend(() =>
  S.Struct({
    TotalSizeInGB: S.optional(S.Number).pipe(
      T.XmlName("totalSizeInGB"),
      T.Ec2QueryName("TotalSizeInGB"),
    ),
    Disks: S.optional(DiskInfoList).pipe(
      T.XmlName("disks"),
      T.Ec2QueryName("Disks"),
    ),
    NvmeSupport: S.optional(EphemeralNvmeSupport).pipe(
      T.XmlName("nvmeSupport"),
      T.Ec2QueryName("NvmeSupport"),
    ),
    EncryptionSupport: S.optional(InstanceStorageEncryptionSupport).pipe(
      T.XmlName("encryptionSupport"),
      T.Ec2QueryName("EncryptionSupport"),
    ),
  }),
).annotate({
  identifier: "InstanceStorageInfo",
}) as any as S.Schema<InstanceStorageInfo>;
export type EbsOptimizedSupport =
  | "unsupported"
  | "supported"
  | "default"
  | (string & {});
export const EbsOptimizedSupport = S.String;
export type EbsEncryptionSupport = "unsupported" | "supported" | (string & {});
export const EbsEncryptionSupport = S.String;
export interface EbsOptimizedInfo {
  BaselineBandwidthInMbps?: number;
  BaselineThroughputInMBps?: number;
  BaselineIops?: number;
  MaximumBandwidthInMbps?: number;
  MaximumThroughputInMBps?: number;
  MaximumIops?: number;
}
export const EbsOptimizedInfo = S.suspend(() =>
  S.Struct({
    BaselineBandwidthInMbps: S.optional(S.Number).pipe(
      T.XmlName("baselineBandwidthInMbps"),
      T.Ec2QueryName("BaselineBandwidthInMbps"),
    ),
    BaselineThroughputInMBps: S.optional(S.Number).pipe(
      T.XmlName("baselineThroughputInMBps"),
      T.Ec2QueryName("BaselineThroughputInMBps"),
    ),
    BaselineIops: S.optional(S.Number).pipe(
      T.XmlName("baselineIops"),
      T.Ec2QueryName("BaselineIops"),
    ),
    MaximumBandwidthInMbps: S.optional(S.Number).pipe(
      T.XmlName("maximumBandwidthInMbps"),
      T.Ec2QueryName("MaximumBandwidthInMbps"),
    ),
    MaximumThroughputInMBps: S.optional(S.Number).pipe(
      T.XmlName("maximumThroughputInMBps"),
      T.Ec2QueryName("MaximumThroughputInMBps"),
    ),
    MaximumIops: S.optional(S.Number).pipe(
      T.XmlName("maximumIops"),
      T.Ec2QueryName("MaximumIops"),
    ),
  }),
).annotate({
  identifier: "EbsOptimizedInfo",
}) as any as S.Schema<EbsOptimizedInfo>;
export type EbsNvmeSupport =
  | "unsupported"
  | "supported"
  | "required"
  | (string & {});
export const EbsNvmeSupport = S.String;
export type AttachmentLimitType = "shared" | "dedicated" | (string & {});
export const AttachmentLimitType = S.String;
export interface EbsCardInfo {
  EbsCardIndex?: number;
  BaselineBandwidthInMbps?: number;
  BaselineThroughputInMBps?: number;
  BaselineIops?: number;
  MaximumBandwidthInMbps?: number;
  MaximumThroughputInMBps?: number;
  MaximumIops?: number;
}
export const EbsCardInfo = S.suspend(() =>
  S.Struct({
    EbsCardIndex: S.optional(S.Number).pipe(
      T.XmlName("ebsCardIndex"),
      T.Ec2QueryName("EbsCardIndex"),
    ),
    BaselineBandwidthInMbps: S.optional(S.Number).pipe(
      T.XmlName("baselineBandwidthInMbps"),
      T.Ec2QueryName("BaselineBandwidthInMbps"),
    ),
    BaselineThroughputInMBps: S.optional(S.Number).pipe(
      T.XmlName("baselineThroughputInMBps"),
      T.Ec2QueryName("BaselineThroughputInMBps"),
    ),
    BaselineIops: S.optional(S.Number).pipe(
      T.XmlName("baselineIops"),
      T.Ec2QueryName("BaselineIops"),
    ),
    MaximumBandwidthInMbps: S.optional(S.Number).pipe(
      T.XmlName("maximumBandwidthInMbps"),
      T.Ec2QueryName("MaximumBandwidthInMbps"),
    ),
    MaximumThroughputInMBps: S.optional(S.Number).pipe(
      T.XmlName("maximumThroughputInMBps"),
      T.Ec2QueryName("MaximumThroughputInMBps"),
    ),
    MaximumIops: S.optional(S.Number).pipe(
      T.XmlName("maximumIops"),
      T.Ec2QueryName("MaximumIops"),
    ),
  }),
).annotate({ identifier: "EbsCardInfo" }) as any as S.Schema<EbsCardInfo>;
export type EbsCardInfoList = EbsCardInfo[];
export const EbsCardInfoList = S.Array(
  EbsCardInfo.pipe(T.XmlName("item")).annotate({ identifier: "EbsCardInfo" }),
);
export interface EbsInfo {
  EbsOptimizedSupport?: EbsOptimizedSupport;
  EncryptionSupport?: EbsEncryptionSupport;
  EbsOptimizedInfo?: EbsOptimizedInfo;
  NvmeSupport?: EbsNvmeSupport;
  MaximumEbsAttachments?: number;
  AttachmentLimitType?: AttachmentLimitType;
  MaximumEbsCards?: number;
  EbsCards?: EbsCardInfo[];
}
export const EbsInfo = S.suspend(() =>
  S.Struct({
    EbsOptimizedSupport: S.optional(EbsOptimizedSupport).pipe(
      T.XmlName("ebsOptimizedSupport"),
      T.Ec2QueryName("EbsOptimizedSupport"),
    ),
    EncryptionSupport: S.optional(EbsEncryptionSupport).pipe(
      T.XmlName("encryptionSupport"),
      T.Ec2QueryName("EncryptionSupport"),
    ),
    EbsOptimizedInfo: S.optional(EbsOptimizedInfo)
      .pipe(T.XmlName("ebsOptimizedInfo"), T.Ec2QueryName("EbsOptimizedInfo"))
      .annotate({ identifier: "EbsOptimizedInfo" }),
    NvmeSupport: S.optional(EbsNvmeSupport).pipe(
      T.XmlName("nvmeSupport"),
      T.Ec2QueryName("NvmeSupport"),
    ),
    MaximumEbsAttachments: S.optional(S.Number).pipe(
      T.XmlName("maximumEbsAttachments"),
      T.Ec2QueryName("MaximumEbsAttachments"),
    ),
    AttachmentLimitType: S.optional(AttachmentLimitType).pipe(
      T.XmlName("attachmentLimitType"),
      T.Ec2QueryName("AttachmentLimitType"),
    ),
    MaximumEbsCards: S.optional(S.Number).pipe(
      T.XmlName("maximumEbsCards"),
      T.Ec2QueryName("MaximumEbsCards"),
    ),
    EbsCards: S.optional(EbsCardInfoList).pipe(
      T.XmlName("ebsCardSet"),
      T.Ec2QueryName("EbsCardSet"),
    ),
  }),
).annotate({ identifier: "EbsInfo" }) as any as S.Schema<EbsInfo>;
export interface NetworkCardInfo {
  NetworkCardIndex?: number;
  NetworkPerformance?: string;
  MaximumNetworkInterfaces?: number;
  AdditionalFlexibleNetworkInterfaces?: number;
  BaselineBandwidthInGbps?: number;
  PeakBandwidthInGbps?: number;
  DefaultEnaQueueCountPerInterface?: number;
  MaximumEnaQueueCount?: number;
  MaximumEnaQueueCountPerInterface?: number;
}
export const NetworkCardInfo = S.suspend(() =>
  S.Struct({
    NetworkCardIndex: S.optional(S.Number).pipe(
      T.XmlName("networkCardIndex"),
      T.Ec2QueryName("NetworkCardIndex"),
    ),
    NetworkPerformance: S.optional(S.String).pipe(
      T.XmlName("networkPerformance"),
      T.Ec2QueryName("NetworkPerformance"),
    ),
    MaximumNetworkInterfaces: S.optional(S.Number).pipe(
      T.XmlName("maximumNetworkInterfaces"),
      T.Ec2QueryName("MaximumNetworkInterfaces"),
    ),
    AdditionalFlexibleNetworkInterfaces: S.optional(S.Number).pipe(
      T.XmlName("additionalFlexibleNetworkInterfaces"),
      T.Ec2QueryName("AdditionalFlexibleNetworkInterfaces"),
    ),
    BaselineBandwidthInGbps: S.optional(S.Number).pipe(
      T.XmlName("baselineBandwidthInGbps"),
      T.Ec2QueryName("BaselineBandwidthInGbps"),
    ),
    PeakBandwidthInGbps: S.optional(S.Number).pipe(
      T.XmlName("peakBandwidthInGbps"),
      T.Ec2QueryName("PeakBandwidthInGbps"),
    ),
    DefaultEnaQueueCountPerInterface: S.optional(S.Number).pipe(
      T.XmlName("defaultEnaQueueCountPerInterface"),
      T.Ec2QueryName("DefaultEnaQueueCountPerInterface"),
    ),
    MaximumEnaQueueCount: S.optional(S.Number).pipe(
      T.XmlName("maximumEnaQueueCount"),
      T.Ec2QueryName("MaximumEnaQueueCount"),
    ),
    MaximumEnaQueueCountPerInterface: S.optional(S.Number).pipe(
      T.XmlName("maximumEnaQueueCountPerInterface"),
      T.Ec2QueryName("MaximumEnaQueueCountPerInterface"),
    ),
  }),
).annotate({
  identifier: "NetworkCardInfo",
}) as any as S.Schema<NetworkCardInfo>;
export type NetworkCardInfoList = NetworkCardInfo[];
export const NetworkCardInfoList = S.Array(
  NetworkCardInfo.pipe(T.XmlName("item")).annotate({
    identifier: "NetworkCardInfo",
  }),
);
export type EnaSupport =
  | "unsupported"
  | "supported"
  | "required"
  | (string & {});
export const EnaSupport = S.String;
export interface EfaInfo {
  MaximumEfaInterfaces?: number;
}
export const EfaInfo = S.suspend(() =>
  S.Struct({
    MaximumEfaInterfaces: S.optional(S.Number).pipe(
      T.XmlName("maximumEfaInterfaces"),
      T.Ec2QueryName("MaximumEfaInterfaces"),
    ),
  }),
).annotate({ identifier: "EfaInfo" }) as any as S.Schema<EfaInfo>;
export type BandwidthWeightingType =
  | "default"
  | "vpc-1"
  | "ebs-1"
  | (string & {});
export const BandwidthWeightingType = S.String;
export type BandwidthWeightingTypeList = BandwidthWeightingType[];
export const BandwidthWeightingTypeList = S.Array(
  BandwidthWeightingType.pipe(T.XmlName("item")),
);
export type FlexibleEnaQueuesSupport =
  | "unsupported"
  | "supported"
  | (string & {});
export const FlexibleEnaQueuesSupport = S.String;
export interface NetworkInfo {
  NetworkPerformance?: string;
  MaximumNetworkInterfaces?: number;
  MaximumNetworkCards?: number;
  DefaultNetworkCardIndex?: number;
  NetworkCards?: NetworkCardInfo[];
  Ipv4AddressesPerInterface?: number;
  Ipv6AddressesPerInterface?: number;
  Ipv6Supported?: boolean;
  EnaSupport?: EnaSupport;
  EfaSupported?: boolean;
  EfaInfo?: EfaInfo;
  EncryptionInTransitSupported?: boolean;
  EnaSrdSupported?: boolean;
  BandwidthWeightings?: BandwidthWeightingType[];
  FlexibleEnaQueuesSupport?: FlexibleEnaQueuesSupport;
  SecondaryNetworkSupported?: boolean;
  MaximumSecondaryNetworkInterfaces?: number;
  Ipv4AddressesPerSecondaryInterface?: number;
}
export const NetworkInfo = S.suspend(() =>
  S.Struct({
    NetworkPerformance: S.optional(S.String).pipe(
      T.XmlName("networkPerformance"),
      T.Ec2QueryName("NetworkPerformance"),
    ),
    MaximumNetworkInterfaces: S.optional(S.Number).pipe(
      T.XmlName("maximumNetworkInterfaces"),
      T.Ec2QueryName("MaximumNetworkInterfaces"),
    ),
    MaximumNetworkCards: S.optional(S.Number).pipe(
      T.XmlName("maximumNetworkCards"),
      T.Ec2QueryName("MaximumNetworkCards"),
    ),
    DefaultNetworkCardIndex: S.optional(S.Number).pipe(
      T.XmlName("defaultNetworkCardIndex"),
      T.Ec2QueryName("DefaultNetworkCardIndex"),
    ),
    NetworkCards: S.optional(NetworkCardInfoList).pipe(
      T.XmlName("networkCards"),
      T.Ec2QueryName("NetworkCards"),
    ),
    Ipv4AddressesPerInterface: S.optional(S.Number).pipe(
      T.XmlName("ipv4AddressesPerInterface"),
      T.Ec2QueryName("Ipv4AddressesPerInterface"),
    ),
    Ipv6AddressesPerInterface: S.optional(S.Number).pipe(
      T.XmlName("ipv6AddressesPerInterface"),
      T.Ec2QueryName("Ipv6AddressesPerInterface"),
    ),
    Ipv6Supported: S.optional(S.Boolean).pipe(
      T.XmlName("ipv6Supported"),
      T.Ec2QueryName("Ipv6Supported"),
    ),
    EnaSupport: S.optional(EnaSupport).pipe(
      T.XmlName("enaSupport"),
      T.Ec2QueryName("EnaSupport"),
    ),
    EfaSupported: S.optional(S.Boolean).pipe(
      T.XmlName("efaSupported"),
      T.Ec2QueryName("EfaSupported"),
    ),
    EfaInfo: S.optional(EfaInfo)
      .pipe(T.XmlName("efaInfo"), T.Ec2QueryName("EfaInfo"))
      .annotate({ identifier: "EfaInfo" }),
    EncryptionInTransitSupported: S.optional(S.Boolean).pipe(
      T.XmlName("encryptionInTransitSupported"),
      T.Ec2QueryName("EncryptionInTransitSupported"),
    ),
    EnaSrdSupported: S.optional(S.Boolean).pipe(
      T.XmlName("enaSrdSupported"),
      T.Ec2QueryName("EnaSrdSupported"),
    ),
    BandwidthWeightings: S.optional(BandwidthWeightingTypeList).pipe(
      T.XmlName("bandwidthWeightings"),
      T.Ec2QueryName("BandwidthWeightings"),
    ),
    FlexibleEnaQueuesSupport: S.optional(FlexibleEnaQueuesSupport).pipe(
      T.XmlName("flexibleEnaQueuesSupport"),
      T.Ec2QueryName("FlexibleEnaQueuesSupport"),
    ),
    SecondaryNetworkSupported: S.optional(S.Boolean).pipe(
      T.XmlName("secondaryNetworkSupported"),
      T.Ec2QueryName("SecondaryNetworkSupported"),
    ),
    MaximumSecondaryNetworkInterfaces: S.optional(S.Number).pipe(
      T.XmlName("maximumSecondaryNetworkInterfaces"),
      T.Ec2QueryName("MaximumSecondaryNetworkInterfaces"),
    ),
    Ipv4AddressesPerSecondaryInterface: S.optional(S.Number).pipe(
      T.XmlName("ipv4AddressesPerSecondaryInterface"),
      T.Ec2QueryName("Ipv4AddressesPerSecondaryInterface"),
    ),
  }),
).annotate({ identifier: "NetworkInfo" }) as any as S.Schema<NetworkInfo>;
export type WorkloadsList = string[];
export const WorkloadsList = S.Array(S.String.pipe(T.XmlName("item")));
export interface GpuDeviceMemoryInfo {
  SizeInMiB?: number;
}
export const GpuDeviceMemoryInfo = S.suspend(() =>
  S.Struct({
    SizeInMiB: S.optional(S.Number).pipe(
      T.XmlName("sizeInMiB"),
      T.Ec2QueryName("SizeInMiB"),
    ),
  }),
).annotate({
  identifier: "GpuDeviceMemoryInfo",
}) as any as S.Schema<GpuDeviceMemoryInfo>;
export interface GpuDeviceInfo {
  Name?: string;
  Manufacturer?: string;
  Count?: number;
  LogicalGpuCount?: number;
  GpuPartitionSize?: number;
  Workloads?: string[];
  MemoryInfo?: GpuDeviceMemoryInfo;
}
export const GpuDeviceInfo = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
    Manufacturer: S.optional(S.String).pipe(
      T.XmlName("manufacturer"),
      T.Ec2QueryName("Manufacturer"),
    ),
    Count: S.optional(S.Number).pipe(
      T.XmlName("count"),
      T.Ec2QueryName("Count"),
    ),
    LogicalGpuCount: S.optional(S.Number).pipe(
      T.XmlName("logicalGpuCount"),
      T.Ec2QueryName("LogicalGpuCount"),
    ),
    GpuPartitionSize: S.optional(S.Number).pipe(
      T.XmlName("gpuPartitionSize"),
      T.Ec2QueryName("GpuPartitionSize"),
    ),
    Workloads: S.optional(WorkloadsList).pipe(
      T.XmlName("workloadSet"),
      T.Ec2QueryName("WorkloadSet"),
    ),
    MemoryInfo: S.optional(GpuDeviceMemoryInfo)
      .pipe(T.XmlName("memoryInfo"), T.Ec2QueryName("MemoryInfo"))
      .annotate({ identifier: "GpuDeviceMemoryInfo" }),
  }),
).annotate({ identifier: "GpuDeviceInfo" }) as any as S.Schema<GpuDeviceInfo>;
export type GpuDeviceInfoList = GpuDeviceInfo[];
export const GpuDeviceInfoList = S.Array(
  GpuDeviceInfo.pipe(T.XmlName("item")).annotate({
    identifier: "GpuDeviceInfo",
  }),
);
export interface GpuInfo {
  Gpus?: GpuDeviceInfo[];
  TotalGpuMemoryInMiB?: number;
}
export const GpuInfo = S.suspend(() =>
  S.Struct({
    Gpus: S.optional(GpuDeviceInfoList).pipe(
      T.XmlName("gpus"),
      T.Ec2QueryName("Gpus"),
    ),
    TotalGpuMemoryInMiB: S.optional(S.Number).pipe(
      T.XmlName("totalGpuMemoryInMiB"),
      T.Ec2QueryName("TotalGpuMemoryInMiB"),
    ),
  }),
).annotate({ identifier: "GpuInfo" }) as any as S.Schema<GpuInfo>;
export interface FpgaDeviceMemoryInfo {
  SizeInMiB?: number;
}
export const FpgaDeviceMemoryInfo = S.suspend(() =>
  S.Struct({
    SizeInMiB: S.optional(S.Number).pipe(
      T.XmlName("sizeInMiB"),
      T.Ec2QueryName("SizeInMiB"),
    ),
  }),
).annotate({
  identifier: "FpgaDeviceMemoryInfo",
}) as any as S.Schema<FpgaDeviceMemoryInfo>;
export interface FpgaDeviceInfo {
  Name?: string;
  Manufacturer?: string;
  Count?: number;
  MemoryInfo?: FpgaDeviceMemoryInfo;
}
export const FpgaDeviceInfo = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
    Manufacturer: S.optional(S.String).pipe(
      T.XmlName("manufacturer"),
      T.Ec2QueryName("Manufacturer"),
    ),
    Count: S.optional(S.Number).pipe(
      T.XmlName("count"),
      T.Ec2QueryName("Count"),
    ),
    MemoryInfo: S.optional(FpgaDeviceMemoryInfo)
      .pipe(T.XmlName("memoryInfo"), T.Ec2QueryName("MemoryInfo"))
      .annotate({ identifier: "FpgaDeviceMemoryInfo" }),
  }),
).annotate({ identifier: "FpgaDeviceInfo" }) as any as S.Schema<FpgaDeviceInfo>;
export type FpgaDeviceInfoList = FpgaDeviceInfo[];
export const FpgaDeviceInfoList = S.Array(
  FpgaDeviceInfo.pipe(T.XmlName("item")).annotate({
    identifier: "FpgaDeviceInfo",
  }),
);
export interface FpgaInfo {
  Fpgas?: FpgaDeviceInfo[];
  TotalFpgaMemoryInMiB?: number;
}
export const FpgaInfo = S.suspend(() =>
  S.Struct({
    Fpgas: S.optional(FpgaDeviceInfoList).pipe(
      T.XmlName("fpgas"),
      T.Ec2QueryName("Fpgas"),
    ),
    TotalFpgaMemoryInMiB: S.optional(S.Number).pipe(
      T.XmlName("totalFpgaMemoryInMiB"),
      T.Ec2QueryName("TotalFpgaMemoryInMiB"),
    ),
  }),
).annotate({ identifier: "FpgaInfo" }) as any as S.Schema<FpgaInfo>;
export type PlacementGroupStrategy =
  | "cluster"
  | "partition"
  | "spread"
  | (string & {});
export const PlacementGroupStrategy = S.String;
export type PlacementGroupStrategyList = PlacementGroupStrategy[];
export const PlacementGroupStrategyList = S.Array(
  PlacementGroupStrategy.pipe(T.XmlName("item")),
);
export interface PlacementGroupInfo {
  SupportedStrategies?: PlacementGroupStrategy[];
}
export const PlacementGroupInfo = S.suspend(() =>
  S.Struct({
    SupportedStrategies: S.optional(PlacementGroupStrategyList).pipe(
      T.XmlName("supportedStrategies"),
      T.Ec2QueryName("SupportedStrategies"),
    ),
  }),
).annotate({
  identifier: "PlacementGroupInfo",
}) as any as S.Schema<PlacementGroupInfo>;
export interface InferenceDeviceMemoryInfo {
  SizeInMiB?: number;
}
export const InferenceDeviceMemoryInfo = S.suspend(() =>
  S.Struct({
    SizeInMiB: S.optional(S.Number).pipe(
      T.XmlName("sizeInMiB"),
      T.Ec2QueryName("SizeInMiB"),
    ),
  }),
).annotate({
  identifier: "InferenceDeviceMemoryInfo",
}) as any as S.Schema<InferenceDeviceMemoryInfo>;
export interface InferenceDeviceInfo {
  Count?: number;
  Name?: string;
  Manufacturer?: string;
  MemoryInfo?: InferenceDeviceMemoryInfo;
}
export const InferenceDeviceInfo = S.suspend(() =>
  S.Struct({
    Count: S.optional(S.Number).pipe(
      T.XmlName("count"),
      T.Ec2QueryName("Count"),
    ),
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
    Manufacturer: S.optional(S.String).pipe(
      T.XmlName("manufacturer"),
      T.Ec2QueryName("Manufacturer"),
    ),
    MemoryInfo: S.optional(InferenceDeviceMemoryInfo)
      .pipe(T.XmlName("memoryInfo"), T.Ec2QueryName("MemoryInfo"))
      .annotate({ identifier: "InferenceDeviceMemoryInfo" }),
  }),
).annotate({
  identifier: "InferenceDeviceInfo",
}) as any as S.Schema<InferenceDeviceInfo>;
export type InferenceDeviceInfoList = InferenceDeviceInfo[];
export const InferenceDeviceInfoList = S.Array(InferenceDeviceInfo);
export interface InferenceAcceleratorInfo {
  Accelerators?: InferenceDeviceInfo[];
  TotalInferenceMemoryInMiB?: number;
}
export const InferenceAcceleratorInfo = S.suspend(() =>
  S.Struct({
    Accelerators: S.optional(InferenceDeviceInfoList).pipe(
      T.XmlName("accelerators"),
      T.Ec2QueryName("Accelerators"),
    ),
    TotalInferenceMemoryInMiB: S.optional(S.Number).pipe(
      T.XmlName("totalInferenceMemoryInMiB"),
      T.Ec2QueryName("TotalInferenceMemoryInMiB"),
    ),
  }),
).annotate({
  identifier: "InferenceAcceleratorInfo",
}) as any as S.Schema<InferenceAcceleratorInfo>;
export type BootModeType = "legacy-bios" | "uefi" | (string & {});
export const BootModeType = S.String;
export type BootModeTypeList = BootModeType[];
export const BootModeTypeList = S.Array(BootModeType.pipe(T.XmlName("item")));
export type NitroEnclavesSupport = "unsupported" | "supported" | (string & {});
export const NitroEnclavesSupport = S.String;
export type NitroTpmSupport = "unsupported" | "supported" | (string & {});
export const NitroTpmSupport = S.String;
export type NitroTpmSupportedVersionsList = string[];
export const NitroTpmSupportedVersionsList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface NitroTpmInfo {
  SupportedVersions?: string[];
}
export const NitroTpmInfo = S.suspend(() =>
  S.Struct({
    SupportedVersions: S.optional(NitroTpmSupportedVersionsList).pipe(
      T.XmlName("supportedVersions"),
      T.Ec2QueryName("SupportedVersions"),
    ),
  }),
).annotate({ identifier: "NitroTpmInfo" }) as any as S.Schema<NitroTpmInfo>;
export interface MediaDeviceMemoryInfo {
  SizeInMiB?: number;
}
export const MediaDeviceMemoryInfo = S.suspend(() =>
  S.Struct({
    SizeInMiB: S.optional(S.Number).pipe(
      T.XmlName("sizeInMiB"),
      T.Ec2QueryName("SizeInMiB"),
    ),
  }),
).annotate({
  identifier: "MediaDeviceMemoryInfo",
}) as any as S.Schema<MediaDeviceMemoryInfo>;
export interface MediaDeviceInfo {
  Count?: number;
  Name?: string;
  Manufacturer?: string;
  MemoryInfo?: MediaDeviceMemoryInfo;
}
export const MediaDeviceInfo = S.suspend(() =>
  S.Struct({
    Count: S.optional(S.Number).pipe(
      T.XmlName("count"),
      T.Ec2QueryName("Count"),
    ),
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
    Manufacturer: S.optional(S.String).pipe(
      T.XmlName("manufacturer"),
      T.Ec2QueryName("Manufacturer"),
    ),
    MemoryInfo: S.optional(MediaDeviceMemoryInfo)
      .pipe(T.XmlName("memoryInfo"), T.Ec2QueryName("MemoryInfo"))
      .annotate({ identifier: "MediaDeviceMemoryInfo" }),
  }),
).annotate({
  identifier: "MediaDeviceInfo",
}) as any as S.Schema<MediaDeviceInfo>;
export type MediaDeviceInfoList = MediaDeviceInfo[];
export const MediaDeviceInfoList = S.Array(
  MediaDeviceInfo.pipe(T.XmlName("item")).annotate({
    identifier: "MediaDeviceInfo",
  }),
);
export interface MediaAcceleratorInfo {
  Accelerators?: MediaDeviceInfo[];
  TotalMediaMemoryInMiB?: number;
}
export const MediaAcceleratorInfo = S.suspend(() =>
  S.Struct({
    Accelerators: S.optional(MediaDeviceInfoList).pipe(
      T.XmlName("accelerators"),
      T.Ec2QueryName("Accelerators"),
    ),
    TotalMediaMemoryInMiB: S.optional(S.Number).pipe(
      T.XmlName("totalMediaMemoryInMiB"),
      T.Ec2QueryName("TotalMediaMemoryInMiB"),
    ),
  }),
).annotate({
  identifier: "MediaAcceleratorInfo",
}) as any as S.Schema<MediaAcceleratorInfo>;
export interface NeuronDeviceCoreInfo {
  Count?: number;
  Version?: number;
}
export const NeuronDeviceCoreInfo = S.suspend(() =>
  S.Struct({
    Count: S.optional(S.Number).pipe(
      T.XmlName("count"),
      T.Ec2QueryName("Count"),
    ),
    Version: S.optional(S.Number).pipe(
      T.XmlName("version"),
      T.Ec2QueryName("Version"),
    ),
  }),
).annotate({
  identifier: "NeuronDeviceCoreInfo",
}) as any as S.Schema<NeuronDeviceCoreInfo>;
export interface NeuronDeviceMemoryInfo {
  SizeInMiB?: number;
}
export const NeuronDeviceMemoryInfo = S.suspend(() =>
  S.Struct({
    SizeInMiB: S.optional(S.Number).pipe(
      T.XmlName("sizeInMiB"),
      T.Ec2QueryName("SizeInMiB"),
    ),
  }),
).annotate({
  identifier: "NeuronDeviceMemoryInfo",
}) as any as S.Schema<NeuronDeviceMemoryInfo>;
export interface NeuronDeviceInfo {
  Count?: number;
  Name?: string;
  CoreInfo?: NeuronDeviceCoreInfo;
  MemoryInfo?: NeuronDeviceMemoryInfo;
}
export const NeuronDeviceInfo = S.suspend(() =>
  S.Struct({
    Count: S.optional(S.Number).pipe(
      T.XmlName("count"),
      T.Ec2QueryName("Count"),
    ),
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
    CoreInfo: S.optional(NeuronDeviceCoreInfo)
      .pipe(T.XmlName("coreInfo"), T.Ec2QueryName("CoreInfo"))
      .annotate({ identifier: "NeuronDeviceCoreInfo" }),
    MemoryInfo: S.optional(NeuronDeviceMemoryInfo)
      .pipe(T.XmlName("memoryInfo"), T.Ec2QueryName("MemoryInfo"))
      .annotate({ identifier: "NeuronDeviceMemoryInfo" }),
  }),
).annotate({
  identifier: "NeuronDeviceInfo",
}) as any as S.Schema<NeuronDeviceInfo>;
export type NeuronDeviceInfoList = NeuronDeviceInfo[];
export const NeuronDeviceInfoList = S.Array(
  NeuronDeviceInfo.pipe(T.XmlName("item")).annotate({
    identifier: "NeuronDeviceInfo",
  }),
);
export interface NeuronInfo {
  NeuronDevices?: NeuronDeviceInfo[];
  TotalNeuronDeviceMemoryInMiB?: number;
}
export const NeuronInfo = S.suspend(() =>
  S.Struct({
    NeuronDevices: S.optional(NeuronDeviceInfoList).pipe(
      T.XmlName("neuronDevices"),
      T.Ec2QueryName("NeuronDevices"),
    ),
    TotalNeuronDeviceMemoryInMiB: S.optional(S.Number).pipe(
      T.XmlName("totalNeuronDeviceMemoryInMiB"),
      T.Ec2QueryName("TotalNeuronDeviceMemoryInMiB"),
    ),
  }),
).annotate({ identifier: "NeuronInfo" }) as any as S.Schema<NeuronInfo>;
export type PhcSupport = "unsupported" | "supported" | (string & {});
export const PhcSupport = S.String;
export type RebootMigrationSupport =
  | "unsupported"
  | "supported"
  | (string & {});
export const RebootMigrationSupport = S.String;
export interface InstanceTypeInfo {
  InstanceType?: InstanceType;
  CurrentGeneration?: boolean;
  FreeTierEligible?: boolean;
  SupportedUsageClasses?: UsageClassType[];
  SupportedRootDeviceTypes?: RootDeviceType[];
  SupportedVirtualizationTypes?: VirtualizationType[];
  BareMetal?: boolean;
  Hypervisor?: InstanceTypeHypervisor;
  ProcessorInfo?: ProcessorInfo;
  VCpuInfo?: VCpuInfo;
  MemoryInfo?: MemoryInfo;
  InstanceStorageSupported?: boolean;
  InstanceStorageInfo?: InstanceStorageInfo;
  EbsInfo?: EbsInfo;
  NetworkInfo?: NetworkInfo;
  GpuInfo?: GpuInfo;
  FpgaInfo?: FpgaInfo;
  PlacementGroupInfo?: PlacementGroupInfo;
  InferenceAcceleratorInfo?: InferenceAcceleratorInfo;
  HibernationSupported?: boolean;
  BurstablePerformanceSupported?: boolean;
  DedicatedHostsSupported?: boolean;
  AutoRecoverySupported?: boolean;
  SupportedBootModes?: BootModeType[];
  NitroEnclavesSupport?: NitroEnclavesSupport;
  NitroTpmSupport?: NitroTpmSupport;
  NitroTpmInfo?: NitroTpmInfo;
  MediaAcceleratorInfo?: MediaAcceleratorInfo;
  NeuronInfo?: NeuronInfo;
  PhcSupport?: PhcSupport;
  RebootMigrationSupport?: RebootMigrationSupport;
}
export const InstanceTypeInfo = S.suspend(() =>
  S.Struct({
    InstanceType: S.optional(InstanceType).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    CurrentGeneration: S.optional(S.Boolean).pipe(
      T.XmlName("currentGeneration"),
      T.Ec2QueryName("CurrentGeneration"),
    ),
    FreeTierEligible: S.optional(S.Boolean).pipe(
      T.XmlName("freeTierEligible"),
      T.Ec2QueryName("FreeTierEligible"),
    ),
    SupportedUsageClasses: S.optional(UsageClassTypeList).pipe(
      T.XmlName("supportedUsageClasses"),
      T.Ec2QueryName("SupportedUsageClasses"),
    ),
    SupportedRootDeviceTypes: S.optional(RootDeviceTypeList).pipe(
      T.XmlName("supportedRootDeviceTypes"),
      T.Ec2QueryName("SupportedRootDeviceTypes"),
    ),
    SupportedVirtualizationTypes: S.optional(VirtualizationTypeList).pipe(
      T.XmlName("supportedVirtualizationTypes"),
      T.Ec2QueryName("SupportedVirtualizationTypes"),
    ),
    BareMetal: S.optional(S.Boolean).pipe(
      T.XmlName("bareMetal"),
      T.Ec2QueryName("BareMetal"),
    ),
    Hypervisor: S.optional(InstanceTypeHypervisor).pipe(
      T.XmlName("hypervisor"),
      T.Ec2QueryName("Hypervisor"),
    ),
    ProcessorInfo: S.optional(ProcessorInfo)
      .pipe(T.XmlName("processorInfo"), T.Ec2QueryName("ProcessorInfo"))
      .annotate({ identifier: "ProcessorInfo" }),
    VCpuInfo: S.optional(VCpuInfo)
      .pipe(T.XmlName("vCpuInfo"), T.Ec2QueryName("VCpuInfo"))
      .annotate({ identifier: "VCpuInfo" }),
    MemoryInfo: S.optional(MemoryInfo)
      .pipe(T.XmlName("memoryInfo"), T.Ec2QueryName("MemoryInfo"))
      .annotate({ identifier: "MemoryInfo" }),
    InstanceStorageSupported: S.optional(S.Boolean).pipe(
      T.XmlName("instanceStorageSupported"),
      T.Ec2QueryName("InstanceStorageSupported"),
    ),
    InstanceStorageInfo: S.optional(InstanceStorageInfo)
      .pipe(
        T.XmlName("instanceStorageInfo"),
        T.Ec2QueryName("InstanceStorageInfo"),
      )
      .annotate({ identifier: "InstanceStorageInfo" }),
    EbsInfo: S.optional(EbsInfo)
      .pipe(T.XmlName("ebsInfo"), T.Ec2QueryName("EbsInfo"))
      .annotate({ identifier: "EbsInfo" }),
    NetworkInfo: S.optional(NetworkInfo)
      .pipe(T.XmlName("networkInfo"), T.Ec2QueryName("NetworkInfo"))
      .annotate({ identifier: "NetworkInfo" }),
    GpuInfo: S.optional(GpuInfo)
      .pipe(T.XmlName("gpuInfo"), T.Ec2QueryName("GpuInfo"))
      .annotate({ identifier: "GpuInfo" }),
    FpgaInfo: S.optional(FpgaInfo)
      .pipe(T.XmlName("fpgaInfo"), T.Ec2QueryName("FpgaInfo"))
      .annotate({ identifier: "FpgaInfo" }),
    PlacementGroupInfo: S.optional(PlacementGroupInfo)
      .pipe(
        T.XmlName("placementGroupInfo"),
        T.Ec2QueryName("PlacementGroupInfo"),
      )
      .annotate({ identifier: "PlacementGroupInfo" }),
    InferenceAcceleratorInfo: S.optional(InferenceAcceleratorInfo)
      .pipe(
        T.XmlName("inferenceAcceleratorInfo"),
        T.Ec2QueryName("InferenceAcceleratorInfo"),
      )
      .annotate({ identifier: "InferenceAcceleratorInfo" }),
    HibernationSupported: S.optional(S.Boolean).pipe(
      T.XmlName("hibernationSupported"),
      T.Ec2QueryName("HibernationSupported"),
    ),
    BurstablePerformanceSupported: S.optional(S.Boolean).pipe(
      T.XmlName("burstablePerformanceSupported"),
      T.Ec2QueryName("BurstablePerformanceSupported"),
    ),
    DedicatedHostsSupported: S.optional(S.Boolean).pipe(
      T.XmlName("dedicatedHostsSupported"),
      T.Ec2QueryName("DedicatedHostsSupported"),
    ),
    AutoRecoverySupported: S.optional(S.Boolean).pipe(
      T.XmlName("autoRecoverySupported"),
      T.Ec2QueryName("AutoRecoverySupported"),
    ),
    SupportedBootModes: S.optional(BootModeTypeList).pipe(
      T.XmlName("supportedBootModes"),
      T.Ec2QueryName("SupportedBootModes"),
    ),
    NitroEnclavesSupport: S.optional(NitroEnclavesSupport).pipe(
      T.XmlName("nitroEnclavesSupport"),
      T.Ec2QueryName("NitroEnclavesSupport"),
    ),
    NitroTpmSupport: S.optional(NitroTpmSupport).pipe(
      T.XmlName("nitroTpmSupport"),
      T.Ec2QueryName("NitroTpmSupport"),
    ),
    NitroTpmInfo: S.optional(NitroTpmInfo)
      .pipe(T.XmlName("nitroTpmInfo"), T.Ec2QueryName("NitroTpmInfo"))
      .annotate({ identifier: "NitroTpmInfo" }),
    MediaAcceleratorInfo: S.optional(MediaAcceleratorInfo)
      .pipe(
        T.XmlName("mediaAcceleratorInfo"),
        T.Ec2QueryName("MediaAcceleratorInfo"),
      )
      .annotate({ identifier: "MediaAcceleratorInfo" }),
    NeuronInfo: S.optional(NeuronInfo)
      .pipe(T.XmlName("neuronInfo"), T.Ec2QueryName("NeuronInfo"))
      .annotate({ identifier: "NeuronInfo" }),
    PhcSupport: S.optional(PhcSupport).pipe(
      T.XmlName("phcSupport"),
      T.Ec2QueryName("PhcSupport"),
    ),
    RebootMigrationSupport: S.optional(RebootMigrationSupport).pipe(
      T.XmlName("rebootMigrationSupport"),
      T.Ec2QueryName("RebootMigrationSupport"),
    ),
  }),
).annotate({
  identifier: "InstanceTypeInfo",
}) as any as S.Schema<InstanceTypeInfo>;
export type InstanceTypeInfoList = InstanceTypeInfo[];
export const InstanceTypeInfoList = S.Array(
  InstanceTypeInfo.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceTypeInfo",
  }),
);
export interface DescribeInstanceTypesResult {
  InstanceTypes?: InstanceTypeInfo[];
  NextToken?: string;
}
export const DescribeInstanceTypesResult = S.suspend(() =>
  S.Struct({
    InstanceTypes: S.optional(InstanceTypeInfoList).pipe(
      T.XmlName("instanceTypeSet"),
      T.Ec2QueryName("InstanceTypeSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeInstanceTypesResult",
}) as any as S.Schema<DescribeInstanceTypesResult>;
export type InternetGatewayIdList = string[];
export const InternetGatewayIdList = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeInternetGatewaysRequest {
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
  InternetGatewayIds?: string[];
  Filters?: Filter[];
}
export const DescribeInternetGatewaysRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    InternetGatewayIds: S.optional(InternetGatewayIdList).pipe(
      T.XmlName("internetGatewayId"),
      T.Ec2QueryName("InternetGatewayId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInternetGatewaysRequest",
}) as any as S.Schema<DescribeInternetGatewaysRequest>;
export type InternetGatewayList = InternetGateway[];
export const InternetGatewayList = S.Array(
  InternetGateway.pipe(T.XmlName("item")).annotate({
    identifier: "InternetGateway",
  }),
);
export interface DescribeInternetGatewaysResult {
  InternetGateways?: InternetGateway[];
  NextToken?: string;
}
export const DescribeInternetGatewaysResult = S.suspend(() =>
  S.Struct({
    InternetGateways: S.optional(InternetGatewayList).pipe(
      T.XmlName("internetGatewaySet"),
      T.Ec2QueryName("InternetGatewaySet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeInternetGatewaysResult",
}) as any as S.Schema<DescribeInternetGatewaysResult>;
export interface DescribeIpamByoasnRequest {
  DryRun?: boolean;
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeIpamByoasnRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeIpamByoasnRequest",
}) as any as S.Schema<DescribeIpamByoasnRequest>;
export type ByoasnSet = Byoasn[];
export const ByoasnSet = S.Array(
  Byoasn.pipe(T.XmlName("item")).annotate({ identifier: "Byoasn" }),
);
export interface DescribeIpamByoasnResult {
  Byoasns?: Byoasn[];
  NextToken?: string;
}
export const DescribeIpamByoasnResult = S.suspend(() =>
  S.Struct({
    Byoasns: S.optional(ByoasnSet).pipe(
      T.XmlName("byoasnSet"),
      T.Ec2QueryName("ByoasnSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeIpamByoasnResult",
}) as any as S.Schema<DescribeIpamByoasnResult>;
export interface DescribeIpamExternalResourceVerificationTokensRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
  IpamExternalResourceVerificationTokenIds?: string[];
}
export const DescribeIpamExternalResourceVerificationTokensRequest = S.suspend(
  () =>
    S.Struct({
      DryRun: S.optional(S.Boolean),
      Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
      NextToken: S.optional(S.String),
      MaxResults: S.optional(S.Number),
      IpamExternalResourceVerificationTokenIds: S.optional(
        ValueStringList,
      ).pipe(T.XmlName("IpamExternalResourceVerificationTokenId")),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "DescribeIpamExternalResourceVerificationTokensRequest",
}) as any as S.Schema<DescribeIpamExternalResourceVerificationTokensRequest>;
export type IpamExternalResourceVerificationTokenSet =
  IpamExternalResourceVerificationToken[];
export const IpamExternalResourceVerificationTokenSet = S.Array(
  IpamExternalResourceVerificationToken.pipe(T.XmlName("item")).annotate({
    identifier: "IpamExternalResourceVerificationToken",
  }),
);
export interface DescribeIpamExternalResourceVerificationTokensResult {
  NextToken?: string;
  IpamExternalResourceVerificationTokens?: IpamExternalResourceVerificationToken[];
}
export const DescribeIpamExternalResourceVerificationTokensResult = S.suspend(
  () =>
    S.Struct({
      NextToken: S.optional(S.String).pipe(
        T.XmlName("nextToken"),
        T.Ec2QueryName("NextToken"),
      ),
      IpamExternalResourceVerificationTokens: S.optional(
        IpamExternalResourceVerificationTokenSet,
      ).pipe(
        T.XmlName("ipamExternalResourceVerificationTokenSet"),
        T.Ec2QueryName("IpamExternalResourceVerificationTokenSet"),
      ),
    }).pipe(ns),
).annotate({
  identifier: "DescribeIpamExternalResourceVerificationTokensResult",
}) as any as S.Schema<DescribeIpamExternalResourceVerificationTokensResult>;
export interface DescribeIpamPoliciesRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  IpamPolicyIds?: string[];
}
export const DescribeIpamPoliciesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    IpamPolicyIds: S.optional(ValueStringList).pipe(T.XmlName("IpamPolicyId")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeIpamPoliciesRequest",
}) as any as S.Schema<DescribeIpamPoliciesRequest>;
export type IpamPolicySet = IpamPolicy[];
export const IpamPolicySet = S.Array(
  IpamPolicy.pipe(T.XmlName("item")).annotate({ identifier: "IpamPolicy" }),
);
export interface DescribeIpamPoliciesResult {
  NextToken?: string;
  IpamPolicies?: IpamPolicy[];
}
export const DescribeIpamPoliciesResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    IpamPolicies: S.optional(IpamPolicySet).pipe(
      T.XmlName("ipamPolicySet"),
      T.Ec2QueryName("IpamPolicySet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeIpamPoliciesResult",
}) as any as S.Schema<DescribeIpamPoliciesResult>;
export interface DescribeIpamPoolsRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  IpamPoolIds?: string[];
}
export const DescribeIpamPoolsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    IpamPoolIds: S.optional(ValueStringList).pipe(T.XmlName("IpamPoolId")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeIpamPoolsRequest",
}) as any as S.Schema<DescribeIpamPoolsRequest>;
export type IpamPoolSet = IpamPool[];
export const IpamPoolSet = S.Array(
  IpamPool.pipe(T.XmlName("item")).annotate({ identifier: "IpamPool" }),
);
export interface DescribeIpamPoolsResult {
  NextToken?: string;
  IpamPools?: IpamPool[];
}
export const DescribeIpamPoolsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    IpamPools: S.optional(IpamPoolSet).pipe(
      T.XmlName("ipamPoolSet"),
      T.Ec2QueryName("IpamPoolSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeIpamPoolsResult",
}) as any as S.Schema<DescribeIpamPoolsResult>;
export interface DescribeIpamPrefixListResolversRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  IpamPrefixListResolverIds?: string[];
}
export const DescribeIpamPrefixListResolversRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    IpamPrefixListResolverIds: S.optional(ValueStringList).pipe(
      T.XmlName("IpamPrefixListResolverId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeIpamPrefixListResolversRequest",
}) as any as S.Schema<DescribeIpamPrefixListResolversRequest>;
export type IpamPrefixListResolverSet = IpamPrefixListResolver[];
export const IpamPrefixListResolverSet = S.Array(
  IpamPrefixListResolver.pipe(T.XmlName("item")).annotate({
    identifier: "IpamPrefixListResolver",
  }),
);
export interface DescribeIpamPrefixListResolversResult {
  NextToken?: string;
  IpamPrefixListResolvers?: IpamPrefixListResolver[];
}
export const DescribeIpamPrefixListResolversResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    IpamPrefixListResolvers: S.optional(IpamPrefixListResolverSet).pipe(
      T.XmlName("ipamPrefixListResolverSet"),
      T.Ec2QueryName("IpamPrefixListResolverSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeIpamPrefixListResolversResult",
}) as any as S.Schema<DescribeIpamPrefixListResolversResult>;
export interface DescribeIpamPrefixListResolverTargetsRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  IpamPrefixListResolverTargetIds?: string[];
  IpamPrefixListResolverId?: string;
}
export const DescribeIpamPrefixListResolverTargetsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    IpamPrefixListResolverTargetIds: S.optional(ValueStringList).pipe(
      T.XmlName("IpamPrefixListResolverTargetId"),
    ),
    IpamPrefixListResolverId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeIpamPrefixListResolverTargetsRequest",
}) as any as S.Schema<DescribeIpamPrefixListResolverTargetsRequest>;
export type IpamPrefixListResolverTargetSet = IpamPrefixListResolverTarget[];
export const IpamPrefixListResolverTargetSet = S.Array(
  IpamPrefixListResolverTarget.pipe(T.XmlName("item")).annotate({
    identifier: "IpamPrefixListResolverTarget",
  }),
);
export interface DescribeIpamPrefixListResolverTargetsResult {
  NextToken?: string;
  IpamPrefixListResolverTargets?: IpamPrefixListResolverTarget[];
}
export const DescribeIpamPrefixListResolverTargetsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    IpamPrefixListResolverTargets: S.optional(
      IpamPrefixListResolverTargetSet,
    ).pipe(
      T.XmlName("ipamPrefixListResolverTargetSet"),
      T.Ec2QueryName("IpamPrefixListResolverTargetSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeIpamPrefixListResolverTargetsResult",
}) as any as S.Schema<DescribeIpamPrefixListResolverTargetsResult>;
export interface DescribeIpamResourceDiscoveriesRequest {
  DryRun?: boolean;
  IpamResourceDiscoveryIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  Filters?: Filter[];
}
export const DescribeIpamResourceDiscoveriesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamResourceDiscoveryIds: S.optional(ValueStringList).pipe(
      T.XmlName("IpamResourceDiscoveryId"),
    ),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeIpamResourceDiscoveriesRequest",
}) as any as S.Schema<DescribeIpamResourceDiscoveriesRequest>;
export type IpamResourceDiscoverySet = IpamResourceDiscovery[];
export const IpamResourceDiscoverySet = S.Array(
  IpamResourceDiscovery.pipe(T.XmlName("item")).annotate({
    identifier: "IpamResourceDiscovery",
  }),
);
export interface DescribeIpamResourceDiscoveriesResult {
  IpamResourceDiscoveries?: IpamResourceDiscovery[];
  NextToken?: string;
}
export const DescribeIpamResourceDiscoveriesResult = S.suspend(() =>
  S.Struct({
    IpamResourceDiscoveries: S.optional(IpamResourceDiscoverySet).pipe(
      T.XmlName("ipamResourceDiscoverySet"),
      T.Ec2QueryName("IpamResourceDiscoverySet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeIpamResourceDiscoveriesResult",
}) as any as S.Schema<DescribeIpamResourceDiscoveriesResult>;
export interface DescribeIpamResourceDiscoveryAssociationsRequest {
  DryRun?: boolean;
  IpamResourceDiscoveryAssociationIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  Filters?: Filter[];
}
export const DescribeIpamResourceDiscoveryAssociationsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamResourceDiscoveryAssociationIds: S.optional(ValueStringList).pipe(
      T.XmlName("IpamResourceDiscoveryAssociationId"),
    ),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeIpamResourceDiscoveryAssociationsRequest",
}) as any as S.Schema<DescribeIpamResourceDiscoveryAssociationsRequest>;
export type IpamResourceDiscoveryAssociationSet =
  IpamResourceDiscoveryAssociation[];
export const IpamResourceDiscoveryAssociationSet = S.Array(
  IpamResourceDiscoveryAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "IpamResourceDiscoveryAssociation",
  }),
);
export interface DescribeIpamResourceDiscoveryAssociationsResult {
  IpamResourceDiscoveryAssociations?: IpamResourceDiscoveryAssociation[];
  NextToken?: string;
}
export const DescribeIpamResourceDiscoveryAssociationsResult = S.suspend(() =>
  S.Struct({
    IpamResourceDiscoveryAssociations: S.optional(
      IpamResourceDiscoveryAssociationSet,
    ).pipe(
      T.XmlName("ipamResourceDiscoveryAssociationSet"),
      T.Ec2QueryName("IpamResourceDiscoveryAssociationSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeIpamResourceDiscoveryAssociationsResult",
}) as any as S.Schema<DescribeIpamResourceDiscoveryAssociationsResult>;
export interface DescribeIpamsRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  IpamIds?: string[];
}
export const DescribeIpamsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    IpamIds: S.optional(ValueStringList).pipe(T.XmlName("IpamId")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeIpamsRequest",
}) as any as S.Schema<DescribeIpamsRequest>;
export type IpamSet = Ipam[];
export const IpamSet = S.Array(
  Ipam.pipe(T.XmlName("item")).annotate({ identifier: "Ipam" }),
);
export interface DescribeIpamsResult {
  NextToken?: string;
  Ipams?: Ipam[];
}
export const DescribeIpamsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    Ipams: S.optional(IpamSet).pipe(
      T.XmlName("ipamSet"),
      T.Ec2QueryName("IpamSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeIpamsResult",
}) as any as S.Schema<DescribeIpamsResult>;
export interface DescribeIpamScopesRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  IpamScopeIds?: string[];
}
export const DescribeIpamScopesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    IpamScopeIds: S.optional(ValueStringList).pipe(T.XmlName("IpamScopeId")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeIpamScopesRequest",
}) as any as S.Schema<DescribeIpamScopesRequest>;
export type IpamScopeSet = IpamScope[];
export const IpamScopeSet = S.Array(
  IpamScope.pipe(T.XmlName("item")).annotate({ identifier: "IpamScope" }),
);
export interface DescribeIpamScopesResult {
  NextToken?: string;
  IpamScopes?: IpamScope[];
}
export const DescribeIpamScopesResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    IpamScopes: S.optional(IpamScopeSet).pipe(
      T.XmlName("ipamScopeSet"),
      T.Ec2QueryName("IpamScopeSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeIpamScopesResult",
}) as any as S.Schema<DescribeIpamScopesResult>;
export type Ipv6PoolIdList = string[];
export const Ipv6PoolIdList = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeIpv6PoolsRequest {
  PoolIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
  Filters?: Filter[];
}
export const DescribeIpv6PoolsRequest = S.suspend(() =>
  S.Struct({
    PoolIds: S.optional(Ipv6PoolIdList).pipe(T.XmlName("PoolId")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeIpv6PoolsRequest",
}) as any as S.Schema<DescribeIpv6PoolsRequest>;
export interface PoolCidrBlock {
  Cidr?: string;
}
export const PoolCidrBlock = S.suspend(() =>
  S.Struct({
    Cidr: S.optional(S.String).pipe(
      T.XmlName("poolCidrBlock"),
      T.Ec2QueryName("PoolCidrBlock"),
    ),
  }),
).annotate({ identifier: "PoolCidrBlock" }) as any as S.Schema<PoolCidrBlock>;
export type PoolCidrBlocksSet = PoolCidrBlock[];
export const PoolCidrBlocksSet = S.Array(
  PoolCidrBlock.pipe(T.XmlName("item")).annotate({
    identifier: "PoolCidrBlock",
  }),
);
export interface Ipv6Pool {
  PoolId?: string;
  Description?: string;
  PoolCidrBlocks?: PoolCidrBlock[];
  Tags?: Tag[];
}
export const Ipv6Pool = S.suspend(() =>
  S.Struct({
    PoolId: S.optional(S.String).pipe(
      T.XmlName("poolId"),
      T.Ec2QueryName("PoolId"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    PoolCidrBlocks: S.optional(PoolCidrBlocksSet).pipe(
      T.XmlName("poolCidrBlockSet"),
      T.Ec2QueryName("PoolCidrBlockSet"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({ identifier: "Ipv6Pool" }) as any as S.Schema<Ipv6Pool>;
export type Ipv6PoolSet = Ipv6Pool[];
export const Ipv6PoolSet = S.Array(
  Ipv6Pool.pipe(T.XmlName("item")).annotate({ identifier: "Ipv6Pool" }),
);
export interface DescribeIpv6PoolsResult {
  Ipv6Pools?: Ipv6Pool[];
  NextToken?: string;
}
export const DescribeIpv6PoolsResult = S.suspend(() =>
  S.Struct({
    Ipv6Pools: S.optional(Ipv6PoolSet).pipe(
      T.XmlName("ipv6PoolSet"),
      T.Ec2QueryName("Ipv6PoolSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeIpv6PoolsResult",
}) as any as S.Schema<DescribeIpv6PoolsResult>;
export type KeyNameStringList = string[];
export const KeyNameStringList = S.Array(S.String.pipe(T.XmlName("KeyName")));
export type KeyPairIdStringList = string[];
export const KeyPairIdStringList = S.Array(
  S.String.pipe(T.XmlName("KeyPairId")),
);
export interface DescribeKeyPairsRequest {
  KeyNames?: string[];
  KeyPairIds?: string[];
  IncludePublicKey?: boolean;
  DryRun?: boolean;
  Filters?: Filter[];
}
export const DescribeKeyPairsRequest = S.suspend(() =>
  S.Struct({
    KeyNames: S.optional(KeyNameStringList).pipe(T.XmlName("KeyName")),
    KeyPairIds: S.optional(KeyPairIdStringList).pipe(T.XmlName("KeyPairId")),
    IncludePublicKey: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeKeyPairsRequest",
}) as any as S.Schema<DescribeKeyPairsRequest>;
export interface KeyPairInfo {
  KeyPairId?: string;
  KeyType?: KeyType;
  Tags?: Tag[];
  PublicKey?: string;
  CreateTime?: Date;
  KeyName?: string;
  KeyFingerprint?: string;
}
export const KeyPairInfo = S.suspend(() =>
  S.Struct({
    KeyPairId: S.optional(S.String).pipe(
      T.XmlName("keyPairId"),
      T.Ec2QueryName("KeyPairId"),
    ),
    KeyType: S.optional(KeyType).pipe(
      T.XmlName("keyType"),
      T.Ec2QueryName("KeyType"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    PublicKey: S.optional(S.String).pipe(
      T.XmlName("publicKey"),
      T.Ec2QueryName("PublicKey"),
    ),
    CreateTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createTime"), T.Ec2QueryName("CreateTime")),
    KeyName: S.optional(S.String).pipe(
      T.XmlName("keyName"),
      T.Ec2QueryName("KeyName"),
    ),
    KeyFingerprint: S.optional(S.String).pipe(
      T.XmlName("keyFingerprint"),
      T.Ec2QueryName("KeyFingerprint"),
    ),
  }),
).annotate({ identifier: "KeyPairInfo" }) as any as S.Schema<KeyPairInfo>;
export type KeyPairList = KeyPairInfo[];
export const KeyPairList = S.Array(
  KeyPairInfo.pipe(T.XmlName("item")).annotate({ identifier: "KeyPairInfo" }),
);
export interface DescribeKeyPairsResult {
  KeyPairs?: KeyPairInfo[];
}
export const DescribeKeyPairsResult = S.suspend(() =>
  S.Struct({
    KeyPairs: S.optional(KeyPairList).pipe(
      T.XmlName("keySet"),
      T.Ec2QueryName("KeySet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeKeyPairsResult",
}) as any as S.Schema<DescribeKeyPairsResult>;
export type LaunchTemplateIdStringList = string[];
export const LaunchTemplateIdStringList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export type LaunchTemplateNameStringList = string[];
export const LaunchTemplateNameStringList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeLaunchTemplatesRequest {
  DryRun?: boolean;
  LaunchTemplateIds?: string[];
  LaunchTemplateNames?: string[];
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeLaunchTemplatesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    LaunchTemplateIds: S.optional(LaunchTemplateIdStringList).pipe(
      T.XmlName("LaunchTemplateId"),
    ),
    LaunchTemplateNames: S.optional(LaunchTemplateNameStringList).pipe(
      T.XmlName("LaunchTemplateName"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeLaunchTemplatesRequest",
}) as any as S.Schema<DescribeLaunchTemplatesRequest>;
export type LaunchTemplateSet = LaunchTemplate[];
export const LaunchTemplateSet = S.Array(
  LaunchTemplate.pipe(T.XmlName("item")).annotate({
    identifier: "LaunchTemplate",
  }),
);
export interface DescribeLaunchTemplatesResult {
  LaunchTemplates?: LaunchTemplate[];
  NextToken?: string;
}
export const DescribeLaunchTemplatesResult = S.suspend(() =>
  S.Struct({
    LaunchTemplates: S.optional(LaunchTemplateSet).pipe(
      T.XmlName("launchTemplates"),
      T.Ec2QueryName("LaunchTemplates"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeLaunchTemplatesResult",
}) as any as S.Schema<DescribeLaunchTemplatesResult>;
export interface DescribeLaunchTemplateVersionsRequest {
  DryRun?: boolean;
  LaunchTemplateId?: string;
  LaunchTemplateName?: string;
  Versions?: string[];
  MinVersion?: string;
  MaxVersion?: string;
  NextToken?: string;
  MaxResults?: number;
  Filters?: Filter[];
  ResolveAlias?: boolean;
}
export const DescribeLaunchTemplateVersionsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    LaunchTemplateId: S.optional(S.String),
    LaunchTemplateName: S.optional(S.String),
    Versions: S.optional(VersionStringList).pipe(
      T.XmlName("LaunchTemplateVersion"),
    ),
    MinVersion: S.optional(S.String),
    MaxVersion: S.optional(S.String),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    ResolveAlias: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeLaunchTemplateVersionsRequest",
}) as any as S.Schema<DescribeLaunchTemplateVersionsRequest>;
export type LaunchTemplateVersionSet = LaunchTemplateVersion[];
export const LaunchTemplateVersionSet = S.Array(
  LaunchTemplateVersion.pipe(T.XmlName("item")).annotate({
    identifier: "LaunchTemplateVersion",
  }),
);
export interface DescribeLaunchTemplateVersionsResult {
  LaunchTemplateVersions?: LaunchTemplateVersion[];
  NextToken?: string;
}
export const DescribeLaunchTemplateVersionsResult = S.suspend(() =>
  S.Struct({
    LaunchTemplateVersions: S.optional(LaunchTemplateVersionSet).pipe(
      T.XmlName("launchTemplateVersionSet"),
      T.Ec2QueryName("LaunchTemplateVersionSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeLaunchTemplateVersionsResult",
}) as any as S.Schema<DescribeLaunchTemplateVersionsResult>;
export type LocalGatewayRouteTableIdSet = string[];
export const LocalGatewayRouteTableIdSet = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeLocalGatewayRouteTablesRequest {
  LocalGatewayRouteTableIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeLocalGatewayRouteTablesRequest = S.suspend(() =>
  S.Struct({
    LocalGatewayRouteTableIds: S.optional(LocalGatewayRouteTableIdSet).pipe(
      T.XmlName("LocalGatewayRouteTableId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeLocalGatewayRouteTablesRequest",
}) as any as S.Schema<DescribeLocalGatewayRouteTablesRequest>;
export type LocalGatewayRouteTableSet = LocalGatewayRouteTable[];
export const LocalGatewayRouteTableSet = S.Array(
  LocalGatewayRouteTable.pipe(T.XmlName("item")).annotate({
    identifier: "LocalGatewayRouteTable",
  }),
);
export interface DescribeLocalGatewayRouteTablesResult {
  LocalGatewayRouteTables?: LocalGatewayRouteTable[];
  NextToken?: string;
}
export const DescribeLocalGatewayRouteTablesResult = S.suspend(() =>
  S.Struct({
    LocalGatewayRouteTables: S.optional(LocalGatewayRouteTableSet).pipe(
      T.XmlName("localGatewayRouteTableSet"),
      T.Ec2QueryName("LocalGatewayRouteTableSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeLocalGatewayRouteTablesResult",
}) as any as S.Schema<DescribeLocalGatewayRouteTablesResult>;
export type LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet =
  string[];
export const LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet =
  S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest {
  LocalGatewayRouteTableVirtualInterfaceGroupAssociationIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest =
  S.suspend(() =>
    S.Struct({
      LocalGatewayRouteTableVirtualInterfaceGroupAssociationIds: S.optional(
        LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet,
      ).pipe(
        T.XmlName("LocalGatewayRouteTableVirtualInterfaceGroupAssociationId"),
      ),
      Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
      MaxResults: S.optional(S.Number),
      NextToken: S.optional(S.String),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
  ).annotate({
    identifier:
      "DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest",
  }) as any as S.Schema<DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest>;
export type LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet =
  LocalGatewayRouteTableVirtualInterfaceGroupAssociation[];
export const LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet =
  S.Array(
    LocalGatewayRouteTableVirtualInterfaceGroupAssociation.pipe(
      T.XmlName("item"),
    ).annotate({
      identifier: "LocalGatewayRouteTableVirtualInterfaceGroupAssociation",
    }),
  );
export interface DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult {
  LocalGatewayRouteTableVirtualInterfaceGroupAssociations?: LocalGatewayRouteTableVirtualInterfaceGroupAssociation[];
  NextToken?: string;
}
export const DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult =
  S.suspend(() =>
    S.Struct({
      LocalGatewayRouteTableVirtualInterfaceGroupAssociations: S.optional(
        LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet,
      ).pipe(
        T.XmlName("localGatewayRouteTableVirtualInterfaceGroupAssociationSet"),
        T.Ec2QueryName(
          "LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet",
        ),
      ),
      NextToken: S.optional(S.String).pipe(
        T.XmlName("nextToken"),
        T.Ec2QueryName("NextToken"),
      ),
    }).pipe(ns),
  ).annotate({
    identifier:
      "DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult",
  }) as any as S.Schema<DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult>;
export type LocalGatewayRouteTableVpcAssociationIdSet = string[];
export const LocalGatewayRouteTableVpcAssociationIdSet = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeLocalGatewayRouteTableVpcAssociationsRequest {
  LocalGatewayRouteTableVpcAssociationIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeLocalGatewayRouteTableVpcAssociationsRequest = S.suspend(
  () =>
    S.Struct({
      LocalGatewayRouteTableVpcAssociationIds: S.optional(
        LocalGatewayRouteTableVpcAssociationIdSet,
      ).pipe(T.XmlName("LocalGatewayRouteTableVpcAssociationId")),
      Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
      MaxResults: S.optional(S.Number),
      NextToken: S.optional(S.String),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "DescribeLocalGatewayRouteTableVpcAssociationsRequest",
}) as any as S.Schema<DescribeLocalGatewayRouteTableVpcAssociationsRequest>;
export type LocalGatewayRouteTableVpcAssociationSet =
  LocalGatewayRouteTableVpcAssociation[];
export const LocalGatewayRouteTableVpcAssociationSet = S.Array(
  LocalGatewayRouteTableVpcAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "LocalGatewayRouteTableVpcAssociation",
  }),
);
export interface DescribeLocalGatewayRouteTableVpcAssociationsResult {
  LocalGatewayRouteTableVpcAssociations?: LocalGatewayRouteTableVpcAssociation[];
  NextToken?: string;
}
export const DescribeLocalGatewayRouteTableVpcAssociationsResult = S.suspend(
  () =>
    S.Struct({
      LocalGatewayRouteTableVpcAssociations: S.optional(
        LocalGatewayRouteTableVpcAssociationSet,
      ).pipe(
        T.XmlName("localGatewayRouteTableVpcAssociationSet"),
        T.Ec2QueryName("LocalGatewayRouteTableVpcAssociationSet"),
      ),
      NextToken: S.optional(S.String).pipe(
        T.XmlName("nextToken"),
        T.Ec2QueryName("NextToken"),
      ),
    }).pipe(ns),
).annotate({
  identifier: "DescribeLocalGatewayRouteTableVpcAssociationsResult",
}) as any as S.Schema<DescribeLocalGatewayRouteTableVpcAssociationsResult>;
export type LocalGatewayIdSet = string[];
export const LocalGatewayIdSet = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeLocalGatewaysRequest {
  LocalGatewayIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeLocalGatewaysRequest = S.suspend(() =>
  S.Struct({
    LocalGatewayIds: S.optional(LocalGatewayIdSet).pipe(
      T.XmlName("LocalGatewayId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeLocalGatewaysRequest",
}) as any as S.Schema<DescribeLocalGatewaysRequest>;
export interface LocalGateway {
  LocalGatewayId?: string;
  OutpostArn?: string;
  OwnerId?: string;
  State?: string;
  Tags?: Tag[];
}
export const LocalGateway = S.suspend(() =>
  S.Struct({
    LocalGatewayId: S.optional(S.String).pipe(
      T.XmlName("localGatewayId"),
      T.Ec2QueryName("LocalGatewayId"),
    ),
    OutpostArn: S.optional(S.String).pipe(
      T.XmlName("outpostArn"),
      T.Ec2QueryName("OutpostArn"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    State: S.optional(S.String).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({ identifier: "LocalGateway" }) as any as S.Schema<LocalGateway>;
export type LocalGatewaySet = LocalGateway[];
export const LocalGatewaySet = S.Array(
  LocalGateway.pipe(T.XmlName("item")).annotate({ identifier: "LocalGateway" }),
);
export interface DescribeLocalGatewaysResult {
  LocalGateways?: LocalGateway[];
  NextToken?: string;
}
export const DescribeLocalGatewaysResult = S.suspend(() =>
  S.Struct({
    LocalGateways: S.optional(LocalGatewaySet).pipe(
      T.XmlName("localGatewaySet"),
      T.Ec2QueryName("LocalGatewaySet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeLocalGatewaysResult",
}) as any as S.Schema<DescribeLocalGatewaysResult>;
export type LocalGatewayVirtualInterfaceGroupIdSet = string[];
export const LocalGatewayVirtualInterfaceGroupIdSet = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeLocalGatewayVirtualInterfaceGroupsRequest {
  LocalGatewayVirtualInterfaceGroupIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeLocalGatewayVirtualInterfaceGroupsRequest = S.suspend(() =>
  S.Struct({
    LocalGatewayVirtualInterfaceGroupIds: S.optional(
      LocalGatewayVirtualInterfaceGroupIdSet,
    ).pipe(T.XmlName("LocalGatewayVirtualInterfaceGroupId")),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeLocalGatewayVirtualInterfaceGroupsRequest",
}) as any as S.Schema<DescribeLocalGatewayVirtualInterfaceGroupsRequest>;
export type LocalGatewayVirtualInterfaceGroupSet =
  LocalGatewayVirtualInterfaceGroup[];
export const LocalGatewayVirtualInterfaceGroupSet = S.Array(
  LocalGatewayVirtualInterfaceGroup.pipe(T.XmlName("item")).annotate({
    identifier: "LocalGatewayVirtualInterfaceGroup",
  }),
);
export interface DescribeLocalGatewayVirtualInterfaceGroupsResult {
  LocalGatewayVirtualInterfaceGroups?: LocalGatewayVirtualInterfaceGroup[];
  NextToken?: string;
}
export const DescribeLocalGatewayVirtualInterfaceGroupsResult = S.suspend(() =>
  S.Struct({
    LocalGatewayVirtualInterfaceGroups: S.optional(
      LocalGatewayVirtualInterfaceGroupSet,
    ).pipe(
      T.XmlName("localGatewayVirtualInterfaceGroupSet"),
      T.Ec2QueryName("LocalGatewayVirtualInterfaceGroupSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeLocalGatewayVirtualInterfaceGroupsResult",
}) as any as S.Schema<DescribeLocalGatewayVirtualInterfaceGroupsResult>;
export interface DescribeLocalGatewayVirtualInterfacesRequest {
  LocalGatewayVirtualInterfaceIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeLocalGatewayVirtualInterfacesRequest = S.suspend(() =>
  S.Struct({
    LocalGatewayVirtualInterfaceIds: S.optional(
      LocalGatewayVirtualInterfaceIdSet,
    ).pipe(T.XmlName("LocalGatewayVirtualInterfaceId")),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeLocalGatewayVirtualInterfacesRequest",
}) as any as S.Schema<DescribeLocalGatewayVirtualInterfacesRequest>;
export type LocalGatewayVirtualInterfaceSet = LocalGatewayVirtualInterface[];
export const LocalGatewayVirtualInterfaceSet = S.Array(
  LocalGatewayVirtualInterface.pipe(T.XmlName("item")).annotate({
    identifier: "LocalGatewayVirtualInterface",
  }),
);
export interface DescribeLocalGatewayVirtualInterfacesResult {
  LocalGatewayVirtualInterfaces?: LocalGatewayVirtualInterface[];
  NextToken?: string;
}
export const DescribeLocalGatewayVirtualInterfacesResult = S.suspend(() =>
  S.Struct({
    LocalGatewayVirtualInterfaces: S.optional(
      LocalGatewayVirtualInterfaceSet,
    ).pipe(
      T.XmlName("localGatewayVirtualInterfaceSet"),
      T.Ec2QueryName("LocalGatewayVirtualInterfaceSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeLocalGatewayVirtualInterfacesResult",
}) as any as S.Schema<DescribeLocalGatewayVirtualInterfacesResult>;
export type SnapshotIdStringList = string[];
export const SnapshotIdStringList = S.Array(
  S.String.pipe(T.XmlName("SnapshotId")),
);
export interface DescribeLockedSnapshotsRequest {
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  SnapshotIds?: string[];
  DryRun?: boolean;
}
export const DescribeLockedSnapshotsRequest = S.suspend(() =>
  S.Struct({
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    SnapshotIds: S.optional(SnapshotIdStringList).pipe(T.XmlName("SnapshotId")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeLockedSnapshotsRequest",
}) as any as S.Schema<DescribeLockedSnapshotsRequest>;
export type LockState =
  | "compliance"
  | "governance"
  | "compliance-cooloff"
  | "expired"
  | (string & {});
export const LockState = S.String;
export interface LockedSnapshotsInfo {
  OwnerId?: string;
  SnapshotId?: string;
  LockState?: LockState;
  LockDuration?: number;
  CoolOffPeriod?: number;
  CoolOffPeriodExpiresOn?: Date;
  LockCreatedOn?: Date;
  LockDurationStartTime?: Date;
  LockExpiresOn?: Date;
}
export const LockedSnapshotsInfo = S.suspend(() =>
  S.Struct({
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    LockState: S.optional(LockState).pipe(
      T.XmlName("lockState"),
      T.Ec2QueryName("LockState"),
    ),
    LockDuration: S.optional(S.Number).pipe(
      T.XmlName("lockDuration"),
      T.Ec2QueryName("LockDuration"),
    ),
    CoolOffPeriod: S.optional(S.Number).pipe(
      T.XmlName("coolOffPeriod"),
      T.Ec2QueryName("CoolOffPeriod"),
    ),
    CoolOffPeriodExpiresOn: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("coolOffPeriodExpiresOn"),
      T.Ec2QueryName("CoolOffPeriodExpiresOn"),
    ),
    LockCreatedOn: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("lockCreatedOn"), T.Ec2QueryName("LockCreatedOn")),
    LockDurationStartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("lockDurationStartTime"),
      T.Ec2QueryName("LockDurationStartTime"),
    ),
    LockExpiresOn: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("lockExpiresOn"), T.Ec2QueryName("LockExpiresOn")),
  }),
).annotate({
  identifier: "LockedSnapshotsInfo",
}) as any as S.Schema<LockedSnapshotsInfo>;
export type LockedSnapshotsInfoList = LockedSnapshotsInfo[];
export const LockedSnapshotsInfoList = S.Array(
  LockedSnapshotsInfo.pipe(T.XmlName("item")).annotate({
    identifier: "LockedSnapshotsInfo",
  }),
);
export interface DescribeLockedSnapshotsResult {
  Snapshots?: LockedSnapshotsInfo[];
  NextToken?: string;
}
export const DescribeLockedSnapshotsResult = S.suspend(() =>
  S.Struct({
    Snapshots: S.optional(LockedSnapshotsInfoList).pipe(
      T.XmlName("snapshotSet"),
      T.Ec2QueryName("SnapshotSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeLockedSnapshotsResult",
}) as any as S.Schema<DescribeLockedSnapshotsResult>;
export interface DescribeMacHostsRequest {
  Filters?: Filter[];
  HostIds?: string[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeMacHostsRequest = S.suspend(() =>
  S.Struct({
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    HostIds: S.optional(RequestHostIdList).pipe(T.XmlName("HostId")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeMacHostsRequest",
}) as any as S.Schema<DescribeMacHostsRequest>;
export type MacOSVersionStringList = string[];
export const MacOSVersionStringList = S.Array(S.String.pipe(T.XmlName("item")));
export interface MacHost {
  HostId?: string;
  MacOSLatestSupportedVersions?: string[];
}
export const MacHost = S.suspend(() =>
  S.Struct({
    HostId: S.optional(S.String).pipe(
      T.XmlName("hostId"),
      T.Ec2QueryName("HostId"),
    ),
    MacOSLatestSupportedVersions: S.optional(MacOSVersionStringList).pipe(
      T.XmlName("macOSLatestSupportedVersionSet"),
      T.Ec2QueryName("MacOSLatestSupportedVersionSet"),
    ),
  }),
).annotate({ identifier: "MacHost" }) as any as S.Schema<MacHost>;
export type MacHostList = MacHost[];
export const MacHostList = S.Array(
  MacHost.pipe(T.XmlName("item")).annotate({ identifier: "MacHost" }),
);
export interface DescribeMacHostsResult {
  MacHosts?: MacHost[];
  NextToken?: string;
}
export const DescribeMacHostsResult = S.suspend(() =>
  S.Struct({
    MacHosts: S.optional(MacHostList).pipe(
      T.XmlName("macHostSet"),
      T.Ec2QueryName("MacHostSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeMacHostsResult",
}) as any as S.Schema<DescribeMacHostsResult>;
export type MacModificationTaskIdList = string[];
export const MacModificationTaskIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeMacModificationTasksRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  MacModificationTaskIds?: string[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeMacModificationTasksRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MacModificationTaskIds: S.optional(MacModificationTaskIdList).pipe(
      T.XmlName("MacModificationTaskId"),
    ),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeMacModificationTasksRequest",
}) as any as S.Schema<DescribeMacModificationTasksRequest>;
export type MacModificationTaskList = MacModificationTask[];
export const MacModificationTaskList = S.Array(
  MacModificationTask.pipe(T.XmlName("item")).annotate({
    identifier: "MacModificationTask",
  }),
);
export interface DescribeMacModificationTasksResult {
  MacModificationTasks?: MacModificationTask[];
  NextToken?: string;
}
export const DescribeMacModificationTasksResult = S.suspend(() =>
  S.Struct({
    MacModificationTasks: S.optional(MacModificationTaskList).pipe(
      T.XmlName("macModificationTaskSet"),
      T.Ec2QueryName("MacModificationTaskSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeMacModificationTasksResult",
}) as any as S.Schema<DescribeMacModificationTasksResult>;
export interface DescribeManagedPrefixListsRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  PrefixListIds?: string[];
}
export const DescribeManagedPrefixListsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    PrefixListIds: S.optional(ValueStringList).pipe(T.XmlName("PrefixListId")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeManagedPrefixListsRequest",
}) as any as S.Schema<DescribeManagedPrefixListsRequest>;
export type ManagedPrefixListSet = ManagedPrefixList[];
export const ManagedPrefixListSet = S.Array(
  ManagedPrefixList.pipe(T.XmlName("item")).annotate({
    identifier: "ManagedPrefixList",
  }),
);
export interface DescribeManagedPrefixListsResult {
  NextToken?: string;
  PrefixLists?: ManagedPrefixList[];
}
export const DescribeManagedPrefixListsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    PrefixLists: S.optional(ManagedPrefixListSet).pipe(
      T.XmlName("prefixListSet"),
      T.Ec2QueryName("PrefixListSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeManagedPrefixListsResult",
}) as any as S.Schema<DescribeManagedPrefixListsResult>;
export interface DescribeMovingAddressesRequest {
  DryRun?: boolean;
  PublicIps?: string[];
  NextToken?: string;
  Filters?: Filter[];
  MaxResults?: number;
}
export const DescribeMovingAddressesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    PublicIps: S.optional(ValueStringList).pipe(
      T.XmlName("publicIp"),
      T.Ec2QueryName("PublicIp"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    Filters: S.optional(FilterList).pipe(
      T.XmlName("filter"),
      T.Ec2QueryName("Filter"),
    ),
    MaxResults: S.optional(S.Number).pipe(
      T.XmlName("maxResults"),
      T.Ec2QueryName("MaxResults"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeMovingAddressesRequest",
}) as any as S.Schema<DescribeMovingAddressesRequest>;
export type MoveStatus = "movingToVpc" | "restoringToClassic" | (string & {});
export const MoveStatus = S.String;
export interface MovingAddressStatus {
  MoveStatus?: MoveStatus;
  PublicIp?: string;
}
export const MovingAddressStatus = S.suspend(() =>
  S.Struct({
    MoveStatus: S.optional(MoveStatus).pipe(
      T.XmlName("moveStatus"),
      T.Ec2QueryName("MoveStatus"),
    ),
    PublicIp: S.optional(S.String).pipe(
      T.XmlName("publicIp"),
      T.Ec2QueryName("PublicIp"),
    ),
  }),
).annotate({
  identifier: "MovingAddressStatus",
}) as any as S.Schema<MovingAddressStatus>;
export type MovingAddressStatusSet = MovingAddressStatus[];
export const MovingAddressStatusSet = S.Array(
  MovingAddressStatus.pipe(T.XmlName("item")).annotate({
    identifier: "MovingAddressStatus",
  }),
);
export interface DescribeMovingAddressesResult {
  MovingAddressStatuses?: MovingAddressStatus[];
  NextToken?: string;
}
export const DescribeMovingAddressesResult = S.suspend(() =>
  S.Struct({
    MovingAddressStatuses: S.optional(MovingAddressStatusSet).pipe(
      T.XmlName("movingAddressStatusSet"),
      T.Ec2QueryName("MovingAddressStatusSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeMovingAddressesResult",
}) as any as S.Schema<DescribeMovingAddressesResult>;
export type NatGatewayIdStringList = string[];
export const NatGatewayIdStringList = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeNatGatewaysRequest {
  DryRun?: boolean;
  Filter?: Filter[];
  MaxResults?: number;
  NatGatewayIds?: string[];
  NextToken?: string;
}
export const DescribeNatGatewaysRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filter: S.optional(FilterList),
    MaxResults: S.optional(S.Number),
    NatGatewayIds: S.optional(NatGatewayIdStringList).pipe(
      T.XmlName("NatGatewayId"),
    ),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeNatGatewaysRequest",
}) as any as S.Schema<DescribeNatGatewaysRequest>;
export type NatGatewayList = NatGateway[];
export const NatGatewayList = S.Array(
  NatGateway.pipe(T.XmlName("item")).annotate({ identifier: "NatGateway" }),
);
export interface DescribeNatGatewaysResult {
  NatGateways?: NatGateway[];
  NextToken?: string;
}
export const DescribeNatGatewaysResult = S.suspend(() =>
  S.Struct({
    NatGateways: S.optional(NatGatewayList).pipe(
      T.XmlName("natGatewaySet"),
      T.Ec2QueryName("NatGatewaySet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeNatGatewaysResult",
}) as any as S.Schema<DescribeNatGatewaysResult>;
export type NetworkAclIdStringList = string[];
export const NetworkAclIdStringList = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeNetworkAclsRequest {
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
  NetworkAclIds?: string[];
  Filters?: Filter[];
}
export const DescribeNetworkAclsRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    NetworkAclIds: S.optional(NetworkAclIdStringList).pipe(
      T.XmlName("NetworkAclId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeNetworkAclsRequest",
}) as any as S.Schema<DescribeNetworkAclsRequest>;
export type NetworkAclList = NetworkAcl[];
export const NetworkAclList = S.Array(
  NetworkAcl.pipe(T.XmlName("item")).annotate({ identifier: "NetworkAcl" }),
);
export interface DescribeNetworkAclsResult {
  NetworkAcls?: NetworkAcl[];
  NextToken?: string;
}
export const DescribeNetworkAclsResult = S.suspend(() =>
  S.Struct({
    NetworkAcls: S.optional(NetworkAclList).pipe(
      T.XmlName("networkAclSet"),
      T.Ec2QueryName("NetworkAclSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeNetworkAclsResult",
}) as any as S.Schema<DescribeNetworkAclsResult>;
export type NetworkInsightsAccessScopeAnalysisIdList = string[];
export const NetworkInsightsAccessScopeAnalysisIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeNetworkInsightsAccessScopeAnalysesRequest {
  NetworkInsightsAccessScopeAnalysisIds?: string[];
  NetworkInsightsAccessScopeId?: string;
  AnalysisStartTimeBegin?: Date;
  AnalysisStartTimeEnd?: Date;
  Filters?: Filter[];
  MaxResults?: number;
  DryRun?: boolean;
  NextToken?: string;
}
export const DescribeNetworkInsightsAccessScopeAnalysesRequest = S.suspend(() =>
  S.Struct({
    NetworkInsightsAccessScopeAnalysisIds: S.optional(
      NetworkInsightsAccessScopeAnalysisIdList,
    ).pipe(T.XmlName("NetworkInsightsAccessScopeAnalysisId")),
    NetworkInsightsAccessScopeId: S.optional(S.String),
    AnalysisStartTimeBegin: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    AnalysisStartTimeEnd: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeNetworkInsightsAccessScopeAnalysesRequest",
}) as any as S.Schema<DescribeNetworkInsightsAccessScopeAnalysesRequest>;
export type AnalysisStatus = "running" | "succeeded" | "failed" | (string & {});
export const AnalysisStatus = S.String;
export type FindingsFound = "true" | "false" | "unknown" | (string & {});
export const FindingsFound = S.String;
export interface NetworkInsightsAccessScopeAnalysis {
  NetworkInsightsAccessScopeAnalysisId?: string;
  NetworkInsightsAccessScopeAnalysisArn?: string;
  NetworkInsightsAccessScopeId?: string;
  Status?: AnalysisStatus;
  StatusMessage?: string;
  WarningMessage?: string;
  StartDate?: Date;
  EndDate?: Date;
  FindingsFound?: FindingsFound;
  AnalyzedEniCount?: number;
  Tags?: Tag[];
}
export const NetworkInsightsAccessScopeAnalysis = S.suspend(() =>
  S.Struct({
    NetworkInsightsAccessScopeAnalysisId: S.optional(S.String).pipe(
      T.XmlName("networkInsightsAccessScopeAnalysisId"),
      T.Ec2QueryName("NetworkInsightsAccessScopeAnalysisId"),
    ),
    NetworkInsightsAccessScopeAnalysisArn: S.optional(S.String).pipe(
      T.XmlName("networkInsightsAccessScopeAnalysisArn"),
      T.Ec2QueryName("NetworkInsightsAccessScopeAnalysisArn"),
    ),
    NetworkInsightsAccessScopeId: S.optional(S.String).pipe(
      T.XmlName("networkInsightsAccessScopeId"),
      T.Ec2QueryName("NetworkInsightsAccessScopeId"),
    ),
    Status: S.optional(AnalysisStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    WarningMessage: S.optional(S.String).pipe(
      T.XmlName("warningMessage"),
      T.Ec2QueryName("WarningMessage"),
    ),
    StartDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startDate"), T.Ec2QueryName("StartDate")),
    EndDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("endDate"), T.Ec2QueryName("EndDate")),
    FindingsFound: S.optional(FindingsFound).pipe(
      T.XmlName("findingsFound"),
      T.Ec2QueryName("FindingsFound"),
    ),
    AnalyzedEniCount: S.optional(S.Number).pipe(
      T.XmlName("analyzedEniCount"),
      T.Ec2QueryName("AnalyzedEniCount"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "NetworkInsightsAccessScopeAnalysis",
}) as any as S.Schema<NetworkInsightsAccessScopeAnalysis>;
export type NetworkInsightsAccessScopeAnalysisList =
  NetworkInsightsAccessScopeAnalysis[];
export const NetworkInsightsAccessScopeAnalysisList = S.Array(
  NetworkInsightsAccessScopeAnalysis.pipe(T.XmlName("item")).annotate({
    identifier: "NetworkInsightsAccessScopeAnalysis",
  }),
);
export interface DescribeNetworkInsightsAccessScopeAnalysesResult {
  NetworkInsightsAccessScopeAnalyses?: NetworkInsightsAccessScopeAnalysis[];
  NextToken?: string;
}
export const DescribeNetworkInsightsAccessScopeAnalysesResult = S.suspend(() =>
  S.Struct({
    NetworkInsightsAccessScopeAnalyses: S.optional(
      NetworkInsightsAccessScopeAnalysisList,
    ).pipe(
      T.XmlName("networkInsightsAccessScopeAnalysisSet"),
      T.Ec2QueryName("NetworkInsightsAccessScopeAnalysisSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeNetworkInsightsAccessScopeAnalysesResult",
}) as any as S.Schema<DescribeNetworkInsightsAccessScopeAnalysesResult>;
export type NetworkInsightsAccessScopeIdList = string[];
export const NetworkInsightsAccessScopeIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeNetworkInsightsAccessScopesRequest {
  NetworkInsightsAccessScopeIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  DryRun?: boolean;
  NextToken?: string;
}
export const DescribeNetworkInsightsAccessScopesRequest = S.suspend(() =>
  S.Struct({
    NetworkInsightsAccessScopeIds: S.optional(
      NetworkInsightsAccessScopeIdList,
    ).pipe(T.XmlName("NetworkInsightsAccessScopeId")),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeNetworkInsightsAccessScopesRequest",
}) as any as S.Schema<DescribeNetworkInsightsAccessScopesRequest>;
export type NetworkInsightsAccessScopeList = NetworkInsightsAccessScope[];
export const NetworkInsightsAccessScopeList = S.Array(
  NetworkInsightsAccessScope.pipe(T.XmlName("item")).annotate({
    identifier: "NetworkInsightsAccessScope",
  }),
);
export interface DescribeNetworkInsightsAccessScopesResult {
  NetworkInsightsAccessScopes?: NetworkInsightsAccessScope[];
  NextToken?: string;
}
export const DescribeNetworkInsightsAccessScopesResult = S.suspend(() =>
  S.Struct({
    NetworkInsightsAccessScopes: S.optional(
      NetworkInsightsAccessScopeList,
    ).pipe(
      T.XmlName("networkInsightsAccessScopeSet"),
      T.Ec2QueryName("NetworkInsightsAccessScopeSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeNetworkInsightsAccessScopesResult",
}) as any as S.Schema<DescribeNetworkInsightsAccessScopesResult>;
export type NetworkInsightsAnalysisIdList = string[];
export const NetworkInsightsAnalysisIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeNetworkInsightsAnalysesRequest {
  NetworkInsightsAnalysisIds?: string[];
  NetworkInsightsPathId?: string;
  AnalysisStartTime?: Date;
  AnalysisEndTime?: Date;
  Filters?: Filter[];
  MaxResults?: number;
  DryRun?: boolean;
  NextToken?: string;
}
export const DescribeNetworkInsightsAnalysesRequest = S.suspend(() =>
  S.Struct({
    NetworkInsightsAnalysisIds: S.optional(NetworkInsightsAnalysisIdList).pipe(
      T.XmlName("NetworkInsightsAnalysisId"),
    ),
    NetworkInsightsPathId: S.optional(S.String),
    AnalysisStartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    AnalysisEndTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeNetworkInsightsAnalysesRequest",
}) as any as S.Schema<DescribeNetworkInsightsAnalysesRequest>;
export type ArnList = string[];
export const ArnList = S.Array(S.String.pipe(T.XmlName("item")));
export interface AnalysisAclRule {
  Cidr?: string;
  Egress?: boolean;
  PortRange?: PortRange;
  Protocol?: string;
  RuleAction?: string;
  RuleNumber?: number;
}
export const AnalysisAclRule = S.suspend(() =>
  S.Struct({
    Cidr: S.optional(S.String).pipe(T.XmlName("cidr"), T.Ec2QueryName("Cidr")),
    Egress: S.optional(S.Boolean).pipe(
      T.XmlName("egress"),
      T.Ec2QueryName("Egress"),
    ),
    PortRange: S.optional(PortRange)
      .pipe(T.XmlName("portRange"), T.Ec2QueryName("PortRange"))
      .annotate({ identifier: "PortRange" }),
    Protocol: S.optional(S.String).pipe(
      T.XmlName("protocol"),
      T.Ec2QueryName("Protocol"),
    ),
    RuleAction: S.optional(S.String).pipe(
      T.XmlName("ruleAction"),
      T.Ec2QueryName("RuleAction"),
    ),
    RuleNumber: S.optional(S.Number).pipe(
      T.XmlName("ruleNumber"),
      T.Ec2QueryName("RuleNumber"),
    ),
  }),
).annotate({
  identifier: "AnalysisAclRule",
}) as any as S.Schema<AnalysisAclRule>;
export interface AnalysisComponent {
  Id?: string;
  Arn?: string;
  Name?: string;
}
export const AnalysisComponent = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String).pipe(T.XmlName("id"), T.Ec2QueryName("Id")),
    Arn: S.optional(S.String).pipe(T.XmlName("arn"), T.Ec2QueryName("Arn")),
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
  }),
).annotate({
  identifier: "AnalysisComponent",
}) as any as S.Schema<AnalysisComponent>;
export type IpAddressList = string[];
export const IpAddressList = S.Array(S.String.pipe(T.XmlName("item")));
export type PortRangeList = PortRange[];
export const PortRangeList = S.Array(
  PortRange.pipe(T.XmlName("item")).annotate({ identifier: "PortRange" }),
);
export interface AnalysisPacketHeader {
  DestinationAddresses?: string[];
  DestinationPortRanges?: PortRange[];
  Protocol?: string;
  SourceAddresses?: string[];
  SourcePortRanges?: PortRange[];
}
export const AnalysisPacketHeader = S.suspend(() =>
  S.Struct({
    DestinationAddresses: S.optional(IpAddressList).pipe(
      T.XmlName("destinationAddressSet"),
      T.Ec2QueryName("DestinationAddressSet"),
    ),
    DestinationPortRanges: S.optional(PortRangeList).pipe(
      T.XmlName("destinationPortRangeSet"),
      T.Ec2QueryName("DestinationPortRangeSet"),
    ),
    Protocol: S.optional(S.String).pipe(
      T.XmlName("protocol"),
      T.Ec2QueryName("Protocol"),
    ),
    SourceAddresses: S.optional(IpAddressList).pipe(
      T.XmlName("sourceAddressSet"),
      T.Ec2QueryName("SourceAddressSet"),
    ),
    SourcePortRanges: S.optional(PortRangeList).pipe(
      T.XmlName("sourcePortRangeSet"),
      T.Ec2QueryName("SourcePortRangeSet"),
    ),
  }),
).annotate({
  identifier: "AnalysisPacketHeader",
}) as any as S.Schema<AnalysisPacketHeader>;
export interface AnalysisRouteTableRoute {
  DestinationCidr?: string;
  DestinationPrefixListId?: string;
  EgressOnlyInternetGatewayId?: string;
  GatewayId?: string;
  InstanceId?: string;
  NatGatewayId?: string;
  NetworkInterfaceId?: string;
  Origin?: string;
  TransitGatewayId?: string;
  VpcPeeringConnectionId?: string;
  State?: string;
  CarrierGatewayId?: string;
  CoreNetworkArn?: string;
  LocalGatewayId?: string;
}
export const AnalysisRouteTableRoute = S.suspend(() =>
  S.Struct({
    DestinationCidr: S.optional(S.String).pipe(
      T.XmlName("destinationCidr"),
      T.Ec2QueryName("DestinationCidr"),
    ),
    DestinationPrefixListId: S.optional(S.String).pipe(
      T.XmlName("destinationPrefixListId"),
      T.Ec2QueryName("DestinationPrefixListId"),
    ),
    EgressOnlyInternetGatewayId: S.optional(S.String).pipe(
      T.XmlName("egressOnlyInternetGatewayId"),
      T.Ec2QueryName("EgressOnlyInternetGatewayId"),
    ),
    GatewayId: S.optional(S.String).pipe(
      T.XmlName("gatewayId"),
      T.Ec2QueryName("GatewayId"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    NatGatewayId: S.optional(S.String).pipe(
      T.XmlName("natGatewayId"),
      T.Ec2QueryName("NatGatewayId"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    Origin: S.optional(S.String).pipe(
      T.XmlName("origin"),
      T.Ec2QueryName("Origin"),
    ),
    TransitGatewayId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayId"),
      T.Ec2QueryName("TransitGatewayId"),
    ),
    VpcPeeringConnectionId: S.optional(S.String).pipe(
      T.XmlName("vpcPeeringConnectionId"),
      T.Ec2QueryName("VpcPeeringConnectionId"),
    ),
    State: S.optional(S.String).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    CarrierGatewayId: S.optional(S.String).pipe(
      T.XmlName("carrierGatewayId"),
      T.Ec2QueryName("CarrierGatewayId"),
    ),
    CoreNetworkArn: S.optional(S.String).pipe(
      T.XmlName("coreNetworkArn"),
      T.Ec2QueryName("CoreNetworkArn"),
    ),
    LocalGatewayId: S.optional(S.String).pipe(
      T.XmlName("localGatewayId"),
      T.Ec2QueryName("LocalGatewayId"),
    ),
  }),
).annotate({
  identifier: "AnalysisRouteTableRoute",
}) as any as S.Schema<AnalysisRouteTableRoute>;
export interface AnalysisSecurityGroupRule {
  Cidr?: string;
  Direction?: string;
  SecurityGroupId?: string;
  PortRange?: PortRange;
  PrefixListId?: string;
  Protocol?: string;
}
export const AnalysisSecurityGroupRule = S.suspend(() =>
  S.Struct({
    Cidr: S.optional(S.String).pipe(T.XmlName("cidr"), T.Ec2QueryName("Cidr")),
    Direction: S.optional(S.String).pipe(
      T.XmlName("direction"),
      T.Ec2QueryName("Direction"),
    ),
    SecurityGroupId: S.optional(S.String).pipe(
      T.XmlName("securityGroupId"),
      T.Ec2QueryName("SecurityGroupId"),
    ),
    PortRange: S.optional(PortRange)
      .pipe(T.XmlName("portRange"), T.Ec2QueryName("PortRange"))
      .annotate({ identifier: "PortRange" }),
    PrefixListId: S.optional(S.String).pipe(
      T.XmlName("prefixListId"),
      T.Ec2QueryName("PrefixListId"),
    ),
    Protocol: S.optional(S.String).pipe(
      T.XmlName("protocol"),
      T.Ec2QueryName("Protocol"),
    ),
  }),
).annotate({
  identifier: "AnalysisSecurityGroupRule",
}) as any as S.Schema<AnalysisSecurityGroupRule>;
export type StringList = string[];
export const StringList = S.Array(S.String.pipe(T.XmlName("item")));
export interface RuleOption {
  Keyword?: string;
  Settings?: string[];
}
export const RuleOption = S.suspend(() =>
  S.Struct({
    Keyword: S.optional(S.String).pipe(
      T.XmlName("keyword"),
      T.Ec2QueryName("Keyword"),
    ),
    Settings: S.optional(StringList).pipe(
      T.XmlName("settingSet"),
      T.Ec2QueryName("SettingSet"),
    ),
  }),
).annotate({ identifier: "RuleOption" }) as any as S.Schema<RuleOption>;
export type RuleOptionList = RuleOption[];
export const RuleOptionList = S.Array(
  RuleOption.pipe(T.XmlName("item")).annotate({ identifier: "RuleOption" }),
);
export interface RuleGroupTypePair {
  RuleGroupArn?: string;
  RuleGroupType?: string;
}
export const RuleGroupTypePair = S.suspend(() =>
  S.Struct({
    RuleGroupArn: S.optional(S.String).pipe(
      T.XmlName("ruleGroupArn"),
      T.Ec2QueryName("RuleGroupArn"),
    ),
    RuleGroupType: S.optional(S.String).pipe(
      T.XmlName("ruleGroupType"),
      T.Ec2QueryName("RuleGroupType"),
    ),
  }),
).annotate({
  identifier: "RuleGroupTypePair",
}) as any as S.Schema<RuleGroupTypePair>;
export type RuleGroupTypePairList = RuleGroupTypePair[];
export const RuleGroupTypePairList = S.Array(
  RuleGroupTypePair.pipe(T.XmlName("item")).annotate({
    identifier: "RuleGroupTypePair",
  }),
);
export interface RuleGroupRuleOptionsPair {
  RuleGroupArn?: string;
  RuleOptions?: RuleOption[];
}
export const RuleGroupRuleOptionsPair = S.suspend(() =>
  S.Struct({
    RuleGroupArn: S.optional(S.String).pipe(
      T.XmlName("ruleGroupArn"),
      T.Ec2QueryName("RuleGroupArn"),
    ),
    RuleOptions: S.optional(RuleOptionList).pipe(
      T.XmlName("ruleOptionSet"),
      T.Ec2QueryName("RuleOptionSet"),
    ),
  }),
).annotate({
  identifier: "RuleGroupRuleOptionsPair",
}) as any as S.Schema<RuleGroupRuleOptionsPair>;
export type RuleGroupRuleOptionsPairList = RuleGroupRuleOptionsPair[];
export const RuleGroupRuleOptionsPairList = S.Array(
  RuleGroupRuleOptionsPair.pipe(T.XmlName("item")).annotate({
    identifier: "RuleGroupRuleOptionsPair",
  }),
);
export type AnalysisComponentList = AnalysisComponent[];
export const AnalysisComponentList = S.Array(
  AnalysisComponent.pipe(T.XmlName("item")).annotate({
    identifier: "AnalysisComponent",
  }),
);
export interface AdditionalDetail {
  AdditionalDetailType?: string;
  Component?: AnalysisComponent;
  VpcEndpointService?: AnalysisComponent;
  RuleOptions?: RuleOption[];
  RuleGroupTypePairs?: RuleGroupTypePair[];
  RuleGroupRuleOptionsPairs?: RuleGroupRuleOptionsPair[];
  ServiceName?: string;
  LoadBalancers?: AnalysisComponent[];
}
export const AdditionalDetail = S.suspend(() =>
  S.Struct({
    AdditionalDetailType: S.optional(S.String).pipe(
      T.XmlName("additionalDetailType"),
      T.Ec2QueryName("AdditionalDetailType"),
    ),
    Component: S.optional(AnalysisComponent)
      .pipe(T.XmlName("component"), T.Ec2QueryName("Component"))
      .annotate({ identifier: "AnalysisComponent" }),
    VpcEndpointService: S.optional(AnalysisComponent)
      .pipe(
        T.XmlName("vpcEndpointService"),
        T.Ec2QueryName("VpcEndpointService"),
      )
      .annotate({ identifier: "AnalysisComponent" }),
    RuleOptions: S.optional(RuleOptionList).pipe(
      T.XmlName("ruleOptionSet"),
      T.Ec2QueryName("RuleOptionSet"),
    ),
    RuleGroupTypePairs: S.optional(RuleGroupTypePairList).pipe(
      T.XmlName("ruleGroupTypePairSet"),
      T.Ec2QueryName("RuleGroupTypePairSet"),
    ),
    RuleGroupRuleOptionsPairs: S.optional(RuleGroupRuleOptionsPairList).pipe(
      T.XmlName("ruleGroupRuleOptionsPairSet"),
      T.Ec2QueryName("RuleGroupRuleOptionsPairSet"),
    ),
    ServiceName: S.optional(S.String).pipe(
      T.XmlName("serviceName"),
      T.Ec2QueryName("ServiceName"),
    ),
    LoadBalancers: S.optional(AnalysisComponentList).pipe(
      T.XmlName("loadBalancerSet"),
      T.Ec2QueryName("LoadBalancerSet"),
    ),
  }),
).annotate({
  identifier: "AdditionalDetail",
}) as any as S.Schema<AdditionalDetail>;
export type AdditionalDetailList = AdditionalDetail[];
export const AdditionalDetailList = S.Array(
  AdditionalDetail.pipe(T.XmlName("item")).annotate({
    identifier: "AdditionalDetail",
  }),
);
export interface TransitGatewayRouteTableRoute {
  DestinationCidr?: string;
  State?: string;
  RouteOrigin?: string;
  PrefixListId?: string;
  AttachmentId?: string;
  ResourceId?: string;
  ResourceType?: string;
}
export const TransitGatewayRouteTableRoute = S.suspend(() =>
  S.Struct({
    DestinationCidr: S.optional(S.String).pipe(
      T.XmlName("destinationCidr"),
      T.Ec2QueryName("DestinationCidr"),
    ),
    State: S.optional(S.String).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    RouteOrigin: S.optional(S.String).pipe(
      T.XmlName("routeOrigin"),
      T.Ec2QueryName("RouteOrigin"),
    ),
    PrefixListId: S.optional(S.String).pipe(
      T.XmlName("prefixListId"),
      T.Ec2QueryName("PrefixListId"),
    ),
    AttachmentId: S.optional(S.String).pipe(
      T.XmlName("attachmentId"),
      T.Ec2QueryName("AttachmentId"),
    ),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    ResourceType: S.optional(S.String).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayRouteTableRoute",
}) as any as S.Schema<TransitGatewayRouteTableRoute>;
export interface AnalysisLoadBalancerListener {
  LoadBalancerPort?: number;
  InstancePort?: number;
}
export const AnalysisLoadBalancerListener = S.suspend(() =>
  S.Struct({
    LoadBalancerPort: S.optional(S.Number).pipe(
      T.XmlName("loadBalancerPort"),
      T.Ec2QueryName("LoadBalancerPort"),
    ),
    InstancePort: S.optional(S.Number).pipe(
      T.XmlName("instancePort"),
      T.Ec2QueryName("InstancePort"),
    ),
  }),
).annotate({
  identifier: "AnalysisLoadBalancerListener",
}) as any as S.Schema<AnalysisLoadBalancerListener>;
export interface AnalysisLoadBalancerTarget {
  Address?: string;
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  Instance?: AnalysisComponent;
  Port?: number;
}
export const AnalysisLoadBalancerTarget = S.suspend(() =>
  S.Struct({
    Address: S.optional(S.String).pipe(
      T.XmlName("address"),
      T.Ec2QueryName("Address"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    Instance: S.optional(AnalysisComponent)
      .pipe(T.XmlName("instance"), T.Ec2QueryName("Instance"))
      .annotate({ identifier: "AnalysisComponent" }),
    Port: S.optional(S.Number).pipe(T.XmlName("port"), T.Ec2QueryName("Port")),
  }),
).annotate({
  identifier: "AnalysisLoadBalancerTarget",
}) as any as S.Schema<AnalysisLoadBalancerTarget>;
export type ProtocolIntList = number[];
export const ProtocolIntList = S.Array(S.Number.pipe(T.XmlName("item")));
export interface FirewallStatelessRule {
  RuleGroupArn?: string;
  Sources?: string[];
  Destinations?: string[];
  SourcePorts?: PortRange[];
  DestinationPorts?: PortRange[];
  Protocols?: number[];
  RuleAction?: string;
  Priority?: number;
}
export const FirewallStatelessRule = S.suspend(() =>
  S.Struct({
    RuleGroupArn: S.optional(S.String).pipe(
      T.XmlName("ruleGroupArn"),
      T.Ec2QueryName("RuleGroupArn"),
    ),
    Sources: S.optional(ValueStringList).pipe(
      T.XmlName("sourceSet"),
      T.Ec2QueryName("SourceSet"),
    ),
    Destinations: S.optional(ValueStringList).pipe(
      T.XmlName("destinationSet"),
      T.Ec2QueryName("DestinationSet"),
    ),
    SourcePorts: S.optional(PortRangeList).pipe(
      T.XmlName("sourcePortSet"),
      T.Ec2QueryName("SourcePortSet"),
    ),
    DestinationPorts: S.optional(PortRangeList).pipe(
      T.XmlName("destinationPortSet"),
      T.Ec2QueryName("DestinationPortSet"),
    ),
    Protocols: S.optional(ProtocolIntList).pipe(
      T.XmlName("protocolSet"),
      T.Ec2QueryName("ProtocolSet"),
    ),
    RuleAction: S.optional(S.String).pipe(
      T.XmlName("ruleAction"),
      T.Ec2QueryName("RuleAction"),
    ),
    Priority: S.optional(S.Number).pipe(
      T.XmlName("priority"),
      T.Ec2QueryName("Priority"),
    ),
  }),
).annotate({
  identifier: "FirewallStatelessRule",
}) as any as S.Schema<FirewallStatelessRule>;
export interface FirewallStatefulRule {
  RuleGroupArn?: string;
  Sources?: string[];
  Destinations?: string[];
  SourcePorts?: PortRange[];
  DestinationPorts?: PortRange[];
  Protocol?: string;
  RuleAction?: string;
  Direction?: string;
}
export const FirewallStatefulRule = S.suspend(() =>
  S.Struct({
    RuleGroupArn: S.optional(S.String).pipe(
      T.XmlName("ruleGroupArn"),
      T.Ec2QueryName("RuleGroupArn"),
    ),
    Sources: S.optional(ValueStringList).pipe(
      T.XmlName("sourceSet"),
      T.Ec2QueryName("SourceSet"),
    ),
    Destinations: S.optional(ValueStringList).pipe(
      T.XmlName("destinationSet"),
      T.Ec2QueryName("DestinationSet"),
    ),
    SourcePorts: S.optional(PortRangeList).pipe(
      T.XmlName("sourcePortSet"),
      T.Ec2QueryName("SourcePortSet"),
    ),
    DestinationPorts: S.optional(PortRangeList).pipe(
      T.XmlName("destinationPortSet"),
      T.Ec2QueryName("DestinationPortSet"),
    ),
    Protocol: S.optional(S.String).pipe(
      T.XmlName("protocol"),
      T.Ec2QueryName("Protocol"),
    ),
    RuleAction: S.optional(S.String).pipe(
      T.XmlName("ruleAction"),
      T.Ec2QueryName("RuleAction"),
    ),
    Direction: S.optional(S.String).pipe(
      T.XmlName("direction"),
      T.Ec2QueryName("Direction"),
    ),
  }),
).annotate({
  identifier: "FirewallStatefulRule",
}) as any as S.Schema<FirewallStatefulRule>;
export interface Explanation {
  Acl?: AnalysisComponent;
  AclRule?: AnalysisAclRule;
  Address?: string;
  Addresses?: string[];
  AttachedTo?: AnalysisComponent;
  AvailabilityZones?: string[];
  AvailabilityZoneIds?: string[];
  Cidrs?: string[];
  Component?: AnalysisComponent;
  CustomerGateway?: AnalysisComponent;
  Destination?: AnalysisComponent;
  DestinationVpc?: AnalysisComponent;
  Direction?: string;
  ExplanationCode?: string;
  IngressRouteTable?: AnalysisComponent;
  InternetGateway?: AnalysisComponent;
  LoadBalancerArn?: string;
  ClassicLoadBalancerListener?: AnalysisLoadBalancerListener;
  LoadBalancerListenerPort?: number;
  LoadBalancerTarget?: AnalysisLoadBalancerTarget;
  LoadBalancerTargetGroup?: AnalysisComponent;
  LoadBalancerTargetGroups?: AnalysisComponent[];
  LoadBalancerTargetPort?: number;
  ElasticLoadBalancerListener?: AnalysisComponent;
  MissingComponent?: string;
  NatGateway?: AnalysisComponent;
  NetworkInterface?: AnalysisComponent;
  PacketField?: string;
  VpcPeeringConnection?: AnalysisComponent;
  Port?: number;
  PortRanges?: PortRange[];
  PrefixList?: AnalysisComponent;
  Protocols?: string[];
  RouteTableRoute?: AnalysisRouteTableRoute;
  RouteTable?: AnalysisComponent;
  SecurityGroup?: AnalysisComponent;
  SecurityGroupRule?: AnalysisSecurityGroupRule;
  SecurityGroups?: AnalysisComponent[];
  SourceVpc?: AnalysisComponent;
  State?: string;
  Subnet?: AnalysisComponent;
  SubnetRouteTable?: AnalysisComponent;
  Vpc?: AnalysisComponent;
  VpcEndpoint?: AnalysisComponent;
  VpnConnection?: AnalysisComponent;
  VpnGateway?: AnalysisComponent;
  TransitGateway?: AnalysisComponent;
  TransitGatewayRouteTable?: AnalysisComponent;
  TransitGatewayRouteTableRoute?: TransitGatewayRouteTableRoute;
  TransitGatewayAttachment?: AnalysisComponent;
  ComponentAccount?: string;
  ComponentRegion?: string;
  FirewallStatelessRule?: FirewallStatelessRule;
  FirewallStatefulRule?: FirewallStatefulRule;
}
export const Explanation = S.suspend(() =>
  S.Struct({
    Acl: S.optional(AnalysisComponent)
      .pipe(T.XmlName("acl"), T.Ec2QueryName("Acl"))
      .annotate({ identifier: "AnalysisComponent" }),
    AclRule: S.optional(AnalysisAclRule)
      .pipe(T.XmlName("aclRule"), T.Ec2QueryName("AclRule"))
      .annotate({ identifier: "AnalysisAclRule" }),
    Address: S.optional(S.String).pipe(
      T.XmlName("address"),
      T.Ec2QueryName("Address"),
    ),
    Addresses: S.optional(IpAddressList).pipe(
      T.XmlName("addressSet"),
      T.Ec2QueryName("AddressSet"),
    ),
    AttachedTo: S.optional(AnalysisComponent)
      .pipe(T.XmlName("attachedTo"), T.Ec2QueryName("AttachedTo"))
      .annotate({ identifier: "AnalysisComponent" }),
    AvailabilityZones: S.optional(ValueStringList).pipe(
      T.XmlName("availabilityZoneSet"),
      T.Ec2QueryName("AvailabilityZoneSet"),
    ),
    AvailabilityZoneIds: S.optional(ValueStringList).pipe(
      T.XmlName("availabilityZoneIdSet"),
      T.Ec2QueryName("AvailabilityZoneIdSet"),
    ),
    Cidrs: S.optional(ValueStringList).pipe(
      T.XmlName("cidrSet"),
      T.Ec2QueryName("CidrSet"),
    ),
    Component: S.optional(AnalysisComponent)
      .pipe(T.XmlName("component"), T.Ec2QueryName("Component"))
      .annotate({ identifier: "AnalysisComponent" }),
    CustomerGateway: S.optional(AnalysisComponent)
      .pipe(T.XmlName("customerGateway"), T.Ec2QueryName("CustomerGateway"))
      .annotate({ identifier: "AnalysisComponent" }),
    Destination: S.optional(AnalysisComponent)
      .pipe(T.XmlName("destination"), T.Ec2QueryName("Destination"))
      .annotate({ identifier: "AnalysisComponent" }),
    DestinationVpc: S.optional(AnalysisComponent)
      .pipe(T.XmlName("destinationVpc"), T.Ec2QueryName("DestinationVpc"))
      .annotate({ identifier: "AnalysisComponent" }),
    Direction: S.optional(S.String).pipe(
      T.XmlName("direction"),
      T.Ec2QueryName("Direction"),
    ),
    ExplanationCode: S.optional(S.String).pipe(
      T.XmlName("explanationCode"),
      T.Ec2QueryName("ExplanationCode"),
    ),
    IngressRouteTable: S.optional(AnalysisComponent)
      .pipe(T.XmlName("ingressRouteTable"), T.Ec2QueryName("IngressRouteTable"))
      .annotate({ identifier: "AnalysisComponent" }),
    InternetGateway: S.optional(AnalysisComponent)
      .pipe(T.XmlName("internetGateway"), T.Ec2QueryName("InternetGateway"))
      .annotate({ identifier: "AnalysisComponent" }),
    LoadBalancerArn: S.optional(S.String).pipe(
      T.XmlName("loadBalancerArn"),
      T.Ec2QueryName("LoadBalancerArn"),
    ),
    ClassicLoadBalancerListener: S.optional(AnalysisLoadBalancerListener)
      .pipe(
        T.XmlName("classicLoadBalancerListener"),
        T.Ec2QueryName("ClassicLoadBalancerListener"),
      )
      .annotate({ identifier: "AnalysisLoadBalancerListener" }),
    LoadBalancerListenerPort: S.optional(S.Number).pipe(
      T.XmlName("loadBalancerListenerPort"),
      T.Ec2QueryName("LoadBalancerListenerPort"),
    ),
    LoadBalancerTarget: S.optional(AnalysisLoadBalancerTarget)
      .pipe(
        T.XmlName("loadBalancerTarget"),
        T.Ec2QueryName("LoadBalancerTarget"),
      )
      .annotate({ identifier: "AnalysisLoadBalancerTarget" }),
    LoadBalancerTargetGroup: S.optional(AnalysisComponent)
      .pipe(
        T.XmlName("loadBalancerTargetGroup"),
        T.Ec2QueryName("LoadBalancerTargetGroup"),
      )
      .annotate({ identifier: "AnalysisComponent" }),
    LoadBalancerTargetGroups: S.optional(AnalysisComponentList).pipe(
      T.XmlName("loadBalancerTargetGroupSet"),
      T.Ec2QueryName("LoadBalancerTargetGroupSet"),
    ),
    LoadBalancerTargetPort: S.optional(S.Number).pipe(
      T.XmlName("loadBalancerTargetPort"),
      T.Ec2QueryName("LoadBalancerTargetPort"),
    ),
    ElasticLoadBalancerListener: S.optional(AnalysisComponent)
      .pipe(
        T.XmlName("elasticLoadBalancerListener"),
        T.Ec2QueryName("ElasticLoadBalancerListener"),
      )
      .annotate({ identifier: "AnalysisComponent" }),
    MissingComponent: S.optional(S.String).pipe(
      T.XmlName("missingComponent"),
      T.Ec2QueryName("MissingComponent"),
    ),
    NatGateway: S.optional(AnalysisComponent)
      .pipe(T.XmlName("natGateway"), T.Ec2QueryName("NatGateway"))
      .annotate({ identifier: "AnalysisComponent" }),
    NetworkInterface: S.optional(AnalysisComponent)
      .pipe(T.XmlName("networkInterface"), T.Ec2QueryName("NetworkInterface"))
      .annotate({ identifier: "AnalysisComponent" }),
    PacketField: S.optional(S.String).pipe(
      T.XmlName("packetField"),
      T.Ec2QueryName("PacketField"),
    ),
    VpcPeeringConnection: S.optional(AnalysisComponent)
      .pipe(
        T.XmlName("vpcPeeringConnection"),
        T.Ec2QueryName("VpcPeeringConnection"),
      )
      .annotate({ identifier: "AnalysisComponent" }),
    Port: S.optional(S.Number).pipe(T.XmlName("port"), T.Ec2QueryName("Port")),
    PortRanges: S.optional(PortRangeList).pipe(
      T.XmlName("portRangeSet"),
      T.Ec2QueryName("PortRangeSet"),
    ),
    PrefixList: S.optional(AnalysisComponent)
      .pipe(T.XmlName("prefixList"), T.Ec2QueryName("PrefixList"))
      .annotate({ identifier: "AnalysisComponent" }),
    Protocols: S.optional(StringList).pipe(
      T.XmlName("protocolSet"),
      T.Ec2QueryName("ProtocolSet"),
    ),
    RouteTableRoute: S.optional(AnalysisRouteTableRoute)
      .pipe(T.XmlName("routeTableRoute"), T.Ec2QueryName("RouteTableRoute"))
      .annotate({ identifier: "AnalysisRouteTableRoute" }),
    RouteTable: S.optional(AnalysisComponent)
      .pipe(T.XmlName("routeTable"), T.Ec2QueryName("RouteTable"))
      .annotate({ identifier: "AnalysisComponent" }),
    SecurityGroup: S.optional(AnalysisComponent)
      .pipe(T.XmlName("securityGroup"), T.Ec2QueryName("SecurityGroup"))
      .annotate({ identifier: "AnalysisComponent" }),
    SecurityGroupRule: S.optional(AnalysisSecurityGroupRule)
      .pipe(T.XmlName("securityGroupRule"), T.Ec2QueryName("SecurityGroupRule"))
      .annotate({ identifier: "AnalysisSecurityGroupRule" }),
    SecurityGroups: S.optional(AnalysisComponentList).pipe(
      T.XmlName("securityGroupSet"),
      T.Ec2QueryName("SecurityGroupSet"),
    ),
    SourceVpc: S.optional(AnalysisComponent)
      .pipe(T.XmlName("sourceVpc"), T.Ec2QueryName("SourceVpc"))
      .annotate({ identifier: "AnalysisComponent" }),
    State: S.optional(S.String).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Subnet: S.optional(AnalysisComponent)
      .pipe(T.XmlName("subnet"), T.Ec2QueryName("Subnet"))
      .annotate({ identifier: "AnalysisComponent" }),
    SubnetRouteTable: S.optional(AnalysisComponent)
      .pipe(T.XmlName("subnetRouteTable"), T.Ec2QueryName("SubnetRouteTable"))
      .annotate({ identifier: "AnalysisComponent" }),
    Vpc: S.optional(AnalysisComponent)
      .pipe(T.XmlName("vpc"), T.Ec2QueryName("Vpc"))
      .annotate({ identifier: "AnalysisComponent" }),
    VpcEndpoint: S.optional(AnalysisComponent)
      .pipe(T.XmlName("vpcEndpoint"), T.Ec2QueryName("VpcEndpoint"))
      .annotate({ identifier: "AnalysisComponent" }),
    VpnConnection: S.optional(AnalysisComponent)
      .pipe(T.XmlName("vpnConnection"), T.Ec2QueryName("VpnConnection"))
      .annotate({ identifier: "AnalysisComponent" }),
    VpnGateway: S.optional(AnalysisComponent)
      .pipe(T.XmlName("vpnGateway"), T.Ec2QueryName("VpnGateway"))
      .annotate({ identifier: "AnalysisComponent" }),
    TransitGateway: S.optional(AnalysisComponent)
      .pipe(T.XmlName("transitGateway"), T.Ec2QueryName("TransitGateway"))
      .annotate({ identifier: "AnalysisComponent" }),
    TransitGatewayRouteTable: S.optional(AnalysisComponent)
      .pipe(
        T.XmlName("transitGatewayRouteTable"),
        T.Ec2QueryName("TransitGatewayRouteTable"),
      )
      .annotate({ identifier: "AnalysisComponent" }),
    TransitGatewayRouteTableRoute: S.optional(TransitGatewayRouteTableRoute)
      .pipe(
        T.XmlName("transitGatewayRouteTableRoute"),
        T.Ec2QueryName("TransitGatewayRouteTableRoute"),
      )
      .annotate({ identifier: "TransitGatewayRouteTableRoute" }),
    TransitGatewayAttachment: S.optional(AnalysisComponent)
      .pipe(
        T.XmlName("transitGatewayAttachment"),
        T.Ec2QueryName("TransitGatewayAttachment"),
      )
      .annotate({ identifier: "AnalysisComponent" }),
    ComponentAccount: S.optional(S.String).pipe(
      T.XmlName("componentAccount"),
      T.Ec2QueryName("ComponentAccount"),
    ),
    ComponentRegion: S.optional(S.String).pipe(
      T.XmlName("componentRegion"),
      T.Ec2QueryName("ComponentRegion"),
    ),
    FirewallStatelessRule: S.optional(FirewallStatelessRule)
      .pipe(
        T.XmlName("firewallStatelessRule"),
        T.Ec2QueryName("FirewallStatelessRule"),
      )
      .annotate({ identifier: "FirewallStatelessRule" }),
    FirewallStatefulRule: S.optional(FirewallStatefulRule)
      .pipe(
        T.XmlName("firewallStatefulRule"),
        T.Ec2QueryName("FirewallStatefulRule"),
      )
      .annotate({ identifier: "FirewallStatefulRule" }),
  }),
).annotate({ identifier: "Explanation" }) as any as S.Schema<Explanation>;
export type ExplanationList = Explanation[];
export const ExplanationList = S.Array(
  Explanation.pipe(T.XmlName("item")).annotate({ identifier: "Explanation" }),
);
export interface PathComponent {
  SequenceNumber?: number;
  AclRule?: AnalysisAclRule;
  AttachedTo?: AnalysisComponent;
  Component?: AnalysisComponent;
  DestinationVpc?: AnalysisComponent;
  OutboundHeader?: AnalysisPacketHeader;
  InboundHeader?: AnalysisPacketHeader;
  RouteTableRoute?: AnalysisRouteTableRoute;
  SecurityGroupRule?: AnalysisSecurityGroupRule;
  SourceVpc?: AnalysisComponent;
  Subnet?: AnalysisComponent;
  Vpc?: AnalysisComponent;
  AdditionalDetails?: AdditionalDetail[];
  TransitGateway?: AnalysisComponent;
  TransitGatewayRouteTableRoute?: TransitGatewayRouteTableRoute;
  Explanations?: Explanation[];
  ElasticLoadBalancerListener?: AnalysisComponent;
  FirewallStatelessRule?: FirewallStatelessRule;
  FirewallStatefulRule?: FirewallStatefulRule;
  ServiceName?: string;
}
export const PathComponent = S.suspend(() =>
  S.Struct({
    SequenceNumber: S.optional(S.Number).pipe(
      T.XmlName("sequenceNumber"),
      T.Ec2QueryName("SequenceNumber"),
    ),
    AclRule: S.optional(AnalysisAclRule)
      .pipe(T.XmlName("aclRule"), T.Ec2QueryName("AclRule"))
      .annotate({ identifier: "AnalysisAclRule" }),
    AttachedTo: S.optional(AnalysisComponent)
      .pipe(T.XmlName("attachedTo"), T.Ec2QueryName("AttachedTo"))
      .annotate({ identifier: "AnalysisComponent" }),
    Component: S.optional(AnalysisComponent)
      .pipe(T.XmlName("component"), T.Ec2QueryName("Component"))
      .annotate({ identifier: "AnalysisComponent" }),
    DestinationVpc: S.optional(AnalysisComponent)
      .pipe(T.XmlName("destinationVpc"), T.Ec2QueryName("DestinationVpc"))
      .annotate({ identifier: "AnalysisComponent" }),
    OutboundHeader: S.optional(AnalysisPacketHeader)
      .pipe(T.XmlName("outboundHeader"), T.Ec2QueryName("OutboundHeader"))
      .annotate({ identifier: "AnalysisPacketHeader" }),
    InboundHeader: S.optional(AnalysisPacketHeader)
      .pipe(T.XmlName("inboundHeader"), T.Ec2QueryName("InboundHeader"))
      .annotate({ identifier: "AnalysisPacketHeader" }),
    RouteTableRoute: S.optional(AnalysisRouteTableRoute)
      .pipe(T.XmlName("routeTableRoute"), T.Ec2QueryName("RouteTableRoute"))
      .annotate({ identifier: "AnalysisRouteTableRoute" }),
    SecurityGroupRule: S.optional(AnalysisSecurityGroupRule)
      .pipe(T.XmlName("securityGroupRule"), T.Ec2QueryName("SecurityGroupRule"))
      .annotate({ identifier: "AnalysisSecurityGroupRule" }),
    SourceVpc: S.optional(AnalysisComponent)
      .pipe(T.XmlName("sourceVpc"), T.Ec2QueryName("SourceVpc"))
      .annotate({ identifier: "AnalysisComponent" }),
    Subnet: S.optional(AnalysisComponent)
      .pipe(T.XmlName("subnet"), T.Ec2QueryName("Subnet"))
      .annotate({ identifier: "AnalysisComponent" }),
    Vpc: S.optional(AnalysisComponent)
      .pipe(T.XmlName("vpc"), T.Ec2QueryName("Vpc"))
      .annotate({ identifier: "AnalysisComponent" }),
    AdditionalDetails: S.optional(AdditionalDetailList).pipe(
      T.XmlName("additionalDetailSet"),
      T.Ec2QueryName("AdditionalDetailSet"),
    ),
    TransitGateway: S.optional(AnalysisComponent)
      .pipe(T.XmlName("transitGateway"), T.Ec2QueryName("TransitGateway"))
      .annotate({ identifier: "AnalysisComponent" }),
    TransitGatewayRouteTableRoute: S.optional(TransitGatewayRouteTableRoute)
      .pipe(
        T.XmlName("transitGatewayRouteTableRoute"),
        T.Ec2QueryName("TransitGatewayRouteTableRoute"),
      )
      .annotate({ identifier: "TransitGatewayRouteTableRoute" }),
    Explanations: S.optional(ExplanationList).pipe(
      T.XmlName("explanationSet"),
      T.Ec2QueryName("ExplanationSet"),
    ),
    ElasticLoadBalancerListener: S.optional(AnalysisComponent)
      .pipe(
        T.XmlName("elasticLoadBalancerListener"),
        T.Ec2QueryName("ElasticLoadBalancerListener"),
      )
      .annotate({ identifier: "AnalysisComponent" }),
    FirewallStatelessRule: S.optional(FirewallStatelessRule)
      .pipe(
        T.XmlName("firewallStatelessRule"),
        T.Ec2QueryName("FirewallStatelessRule"),
      )
      .annotate({ identifier: "FirewallStatelessRule" }),
    FirewallStatefulRule: S.optional(FirewallStatefulRule)
      .pipe(
        T.XmlName("firewallStatefulRule"),
        T.Ec2QueryName("FirewallStatefulRule"),
      )
      .annotate({ identifier: "FirewallStatefulRule" }),
    ServiceName: S.optional(S.String).pipe(
      T.XmlName("serviceName"),
      T.Ec2QueryName("ServiceName"),
    ),
  }),
).annotate({ identifier: "PathComponent" }) as any as S.Schema<PathComponent>;
export type PathComponentList = PathComponent[];
export const PathComponentList = S.Array(
  PathComponent.pipe(T.XmlName("item")).annotate({
    identifier: "PathComponent",
  }),
);
export interface AlternatePathHint {
  ComponentId?: string;
  ComponentArn?: string;
}
export const AlternatePathHint = S.suspend(() =>
  S.Struct({
    ComponentId: S.optional(S.String).pipe(
      T.XmlName("componentId"),
      T.Ec2QueryName("ComponentId"),
    ),
    ComponentArn: S.optional(S.String).pipe(
      T.XmlName("componentArn"),
      T.Ec2QueryName("ComponentArn"),
    ),
  }),
).annotate({
  identifier: "AlternatePathHint",
}) as any as S.Schema<AlternatePathHint>;
export type AlternatePathHintList = AlternatePathHint[];
export const AlternatePathHintList = S.Array(
  AlternatePathHint.pipe(T.XmlName("item")).annotate({
    identifier: "AlternatePathHint",
  }),
);
export interface NetworkInsightsAnalysis {
  NetworkInsightsAnalysisId?: string;
  NetworkInsightsAnalysisArn?: string;
  NetworkInsightsPathId?: string;
  AdditionalAccounts?: string[];
  FilterInArns?: string[];
  FilterOutArns?: string[];
  StartDate?: Date;
  Status?: AnalysisStatus;
  StatusMessage?: string;
  WarningMessage?: string;
  NetworkPathFound?: boolean;
  ForwardPathComponents?: PathComponent[];
  ReturnPathComponents?: PathComponent[];
  Explanations?: Explanation[];
  AlternatePathHints?: AlternatePathHint[];
  SuggestedAccounts?: string[];
  Tags?: Tag[];
}
export const NetworkInsightsAnalysis = S.suspend(() =>
  S.Struct({
    NetworkInsightsAnalysisId: S.optional(S.String).pipe(
      T.XmlName("networkInsightsAnalysisId"),
      T.Ec2QueryName("NetworkInsightsAnalysisId"),
    ),
    NetworkInsightsAnalysisArn: S.optional(S.String).pipe(
      T.XmlName("networkInsightsAnalysisArn"),
      T.Ec2QueryName("NetworkInsightsAnalysisArn"),
    ),
    NetworkInsightsPathId: S.optional(S.String).pipe(
      T.XmlName("networkInsightsPathId"),
      T.Ec2QueryName("NetworkInsightsPathId"),
    ),
    AdditionalAccounts: S.optional(ValueStringList).pipe(
      T.XmlName("additionalAccountSet"),
      T.Ec2QueryName("AdditionalAccountSet"),
    ),
    FilterInArns: S.optional(ArnList).pipe(
      T.XmlName("filterInArnSet"),
      T.Ec2QueryName("FilterInArnSet"),
    ),
    FilterOutArns: S.optional(ArnList).pipe(
      T.XmlName("filterOutArnSet"),
      T.Ec2QueryName("FilterOutArnSet"),
    ),
    StartDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startDate"), T.Ec2QueryName("StartDate")),
    Status: S.optional(AnalysisStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    WarningMessage: S.optional(S.String).pipe(
      T.XmlName("warningMessage"),
      T.Ec2QueryName("WarningMessage"),
    ),
    NetworkPathFound: S.optional(S.Boolean).pipe(
      T.XmlName("networkPathFound"),
      T.Ec2QueryName("NetworkPathFound"),
    ),
    ForwardPathComponents: S.optional(PathComponentList).pipe(
      T.XmlName("forwardPathComponentSet"),
      T.Ec2QueryName("ForwardPathComponentSet"),
    ),
    ReturnPathComponents: S.optional(PathComponentList).pipe(
      T.XmlName("returnPathComponentSet"),
      T.Ec2QueryName("ReturnPathComponentSet"),
    ),
    Explanations: S.optional(ExplanationList).pipe(
      T.XmlName("explanationSet"),
      T.Ec2QueryName("ExplanationSet"),
    ),
    AlternatePathHints: S.optional(AlternatePathHintList).pipe(
      T.XmlName("alternatePathHintSet"),
      T.Ec2QueryName("AlternatePathHintSet"),
    ),
    SuggestedAccounts: S.optional(ValueStringList).pipe(
      T.XmlName("suggestedAccountSet"),
      T.Ec2QueryName("SuggestedAccountSet"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "NetworkInsightsAnalysis",
}) as any as S.Schema<NetworkInsightsAnalysis>;
export type NetworkInsightsAnalysisList = NetworkInsightsAnalysis[];
export const NetworkInsightsAnalysisList = S.Array(
  NetworkInsightsAnalysis.pipe(T.XmlName("item")).annotate({
    identifier: "NetworkInsightsAnalysis",
  }),
);
export interface DescribeNetworkInsightsAnalysesResult {
  NetworkInsightsAnalyses?: NetworkInsightsAnalysis[];
  NextToken?: string;
}
export const DescribeNetworkInsightsAnalysesResult = S.suspend(() =>
  S.Struct({
    NetworkInsightsAnalyses: S.optional(NetworkInsightsAnalysisList).pipe(
      T.XmlName("networkInsightsAnalysisSet"),
      T.Ec2QueryName("NetworkInsightsAnalysisSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeNetworkInsightsAnalysesResult",
}) as any as S.Schema<DescribeNetworkInsightsAnalysesResult>;
export type NetworkInsightsPathIdList = string[];
export const NetworkInsightsPathIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeNetworkInsightsPathsRequest {
  NetworkInsightsPathIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  DryRun?: boolean;
  NextToken?: string;
}
export const DescribeNetworkInsightsPathsRequest = S.suspend(() =>
  S.Struct({
    NetworkInsightsPathIds: S.optional(NetworkInsightsPathIdList).pipe(
      T.XmlName("NetworkInsightsPathId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeNetworkInsightsPathsRequest",
}) as any as S.Schema<DescribeNetworkInsightsPathsRequest>;
export type NetworkInsightsPathList = NetworkInsightsPath[];
export const NetworkInsightsPathList = S.Array(
  NetworkInsightsPath.pipe(T.XmlName("item")).annotate({
    identifier: "NetworkInsightsPath",
  }),
);
export interface DescribeNetworkInsightsPathsResult {
  NetworkInsightsPaths?: NetworkInsightsPath[];
  NextToken?: string;
}
export const DescribeNetworkInsightsPathsResult = S.suspend(() =>
  S.Struct({
    NetworkInsightsPaths: S.optional(NetworkInsightsPathList).pipe(
      T.XmlName("networkInsightsPathSet"),
      T.Ec2QueryName("NetworkInsightsPathSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeNetworkInsightsPathsResult",
}) as any as S.Schema<DescribeNetworkInsightsPathsResult>;
export type NetworkInterfaceAttribute =
  | "description"
  | "groupSet"
  | "sourceDestCheck"
  | "attachment"
  | "associatePublicIpAddress"
  | (string & {});
export const NetworkInterfaceAttribute = S.String;
export interface DescribeNetworkInterfaceAttributeRequest {
  DryRun?: boolean;
  NetworkInterfaceId?: string;
  Attribute?: NetworkInterfaceAttribute;
}
export const DescribeNetworkInterfaceAttributeRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    Attribute: S.optional(NetworkInterfaceAttribute).pipe(
      T.XmlName("attribute"),
      T.Ec2QueryName("Attribute"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeNetworkInterfaceAttributeRequest",
}) as any as S.Schema<DescribeNetworkInterfaceAttributeRequest>;
export interface DescribeNetworkInterfaceAttributeResult {
  Attachment?: NetworkInterfaceAttachment;
  Description?: AttributeValue;
  Groups?: GroupIdentifier[];
  NetworkInterfaceId?: string;
  SourceDestCheck?: AttributeBooleanValue;
  AssociatePublicIpAddress?: boolean;
}
export const DescribeNetworkInterfaceAttributeResult = S.suspend(() =>
  S.Struct({
    Attachment: S.optional(NetworkInterfaceAttachment)
      .pipe(T.XmlName("attachment"), T.Ec2QueryName("Attachment"))
      .annotate({ identifier: "NetworkInterfaceAttachment" }),
    Description: S.optional(AttributeValue)
      .pipe(T.XmlName("description"), T.Ec2QueryName("Description"))
      .annotate({ identifier: "AttributeValue" }),
    Groups: S.optional(GroupIdentifierList).pipe(
      T.XmlName("groupSet"),
      T.Ec2QueryName("GroupSet"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    SourceDestCheck: S.optional(AttributeBooleanValue)
      .pipe(T.XmlName("sourceDestCheck"), T.Ec2QueryName("SourceDestCheck"))
      .annotate({ identifier: "AttributeBooleanValue" }),
    AssociatePublicIpAddress: S.optional(S.Boolean).pipe(
      T.XmlName("associatePublicIpAddress"),
      T.Ec2QueryName("AssociatePublicIpAddress"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeNetworkInterfaceAttributeResult",
}) as any as S.Schema<DescribeNetworkInterfaceAttributeResult>;
export type NetworkInterfacePermissionIdList = string[];
export const NetworkInterfacePermissionIdList = S.Array(S.String);
export interface DescribeNetworkInterfacePermissionsRequest {
  NetworkInterfacePermissionIds?: string[];
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeNetworkInterfacePermissionsRequest = S.suspend(() =>
  S.Struct({
    NetworkInterfacePermissionIds: S.optional(
      NetworkInterfacePermissionIdList,
    ).pipe(T.XmlName("NetworkInterfacePermissionId")),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeNetworkInterfacePermissionsRequest",
}) as any as S.Schema<DescribeNetworkInterfacePermissionsRequest>;
export type NetworkInterfacePermissionList = NetworkInterfacePermission[];
export const NetworkInterfacePermissionList = S.Array(
  NetworkInterfacePermission.pipe(T.XmlName("item")).annotate({
    identifier: "NetworkInterfacePermission",
  }),
);
export interface DescribeNetworkInterfacePermissionsResult {
  NetworkInterfacePermissions?: NetworkInterfacePermission[];
  NextToken?: string;
}
export const DescribeNetworkInterfacePermissionsResult = S.suspend(() =>
  S.Struct({
    NetworkInterfacePermissions: S.optional(
      NetworkInterfacePermissionList,
    ).pipe(
      T.XmlName("networkInterfacePermissions"),
      T.Ec2QueryName("NetworkInterfacePermissions"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeNetworkInterfacePermissionsResult",
}) as any as S.Schema<DescribeNetworkInterfacePermissionsResult>;
export type NetworkInterfaceIdList = string[];
export const NetworkInterfaceIdList = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeNetworkInterfacesRequest {
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
  NetworkInterfaceIds?: string[];
  Filters?: Filter[];
}
export const DescribeNetworkInterfacesRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    NetworkInterfaceIds: S.optional(NetworkInterfaceIdList).pipe(
      T.XmlName("NetworkInterfaceId"),
    ),
    Filters: S.optional(FilterList).pipe(
      T.XmlName("filter"),
      T.Ec2QueryName("Filter"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeNetworkInterfacesRequest",
}) as any as S.Schema<DescribeNetworkInterfacesRequest>;
export type NetworkInterfaceList = NetworkInterface[];
export const NetworkInterfaceList = S.Array(
  NetworkInterface.pipe(T.XmlName("item")).annotate({
    identifier: "NetworkInterface",
  }),
);
export interface DescribeNetworkInterfacesResult {
  NetworkInterfaces?: NetworkInterface[];
  NextToken?: string;
}
export const DescribeNetworkInterfacesResult = S.suspend(() =>
  S.Struct({
    NetworkInterfaces: S.optional(NetworkInterfaceList).pipe(
      T.XmlName("networkInterfaceSet"),
      T.Ec2QueryName("NetworkInterfaceSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeNetworkInterfacesResult",
}) as any as S.Schema<DescribeNetworkInterfacesResult>;
export type OutpostLagIdSet = string[];
export const OutpostLagIdSet = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeOutpostLagsRequest {
  OutpostLagIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeOutpostLagsRequest = S.suspend(() =>
  S.Struct({
    OutpostLagIds: S.optional(OutpostLagIdSet).pipe(T.XmlName("OutpostLagId")),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeOutpostLagsRequest",
}) as any as S.Schema<DescribeOutpostLagsRequest>;
export type ServiceLinkVirtualInterfaceIdSet = string[];
export const ServiceLinkVirtualInterfaceIdSet = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface OutpostLag {
  OutpostArn?: string;
  OwnerId?: string;
  State?: string;
  OutpostLagId?: string;
  LocalGatewayVirtualInterfaceIds?: string[];
  ServiceLinkVirtualInterfaceIds?: string[];
  Tags?: Tag[];
}
export const OutpostLag = S.suspend(() =>
  S.Struct({
    OutpostArn: S.optional(S.String).pipe(
      T.XmlName("outpostArn"),
      T.Ec2QueryName("OutpostArn"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    State: S.optional(S.String).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    OutpostLagId: S.optional(S.String).pipe(
      T.XmlName("outpostLagId"),
      T.Ec2QueryName("OutpostLagId"),
    ),
    LocalGatewayVirtualInterfaceIds: S.optional(
      LocalGatewayVirtualInterfaceIdSet,
    ).pipe(
      T.XmlName("localGatewayVirtualInterfaceIdSet"),
      T.Ec2QueryName("LocalGatewayVirtualInterfaceIdSet"),
    ),
    ServiceLinkVirtualInterfaceIds: S.optional(
      ServiceLinkVirtualInterfaceIdSet,
    ).pipe(
      T.XmlName("serviceLinkVirtualInterfaceIdSet"),
      T.Ec2QueryName("ServiceLinkVirtualInterfaceIdSet"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({ identifier: "OutpostLag" }) as any as S.Schema<OutpostLag>;
export type OutpostLagSet = OutpostLag[];
export const OutpostLagSet = S.Array(
  OutpostLag.pipe(T.XmlName("item")).annotate({ identifier: "OutpostLag" }),
);
export interface DescribeOutpostLagsResult {
  OutpostLags?: OutpostLag[];
  NextToken?: string;
}
export const DescribeOutpostLagsResult = S.suspend(() =>
  S.Struct({
    OutpostLags: S.optional(OutpostLagSet).pipe(
      T.XmlName("outpostLagSet"),
      T.Ec2QueryName("OutpostLagSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeOutpostLagsResult",
}) as any as S.Schema<DescribeOutpostLagsResult>;
export type PlacementGroupIdStringList = string[];
export const PlacementGroupIdStringList = S.Array(
  S.String.pipe(T.XmlName("GroupId")),
);
export type PlacementGroupStringList = string[];
export const PlacementGroupStringList = S.Array(S.String);
export interface DescribePlacementGroupsRequest {
  GroupIds?: string[];
  DryRun?: boolean;
  GroupNames?: string[];
  Filters?: Filter[];
}
export const DescribePlacementGroupsRequest = S.suspend(() =>
  S.Struct({
    GroupIds: S.optional(PlacementGroupIdStringList).pipe(T.XmlName("GroupId")),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    GroupNames: S.optional(PlacementGroupStringList).pipe(
      T.XmlName("groupName"),
      T.Ec2QueryName("GroupName"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribePlacementGroupsRequest",
}) as any as S.Schema<DescribePlacementGroupsRequest>;
export type PlacementGroupList = PlacementGroup[];
export const PlacementGroupList = S.Array(
  PlacementGroup.pipe(T.XmlName("item")).annotate({
    identifier: "PlacementGroup",
  }),
);
export interface DescribePlacementGroupsResult {
  PlacementGroups?: PlacementGroup[];
}
export const DescribePlacementGroupsResult = S.suspend(() =>
  S.Struct({
    PlacementGroups: S.optional(PlacementGroupList).pipe(
      T.XmlName("placementGroupSet"),
      T.Ec2QueryName("PlacementGroupSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribePlacementGroupsResult",
}) as any as S.Schema<DescribePlacementGroupsResult>;
export type PrefixListResourceIdStringList = string[];
export const PrefixListResourceIdStringList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribePrefixListsRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  PrefixListIds?: string[];
}
export const DescribePrefixListsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    PrefixListIds: S.optional(PrefixListResourceIdStringList).pipe(
      T.XmlName("PrefixListId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribePrefixListsRequest",
}) as any as S.Schema<DescribePrefixListsRequest>;
export interface PrefixList {
  Cidrs?: string[];
  PrefixListId?: string;
  PrefixListName?: string;
}
export const PrefixList = S.suspend(() =>
  S.Struct({
    Cidrs: S.optional(ValueStringList).pipe(
      T.XmlName("cidrSet"),
      T.Ec2QueryName("CidrSet"),
    ),
    PrefixListId: S.optional(S.String).pipe(
      T.XmlName("prefixListId"),
      T.Ec2QueryName("PrefixListId"),
    ),
    PrefixListName: S.optional(S.String).pipe(
      T.XmlName("prefixListName"),
      T.Ec2QueryName("PrefixListName"),
    ),
  }),
).annotate({ identifier: "PrefixList" }) as any as S.Schema<PrefixList>;
export type PrefixListSet = PrefixList[];
export const PrefixListSet = S.Array(
  PrefixList.pipe(T.XmlName("item")).annotate({ identifier: "PrefixList" }),
);
export interface DescribePrefixListsResult {
  NextToken?: string;
  PrefixLists?: PrefixList[];
}
export const DescribePrefixListsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    PrefixLists: S.optional(PrefixListSet).pipe(
      T.XmlName("prefixListSet"),
      T.Ec2QueryName("PrefixListSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribePrefixListsResult",
}) as any as S.Schema<DescribePrefixListsResult>;
export type ResourceList = string[];
export const ResourceList = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribePrincipalIdFormatRequest {
  DryRun?: boolean;
  Resources?: string[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribePrincipalIdFormatRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Resources: S.optional(ResourceList).pipe(T.XmlName("Resource")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribePrincipalIdFormatRequest",
}) as any as S.Schema<DescribePrincipalIdFormatRequest>;
export interface PrincipalIdFormat {
  Arn?: string;
  Statuses?: IdFormat[];
}
export const PrincipalIdFormat = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String).pipe(T.XmlName("arn"), T.Ec2QueryName("Arn")),
    Statuses: S.optional(IdFormatList).pipe(
      T.XmlName("statusSet"),
      T.Ec2QueryName("StatusSet"),
    ),
  }),
).annotate({
  identifier: "PrincipalIdFormat",
}) as any as S.Schema<PrincipalIdFormat>;
export type PrincipalIdFormatList = PrincipalIdFormat[];
export const PrincipalIdFormatList = S.Array(
  PrincipalIdFormat.pipe(T.XmlName("item")).annotate({
    identifier: "PrincipalIdFormat",
  }),
);
export interface DescribePrincipalIdFormatResult {
  Principals?: PrincipalIdFormat[];
  NextToken?: string;
}
export const DescribePrincipalIdFormatResult = S.suspend(() =>
  S.Struct({
    Principals: S.optional(PrincipalIdFormatList).pipe(
      T.XmlName("principalSet"),
      T.Ec2QueryName("PrincipalSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribePrincipalIdFormatResult",
}) as any as S.Schema<DescribePrincipalIdFormatResult>;
export type PublicIpv4PoolIdStringList = string[];
export const PublicIpv4PoolIdStringList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribePublicIpv4PoolsRequest {
  PoolIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  Filters?: Filter[];
}
export const DescribePublicIpv4PoolsRequest = S.suspend(() =>
  S.Struct({
    PoolIds: S.optional(PublicIpv4PoolIdStringList).pipe(T.XmlName("PoolId")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribePublicIpv4PoolsRequest",
}) as any as S.Schema<DescribePublicIpv4PoolsRequest>;
export interface PublicIpv4PoolRange {
  FirstAddress?: string;
  LastAddress?: string;
  AddressCount?: number;
  AvailableAddressCount?: number;
}
export const PublicIpv4PoolRange = S.suspend(() =>
  S.Struct({
    FirstAddress: S.optional(S.String).pipe(
      T.XmlName("firstAddress"),
      T.Ec2QueryName("FirstAddress"),
    ),
    LastAddress: S.optional(S.String).pipe(
      T.XmlName("lastAddress"),
      T.Ec2QueryName("LastAddress"),
    ),
    AddressCount: S.optional(S.Number).pipe(
      T.XmlName("addressCount"),
      T.Ec2QueryName("AddressCount"),
    ),
    AvailableAddressCount: S.optional(S.Number).pipe(
      T.XmlName("availableAddressCount"),
      T.Ec2QueryName("AvailableAddressCount"),
    ),
  }),
).annotate({
  identifier: "PublicIpv4PoolRange",
}) as any as S.Schema<PublicIpv4PoolRange>;
export type PublicIpv4PoolRangeSet = PublicIpv4PoolRange[];
export const PublicIpv4PoolRangeSet = S.Array(
  PublicIpv4PoolRange.pipe(T.XmlName("item")).annotate({
    identifier: "PublicIpv4PoolRange",
  }),
);
export interface PublicIpv4Pool {
  PoolId?: string;
  Description?: string;
  PoolAddressRanges?: PublicIpv4PoolRange[];
  TotalAddressCount?: number;
  TotalAvailableAddressCount?: number;
  NetworkBorderGroup?: string;
  Tags?: Tag[];
}
export const PublicIpv4Pool = S.suspend(() =>
  S.Struct({
    PoolId: S.optional(S.String).pipe(
      T.XmlName("poolId"),
      T.Ec2QueryName("PoolId"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    PoolAddressRanges: S.optional(PublicIpv4PoolRangeSet).pipe(
      T.XmlName("poolAddressRangeSet"),
      T.Ec2QueryName("PoolAddressRangeSet"),
    ),
    TotalAddressCount: S.optional(S.Number).pipe(
      T.XmlName("totalAddressCount"),
      T.Ec2QueryName("TotalAddressCount"),
    ),
    TotalAvailableAddressCount: S.optional(S.Number).pipe(
      T.XmlName("totalAvailableAddressCount"),
      T.Ec2QueryName("TotalAvailableAddressCount"),
    ),
    NetworkBorderGroup: S.optional(S.String).pipe(
      T.XmlName("networkBorderGroup"),
      T.Ec2QueryName("NetworkBorderGroup"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({ identifier: "PublicIpv4Pool" }) as any as S.Schema<PublicIpv4Pool>;
export type PublicIpv4PoolSet = PublicIpv4Pool[];
export const PublicIpv4PoolSet = S.Array(
  PublicIpv4Pool.pipe(T.XmlName("item")).annotate({
    identifier: "PublicIpv4Pool",
  }),
);
export interface DescribePublicIpv4PoolsResult {
  PublicIpv4Pools?: PublicIpv4Pool[];
  NextToken?: string;
}
export const DescribePublicIpv4PoolsResult = S.suspend(() =>
  S.Struct({
    PublicIpv4Pools: S.optional(PublicIpv4PoolSet).pipe(
      T.XmlName("publicIpv4PoolSet"),
      T.Ec2QueryName("PublicIpv4PoolSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribePublicIpv4PoolsResult",
}) as any as S.Schema<DescribePublicIpv4PoolsResult>;
export type RegionNameStringList = string[];
export const RegionNameStringList = S.Array(
  S.String.pipe(T.XmlName("RegionName")),
);
export interface DescribeRegionsRequest {
  RegionNames?: string[];
  AllRegions?: boolean;
  DryRun?: boolean;
  Filters?: Filter[];
}
export const DescribeRegionsRequest = S.suspend(() =>
  S.Struct({
    RegionNames: S.optional(RegionNameStringList).pipe(T.XmlName("RegionName")),
    AllRegions: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeRegionsRequest",
}) as any as S.Schema<DescribeRegionsRequest>;
export interface RegionGeography {
  Name?: string;
}
export const RegionGeography = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
  }),
).annotate({
  identifier: "RegionGeography",
}) as any as S.Schema<RegionGeography>;
export type RegionGeographyList = RegionGeography[];
export const RegionGeographyList = S.Array(
  RegionGeography.pipe(T.XmlName("item")).annotate({
    identifier: "RegionGeography",
  }),
);
export interface Region {
  OptInStatus?: string;
  Geography?: RegionGeography[];
  RegionName?: string;
  Endpoint?: string;
}
export const Region = S.suspend(() =>
  S.Struct({
    OptInStatus: S.optional(S.String).pipe(
      T.XmlName("optInStatus"),
      T.Ec2QueryName("OptInStatus"),
    ),
    Geography: S.optional(RegionGeographyList).pipe(
      T.XmlName("geographySet"),
      T.Ec2QueryName("GeographySet"),
    ),
    RegionName: S.optional(S.String).pipe(
      T.XmlName("regionName"),
      T.Ec2QueryName("RegionName"),
    ),
    Endpoint: S.optional(S.String).pipe(
      T.XmlName("regionEndpoint"),
      T.Ec2QueryName("RegionEndpoint"),
    ),
  }),
).annotate({ identifier: "Region" }) as any as S.Schema<Region>;
export type RegionList = Region[];
export const RegionList = S.Array(
  Region.pipe(T.XmlName("item")).annotate({ identifier: "Region" }),
);
export interface DescribeRegionsResult {
  Regions?: Region[];
}
export const DescribeRegionsResult = S.suspend(() =>
  S.Struct({
    Regions: S.optional(RegionList).pipe(
      T.XmlName("regionInfo"),
      T.Ec2QueryName("RegionInfo"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeRegionsResult",
}) as any as S.Schema<DescribeRegionsResult>;
export type ReplaceRootVolumeTaskIds = string[];
export const ReplaceRootVolumeTaskIds = S.Array(
  S.String.pipe(T.XmlName("ReplaceRootVolumeTaskId")),
);
export interface DescribeReplaceRootVolumeTasksRequest {
  ReplaceRootVolumeTaskIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeReplaceRootVolumeTasksRequest = S.suspend(() =>
  S.Struct({
    ReplaceRootVolumeTaskIds: S.optional(ReplaceRootVolumeTaskIds).pipe(
      T.XmlName("ReplaceRootVolumeTaskId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeReplaceRootVolumeTasksRequest",
}) as any as S.Schema<DescribeReplaceRootVolumeTasksRequest>;
export type ReplaceRootVolumeTasks = ReplaceRootVolumeTask[];
export const ReplaceRootVolumeTasks = S.Array(
  ReplaceRootVolumeTask.pipe(T.XmlName("item")).annotate({
    identifier: "ReplaceRootVolumeTask",
  }),
);
export interface DescribeReplaceRootVolumeTasksResult {
  ReplaceRootVolumeTasks?: ReplaceRootVolumeTask[];
  NextToken?: string;
}
export const DescribeReplaceRootVolumeTasksResult = S.suspend(() =>
  S.Struct({
    ReplaceRootVolumeTasks: S.optional(ReplaceRootVolumeTasks).pipe(
      T.XmlName("replaceRootVolumeTaskSet"),
      T.Ec2QueryName("ReplaceRootVolumeTaskSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeReplaceRootVolumeTasksResult",
}) as any as S.Schema<DescribeReplaceRootVolumeTasksResult>;
export type OfferingClassType = "standard" | "convertible" | (string & {});
export const OfferingClassType = S.String;
export type ReservedInstancesIdStringList = string[];
export const ReservedInstancesIdStringList = S.Array(
  S.String.pipe(T.XmlName("ReservedInstancesId")),
);
export type OfferingTypeValues =
  | "Heavy Utilization"
  | "Medium Utilization"
  | "Light Utilization"
  | "No Upfront"
  | "Partial Upfront"
  | "All Upfront"
  | (string & {});
export const OfferingTypeValues = S.String;
export interface DescribeReservedInstancesRequest {
  OfferingClass?: OfferingClassType;
  ReservedInstancesIds?: string[];
  DryRun?: boolean;
  Filters?: Filter[];
  OfferingType?: OfferingTypeValues;
}
export const DescribeReservedInstancesRequest = S.suspend(() =>
  S.Struct({
    OfferingClass: S.optional(OfferingClassType),
    ReservedInstancesIds: S.optional(ReservedInstancesIdStringList).pipe(
      T.XmlName("ReservedInstancesId"),
    ),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    OfferingType: S.optional(OfferingTypeValues).pipe(
      T.XmlName("offeringType"),
      T.Ec2QueryName("OfferingType"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeReservedInstancesRequest",
}) as any as S.Schema<DescribeReservedInstancesRequest>;
export type RecurringChargeFrequency = "Hourly" | (string & {});
export const RecurringChargeFrequency = S.String;
export interface RecurringCharge {
  Amount?: number;
  Frequency?: RecurringChargeFrequency;
}
export const RecurringCharge = S.suspend(() =>
  S.Struct({
    Amount: S.optional(S.Number).pipe(
      T.XmlName("amount"),
      T.Ec2QueryName("Amount"),
    ),
    Frequency: S.optional(RecurringChargeFrequency).pipe(
      T.XmlName("frequency"),
      T.Ec2QueryName("Frequency"),
    ),
  }),
).annotate({
  identifier: "RecurringCharge",
}) as any as S.Schema<RecurringCharge>;
export type RecurringChargesList = RecurringCharge[];
export const RecurringChargesList = S.Array(
  RecurringCharge.pipe(T.XmlName("item")).annotate({
    identifier: "RecurringCharge",
  }),
);
export type Scope = "Availability Zone" | "Region" | (string & {});
export const Scope = S.String;
export type RIProductDescription =
  | "Linux/UNIX"
  | "Linux/UNIX (Amazon VPC)"
  | "Windows"
  | "Windows (Amazon VPC)"
  | "Red Hat Enterprise Linux"
  | "SUSE Linux"
  | "Ubuntu Pro Linux"
  | (string & {});
export const RIProductDescription = S.String;
export type ReservedInstanceState =
  | "payment-pending"
  | "active"
  | "payment-failed"
  | "retired"
  | "queued"
  | "queued-deleted"
  | (string & {});
export const ReservedInstanceState = S.String;
export interface ReservedInstances {
  CurrencyCode?: CurrencyCodeValues;
  InstanceTenancy?: Tenancy;
  OfferingClass?: OfferingClassType;
  OfferingType?: OfferingTypeValues;
  RecurringCharges?: RecurringCharge[];
  Scope?: Scope;
  Tags?: Tag[];
  AvailabilityZoneId?: string;
  ReservedInstancesId?: string;
  InstanceType?: InstanceType;
  AvailabilityZone?: string;
  Start?: Date;
  End?: Date;
  Duration?: number;
  UsagePrice?: number;
  FixedPrice?: number;
  InstanceCount?: number;
  ProductDescription?: RIProductDescription;
  State?: ReservedInstanceState;
}
export const ReservedInstances = S.suspend(() =>
  S.Struct({
    CurrencyCode: S.optional(CurrencyCodeValues).pipe(
      T.XmlName("currencyCode"),
      T.Ec2QueryName("CurrencyCode"),
    ),
    InstanceTenancy: S.optional(Tenancy).pipe(
      T.XmlName("instanceTenancy"),
      T.Ec2QueryName("InstanceTenancy"),
    ),
    OfferingClass: S.optional(OfferingClassType).pipe(
      T.XmlName("offeringClass"),
      T.Ec2QueryName("OfferingClass"),
    ),
    OfferingType: S.optional(OfferingTypeValues).pipe(
      T.XmlName("offeringType"),
      T.Ec2QueryName("OfferingType"),
    ),
    RecurringCharges: S.optional(RecurringChargesList).pipe(
      T.XmlName("recurringCharges"),
      T.Ec2QueryName("RecurringCharges"),
    ),
    Scope: S.optional(Scope).pipe(T.XmlName("scope"), T.Ec2QueryName("Scope")),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    ReservedInstancesId: S.optional(S.String).pipe(
      T.XmlName("reservedInstancesId"),
      T.Ec2QueryName("ReservedInstancesId"),
    ),
    InstanceType: S.optional(InstanceType).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    Start: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("start"), T.Ec2QueryName("Start")),
    End: S.optional(T.DateFromString.pipe(T.TimestampFormat("date-time"))).pipe(
      T.XmlName("end"),
      T.Ec2QueryName("End"),
    ),
    Duration: S.optional(S.Number).pipe(
      T.XmlName("duration"),
      T.Ec2QueryName("Duration"),
    ),
    UsagePrice: S.optional(S.Number).pipe(
      T.XmlName("usagePrice"),
      T.Ec2QueryName("UsagePrice"),
    ),
    FixedPrice: S.optional(S.Number).pipe(
      T.XmlName("fixedPrice"),
      T.Ec2QueryName("FixedPrice"),
    ),
    InstanceCount: S.optional(S.Number).pipe(
      T.XmlName("instanceCount"),
      T.Ec2QueryName("InstanceCount"),
    ),
    ProductDescription: S.optional(RIProductDescription).pipe(
      T.XmlName("productDescription"),
      T.Ec2QueryName("ProductDescription"),
    ),
    State: S.optional(ReservedInstanceState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({
  identifier: "ReservedInstances",
}) as any as S.Schema<ReservedInstances>;
export type ReservedInstancesList = ReservedInstances[];
export const ReservedInstancesList = S.Array(
  ReservedInstances.pipe(T.XmlName("item")).annotate({
    identifier: "ReservedInstances",
  }),
);
export interface DescribeReservedInstancesResult {
  ReservedInstances?: ReservedInstances[];
}
export const DescribeReservedInstancesResult = S.suspend(() =>
  S.Struct({
    ReservedInstances: S.optional(ReservedInstancesList).pipe(
      T.XmlName("reservedInstancesSet"),
      T.Ec2QueryName("ReservedInstancesSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeReservedInstancesResult",
}) as any as S.Schema<DescribeReservedInstancesResult>;
export interface DescribeReservedInstancesListingsRequest {
  ReservedInstancesId?: string;
  ReservedInstancesListingId?: string;
  Filters?: Filter[];
}
export const DescribeReservedInstancesListingsRequest = S.suspend(() =>
  S.Struct({
    ReservedInstancesId: S.optional(S.String).pipe(
      T.XmlName("reservedInstancesId"),
      T.Ec2QueryName("ReservedInstancesId"),
    ),
    ReservedInstancesListingId: S.optional(S.String).pipe(
      T.XmlName("reservedInstancesListingId"),
      T.Ec2QueryName("ReservedInstancesListingId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeReservedInstancesListingsRequest",
}) as any as S.Schema<DescribeReservedInstancesListingsRequest>;
export interface DescribeReservedInstancesListingsResult {
  ReservedInstancesListings?: ReservedInstancesListing[];
}
export const DescribeReservedInstancesListingsResult = S.suspend(() =>
  S.Struct({
    ReservedInstancesListings: S.optional(ReservedInstancesListingList).pipe(
      T.XmlName("reservedInstancesListingsSet"),
      T.Ec2QueryName("ReservedInstancesListingsSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeReservedInstancesListingsResult",
}) as any as S.Schema<DescribeReservedInstancesListingsResult>;
export type ReservedInstancesModificationIdStringList = string[];
export const ReservedInstancesModificationIdStringList = S.Array(
  S.String.pipe(T.XmlName("ReservedInstancesModificationId")),
);
export interface DescribeReservedInstancesModificationsRequest {
  ReservedInstancesModificationIds?: string[];
  NextToken?: string;
  Filters?: Filter[];
}
export const DescribeReservedInstancesModificationsRequest = S.suspend(() =>
  S.Struct({
    ReservedInstancesModificationIds: S.optional(
      ReservedInstancesModificationIdStringList,
    ).pipe(T.XmlName("ReservedInstancesModificationId")),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeReservedInstancesModificationsRequest",
}) as any as S.Schema<DescribeReservedInstancesModificationsRequest>;
export interface ReservedInstancesConfiguration {
  AvailabilityZone?: string;
  InstanceCount?: number;
  InstanceType?: InstanceType;
  Platform?: string;
  Scope?: Scope;
  AvailabilityZoneId?: string;
}
export const ReservedInstancesConfiguration = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    InstanceCount: S.optional(S.Number).pipe(
      T.XmlName("instanceCount"),
      T.Ec2QueryName("InstanceCount"),
    ),
    InstanceType: S.optional(InstanceType).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    Platform: S.optional(S.String).pipe(
      T.XmlName("platform"),
      T.Ec2QueryName("Platform"),
    ),
    Scope: S.optional(Scope).pipe(T.XmlName("scope"), T.Ec2QueryName("Scope")),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
  }),
).annotate({
  identifier: "ReservedInstancesConfiguration",
}) as any as S.Schema<ReservedInstancesConfiguration>;
export interface ReservedInstancesModificationResult {
  ReservedInstancesId?: string;
  TargetConfiguration?: ReservedInstancesConfiguration;
}
export const ReservedInstancesModificationResult = S.suspend(() =>
  S.Struct({
    ReservedInstancesId: S.optional(S.String).pipe(
      T.XmlName("reservedInstancesId"),
      T.Ec2QueryName("ReservedInstancesId"),
    ),
    TargetConfiguration: S.optional(ReservedInstancesConfiguration)
      .pipe(
        T.XmlName("targetConfiguration"),
        T.Ec2QueryName("TargetConfiguration"),
      )
      .annotate({ identifier: "ReservedInstancesConfiguration" }),
  }),
).annotate({
  identifier: "ReservedInstancesModificationResult",
}) as any as S.Schema<ReservedInstancesModificationResult>;
export type ReservedInstancesModificationResultList =
  ReservedInstancesModificationResult[];
export const ReservedInstancesModificationResultList = S.Array(
  ReservedInstancesModificationResult.pipe(T.XmlName("item")).annotate({
    identifier: "ReservedInstancesModificationResult",
  }),
);
export interface ReservedInstancesId {
  ReservedInstancesId?: string;
}
export const ReservedInstancesId = S.suspend(() =>
  S.Struct({
    ReservedInstancesId: S.optional(S.String).pipe(
      T.XmlName("reservedInstancesId"),
      T.Ec2QueryName("ReservedInstancesId"),
    ),
  }),
).annotate({
  identifier: "ReservedInstancesId",
}) as any as S.Schema<ReservedInstancesId>;
export type ReservedIntancesIds = ReservedInstancesId[];
export const ReservedIntancesIds = S.Array(
  ReservedInstancesId.pipe(T.XmlName("item")).annotate({
    identifier: "ReservedInstancesId",
  }),
);
export interface ReservedInstancesModification {
  ClientToken?: string;
  CreateDate?: Date;
  EffectiveDate?: Date;
  ModificationResults?: ReservedInstancesModificationResult[];
  ReservedInstancesIds?: ReservedInstancesId[];
  ReservedInstancesModificationId?: string;
  Status?: string;
  StatusMessage?: string;
  UpdateDate?: Date;
}
export const ReservedInstancesModification = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
    CreateDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createDate"), T.Ec2QueryName("CreateDate")),
    EffectiveDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("effectiveDate"), T.Ec2QueryName("EffectiveDate")),
    ModificationResults: S.optional(
      ReservedInstancesModificationResultList,
    ).pipe(
      T.XmlName("modificationResultSet"),
      T.Ec2QueryName("ModificationResultSet"),
    ),
    ReservedInstancesIds: S.optional(ReservedIntancesIds).pipe(
      T.XmlName("reservedInstancesSet"),
      T.Ec2QueryName("ReservedInstancesSet"),
    ),
    ReservedInstancesModificationId: S.optional(S.String).pipe(
      T.XmlName("reservedInstancesModificationId"),
      T.Ec2QueryName("ReservedInstancesModificationId"),
    ),
    Status: S.optional(S.String).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    UpdateDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("updateDate"), T.Ec2QueryName("UpdateDate")),
  }),
).annotate({
  identifier: "ReservedInstancesModification",
}) as any as S.Schema<ReservedInstancesModification>;
export type ReservedInstancesModificationList = ReservedInstancesModification[];
export const ReservedInstancesModificationList = S.Array(
  ReservedInstancesModification.pipe(T.XmlName("item")).annotate({
    identifier: "ReservedInstancesModification",
  }),
);
export interface DescribeReservedInstancesModificationsResult {
  NextToken?: string;
  ReservedInstancesModifications?: ReservedInstancesModification[];
}
export const DescribeReservedInstancesModificationsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    ReservedInstancesModifications: S.optional(
      ReservedInstancesModificationList,
    ).pipe(
      T.XmlName("reservedInstancesModificationsSet"),
      T.Ec2QueryName("ReservedInstancesModificationsSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeReservedInstancesModificationsResult",
}) as any as S.Schema<DescribeReservedInstancesModificationsResult>;
export type ReservedInstancesOfferingIdStringList = string[];
export const ReservedInstancesOfferingIdStringList = S.Array(S.String);
export interface DescribeReservedInstancesOfferingsRequest {
  AvailabilityZone?: string;
  IncludeMarketplace?: boolean;
  InstanceType?: InstanceType;
  MaxDuration?: number;
  MaxInstanceCount?: number;
  MinDuration?: number;
  OfferingClass?: OfferingClassType;
  ProductDescription?: RIProductDescription;
  ReservedInstancesOfferingIds?: string[];
  AvailabilityZoneId?: string;
  DryRun?: boolean;
  Filters?: Filter[];
  InstanceTenancy?: Tenancy;
  OfferingType?: OfferingTypeValues;
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeReservedInstancesOfferingsRequest = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String),
    IncludeMarketplace: S.optional(S.Boolean),
    InstanceType: S.optional(InstanceType),
    MaxDuration: S.optional(S.Number),
    MaxInstanceCount: S.optional(S.Number),
    MinDuration: S.optional(S.Number),
    OfferingClass: S.optional(OfferingClassType),
    ProductDescription: S.optional(RIProductDescription),
    ReservedInstancesOfferingIds: S.optional(
      ReservedInstancesOfferingIdStringList,
    ).pipe(T.XmlName("ReservedInstancesOfferingId")),
    AvailabilityZoneId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    InstanceTenancy: S.optional(Tenancy).pipe(
      T.XmlName("instanceTenancy"),
      T.Ec2QueryName("InstanceTenancy"),
    ),
    OfferingType: S.optional(OfferingTypeValues).pipe(
      T.XmlName("offeringType"),
      T.Ec2QueryName("OfferingType"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    MaxResults: S.optional(S.Number).pipe(
      T.XmlName("maxResults"),
      T.Ec2QueryName("MaxResults"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeReservedInstancesOfferingsRequest",
}) as any as S.Schema<DescribeReservedInstancesOfferingsRequest>;
export interface PricingDetail {
  Count?: number;
  Price?: number;
}
export const PricingDetail = S.suspend(() =>
  S.Struct({
    Count: S.optional(S.Number).pipe(
      T.XmlName("count"),
      T.Ec2QueryName("Count"),
    ),
    Price: S.optional(S.Number).pipe(
      T.XmlName("price"),
      T.Ec2QueryName("Price"),
    ),
  }),
).annotate({ identifier: "PricingDetail" }) as any as S.Schema<PricingDetail>;
export type PricingDetailsList = PricingDetail[];
export const PricingDetailsList = S.Array(
  PricingDetail.pipe(T.XmlName("item")).annotate({
    identifier: "PricingDetail",
  }),
);
export interface ReservedInstancesOffering {
  CurrencyCode?: CurrencyCodeValues;
  InstanceTenancy?: Tenancy;
  Marketplace?: boolean;
  OfferingClass?: OfferingClassType;
  OfferingType?: OfferingTypeValues;
  PricingDetails?: PricingDetail[];
  RecurringCharges?: RecurringCharge[];
  Scope?: Scope;
  AvailabilityZoneId?: string;
  ReservedInstancesOfferingId?: string;
  InstanceType?: InstanceType;
  AvailabilityZone?: string;
  Duration?: number;
  UsagePrice?: number;
  FixedPrice?: number;
  ProductDescription?: RIProductDescription;
}
export const ReservedInstancesOffering = S.suspend(() =>
  S.Struct({
    CurrencyCode: S.optional(CurrencyCodeValues).pipe(
      T.XmlName("currencyCode"),
      T.Ec2QueryName("CurrencyCode"),
    ),
    InstanceTenancy: S.optional(Tenancy).pipe(
      T.XmlName("instanceTenancy"),
      T.Ec2QueryName("InstanceTenancy"),
    ),
    Marketplace: S.optional(S.Boolean).pipe(
      T.XmlName("marketplace"),
      T.Ec2QueryName("Marketplace"),
    ),
    OfferingClass: S.optional(OfferingClassType).pipe(
      T.XmlName("offeringClass"),
      T.Ec2QueryName("OfferingClass"),
    ),
    OfferingType: S.optional(OfferingTypeValues).pipe(
      T.XmlName("offeringType"),
      T.Ec2QueryName("OfferingType"),
    ),
    PricingDetails: S.optional(PricingDetailsList).pipe(
      T.XmlName("pricingDetailsSet"),
      T.Ec2QueryName("PricingDetailsSet"),
    ),
    RecurringCharges: S.optional(RecurringChargesList).pipe(
      T.XmlName("recurringCharges"),
      T.Ec2QueryName("RecurringCharges"),
    ),
    Scope: S.optional(Scope).pipe(T.XmlName("scope"), T.Ec2QueryName("Scope")),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    ReservedInstancesOfferingId: S.optional(S.String).pipe(
      T.XmlName("reservedInstancesOfferingId"),
      T.Ec2QueryName("ReservedInstancesOfferingId"),
    ),
    InstanceType: S.optional(InstanceType).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    Duration: S.optional(S.Number).pipe(
      T.XmlName("duration"),
      T.Ec2QueryName("Duration"),
    ),
    UsagePrice: S.optional(S.Number).pipe(
      T.XmlName("usagePrice"),
      T.Ec2QueryName("UsagePrice"),
    ),
    FixedPrice: S.optional(S.Number).pipe(
      T.XmlName("fixedPrice"),
      T.Ec2QueryName("FixedPrice"),
    ),
    ProductDescription: S.optional(RIProductDescription).pipe(
      T.XmlName("productDescription"),
      T.Ec2QueryName("ProductDescription"),
    ),
  }),
).annotate({
  identifier: "ReservedInstancesOffering",
}) as any as S.Schema<ReservedInstancesOffering>;
export type ReservedInstancesOfferingList = ReservedInstancesOffering[];
export const ReservedInstancesOfferingList = S.Array(
  ReservedInstancesOffering.pipe(T.XmlName("item")).annotate({
    identifier: "ReservedInstancesOffering",
  }),
);
export interface DescribeReservedInstancesOfferingsResult {
  NextToken?: string;
  ReservedInstancesOfferings?: ReservedInstancesOffering[];
}
export const DescribeReservedInstancesOfferingsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    ReservedInstancesOfferings: S.optional(ReservedInstancesOfferingList).pipe(
      T.XmlName("reservedInstancesOfferingsSet"),
      T.Ec2QueryName("ReservedInstancesOfferingsSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeReservedInstancesOfferingsResult",
}) as any as S.Schema<DescribeReservedInstancesOfferingsResult>;
export type RouteServerEndpointIdsList = string[];
export const RouteServerEndpointIdsList = S.Array(S.String);
export interface DescribeRouteServerEndpointsRequest {
  RouteServerEndpointIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeRouteServerEndpointsRequest = S.suspend(() =>
  S.Struct({
    RouteServerEndpointIds: S.optional(RouteServerEndpointIdsList).pipe(
      T.XmlName("RouteServerEndpointId"),
    ),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeRouteServerEndpointsRequest",
}) as any as S.Schema<DescribeRouteServerEndpointsRequest>;
export type RouteServerEndpointsList = RouteServerEndpoint[];
export const RouteServerEndpointsList = S.Array(
  RouteServerEndpoint.pipe(T.XmlName("item")).annotate({
    identifier: "RouteServerEndpoint",
  }),
);
export interface DescribeRouteServerEndpointsResult {
  RouteServerEndpoints?: RouteServerEndpoint[];
  NextToken?: string;
}
export const DescribeRouteServerEndpointsResult = S.suspend(() =>
  S.Struct({
    RouteServerEndpoints: S.optional(RouteServerEndpointsList).pipe(
      T.XmlName("routeServerEndpointSet"),
      T.Ec2QueryName("RouteServerEndpointSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeRouteServerEndpointsResult",
}) as any as S.Schema<DescribeRouteServerEndpointsResult>;
export type RouteServerPeerIdsList = string[];
export const RouteServerPeerIdsList = S.Array(S.String);
export interface DescribeRouteServerPeersRequest {
  RouteServerPeerIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeRouteServerPeersRequest = S.suspend(() =>
  S.Struct({
    RouteServerPeerIds: S.optional(RouteServerPeerIdsList).pipe(
      T.XmlName("RouteServerPeerId"),
    ),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeRouteServerPeersRequest",
}) as any as S.Schema<DescribeRouteServerPeersRequest>;
export type RouteServerPeersList = RouteServerPeer[];
export const RouteServerPeersList = S.Array(
  RouteServerPeer.pipe(T.XmlName("item")).annotate({
    identifier: "RouteServerPeer",
  }),
);
export interface DescribeRouteServerPeersResult {
  RouteServerPeers?: RouteServerPeer[];
  NextToken?: string;
}
export const DescribeRouteServerPeersResult = S.suspend(() =>
  S.Struct({
    RouteServerPeers: S.optional(RouteServerPeersList).pipe(
      T.XmlName("routeServerPeerSet"),
      T.Ec2QueryName("RouteServerPeerSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeRouteServerPeersResult",
}) as any as S.Schema<DescribeRouteServerPeersResult>;
export type RouteServerIdsList = string[];
export const RouteServerIdsList = S.Array(S.String);
export interface DescribeRouteServersRequest {
  RouteServerIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeRouteServersRequest = S.suspend(() =>
  S.Struct({
    RouteServerIds: S.optional(RouteServerIdsList).pipe(
      T.XmlName("RouteServerId"),
    ),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeRouteServersRequest",
}) as any as S.Schema<DescribeRouteServersRequest>;
export type RouteServersList = RouteServer[];
export const RouteServersList = S.Array(
  RouteServer.pipe(T.XmlName("item")).annotate({ identifier: "RouteServer" }),
);
export interface DescribeRouteServersResult {
  RouteServers?: RouteServer[];
  NextToken?: string;
}
export const DescribeRouteServersResult = S.suspend(() =>
  S.Struct({
    RouteServers: S.optional(RouteServersList).pipe(
      T.XmlName("routeServerSet"),
      T.Ec2QueryName("RouteServerSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeRouteServersResult",
}) as any as S.Schema<DescribeRouteServersResult>;
export type RouteTableIdStringList = string[];
export const RouteTableIdStringList = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeRouteTablesRequest {
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
  RouteTableIds?: string[];
  Filters?: Filter[];
}
export const DescribeRouteTablesRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    RouteTableIds: S.optional(RouteTableIdStringList).pipe(
      T.XmlName("RouteTableId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeRouteTablesRequest",
}) as any as S.Schema<DescribeRouteTablesRequest>;
export type RouteTableList = RouteTable[];
export const RouteTableList = S.Array(
  RouteTable.pipe(T.XmlName("item")).annotate({ identifier: "RouteTable" }),
);
export interface DescribeRouteTablesResult {
  RouteTables?: RouteTable[];
  NextToken?: string;
}
export const DescribeRouteTablesResult = S.suspend(() =>
  S.Struct({
    RouteTables: S.optional(RouteTableList).pipe(
      T.XmlName("routeTableSet"),
      T.Ec2QueryName("RouteTableSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeRouteTablesResult",
}) as any as S.Schema<DescribeRouteTablesResult>;
export interface SlotDateTimeRangeRequest {
  EarliestTime?: Date;
  LatestTime?: Date;
}
export const SlotDateTimeRangeRequest = S.suspend(() =>
  S.Struct({
    EarliestTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    LatestTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
  }),
).annotate({
  identifier: "SlotDateTimeRangeRequest",
}) as any as S.Schema<SlotDateTimeRangeRequest>;
export type OccurrenceDayRequestSet = number[];
export const OccurrenceDayRequestSet = S.Array(
  S.Number.pipe(T.XmlName("OccurenceDay")),
);
export interface ScheduledInstanceRecurrenceRequest {
  Frequency?: string;
  Interval?: number;
  OccurrenceDays?: number[];
  OccurrenceRelativeToEnd?: boolean;
  OccurrenceUnit?: string;
}
export const ScheduledInstanceRecurrenceRequest = S.suspend(() =>
  S.Struct({
    Frequency: S.optional(S.String),
    Interval: S.optional(S.Number),
    OccurrenceDays: S.optional(OccurrenceDayRequestSet).pipe(
      T.XmlName("OccurrenceDay"),
    ),
    OccurrenceRelativeToEnd: S.optional(S.Boolean),
    OccurrenceUnit: S.optional(S.String),
  }),
).annotate({
  identifier: "ScheduledInstanceRecurrenceRequest",
}) as any as S.Schema<ScheduledInstanceRecurrenceRequest>;
export interface DescribeScheduledInstanceAvailabilityRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  FirstSlotStartTimeRange?: SlotDateTimeRangeRequest;
  MaxResults?: number;
  MaxSlotDurationInHours?: number;
  MinSlotDurationInHours?: number;
  NextToken?: string;
  Recurrence?: ScheduledInstanceRecurrenceRequest;
}
export const DescribeScheduledInstanceAvailabilityRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    FirstSlotStartTimeRange: S.optional(SlotDateTimeRangeRequest),
    MaxResults: S.optional(S.Number),
    MaxSlotDurationInHours: S.optional(S.Number),
    MinSlotDurationInHours: S.optional(S.Number),
    NextToken: S.optional(S.String),
    Recurrence: S.optional(ScheduledInstanceRecurrenceRequest),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeScheduledInstanceAvailabilityRequest",
}) as any as S.Schema<DescribeScheduledInstanceAvailabilityRequest>;
export type OccurrenceDaySet = number[];
export const OccurrenceDaySet = S.Array(S.Number.pipe(T.XmlName("item")));
export interface ScheduledInstanceRecurrence {
  Frequency?: string;
  Interval?: number;
  OccurrenceDaySet?: number[];
  OccurrenceRelativeToEnd?: boolean;
  OccurrenceUnit?: string;
}
export const ScheduledInstanceRecurrence = S.suspend(() =>
  S.Struct({
    Frequency: S.optional(S.String).pipe(
      T.XmlName("frequency"),
      T.Ec2QueryName("Frequency"),
    ),
    Interval: S.optional(S.Number).pipe(
      T.XmlName("interval"),
      T.Ec2QueryName("Interval"),
    ),
    OccurrenceDaySet: S.optional(OccurrenceDaySet).pipe(
      T.XmlName("occurrenceDaySet"),
      T.Ec2QueryName("OccurrenceDaySet"),
    ),
    OccurrenceRelativeToEnd: S.optional(S.Boolean).pipe(
      T.XmlName("occurrenceRelativeToEnd"),
      T.Ec2QueryName("OccurrenceRelativeToEnd"),
    ),
    OccurrenceUnit: S.optional(S.String).pipe(
      T.XmlName("occurrenceUnit"),
      T.Ec2QueryName("OccurrenceUnit"),
    ),
  }),
).annotate({
  identifier: "ScheduledInstanceRecurrence",
}) as any as S.Schema<ScheduledInstanceRecurrence>;
export interface ScheduledInstanceAvailability {
  AvailabilityZone?: string;
  AvailableInstanceCount?: number;
  FirstSlotStartTime?: Date;
  HourlyPrice?: string;
  InstanceType?: string;
  MaxTermDurationInDays?: number;
  MinTermDurationInDays?: number;
  NetworkPlatform?: string;
  Platform?: string;
  PurchaseToken?: string;
  Recurrence?: ScheduledInstanceRecurrence;
  SlotDurationInHours?: number;
  TotalScheduledInstanceHours?: number;
}
export const ScheduledInstanceAvailability = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailableInstanceCount: S.optional(S.Number).pipe(
      T.XmlName("availableInstanceCount"),
      T.Ec2QueryName("AvailableInstanceCount"),
    ),
    FirstSlotStartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("firstSlotStartTime"),
      T.Ec2QueryName("FirstSlotStartTime"),
    ),
    HourlyPrice: S.optional(S.String).pipe(
      T.XmlName("hourlyPrice"),
      T.Ec2QueryName("HourlyPrice"),
    ),
    InstanceType: S.optional(S.String).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    MaxTermDurationInDays: S.optional(S.Number).pipe(
      T.XmlName("maxTermDurationInDays"),
      T.Ec2QueryName("MaxTermDurationInDays"),
    ),
    MinTermDurationInDays: S.optional(S.Number).pipe(
      T.XmlName("minTermDurationInDays"),
      T.Ec2QueryName("MinTermDurationInDays"),
    ),
    NetworkPlatform: S.optional(S.String).pipe(
      T.XmlName("networkPlatform"),
      T.Ec2QueryName("NetworkPlatform"),
    ),
    Platform: S.optional(S.String).pipe(
      T.XmlName("platform"),
      T.Ec2QueryName("Platform"),
    ),
    PurchaseToken: S.optional(S.String).pipe(
      T.XmlName("purchaseToken"),
      T.Ec2QueryName("PurchaseToken"),
    ),
    Recurrence: S.optional(ScheduledInstanceRecurrence)
      .pipe(T.XmlName("recurrence"), T.Ec2QueryName("Recurrence"))
      .annotate({ identifier: "ScheduledInstanceRecurrence" }),
    SlotDurationInHours: S.optional(S.Number).pipe(
      T.XmlName("slotDurationInHours"),
      T.Ec2QueryName("SlotDurationInHours"),
    ),
    TotalScheduledInstanceHours: S.optional(S.Number).pipe(
      T.XmlName("totalScheduledInstanceHours"),
      T.Ec2QueryName("TotalScheduledInstanceHours"),
    ),
  }),
).annotate({
  identifier: "ScheduledInstanceAvailability",
}) as any as S.Schema<ScheduledInstanceAvailability>;
export type ScheduledInstanceAvailabilitySet = ScheduledInstanceAvailability[];
export const ScheduledInstanceAvailabilitySet = S.Array(
  ScheduledInstanceAvailability.pipe(T.XmlName("item")).annotate({
    identifier: "ScheduledInstanceAvailability",
  }),
);
export interface DescribeScheduledInstanceAvailabilityResult {
  NextToken?: string;
  ScheduledInstanceAvailabilitySet?: ScheduledInstanceAvailability[];
}
export const DescribeScheduledInstanceAvailabilityResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    ScheduledInstanceAvailabilitySet: S.optional(
      ScheduledInstanceAvailabilitySet,
    ).pipe(
      T.XmlName("scheduledInstanceAvailabilitySet"),
      T.Ec2QueryName("ScheduledInstanceAvailabilitySet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeScheduledInstanceAvailabilityResult",
}) as any as S.Schema<DescribeScheduledInstanceAvailabilityResult>;
export type ScheduledInstanceIdRequestSet = string[];
export const ScheduledInstanceIdRequestSet = S.Array(
  S.String.pipe(T.XmlName("ScheduledInstanceId")),
);
export interface SlotStartTimeRangeRequest {
  EarliestTime?: Date;
  LatestTime?: Date;
}
export const SlotStartTimeRangeRequest = S.suspend(() =>
  S.Struct({
    EarliestTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    LatestTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
  }),
).annotate({
  identifier: "SlotStartTimeRangeRequest",
}) as any as S.Schema<SlotStartTimeRangeRequest>;
export interface DescribeScheduledInstancesRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  ScheduledInstanceIds?: string[];
  SlotStartTimeRange?: SlotStartTimeRangeRequest;
}
export const DescribeScheduledInstancesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    ScheduledInstanceIds: S.optional(ScheduledInstanceIdRequestSet).pipe(
      T.XmlName("ScheduledInstanceId"),
    ),
    SlotStartTimeRange: S.optional(SlotStartTimeRangeRequest),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeScheduledInstancesRequest",
}) as any as S.Schema<DescribeScheduledInstancesRequest>;
export interface ScheduledInstance {
  AvailabilityZone?: string;
  CreateDate?: Date;
  HourlyPrice?: string;
  InstanceCount?: number;
  InstanceType?: string;
  NetworkPlatform?: string;
  NextSlotStartTime?: Date;
  Platform?: string;
  PreviousSlotEndTime?: Date;
  Recurrence?: ScheduledInstanceRecurrence;
  ScheduledInstanceId?: string;
  SlotDurationInHours?: number;
  TermEndDate?: Date;
  TermStartDate?: Date;
  TotalScheduledInstanceHours?: number;
}
export const ScheduledInstance = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    CreateDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createDate"), T.Ec2QueryName("CreateDate")),
    HourlyPrice: S.optional(S.String).pipe(
      T.XmlName("hourlyPrice"),
      T.Ec2QueryName("HourlyPrice"),
    ),
    InstanceCount: S.optional(S.Number).pipe(
      T.XmlName("instanceCount"),
      T.Ec2QueryName("InstanceCount"),
    ),
    InstanceType: S.optional(S.String).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    NetworkPlatform: S.optional(S.String).pipe(
      T.XmlName("networkPlatform"),
      T.Ec2QueryName("NetworkPlatform"),
    ),
    NextSlotStartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("nextSlotStartTime"), T.Ec2QueryName("NextSlotStartTime")),
    Platform: S.optional(S.String).pipe(
      T.XmlName("platform"),
      T.Ec2QueryName("Platform"),
    ),
    PreviousSlotEndTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("previousSlotEndTime"),
      T.Ec2QueryName("PreviousSlotEndTime"),
    ),
    Recurrence: S.optional(ScheduledInstanceRecurrence)
      .pipe(T.XmlName("recurrence"), T.Ec2QueryName("Recurrence"))
      .annotate({ identifier: "ScheduledInstanceRecurrence" }),
    ScheduledInstanceId: S.optional(S.String).pipe(
      T.XmlName("scheduledInstanceId"),
      T.Ec2QueryName("ScheduledInstanceId"),
    ),
    SlotDurationInHours: S.optional(S.Number).pipe(
      T.XmlName("slotDurationInHours"),
      T.Ec2QueryName("SlotDurationInHours"),
    ),
    TermEndDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("termEndDate"), T.Ec2QueryName("TermEndDate")),
    TermStartDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("termStartDate"), T.Ec2QueryName("TermStartDate")),
    TotalScheduledInstanceHours: S.optional(S.Number).pipe(
      T.XmlName("totalScheduledInstanceHours"),
      T.Ec2QueryName("TotalScheduledInstanceHours"),
    ),
  }),
).annotate({
  identifier: "ScheduledInstance",
}) as any as S.Schema<ScheduledInstance>;
export type ScheduledInstanceSet = ScheduledInstance[];
export const ScheduledInstanceSet = S.Array(
  ScheduledInstance.pipe(T.XmlName("item")).annotate({
    identifier: "ScheduledInstance",
  }),
);
export interface DescribeScheduledInstancesResult {
  NextToken?: string;
  ScheduledInstanceSet?: ScheduledInstance[];
}
export const DescribeScheduledInstancesResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    ScheduledInstanceSet: S.optional(ScheduledInstanceSet).pipe(
      T.XmlName("scheduledInstanceSet"),
      T.Ec2QueryName("ScheduledInstanceSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeScheduledInstancesResult",
}) as any as S.Schema<DescribeScheduledInstancesResult>;
export type SecondaryInterfaceIdList = string[];
export const SecondaryInterfaceIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeSecondaryInterfacesRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  SecondaryInterfaceIds?: string[];
}
export const DescribeSecondaryInterfacesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    SecondaryInterfaceIds: S.optional(SecondaryInterfaceIdList).pipe(
      T.XmlName("SecondaryInterfaceId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSecondaryInterfacesRequest",
}) as any as S.Schema<DescribeSecondaryInterfacesRequest>;
export interface SecondaryInterfaceAttachment {
  AttachmentId?: string;
  AttachTime?: Date;
  DeleteOnTermination?: boolean;
  DeviceIndex?: number;
  InstanceId?: string;
  InstanceOwnerId?: string;
  NetworkCardIndex?: number;
  Status?: AttachmentStatus;
}
export const SecondaryInterfaceAttachment = S.suspend(() =>
  S.Struct({
    AttachmentId: S.optional(S.String).pipe(
      T.XmlName("attachmentId"),
      T.Ec2QueryName("AttachmentId"),
    ),
    AttachTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("attachTime"), T.Ec2QueryName("AttachTime")),
    DeleteOnTermination: S.optional(S.Boolean).pipe(
      T.XmlName("deleteOnTermination"),
      T.Ec2QueryName("DeleteOnTermination"),
    ),
    DeviceIndex: S.optional(S.Number).pipe(
      T.XmlName("deviceIndex"),
      T.Ec2QueryName("DeviceIndex"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    InstanceOwnerId: S.optional(S.String).pipe(
      T.XmlName("instanceOwnerId"),
      T.Ec2QueryName("InstanceOwnerId"),
    ),
    NetworkCardIndex: S.optional(S.Number).pipe(
      T.XmlName("networkCardIndex"),
      T.Ec2QueryName("NetworkCardIndex"),
    ),
    Status: S.optional(AttachmentStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
  }),
).annotate({
  identifier: "SecondaryInterfaceAttachment",
}) as any as S.Schema<SecondaryInterfaceAttachment>;
export interface SecondaryInterfaceIpv4Address {
  PrivateIpAddress?: string;
}
export const SecondaryInterfaceIpv4Address = S.suspend(() =>
  S.Struct({
    PrivateIpAddress: S.optional(S.String).pipe(
      T.XmlName("privateIpAddress"),
      T.Ec2QueryName("PrivateIpAddress"),
    ),
  }),
).annotate({
  identifier: "SecondaryInterfaceIpv4Address",
}) as any as S.Schema<SecondaryInterfaceIpv4Address>;
export type SecondaryInterfaceIpv4AddressList = SecondaryInterfaceIpv4Address[];
export const SecondaryInterfaceIpv4AddressList = S.Array(
  SecondaryInterfaceIpv4Address.pipe(T.XmlName("item")).annotate({
    identifier: "SecondaryInterfaceIpv4Address",
  }),
);
export interface SecondaryInterface {
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  Attachment?: SecondaryInterfaceAttachment;
  MacAddress?: string;
  OwnerId?: string;
  PrivateIpv4Addresses?: SecondaryInterfaceIpv4Address[];
  SecondaryInterfaceId?: string;
  SecondaryInterfaceArn?: string;
  SecondaryInterfaceType?: SecondaryInterfaceType;
  SecondarySubnetId?: string;
  SecondaryNetworkId?: string;
  SecondaryNetworkType?: SecondaryNetworkType;
  SourceDestCheck?: boolean;
  Status?: SecondaryInterfaceStatus;
  Tags?: Tag[];
}
export const SecondaryInterface = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    Attachment: S.optional(SecondaryInterfaceAttachment)
      .pipe(T.XmlName("attachment"), T.Ec2QueryName("Attachment"))
      .annotate({ identifier: "SecondaryInterfaceAttachment" }),
    MacAddress: S.optional(S.String).pipe(
      T.XmlName("macAddress"),
      T.Ec2QueryName("MacAddress"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    PrivateIpv4Addresses: S.optional(SecondaryInterfaceIpv4AddressList).pipe(
      T.XmlName("privateIpv4AddressSet"),
      T.Ec2QueryName("PrivateIpv4AddressSet"),
    ),
    SecondaryInterfaceId: S.optional(S.String).pipe(
      T.XmlName("secondaryInterfaceId"),
      T.Ec2QueryName("SecondaryInterfaceId"),
    ),
    SecondaryInterfaceArn: S.optional(S.String).pipe(
      T.XmlName("secondaryInterfaceArn"),
      T.Ec2QueryName("SecondaryInterfaceArn"),
    ),
    SecondaryInterfaceType: S.optional(SecondaryInterfaceType).pipe(
      T.XmlName("secondaryInterfaceType"),
      T.Ec2QueryName("SecondaryInterfaceType"),
    ),
    SecondarySubnetId: S.optional(S.String).pipe(
      T.XmlName("secondarySubnetId"),
      T.Ec2QueryName("SecondarySubnetId"),
    ),
    SecondaryNetworkId: S.optional(S.String).pipe(
      T.XmlName("secondaryNetworkId"),
      T.Ec2QueryName("SecondaryNetworkId"),
    ),
    SecondaryNetworkType: S.optional(SecondaryNetworkType).pipe(
      T.XmlName("secondaryNetworkType"),
      T.Ec2QueryName("SecondaryNetworkType"),
    ),
    SourceDestCheck: S.optional(S.Boolean).pipe(
      T.XmlName("sourceDestCheck"),
      T.Ec2QueryName("SourceDestCheck"),
    ),
    Status: S.optional(SecondaryInterfaceStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "SecondaryInterface",
}) as any as S.Schema<SecondaryInterface>;
export type SecondaryInterfaceList = SecondaryInterface[];
export const SecondaryInterfaceList = S.Array(
  SecondaryInterface.pipe(T.XmlName("item")).annotate({
    identifier: "SecondaryInterface",
  }),
);
export interface DescribeSecondaryInterfacesResult {
  SecondaryInterfaces?: SecondaryInterface[];
  NextToken?: string;
}
export const DescribeSecondaryInterfacesResult = S.suspend(() =>
  S.Struct({
    SecondaryInterfaces: S.optional(SecondaryInterfaceList).pipe(
      T.XmlName("secondaryInterfaceSet"),
      T.Ec2QueryName("SecondaryInterfaceSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeSecondaryInterfacesResult",
}) as any as S.Schema<DescribeSecondaryInterfacesResult>;
export type SecondaryNetworkIdList = string[];
export const SecondaryNetworkIdList = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeSecondaryNetworksRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  SecondaryNetworkIds?: string[];
}
export const DescribeSecondaryNetworksRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    SecondaryNetworkIds: S.optional(SecondaryNetworkIdList).pipe(
      T.XmlName("SecondaryNetworkId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSecondaryNetworksRequest",
}) as any as S.Schema<DescribeSecondaryNetworksRequest>;
export type SecondaryNetworkList = SecondaryNetwork[];
export const SecondaryNetworkList = S.Array(
  SecondaryNetwork.pipe(T.XmlName("item")).annotate({
    identifier: "SecondaryNetwork",
  }),
);
export interface DescribeSecondaryNetworksResult {
  SecondaryNetworks?: SecondaryNetwork[];
  NextToken?: string;
}
export const DescribeSecondaryNetworksResult = S.suspend(() =>
  S.Struct({
    SecondaryNetworks: S.optional(SecondaryNetworkList).pipe(
      T.XmlName("secondaryNetworkSet"),
      T.Ec2QueryName("SecondaryNetworkSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeSecondaryNetworksResult",
}) as any as S.Schema<DescribeSecondaryNetworksResult>;
export type SecondarySubnetIdList = string[];
export const SecondarySubnetIdList = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeSecondarySubnetsRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  SecondarySubnetIds?: string[];
}
export const DescribeSecondarySubnetsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    SecondarySubnetIds: S.optional(SecondarySubnetIdList).pipe(
      T.XmlName("SecondarySubnetId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSecondarySubnetsRequest",
}) as any as S.Schema<DescribeSecondarySubnetsRequest>;
export type SecondarySubnetList = SecondarySubnet[];
export const SecondarySubnetList = S.Array(
  SecondarySubnet.pipe(T.XmlName("item")).annotate({
    identifier: "SecondarySubnet",
  }),
);
export interface DescribeSecondarySubnetsResult {
  SecondarySubnets?: SecondarySubnet[];
  NextToken?: string;
}
export const DescribeSecondarySubnetsResult = S.suspend(() =>
  S.Struct({
    SecondarySubnets: S.optional(SecondarySubnetList).pipe(
      T.XmlName("secondarySubnetSet"),
      T.Ec2QueryName("SecondarySubnetSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeSecondarySubnetsResult",
}) as any as S.Schema<DescribeSecondarySubnetsResult>;
export type GroupIds = string[];
export const GroupIds = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeSecurityGroupReferencesRequest {
  DryRun?: boolean;
  GroupId?: string[];
}
export const DescribeSecurityGroupReferencesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    GroupId: S.optional(GroupIds),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSecurityGroupReferencesRequest",
}) as any as S.Schema<DescribeSecurityGroupReferencesRequest>;
export interface SecurityGroupReference {
  GroupId?: string;
  ReferencingVpcId?: string;
  VpcPeeringConnectionId?: string;
  TransitGatewayId?: string;
}
export const SecurityGroupReference = S.suspend(() =>
  S.Struct({
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
    ReferencingVpcId: S.optional(S.String).pipe(
      T.XmlName("referencingVpcId"),
      T.Ec2QueryName("ReferencingVpcId"),
    ),
    VpcPeeringConnectionId: S.optional(S.String).pipe(
      T.XmlName("vpcPeeringConnectionId"),
      T.Ec2QueryName("VpcPeeringConnectionId"),
    ),
    TransitGatewayId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayId"),
      T.Ec2QueryName("TransitGatewayId"),
    ),
  }),
).annotate({
  identifier: "SecurityGroupReference",
}) as any as S.Schema<SecurityGroupReference>;
export type SecurityGroupReferences = SecurityGroupReference[];
export const SecurityGroupReferences = S.Array(
  SecurityGroupReference.pipe(T.XmlName("item")).annotate({
    identifier: "SecurityGroupReference",
  }),
);
export interface DescribeSecurityGroupReferencesResult {
  SecurityGroupReferenceSet?: SecurityGroupReference[];
}
export const DescribeSecurityGroupReferencesResult = S.suspend(() =>
  S.Struct({
    SecurityGroupReferenceSet: S.optional(SecurityGroupReferences).pipe(
      T.XmlName("securityGroupReferenceSet"),
      T.Ec2QueryName("SecurityGroupReferenceSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeSecurityGroupReferencesResult",
}) as any as S.Schema<DescribeSecurityGroupReferencesResult>;
export type SecurityGroupRuleIdList = string[];
export const SecurityGroupRuleIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeSecurityGroupRulesRequest {
  Filters?: Filter[];
  SecurityGroupRuleIds?: string[];
  DryRun?: boolean;
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeSecurityGroupRulesRequest = S.suspend(() =>
  S.Struct({
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    SecurityGroupRuleIds: S.optional(SecurityGroupRuleIdList).pipe(
      T.XmlName("SecurityGroupRuleId"),
    ),
    DryRun: S.optional(S.Boolean),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSecurityGroupRulesRequest",
}) as any as S.Schema<DescribeSecurityGroupRulesRequest>;
export interface DescribeSecurityGroupRulesResult {
  SecurityGroupRules?: SecurityGroupRule[];
  NextToken?: string;
}
export const DescribeSecurityGroupRulesResult = S.suspend(() =>
  S.Struct({
    SecurityGroupRules: S.optional(SecurityGroupRuleList).pipe(
      T.XmlName("securityGroupRuleSet"),
      T.Ec2QueryName("SecurityGroupRuleSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeSecurityGroupRulesResult",
}) as any as S.Schema<DescribeSecurityGroupRulesResult>;
export type GroupNameStringList = string[];
export const GroupNameStringList = S.Array(
  S.String.pipe(T.XmlName("GroupName")),
);
export interface DescribeSecurityGroupsRequest {
  GroupIds?: string[];
  GroupNames?: string[];
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
  Filters?: Filter[];
}
export const DescribeSecurityGroupsRequest = S.suspend(() =>
  S.Struct({
    GroupIds: S.optional(GroupIdStringList).pipe(T.XmlName("GroupId")),
    GroupNames: S.optional(GroupNameStringList).pipe(T.XmlName("GroupName")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSecurityGroupsRequest",
}) as any as S.Schema<DescribeSecurityGroupsRequest>;
export interface SecurityGroup {
  GroupId?: string;
  IpPermissionsEgress?: IpPermission[];
  Tags?: Tag[];
  VpcId?: string;
  SecurityGroupArn?: string;
  OwnerId?: string;
  GroupName?: string;
  Description?: string;
  IpPermissions?: IpPermission[];
}
export const SecurityGroup = S.suspend(() =>
  S.Struct({
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
    IpPermissionsEgress: S.optional(IpPermissionList).pipe(
      T.XmlName("ipPermissionsEgress"),
      T.Ec2QueryName("IpPermissionsEgress"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    SecurityGroupArn: S.optional(S.String).pipe(
      T.XmlName("securityGroupArn"),
      T.Ec2QueryName("SecurityGroupArn"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    GroupName: S.optional(S.String).pipe(
      T.XmlName("groupName"),
      T.Ec2QueryName("GroupName"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("groupDescription"),
      T.Ec2QueryName("GroupDescription"),
    ),
    IpPermissions: S.optional(IpPermissionList).pipe(
      T.XmlName("ipPermissions"),
      T.Ec2QueryName("IpPermissions"),
    ),
  }),
).annotate({ identifier: "SecurityGroup" }) as any as S.Schema<SecurityGroup>;
export type SecurityGroupList = SecurityGroup[];
export const SecurityGroupList = S.Array(
  SecurityGroup.pipe(T.XmlName("item")).annotate({
    identifier: "SecurityGroup",
  }),
);
export interface DescribeSecurityGroupsResult {
  NextToken?: string;
  SecurityGroups?: SecurityGroup[];
}
export const DescribeSecurityGroupsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    SecurityGroups: S.optional(SecurityGroupList).pipe(
      T.XmlName("securityGroupInfo"),
      T.Ec2QueryName("SecurityGroupInfo"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeSecurityGroupsResult",
}) as any as S.Schema<DescribeSecurityGroupsResult>;
export interface DescribeSecurityGroupVpcAssociationsRequest {
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
}
export const DescribeSecurityGroupVpcAssociationsRequest = S.suspend(() =>
  S.Struct({
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSecurityGroupVpcAssociationsRequest",
}) as any as S.Schema<DescribeSecurityGroupVpcAssociationsRequest>;
export interface SecurityGroupVpcAssociation {
  GroupId?: string;
  VpcId?: string;
  VpcOwnerId?: string;
  State?: SecurityGroupVpcAssociationState;
  StateReason?: string;
  GroupOwnerId?: string;
}
export const SecurityGroupVpcAssociation = S.suspend(() =>
  S.Struct({
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    VpcOwnerId: S.optional(S.String).pipe(
      T.XmlName("vpcOwnerId"),
      T.Ec2QueryName("VpcOwnerId"),
    ),
    State: S.optional(SecurityGroupVpcAssociationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StateReason: S.optional(S.String).pipe(
      T.XmlName("stateReason"),
      T.Ec2QueryName("StateReason"),
    ),
    GroupOwnerId: S.optional(S.String).pipe(
      T.XmlName("groupOwnerId"),
      T.Ec2QueryName("GroupOwnerId"),
    ),
  }),
).annotate({
  identifier: "SecurityGroupVpcAssociation",
}) as any as S.Schema<SecurityGroupVpcAssociation>;
export type SecurityGroupVpcAssociationList = SecurityGroupVpcAssociation[];
export const SecurityGroupVpcAssociationList = S.Array(
  SecurityGroupVpcAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "SecurityGroupVpcAssociation",
  }),
);
export interface DescribeSecurityGroupVpcAssociationsResult {
  SecurityGroupVpcAssociations?: SecurityGroupVpcAssociation[];
  NextToken?: string;
}
export const DescribeSecurityGroupVpcAssociationsResult = S.suspend(() =>
  S.Struct({
    SecurityGroupVpcAssociations: S.optional(
      SecurityGroupVpcAssociationList,
    ).pipe(
      T.XmlName("securityGroupVpcAssociationSet"),
      T.Ec2QueryName("SecurityGroupVpcAssociationSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeSecurityGroupVpcAssociationsResult",
}) as any as S.Schema<DescribeSecurityGroupVpcAssociationsResult>;
export interface DescribeServiceLinkVirtualInterfacesRequest {
  ServiceLinkVirtualInterfaceIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeServiceLinkVirtualInterfacesRequest = S.suspend(() =>
  S.Struct({
    ServiceLinkVirtualInterfaceIds: S.optional(
      ServiceLinkVirtualInterfaceIdSet,
    ).pipe(T.XmlName("ServiceLinkVirtualInterfaceId")),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeServiceLinkVirtualInterfacesRequest",
}) as any as S.Schema<DescribeServiceLinkVirtualInterfacesRequest>;
export type ServiceLinkVirtualInterfaceConfigurationState =
  | "pending"
  | "available"
  | "deleting"
  | "deleted"
  | (string & {});
export const ServiceLinkVirtualInterfaceConfigurationState = S.String;
export interface ServiceLinkVirtualInterface {
  ServiceLinkVirtualInterfaceId?: string;
  ServiceLinkVirtualInterfaceArn?: string;
  OutpostId?: string;
  OutpostArn?: string;
  OwnerId?: string;
  LocalAddress?: string;
  PeerAddress?: string;
  PeerBgpAsn?: number;
  Vlan?: number;
  OutpostLagId?: string;
  Tags?: Tag[];
  ConfigurationState?: ServiceLinkVirtualInterfaceConfigurationState;
}
export const ServiceLinkVirtualInterface = S.suspend(() =>
  S.Struct({
    ServiceLinkVirtualInterfaceId: S.optional(S.String).pipe(
      T.XmlName("serviceLinkVirtualInterfaceId"),
      T.Ec2QueryName("ServiceLinkVirtualInterfaceId"),
    ),
    ServiceLinkVirtualInterfaceArn: S.optional(S.String).pipe(
      T.XmlName("serviceLinkVirtualInterfaceArn"),
      T.Ec2QueryName("ServiceLinkVirtualInterfaceArn"),
    ),
    OutpostId: S.optional(S.String).pipe(
      T.XmlName("outpostId"),
      T.Ec2QueryName("OutpostId"),
    ),
    OutpostArn: S.optional(S.String).pipe(
      T.XmlName("outpostArn"),
      T.Ec2QueryName("OutpostArn"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    LocalAddress: S.optional(S.String).pipe(
      T.XmlName("localAddress"),
      T.Ec2QueryName("LocalAddress"),
    ),
    PeerAddress: S.optional(S.String).pipe(
      T.XmlName("peerAddress"),
      T.Ec2QueryName("PeerAddress"),
    ),
    PeerBgpAsn: S.optional(S.Number).pipe(
      T.XmlName("peerBgpAsn"),
      T.Ec2QueryName("PeerBgpAsn"),
    ),
    Vlan: S.optional(S.Number).pipe(T.XmlName("vlan"), T.Ec2QueryName("Vlan")),
    OutpostLagId: S.optional(S.String).pipe(
      T.XmlName("outpostLagId"),
      T.Ec2QueryName("OutpostLagId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    ConfigurationState: S.optional(
      ServiceLinkVirtualInterfaceConfigurationState,
    ).pipe(
      T.XmlName("configurationState"),
      T.Ec2QueryName("ConfigurationState"),
    ),
  }),
).annotate({
  identifier: "ServiceLinkVirtualInterface",
}) as any as S.Schema<ServiceLinkVirtualInterface>;
export type ServiceLinkVirtualInterfaceSet = ServiceLinkVirtualInterface[];
export const ServiceLinkVirtualInterfaceSet = S.Array(
  ServiceLinkVirtualInterface.pipe(T.XmlName("item")).annotate({
    identifier: "ServiceLinkVirtualInterface",
  }),
);
export interface DescribeServiceLinkVirtualInterfacesResult {
  ServiceLinkVirtualInterfaces?: ServiceLinkVirtualInterface[];
  NextToken?: string;
}
export const DescribeServiceLinkVirtualInterfacesResult = S.suspend(() =>
  S.Struct({
    ServiceLinkVirtualInterfaces: S.optional(
      ServiceLinkVirtualInterfaceSet,
    ).pipe(
      T.XmlName("serviceLinkVirtualInterfaceSet"),
      T.Ec2QueryName("ServiceLinkVirtualInterfaceSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeServiceLinkVirtualInterfacesResult",
}) as any as S.Schema<DescribeServiceLinkVirtualInterfacesResult>;
export type SnapshotAttributeName =
  | "productCodes"
  | "createVolumePermission"
  | (string & {});
export const SnapshotAttributeName = S.String;
export interface DescribeSnapshotAttributeRequest {
  Attribute?: SnapshotAttributeName;
  SnapshotId?: string;
  DryRun?: boolean;
}
export const DescribeSnapshotAttributeRequest = S.suspend(() =>
  S.Struct({
    Attribute: S.optional(SnapshotAttributeName),
    SnapshotId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSnapshotAttributeRequest",
}) as any as S.Schema<DescribeSnapshotAttributeRequest>;
export interface CreateVolumePermission {
  UserId?: string;
  Group?: PermissionGroup;
}
export const CreateVolumePermission = S.suspend(() =>
  S.Struct({
    UserId: S.optional(S.String).pipe(
      T.XmlName("userId"),
      T.Ec2QueryName("UserId"),
    ),
    Group: S.optional(PermissionGroup).pipe(
      T.XmlName("group"),
      T.Ec2QueryName("Group"),
    ),
  }),
).annotate({
  identifier: "CreateVolumePermission",
}) as any as S.Schema<CreateVolumePermission>;
export type CreateVolumePermissionList = CreateVolumePermission[];
export const CreateVolumePermissionList = S.Array(
  CreateVolumePermission.pipe(T.XmlName("item")).annotate({
    identifier: "CreateVolumePermission",
  }),
);
export interface DescribeSnapshotAttributeResult {
  ProductCodes?: ProductCode[];
  SnapshotId?: string;
  CreateVolumePermissions?: CreateVolumePermission[];
}
export const DescribeSnapshotAttributeResult = S.suspend(() =>
  S.Struct({
    ProductCodes: S.optional(ProductCodeList).pipe(
      T.XmlName("productCodes"),
      T.Ec2QueryName("ProductCodes"),
    ),
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    CreateVolumePermissions: S.optional(CreateVolumePermissionList).pipe(
      T.XmlName("createVolumePermission"),
      T.Ec2QueryName("CreateVolumePermission"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeSnapshotAttributeResult",
}) as any as S.Schema<DescribeSnapshotAttributeResult>;
export type RestorableByStringList = string[];
export const RestorableByStringList = S.Array(S.String);
export interface DescribeSnapshotsRequest {
  MaxResults?: number;
  NextToken?: string;
  OwnerIds?: string[];
  RestorableByUserIds?: string[];
  SnapshotIds?: string[];
  DryRun?: boolean;
  Filters?: Filter[];
}
export const DescribeSnapshotsRequest = S.suspend(() =>
  S.Struct({
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    OwnerIds: S.optional(OwnerStringList).pipe(T.XmlName("Owner")),
    RestorableByUserIds: S.optional(RestorableByStringList).pipe(
      T.XmlName("RestorableBy"),
    ),
    SnapshotIds: S.optional(SnapshotIdStringList).pipe(T.XmlName("SnapshotId")),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSnapshotsRequest",
}) as any as S.Schema<DescribeSnapshotsRequest>;
export type SnapshotList = Snapshot[];
export const SnapshotList = S.Array(
  Snapshot.pipe(T.XmlName("item")).annotate({ identifier: "Snapshot" }),
);
export interface DescribeSnapshotsResult {
  NextToken?: string;
  Snapshots?: Snapshot[];
}
export const DescribeSnapshotsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    Snapshots: S.optional(SnapshotList).pipe(
      T.XmlName("snapshotSet"),
      T.Ec2QueryName("SnapshotSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeSnapshotsResult",
}) as any as S.Schema<DescribeSnapshotsResult>;
export interface DescribeSnapshotTierStatusRequest {
  Filters?: Filter[];
  DryRun?: boolean;
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeSnapshotTierStatusRequest = S.suspend(() =>
  S.Struct({
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSnapshotTierStatusRequest",
}) as any as S.Schema<DescribeSnapshotTierStatusRequest>;
export type TieringOperationStatus =
  | "archival-in-progress"
  | "archival-completed"
  | "archival-failed"
  | "temporary-restore-in-progress"
  | "temporary-restore-completed"
  | "temporary-restore-failed"
  | "permanent-restore-in-progress"
  | "permanent-restore-completed"
  | "permanent-restore-failed"
  | (string & {});
export const TieringOperationStatus = S.String;
export interface SnapshotTierStatus {
  SnapshotId?: string;
  VolumeId?: string;
  Status?: SnapshotState;
  OwnerId?: string;
  Tags?: Tag[];
  StorageTier?: StorageTier;
  LastTieringStartTime?: Date;
  LastTieringProgress?: number;
  LastTieringOperationStatus?: TieringOperationStatus;
  LastTieringOperationStatusDetail?: string;
  ArchivalCompleteTime?: Date;
  RestoreExpiryTime?: Date;
}
export const SnapshotTierStatus = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    VolumeId: S.optional(S.String).pipe(
      T.XmlName("volumeId"),
      T.Ec2QueryName("VolumeId"),
    ),
    Status: S.optional(SnapshotState).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    StorageTier: S.optional(StorageTier).pipe(
      T.XmlName("storageTier"),
      T.Ec2QueryName("StorageTier"),
    ),
    LastTieringStartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("lastTieringStartTime"),
      T.Ec2QueryName("LastTieringStartTime"),
    ),
    LastTieringProgress: S.optional(S.Number).pipe(
      T.XmlName("lastTieringProgress"),
      T.Ec2QueryName("LastTieringProgress"),
    ),
    LastTieringOperationStatus: S.optional(TieringOperationStatus).pipe(
      T.XmlName("lastTieringOperationStatus"),
      T.Ec2QueryName("LastTieringOperationStatus"),
    ),
    LastTieringOperationStatusDetail: S.optional(S.String).pipe(
      T.XmlName("lastTieringOperationStatusDetail"),
      T.Ec2QueryName("LastTieringOperationStatusDetail"),
    ),
    ArchivalCompleteTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("archivalCompleteTime"),
      T.Ec2QueryName("ArchivalCompleteTime"),
    ),
    RestoreExpiryTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("restoreExpiryTime"), T.Ec2QueryName("RestoreExpiryTime")),
  }),
).annotate({
  identifier: "SnapshotTierStatus",
}) as any as S.Schema<SnapshotTierStatus>;
export type SnapshotTierStatusSet = SnapshotTierStatus[];
export const SnapshotTierStatusSet = S.Array(
  SnapshotTierStatus.pipe(T.XmlName("item")).annotate({
    identifier: "SnapshotTierStatus",
  }),
);
export interface DescribeSnapshotTierStatusResult {
  SnapshotTierStatuses?: SnapshotTierStatus[];
  NextToken?: string;
}
export const DescribeSnapshotTierStatusResult = S.suspend(() =>
  S.Struct({
    SnapshotTierStatuses: S.optional(SnapshotTierStatusSet).pipe(
      T.XmlName("snapshotTierStatusSet"),
      T.Ec2QueryName("SnapshotTierStatusSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeSnapshotTierStatusResult",
}) as any as S.Schema<DescribeSnapshotTierStatusResult>;
export interface DescribeSpotDatafeedSubscriptionRequest {
  DryRun?: boolean;
}
export const DescribeSpotDatafeedSubscriptionRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSpotDatafeedSubscriptionRequest",
}) as any as S.Schema<DescribeSpotDatafeedSubscriptionRequest>;
export interface DescribeSpotDatafeedSubscriptionResult {
  SpotDatafeedSubscription?: SpotDatafeedSubscription;
}
export const DescribeSpotDatafeedSubscriptionResult = S.suspend(() =>
  S.Struct({
    SpotDatafeedSubscription: S.optional(SpotDatafeedSubscription)
      .pipe(
        T.XmlName("spotDatafeedSubscription"),
        T.Ec2QueryName("SpotDatafeedSubscription"),
      )
      .annotate({ identifier: "SpotDatafeedSubscription" }),
  }).pipe(ns),
).annotate({
  identifier: "DescribeSpotDatafeedSubscriptionResult",
}) as any as S.Schema<DescribeSpotDatafeedSubscriptionResult>;
export interface DescribeSpotFleetInstancesRequest {
  DryRun?: boolean;
  SpotFleetRequestId?: string;
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeSpotFleetInstancesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    SpotFleetRequestId: S.optional(S.String).pipe(
      T.XmlName("spotFleetRequestId"),
      T.Ec2QueryName("SpotFleetRequestId"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    MaxResults: S.optional(S.Number).pipe(
      T.XmlName("maxResults"),
      T.Ec2QueryName("MaxResults"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSpotFleetInstancesRequest",
}) as any as S.Schema<DescribeSpotFleetInstancesRequest>;
export interface DescribeSpotFleetInstancesResponse {
  ActiveInstances?: ActiveInstance[];
  NextToken?: string;
  SpotFleetRequestId?: string;
}
export const DescribeSpotFleetInstancesResponse = S.suspend(() =>
  S.Struct({
    ActiveInstances: S.optional(ActiveInstanceSet).pipe(
      T.XmlName("activeInstanceSet"),
      T.Ec2QueryName("ActiveInstanceSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    SpotFleetRequestId: S.optional(S.String).pipe(
      T.XmlName("spotFleetRequestId"),
      T.Ec2QueryName("SpotFleetRequestId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeSpotFleetInstancesResponse",
}) as any as S.Schema<DescribeSpotFleetInstancesResponse>;
export type EventType =
  | "instanceChange"
  | "fleetRequestChange"
  | "error"
  | "information"
  | (string & {});
export const EventType = S.String;
export interface DescribeSpotFleetRequestHistoryRequest {
  DryRun?: boolean;
  SpotFleetRequestId?: string;
  EventType?: EventType;
  StartTime?: Date;
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeSpotFleetRequestHistoryRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    SpotFleetRequestId: S.optional(S.String).pipe(
      T.XmlName("spotFleetRequestId"),
      T.Ec2QueryName("SpotFleetRequestId"),
    ),
    EventType: S.optional(EventType).pipe(
      T.XmlName("eventType"),
      T.Ec2QueryName("EventType"),
    ),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startTime"), T.Ec2QueryName("StartTime")),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    MaxResults: S.optional(S.Number).pipe(
      T.XmlName("maxResults"),
      T.Ec2QueryName("MaxResults"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSpotFleetRequestHistoryRequest",
}) as any as S.Schema<DescribeSpotFleetRequestHistoryRequest>;
export interface HistoryRecord {
  EventInformation?: EventInformation;
  EventType?: EventType;
  Timestamp?: Date;
}
export const HistoryRecord = S.suspend(() =>
  S.Struct({
    EventInformation: S.optional(EventInformation)
      .pipe(T.XmlName("eventInformation"), T.Ec2QueryName("EventInformation"))
      .annotate({ identifier: "EventInformation" }),
    EventType: S.optional(EventType).pipe(
      T.XmlName("eventType"),
      T.Ec2QueryName("EventType"),
    ),
    Timestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("timestamp"), T.Ec2QueryName("Timestamp")),
  }),
).annotate({ identifier: "HistoryRecord" }) as any as S.Schema<HistoryRecord>;
export type HistoryRecords = HistoryRecord[];
export const HistoryRecords = S.Array(
  HistoryRecord.pipe(T.XmlName("item")).annotate({
    identifier: "HistoryRecord",
  }),
);
export interface DescribeSpotFleetRequestHistoryResponse {
  HistoryRecords?: HistoryRecord[];
  LastEvaluatedTime?: Date;
  NextToken?: string;
  SpotFleetRequestId?: string;
  StartTime?: Date;
}
export const DescribeSpotFleetRequestHistoryResponse = S.suspend(() =>
  S.Struct({
    HistoryRecords: S.optional(HistoryRecords).pipe(
      T.XmlName("historyRecordSet"),
      T.Ec2QueryName("HistoryRecordSet"),
    ),
    LastEvaluatedTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("lastEvaluatedTime"), T.Ec2QueryName("LastEvaluatedTime")),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    SpotFleetRequestId: S.optional(S.String).pipe(
      T.XmlName("spotFleetRequestId"),
      T.Ec2QueryName("SpotFleetRequestId"),
    ),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startTime"), T.Ec2QueryName("StartTime")),
  }).pipe(ns),
).annotate({
  identifier: "DescribeSpotFleetRequestHistoryResponse",
}) as any as S.Schema<DescribeSpotFleetRequestHistoryResponse>;
export interface DescribeSpotFleetRequestsRequest {
  DryRun?: boolean;
  SpotFleetRequestIds?: string[];
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeSpotFleetRequestsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    SpotFleetRequestIds: S.optional(SpotFleetRequestIdList).pipe(
      T.XmlName("spotFleetRequestId"),
      T.Ec2QueryName("SpotFleetRequestId"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    MaxResults: S.optional(S.Number).pipe(
      T.XmlName("maxResults"),
      T.Ec2QueryName("MaxResults"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSpotFleetRequestsRequest",
}) as any as S.Schema<DescribeSpotFleetRequestsRequest>;
export type ActivityStatus =
  | "error"
  | "pending_fulfillment"
  | "pending_termination"
  | "fulfilled"
  | (string & {});
export const ActivityStatus = S.String;
export type AllocationStrategy =
  | "lowestPrice"
  | "diversified"
  | "capacityOptimized"
  | "capacityOptimizedPrioritized"
  | "priceCapacityOptimized"
  | (string & {});
export const AllocationStrategy = S.String;
export type OnDemandAllocationStrategy =
  | "lowestPrice"
  | "prioritized"
  | (string & {});
export const OnDemandAllocationStrategy = S.String;
export type ReplacementStrategy =
  | "launch"
  | "launch-before-terminate"
  | (string & {});
export const ReplacementStrategy = S.String;
export interface SpotCapacityRebalance {
  ReplacementStrategy?: ReplacementStrategy;
  TerminationDelay?: number;
}
export const SpotCapacityRebalance = S.suspend(() =>
  S.Struct({
    ReplacementStrategy: S.optional(ReplacementStrategy).pipe(
      T.XmlName("replacementStrategy"),
      T.Ec2QueryName("ReplacementStrategy"),
    ),
    TerminationDelay: S.optional(S.Number).pipe(
      T.XmlName("terminationDelay"),
      T.Ec2QueryName("TerminationDelay"),
    ),
  }),
).annotate({
  identifier: "SpotCapacityRebalance",
}) as any as S.Schema<SpotCapacityRebalance>;
export interface SpotMaintenanceStrategies {
  CapacityRebalance?: SpotCapacityRebalance;
}
export const SpotMaintenanceStrategies = S.suspend(() =>
  S.Struct({
    CapacityRebalance: S.optional(SpotCapacityRebalance)
      .pipe(T.XmlName("capacityRebalance"), T.Ec2QueryName("CapacityRebalance"))
      .annotate({ identifier: "SpotCapacityRebalance" }),
  }),
).annotate({
  identifier: "SpotMaintenanceStrategies",
}) as any as S.Schema<SpotMaintenanceStrategies>;
export type ExcessCapacityTerminationPolicy =
  | "noTermination"
  | "default"
  | (string & {});
export const ExcessCapacityTerminationPolicy = S.String;
export interface SpotFleetMonitoring {
  Enabled?: boolean;
}
export const SpotFleetMonitoring = S.suspend(() =>
  S.Struct({
    Enabled: S.optional(S.Boolean).pipe(
      T.XmlName("enabled"),
      T.Ec2QueryName("Enabled"),
    ),
  }),
).annotate({
  identifier: "SpotFleetMonitoring",
}) as any as S.Schema<SpotFleetMonitoring>;
export interface InstanceNetworkInterfaceSpecification {
  AssociatePublicIpAddress?: boolean;
  DeleteOnTermination?: boolean;
  Description?: string;
  DeviceIndex?: number;
  Groups?: string[];
  Ipv6AddressCount?: number;
  Ipv6Addresses?: InstanceIpv6Address[];
  NetworkInterfaceId?: string;
  PrivateIpAddress?: string;
  PrivateIpAddresses?: PrivateIpAddressSpecification[];
  SecondaryPrivateIpAddressCount?: number;
  SubnetId?: string;
  AssociateCarrierIpAddress?: boolean;
  InterfaceType?: string;
  NetworkCardIndex?: number;
  Ipv4Prefixes?: Ipv4PrefixSpecificationRequest[];
  Ipv4PrefixCount?: number;
  Ipv6Prefixes?: Ipv6PrefixSpecificationRequest[];
  Ipv6PrefixCount?: number;
  PrimaryIpv6?: boolean;
  EnaSrdSpecification?: EnaSrdSpecificationRequest;
  ConnectionTrackingSpecification?: ConnectionTrackingSpecificationRequest;
  EnaQueueCount?: number;
}
export const InstanceNetworkInterfaceSpecification = S.suspend(() =>
  S.Struct({
    AssociatePublicIpAddress: S.optional(S.Boolean).pipe(
      T.XmlName("associatePublicIpAddress"),
      T.Ec2QueryName("AssociatePublicIpAddress"),
    ),
    DeleteOnTermination: S.optional(S.Boolean).pipe(
      T.XmlName("deleteOnTermination"),
      T.Ec2QueryName("DeleteOnTermination"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    DeviceIndex: S.optional(S.Number).pipe(
      T.XmlName("deviceIndex"),
      T.Ec2QueryName("DeviceIndex"),
    ),
    Groups: S.optional(SecurityGroupIdStringList).pipe(
      T.XmlName("SecurityGroupId"),
    ),
    Ipv6AddressCount: S.optional(S.Number).pipe(
      T.XmlName("ipv6AddressCount"),
      T.Ec2QueryName("Ipv6AddressCount"),
    ),
    Ipv6Addresses: S.optional(InstanceIpv6AddressList).pipe(
      T.XmlName("ipv6AddressesSet"),
      T.Ec2QueryName("Ipv6Addresses"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    PrivateIpAddress: S.optional(S.String).pipe(
      T.XmlName("privateIpAddress"),
      T.Ec2QueryName("PrivateIpAddress"),
    ),
    PrivateIpAddresses: S.optional(PrivateIpAddressSpecificationList).pipe(
      T.XmlName("privateIpAddressesSet"),
      T.Ec2QueryName("PrivateIpAddresses"),
    ),
    SecondaryPrivateIpAddressCount: S.optional(S.Number).pipe(
      T.XmlName("secondaryPrivateIpAddressCount"),
      T.Ec2QueryName("SecondaryPrivateIpAddressCount"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    AssociateCarrierIpAddress: S.optional(S.Boolean),
    InterfaceType: S.optional(S.String),
    NetworkCardIndex: S.optional(S.Number),
    Ipv4Prefixes: S.optional(Ipv4PrefixList).pipe(T.XmlName("Ipv4Prefix")),
    Ipv4PrefixCount: S.optional(S.Number),
    Ipv6Prefixes: S.optional(Ipv6PrefixList).pipe(T.XmlName("Ipv6Prefix")),
    Ipv6PrefixCount: S.optional(S.Number),
    PrimaryIpv6: S.optional(S.Boolean),
    EnaSrdSpecification: S.optional(EnaSrdSpecificationRequest),
    ConnectionTrackingSpecification: S.optional(
      ConnectionTrackingSpecificationRequest,
    ),
    EnaQueueCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "InstanceNetworkInterfaceSpecification",
}) as any as S.Schema<InstanceNetworkInterfaceSpecification>;
export type InstanceNetworkInterfaceSpecificationList =
  InstanceNetworkInterfaceSpecification[];
export const InstanceNetworkInterfaceSpecificationList = S.Array(
  InstanceNetworkInterfaceSpecification.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceNetworkInterfaceSpecification",
  }),
);
export interface SpotPlacement {
  AvailabilityZone?: string;
  GroupName?: string;
  Tenancy?: Tenancy;
  AvailabilityZoneId?: string;
}
export const SpotPlacement = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    GroupName: S.optional(S.String).pipe(
      T.XmlName("groupName"),
      T.Ec2QueryName("GroupName"),
    ),
    Tenancy: S.optional(Tenancy).pipe(
      T.XmlName("tenancy"),
      T.Ec2QueryName("Tenancy"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
  }),
).annotate({ identifier: "SpotPlacement" }) as any as S.Schema<SpotPlacement>;
export interface SpotFleetTagSpecification {
  ResourceType?: ResourceType;
  Tags?: Tag[];
}
export const SpotFleetTagSpecification = S.suspend(() =>
  S.Struct({
    ResourceType: S.optional(ResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    Tags: S.optional(TagList).pipe(T.XmlName("tag"), T.Ec2QueryName("Tag")),
  }),
).annotate({
  identifier: "SpotFleetTagSpecification",
}) as any as S.Schema<SpotFleetTagSpecification>;
export type SpotFleetTagSpecificationList = SpotFleetTagSpecification[];
export const SpotFleetTagSpecificationList = S.Array(
  SpotFleetTagSpecification.pipe(T.XmlName("item")).annotate({
    identifier: "SpotFleetTagSpecification",
  }),
);
export interface SpotFleetLaunchSpecification {
  AddressingType?: string;
  BlockDeviceMappings?: BlockDeviceMapping[];
  EbsOptimized?: boolean;
  IamInstanceProfile?: IamInstanceProfileSpecification;
  ImageId?: string;
  InstanceType?: InstanceType;
  KernelId?: string;
  KeyName?: string;
  Monitoring?: SpotFleetMonitoring;
  NetworkInterfaces?: InstanceNetworkInterfaceSpecification[];
  Placement?: SpotPlacement;
  RamdiskId?: string;
  SpotPrice?: string;
  SubnetId?: string;
  UserData?: string | redacted.Redacted<string>;
  WeightedCapacity?: number;
  TagSpecifications?: SpotFleetTagSpecification[];
  InstanceRequirements?: InstanceRequirements;
  SecurityGroups?: GroupIdentifier[];
}
export const SpotFleetLaunchSpecification = S.suspend(() =>
  S.Struct({
    AddressingType: S.optional(S.String).pipe(
      T.XmlName("addressingType"),
      T.Ec2QueryName("AddressingType"),
    ),
    BlockDeviceMappings: S.optional(BlockDeviceMappingList).pipe(
      T.XmlName("blockDeviceMapping"),
      T.Ec2QueryName("BlockDeviceMapping"),
    ),
    EbsOptimized: S.optional(S.Boolean).pipe(
      T.XmlName("ebsOptimized"),
      T.Ec2QueryName("EbsOptimized"),
    ),
    IamInstanceProfile: S.optional(IamInstanceProfileSpecification)
      .pipe(
        T.XmlName("iamInstanceProfile"),
        T.Ec2QueryName("IamInstanceProfile"),
      )
      .annotate({ identifier: "IamInstanceProfileSpecification" }),
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    InstanceType: S.optional(InstanceType).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    KernelId: S.optional(S.String).pipe(
      T.XmlName("kernelId"),
      T.Ec2QueryName("KernelId"),
    ),
    KeyName: S.optional(S.String).pipe(
      T.XmlName("keyName"),
      T.Ec2QueryName("KeyName"),
    ),
    Monitoring: S.optional(SpotFleetMonitoring)
      .pipe(T.XmlName("monitoring"), T.Ec2QueryName("Monitoring"))
      .annotate({ identifier: "SpotFleetMonitoring" }),
    NetworkInterfaces: S.optional(
      InstanceNetworkInterfaceSpecificationList,
    ).pipe(
      T.XmlName("networkInterfaceSet"),
      T.Ec2QueryName("NetworkInterfaceSet"),
    ),
    Placement: S.optional(SpotPlacement)
      .pipe(T.XmlName("placement"), T.Ec2QueryName("Placement"))
      .annotate({ identifier: "SpotPlacement" }),
    RamdiskId: S.optional(S.String).pipe(
      T.XmlName("ramdiskId"),
      T.Ec2QueryName("RamdiskId"),
    ),
    SpotPrice: S.optional(S.String).pipe(
      T.XmlName("spotPrice"),
      T.Ec2QueryName("SpotPrice"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    UserData: S.optional(SensitiveString).pipe(
      T.XmlName("userData"),
      T.Ec2QueryName("UserData"),
    ),
    WeightedCapacity: S.optional(S.Number).pipe(
      T.XmlName("weightedCapacity"),
      T.Ec2QueryName("WeightedCapacity"),
    ),
    TagSpecifications: S.optional(SpotFleetTagSpecificationList).pipe(
      T.XmlName("tagSpecificationSet"),
      T.Ec2QueryName("TagSpecificationSet"),
    ),
    InstanceRequirements: S.optional(InstanceRequirements)
      .pipe(
        T.XmlName("instanceRequirements"),
        T.Ec2QueryName("InstanceRequirements"),
      )
      .annotate({ identifier: "InstanceRequirements" }),
    SecurityGroups: S.optional(GroupIdentifierList).pipe(
      T.XmlName("groupSet"),
      T.Ec2QueryName("GroupSet"),
    ),
  }),
).annotate({
  identifier: "SpotFleetLaunchSpecification",
}) as any as S.Schema<SpotFleetLaunchSpecification>;
export type LaunchSpecsList = SpotFleetLaunchSpecification[];
export const LaunchSpecsList = S.Array(
  SpotFleetLaunchSpecification.pipe(T.XmlName("item")).annotate({
    identifier: "SpotFleetLaunchSpecification",
  }),
);
export interface LaunchTemplateOverrides {
  InstanceType?: InstanceType;
  SpotPrice?: string;
  SubnetId?: string;
  AvailabilityZone?: string;
  WeightedCapacity?: number;
  Priority?: number;
  InstanceRequirements?: InstanceRequirements;
  AvailabilityZoneId?: string;
}
export const LaunchTemplateOverrides = S.suspend(() =>
  S.Struct({
    InstanceType: S.optional(InstanceType).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    SpotPrice: S.optional(S.String).pipe(
      T.XmlName("spotPrice"),
      T.Ec2QueryName("SpotPrice"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    WeightedCapacity: S.optional(S.Number).pipe(
      T.XmlName("weightedCapacity"),
      T.Ec2QueryName("WeightedCapacity"),
    ),
    Priority: S.optional(S.Number).pipe(
      T.XmlName("priority"),
      T.Ec2QueryName("Priority"),
    ),
    InstanceRequirements: S.optional(InstanceRequirements)
      .pipe(
        T.XmlName("instanceRequirements"),
        T.Ec2QueryName("InstanceRequirements"),
      )
      .annotate({ identifier: "InstanceRequirements" }),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
  }),
).annotate({
  identifier: "LaunchTemplateOverrides",
}) as any as S.Schema<LaunchTemplateOverrides>;
export type LaunchTemplateOverridesList = LaunchTemplateOverrides[];
export const LaunchTemplateOverridesList = S.Array(
  LaunchTemplateOverrides.pipe(T.XmlName("item")).annotate({
    identifier: "LaunchTemplateOverrides",
  }),
);
export interface LaunchTemplateConfig {
  LaunchTemplateSpecification?: FleetLaunchTemplateSpecification;
  Overrides?: LaunchTemplateOverrides[];
}
export const LaunchTemplateConfig = S.suspend(() =>
  S.Struct({
    LaunchTemplateSpecification: S.optional(FleetLaunchTemplateSpecification)
      .pipe(
        T.XmlName("launchTemplateSpecification"),
        T.Ec2QueryName("LaunchTemplateSpecification"),
      )
      .annotate({ identifier: "FleetLaunchTemplateSpecification" }),
    Overrides: S.optional(LaunchTemplateOverridesList).pipe(
      T.XmlName("overrides"),
      T.Ec2QueryName("Overrides"),
    ),
  }),
).annotate({
  identifier: "LaunchTemplateConfig",
}) as any as S.Schema<LaunchTemplateConfig>;
export type LaunchTemplateConfigList = LaunchTemplateConfig[];
export const LaunchTemplateConfigList = S.Array(
  LaunchTemplateConfig.pipe(T.XmlName("item")).annotate({
    identifier: "LaunchTemplateConfig",
  }),
);
export interface ClassicLoadBalancer {
  Name?: string;
}
export const ClassicLoadBalancer = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
  }),
).annotate({
  identifier: "ClassicLoadBalancer",
}) as any as S.Schema<ClassicLoadBalancer>;
export type ClassicLoadBalancers = ClassicLoadBalancer[];
export const ClassicLoadBalancers = S.Array(
  ClassicLoadBalancer.pipe(T.XmlName("item")).annotate({
    identifier: "ClassicLoadBalancer",
  }),
);
export interface ClassicLoadBalancersConfig {
  ClassicLoadBalancers?: ClassicLoadBalancer[];
}
export const ClassicLoadBalancersConfig = S.suspend(() =>
  S.Struct({
    ClassicLoadBalancers: S.optional(ClassicLoadBalancers).pipe(
      T.XmlName("classicLoadBalancers"),
      T.Ec2QueryName("ClassicLoadBalancers"),
    ),
  }),
).annotate({
  identifier: "ClassicLoadBalancersConfig",
}) as any as S.Schema<ClassicLoadBalancersConfig>;
export interface TargetGroup {
  Arn?: string;
}
export const TargetGroup = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String).pipe(T.XmlName("arn"), T.Ec2QueryName("Arn")),
  }),
).annotate({ identifier: "TargetGroup" }) as any as S.Schema<TargetGroup>;
export type TargetGroups = TargetGroup[];
export const TargetGroups = S.Array(
  TargetGroup.pipe(T.XmlName("item")).annotate({ identifier: "TargetGroup" }),
);
export interface TargetGroupsConfig {
  TargetGroups?: TargetGroup[];
}
export const TargetGroupsConfig = S.suspend(() =>
  S.Struct({
    TargetGroups: S.optional(TargetGroups).pipe(
      T.XmlName("targetGroups"),
      T.Ec2QueryName("TargetGroups"),
    ),
  }),
).annotate({
  identifier: "TargetGroupsConfig",
}) as any as S.Schema<TargetGroupsConfig>;
export interface LoadBalancersConfig {
  ClassicLoadBalancersConfig?: ClassicLoadBalancersConfig;
  TargetGroupsConfig?: TargetGroupsConfig;
}
export const LoadBalancersConfig = S.suspend(() =>
  S.Struct({
    ClassicLoadBalancersConfig: S.optional(ClassicLoadBalancersConfig)
      .pipe(
        T.XmlName("classicLoadBalancersConfig"),
        T.Ec2QueryName("ClassicLoadBalancersConfig"),
      )
      .annotate({ identifier: "ClassicLoadBalancersConfig" }),
    TargetGroupsConfig: S.optional(TargetGroupsConfig)
      .pipe(
        T.XmlName("targetGroupsConfig"),
        T.Ec2QueryName("TargetGroupsConfig"),
      )
      .annotate({ identifier: "TargetGroupsConfig" }),
  }),
).annotate({
  identifier: "LoadBalancersConfig",
}) as any as S.Schema<LoadBalancersConfig>;
export interface SpotFleetRequestConfigData {
  AllocationStrategy?: AllocationStrategy;
  OnDemandAllocationStrategy?: OnDemandAllocationStrategy;
  SpotMaintenanceStrategies?: SpotMaintenanceStrategies;
  ClientToken?: string;
  ExcessCapacityTerminationPolicy?: ExcessCapacityTerminationPolicy;
  FulfilledCapacity?: number;
  OnDemandFulfilledCapacity?: number;
  IamFleetRole?: string;
  LaunchSpecifications?: SpotFleetLaunchSpecification[];
  LaunchTemplateConfigs?: LaunchTemplateConfig[];
  SpotPrice?: string;
  TargetCapacity?: number;
  OnDemandTargetCapacity?: number;
  OnDemandMaxTotalPrice?: string;
  SpotMaxTotalPrice?: string;
  TerminateInstancesWithExpiration?: boolean;
  Type?: FleetType;
  ValidFrom?: Date;
  ValidUntil?: Date;
  ReplaceUnhealthyInstances?: boolean;
  InstanceInterruptionBehavior?: InstanceInterruptionBehavior;
  LoadBalancersConfig?: LoadBalancersConfig;
  InstancePoolsToUseCount?: number;
  Context?: string;
  TargetCapacityUnitType?: TargetCapacityUnitType;
  TagSpecifications?: TagSpecification[];
}
export const SpotFleetRequestConfigData = S.suspend(() =>
  S.Struct({
    AllocationStrategy: S.optional(AllocationStrategy).pipe(
      T.XmlName("allocationStrategy"),
      T.Ec2QueryName("AllocationStrategy"),
    ),
    OnDemandAllocationStrategy: S.optional(OnDemandAllocationStrategy).pipe(
      T.XmlName("onDemandAllocationStrategy"),
      T.Ec2QueryName("OnDemandAllocationStrategy"),
    ),
    SpotMaintenanceStrategies: S.optional(SpotMaintenanceStrategies)
      .pipe(
        T.XmlName("spotMaintenanceStrategies"),
        T.Ec2QueryName("SpotMaintenanceStrategies"),
      )
      .annotate({ identifier: "SpotMaintenanceStrategies" }),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
    ExcessCapacityTerminationPolicy: S.optional(
      ExcessCapacityTerminationPolicy,
    ).pipe(
      T.XmlName("excessCapacityTerminationPolicy"),
      T.Ec2QueryName("ExcessCapacityTerminationPolicy"),
    ),
    FulfilledCapacity: S.optional(S.Number).pipe(
      T.XmlName("fulfilledCapacity"),
      T.Ec2QueryName("FulfilledCapacity"),
    ),
    OnDemandFulfilledCapacity: S.optional(S.Number).pipe(
      T.XmlName("onDemandFulfilledCapacity"),
      T.Ec2QueryName("OnDemandFulfilledCapacity"),
    ),
    IamFleetRole: S.optional(S.String).pipe(
      T.XmlName("iamFleetRole"),
      T.Ec2QueryName("IamFleetRole"),
    ),
    LaunchSpecifications: S.optional(LaunchSpecsList).pipe(
      T.XmlName("launchSpecifications"),
      T.Ec2QueryName("LaunchSpecifications"),
    ),
    LaunchTemplateConfigs: S.optional(LaunchTemplateConfigList).pipe(
      T.XmlName("launchTemplateConfigs"),
      T.Ec2QueryName("LaunchTemplateConfigs"),
    ),
    SpotPrice: S.optional(S.String).pipe(
      T.XmlName("spotPrice"),
      T.Ec2QueryName("SpotPrice"),
    ),
    TargetCapacity: S.optional(S.Number).pipe(
      T.XmlName("targetCapacity"),
      T.Ec2QueryName("TargetCapacity"),
    ),
    OnDemandTargetCapacity: S.optional(S.Number).pipe(
      T.XmlName("onDemandTargetCapacity"),
      T.Ec2QueryName("OnDemandTargetCapacity"),
    ),
    OnDemandMaxTotalPrice: S.optional(S.String).pipe(
      T.XmlName("onDemandMaxTotalPrice"),
      T.Ec2QueryName("OnDemandMaxTotalPrice"),
    ),
    SpotMaxTotalPrice: S.optional(S.String).pipe(
      T.XmlName("spotMaxTotalPrice"),
      T.Ec2QueryName("SpotMaxTotalPrice"),
    ),
    TerminateInstancesWithExpiration: S.optional(S.Boolean).pipe(
      T.XmlName("terminateInstancesWithExpiration"),
      T.Ec2QueryName("TerminateInstancesWithExpiration"),
    ),
    Type: S.optional(FleetType).pipe(T.XmlName("type"), T.Ec2QueryName("Type")),
    ValidFrom: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("validFrom"), T.Ec2QueryName("ValidFrom")),
    ValidUntil: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("validUntil"), T.Ec2QueryName("ValidUntil")),
    ReplaceUnhealthyInstances: S.optional(S.Boolean).pipe(
      T.XmlName("replaceUnhealthyInstances"),
      T.Ec2QueryName("ReplaceUnhealthyInstances"),
    ),
    InstanceInterruptionBehavior: S.optional(InstanceInterruptionBehavior).pipe(
      T.XmlName("instanceInterruptionBehavior"),
      T.Ec2QueryName("InstanceInterruptionBehavior"),
    ),
    LoadBalancersConfig: S.optional(LoadBalancersConfig)
      .pipe(
        T.XmlName("loadBalancersConfig"),
        T.Ec2QueryName("LoadBalancersConfig"),
      )
      .annotate({ identifier: "LoadBalancersConfig" }),
    InstancePoolsToUseCount: S.optional(S.Number).pipe(
      T.XmlName("instancePoolsToUseCount"),
      T.Ec2QueryName("InstancePoolsToUseCount"),
    ),
    Context: S.optional(S.String).pipe(
      T.XmlName("context"),
      T.Ec2QueryName("Context"),
    ),
    TargetCapacityUnitType: S.optional(TargetCapacityUnitType).pipe(
      T.XmlName("targetCapacityUnitType"),
      T.Ec2QueryName("TargetCapacityUnitType"),
    ),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }),
).annotate({
  identifier: "SpotFleetRequestConfigData",
}) as any as S.Schema<SpotFleetRequestConfigData>;
export interface SpotFleetRequestConfig {
  ActivityStatus?: ActivityStatus;
  CreateTime?: Date;
  SpotFleetRequestConfig?: SpotFleetRequestConfigData;
  SpotFleetRequestId?: string;
  SpotFleetRequestState?: BatchState;
  Tags?: Tag[];
}
export const SpotFleetRequestConfig = S.suspend(() =>
  S.Struct({
    ActivityStatus: S.optional(ActivityStatus).pipe(
      T.XmlName("activityStatus"),
      T.Ec2QueryName("ActivityStatus"),
    ),
    CreateTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createTime"), T.Ec2QueryName("CreateTime")),
    SpotFleetRequestConfig: S.optional(SpotFleetRequestConfigData)
      .pipe(
        T.XmlName("spotFleetRequestConfig"),
        T.Ec2QueryName("SpotFleetRequestConfig"),
      )
      .annotate({ identifier: "SpotFleetRequestConfigData" }),
    SpotFleetRequestId: S.optional(S.String).pipe(
      T.XmlName("spotFleetRequestId"),
      T.Ec2QueryName("SpotFleetRequestId"),
    ),
    SpotFleetRequestState: S.optional(BatchState).pipe(
      T.XmlName("spotFleetRequestState"),
      T.Ec2QueryName("SpotFleetRequestState"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "SpotFleetRequestConfig",
}) as any as S.Schema<SpotFleetRequestConfig>;
export type SpotFleetRequestConfigSet = SpotFleetRequestConfig[];
export const SpotFleetRequestConfigSet = S.Array(
  SpotFleetRequestConfig.pipe(T.XmlName("item")).annotate({
    identifier: "SpotFleetRequestConfig",
  }),
);
export interface DescribeSpotFleetRequestsResponse {
  NextToken?: string;
  SpotFleetRequestConfigs?: (SpotFleetRequestConfig & {
    SpotFleetRequestConfig: SpotFleetRequestConfigData & {
      IamFleetRole: string;
      TargetCapacity: number;
    };
  })[];
}
export const DescribeSpotFleetRequestsResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    SpotFleetRequestConfigs: S.optional(SpotFleetRequestConfigSet).pipe(
      T.XmlName("spotFleetRequestConfigSet"),
      T.Ec2QueryName("SpotFleetRequestConfigSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeSpotFleetRequestsResponse",
}) as any as S.Schema<DescribeSpotFleetRequestsResponse>;
export interface DescribeSpotInstanceRequestsRequest {
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
  SpotInstanceRequestIds?: string[];
  Filters?: Filter[];
}
export const DescribeSpotInstanceRequestsRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    SpotInstanceRequestIds: S.optional(SpotInstanceRequestIdList).pipe(
      T.XmlName("SpotInstanceRequestId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSpotInstanceRequestsRequest",
}) as any as S.Schema<DescribeSpotInstanceRequestsRequest>;
export interface RunInstancesMonitoringEnabled {
  Enabled?: boolean;
}
export const RunInstancesMonitoringEnabled = S.suspend(() =>
  S.Struct({
    Enabled: S.optional(S.Boolean).pipe(
      T.XmlName("enabled"),
      T.Ec2QueryName("Enabled"),
    ),
  }),
).annotate({
  identifier: "RunInstancesMonitoringEnabled",
}) as any as S.Schema<RunInstancesMonitoringEnabled>;
export interface LaunchSpecification {
  UserData?: string | redacted.Redacted<string>;
  AddressingType?: string;
  BlockDeviceMappings?: BlockDeviceMapping[];
  EbsOptimized?: boolean;
  IamInstanceProfile?: IamInstanceProfileSpecification;
  ImageId?: string;
  InstanceType?: InstanceType;
  KernelId?: string;
  KeyName?: string;
  NetworkInterfaces?: InstanceNetworkInterfaceSpecification[];
  Placement?: SpotPlacement;
  RamdiskId?: string;
  SubnetId?: string;
  SecurityGroups?: GroupIdentifier[];
  Monitoring?: RunInstancesMonitoringEnabled;
}
export const LaunchSpecification = S.suspend(() =>
  S.Struct({
    UserData: S.optional(SensitiveString).pipe(
      T.XmlName("userData"),
      T.Ec2QueryName("UserData"),
    ),
    AddressingType: S.optional(S.String).pipe(
      T.XmlName("addressingType"),
      T.Ec2QueryName("AddressingType"),
    ),
    BlockDeviceMappings: S.optional(BlockDeviceMappingList).pipe(
      T.XmlName("blockDeviceMapping"),
      T.Ec2QueryName("BlockDeviceMapping"),
    ),
    EbsOptimized: S.optional(S.Boolean).pipe(
      T.XmlName("ebsOptimized"),
      T.Ec2QueryName("EbsOptimized"),
    ),
    IamInstanceProfile: S.optional(IamInstanceProfileSpecification)
      .pipe(
        T.XmlName("iamInstanceProfile"),
        T.Ec2QueryName("IamInstanceProfile"),
      )
      .annotate({ identifier: "IamInstanceProfileSpecification" }),
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    InstanceType: S.optional(InstanceType).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    KernelId: S.optional(S.String).pipe(
      T.XmlName("kernelId"),
      T.Ec2QueryName("KernelId"),
    ),
    KeyName: S.optional(S.String).pipe(
      T.XmlName("keyName"),
      T.Ec2QueryName("KeyName"),
    ),
    NetworkInterfaces: S.optional(
      InstanceNetworkInterfaceSpecificationList,
    ).pipe(
      T.XmlName("networkInterfaceSet"),
      T.Ec2QueryName("NetworkInterfaceSet"),
    ),
    Placement: S.optional(SpotPlacement)
      .pipe(T.XmlName("placement"), T.Ec2QueryName("Placement"))
      .annotate({ identifier: "SpotPlacement" }),
    RamdiskId: S.optional(S.String).pipe(
      T.XmlName("ramdiskId"),
      T.Ec2QueryName("RamdiskId"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    SecurityGroups: S.optional(GroupIdentifierList).pipe(
      T.XmlName("groupSet"),
      T.Ec2QueryName("GroupSet"),
    ),
    Monitoring: S.optional(RunInstancesMonitoringEnabled)
      .pipe(T.XmlName("monitoring"), T.Ec2QueryName("Monitoring"))
      .annotate({ identifier: "RunInstancesMonitoringEnabled" }),
  }),
).annotate({
  identifier: "LaunchSpecification",
}) as any as S.Schema<LaunchSpecification>;
export type SpotInstanceState =
  | "open"
  | "active"
  | "closed"
  | "cancelled"
  | "failed"
  | "disabled"
  | (string & {});
export const SpotInstanceState = S.String;
export interface SpotInstanceStatus {
  Code?: string;
  Message?: string;
  UpdateTime?: Date;
}
export const SpotInstanceStatus = S.suspend(() =>
  S.Struct({
    Code: S.optional(S.String).pipe(T.XmlName("code"), T.Ec2QueryName("Code")),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
    UpdateTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("updateTime"), T.Ec2QueryName("UpdateTime")),
  }),
).annotate({
  identifier: "SpotInstanceStatus",
}) as any as S.Schema<SpotInstanceStatus>;
export interface SpotInstanceRequest {
  ActualBlockHourlyPrice?: string;
  AvailabilityZoneGroup?: string;
  BlockDurationMinutes?: number;
  CreateTime?: Date;
  Fault?: SpotInstanceStateFault;
  InstanceId?: string;
  LaunchGroup?: string;
  LaunchSpecification?: LaunchSpecification;
  LaunchedAvailabilityZone?: string;
  LaunchedAvailabilityZoneId?: string;
  ProductDescription?: RIProductDescription;
  SpotInstanceRequestId?: string;
  SpotPrice?: string;
  State?: SpotInstanceState;
  Status?: SpotInstanceStatus;
  Tags?: Tag[];
  Type?: SpotInstanceType;
  ValidFrom?: Date;
  ValidUntil?: Date;
  InstanceInterruptionBehavior?: InstanceInterruptionBehavior;
}
export const SpotInstanceRequest = S.suspend(() =>
  S.Struct({
    ActualBlockHourlyPrice: S.optional(S.String).pipe(
      T.XmlName("actualBlockHourlyPrice"),
      T.Ec2QueryName("ActualBlockHourlyPrice"),
    ),
    AvailabilityZoneGroup: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneGroup"),
      T.Ec2QueryName("AvailabilityZoneGroup"),
    ),
    BlockDurationMinutes: S.optional(S.Number).pipe(
      T.XmlName("blockDurationMinutes"),
      T.Ec2QueryName("BlockDurationMinutes"),
    ),
    CreateTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createTime"), T.Ec2QueryName("CreateTime")),
    Fault: S.optional(SpotInstanceStateFault)
      .pipe(T.XmlName("fault"), T.Ec2QueryName("Fault"))
      .annotate({ identifier: "SpotInstanceStateFault" }),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    LaunchGroup: S.optional(S.String).pipe(
      T.XmlName("launchGroup"),
      T.Ec2QueryName("LaunchGroup"),
    ),
    LaunchSpecification: S.optional(LaunchSpecification)
      .pipe(
        T.XmlName("launchSpecification"),
        T.Ec2QueryName("LaunchSpecification"),
      )
      .annotate({ identifier: "LaunchSpecification" }),
    LaunchedAvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("launchedAvailabilityZone"),
      T.Ec2QueryName("LaunchedAvailabilityZone"),
    ),
    LaunchedAvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("launchedAvailabilityZoneId"),
      T.Ec2QueryName("LaunchedAvailabilityZoneId"),
    ),
    ProductDescription: S.optional(RIProductDescription).pipe(
      T.XmlName("productDescription"),
      T.Ec2QueryName("ProductDescription"),
    ),
    SpotInstanceRequestId: S.optional(S.String).pipe(
      T.XmlName("spotInstanceRequestId"),
      T.Ec2QueryName("SpotInstanceRequestId"),
    ),
    SpotPrice: S.optional(S.String).pipe(
      T.XmlName("spotPrice"),
      T.Ec2QueryName("SpotPrice"),
    ),
    State: S.optional(SpotInstanceState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Status: S.optional(SpotInstanceStatus)
      .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
      .annotate({ identifier: "SpotInstanceStatus" }),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    Type: S.optional(SpotInstanceType).pipe(
      T.XmlName("type"),
      T.Ec2QueryName("Type"),
    ),
    ValidFrom: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("validFrom"), T.Ec2QueryName("ValidFrom")),
    ValidUntil: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("validUntil"), T.Ec2QueryName("ValidUntil")),
    InstanceInterruptionBehavior: S.optional(InstanceInterruptionBehavior).pipe(
      T.XmlName("instanceInterruptionBehavior"),
      T.Ec2QueryName("InstanceInterruptionBehavior"),
    ),
  }),
).annotate({
  identifier: "SpotInstanceRequest",
}) as any as S.Schema<SpotInstanceRequest>;
export type SpotInstanceRequestList = SpotInstanceRequest[];
export const SpotInstanceRequestList = S.Array(
  SpotInstanceRequest.pipe(T.XmlName("item")).annotate({
    identifier: "SpotInstanceRequest",
  }),
);
export interface DescribeSpotInstanceRequestsResult {
  SpotInstanceRequests?: (SpotInstanceRequest & {
    LaunchSpecification: LaunchSpecification & {
      Monitoring: RunInstancesMonitoringEnabled & { Enabled: boolean };
    };
  })[];
  NextToken?: string;
}
export const DescribeSpotInstanceRequestsResult = S.suspend(() =>
  S.Struct({
    SpotInstanceRequests: S.optional(SpotInstanceRequestList).pipe(
      T.XmlName("spotInstanceRequestSet"),
      T.Ec2QueryName("SpotInstanceRequestSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeSpotInstanceRequestsResult",
}) as any as S.Schema<DescribeSpotInstanceRequestsResult>;
export type InstanceTypeList = InstanceType[];
export const InstanceTypeList = S.Array(InstanceType);
export type ProductDescriptionList = string[];
export const ProductDescriptionList = S.Array(S.String);
export interface DescribeSpotPriceHistoryRequest {
  AvailabilityZoneId?: string;
  DryRun?: boolean;
  StartTime?: Date;
  EndTime?: Date;
  InstanceTypes?: InstanceType[];
  ProductDescriptions?: string[];
  Filters?: Filter[];
  AvailabilityZone?: string;
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeSpotPriceHistoryRequest = S.suspend(() =>
  S.Struct({
    AvailabilityZoneId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startTime"), T.Ec2QueryName("StartTime")),
    EndTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("endTime"), T.Ec2QueryName("EndTime")),
    InstanceTypes: S.optional(InstanceTypeList).pipe(T.XmlName("InstanceType")),
    ProductDescriptions: S.optional(ProductDescriptionList).pipe(
      T.XmlName("ProductDescription"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    MaxResults: S.optional(S.Number).pipe(
      T.XmlName("maxResults"),
      T.Ec2QueryName("MaxResults"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSpotPriceHistoryRequest",
}) as any as S.Schema<DescribeSpotPriceHistoryRequest>;
export interface SpotPrice {
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  InstanceType?: InstanceType;
  ProductDescription?: RIProductDescription;
  SpotPrice?: string;
  Timestamp?: Date;
}
export const SpotPrice = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    InstanceType: S.optional(InstanceType).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    ProductDescription: S.optional(RIProductDescription).pipe(
      T.XmlName("productDescription"),
      T.Ec2QueryName("ProductDescription"),
    ),
    SpotPrice: S.optional(S.String).pipe(
      T.XmlName("spotPrice"),
      T.Ec2QueryName("SpotPrice"),
    ),
    Timestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("timestamp"), T.Ec2QueryName("Timestamp")),
  }),
).annotate({ identifier: "SpotPrice" }) as any as S.Schema<SpotPrice>;
export type SpotPriceHistoryList = SpotPrice[];
export const SpotPriceHistoryList = S.Array(
  SpotPrice.pipe(T.XmlName("item")).annotate({ identifier: "SpotPrice" }),
);
export interface DescribeSpotPriceHistoryResult {
  NextToken?: string;
  SpotPriceHistory?: SpotPrice[];
}
export const DescribeSpotPriceHistoryResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    SpotPriceHistory: S.optional(SpotPriceHistoryList).pipe(
      T.XmlName("spotPriceHistorySet"),
      T.Ec2QueryName("SpotPriceHistorySet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeSpotPriceHistoryResult",
}) as any as S.Schema<DescribeSpotPriceHistoryResult>;
export interface DescribeStaleSecurityGroupsRequest {
  DryRun?: boolean;
  MaxResults?: number;
  NextToken?: string;
  VpcId?: string;
}
export const DescribeStaleSecurityGroupsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    VpcId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeStaleSecurityGroupsRequest",
}) as any as S.Schema<DescribeStaleSecurityGroupsRequest>;
export type IpRanges = string[];
export const IpRanges = S.Array(S.String.pipe(T.XmlName("item")));
export type PrefixListIdSet = string[];
export const PrefixListIdSet = S.Array(S.String.pipe(T.XmlName("item")));
export type UserIdGroupPairSet = UserIdGroupPair[];
export const UserIdGroupPairSet = S.Array(
  UserIdGroupPair.pipe(T.XmlName("item")).annotate({
    identifier: "UserIdGroupPair",
  }),
);
export interface StaleIpPermission {
  FromPort?: number;
  IpProtocol?: string;
  IpRanges?: string[];
  PrefixListIds?: string[];
  ToPort?: number;
  UserIdGroupPairs?: UserIdGroupPair[];
}
export const StaleIpPermission = S.suspend(() =>
  S.Struct({
    FromPort: S.optional(S.Number).pipe(
      T.XmlName("fromPort"),
      T.Ec2QueryName("FromPort"),
    ),
    IpProtocol: S.optional(S.String).pipe(
      T.XmlName("ipProtocol"),
      T.Ec2QueryName("IpProtocol"),
    ),
    IpRanges: S.optional(IpRanges).pipe(
      T.XmlName("ipRanges"),
      T.Ec2QueryName("IpRanges"),
    ),
    PrefixListIds: S.optional(PrefixListIdSet).pipe(
      T.XmlName("prefixListIds"),
      T.Ec2QueryName("PrefixListIds"),
    ),
    ToPort: S.optional(S.Number).pipe(
      T.XmlName("toPort"),
      T.Ec2QueryName("ToPort"),
    ),
    UserIdGroupPairs: S.optional(UserIdGroupPairSet).pipe(
      T.XmlName("groups"),
      T.Ec2QueryName("Groups"),
    ),
  }),
).annotate({
  identifier: "StaleIpPermission",
}) as any as S.Schema<StaleIpPermission>;
export type StaleIpPermissionSet = StaleIpPermission[];
export const StaleIpPermissionSet = S.Array(
  StaleIpPermission.pipe(T.XmlName("item")).annotate({
    identifier: "StaleIpPermission",
  }),
);
export interface StaleSecurityGroup {
  Description?: string;
  GroupId?: string;
  GroupName?: string;
  StaleIpPermissions?: StaleIpPermission[];
  StaleIpPermissionsEgress?: StaleIpPermission[];
  VpcId?: string;
}
export const StaleSecurityGroup = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
    GroupName: S.optional(S.String).pipe(
      T.XmlName("groupName"),
      T.Ec2QueryName("GroupName"),
    ),
    StaleIpPermissions: S.optional(StaleIpPermissionSet).pipe(
      T.XmlName("staleIpPermissions"),
      T.Ec2QueryName("StaleIpPermissions"),
    ),
    StaleIpPermissionsEgress: S.optional(StaleIpPermissionSet).pipe(
      T.XmlName("staleIpPermissionsEgress"),
      T.Ec2QueryName("StaleIpPermissionsEgress"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
  }),
).annotate({
  identifier: "StaleSecurityGroup",
}) as any as S.Schema<StaleSecurityGroup>;
export type StaleSecurityGroupSet = StaleSecurityGroup[];
export const StaleSecurityGroupSet = S.Array(
  StaleSecurityGroup.pipe(T.XmlName("item")).annotate({
    identifier: "StaleSecurityGroup",
  }),
);
export interface DescribeStaleSecurityGroupsResult {
  NextToken?: string;
  StaleSecurityGroupSet?: StaleSecurityGroup[];
}
export const DescribeStaleSecurityGroupsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    StaleSecurityGroupSet: S.optional(StaleSecurityGroupSet).pipe(
      T.XmlName("staleSecurityGroupSet"),
      T.Ec2QueryName("StaleSecurityGroupSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeStaleSecurityGroupsResult",
}) as any as S.Schema<DescribeStaleSecurityGroupsResult>;
export type ImageIdList = string[];
export const ImageIdList = S.Array(S.String.pipe(T.XmlName("item")));
export interface DescribeStoreImageTasksRequest {
  ImageIds?: string[];
  DryRun?: boolean;
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeStoreImageTasksRequest = S.suspend(() =>
  S.Struct({
    ImageIds: S.optional(ImageIdList).pipe(T.XmlName("ImageId")),
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeStoreImageTasksRequest",
}) as any as S.Schema<DescribeStoreImageTasksRequest>;
export interface StoreImageTaskResult {
  AmiId?: string;
  TaskStartTime?: Date;
  Bucket?: string;
  S3objectKey?: string;
  ProgressPercentage?: number;
  StoreTaskState?: string;
  StoreTaskFailureReason?: string;
}
export const StoreImageTaskResult = S.suspend(() =>
  S.Struct({
    AmiId: S.optional(S.String).pipe(
      T.XmlName("amiId"),
      T.Ec2QueryName("AmiId"),
    ),
    TaskStartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("taskStartTime"), T.Ec2QueryName("TaskStartTime")),
    Bucket: S.optional(S.String).pipe(
      T.XmlName("bucket"),
      T.Ec2QueryName("Bucket"),
    ),
    S3objectKey: S.optional(S.String).pipe(
      T.XmlName("s3objectKey"),
      T.Ec2QueryName("S3objectKey"),
    ),
    ProgressPercentage: S.optional(S.Number).pipe(
      T.XmlName("progressPercentage"),
      T.Ec2QueryName("ProgressPercentage"),
    ),
    StoreTaskState: S.optional(S.String).pipe(
      T.XmlName("storeTaskState"),
      T.Ec2QueryName("StoreTaskState"),
    ),
    StoreTaskFailureReason: S.optional(S.String).pipe(
      T.XmlName("storeTaskFailureReason"),
      T.Ec2QueryName("StoreTaskFailureReason"),
    ),
  }),
).annotate({
  identifier: "StoreImageTaskResult",
}) as any as S.Schema<StoreImageTaskResult>;
export type StoreImageTaskResultSet = StoreImageTaskResult[];
export const StoreImageTaskResultSet = S.Array(
  StoreImageTaskResult.pipe(T.XmlName("item")).annotate({
    identifier: "StoreImageTaskResult",
  }),
);
export interface DescribeStoreImageTasksResult {
  StoreImageTaskResults?: StoreImageTaskResult[];
  NextToken?: string;
}
export const DescribeStoreImageTasksResult = S.suspend(() =>
  S.Struct({
    StoreImageTaskResults: S.optional(StoreImageTaskResultSet).pipe(
      T.XmlName("storeImageTaskResultSet"),
      T.Ec2QueryName("StoreImageTaskResultSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeStoreImageTasksResult",
}) as any as S.Schema<DescribeStoreImageTasksResult>;
export type SubnetIdStringList = string[];
export const SubnetIdStringList = S.Array(S.String.pipe(T.XmlName("SubnetId")));
export interface DescribeSubnetsRequest {
  Filters?: Filter[];
  SubnetIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
}
export const DescribeSubnetsRequest = S.suspend(() =>
  S.Struct({
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    SubnetIds: S.optional(SubnetIdStringList).pipe(T.XmlName("SubnetId")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSubnetsRequest",
}) as any as S.Schema<DescribeSubnetsRequest>;
export type SubnetList = Subnet[];
export const SubnetList = S.Array(
  Subnet.pipe(T.XmlName("item")).annotate({ identifier: "Subnet" }),
);
export interface DescribeSubnetsResult {
  NextToken?: string;
  Subnets?: Subnet[];
}
export const DescribeSubnetsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    Subnets: S.optional(SubnetList).pipe(
      T.XmlName("subnetSet"),
      T.Ec2QueryName("SubnetSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeSubnetsResult",
}) as any as S.Schema<DescribeSubnetsResult>;
export interface DescribeTagsRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeTagsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number).pipe(
      T.XmlName("maxResults"),
      T.Ec2QueryName("MaxResults"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTagsRequest",
}) as any as S.Schema<DescribeTagsRequest>;
export interface TagDescription {
  Key?: string;
  ResourceId?: string;
  ResourceType?: ResourceType;
  Value?: string;
}
export const TagDescription = S.suspend(() =>
  S.Struct({
    Key: S.optional(S.String).pipe(T.XmlName("key"), T.Ec2QueryName("Key")),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    ResourceType: S.optional(ResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    Value: S.optional(S.String).pipe(
      T.XmlName("value"),
      T.Ec2QueryName("Value"),
    ),
  }),
).annotate({ identifier: "TagDescription" }) as any as S.Schema<TagDescription>;
export type TagDescriptionList = TagDescription[];
export const TagDescriptionList = S.Array(
  TagDescription.pipe(T.XmlName("item")).annotate({
    identifier: "TagDescription",
  }),
);
export interface DescribeTagsResult {
  NextToken?: string;
  Tags?: TagDescription[];
}
export const DescribeTagsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    Tags: S.optional(TagDescriptionList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTagsResult",
}) as any as S.Schema<DescribeTagsResult>;
export type TrafficMirrorFilterRuleIdList = string[];
export const TrafficMirrorFilterRuleIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeTrafficMirrorFilterRulesRequest {
  TrafficMirrorFilterRuleIds?: string[];
  TrafficMirrorFilterId?: string;
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeTrafficMirrorFilterRulesRequest = S.suspend(() =>
  S.Struct({
    TrafficMirrorFilterRuleIds: S.optional(TrafficMirrorFilterRuleIdList).pipe(
      T.XmlName("TrafficMirrorFilterRuleId"),
    ),
    TrafficMirrorFilterId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTrafficMirrorFilterRulesRequest",
}) as any as S.Schema<DescribeTrafficMirrorFilterRulesRequest>;
export type TrafficMirrorFilterRuleSet = TrafficMirrorFilterRule[];
export const TrafficMirrorFilterRuleSet = S.Array(
  TrafficMirrorFilterRule.pipe(T.XmlName("item")).annotate({
    identifier: "TrafficMirrorFilterRule",
  }),
);
export interface DescribeTrafficMirrorFilterRulesResult {
  TrafficMirrorFilterRules?: TrafficMirrorFilterRule[];
  NextToken?: string;
}
export const DescribeTrafficMirrorFilterRulesResult = S.suspend(() =>
  S.Struct({
    TrafficMirrorFilterRules: S.optional(TrafficMirrorFilterRuleSet).pipe(
      T.XmlName("trafficMirrorFilterRuleSet"),
      T.Ec2QueryName("TrafficMirrorFilterRuleSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTrafficMirrorFilterRulesResult",
}) as any as S.Schema<DescribeTrafficMirrorFilterRulesResult>;
export type TrafficMirrorFilterIdList = string[];
export const TrafficMirrorFilterIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeTrafficMirrorFiltersRequest {
  TrafficMirrorFilterIds?: string[];
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeTrafficMirrorFiltersRequest = S.suspend(() =>
  S.Struct({
    TrafficMirrorFilterIds: S.optional(TrafficMirrorFilterIdList).pipe(
      T.XmlName("TrafficMirrorFilterId"),
    ),
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTrafficMirrorFiltersRequest",
}) as any as S.Schema<DescribeTrafficMirrorFiltersRequest>;
export type TrafficMirrorFilterSet = TrafficMirrorFilter[];
export const TrafficMirrorFilterSet = S.Array(
  TrafficMirrorFilter.pipe(T.XmlName("item")).annotate({
    identifier: "TrafficMirrorFilter",
  }),
);
export interface DescribeTrafficMirrorFiltersResult {
  TrafficMirrorFilters?: TrafficMirrorFilter[];
  NextToken?: string;
}
export const DescribeTrafficMirrorFiltersResult = S.suspend(() =>
  S.Struct({
    TrafficMirrorFilters: S.optional(TrafficMirrorFilterSet).pipe(
      T.XmlName("trafficMirrorFilterSet"),
      T.Ec2QueryName("TrafficMirrorFilterSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTrafficMirrorFiltersResult",
}) as any as S.Schema<DescribeTrafficMirrorFiltersResult>;
export type TrafficMirrorSessionIdList = string[];
export const TrafficMirrorSessionIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeTrafficMirrorSessionsRequest {
  TrafficMirrorSessionIds?: string[];
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeTrafficMirrorSessionsRequest = S.suspend(() =>
  S.Struct({
    TrafficMirrorSessionIds: S.optional(TrafficMirrorSessionIdList).pipe(
      T.XmlName("TrafficMirrorSessionId"),
    ),
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTrafficMirrorSessionsRequest",
}) as any as S.Schema<DescribeTrafficMirrorSessionsRequest>;
export type TrafficMirrorSessionSet = TrafficMirrorSession[];
export const TrafficMirrorSessionSet = S.Array(
  TrafficMirrorSession.pipe(T.XmlName("item")).annotate({
    identifier: "TrafficMirrorSession",
  }),
);
export interface DescribeTrafficMirrorSessionsResult {
  TrafficMirrorSessions?: TrafficMirrorSession[];
  NextToken?: string;
}
export const DescribeTrafficMirrorSessionsResult = S.suspend(() =>
  S.Struct({
    TrafficMirrorSessions: S.optional(TrafficMirrorSessionSet).pipe(
      T.XmlName("trafficMirrorSessionSet"),
      T.Ec2QueryName("TrafficMirrorSessionSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTrafficMirrorSessionsResult",
}) as any as S.Schema<DescribeTrafficMirrorSessionsResult>;
export type TrafficMirrorTargetIdList = string[];
export const TrafficMirrorTargetIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeTrafficMirrorTargetsRequest {
  TrafficMirrorTargetIds?: string[];
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeTrafficMirrorTargetsRequest = S.suspend(() =>
  S.Struct({
    TrafficMirrorTargetIds: S.optional(TrafficMirrorTargetIdList).pipe(
      T.XmlName("TrafficMirrorTargetId"),
    ),
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTrafficMirrorTargetsRequest",
}) as any as S.Schema<DescribeTrafficMirrorTargetsRequest>;
export type TrafficMirrorTargetSet = TrafficMirrorTarget[];
export const TrafficMirrorTargetSet = S.Array(
  TrafficMirrorTarget.pipe(T.XmlName("item")).annotate({
    identifier: "TrafficMirrorTarget",
  }),
);
export interface DescribeTrafficMirrorTargetsResult {
  TrafficMirrorTargets?: TrafficMirrorTarget[];
  NextToken?: string;
}
export const DescribeTrafficMirrorTargetsResult = S.suspend(() =>
  S.Struct({
    TrafficMirrorTargets: S.optional(TrafficMirrorTargetSet).pipe(
      T.XmlName("trafficMirrorTargetSet"),
      T.Ec2QueryName("TrafficMirrorTargetSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTrafficMirrorTargetsResult",
}) as any as S.Schema<DescribeTrafficMirrorTargetsResult>;
export interface DescribeTransitGatewayAttachmentsRequest {
  TransitGatewayAttachmentIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeTransitGatewayAttachmentsRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentIds: S.optional(
      TransitGatewayAttachmentIdStringList,
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTransitGatewayAttachmentsRequest",
}) as any as S.Schema<DescribeTransitGatewayAttachmentsRequest>;
export interface TransitGatewayAttachmentAssociation {
  TransitGatewayRouteTableId?: string;
  State?: TransitGatewayAssociationState;
}
export const TransitGatewayAttachmentAssociation = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayRouteTableId"),
      T.Ec2QueryName("TransitGatewayRouteTableId"),
    ),
    State: S.optional(TransitGatewayAssociationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayAttachmentAssociation",
}) as any as S.Schema<TransitGatewayAttachmentAssociation>;
export interface TransitGatewayAttachment {
  TransitGatewayAttachmentId?: string;
  TransitGatewayId?: string;
  TransitGatewayOwnerId?: string;
  ResourceOwnerId?: string;
  ResourceType?: TransitGatewayAttachmentResourceType;
  ResourceId?: string;
  State?: TransitGatewayAttachmentState;
  Association?: TransitGatewayAttachmentAssociation;
  CreationTime?: Date;
  Tags?: Tag[];
}
export const TransitGatewayAttachment = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayAttachmentId"),
      T.Ec2QueryName("TransitGatewayAttachmentId"),
    ),
    TransitGatewayId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayId"),
      T.Ec2QueryName("TransitGatewayId"),
    ),
    TransitGatewayOwnerId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayOwnerId"),
      T.Ec2QueryName("TransitGatewayOwnerId"),
    ),
    ResourceOwnerId: S.optional(S.String).pipe(
      T.XmlName("resourceOwnerId"),
      T.Ec2QueryName("ResourceOwnerId"),
    ),
    ResourceType: S.optional(TransitGatewayAttachmentResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    State: S.optional(TransitGatewayAttachmentState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Association: S.optional(TransitGatewayAttachmentAssociation)
      .pipe(T.XmlName("association"), T.Ec2QueryName("Association"))
      .annotate({ identifier: "TransitGatewayAttachmentAssociation" }),
    CreationTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("creationTime"), T.Ec2QueryName("CreationTime")),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayAttachment",
}) as any as S.Schema<TransitGatewayAttachment>;
export type TransitGatewayAttachmentList = TransitGatewayAttachment[];
export const TransitGatewayAttachmentList = S.Array(
  TransitGatewayAttachment.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayAttachment",
  }),
);
export interface DescribeTransitGatewayAttachmentsResult {
  TransitGatewayAttachments?: TransitGatewayAttachment[];
  NextToken?: string;
}
export const DescribeTransitGatewayAttachmentsResult = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachments: S.optional(TransitGatewayAttachmentList).pipe(
      T.XmlName("transitGatewayAttachments"),
      T.Ec2QueryName("TransitGatewayAttachments"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTransitGatewayAttachmentsResult",
}) as any as S.Schema<DescribeTransitGatewayAttachmentsResult>;
export type TransitGatewayConnectPeerIdStringList = string[];
export const TransitGatewayConnectPeerIdStringList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeTransitGatewayConnectPeersRequest {
  TransitGatewayConnectPeerIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeTransitGatewayConnectPeersRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayConnectPeerIds: S.optional(
      TransitGatewayConnectPeerIdStringList,
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTransitGatewayConnectPeersRequest",
}) as any as S.Schema<DescribeTransitGatewayConnectPeersRequest>;
export type TransitGatewayConnectPeerList = TransitGatewayConnectPeer[];
export const TransitGatewayConnectPeerList = S.Array(
  TransitGatewayConnectPeer.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayConnectPeer",
  }),
);
export interface DescribeTransitGatewayConnectPeersResult {
  TransitGatewayConnectPeers?: TransitGatewayConnectPeer[];
  NextToken?: string;
}
export const DescribeTransitGatewayConnectPeersResult = S.suspend(() =>
  S.Struct({
    TransitGatewayConnectPeers: S.optional(TransitGatewayConnectPeerList).pipe(
      T.XmlName("transitGatewayConnectPeerSet"),
      T.Ec2QueryName("TransitGatewayConnectPeerSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTransitGatewayConnectPeersResult",
}) as any as S.Schema<DescribeTransitGatewayConnectPeersResult>;
export interface DescribeTransitGatewayConnectsRequest {
  TransitGatewayAttachmentIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeTransitGatewayConnectsRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentIds: S.optional(
      TransitGatewayAttachmentIdStringList,
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTransitGatewayConnectsRequest",
}) as any as S.Schema<DescribeTransitGatewayConnectsRequest>;
export type TransitGatewayConnectList = TransitGatewayConnect[];
export const TransitGatewayConnectList = S.Array(
  TransitGatewayConnect.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayConnect",
  }),
);
export interface DescribeTransitGatewayConnectsResult {
  TransitGatewayConnects?: TransitGatewayConnect[];
  NextToken?: string;
}
export const DescribeTransitGatewayConnectsResult = S.suspend(() =>
  S.Struct({
    TransitGatewayConnects: S.optional(TransitGatewayConnectList).pipe(
      T.XmlName("transitGatewayConnectSet"),
      T.Ec2QueryName("TransitGatewayConnectSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTransitGatewayConnectsResult",
}) as any as S.Schema<DescribeTransitGatewayConnectsResult>;
export type TransitGatewayMeteringPolicyIdStringList = string[];
export const TransitGatewayMeteringPolicyIdStringList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeTransitGatewayMeteringPoliciesRequest {
  TransitGatewayMeteringPolicyIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeTransitGatewayMeteringPoliciesRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayMeteringPolicyIds: S.optional(
      TransitGatewayMeteringPolicyIdStringList,
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTransitGatewayMeteringPoliciesRequest",
}) as any as S.Schema<DescribeTransitGatewayMeteringPoliciesRequest>;
export type TransitGatewayMeteringPolicyList = TransitGatewayMeteringPolicy[];
export const TransitGatewayMeteringPolicyList = S.Array(
  TransitGatewayMeteringPolicy.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayMeteringPolicy",
  }),
);
export interface DescribeTransitGatewayMeteringPoliciesResult {
  TransitGatewayMeteringPolicies?: TransitGatewayMeteringPolicy[];
  NextToken?: string;
}
export const DescribeTransitGatewayMeteringPoliciesResult = S.suspend(() =>
  S.Struct({
    TransitGatewayMeteringPolicies: S.optional(
      TransitGatewayMeteringPolicyList,
    ).pipe(
      T.XmlName("transitGatewayMeteringPolicies"),
      T.Ec2QueryName("TransitGatewayMeteringPolicies"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTransitGatewayMeteringPoliciesResult",
}) as any as S.Schema<DescribeTransitGatewayMeteringPoliciesResult>;
export type TransitGatewayMulticastDomainIdStringList = string[];
export const TransitGatewayMulticastDomainIdStringList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeTransitGatewayMulticastDomainsRequest {
  TransitGatewayMulticastDomainIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeTransitGatewayMulticastDomainsRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayMulticastDomainIds: S.optional(
      TransitGatewayMulticastDomainIdStringList,
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTransitGatewayMulticastDomainsRequest",
}) as any as S.Schema<DescribeTransitGatewayMulticastDomainsRequest>;
export type TransitGatewayMulticastDomainList = TransitGatewayMulticastDomain[];
export const TransitGatewayMulticastDomainList = S.Array(
  TransitGatewayMulticastDomain.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayMulticastDomain",
  }),
);
export interface DescribeTransitGatewayMulticastDomainsResult {
  TransitGatewayMulticastDomains?: TransitGatewayMulticastDomain[];
  NextToken?: string;
}
export const DescribeTransitGatewayMulticastDomainsResult = S.suspend(() =>
  S.Struct({
    TransitGatewayMulticastDomains: S.optional(
      TransitGatewayMulticastDomainList,
    ).pipe(
      T.XmlName("transitGatewayMulticastDomains"),
      T.Ec2QueryName("TransitGatewayMulticastDomains"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTransitGatewayMulticastDomainsResult",
}) as any as S.Schema<DescribeTransitGatewayMulticastDomainsResult>;
export interface DescribeTransitGatewayPeeringAttachmentsRequest {
  TransitGatewayAttachmentIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeTransitGatewayPeeringAttachmentsRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentIds: S.optional(
      TransitGatewayAttachmentIdStringList,
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTransitGatewayPeeringAttachmentsRequest",
}) as any as S.Schema<DescribeTransitGatewayPeeringAttachmentsRequest>;
export type TransitGatewayPeeringAttachmentList =
  TransitGatewayPeeringAttachment[];
export const TransitGatewayPeeringAttachmentList = S.Array(
  TransitGatewayPeeringAttachment.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayPeeringAttachment",
  }),
);
export interface DescribeTransitGatewayPeeringAttachmentsResult {
  TransitGatewayPeeringAttachments?: TransitGatewayPeeringAttachment[];
  NextToken?: string;
}
export const DescribeTransitGatewayPeeringAttachmentsResult = S.suspend(() =>
  S.Struct({
    TransitGatewayPeeringAttachments: S.optional(
      TransitGatewayPeeringAttachmentList,
    ).pipe(
      T.XmlName("transitGatewayPeeringAttachments"),
      T.Ec2QueryName("TransitGatewayPeeringAttachments"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTransitGatewayPeeringAttachmentsResult",
}) as any as S.Schema<DescribeTransitGatewayPeeringAttachmentsResult>;
export type TransitGatewayPolicyTableIdStringList = string[];
export const TransitGatewayPolicyTableIdStringList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeTransitGatewayPolicyTablesRequest {
  TransitGatewayPolicyTableIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeTransitGatewayPolicyTablesRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayPolicyTableIds: S.optional(
      TransitGatewayPolicyTableIdStringList,
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTransitGatewayPolicyTablesRequest",
}) as any as S.Schema<DescribeTransitGatewayPolicyTablesRequest>;
export type TransitGatewayPolicyTableList = TransitGatewayPolicyTable[];
export const TransitGatewayPolicyTableList = S.Array(
  TransitGatewayPolicyTable.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayPolicyTable",
  }),
);
export interface DescribeTransitGatewayPolicyTablesResult {
  TransitGatewayPolicyTables?: TransitGatewayPolicyTable[];
  NextToken?: string;
}
export const DescribeTransitGatewayPolicyTablesResult = S.suspend(() =>
  S.Struct({
    TransitGatewayPolicyTables: S.optional(TransitGatewayPolicyTableList).pipe(
      T.XmlName("transitGatewayPolicyTables"),
      T.Ec2QueryName("TransitGatewayPolicyTables"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTransitGatewayPolicyTablesResult",
}) as any as S.Schema<DescribeTransitGatewayPolicyTablesResult>;
export type TransitGatewayRouteTableAnnouncementIdStringList = string[];
export const TransitGatewayRouteTableAnnouncementIdStringList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeTransitGatewayRouteTableAnnouncementsRequest {
  TransitGatewayRouteTableAnnouncementIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeTransitGatewayRouteTableAnnouncementsRequest = S.suspend(
  () =>
    S.Struct({
      TransitGatewayRouteTableAnnouncementIds: S.optional(
        TransitGatewayRouteTableAnnouncementIdStringList,
      ),
      Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
      MaxResults: S.optional(S.Number),
      NextToken: S.optional(S.String),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "DescribeTransitGatewayRouteTableAnnouncementsRequest",
}) as any as S.Schema<DescribeTransitGatewayRouteTableAnnouncementsRequest>;
export type TransitGatewayRouteTableAnnouncementList =
  TransitGatewayRouteTableAnnouncement[];
export const TransitGatewayRouteTableAnnouncementList = S.Array(
  TransitGatewayRouteTableAnnouncement.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayRouteTableAnnouncement",
  }),
);
export interface DescribeTransitGatewayRouteTableAnnouncementsResult {
  TransitGatewayRouteTableAnnouncements?: TransitGatewayRouteTableAnnouncement[];
  NextToken?: string;
}
export const DescribeTransitGatewayRouteTableAnnouncementsResult = S.suspend(
  () =>
    S.Struct({
      TransitGatewayRouteTableAnnouncements: S.optional(
        TransitGatewayRouteTableAnnouncementList,
      ).pipe(
        T.XmlName("transitGatewayRouteTableAnnouncements"),
        T.Ec2QueryName("TransitGatewayRouteTableAnnouncements"),
      ),
      NextToken: S.optional(S.String).pipe(
        T.XmlName("nextToken"),
        T.Ec2QueryName("NextToken"),
      ),
    }).pipe(ns),
).annotate({
  identifier: "DescribeTransitGatewayRouteTableAnnouncementsResult",
}) as any as S.Schema<DescribeTransitGatewayRouteTableAnnouncementsResult>;
export type TransitGatewayRouteTableIdStringList = string[];
export const TransitGatewayRouteTableIdStringList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeTransitGatewayRouteTablesRequest {
  TransitGatewayRouteTableIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeTransitGatewayRouteTablesRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableIds: S.optional(
      TransitGatewayRouteTableIdStringList,
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTransitGatewayRouteTablesRequest",
}) as any as S.Schema<DescribeTransitGatewayRouteTablesRequest>;
export type TransitGatewayRouteTableList = TransitGatewayRouteTable[];
export const TransitGatewayRouteTableList = S.Array(
  TransitGatewayRouteTable.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayRouteTable",
  }),
);
export interface DescribeTransitGatewayRouteTablesResult {
  TransitGatewayRouteTables?: TransitGatewayRouteTable[];
  NextToken?: string;
}
export const DescribeTransitGatewayRouteTablesResult = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTables: S.optional(TransitGatewayRouteTableList).pipe(
      T.XmlName("transitGatewayRouteTables"),
      T.Ec2QueryName("TransitGatewayRouteTables"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTransitGatewayRouteTablesResult",
}) as any as S.Schema<DescribeTransitGatewayRouteTablesResult>;
export type TransitGatewayIdStringList = string[];
export const TransitGatewayIdStringList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeTransitGatewaysRequest {
  TransitGatewayIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeTransitGatewaysRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayIds: S.optional(TransitGatewayIdStringList),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTransitGatewaysRequest",
}) as any as S.Schema<DescribeTransitGatewaysRequest>;
export type TransitGatewayList = TransitGateway[];
export const TransitGatewayList = S.Array(
  TransitGateway.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGateway",
  }),
);
export interface DescribeTransitGatewaysResult {
  TransitGateways?: TransitGateway[];
  NextToken?: string;
}
export const DescribeTransitGatewaysResult = S.suspend(() =>
  S.Struct({
    TransitGateways: S.optional(TransitGatewayList).pipe(
      T.XmlName("transitGatewaySet"),
      T.Ec2QueryName("TransitGatewaySet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTransitGatewaysResult",
}) as any as S.Schema<DescribeTransitGatewaysResult>;
export interface DescribeTransitGatewayVpcAttachmentsRequest {
  TransitGatewayAttachmentIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeTransitGatewayVpcAttachmentsRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentIds: S.optional(
      TransitGatewayAttachmentIdStringList,
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTransitGatewayVpcAttachmentsRequest",
}) as any as S.Schema<DescribeTransitGatewayVpcAttachmentsRequest>;
export type TransitGatewayVpcAttachmentList = TransitGatewayVpcAttachment[];
export const TransitGatewayVpcAttachmentList = S.Array(
  TransitGatewayVpcAttachment.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayVpcAttachment",
  }),
);
export interface DescribeTransitGatewayVpcAttachmentsResult {
  TransitGatewayVpcAttachments?: TransitGatewayVpcAttachment[];
  NextToken?: string;
}
export const DescribeTransitGatewayVpcAttachmentsResult = S.suspend(() =>
  S.Struct({
    TransitGatewayVpcAttachments: S.optional(
      TransitGatewayVpcAttachmentList,
    ).pipe(
      T.XmlName("transitGatewayVpcAttachments"),
      T.Ec2QueryName("TransitGatewayVpcAttachments"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTransitGatewayVpcAttachmentsResult",
}) as any as S.Schema<DescribeTransitGatewayVpcAttachmentsResult>;
export type TrunkInterfaceAssociationIdList = string[];
export const TrunkInterfaceAssociationIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeTrunkInterfaceAssociationsRequest {
  AssociationIds?: string[];
  DryRun?: boolean;
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeTrunkInterfaceAssociationsRequest = S.suspend(() =>
  S.Struct({
    AssociationIds: S.optional(TrunkInterfaceAssociationIdList).pipe(
      T.XmlName("AssociationId"),
    ),
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTrunkInterfaceAssociationsRequest",
}) as any as S.Schema<DescribeTrunkInterfaceAssociationsRequest>;
export type TrunkInterfaceAssociationList = TrunkInterfaceAssociation[];
export const TrunkInterfaceAssociationList = S.Array(
  TrunkInterfaceAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "TrunkInterfaceAssociation",
  }),
);
export interface DescribeTrunkInterfaceAssociationsResult {
  InterfaceAssociations?: TrunkInterfaceAssociation[];
  NextToken?: string;
}
export const DescribeTrunkInterfaceAssociationsResult = S.suspend(() =>
  S.Struct({
    InterfaceAssociations: S.optional(TrunkInterfaceAssociationList).pipe(
      T.XmlName("interfaceAssociationSet"),
      T.Ec2QueryName("InterfaceAssociationSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTrunkInterfaceAssociationsResult",
}) as any as S.Schema<DescribeTrunkInterfaceAssociationsResult>;
export type VerifiedAccessEndpointIdList = string[];
export const VerifiedAccessEndpointIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeVerifiedAccessEndpointsRequest {
  VerifiedAccessEndpointIds?: string[];
  VerifiedAccessInstanceId?: string;
  VerifiedAccessGroupId?: string;
  MaxResults?: number;
  NextToken?: string;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeVerifiedAccessEndpointsRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessEndpointIds: S.optional(VerifiedAccessEndpointIdList).pipe(
      T.XmlName("VerifiedAccessEndpointId"),
    ),
    VerifiedAccessInstanceId: S.optional(S.String),
    VerifiedAccessGroupId: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVerifiedAccessEndpointsRequest",
}) as any as S.Schema<DescribeVerifiedAccessEndpointsRequest>;
export type VerifiedAccessEndpointList = VerifiedAccessEndpoint[];
export const VerifiedAccessEndpointList = S.Array(
  VerifiedAccessEndpoint.pipe(T.XmlName("item")).annotate({
    identifier: "VerifiedAccessEndpoint",
  }),
);
export interface DescribeVerifiedAccessEndpointsResult {
  VerifiedAccessEndpoints?: VerifiedAccessEndpoint[];
  NextToken?: string;
}
export const DescribeVerifiedAccessEndpointsResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessEndpoints: S.optional(VerifiedAccessEndpointList).pipe(
      T.XmlName("verifiedAccessEndpointSet"),
      T.Ec2QueryName("VerifiedAccessEndpointSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVerifiedAccessEndpointsResult",
}) as any as S.Schema<DescribeVerifiedAccessEndpointsResult>;
export type VerifiedAccessGroupIdList = string[];
export const VerifiedAccessGroupIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeVerifiedAccessGroupsRequest {
  VerifiedAccessGroupIds?: string[];
  VerifiedAccessInstanceId?: string;
  MaxResults?: number;
  NextToken?: string;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeVerifiedAccessGroupsRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessGroupIds: S.optional(VerifiedAccessGroupIdList).pipe(
      T.XmlName("VerifiedAccessGroupId"),
    ),
    VerifiedAccessInstanceId: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVerifiedAccessGroupsRequest",
}) as any as S.Schema<DescribeVerifiedAccessGroupsRequest>;
export type VerifiedAccessGroupList = VerifiedAccessGroup[];
export const VerifiedAccessGroupList = S.Array(
  VerifiedAccessGroup.pipe(T.XmlName("item")).annotate({
    identifier: "VerifiedAccessGroup",
  }),
);
export interface DescribeVerifiedAccessGroupsResult {
  VerifiedAccessGroups?: VerifiedAccessGroup[];
  NextToken?: string;
}
export const DescribeVerifiedAccessGroupsResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessGroups: S.optional(VerifiedAccessGroupList).pipe(
      T.XmlName("verifiedAccessGroupSet"),
      T.Ec2QueryName("VerifiedAccessGroupSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVerifiedAccessGroupsResult",
}) as any as S.Schema<DescribeVerifiedAccessGroupsResult>;
export type VerifiedAccessInstanceIdList = string[];
export const VerifiedAccessInstanceIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeVerifiedAccessInstanceLoggingConfigurationsRequest {
  VerifiedAccessInstanceIds?: string[];
  MaxResults?: number;
  NextToken?: string;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeVerifiedAccessInstanceLoggingConfigurationsRequest =
  S.suspend(() =>
    S.Struct({
      VerifiedAccessInstanceIds: S.optional(VerifiedAccessInstanceIdList).pipe(
        T.XmlName("VerifiedAccessInstanceId"),
      ),
      MaxResults: S.optional(S.Number),
      NextToken: S.optional(S.String),
      Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
  ).annotate({
    identifier: "DescribeVerifiedAccessInstanceLoggingConfigurationsRequest",
  }) as any as S.Schema<DescribeVerifiedAccessInstanceLoggingConfigurationsRequest>;
export type VerifiedAccessLogDeliveryStatusCode =
  | "success"
  | "failed"
  | (string & {});
export const VerifiedAccessLogDeliveryStatusCode = S.String;
export interface VerifiedAccessLogDeliveryStatus {
  Code?: VerifiedAccessLogDeliveryStatusCode;
  Message?: string;
}
export const VerifiedAccessLogDeliveryStatus = S.suspend(() =>
  S.Struct({
    Code: S.optional(VerifiedAccessLogDeliveryStatusCode).pipe(
      T.XmlName("code"),
      T.Ec2QueryName("Code"),
    ),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "VerifiedAccessLogDeliveryStatus",
}) as any as S.Schema<VerifiedAccessLogDeliveryStatus>;
export interface VerifiedAccessLogS3Destination {
  Enabled?: boolean;
  DeliveryStatus?: VerifiedAccessLogDeliveryStatus;
  BucketName?: string;
  Prefix?: string;
  BucketOwner?: string;
}
export const VerifiedAccessLogS3Destination = S.suspend(() =>
  S.Struct({
    Enabled: S.optional(S.Boolean).pipe(
      T.XmlName("enabled"),
      T.Ec2QueryName("Enabled"),
    ),
    DeliveryStatus: S.optional(VerifiedAccessLogDeliveryStatus)
      .pipe(T.XmlName("deliveryStatus"), T.Ec2QueryName("DeliveryStatus"))
      .annotate({ identifier: "VerifiedAccessLogDeliveryStatus" }),
    BucketName: S.optional(S.String).pipe(
      T.XmlName("bucketName"),
      T.Ec2QueryName("BucketName"),
    ),
    Prefix: S.optional(S.String).pipe(
      T.XmlName("prefix"),
      T.Ec2QueryName("Prefix"),
    ),
    BucketOwner: S.optional(S.String).pipe(
      T.XmlName("bucketOwner"),
      T.Ec2QueryName("BucketOwner"),
    ),
  }),
).annotate({
  identifier: "VerifiedAccessLogS3Destination",
}) as any as S.Schema<VerifiedAccessLogS3Destination>;
export interface VerifiedAccessLogCloudWatchLogsDestination {
  Enabled?: boolean;
  DeliveryStatus?: VerifiedAccessLogDeliveryStatus;
  LogGroup?: string;
}
export const VerifiedAccessLogCloudWatchLogsDestination = S.suspend(() =>
  S.Struct({
    Enabled: S.optional(S.Boolean).pipe(
      T.XmlName("enabled"),
      T.Ec2QueryName("Enabled"),
    ),
    DeliveryStatus: S.optional(VerifiedAccessLogDeliveryStatus)
      .pipe(T.XmlName("deliveryStatus"), T.Ec2QueryName("DeliveryStatus"))
      .annotate({ identifier: "VerifiedAccessLogDeliveryStatus" }),
    LogGroup: S.optional(S.String).pipe(
      T.XmlName("logGroup"),
      T.Ec2QueryName("LogGroup"),
    ),
  }),
).annotate({
  identifier: "VerifiedAccessLogCloudWatchLogsDestination",
}) as any as S.Schema<VerifiedAccessLogCloudWatchLogsDestination>;
export interface VerifiedAccessLogKinesisDataFirehoseDestination {
  Enabled?: boolean;
  DeliveryStatus?: VerifiedAccessLogDeliveryStatus;
  DeliveryStream?: string;
}
export const VerifiedAccessLogKinesisDataFirehoseDestination = S.suspend(() =>
  S.Struct({
    Enabled: S.optional(S.Boolean).pipe(
      T.XmlName("enabled"),
      T.Ec2QueryName("Enabled"),
    ),
    DeliveryStatus: S.optional(VerifiedAccessLogDeliveryStatus)
      .pipe(T.XmlName("deliveryStatus"), T.Ec2QueryName("DeliveryStatus"))
      .annotate({ identifier: "VerifiedAccessLogDeliveryStatus" }),
    DeliveryStream: S.optional(S.String).pipe(
      T.XmlName("deliveryStream"),
      T.Ec2QueryName("DeliveryStream"),
    ),
  }),
).annotate({
  identifier: "VerifiedAccessLogKinesisDataFirehoseDestination",
}) as any as S.Schema<VerifiedAccessLogKinesisDataFirehoseDestination>;
export interface VerifiedAccessLogs {
  S3?: VerifiedAccessLogS3Destination;
  CloudWatchLogs?: VerifiedAccessLogCloudWatchLogsDestination;
  KinesisDataFirehose?: VerifiedAccessLogKinesisDataFirehoseDestination;
  LogVersion?: string;
  IncludeTrustContext?: boolean;
}
export const VerifiedAccessLogs = S.suspend(() =>
  S.Struct({
    S3: S.optional(VerifiedAccessLogS3Destination)
      .pipe(T.XmlName("s3"), T.Ec2QueryName("S3"))
      .annotate({ identifier: "VerifiedAccessLogS3Destination" }),
    CloudWatchLogs: S.optional(VerifiedAccessLogCloudWatchLogsDestination)
      .pipe(T.XmlName("cloudWatchLogs"), T.Ec2QueryName("CloudWatchLogs"))
      .annotate({ identifier: "VerifiedAccessLogCloudWatchLogsDestination" }),
    KinesisDataFirehose: S.optional(
      VerifiedAccessLogKinesisDataFirehoseDestination,
    )
      .pipe(
        T.XmlName("kinesisDataFirehose"),
        T.Ec2QueryName("KinesisDataFirehose"),
      )
      .annotate({
        identifier: "VerifiedAccessLogKinesisDataFirehoseDestination",
      }),
    LogVersion: S.optional(S.String).pipe(
      T.XmlName("logVersion"),
      T.Ec2QueryName("LogVersion"),
    ),
    IncludeTrustContext: S.optional(S.Boolean).pipe(
      T.XmlName("includeTrustContext"),
      T.Ec2QueryName("IncludeTrustContext"),
    ),
  }),
).annotate({
  identifier: "VerifiedAccessLogs",
}) as any as S.Schema<VerifiedAccessLogs>;
export interface VerifiedAccessInstanceLoggingConfiguration {
  VerifiedAccessInstanceId?: string;
  AccessLogs?: VerifiedAccessLogs;
}
export const VerifiedAccessInstanceLoggingConfiguration = S.suspend(() =>
  S.Struct({
    VerifiedAccessInstanceId: S.optional(S.String).pipe(
      T.XmlName("verifiedAccessInstanceId"),
      T.Ec2QueryName("VerifiedAccessInstanceId"),
    ),
    AccessLogs: S.optional(VerifiedAccessLogs)
      .pipe(T.XmlName("accessLogs"), T.Ec2QueryName("AccessLogs"))
      .annotate({ identifier: "VerifiedAccessLogs" }),
  }),
).annotate({
  identifier: "VerifiedAccessInstanceLoggingConfiguration",
}) as any as S.Schema<VerifiedAccessInstanceLoggingConfiguration>;
export type VerifiedAccessInstanceLoggingConfigurationList =
  VerifiedAccessInstanceLoggingConfiguration[];
export const VerifiedAccessInstanceLoggingConfigurationList = S.Array(
  VerifiedAccessInstanceLoggingConfiguration.pipe(T.XmlName("item")).annotate({
    identifier: "VerifiedAccessInstanceLoggingConfiguration",
  }),
);
export interface DescribeVerifiedAccessInstanceLoggingConfigurationsResult {
  LoggingConfigurations?: VerifiedAccessInstanceLoggingConfiguration[];
  NextToken?: string;
}
export const DescribeVerifiedAccessInstanceLoggingConfigurationsResult =
  S.suspend(() =>
    S.Struct({
      LoggingConfigurations: S.optional(
        VerifiedAccessInstanceLoggingConfigurationList,
      ).pipe(
        T.XmlName("loggingConfigurationSet"),
        T.Ec2QueryName("LoggingConfigurationSet"),
      ),
      NextToken: S.optional(S.String).pipe(
        T.XmlName("nextToken"),
        T.Ec2QueryName("NextToken"),
      ),
    }).pipe(ns),
  ).annotate({
    identifier: "DescribeVerifiedAccessInstanceLoggingConfigurationsResult",
  }) as any as S.Schema<DescribeVerifiedAccessInstanceLoggingConfigurationsResult>;
export interface DescribeVerifiedAccessInstancesRequest {
  VerifiedAccessInstanceIds?: string[];
  MaxResults?: number;
  NextToken?: string;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeVerifiedAccessInstancesRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessInstanceIds: S.optional(VerifiedAccessInstanceIdList).pipe(
      T.XmlName("VerifiedAccessInstanceId"),
    ),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVerifiedAccessInstancesRequest",
}) as any as S.Schema<DescribeVerifiedAccessInstancesRequest>;
export type VerifiedAccessInstanceList = VerifiedAccessInstance[];
export const VerifiedAccessInstanceList = S.Array(
  VerifiedAccessInstance.pipe(T.XmlName("item")).annotate({
    identifier: "VerifiedAccessInstance",
  }),
);
export interface DescribeVerifiedAccessInstancesResult {
  VerifiedAccessInstances?: VerifiedAccessInstance[];
  NextToken?: string;
}
export const DescribeVerifiedAccessInstancesResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessInstances: S.optional(VerifiedAccessInstanceList).pipe(
      T.XmlName("verifiedAccessInstanceSet"),
      T.Ec2QueryName("VerifiedAccessInstanceSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVerifiedAccessInstancesResult",
}) as any as S.Schema<DescribeVerifiedAccessInstancesResult>;
export type VerifiedAccessTrustProviderIdList = string[];
export const VerifiedAccessTrustProviderIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeVerifiedAccessTrustProvidersRequest {
  VerifiedAccessTrustProviderIds?: string[];
  MaxResults?: number;
  NextToken?: string;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const DescribeVerifiedAccessTrustProvidersRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessTrustProviderIds: S.optional(
      VerifiedAccessTrustProviderIdList,
    ).pipe(T.XmlName("VerifiedAccessTrustProviderId")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVerifiedAccessTrustProvidersRequest",
}) as any as S.Schema<DescribeVerifiedAccessTrustProvidersRequest>;
export type VerifiedAccessTrustProviderList = VerifiedAccessTrustProvider[];
export const VerifiedAccessTrustProviderList = S.Array(
  VerifiedAccessTrustProvider.pipe(T.XmlName("item")).annotate({
    identifier: "VerifiedAccessTrustProvider",
  }),
);
export interface DescribeVerifiedAccessTrustProvidersResult {
  VerifiedAccessTrustProviders?: VerifiedAccessTrustProvider[];
  NextToken?: string;
}
export const DescribeVerifiedAccessTrustProvidersResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessTrustProviders: S.optional(
      VerifiedAccessTrustProviderList,
    ).pipe(
      T.XmlName("verifiedAccessTrustProviderSet"),
      T.Ec2QueryName("VerifiedAccessTrustProviderSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVerifiedAccessTrustProvidersResult",
}) as any as S.Schema<DescribeVerifiedAccessTrustProvidersResult>;
export type VolumeAttributeName =
  | "autoEnableIO"
  | "productCodes"
  | (string & {});
export const VolumeAttributeName = S.String;
export interface DescribeVolumeAttributeRequest {
  Attribute?: VolumeAttributeName;
  VolumeId?: string;
  DryRun?: boolean;
}
export const DescribeVolumeAttributeRequest = S.suspend(() =>
  S.Struct({
    Attribute: S.optional(VolumeAttributeName),
    VolumeId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVolumeAttributeRequest",
}) as any as S.Schema<DescribeVolumeAttributeRequest>;
export interface DescribeVolumeAttributeResult {
  AutoEnableIO?: AttributeBooleanValue;
  ProductCodes?: ProductCode[];
  VolumeId?: string;
}
export const DescribeVolumeAttributeResult = S.suspend(() =>
  S.Struct({
    AutoEnableIO: S.optional(AttributeBooleanValue)
      .pipe(T.XmlName("autoEnableIO"), T.Ec2QueryName("AutoEnableIO"))
      .annotate({ identifier: "AttributeBooleanValue" }),
    ProductCodes: S.optional(ProductCodeList).pipe(
      T.XmlName("productCodes"),
      T.Ec2QueryName("ProductCodes"),
    ),
    VolumeId: S.optional(S.String).pipe(
      T.XmlName("volumeId"),
      T.Ec2QueryName("VolumeId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVolumeAttributeResult",
}) as any as S.Schema<DescribeVolumeAttributeResult>;
export interface DescribeVolumesRequest {
  VolumeIds?: string[];
  DryRun?: boolean;
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeVolumesRequest = S.suspend(() =>
  S.Struct({
    VolumeIds: S.optional(VolumeIdStringList).pipe(T.XmlName("VolumeId")),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    MaxResults: S.optional(S.Number).pipe(
      T.XmlName("maxResults"),
      T.Ec2QueryName("MaxResults"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVolumesRequest",
}) as any as S.Schema<DescribeVolumesRequest>;
export interface DescribeVolumesResult {
  NextToken?: string;
  Volumes?: Volume[];
}
export const DescribeVolumesResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    Volumes: S.optional(VolumeList).pipe(
      T.XmlName("volumeSet"),
      T.Ec2QueryName("VolumeSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVolumesResult",
}) as any as S.Schema<DescribeVolumesResult>;
export interface DescribeVolumesModificationsRequest {
  DryRun?: boolean;
  VolumeIds?: string[];
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeVolumesModificationsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    VolumeIds: S.optional(VolumeIdStringList).pipe(T.XmlName("VolumeId")),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVolumesModificationsRequest",
}) as any as S.Schema<DescribeVolumesModificationsRequest>;
export type VolumeModificationState =
  | "modifying"
  | "optimizing"
  | "completed"
  | "failed"
  | (string & {});
export const VolumeModificationState = S.String;
export interface VolumeModification {
  VolumeId?: string;
  ModificationState?: VolumeModificationState;
  StatusMessage?: string;
  TargetSize?: number;
  TargetIops?: number;
  TargetVolumeType?: VolumeType;
  TargetThroughput?: number;
  TargetMultiAttachEnabled?: boolean;
  OriginalSize?: number;
  OriginalIops?: number;
  OriginalVolumeType?: VolumeType;
  OriginalThroughput?: number;
  OriginalMultiAttachEnabled?: boolean;
  Progress?: number;
  StartTime?: Date;
  EndTime?: Date;
}
export const VolumeModification = S.suspend(() =>
  S.Struct({
    VolumeId: S.optional(S.String).pipe(
      T.XmlName("volumeId"),
      T.Ec2QueryName("VolumeId"),
    ),
    ModificationState: S.optional(VolumeModificationState).pipe(
      T.XmlName("modificationState"),
      T.Ec2QueryName("ModificationState"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    TargetSize: S.optional(S.Number).pipe(
      T.XmlName("targetSize"),
      T.Ec2QueryName("TargetSize"),
    ),
    TargetIops: S.optional(S.Number).pipe(
      T.XmlName("targetIops"),
      T.Ec2QueryName("TargetIops"),
    ),
    TargetVolumeType: S.optional(VolumeType).pipe(
      T.XmlName("targetVolumeType"),
      T.Ec2QueryName("TargetVolumeType"),
    ),
    TargetThroughput: S.optional(S.Number).pipe(
      T.XmlName("targetThroughput"),
      T.Ec2QueryName("TargetThroughput"),
    ),
    TargetMultiAttachEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("targetMultiAttachEnabled"),
      T.Ec2QueryName("TargetMultiAttachEnabled"),
    ),
    OriginalSize: S.optional(S.Number).pipe(
      T.XmlName("originalSize"),
      T.Ec2QueryName("OriginalSize"),
    ),
    OriginalIops: S.optional(S.Number).pipe(
      T.XmlName("originalIops"),
      T.Ec2QueryName("OriginalIops"),
    ),
    OriginalVolumeType: S.optional(VolumeType).pipe(
      T.XmlName("originalVolumeType"),
      T.Ec2QueryName("OriginalVolumeType"),
    ),
    OriginalThroughput: S.optional(S.Number).pipe(
      T.XmlName("originalThroughput"),
      T.Ec2QueryName("OriginalThroughput"),
    ),
    OriginalMultiAttachEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("originalMultiAttachEnabled"),
      T.Ec2QueryName("OriginalMultiAttachEnabled"),
    ),
    Progress: S.optional(S.Number).pipe(
      T.XmlName("progress"),
      T.Ec2QueryName("Progress"),
    ),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startTime"), T.Ec2QueryName("StartTime")),
    EndTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("endTime"), T.Ec2QueryName("EndTime")),
  }),
).annotate({
  identifier: "VolumeModification",
}) as any as S.Schema<VolumeModification>;
export type VolumeModificationList = VolumeModification[];
export const VolumeModificationList = S.Array(
  VolumeModification.pipe(T.XmlName("item")).annotate({
    identifier: "VolumeModification",
  }),
);
export interface DescribeVolumesModificationsResult {
  NextToken?: string;
  VolumesModifications?: VolumeModification[];
}
export const DescribeVolumesModificationsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    VolumesModifications: S.optional(VolumeModificationList).pipe(
      T.XmlName("volumeModificationSet"),
      T.Ec2QueryName("VolumeModificationSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVolumesModificationsResult",
}) as any as S.Schema<DescribeVolumesModificationsResult>;
export interface DescribeVolumeStatusRequest {
  MaxResults?: number;
  NextToken?: string;
  VolumeIds?: string[];
  DryRun?: boolean;
  Filters?: Filter[];
}
export const DescribeVolumeStatusRequest = S.suspend(() =>
  S.Struct({
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    VolumeIds: S.optional(VolumeIdStringList).pipe(T.XmlName("VolumeId")),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVolumeStatusRequest",
}) as any as S.Schema<DescribeVolumeStatusRequest>;
export interface VolumeStatusAction {
  Code?: string;
  Description?: string;
  EventId?: string;
  EventType?: string;
}
export const VolumeStatusAction = S.suspend(() =>
  S.Struct({
    Code: S.optional(S.String).pipe(T.XmlName("code"), T.Ec2QueryName("Code")),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    EventId: S.optional(S.String).pipe(
      T.XmlName("eventId"),
      T.Ec2QueryName("EventId"),
    ),
    EventType: S.optional(S.String).pipe(
      T.XmlName("eventType"),
      T.Ec2QueryName("EventType"),
    ),
  }),
).annotate({
  identifier: "VolumeStatusAction",
}) as any as S.Schema<VolumeStatusAction>;
export type VolumeStatusActionsList = VolumeStatusAction[];
export const VolumeStatusActionsList = S.Array(
  VolumeStatusAction.pipe(T.XmlName("item")).annotate({
    identifier: "VolumeStatusAction",
  }),
);
export interface VolumeStatusEvent {
  Description?: string;
  EventId?: string;
  EventType?: string;
  NotAfter?: Date;
  NotBefore?: Date;
  InstanceId?: string;
}
export const VolumeStatusEvent = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    EventId: S.optional(S.String).pipe(
      T.XmlName("eventId"),
      T.Ec2QueryName("EventId"),
    ),
    EventType: S.optional(S.String).pipe(
      T.XmlName("eventType"),
      T.Ec2QueryName("EventType"),
    ),
    NotAfter: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("notAfter"), T.Ec2QueryName("NotAfter")),
    NotBefore: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("notBefore"), T.Ec2QueryName("NotBefore")),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
  }),
).annotate({
  identifier: "VolumeStatusEvent",
}) as any as S.Schema<VolumeStatusEvent>;
export type VolumeStatusEventsList = VolumeStatusEvent[];
export const VolumeStatusEventsList = S.Array(
  VolumeStatusEvent.pipe(T.XmlName("item")).annotate({
    identifier: "VolumeStatusEvent",
  }),
);
export type VolumeStatusName =
  | "io-enabled"
  | "io-performance"
  | "initialization-state"
  | (string & {});
export const VolumeStatusName = S.String;
export interface VolumeStatusDetails {
  Name?: VolumeStatusName;
  Status?: string;
}
export const VolumeStatusDetails = S.suspend(() =>
  S.Struct({
    Name: S.optional(VolumeStatusName).pipe(
      T.XmlName("name"),
      T.Ec2QueryName("Name"),
    ),
    Status: S.optional(S.String).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
  }),
).annotate({
  identifier: "VolumeStatusDetails",
}) as any as S.Schema<VolumeStatusDetails>;
export type VolumeStatusDetailsList = VolumeStatusDetails[];
export const VolumeStatusDetailsList = S.Array(
  VolumeStatusDetails.pipe(T.XmlName("item")).annotate({
    identifier: "VolumeStatusDetails",
  }),
);
export type VolumeStatusInfoStatus =
  | "ok"
  | "impaired"
  | "insufficient-data"
  | "warning"
  | (string & {});
export const VolumeStatusInfoStatus = S.String;
export interface VolumeStatusInfo {
  Details?: VolumeStatusDetails[];
  Status?: VolumeStatusInfoStatus;
}
export const VolumeStatusInfo = S.suspend(() =>
  S.Struct({
    Details: S.optional(VolumeStatusDetailsList).pipe(
      T.XmlName("details"),
      T.Ec2QueryName("Details"),
    ),
    Status: S.optional(VolumeStatusInfoStatus).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
  }),
).annotate({
  identifier: "VolumeStatusInfo",
}) as any as S.Schema<VolumeStatusInfo>;
export interface VolumeStatusAttachmentStatus {
  IoPerformance?: string;
  InstanceId?: string;
}
export const VolumeStatusAttachmentStatus = S.suspend(() =>
  S.Struct({
    IoPerformance: S.optional(S.String).pipe(
      T.XmlName("ioPerformance"),
      T.Ec2QueryName("IoPerformance"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
  }),
).annotate({
  identifier: "VolumeStatusAttachmentStatus",
}) as any as S.Schema<VolumeStatusAttachmentStatus>;
export type VolumeStatusAttachmentStatusList = VolumeStatusAttachmentStatus[];
export const VolumeStatusAttachmentStatusList = S.Array(
  VolumeStatusAttachmentStatus.pipe(T.XmlName("item")).annotate({
    identifier: "VolumeStatusAttachmentStatus",
  }),
);
export type InitializationType =
  | "default"
  | "provisioned-rate"
  | "volume-copy"
  | (string & {});
export const InitializationType = S.String;
export interface InitializationStatusDetails {
  InitializationType?: InitializationType;
  Progress?: number;
  EstimatedTimeToCompleteInSeconds?: number;
}
export const InitializationStatusDetails = S.suspend(() =>
  S.Struct({
    InitializationType: S.optional(InitializationType).pipe(
      T.XmlName("initializationType"),
      T.Ec2QueryName("InitializationType"),
    ),
    Progress: S.optional(S.Number).pipe(
      T.XmlName("progress"),
      T.Ec2QueryName("Progress"),
    ),
    EstimatedTimeToCompleteInSeconds: S.optional(S.Number).pipe(
      T.XmlName("estimatedTimeToCompleteInSeconds"),
      T.Ec2QueryName("EstimatedTimeToCompleteInSeconds"),
    ),
  }),
).annotate({
  identifier: "InitializationStatusDetails",
}) as any as S.Schema<InitializationStatusDetails>;
export interface VolumeStatusItem {
  Actions?: VolumeStatusAction[];
  AvailabilityZone?: string;
  OutpostArn?: string;
  Events?: VolumeStatusEvent[];
  VolumeId?: string;
  VolumeStatus?: VolumeStatusInfo;
  AttachmentStatuses?: VolumeStatusAttachmentStatus[];
  InitializationStatusDetails?: InitializationStatusDetails;
  AvailabilityZoneId?: string;
}
export const VolumeStatusItem = S.suspend(() =>
  S.Struct({
    Actions: S.optional(VolumeStatusActionsList).pipe(
      T.XmlName("actionsSet"),
      T.Ec2QueryName("ActionsSet"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    OutpostArn: S.optional(S.String).pipe(
      T.XmlName("outpostArn"),
      T.Ec2QueryName("OutpostArn"),
    ),
    Events: S.optional(VolumeStatusEventsList).pipe(
      T.XmlName("eventsSet"),
      T.Ec2QueryName("EventsSet"),
    ),
    VolumeId: S.optional(S.String).pipe(
      T.XmlName("volumeId"),
      T.Ec2QueryName("VolumeId"),
    ),
    VolumeStatus: S.optional(VolumeStatusInfo)
      .pipe(T.XmlName("volumeStatus"), T.Ec2QueryName("VolumeStatus"))
      .annotate({ identifier: "VolumeStatusInfo" }),
    AttachmentStatuses: S.optional(VolumeStatusAttachmentStatusList).pipe(
      T.XmlName("attachmentStatuses"),
      T.Ec2QueryName("AttachmentStatuses"),
    ),
    InitializationStatusDetails: S.optional(InitializationStatusDetails)
      .pipe(
        T.XmlName("initializationStatusDetails"),
        T.Ec2QueryName("InitializationStatusDetails"),
      )
      .annotate({ identifier: "InitializationStatusDetails" }),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
  }),
).annotate({
  identifier: "VolumeStatusItem",
}) as any as S.Schema<VolumeStatusItem>;
export type VolumeStatusList = VolumeStatusItem[];
export const VolumeStatusList = S.Array(
  VolumeStatusItem.pipe(T.XmlName("item")).annotate({
    identifier: "VolumeStatusItem",
  }),
);
export interface DescribeVolumeStatusResult {
  NextToken?: string;
  VolumeStatuses?: VolumeStatusItem[];
}
export const DescribeVolumeStatusResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    VolumeStatuses: S.optional(VolumeStatusList).pipe(
      T.XmlName("volumeStatusSet"),
      T.Ec2QueryName("VolumeStatusSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVolumeStatusResult",
}) as any as S.Schema<DescribeVolumeStatusResult>;
export type VpcAttributeName =
  | "enableDnsSupport"
  | "enableDnsHostnames"
  | "enableNetworkAddressUsageMetrics"
  | (string & {});
export const VpcAttributeName = S.String;
export interface DescribeVpcAttributeRequest {
  Attribute?: VpcAttributeName;
  VpcId?: string;
  DryRun?: boolean;
}
export const DescribeVpcAttributeRequest = S.suspend(() =>
  S.Struct({
    Attribute: S.optional(VpcAttributeName),
    VpcId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVpcAttributeRequest",
}) as any as S.Schema<DescribeVpcAttributeRequest>;
export interface DescribeVpcAttributeResult {
  EnableDnsHostnames?: AttributeBooleanValue;
  EnableDnsSupport?: AttributeBooleanValue;
  EnableNetworkAddressUsageMetrics?: AttributeBooleanValue;
  VpcId?: string;
}
export const DescribeVpcAttributeResult = S.suspend(() =>
  S.Struct({
    EnableDnsHostnames: S.optional(AttributeBooleanValue)
      .pipe(
        T.XmlName("enableDnsHostnames"),
        T.Ec2QueryName("EnableDnsHostnames"),
      )
      .annotate({ identifier: "AttributeBooleanValue" }),
    EnableDnsSupport: S.optional(AttributeBooleanValue)
      .pipe(T.XmlName("enableDnsSupport"), T.Ec2QueryName("EnableDnsSupport"))
      .annotate({ identifier: "AttributeBooleanValue" }),
    EnableNetworkAddressUsageMetrics: S.optional(AttributeBooleanValue)
      .pipe(
        T.XmlName("enableNetworkAddressUsageMetrics"),
        T.Ec2QueryName("EnableNetworkAddressUsageMetrics"),
      )
      .annotate({ identifier: "AttributeBooleanValue" }),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVpcAttributeResult",
}) as any as S.Schema<DescribeVpcAttributeResult>;
export type VpcBlockPublicAccessExclusionIdList = string[];
export const VpcBlockPublicAccessExclusionIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeVpcBlockPublicAccessExclusionsRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  ExclusionIds?: string[];
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeVpcBlockPublicAccessExclusionsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    ExclusionIds: S.optional(VpcBlockPublicAccessExclusionIdList).pipe(
      T.XmlName("ExclusionId"),
    ),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVpcBlockPublicAccessExclusionsRequest",
}) as any as S.Schema<DescribeVpcBlockPublicAccessExclusionsRequest>;
export type VpcBlockPublicAccessExclusionList = VpcBlockPublicAccessExclusion[];
export const VpcBlockPublicAccessExclusionList = S.Array(
  VpcBlockPublicAccessExclusion.pipe(T.XmlName("item")).annotate({
    identifier: "VpcBlockPublicAccessExclusion",
  }),
);
export interface DescribeVpcBlockPublicAccessExclusionsResult {
  VpcBlockPublicAccessExclusions?: VpcBlockPublicAccessExclusion[];
  NextToken?: string;
}
export const DescribeVpcBlockPublicAccessExclusionsResult = S.suspend(() =>
  S.Struct({
    VpcBlockPublicAccessExclusions: S.optional(
      VpcBlockPublicAccessExclusionList,
    ).pipe(
      T.XmlName("vpcBlockPublicAccessExclusionSet"),
      T.Ec2QueryName("VpcBlockPublicAccessExclusionSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVpcBlockPublicAccessExclusionsResult",
}) as any as S.Schema<DescribeVpcBlockPublicAccessExclusionsResult>;
export interface DescribeVpcBlockPublicAccessOptionsRequest {
  DryRun?: boolean;
}
export const DescribeVpcBlockPublicAccessOptionsRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVpcBlockPublicAccessOptionsRequest",
}) as any as S.Schema<DescribeVpcBlockPublicAccessOptionsRequest>;
export type VpcBlockPublicAccessState =
  | "default-state"
  | "update-in-progress"
  | "update-complete"
  | (string & {});
export const VpcBlockPublicAccessState = S.String;
export type InternetGatewayBlockMode =
  | "off"
  | "block-bidirectional"
  | "block-ingress"
  | (string & {});
export const InternetGatewayBlockMode = S.String;
export type ManagedBy = "account" | "declarative-policy" | (string & {});
export const ManagedBy = S.String;
export type VpcBlockPublicAccessExclusionsAllowed =
  | "allowed"
  | "not-allowed"
  | (string & {});
export const VpcBlockPublicAccessExclusionsAllowed = S.String;
export interface VpcBlockPublicAccessOptions {
  AwsAccountId?: string;
  AwsRegion?: string;
  State?: VpcBlockPublicAccessState;
  InternetGatewayBlockMode?: InternetGatewayBlockMode;
  Reason?: string;
  LastUpdateTimestamp?: Date;
  ManagedBy?: ManagedBy;
  ExclusionsAllowed?: VpcBlockPublicAccessExclusionsAllowed;
}
export const VpcBlockPublicAccessOptions = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.optional(S.String).pipe(
      T.XmlName("awsAccountId"),
      T.Ec2QueryName("AwsAccountId"),
    ),
    AwsRegion: S.optional(S.String).pipe(
      T.XmlName("awsRegion"),
      T.Ec2QueryName("AwsRegion"),
    ),
    State: S.optional(VpcBlockPublicAccessState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    InternetGatewayBlockMode: S.optional(InternetGatewayBlockMode).pipe(
      T.XmlName("internetGatewayBlockMode"),
      T.Ec2QueryName("InternetGatewayBlockMode"),
    ),
    Reason: S.optional(S.String).pipe(
      T.XmlName("reason"),
      T.Ec2QueryName("Reason"),
    ),
    LastUpdateTimestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("lastUpdateTimestamp"),
      T.Ec2QueryName("LastUpdateTimestamp"),
    ),
    ManagedBy: S.optional(ManagedBy).pipe(
      T.XmlName("managedBy"),
      T.Ec2QueryName("ManagedBy"),
    ),
    ExclusionsAllowed: S.optional(VpcBlockPublicAccessExclusionsAllowed).pipe(
      T.XmlName("exclusionsAllowed"),
      T.Ec2QueryName("ExclusionsAllowed"),
    ),
  }),
).annotate({
  identifier: "VpcBlockPublicAccessOptions",
}) as any as S.Schema<VpcBlockPublicAccessOptions>;
export interface DescribeVpcBlockPublicAccessOptionsResult {
  VpcBlockPublicAccessOptions?: VpcBlockPublicAccessOptions;
}
export const DescribeVpcBlockPublicAccessOptionsResult = S.suspend(() =>
  S.Struct({
    VpcBlockPublicAccessOptions: S.optional(VpcBlockPublicAccessOptions)
      .pipe(
        T.XmlName("vpcBlockPublicAccessOptions"),
        T.Ec2QueryName("VpcBlockPublicAccessOptions"),
      )
      .annotate({ identifier: "VpcBlockPublicAccessOptions" }),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVpcBlockPublicAccessOptionsResult",
}) as any as S.Schema<DescribeVpcBlockPublicAccessOptionsResult>;
export type VpcClassicLinkIdList = string[];
export const VpcClassicLinkIdList = S.Array(S.String.pipe(T.XmlName("VpcId")));
export interface DescribeVpcClassicLinkRequest {
  DryRun?: boolean;
  VpcIds?: string[];
  Filters?: Filter[];
}
export const DescribeVpcClassicLinkRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    VpcIds: S.optional(VpcClassicLinkIdList).pipe(T.XmlName("VpcId")),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVpcClassicLinkRequest",
}) as any as S.Schema<DescribeVpcClassicLinkRequest>;
export interface VpcClassicLink {
  ClassicLinkEnabled?: boolean;
  Tags?: Tag[];
  VpcId?: string;
}
export const VpcClassicLink = S.suspend(() =>
  S.Struct({
    ClassicLinkEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("classicLinkEnabled"),
      T.Ec2QueryName("ClassicLinkEnabled"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
  }),
).annotate({ identifier: "VpcClassicLink" }) as any as S.Schema<VpcClassicLink>;
export type VpcClassicLinkList = VpcClassicLink[];
export const VpcClassicLinkList = S.Array(
  VpcClassicLink.pipe(T.XmlName("item")).annotate({
    identifier: "VpcClassicLink",
  }),
);
export interface DescribeVpcClassicLinkResult {
  Vpcs?: VpcClassicLink[];
}
export const DescribeVpcClassicLinkResult = S.suspend(() =>
  S.Struct({
    Vpcs: S.optional(VpcClassicLinkList).pipe(
      T.XmlName("vpcSet"),
      T.Ec2QueryName("VpcSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVpcClassicLinkResult",
}) as any as S.Schema<DescribeVpcClassicLinkResult>;
export interface DescribeVpcClassicLinkDnsSupportRequest {
  VpcIds?: string[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeVpcClassicLinkDnsSupportRequest = S.suspend(() =>
  S.Struct({
    VpcIds: S.optional(VpcClassicLinkIdList).pipe(T.XmlName("VpcIds")),
    MaxResults: S.optional(S.Number).pipe(
      T.XmlName("maxResults"),
      T.Ec2QueryName("MaxResults"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVpcClassicLinkDnsSupportRequest",
}) as any as S.Schema<DescribeVpcClassicLinkDnsSupportRequest>;
export interface ClassicLinkDnsSupport {
  ClassicLinkDnsSupported?: boolean;
  VpcId?: string;
}
export const ClassicLinkDnsSupport = S.suspend(() =>
  S.Struct({
    ClassicLinkDnsSupported: S.optional(S.Boolean).pipe(
      T.XmlName("classicLinkDnsSupported"),
      T.Ec2QueryName("ClassicLinkDnsSupported"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
  }),
).annotate({
  identifier: "ClassicLinkDnsSupport",
}) as any as S.Schema<ClassicLinkDnsSupport>;
export type ClassicLinkDnsSupportList = ClassicLinkDnsSupport[];
export const ClassicLinkDnsSupportList = S.Array(
  ClassicLinkDnsSupport.pipe(T.XmlName("item")).annotate({
    identifier: "ClassicLinkDnsSupport",
  }),
);
export interface DescribeVpcClassicLinkDnsSupportResult {
  NextToken?: string;
  Vpcs?: ClassicLinkDnsSupport[];
}
export const DescribeVpcClassicLinkDnsSupportResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    Vpcs: S.optional(ClassicLinkDnsSupportList).pipe(
      T.XmlName("vpcs"),
      T.Ec2QueryName("Vpcs"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVpcClassicLinkDnsSupportResult",
}) as any as S.Schema<DescribeVpcClassicLinkDnsSupportResult>;
export type VpcEncryptionControlIdList = string[];
export const VpcEncryptionControlIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export type VpcIdStringList = string[];
export const VpcIdStringList = S.Array(S.String.pipe(T.XmlName("VpcId")));
export interface DescribeVpcEncryptionControlsRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  VpcEncryptionControlIds?: string[];
  VpcIds?: string[];
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeVpcEncryptionControlsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    VpcEncryptionControlIds: S.optional(VpcEncryptionControlIdList).pipe(
      T.XmlName("VpcEncryptionControlId"),
    ),
    VpcIds: S.optional(VpcIdStringList).pipe(T.XmlName("VpcId")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVpcEncryptionControlsRequest",
}) as any as S.Schema<DescribeVpcEncryptionControlsRequest>;
export type VpcEncryptionControlList = VpcEncryptionControl[];
export const VpcEncryptionControlList = S.Array(
  VpcEncryptionControl.pipe(T.XmlName("item")).annotate({
    identifier: "VpcEncryptionControl",
  }),
);
export interface DescribeVpcEncryptionControlsResult {
  VpcEncryptionControls?: VpcEncryptionControl[];
  NextToken?: string;
}
export const DescribeVpcEncryptionControlsResult = S.suspend(() =>
  S.Struct({
    VpcEncryptionControls: S.optional(VpcEncryptionControlList).pipe(
      T.XmlName("vpcEncryptionControlSet"),
      T.Ec2QueryName("VpcEncryptionControlSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVpcEncryptionControlsResult",
}) as any as S.Schema<DescribeVpcEncryptionControlsResult>;
export interface DescribeVpcEndpointAssociationsRequest {
  DryRun?: boolean;
  VpcEndpointIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeVpcEndpointAssociationsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    VpcEndpointIds: S.optional(VpcEndpointIdList).pipe(
      T.XmlName("VpcEndpointId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVpcEndpointAssociationsRequest",
}) as any as S.Schema<DescribeVpcEndpointAssociationsRequest>;
export interface VpcEndpointAssociation {
  Id?: string;
  VpcEndpointId?: string;
  ServiceNetworkArn?: string;
  ServiceNetworkName?: string;
  AssociatedResourceAccessibility?: string;
  FailureReason?: string;
  FailureCode?: string;
  DnsEntry?: DnsEntry;
  PrivateDnsEntry?: DnsEntry;
  AssociatedResourceArn?: string;
  ResourceConfigurationGroupArn?: string;
  Tags?: Tag[];
}
export const VpcEndpointAssociation = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String).pipe(T.XmlName("id"), T.Ec2QueryName("Id")),
    VpcEndpointId: S.optional(S.String).pipe(
      T.XmlName("vpcEndpointId"),
      T.Ec2QueryName("VpcEndpointId"),
    ),
    ServiceNetworkArn: S.optional(S.String).pipe(
      T.XmlName("serviceNetworkArn"),
      T.Ec2QueryName("ServiceNetworkArn"),
    ),
    ServiceNetworkName: S.optional(S.String).pipe(
      T.XmlName("serviceNetworkName"),
      T.Ec2QueryName("ServiceNetworkName"),
    ),
    AssociatedResourceAccessibility: S.optional(S.String).pipe(
      T.XmlName("associatedResourceAccessibility"),
      T.Ec2QueryName("AssociatedResourceAccessibility"),
    ),
    FailureReason: S.optional(S.String).pipe(
      T.XmlName("failureReason"),
      T.Ec2QueryName("FailureReason"),
    ),
    FailureCode: S.optional(S.String).pipe(
      T.XmlName("failureCode"),
      T.Ec2QueryName("FailureCode"),
    ),
    DnsEntry: S.optional(DnsEntry)
      .pipe(T.XmlName("dnsEntry"), T.Ec2QueryName("DnsEntry"))
      .annotate({ identifier: "DnsEntry" }),
    PrivateDnsEntry: S.optional(DnsEntry)
      .pipe(T.XmlName("privateDnsEntry"), T.Ec2QueryName("PrivateDnsEntry"))
      .annotate({ identifier: "DnsEntry" }),
    AssociatedResourceArn: S.optional(S.String).pipe(
      T.XmlName("associatedResourceArn"),
      T.Ec2QueryName("AssociatedResourceArn"),
    ),
    ResourceConfigurationGroupArn: S.optional(S.String).pipe(
      T.XmlName("resourceConfigurationGroupArn"),
      T.Ec2QueryName("ResourceConfigurationGroupArn"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }),
).annotate({
  identifier: "VpcEndpointAssociation",
}) as any as S.Schema<VpcEndpointAssociation>;
export type VpcEndpointAssociationSet = VpcEndpointAssociation[];
export const VpcEndpointAssociationSet = S.Array(
  VpcEndpointAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "VpcEndpointAssociation",
  }),
);
export interface DescribeVpcEndpointAssociationsResult {
  VpcEndpointAssociations?: VpcEndpointAssociation[];
  NextToken?: string;
}
export const DescribeVpcEndpointAssociationsResult = S.suspend(() =>
  S.Struct({
    VpcEndpointAssociations: S.optional(VpcEndpointAssociationSet).pipe(
      T.XmlName("vpcEndpointAssociationSet"),
      T.Ec2QueryName("VpcEndpointAssociationSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVpcEndpointAssociationsResult",
}) as any as S.Schema<DescribeVpcEndpointAssociationsResult>;
export interface DescribeVpcEndpointConnectionNotificationsRequest {
  DryRun?: boolean;
  ConnectionNotificationId?: string;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeVpcEndpointConnectionNotificationsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ConnectionNotificationId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVpcEndpointConnectionNotificationsRequest",
}) as any as S.Schema<DescribeVpcEndpointConnectionNotificationsRequest>;
export type ConnectionNotificationSet = ConnectionNotification[];
export const ConnectionNotificationSet = S.Array(
  ConnectionNotification.pipe(T.XmlName("item")).annotate({
    identifier: "ConnectionNotification",
  }),
);
export interface DescribeVpcEndpointConnectionNotificationsResult {
  ConnectionNotificationSet?: ConnectionNotification[];
  NextToken?: string;
}
export const DescribeVpcEndpointConnectionNotificationsResult = S.suspend(() =>
  S.Struct({
    ConnectionNotificationSet: S.optional(ConnectionNotificationSet).pipe(
      T.XmlName("connectionNotificationSet"),
      T.Ec2QueryName("ConnectionNotificationSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVpcEndpointConnectionNotificationsResult",
}) as any as S.Schema<DescribeVpcEndpointConnectionNotificationsResult>;
export interface DescribeVpcEndpointConnectionsRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeVpcEndpointConnectionsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVpcEndpointConnectionsRequest",
}) as any as S.Schema<DescribeVpcEndpointConnectionsRequest>;
export interface VpcEndpointConnection {
  ServiceId?: string;
  VpcEndpointId?: string;
  VpcEndpointOwner?: string;
  VpcEndpointState?: State;
  CreationTimestamp?: Date;
  DnsEntries?: DnsEntry[];
  NetworkLoadBalancerArns?: string[];
  GatewayLoadBalancerArns?: string[];
  IpAddressType?: IpAddressType;
  VpcEndpointConnectionId?: string;
  Tags?: Tag[];
  VpcEndpointRegion?: string;
}
export const VpcEndpointConnection = S.suspend(() =>
  S.Struct({
    ServiceId: S.optional(S.String).pipe(
      T.XmlName("serviceId"),
      T.Ec2QueryName("ServiceId"),
    ),
    VpcEndpointId: S.optional(S.String).pipe(
      T.XmlName("vpcEndpointId"),
      T.Ec2QueryName("VpcEndpointId"),
    ),
    VpcEndpointOwner: S.optional(S.String).pipe(
      T.XmlName("vpcEndpointOwner"),
      T.Ec2QueryName("VpcEndpointOwner"),
    ),
    VpcEndpointState: S.optional(State).pipe(
      T.XmlName("vpcEndpointState"),
      T.Ec2QueryName("VpcEndpointState"),
    ),
    CreationTimestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("creationTimestamp"), T.Ec2QueryName("CreationTimestamp")),
    DnsEntries: S.optional(DnsEntrySet).pipe(
      T.XmlName("dnsEntrySet"),
      T.Ec2QueryName("DnsEntrySet"),
    ),
    NetworkLoadBalancerArns: S.optional(ValueStringList).pipe(
      T.XmlName("networkLoadBalancerArnSet"),
      T.Ec2QueryName("NetworkLoadBalancerArnSet"),
    ),
    GatewayLoadBalancerArns: S.optional(ValueStringList).pipe(
      T.XmlName("gatewayLoadBalancerArnSet"),
      T.Ec2QueryName("GatewayLoadBalancerArnSet"),
    ),
    IpAddressType: S.optional(IpAddressType).pipe(
      T.XmlName("ipAddressType"),
      T.Ec2QueryName("IpAddressType"),
    ),
    VpcEndpointConnectionId: S.optional(S.String).pipe(
      T.XmlName("vpcEndpointConnectionId"),
      T.Ec2QueryName("VpcEndpointConnectionId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    VpcEndpointRegion: S.optional(S.String).pipe(
      T.XmlName("vpcEndpointRegion"),
      T.Ec2QueryName("VpcEndpointRegion"),
    ),
  }),
).annotate({
  identifier: "VpcEndpointConnection",
}) as any as S.Schema<VpcEndpointConnection>;
export type VpcEndpointConnectionSet = VpcEndpointConnection[];
export const VpcEndpointConnectionSet = S.Array(
  VpcEndpointConnection.pipe(T.XmlName("item")).annotate({
    identifier: "VpcEndpointConnection",
  }),
);
export interface DescribeVpcEndpointConnectionsResult {
  VpcEndpointConnections?: VpcEndpointConnection[];
  NextToken?: string;
}
export const DescribeVpcEndpointConnectionsResult = S.suspend(() =>
  S.Struct({
    VpcEndpointConnections: S.optional(VpcEndpointConnectionSet).pipe(
      T.XmlName("vpcEndpointConnectionSet"),
      T.Ec2QueryName("VpcEndpointConnectionSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVpcEndpointConnectionsResult",
}) as any as S.Schema<DescribeVpcEndpointConnectionsResult>;
export interface DescribeVpcEndpointsRequest {
  DryRun?: boolean;
  VpcEndpointIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeVpcEndpointsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    VpcEndpointIds: S.optional(VpcEndpointIdList).pipe(
      T.XmlName("VpcEndpointId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVpcEndpointsRequest",
}) as any as S.Schema<DescribeVpcEndpointsRequest>;
export type VpcEndpointSet = VpcEndpoint[];
export const VpcEndpointSet = S.Array(
  VpcEndpoint.pipe(T.XmlName("item")).annotate({ identifier: "VpcEndpoint" }),
);
export interface DescribeVpcEndpointsResult {
  VpcEndpoints?: VpcEndpoint[];
  NextToken?: string;
}
export const DescribeVpcEndpointsResult = S.suspend(() =>
  S.Struct({
    VpcEndpoints: S.optional(VpcEndpointSet).pipe(
      T.XmlName("vpcEndpointSet"),
      T.Ec2QueryName("VpcEndpointSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVpcEndpointsResult",
}) as any as S.Schema<DescribeVpcEndpointsResult>;
export interface DescribeVpcEndpointServiceConfigurationsRequest {
  DryRun?: boolean;
  ServiceIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeVpcEndpointServiceConfigurationsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ServiceIds: S.optional(VpcEndpointServiceIdList).pipe(
      T.XmlName("ServiceId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVpcEndpointServiceConfigurationsRequest",
}) as any as S.Schema<DescribeVpcEndpointServiceConfigurationsRequest>;
export type ServiceConfigurationSet = ServiceConfiguration[];
export const ServiceConfigurationSet = S.Array(
  ServiceConfiguration.pipe(T.XmlName("item")).annotate({
    identifier: "ServiceConfiguration",
  }),
);
export interface DescribeVpcEndpointServiceConfigurationsResult {
  ServiceConfigurations?: ServiceConfiguration[];
  NextToken?: string;
}
export const DescribeVpcEndpointServiceConfigurationsResult = S.suspend(() =>
  S.Struct({
    ServiceConfigurations: S.optional(ServiceConfigurationSet).pipe(
      T.XmlName("serviceConfigurationSet"),
      T.Ec2QueryName("ServiceConfigurationSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVpcEndpointServiceConfigurationsResult",
}) as any as S.Schema<DescribeVpcEndpointServiceConfigurationsResult>;
export interface DescribeVpcEndpointServicePermissionsRequest {
  DryRun?: boolean;
  ServiceId?: string;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeVpcEndpointServicePermissionsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ServiceId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVpcEndpointServicePermissionsRequest",
}) as any as S.Schema<DescribeVpcEndpointServicePermissionsRequest>;
export type PrincipalType =
  | "All"
  | "Service"
  | "OrganizationUnit"
  | "Account"
  | "User"
  | "Role"
  | (string & {});
export const PrincipalType = S.String;
export interface AllowedPrincipal {
  PrincipalType?: PrincipalType;
  Principal?: string;
  ServicePermissionId?: string;
  Tags?: Tag[];
  ServiceId?: string;
}
export const AllowedPrincipal = S.suspend(() =>
  S.Struct({
    PrincipalType: S.optional(PrincipalType).pipe(
      T.XmlName("principalType"),
      T.Ec2QueryName("PrincipalType"),
    ),
    Principal: S.optional(S.String).pipe(
      T.XmlName("principal"),
      T.Ec2QueryName("Principal"),
    ),
    ServicePermissionId: S.optional(S.String).pipe(
      T.XmlName("servicePermissionId"),
      T.Ec2QueryName("ServicePermissionId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    ServiceId: S.optional(S.String).pipe(
      T.XmlName("serviceId"),
      T.Ec2QueryName("ServiceId"),
    ),
  }),
).annotate({
  identifier: "AllowedPrincipal",
}) as any as S.Schema<AllowedPrincipal>;
export type AllowedPrincipalSet = AllowedPrincipal[];
export const AllowedPrincipalSet = S.Array(
  AllowedPrincipal.pipe(T.XmlName("item")).annotate({
    identifier: "AllowedPrincipal",
  }),
);
export interface DescribeVpcEndpointServicePermissionsResult {
  AllowedPrincipals?: AllowedPrincipal[];
  NextToken?: string;
}
export const DescribeVpcEndpointServicePermissionsResult = S.suspend(() =>
  S.Struct({
    AllowedPrincipals: S.optional(AllowedPrincipalSet).pipe(
      T.XmlName("allowedPrincipals"),
      T.Ec2QueryName("AllowedPrincipals"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVpcEndpointServicePermissionsResult",
}) as any as S.Schema<DescribeVpcEndpointServicePermissionsResult>;
export interface DescribeVpcEndpointServicesRequest {
  DryRun?: boolean;
  ServiceNames?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  ServiceRegions?: string[];
}
export const DescribeVpcEndpointServicesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ServiceNames: S.optional(ValueStringList).pipe(T.XmlName("ServiceName")),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    ServiceRegions: S.optional(ValueStringList).pipe(
      T.XmlName("ServiceRegion"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVpcEndpointServicesRequest",
}) as any as S.Schema<DescribeVpcEndpointServicesRequest>;
export interface PrivateDnsDetails {
  PrivateDnsName?: string;
}
export const PrivateDnsDetails = S.suspend(() =>
  S.Struct({
    PrivateDnsName: S.optional(S.String).pipe(
      T.XmlName("privateDnsName"),
      T.Ec2QueryName("PrivateDnsName"),
    ),
  }),
).annotate({
  identifier: "PrivateDnsDetails",
}) as any as S.Schema<PrivateDnsDetails>;
export type PrivateDnsDetailsSet = PrivateDnsDetails[];
export const PrivateDnsDetailsSet = S.Array(
  PrivateDnsDetails.pipe(T.XmlName("item")).annotate({
    identifier: "PrivateDnsDetails",
  }),
);
export interface ServiceDetail {
  ServiceName?: string;
  ServiceId?: string;
  ServiceType?: ServiceTypeDetail[];
  ServiceRegion?: string;
  AvailabilityZoneIds?: string[];
  AvailabilityZones?: string[];
  Owner?: string;
  BaseEndpointDnsNames?: string[];
  PrivateDnsName?: string;
  PrivateDnsNames?: PrivateDnsDetails[];
  VpcEndpointPolicySupported?: boolean;
  AcceptanceRequired?: boolean;
  ManagesVpcEndpoints?: boolean;
  PayerResponsibility?: PayerResponsibility;
  Tags?: Tag[];
  PrivateDnsNameVerificationState?: DnsNameState;
  SupportedIpAddressTypes?: ServiceConnectivityType[];
}
export const ServiceDetail = S.suspend(() =>
  S.Struct({
    ServiceName: S.optional(S.String).pipe(
      T.XmlName("serviceName"),
      T.Ec2QueryName("ServiceName"),
    ),
    ServiceId: S.optional(S.String).pipe(
      T.XmlName("serviceId"),
      T.Ec2QueryName("ServiceId"),
    ),
    ServiceType: S.optional(ServiceTypeDetailSet).pipe(
      T.XmlName("serviceType"),
      T.Ec2QueryName("ServiceType"),
    ),
    ServiceRegion: S.optional(S.String).pipe(
      T.XmlName("serviceRegion"),
      T.Ec2QueryName("ServiceRegion"),
    ),
    AvailabilityZoneIds: S.optional(ValueStringList).pipe(
      T.XmlName("availabilityZoneIdSet"),
      T.Ec2QueryName("AvailabilityZoneIdSet"),
    ),
    AvailabilityZones: S.optional(ValueStringList).pipe(
      T.XmlName("availabilityZoneSet"),
      T.Ec2QueryName("AvailabilityZoneSet"),
    ),
    Owner: S.optional(S.String).pipe(
      T.XmlName("owner"),
      T.Ec2QueryName("Owner"),
    ),
    BaseEndpointDnsNames: S.optional(ValueStringList).pipe(
      T.XmlName("baseEndpointDnsNameSet"),
      T.Ec2QueryName("BaseEndpointDnsNameSet"),
    ),
    PrivateDnsName: S.optional(S.String).pipe(
      T.XmlName("privateDnsName"),
      T.Ec2QueryName("PrivateDnsName"),
    ),
    PrivateDnsNames: S.optional(PrivateDnsDetailsSet).pipe(
      T.XmlName("privateDnsNameSet"),
      T.Ec2QueryName("PrivateDnsNameSet"),
    ),
    VpcEndpointPolicySupported: S.optional(S.Boolean).pipe(
      T.XmlName("vpcEndpointPolicySupported"),
      T.Ec2QueryName("VpcEndpointPolicySupported"),
    ),
    AcceptanceRequired: S.optional(S.Boolean).pipe(
      T.XmlName("acceptanceRequired"),
      T.Ec2QueryName("AcceptanceRequired"),
    ),
    ManagesVpcEndpoints: S.optional(S.Boolean).pipe(
      T.XmlName("managesVpcEndpoints"),
      T.Ec2QueryName("ManagesVpcEndpoints"),
    ),
    PayerResponsibility: S.optional(PayerResponsibility).pipe(
      T.XmlName("payerResponsibility"),
      T.Ec2QueryName("PayerResponsibility"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    PrivateDnsNameVerificationState: S.optional(DnsNameState).pipe(
      T.XmlName("privateDnsNameVerificationState"),
      T.Ec2QueryName("PrivateDnsNameVerificationState"),
    ),
    SupportedIpAddressTypes: S.optional(SupportedIpAddressTypes).pipe(
      T.XmlName("supportedIpAddressTypeSet"),
      T.Ec2QueryName("SupportedIpAddressTypeSet"),
    ),
  }),
).annotate({ identifier: "ServiceDetail" }) as any as S.Schema<ServiceDetail>;
export type ServiceDetailSet = ServiceDetail[];
export const ServiceDetailSet = S.Array(
  ServiceDetail.pipe(T.XmlName("item")).annotate({
    identifier: "ServiceDetail",
  }),
);
export interface DescribeVpcEndpointServicesResult {
  ServiceNames?: string[];
  ServiceDetails?: ServiceDetail[];
  NextToken?: string;
}
export const DescribeVpcEndpointServicesResult = S.suspend(() =>
  S.Struct({
    ServiceNames: S.optional(ValueStringList).pipe(
      T.XmlName("serviceNameSet"),
      T.Ec2QueryName("ServiceNameSet"),
    ),
    ServiceDetails: S.optional(ServiceDetailSet).pipe(
      T.XmlName("serviceDetailSet"),
      T.Ec2QueryName("ServiceDetailSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVpcEndpointServicesResult",
}) as any as S.Schema<DescribeVpcEndpointServicesResult>;
export type VpcPeeringConnectionIdList = string[];
export const VpcPeeringConnectionIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DescribeVpcPeeringConnectionsRequest {
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
  VpcPeeringConnectionIds?: string[];
  Filters?: Filter[];
}
export const DescribeVpcPeeringConnectionsRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    VpcPeeringConnectionIds: S.optional(VpcPeeringConnectionIdList).pipe(
      T.XmlName("VpcPeeringConnectionId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVpcPeeringConnectionsRequest",
}) as any as S.Schema<DescribeVpcPeeringConnectionsRequest>;
export type VpcPeeringConnectionList = VpcPeeringConnection[];
export const VpcPeeringConnectionList = S.Array(
  VpcPeeringConnection.pipe(T.XmlName("item")).annotate({
    identifier: "VpcPeeringConnection",
  }),
);
export interface DescribeVpcPeeringConnectionsResult {
  VpcPeeringConnections?: VpcPeeringConnection[];
  NextToken?: string;
}
export const DescribeVpcPeeringConnectionsResult = S.suspend(() =>
  S.Struct({
    VpcPeeringConnections: S.optional(VpcPeeringConnectionList).pipe(
      T.XmlName("vpcPeeringConnectionSet"),
      T.Ec2QueryName("VpcPeeringConnectionSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVpcPeeringConnectionsResult",
}) as any as S.Schema<DescribeVpcPeeringConnectionsResult>;
export interface DescribeVpcsRequest {
  Filters?: Filter[];
  VpcIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
}
export const DescribeVpcsRequest = S.suspend(() =>
  S.Struct({
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    VpcIds: S.optional(VpcIdStringList).pipe(T.XmlName("VpcId")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVpcsRequest",
}) as any as S.Schema<DescribeVpcsRequest>;
export type VpcList = Vpc[];
export const VpcList = S.Array(
  Vpc.pipe(T.XmlName("item")).annotate({ identifier: "Vpc" }),
);
export interface DescribeVpcsResult {
  NextToken?: string;
  Vpcs?: Vpc[];
}
export const DescribeVpcsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    Vpcs: S.optional(VpcList).pipe(
      T.XmlName("vpcSet"),
      T.Ec2QueryName("VpcSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVpcsResult",
}) as any as S.Schema<DescribeVpcsResult>;
export type VpnConcentratorIdStringList = string[];
export const VpnConcentratorIdStringList = S.Array(
  S.String.pipe(T.XmlName("VpnConcentratorId")),
);
export interface DescribeVpnConcentratorsRequest {
  VpnConcentratorIds?: string[];
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const DescribeVpnConcentratorsRequest = S.suspend(() =>
  S.Struct({
    VpnConcentratorIds: S.optional(VpnConcentratorIdStringList).pipe(
      T.XmlName("VpnConcentratorId"),
    ),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVpnConcentratorsRequest",
}) as any as S.Schema<DescribeVpnConcentratorsRequest>;
export type VpnConcentratorList = VpnConcentrator[];
export const VpnConcentratorList = S.Array(
  VpnConcentrator.pipe(T.XmlName("item")).annotate({
    identifier: "VpnConcentrator",
  }),
);
export interface DescribeVpnConcentratorsResult {
  VpnConcentrators?: VpnConcentrator[];
  NextToken?: string;
}
export const DescribeVpnConcentratorsResult = S.suspend(() =>
  S.Struct({
    VpnConcentrators: S.optional(VpnConcentratorList).pipe(
      T.XmlName("vpnConcentratorSet"),
      T.Ec2QueryName("VpnConcentratorSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVpnConcentratorsResult",
}) as any as S.Schema<DescribeVpnConcentratorsResult>;
export type VpnConnectionIdStringList = string[];
export const VpnConnectionIdStringList = S.Array(
  S.String.pipe(T.XmlName("VpnConnectionId")),
);
export interface DescribeVpnConnectionsRequest {
  Filters?: Filter[];
  VpnConnectionIds?: string[];
  DryRun?: boolean;
}
export const DescribeVpnConnectionsRequest = S.suspend(() =>
  S.Struct({
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    VpnConnectionIds: S.optional(VpnConnectionIdStringList).pipe(
      T.XmlName("VpnConnectionId"),
    ),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVpnConnectionsRequest",
}) as any as S.Schema<DescribeVpnConnectionsRequest>;
export type VpnConnectionList = VpnConnection[];
export const VpnConnectionList = S.Array(
  VpnConnection.pipe(T.XmlName("item")).annotate({
    identifier: "VpnConnection",
  }),
);
export interface DescribeVpnConnectionsResult {
  VpnConnections?: VpnConnection[];
}
export const DescribeVpnConnectionsResult = S.suspend(() =>
  S.Struct({
    VpnConnections: S.optional(VpnConnectionList).pipe(
      T.XmlName("vpnConnectionSet"),
      T.Ec2QueryName("VpnConnectionSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVpnConnectionsResult",
}) as any as S.Schema<DescribeVpnConnectionsResult>;
export type VpnGatewayIdStringList = string[];
export const VpnGatewayIdStringList = S.Array(
  S.String.pipe(T.XmlName("VpnGatewayId")),
);
export interface DescribeVpnGatewaysRequest {
  Filters?: Filter[];
  VpnGatewayIds?: string[];
  DryRun?: boolean;
}
export const DescribeVpnGatewaysRequest = S.suspend(() =>
  S.Struct({
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    VpnGatewayIds: S.optional(VpnGatewayIdStringList).pipe(
      T.XmlName("VpnGatewayId"),
    ),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVpnGatewaysRequest",
}) as any as S.Schema<DescribeVpnGatewaysRequest>;
export type VpnGatewayList = VpnGateway[];
export const VpnGatewayList = S.Array(
  VpnGateway.pipe(T.XmlName("item")).annotate({ identifier: "VpnGateway" }),
);
export interface DescribeVpnGatewaysResult {
  VpnGateways?: VpnGateway[];
}
export const DescribeVpnGatewaysResult = S.suspend(() =>
  S.Struct({
    VpnGateways: S.optional(VpnGatewayList).pipe(
      T.XmlName("vpnGatewaySet"),
      T.Ec2QueryName("VpnGatewaySet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeVpnGatewaysResult",
}) as any as S.Schema<DescribeVpnGatewaysResult>;
export interface DetachClassicLinkVpcRequest {
  DryRun?: boolean;
  InstanceId?: string;
  VpcId?: string;
}
export const DetachClassicLinkVpcRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DetachClassicLinkVpcRequest",
}) as any as S.Schema<DetachClassicLinkVpcRequest>;
export interface DetachClassicLinkVpcResult {
  Return?: boolean;
}
export const DetachClassicLinkVpcResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DetachClassicLinkVpcResult",
}) as any as S.Schema<DetachClassicLinkVpcResult>;
export interface DetachInternetGatewayRequest {
  DryRun?: boolean;
  InternetGatewayId?: string;
  VpcId?: string;
}
export const DetachInternetGatewayRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    InternetGatewayId: S.optional(S.String).pipe(
      T.XmlName("internetGatewayId"),
      T.Ec2QueryName("InternetGatewayId"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DetachInternetGatewayRequest",
}) as any as S.Schema<DetachInternetGatewayRequest>;
export interface DetachInternetGatewayResponse {}
export const DetachInternetGatewayResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DetachInternetGatewayResponse",
}) as any as S.Schema<DetachInternetGatewayResponse>;
export interface DetachNetworkInterfaceRequest {
  DryRun?: boolean;
  AttachmentId?: string;
  Force?: boolean;
}
export const DetachNetworkInterfaceRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    AttachmentId: S.optional(S.String).pipe(
      T.XmlName("attachmentId"),
      T.Ec2QueryName("AttachmentId"),
    ),
    Force: S.optional(S.Boolean).pipe(
      T.XmlName("force"),
      T.Ec2QueryName("Force"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DetachNetworkInterfaceRequest",
}) as any as S.Schema<DetachNetworkInterfaceRequest>;
export interface DetachNetworkInterfaceResponse {}
export const DetachNetworkInterfaceResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DetachNetworkInterfaceResponse",
}) as any as S.Schema<DetachNetworkInterfaceResponse>;
export interface DetachVerifiedAccessTrustProviderRequest {
  VerifiedAccessInstanceId?: string;
  VerifiedAccessTrustProviderId?: string;
  ClientToken?: string;
  DryRun?: boolean;
}
export const DetachVerifiedAccessTrustProviderRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessInstanceId: S.optional(S.String),
    VerifiedAccessTrustProviderId: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DetachVerifiedAccessTrustProviderRequest",
}) as any as S.Schema<DetachVerifiedAccessTrustProviderRequest>;
export interface DetachVerifiedAccessTrustProviderResult {
  VerifiedAccessTrustProvider?: VerifiedAccessTrustProvider;
  VerifiedAccessInstance?: VerifiedAccessInstance;
}
export const DetachVerifiedAccessTrustProviderResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessTrustProvider: S.optional(VerifiedAccessTrustProvider)
      .pipe(
        T.XmlName("verifiedAccessTrustProvider"),
        T.Ec2QueryName("VerifiedAccessTrustProvider"),
      )
      .annotate({ identifier: "VerifiedAccessTrustProvider" }),
    VerifiedAccessInstance: S.optional(VerifiedAccessInstance)
      .pipe(
        T.XmlName("verifiedAccessInstance"),
        T.Ec2QueryName("VerifiedAccessInstance"),
      )
      .annotate({ identifier: "VerifiedAccessInstance" }),
  }).pipe(ns),
).annotate({
  identifier: "DetachVerifiedAccessTrustProviderResult",
}) as any as S.Schema<DetachVerifiedAccessTrustProviderResult>;
export interface DetachVolumeRequest {
  Device?: string;
  Force?: boolean;
  InstanceId?: string;
  VolumeId?: string;
  DryRun?: boolean;
}
export const DetachVolumeRequest = S.suspend(() =>
  S.Struct({
    Device: S.optional(S.String),
    Force: S.optional(S.Boolean),
    InstanceId: S.optional(S.String),
    VolumeId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DetachVolumeRequest",
}) as any as S.Schema<DetachVolumeRequest>;
export interface DetachVpnGatewayRequest {
  VpcId?: string;
  VpnGatewayId?: string;
  DryRun?: boolean;
}
export const DetachVpnGatewayRequest = S.suspend(() =>
  S.Struct({
    VpcId: S.optional(S.String),
    VpnGatewayId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DetachVpnGatewayRequest",
}) as any as S.Schema<DetachVpnGatewayRequest>;
export interface DetachVpnGatewayResponse {}
export const DetachVpnGatewayResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DetachVpnGatewayResponse",
}) as any as S.Schema<DetachVpnGatewayResponse>;
export interface DisableAddressTransferRequest {
  AllocationId?: string;
  DryRun?: boolean;
}
export const DisableAddressTransferRequest = S.suspend(() =>
  S.Struct({
    AllocationId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableAddressTransferRequest",
}) as any as S.Schema<DisableAddressTransferRequest>;
export interface DisableAddressTransferResult {
  AddressTransfer?: AddressTransfer;
}
export const DisableAddressTransferResult = S.suspend(() =>
  S.Struct({
    AddressTransfer: S.optional(AddressTransfer)
      .pipe(T.XmlName("addressTransfer"), T.Ec2QueryName("AddressTransfer"))
      .annotate({ identifier: "AddressTransfer" }),
  }).pipe(ns),
).annotate({
  identifier: "DisableAddressTransferResult",
}) as any as S.Schema<DisableAddressTransferResult>;
export interface DisableAllowedImagesSettingsRequest {
  DryRun?: boolean;
}
export const DisableAllowedImagesSettingsRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableAllowedImagesSettingsRequest",
}) as any as S.Schema<DisableAllowedImagesSettingsRequest>;
export type AllowedImagesSettingsDisabledState = "disabled" | (string & {});
export const AllowedImagesSettingsDisabledState = S.String;
export interface DisableAllowedImagesSettingsResult {
  AllowedImagesSettingsState?: AllowedImagesSettingsDisabledState;
}
export const DisableAllowedImagesSettingsResult = S.suspend(() =>
  S.Struct({
    AllowedImagesSettingsState: S.optional(
      AllowedImagesSettingsDisabledState,
    ).pipe(
      T.XmlName("allowedImagesSettingsState"),
      T.Ec2QueryName("AllowedImagesSettingsState"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisableAllowedImagesSettingsResult",
}) as any as S.Schema<DisableAllowedImagesSettingsResult>;
export interface DisableAwsNetworkPerformanceMetricSubscriptionRequest {
  Source?: string;
  Destination?: string;
  Metric?: MetricType;
  Statistic?: StatisticType;
  DryRun?: boolean;
}
export const DisableAwsNetworkPerformanceMetricSubscriptionRequest = S.suspend(
  () =>
    S.Struct({
      Source: S.optional(S.String),
      Destination: S.optional(S.String),
      Metric: S.optional(MetricType),
      Statistic: S.optional(StatisticType),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "DisableAwsNetworkPerformanceMetricSubscriptionRequest",
}) as any as S.Schema<DisableAwsNetworkPerformanceMetricSubscriptionRequest>;
export interface DisableAwsNetworkPerformanceMetricSubscriptionResult {
  Output?: boolean;
}
export const DisableAwsNetworkPerformanceMetricSubscriptionResult = S.suspend(
  () =>
    S.Struct({
      Output: S.optional(S.Boolean).pipe(
        T.XmlName("output"),
        T.Ec2QueryName("Output"),
      ),
    }).pipe(ns),
).annotate({
  identifier: "DisableAwsNetworkPerformanceMetricSubscriptionResult",
}) as any as S.Schema<DisableAwsNetworkPerformanceMetricSubscriptionResult>;
export interface DisableCapacityManagerRequest {
  DryRun?: boolean;
  ClientToken?: string;
}
export const DisableCapacityManagerRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableCapacityManagerRequest",
}) as any as S.Schema<DisableCapacityManagerRequest>;
export type CapacityManagerStatus = "enabled" | "disabled" | (string & {});
export const CapacityManagerStatus = S.String;
export interface DisableCapacityManagerResult {
  CapacityManagerStatus?: CapacityManagerStatus;
  OrganizationsAccess?: boolean;
}
export const DisableCapacityManagerResult = S.suspend(() =>
  S.Struct({
    CapacityManagerStatus: S.optional(CapacityManagerStatus).pipe(
      T.XmlName("capacityManagerStatus"),
      T.Ec2QueryName("CapacityManagerStatus"),
    ),
    OrganizationsAccess: S.optional(S.Boolean).pipe(
      T.XmlName("organizationsAccess"),
      T.Ec2QueryName("OrganizationsAccess"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisableCapacityManagerResult",
}) as any as S.Schema<DisableCapacityManagerResult>;
export interface DisableEbsEncryptionByDefaultRequest {
  DryRun?: boolean;
}
export const DisableEbsEncryptionByDefaultRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableEbsEncryptionByDefaultRequest",
}) as any as S.Schema<DisableEbsEncryptionByDefaultRequest>;
export interface DisableEbsEncryptionByDefaultResult {
  EbsEncryptionByDefault?: boolean;
}
export const DisableEbsEncryptionByDefaultResult = S.suspend(() =>
  S.Struct({
    EbsEncryptionByDefault: S.optional(S.Boolean).pipe(
      T.XmlName("ebsEncryptionByDefault"),
      T.Ec2QueryName("EbsEncryptionByDefault"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisableEbsEncryptionByDefaultResult",
}) as any as S.Schema<DisableEbsEncryptionByDefaultResult>;
export interface DisableFastLaunchRequest {
  ImageId?: string;
  Force?: boolean;
  DryRun?: boolean;
}
export const DisableFastLaunchRequest = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String),
    Force: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableFastLaunchRequest",
}) as any as S.Schema<DisableFastLaunchRequest>;
export interface DisableFastLaunchResult {
  ImageId?: string;
  ResourceType?: FastLaunchResourceType;
  SnapshotConfiguration?: FastLaunchSnapshotConfigurationResponse;
  LaunchTemplate?: FastLaunchLaunchTemplateSpecificationResponse;
  MaxParallelLaunches?: number;
  OwnerId?: string;
  State?: FastLaunchStateCode;
  StateTransitionReason?: string;
  StateTransitionTime?: Date;
}
export const DisableFastLaunchResult = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    ResourceType: S.optional(FastLaunchResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    SnapshotConfiguration: S.optional(FastLaunchSnapshotConfigurationResponse)
      .pipe(
        T.XmlName("snapshotConfiguration"),
        T.Ec2QueryName("SnapshotConfiguration"),
      )
      .annotate({ identifier: "FastLaunchSnapshotConfigurationResponse" }),
    LaunchTemplate: S.optional(FastLaunchLaunchTemplateSpecificationResponse)
      .pipe(T.XmlName("launchTemplate"), T.Ec2QueryName("LaunchTemplate"))
      .annotate({
        identifier: "FastLaunchLaunchTemplateSpecificationResponse",
      }),
    MaxParallelLaunches: S.optional(S.Number).pipe(
      T.XmlName("maxParallelLaunches"),
      T.Ec2QueryName("MaxParallelLaunches"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    State: S.optional(FastLaunchStateCode).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StateTransitionReason: S.optional(S.String).pipe(
      T.XmlName("stateTransitionReason"),
      T.Ec2QueryName("StateTransitionReason"),
    ),
    StateTransitionTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("stateTransitionTime"),
      T.Ec2QueryName("StateTransitionTime"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisableFastLaunchResult",
}) as any as S.Schema<DisableFastLaunchResult>;
export type AvailabilityZoneStringList = string[];
export const AvailabilityZoneStringList = S.Array(
  S.String.pipe(T.XmlName("AvailabilityZone")),
);
export type AvailabilityZoneIdStringList = string[];
export const AvailabilityZoneIdStringList = S.Array(
  S.String.pipe(T.XmlName("AvailabilityZoneId")),
);
export interface DisableFastSnapshotRestoresRequest {
  AvailabilityZones?: string[];
  AvailabilityZoneIds?: string[];
  SourceSnapshotIds?: string[];
  DryRun?: boolean;
}
export const DisableFastSnapshotRestoresRequest = S.suspend(() =>
  S.Struct({
    AvailabilityZones: S.optional(AvailabilityZoneStringList).pipe(
      T.XmlName("AvailabilityZone"),
    ),
    AvailabilityZoneIds: S.optional(AvailabilityZoneIdStringList).pipe(
      T.XmlName("AvailabilityZoneId"),
    ),
    SourceSnapshotIds: S.optional(SnapshotIdStringList).pipe(
      T.XmlName("SourceSnapshotId"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableFastSnapshotRestoresRequest",
}) as any as S.Schema<DisableFastSnapshotRestoresRequest>;
export interface DisableFastSnapshotRestoreSuccessItem {
  SnapshotId?: string;
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  State?: FastSnapshotRestoreStateCode;
  StateTransitionReason?: string;
  OwnerId?: string;
  OwnerAlias?: string;
  EnablingTime?: Date;
  OptimizingTime?: Date;
  EnabledTime?: Date;
  DisablingTime?: Date;
  DisabledTime?: Date;
}
export const DisableFastSnapshotRestoreSuccessItem = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    State: S.optional(FastSnapshotRestoreStateCode).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StateTransitionReason: S.optional(S.String).pipe(
      T.XmlName("stateTransitionReason"),
      T.Ec2QueryName("StateTransitionReason"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    OwnerAlias: S.optional(S.String).pipe(
      T.XmlName("ownerAlias"),
      T.Ec2QueryName("OwnerAlias"),
    ),
    EnablingTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("enablingTime"), T.Ec2QueryName("EnablingTime")),
    OptimizingTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("optimizingTime"), T.Ec2QueryName("OptimizingTime")),
    EnabledTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("enabledTime"), T.Ec2QueryName("EnabledTime")),
    DisablingTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("disablingTime"), T.Ec2QueryName("DisablingTime")),
    DisabledTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("disabledTime"), T.Ec2QueryName("DisabledTime")),
  }),
).annotate({
  identifier: "DisableFastSnapshotRestoreSuccessItem",
}) as any as S.Schema<DisableFastSnapshotRestoreSuccessItem>;
export type DisableFastSnapshotRestoreSuccessSet =
  DisableFastSnapshotRestoreSuccessItem[];
export const DisableFastSnapshotRestoreSuccessSet = S.Array(
  DisableFastSnapshotRestoreSuccessItem.pipe(T.XmlName("item")).annotate({
    identifier: "DisableFastSnapshotRestoreSuccessItem",
  }),
);
export interface DisableFastSnapshotRestoreStateError {
  Code?: string;
  Message?: string;
}
export const DisableFastSnapshotRestoreStateError = S.suspend(() =>
  S.Struct({
    Code: S.optional(S.String).pipe(T.XmlName("code"), T.Ec2QueryName("Code")),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "DisableFastSnapshotRestoreStateError",
}) as any as S.Schema<DisableFastSnapshotRestoreStateError>;
export interface DisableFastSnapshotRestoreStateErrorItem {
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  Error?: DisableFastSnapshotRestoreStateError;
}
export const DisableFastSnapshotRestoreStateErrorItem = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    Error: S.optional(DisableFastSnapshotRestoreStateError)
      .pipe(T.XmlName("error"), T.Ec2QueryName("Error"))
      .annotate({ identifier: "DisableFastSnapshotRestoreStateError" }),
  }),
).annotate({
  identifier: "DisableFastSnapshotRestoreStateErrorItem",
}) as any as S.Schema<DisableFastSnapshotRestoreStateErrorItem>;
export type DisableFastSnapshotRestoreStateErrorSet =
  DisableFastSnapshotRestoreStateErrorItem[];
export const DisableFastSnapshotRestoreStateErrorSet = S.Array(
  DisableFastSnapshotRestoreStateErrorItem.pipe(T.XmlName("item")).annotate({
    identifier: "DisableFastSnapshotRestoreStateErrorItem",
  }),
);
export interface DisableFastSnapshotRestoreErrorItem {
  SnapshotId?: string;
  FastSnapshotRestoreStateErrors?: DisableFastSnapshotRestoreStateErrorItem[];
}
export const DisableFastSnapshotRestoreErrorItem = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    FastSnapshotRestoreStateErrors: S.optional(
      DisableFastSnapshotRestoreStateErrorSet,
    ).pipe(
      T.XmlName("fastSnapshotRestoreStateErrorSet"),
      T.Ec2QueryName("FastSnapshotRestoreStateErrorSet"),
    ),
  }),
).annotate({
  identifier: "DisableFastSnapshotRestoreErrorItem",
}) as any as S.Schema<DisableFastSnapshotRestoreErrorItem>;
export type DisableFastSnapshotRestoreErrorSet =
  DisableFastSnapshotRestoreErrorItem[];
export const DisableFastSnapshotRestoreErrorSet = S.Array(
  DisableFastSnapshotRestoreErrorItem.pipe(T.XmlName("item")).annotate({
    identifier: "DisableFastSnapshotRestoreErrorItem",
  }),
);
export interface DisableFastSnapshotRestoresResult {
  Successful?: DisableFastSnapshotRestoreSuccessItem[];
  Unsuccessful?: DisableFastSnapshotRestoreErrorItem[];
}
export const DisableFastSnapshotRestoresResult = S.suspend(() =>
  S.Struct({
    Successful: S.optional(DisableFastSnapshotRestoreSuccessSet).pipe(
      T.XmlName("successful"),
      T.Ec2QueryName("Successful"),
    ),
    Unsuccessful: S.optional(DisableFastSnapshotRestoreErrorSet).pipe(
      T.XmlName("unsuccessful"),
      T.Ec2QueryName("Unsuccessful"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisableFastSnapshotRestoresResult",
}) as any as S.Schema<DisableFastSnapshotRestoresResult>;
export interface DisableImageRequest {
  ImageId?: string;
  DryRun?: boolean;
}
export const DisableImageRequest = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableImageRequest",
}) as any as S.Schema<DisableImageRequest>;
export interface DisableImageResult {
  Return?: boolean;
}
export const DisableImageResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisableImageResult",
}) as any as S.Schema<DisableImageResult>;
export interface DisableImageBlockPublicAccessRequest {
  DryRun?: boolean;
}
export const DisableImageBlockPublicAccessRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableImageBlockPublicAccessRequest",
}) as any as S.Schema<DisableImageBlockPublicAccessRequest>;
export type ImageBlockPublicAccessDisabledState = "unblocked" | (string & {});
export const ImageBlockPublicAccessDisabledState = S.String;
export interface DisableImageBlockPublicAccessResult {
  ImageBlockPublicAccessState?: ImageBlockPublicAccessDisabledState;
}
export const DisableImageBlockPublicAccessResult = S.suspend(() =>
  S.Struct({
    ImageBlockPublicAccessState: S.optional(
      ImageBlockPublicAccessDisabledState,
    ).pipe(
      T.XmlName("imageBlockPublicAccessState"),
      T.Ec2QueryName("ImageBlockPublicAccessState"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisableImageBlockPublicAccessResult",
}) as any as S.Schema<DisableImageBlockPublicAccessResult>;
export interface DisableImageDeprecationRequest {
  ImageId?: string;
  DryRun?: boolean;
}
export const DisableImageDeprecationRequest = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableImageDeprecationRequest",
}) as any as S.Schema<DisableImageDeprecationRequest>;
export interface DisableImageDeprecationResult {
  Return?: boolean;
}
export const DisableImageDeprecationResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisableImageDeprecationResult",
}) as any as S.Schema<DisableImageDeprecationResult>;
export interface DisableImageDeregistrationProtectionRequest {
  ImageId?: string;
  DryRun?: boolean;
}
export const DisableImageDeregistrationProtectionRequest = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableImageDeregistrationProtectionRequest",
}) as any as S.Schema<DisableImageDeregistrationProtectionRequest>;
export interface DisableImageDeregistrationProtectionResult {
  Return?: string;
}
export const DisableImageDeregistrationProtectionResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.String).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisableImageDeregistrationProtectionResult",
}) as any as S.Schema<DisableImageDeregistrationProtectionResult>;
export type InstanceIdUpdateStringList = string[];
export const InstanceIdUpdateStringList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface DisableInstanceSqlHaStandbyDetectionsRequest {
  InstanceIds?: string[];
  DryRun?: boolean;
}
export const DisableInstanceSqlHaStandbyDetectionsRequest = S.suspend(() =>
  S.Struct({
    InstanceIds: S.optional(InstanceIdUpdateStringList).pipe(
      T.XmlName("InstanceId"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableInstanceSqlHaStandbyDetectionsRequest",
}) as any as S.Schema<DisableInstanceSqlHaStandbyDetectionsRequest>;
export interface DisableInstanceSqlHaStandbyDetectionsResult {
  Instances?: RegisteredInstance[];
}
export const DisableInstanceSqlHaStandbyDetectionsResult = S.suspend(() =>
  S.Struct({
    Instances: S.optional(RegisteredInstanceList).pipe(
      T.XmlName("instanceSet"),
      T.Ec2QueryName("InstanceSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisableInstanceSqlHaStandbyDetectionsResult",
}) as any as S.Schema<DisableInstanceSqlHaStandbyDetectionsResult>;
export interface DisableIpamOrganizationAdminAccountRequest {
  DryRun?: boolean;
  DelegatedAdminAccountId?: string;
}
export const DisableIpamOrganizationAdminAccountRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    DelegatedAdminAccountId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableIpamOrganizationAdminAccountRequest",
}) as any as S.Schema<DisableIpamOrganizationAdminAccountRequest>;
export interface DisableIpamOrganizationAdminAccountResult {
  Success?: boolean;
}
export const DisableIpamOrganizationAdminAccountResult = S.suspend(() =>
  S.Struct({
    Success: S.optional(S.Boolean).pipe(
      T.XmlName("success"),
      T.Ec2QueryName("Success"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisableIpamOrganizationAdminAccountResult",
}) as any as S.Schema<DisableIpamOrganizationAdminAccountResult>;
export interface DisableIpamPolicyRequest {
  DryRun?: boolean;
  IpamPolicyId?: string;
  OrganizationTargetId?: string;
}
export const DisableIpamPolicyRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPolicyId: S.optional(S.String),
    OrganizationTargetId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableIpamPolicyRequest",
}) as any as S.Schema<DisableIpamPolicyRequest>;
export interface DisableIpamPolicyResult {
  Return?: boolean;
}
export const DisableIpamPolicyResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisableIpamPolicyResult",
}) as any as S.Schema<DisableIpamPolicyResult>;
export interface DisableRouteServerPropagationRequest {
  RouteServerId?: string;
  RouteTableId?: string;
  DryRun?: boolean;
}
export const DisableRouteServerPropagationRequest = S.suspend(() =>
  S.Struct({
    RouteServerId: S.optional(S.String),
    RouteTableId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableRouteServerPropagationRequest",
}) as any as S.Schema<DisableRouteServerPropagationRequest>;
export type RouteServerPropagationState =
  | "pending"
  | "available"
  | "deleting"
  | (string & {});
export const RouteServerPropagationState = S.String;
export interface RouteServerPropagation {
  RouteServerId?: string;
  RouteTableId?: string;
  State?: RouteServerPropagationState;
}
export const RouteServerPropagation = S.suspend(() =>
  S.Struct({
    RouteServerId: S.optional(S.String).pipe(
      T.XmlName("routeServerId"),
      T.Ec2QueryName("RouteServerId"),
    ),
    RouteTableId: S.optional(S.String).pipe(
      T.XmlName("routeTableId"),
      T.Ec2QueryName("RouteTableId"),
    ),
    State: S.optional(RouteServerPropagationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({
  identifier: "RouteServerPropagation",
}) as any as S.Schema<RouteServerPropagation>;
export interface DisableRouteServerPropagationResult {
  RouteServerPropagation?: RouteServerPropagation;
}
export const DisableRouteServerPropagationResult = S.suspend(() =>
  S.Struct({
    RouteServerPropagation: S.optional(RouteServerPropagation)
      .pipe(
        T.XmlName("routeServerPropagation"),
        T.Ec2QueryName("RouteServerPropagation"),
      )
      .annotate({ identifier: "RouteServerPropagation" }),
  }).pipe(ns),
).annotate({
  identifier: "DisableRouteServerPropagationResult",
}) as any as S.Schema<DisableRouteServerPropagationResult>;
export interface DisableSerialConsoleAccessRequest {
  DryRun?: boolean;
}
export const DisableSerialConsoleAccessRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableSerialConsoleAccessRequest",
}) as any as S.Schema<DisableSerialConsoleAccessRequest>;
export interface DisableSerialConsoleAccessResult {
  SerialConsoleAccessEnabled?: boolean;
}
export const DisableSerialConsoleAccessResult = S.suspend(() =>
  S.Struct({
    SerialConsoleAccessEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("serialConsoleAccessEnabled"),
      T.Ec2QueryName("SerialConsoleAccessEnabled"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisableSerialConsoleAccessResult",
}) as any as S.Schema<DisableSerialConsoleAccessResult>;
export interface DisableSnapshotBlockPublicAccessRequest {
  DryRun?: boolean;
}
export const DisableSnapshotBlockPublicAccessRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableSnapshotBlockPublicAccessRequest",
}) as any as S.Schema<DisableSnapshotBlockPublicAccessRequest>;
export type SnapshotBlockPublicAccessState =
  | "block-all-sharing"
  | "block-new-sharing"
  | "unblocked"
  | (string & {});
export const SnapshotBlockPublicAccessState = S.String;
export interface DisableSnapshotBlockPublicAccessResult {
  State?: SnapshotBlockPublicAccessState;
}
export const DisableSnapshotBlockPublicAccessResult = S.suspend(() =>
  S.Struct({
    State: S.optional(SnapshotBlockPublicAccessState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisableSnapshotBlockPublicAccessResult",
}) as any as S.Schema<DisableSnapshotBlockPublicAccessResult>;
export interface DisableTransitGatewayRouteTablePropagationRequest {
  TransitGatewayRouteTableId?: string;
  TransitGatewayAttachmentId?: string;
  DryRun?: boolean;
  TransitGatewayRouteTableAnnouncementId?: string;
}
export const DisableTransitGatewayRouteTablePropagationRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String),
    TransitGatewayAttachmentId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    TransitGatewayRouteTableAnnouncementId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableTransitGatewayRouteTablePropagationRequest",
}) as any as S.Schema<DisableTransitGatewayRouteTablePropagationRequest>;
export type TransitGatewayPropagationState =
  | "enabling"
  | "enabled"
  | "disabling"
  | "disabled"
  | (string & {});
export const TransitGatewayPropagationState = S.String;
export interface TransitGatewayPropagation {
  TransitGatewayAttachmentId?: string;
  ResourceId?: string;
  ResourceType?: TransitGatewayAttachmentResourceType;
  TransitGatewayRouteTableId?: string;
  State?: TransitGatewayPropagationState;
  TransitGatewayRouteTableAnnouncementId?: string;
}
export const TransitGatewayPropagation = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayAttachmentId"),
      T.Ec2QueryName("TransitGatewayAttachmentId"),
    ),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    ResourceType: S.optional(TransitGatewayAttachmentResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    TransitGatewayRouteTableId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayRouteTableId"),
      T.Ec2QueryName("TransitGatewayRouteTableId"),
    ),
    State: S.optional(TransitGatewayPropagationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    TransitGatewayRouteTableAnnouncementId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayRouteTableAnnouncementId"),
      T.Ec2QueryName("TransitGatewayRouteTableAnnouncementId"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayPropagation",
}) as any as S.Schema<TransitGatewayPropagation>;
export interface DisableTransitGatewayRouteTablePropagationResult {
  Propagation?: TransitGatewayPropagation;
}
export const DisableTransitGatewayRouteTablePropagationResult = S.suspend(() =>
  S.Struct({
    Propagation: S.optional(TransitGatewayPropagation)
      .pipe(T.XmlName("propagation"), T.Ec2QueryName("Propagation"))
      .annotate({ identifier: "TransitGatewayPropagation" }),
  }).pipe(ns),
).annotate({
  identifier: "DisableTransitGatewayRouteTablePropagationResult",
}) as any as S.Schema<DisableTransitGatewayRouteTablePropagationResult>;
export interface DisableVgwRoutePropagationRequest {
  GatewayId?: string;
  RouteTableId?: string;
  DryRun?: boolean;
}
export const DisableVgwRoutePropagationRequest = S.suspend(() =>
  S.Struct({
    GatewayId: S.optional(S.String),
    RouteTableId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableVgwRoutePropagationRequest",
}) as any as S.Schema<DisableVgwRoutePropagationRequest>;
export interface DisableVgwRoutePropagationResponse {}
export const DisableVgwRoutePropagationResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DisableVgwRoutePropagationResponse",
}) as any as S.Schema<DisableVgwRoutePropagationResponse>;
export interface DisableVpcClassicLinkRequest {
  DryRun?: boolean;
  VpcId?: string;
}
export const DisableVpcClassicLinkRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableVpcClassicLinkRequest",
}) as any as S.Schema<DisableVpcClassicLinkRequest>;
export interface DisableVpcClassicLinkResult {
  Return?: boolean;
}
export const DisableVpcClassicLinkResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisableVpcClassicLinkResult",
}) as any as S.Schema<DisableVpcClassicLinkResult>;
export interface DisableVpcClassicLinkDnsSupportRequest {
  VpcId?: string;
}
export const DisableVpcClassicLinkDnsSupportRequest = S.suspend(() =>
  S.Struct({ VpcId: S.optional(S.String).pipe(T.XmlName("VpcId")) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableVpcClassicLinkDnsSupportRequest",
}) as any as S.Schema<DisableVpcClassicLinkDnsSupportRequest>;
export interface DisableVpcClassicLinkDnsSupportResult {
  Return?: boolean;
}
export const DisableVpcClassicLinkDnsSupportResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisableVpcClassicLinkDnsSupportResult",
}) as any as S.Schema<DisableVpcClassicLinkDnsSupportResult>;
export interface DisassociateAddressRequest {
  AssociationId?: string;
  PublicIp?: string;
  DryRun?: boolean;
}
export const DisassociateAddressRequest = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String),
    PublicIp: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateAddressRequest",
}) as any as S.Schema<DisassociateAddressRequest>;
export interface DisassociateAddressResponse {}
export const DisassociateAddressResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DisassociateAddressResponse",
}) as any as S.Schema<DisassociateAddressResponse>;
export interface DisassociateCapacityReservationBillingOwnerRequest {
  DryRun?: boolean;
  CapacityReservationId?: string;
  UnusedReservationBillingOwnerId?: string;
}
export const DisassociateCapacityReservationBillingOwnerRequest = S.suspend(
  () =>
    S.Struct({
      DryRun: S.optional(S.Boolean),
      CapacityReservationId: S.optional(S.String),
      UnusedReservationBillingOwnerId: S.optional(S.String),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "DisassociateCapacityReservationBillingOwnerRequest",
}) as any as S.Schema<DisassociateCapacityReservationBillingOwnerRequest>;
export interface DisassociateCapacityReservationBillingOwnerResult {
  Return?: boolean;
}
export const DisassociateCapacityReservationBillingOwnerResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisassociateCapacityReservationBillingOwnerResult",
}) as any as S.Schema<DisassociateCapacityReservationBillingOwnerResult>;
export interface DisassociateClientVpnTargetNetworkRequest {
  ClientVpnEndpointId?: string;
  AssociationId?: string;
  DryRun?: boolean;
}
export const DisassociateClientVpnTargetNetworkRequest = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String),
    AssociationId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateClientVpnTargetNetworkRequest",
}) as any as S.Schema<DisassociateClientVpnTargetNetworkRequest>;
export interface DisassociateClientVpnTargetNetworkResult {
  AssociationId?: string;
  Status?: AssociationStatus;
}
export const DisassociateClientVpnTargetNetworkResult = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
    Status: S.optional(AssociationStatus)
      .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
      .annotate({ identifier: "AssociationStatus" }),
  }).pipe(ns),
).annotate({
  identifier: "DisassociateClientVpnTargetNetworkResult",
}) as any as S.Schema<DisassociateClientVpnTargetNetworkResult>;
export interface DisassociateEnclaveCertificateIamRoleRequest {
  CertificateArn?: string;
  RoleArn?: string;
  DryRun?: boolean;
}
export const DisassociateEnclaveCertificateIamRoleRequest = S.suspend(() =>
  S.Struct({
    CertificateArn: S.optional(S.String),
    RoleArn: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateEnclaveCertificateIamRoleRequest",
}) as any as S.Schema<DisassociateEnclaveCertificateIamRoleRequest>;
export interface DisassociateEnclaveCertificateIamRoleResult {
  Return?: boolean;
}
export const DisassociateEnclaveCertificateIamRoleResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisassociateEnclaveCertificateIamRoleResult",
}) as any as S.Schema<DisassociateEnclaveCertificateIamRoleResult>;
export interface DisassociateIamInstanceProfileRequest {
  AssociationId?: string;
}
export const DisassociateIamInstanceProfileRequest = S.suspend(() =>
  S.Struct({ AssociationId: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateIamInstanceProfileRequest",
}) as any as S.Schema<DisassociateIamInstanceProfileRequest>;
export interface DisassociateIamInstanceProfileResult {
  IamInstanceProfileAssociation?: IamInstanceProfileAssociation;
}
export const DisassociateIamInstanceProfileResult = S.suspend(() =>
  S.Struct({
    IamInstanceProfileAssociation: S.optional(IamInstanceProfileAssociation)
      .pipe(
        T.XmlName("iamInstanceProfileAssociation"),
        T.Ec2QueryName("IamInstanceProfileAssociation"),
      )
      .annotate({ identifier: "IamInstanceProfileAssociation" }),
  }).pipe(ns),
).annotate({
  identifier: "DisassociateIamInstanceProfileResult",
}) as any as S.Schema<DisassociateIamInstanceProfileResult>;
export interface InstanceEventWindowDisassociationRequest {
  InstanceIds?: string[];
  InstanceTags?: Tag[];
  DedicatedHostIds?: string[];
}
export const InstanceEventWindowDisassociationRequest = S.suspend(() =>
  S.Struct({
    InstanceIds: S.optional(InstanceIdList).pipe(T.XmlName("InstanceId")),
    InstanceTags: S.optional(TagList).pipe(T.XmlName("InstanceTag")),
    DedicatedHostIds: S.optional(DedicatedHostIdList).pipe(
      T.XmlName("DedicatedHostId"),
    ),
  }),
).annotate({
  identifier: "InstanceEventWindowDisassociationRequest",
}) as any as S.Schema<InstanceEventWindowDisassociationRequest>;
export interface DisassociateInstanceEventWindowRequest {
  DryRun?: boolean;
  InstanceEventWindowId?: string;
  AssociationTarget?: InstanceEventWindowDisassociationRequest;
}
export const DisassociateInstanceEventWindowRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    InstanceEventWindowId: S.optional(S.String),
    AssociationTarget: S.optional(InstanceEventWindowDisassociationRequest),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateInstanceEventWindowRequest",
}) as any as S.Schema<DisassociateInstanceEventWindowRequest>;
export interface DisassociateInstanceEventWindowResult {
  InstanceEventWindow?: InstanceEventWindow;
}
export const DisassociateInstanceEventWindowResult = S.suspend(() =>
  S.Struct({
    InstanceEventWindow: S.optional(InstanceEventWindow)
      .pipe(
        T.XmlName("instanceEventWindow"),
        T.Ec2QueryName("InstanceEventWindow"),
      )
      .annotate({ identifier: "InstanceEventWindow" }),
  }).pipe(ns),
).annotate({
  identifier: "DisassociateInstanceEventWindowResult",
}) as any as S.Schema<DisassociateInstanceEventWindowResult>;
export interface DisassociateIpamByoasnRequest {
  DryRun?: boolean;
  Asn?: string;
  Cidr?: string;
}
export const DisassociateIpamByoasnRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Asn: S.optional(S.String),
    Cidr: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateIpamByoasnRequest",
}) as any as S.Schema<DisassociateIpamByoasnRequest>;
export interface DisassociateIpamByoasnResult {
  AsnAssociation?: AsnAssociation;
}
export const DisassociateIpamByoasnResult = S.suspend(() =>
  S.Struct({
    AsnAssociation: S.optional(AsnAssociation)
      .pipe(T.XmlName("asnAssociation"), T.Ec2QueryName("AsnAssociation"))
      .annotate({ identifier: "AsnAssociation" }),
  }).pipe(ns),
).annotate({
  identifier: "DisassociateIpamByoasnResult",
}) as any as S.Schema<DisassociateIpamByoasnResult>;
export interface DisassociateIpamResourceDiscoveryRequest {
  DryRun?: boolean;
  IpamResourceDiscoveryAssociationId?: string;
}
export const DisassociateIpamResourceDiscoveryRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamResourceDiscoveryAssociationId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateIpamResourceDiscoveryRequest",
}) as any as S.Schema<DisassociateIpamResourceDiscoveryRequest>;
export interface DisassociateIpamResourceDiscoveryResult {
  IpamResourceDiscoveryAssociation?: IpamResourceDiscoveryAssociation;
}
export const DisassociateIpamResourceDiscoveryResult = S.suspend(() =>
  S.Struct({
    IpamResourceDiscoveryAssociation: S.optional(
      IpamResourceDiscoveryAssociation,
    )
      .pipe(
        T.XmlName("ipamResourceDiscoveryAssociation"),
        T.Ec2QueryName("IpamResourceDiscoveryAssociation"),
      )
      .annotate({ identifier: "IpamResourceDiscoveryAssociation" }),
  }).pipe(ns),
).annotate({
  identifier: "DisassociateIpamResourceDiscoveryResult",
}) as any as S.Schema<DisassociateIpamResourceDiscoveryResult>;
export type EipAssociationIdList = string[];
export const EipAssociationIdList = S.Array(S.String.pipe(T.XmlName("item")));
export interface DisassociateNatGatewayAddressRequest {
  NatGatewayId?: string;
  AssociationIds?: string[];
  MaxDrainDurationSeconds?: number;
  DryRun?: boolean;
}
export const DisassociateNatGatewayAddressRequest = S.suspend(() =>
  S.Struct({
    NatGatewayId: S.optional(S.String),
    AssociationIds: S.optional(EipAssociationIdList).pipe(
      T.XmlName("AssociationId"),
    ),
    MaxDrainDurationSeconds: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateNatGatewayAddressRequest",
}) as any as S.Schema<DisassociateNatGatewayAddressRequest>;
export interface DisassociateNatGatewayAddressResult {
  NatGatewayId?: string;
  NatGatewayAddresses?: NatGatewayAddress[];
}
export const DisassociateNatGatewayAddressResult = S.suspend(() =>
  S.Struct({
    NatGatewayId: S.optional(S.String).pipe(
      T.XmlName("natGatewayId"),
      T.Ec2QueryName("NatGatewayId"),
    ),
    NatGatewayAddresses: S.optional(NatGatewayAddressList).pipe(
      T.XmlName("natGatewayAddressSet"),
      T.Ec2QueryName("NatGatewayAddressSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisassociateNatGatewayAddressResult",
}) as any as S.Schema<DisassociateNatGatewayAddressResult>;
export interface DisassociateRouteServerRequest {
  RouteServerId?: string;
  VpcId?: string;
  DryRun?: boolean;
}
export const DisassociateRouteServerRequest = S.suspend(() =>
  S.Struct({
    RouteServerId: S.optional(S.String),
    VpcId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateRouteServerRequest",
}) as any as S.Schema<DisassociateRouteServerRequest>;
export interface DisassociateRouteServerResult {
  RouteServerAssociation?: RouteServerAssociation;
}
export const DisassociateRouteServerResult = S.suspend(() =>
  S.Struct({
    RouteServerAssociation: S.optional(RouteServerAssociation)
      .pipe(
        T.XmlName("routeServerAssociation"),
        T.Ec2QueryName("RouteServerAssociation"),
      )
      .annotate({ identifier: "RouteServerAssociation" }),
  }).pipe(ns),
).annotate({
  identifier: "DisassociateRouteServerResult",
}) as any as S.Schema<DisassociateRouteServerResult>;
export interface DisassociateRouteTableRequest {
  DryRun?: boolean;
  AssociationId?: string;
}
export const DisassociateRouteTableRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateRouteTableRequest",
}) as any as S.Schema<DisassociateRouteTableRequest>;
export interface DisassociateRouteTableResponse {}
export const DisassociateRouteTableResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DisassociateRouteTableResponse",
}) as any as S.Schema<DisassociateRouteTableResponse>;
export interface DisassociateSecurityGroupVpcRequest {
  GroupId?: string;
  VpcId?: string;
  DryRun?: boolean;
}
export const DisassociateSecurityGroupVpcRequest = S.suspend(() =>
  S.Struct({
    GroupId: S.optional(S.String),
    VpcId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateSecurityGroupVpcRequest",
}) as any as S.Schema<DisassociateSecurityGroupVpcRequest>;
export interface DisassociateSecurityGroupVpcResult {
  State?: SecurityGroupVpcAssociationState;
}
export const DisassociateSecurityGroupVpcResult = S.suspend(() =>
  S.Struct({
    State: S.optional(SecurityGroupVpcAssociationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisassociateSecurityGroupVpcResult",
}) as any as S.Schema<DisassociateSecurityGroupVpcResult>;
export interface DisassociateSubnetCidrBlockRequest {
  AssociationId?: string;
}
export const DisassociateSubnetCidrBlockRequest = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateSubnetCidrBlockRequest",
}) as any as S.Schema<DisassociateSubnetCidrBlockRequest>;
export interface DisassociateSubnetCidrBlockResult {
  Ipv6CidrBlockAssociation?: SubnetIpv6CidrBlockAssociation;
  SubnetId?: string;
}
export const DisassociateSubnetCidrBlockResult = S.suspend(() =>
  S.Struct({
    Ipv6CidrBlockAssociation: S.optional(SubnetIpv6CidrBlockAssociation)
      .pipe(
        T.XmlName("ipv6CidrBlockAssociation"),
        T.Ec2QueryName("Ipv6CidrBlockAssociation"),
      )
      .annotate({ identifier: "SubnetIpv6CidrBlockAssociation" }),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisassociateSubnetCidrBlockResult",
}) as any as S.Schema<DisassociateSubnetCidrBlockResult>;
export interface DisassociateTransitGatewayMulticastDomainRequest {
  TransitGatewayMulticastDomainId?: string;
  TransitGatewayAttachmentId?: string;
  SubnetIds?: string[];
  DryRun?: boolean;
}
export const DisassociateTransitGatewayMulticastDomainRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayMulticastDomainId: S.optional(S.String),
    TransitGatewayAttachmentId: S.optional(S.String),
    SubnetIds: S.optional(TransitGatewaySubnetIdList),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateTransitGatewayMulticastDomainRequest",
}) as any as S.Schema<DisassociateTransitGatewayMulticastDomainRequest>;
export interface DisassociateTransitGatewayMulticastDomainResult {
  Associations?: TransitGatewayMulticastDomainAssociations;
}
export const DisassociateTransitGatewayMulticastDomainResult = S.suspend(() =>
  S.Struct({
    Associations: S.optional(TransitGatewayMulticastDomainAssociations)
      .pipe(T.XmlName("associations"), T.Ec2QueryName("Associations"))
      .annotate({ identifier: "TransitGatewayMulticastDomainAssociations" }),
  }).pipe(ns),
).annotate({
  identifier: "DisassociateTransitGatewayMulticastDomainResult",
}) as any as S.Schema<DisassociateTransitGatewayMulticastDomainResult>;
export interface DisassociateTransitGatewayPolicyTableRequest {
  TransitGatewayPolicyTableId?: string;
  TransitGatewayAttachmentId?: string;
  DryRun?: boolean;
}
export const DisassociateTransitGatewayPolicyTableRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayPolicyTableId: S.optional(S.String),
    TransitGatewayAttachmentId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateTransitGatewayPolicyTableRequest",
}) as any as S.Schema<DisassociateTransitGatewayPolicyTableRequest>;
export interface DisassociateTransitGatewayPolicyTableResult {
  Association?: TransitGatewayPolicyTableAssociation;
}
export const DisassociateTransitGatewayPolicyTableResult = S.suspend(() =>
  S.Struct({
    Association: S.optional(TransitGatewayPolicyTableAssociation)
      .pipe(T.XmlName("association"), T.Ec2QueryName("Association"))
      .annotate({ identifier: "TransitGatewayPolicyTableAssociation" }),
  }).pipe(ns),
).annotate({
  identifier: "DisassociateTransitGatewayPolicyTableResult",
}) as any as S.Schema<DisassociateTransitGatewayPolicyTableResult>;
export interface DisassociateTransitGatewayRouteTableRequest {
  TransitGatewayRouteTableId?: string;
  TransitGatewayAttachmentId?: string;
  DryRun?: boolean;
}
export const DisassociateTransitGatewayRouteTableRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String),
    TransitGatewayAttachmentId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateTransitGatewayRouteTableRequest",
}) as any as S.Schema<DisassociateTransitGatewayRouteTableRequest>;
export interface DisassociateTransitGatewayRouteTableResult {
  Association?: TransitGatewayAssociation;
}
export const DisassociateTransitGatewayRouteTableResult = S.suspend(() =>
  S.Struct({
    Association: S.optional(TransitGatewayAssociation)
      .pipe(T.XmlName("association"), T.Ec2QueryName("Association"))
      .annotate({ identifier: "TransitGatewayAssociation" }),
  }).pipe(ns),
).annotate({
  identifier: "DisassociateTransitGatewayRouteTableResult",
}) as any as S.Schema<DisassociateTransitGatewayRouteTableResult>;
export interface DisassociateTrunkInterfaceRequest {
  AssociationId?: string;
  ClientToken?: string;
  DryRun?: boolean;
}
export const DisassociateTrunkInterfaceRequest = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateTrunkInterfaceRequest",
}) as any as S.Schema<DisassociateTrunkInterfaceRequest>;
export interface DisassociateTrunkInterfaceResult {
  Return?: boolean;
  ClientToken?: string;
}
export const DisassociateTrunkInterfaceResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisassociateTrunkInterfaceResult",
}) as any as S.Schema<DisassociateTrunkInterfaceResult>;
export interface DisassociateVpcCidrBlockRequest {
  AssociationId?: string;
}
export const DisassociateVpcCidrBlockRequest = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateVpcCidrBlockRequest",
}) as any as S.Schema<DisassociateVpcCidrBlockRequest>;
export interface DisassociateVpcCidrBlockResult {
  Ipv6CidrBlockAssociation?: VpcIpv6CidrBlockAssociation;
  CidrBlockAssociation?: VpcCidrBlockAssociation;
  VpcId?: string;
}
export const DisassociateVpcCidrBlockResult = S.suspend(() =>
  S.Struct({
    Ipv6CidrBlockAssociation: S.optional(VpcIpv6CidrBlockAssociation)
      .pipe(
        T.XmlName("ipv6CidrBlockAssociation"),
        T.Ec2QueryName("Ipv6CidrBlockAssociation"),
      )
      .annotate({ identifier: "VpcIpv6CidrBlockAssociation" }),
    CidrBlockAssociation: S.optional(VpcCidrBlockAssociation)
      .pipe(
        T.XmlName("cidrBlockAssociation"),
        T.Ec2QueryName("CidrBlockAssociation"),
      )
      .annotate({ identifier: "VpcCidrBlockAssociation" }),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DisassociateVpcCidrBlockResult",
}) as any as S.Schema<DisassociateVpcCidrBlockResult>;
export interface EnableAddressTransferRequest {
  AllocationId?: string;
  TransferAccountId?: string;
  DryRun?: boolean;
}
export const EnableAddressTransferRequest = S.suspend(() =>
  S.Struct({
    AllocationId: S.optional(S.String),
    TransferAccountId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableAddressTransferRequest",
}) as any as S.Schema<EnableAddressTransferRequest>;
export interface EnableAddressTransferResult {
  AddressTransfer?: AddressTransfer;
}
export const EnableAddressTransferResult = S.suspend(() =>
  S.Struct({
    AddressTransfer: S.optional(AddressTransfer)
      .pipe(T.XmlName("addressTransfer"), T.Ec2QueryName("AddressTransfer"))
      .annotate({ identifier: "AddressTransfer" }),
  }).pipe(ns),
).annotate({
  identifier: "EnableAddressTransferResult",
}) as any as S.Schema<EnableAddressTransferResult>;
export type AllowedImagesSettingsEnabledState =
  | "enabled"
  | "audit-mode"
  | (string & {});
export const AllowedImagesSettingsEnabledState = S.String;
export interface EnableAllowedImagesSettingsRequest {
  AllowedImagesSettingsState?: AllowedImagesSettingsEnabledState;
  DryRun?: boolean;
}
export const EnableAllowedImagesSettingsRequest = S.suspend(() =>
  S.Struct({
    AllowedImagesSettingsState: S.optional(AllowedImagesSettingsEnabledState),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableAllowedImagesSettingsRequest",
}) as any as S.Schema<EnableAllowedImagesSettingsRequest>;
export interface EnableAllowedImagesSettingsResult {
  AllowedImagesSettingsState?: AllowedImagesSettingsEnabledState;
}
export const EnableAllowedImagesSettingsResult = S.suspend(() =>
  S.Struct({
    AllowedImagesSettingsState: S.optional(
      AllowedImagesSettingsEnabledState,
    ).pipe(
      T.XmlName("allowedImagesSettingsState"),
      T.Ec2QueryName("AllowedImagesSettingsState"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "EnableAllowedImagesSettingsResult",
}) as any as S.Schema<EnableAllowedImagesSettingsResult>;
export interface EnableAwsNetworkPerformanceMetricSubscriptionRequest {
  Source?: string;
  Destination?: string;
  Metric?: MetricType;
  Statistic?: StatisticType;
  DryRun?: boolean;
}
export const EnableAwsNetworkPerformanceMetricSubscriptionRequest = S.suspend(
  () =>
    S.Struct({
      Source: S.optional(S.String),
      Destination: S.optional(S.String),
      Metric: S.optional(MetricType),
      Statistic: S.optional(StatisticType),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "EnableAwsNetworkPerformanceMetricSubscriptionRequest",
}) as any as S.Schema<EnableAwsNetworkPerformanceMetricSubscriptionRequest>;
export interface EnableAwsNetworkPerformanceMetricSubscriptionResult {
  Output?: boolean;
}
export const EnableAwsNetworkPerformanceMetricSubscriptionResult = S.suspend(
  () =>
    S.Struct({
      Output: S.optional(S.Boolean).pipe(
        T.XmlName("output"),
        T.Ec2QueryName("Output"),
      ),
    }).pipe(ns),
).annotate({
  identifier: "EnableAwsNetworkPerformanceMetricSubscriptionResult",
}) as any as S.Schema<EnableAwsNetworkPerformanceMetricSubscriptionResult>;
export interface EnableCapacityManagerRequest {
  OrganizationsAccess?: boolean;
  DryRun?: boolean;
  ClientToken?: string;
}
export const EnableCapacityManagerRequest = S.suspend(() =>
  S.Struct({
    OrganizationsAccess: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableCapacityManagerRequest",
}) as any as S.Schema<EnableCapacityManagerRequest>;
export interface EnableCapacityManagerResult {
  CapacityManagerStatus?: CapacityManagerStatus;
  OrganizationsAccess?: boolean;
}
export const EnableCapacityManagerResult = S.suspend(() =>
  S.Struct({
    CapacityManagerStatus: S.optional(CapacityManagerStatus).pipe(
      T.XmlName("capacityManagerStatus"),
      T.Ec2QueryName("CapacityManagerStatus"),
    ),
    OrganizationsAccess: S.optional(S.Boolean).pipe(
      T.XmlName("organizationsAccess"),
      T.Ec2QueryName("OrganizationsAccess"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "EnableCapacityManagerResult",
}) as any as S.Schema<EnableCapacityManagerResult>;
export interface EnableEbsEncryptionByDefaultRequest {
  DryRun?: boolean;
}
export const EnableEbsEncryptionByDefaultRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableEbsEncryptionByDefaultRequest",
}) as any as S.Schema<EnableEbsEncryptionByDefaultRequest>;
export interface EnableEbsEncryptionByDefaultResult {
  EbsEncryptionByDefault?: boolean;
}
export const EnableEbsEncryptionByDefaultResult = S.suspend(() =>
  S.Struct({
    EbsEncryptionByDefault: S.optional(S.Boolean).pipe(
      T.XmlName("ebsEncryptionByDefault"),
      T.Ec2QueryName("EbsEncryptionByDefault"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "EnableEbsEncryptionByDefaultResult",
}) as any as S.Schema<EnableEbsEncryptionByDefaultResult>;
export interface FastLaunchSnapshotConfigurationRequest {
  TargetResourceCount?: number;
}
export const FastLaunchSnapshotConfigurationRequest = S.suspend(() =>
  S.Struct({ TargetResourceCount: S.optional(S.Number) }),
).annotate({
  identifier: "FastLaunchSnapshotConfigurationRequest",
}) as any as S.Schema<FastLaunchSnapshotConfigurationRequest>;
export interface FastLaunchLaunchTemplateSpecificationRequest {
  LaunchTemplateId?: string;
  LaunchTemplateName?: string;
  Version?: string;
}
export const FastLaunchLaunchTemplateSpecificationRequest = S.suspend(() =>
  S.Struct({
    LaunchTemplateId: S.optional(S.String),
    LaunchTemplateName: S.optional(S.String),
    Version: S.optional(S.String),
  }),
).annotate({
  identifier: "FastLaunchLaunchTemplateSpecificationRequest",
}) as any as S.Schema<FastLaunchLaunchTemplateSpecificationRequest>;
export interface EnableFastLaunchRequest {
  ImageId?: string;
  ResourceType?: string;
  SnapshotConfiguration?: FastLaunchSnapshotConfigurationRequest;
  LaunchTemplate?: FastLaunchLaunchTemplateSpecificationRequest;
  MaxParallelLaunches?: number;
  DryRun?: boolean;
}
export const EnableFastLaunchRequest = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String),
    ResourceType: S.optional(S.String),
    SnapshotConfiguration: S.optional(FastLaunchSnapshotConfigurationRequest),
    LaunchTemplate: S.optional(FastLaunchLaunchTemplateSpecificationRequest),
    MaxParallelLaunches: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableFastLaunchRequest",
}) as any as S.Schema<EnableFastLaunchRequest>;
export interface EnableFastLaunchResult {
  ImageId?: string;
  ResourceType?: FastLaunchResourceType;
  SnapshotConfiguration?: FastLaunchSnapshotConfigurationResponse;
  LaunchTemplate?: FastLaunchLaunchTemplateSpecificationResponse;
  MaxParallelLaunches?: number;
  OwnerId?: string;
  State?: FastLaunchStateCode;
  StateTransitionReason?: string;
  StateTransitionTime?: Date;
}
export const EnableFastLaunchResult = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    ResourceType: S.optional(FastLaunchResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    SnapshotConfiguration: S.optional(FastLaunchSnapshotConfigurationResponse)
      .pipe(
        T.XmlName("snapshotConfiguration"),
        T.Ec2QueryName("SnapshotConfiguration"),
      )
      .annotate({ identifier: "FastLaunchSnapshotConfigurationResponse" }),
    LaunchTemplate: S.optional(FastLaunchLaunchTemplateSpecificationResponse)
      .pipe(T.XmlName("launchTemplate"), T.Ec2QueryName("LaunchTemplate"))
      .annotate({
        identifier: "FastLaunchLaunchTemplateSpecificationResponse",
      }),
    MaxParallelLaunches: S.optional(S.Number).pipe(
      T.XmlName("maxParallelLaunches"),
      T.Ec2QueryName("MaxParallelLaunches"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    State: S.optional(FastLaunchStateCode).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StateTransitionReason: S.optional(S.String).pipe(
      T.XmlName("stateTransitionReason"),
      T.Ec2QueryName("StateTransitionReason"),
    ),
    StateTransitionTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("stateTransitionTime"),
      T.Ec2QueryName("StateTransitionTime"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "EnableFastLaunchResult",
}) as any as S.Schema<EnableFastLaunchResult>;
export interface EnableFastSnapshotRestoresRequest {
  AvailabilityZones?: string[];
  AvailabilityZoneIds?: string[];
  SourceSnapshotIds?: string[];
  DryRun?: boolean;
}
export const EnableFastSnapshotRestoresRequest = S.suspend(() =>
  S.Struct({
    AvailabilityZones: S.optional(AvailabilityZoneStringList).pipe(
      T.XmlName("AvailabilityZone"),
    ),
    AvailabilityZoneIds: S.optional(AvailabilityZoneIdStringList).pipe(
      T.XmlName("AvailabilityZoneId"),
    ),
    SourceSnapshotIds: S.optional(SnapshotIdStringList).pipe(
      T.XmlName("SourceSnapshotId"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableFastSnapshotRestoresRequest",
}) as any as S.Schema<EnableFastSnapshotRestoresRequest>;
export interface EnableFastSnapshotRestoreSuccessItem {
  SnapshotId?: string;
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  State?: FastSnapshotRestoreStateCode;
  StateTransitionReason?: string;
  OwnerId?: string;
  OwnerAlias?: string;
  EnablingTime?: Date;
  OptimizingTime?: Date;
  EnabledTime?: Date;
  DisablingTime?: Date;
  DisabledTime?: Date;
}
export const EnableFastSnapshotRestoreSuccessItem = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    State: S.optional(FastSnapshotRestoreStateCode).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    StateTransitionReason: S.optional(S.String).pipe(
      T.XmlName("stateTransitionReason"),
      T.Ec2QueryName("StateTransitionReason"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    OwnerAlias: S.optional(S.String).pipe(
      T.XmlName("ownerAlias"),
      T.Ec2QueryName("OwnerAlias"),
    ),
    EnablingTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("enablingTime"), T.Ec2QueryName("EnablingTime")),
    OptimizingTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("optimizingTime"), T.Ec2QueryName("OptimizingTime")),
    EnabledTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("enabledTime"), T.Ec2QueryName("EnabledTime")),
    DisablingTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("disablingTime"), T.Ec2QueryName("DisablingTime")),
    DisabledTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("disabledTime"), T.Ec2QueryName("DisabledTime")),
  }),
).annotate({
  identifier: "EnableFastSnapshotRestoreSuccessItem",
}) as any as S.Schema<EnableFastSnapshotRestoreSuccessItem>;
export type EnableFastSnapshotRestoreSuccessSet =
  EnableFastSnapshotRestoreSuccessItem[];
export const EnableFastSnapshotRestoreSuccessSet = S.Array(
  EnableFastSnapshotRestoreSuccessItem.pipe(T.XmlName("item")).annotate({
    identifier: "EnableFastSnapshotRestoreSuccessItem",
  }),
);
export interface EnableFastSnapshotRestoreStateError {
  Code?: string;
  Message?: string;
}
export const EnableFastSnapshotRestoreStateError = S.suspend(() =>
  S.Struct({
    Code: S.optional(S.String).pipe(T.XmlName("code"), T.Ec2QueryName("Code")),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "EnableFastSnapshotRestoreStateError",
}) as any as S.Schema<EnableFastSnapshotRestoreStateError>;
export interface EnableFastSnapshotRestoreStateErrorItem {
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  Error?: EnableFastSnapshotRestoreStateError;
}
export const EnableFastSnapshotRestoreStateErrorItem = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    Error: S.optional(EnableFastSnapshotRestoreStateError)
      .pipe(T.XmlName("error"), T.Ec2QueryName("Error"))
      .annotate({ identifier: "EnableFastSnapshotRestoreStateError" }),
  }),
).annotate({
  identifier: "EnableFastSnapshotRestoreStateErrorItem",
}) as any as S.Schema<EnableFastSnapshotRestoreStateErrorItem>;
export type EnableFastSnapshotRestoreStateErrorSet =
  EnableFastSnapshotRestoreStateErrorItem[];
export const EnableFastSnapshotRestoreStateErrorSet = S.Array(
  EnableFastSnapshotRestoreStateErrorItem.pipe(T.XmlName("item")).annotate({
    identifier: "EnableFastSnapshotRestoreStateErrorItem",
  }),
);
export interface EnableFastSnapshotRestoreErrorItem {
  SnapshotId?: string;
  FastSnapshotRestoreStateErrors?: EnableFastSnapshotRestoreStateErrorItem[];
}
export const EnableFastSnapshotRestoreErrorItem = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    FastSnapshotRestoreStateErrors: S.optional(
      EnableFastSnapshotRestoreStateErrorSet,
    ).pipe(
      T.XmlName("fastSnapshotRestoreStateErrorSet"),
      T.Ec2QueryName("FastSnapshotRestoreStateErrorSet"),
    ),
  }),
).annotate({
  identifier: "EnableFastSnapshotRestoreErrorItem",
}) as any as S.Schema<EnableFastSnapshotRestoreErrorItem>;
export type EnableFastSnapshotRestoreErrorSet =
  EnableFastSnapshotRestoreErrorItem[];
export const EnableFastSnapshotRestoreErrorSet = S.Array(
  EnableFastSnapshotRestoreErrorItem.pipe(T.XmlName("item")).annotate({
    identifier: "EnableFastSnapshotRestoreErrorItem",
  }),
);
export interface EnableFastSnapshotRestoresResult {
  Successful?: EnableFastSnapshotRestoreSuccessItem[];
  Unsuccessful?: EnableFastSnapshotRestoreErrorItem[];
}
export const EnableFastSnapshotRestoresResult = S.suspend(() =>
  S.Struct({
    Successful: S.optional(EnableFastSnapshotRestoreSuccessSet).pipe(
      T.XmlName("successful"),
      T.Ec2QueryName("Successful"),
    ),
    Unsuccessful: S.optional(EnableFastSnapshotRestoreErrorSet).pipe(
      T.XmlName("unsuccessful"),
      T.Ec2QueryName("Unsuccessful"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "EnableFastSnapshotRestoresResult",
}) as any as S.Schema<EnableFastSnapshotRestoresResult>;
export interface EnableImageRequest {
  ImageId?: string;
  DryRun?: boolean;
}
export const EnableImageRequest = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableImageRequest",
}) as any as S.Schema<EnableImageRequest>;
export interface EnableImageResult {
  Return?: boolean;
}
export const EnableImageResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "EnableImageResult",
}) as any as S.Schema<EnableImageResult>;
export type ImageBlockPublicAccessEnabledState =
  | "block-new-sharing"
  | (string & {});
export const ImageBlockPublicAccessEnabledState = S.String;
export interface EnableImageBlockPublicAccessRequest {
  ImageBlockPublicAccessState?: ImageBlockPublicAccessEnabledState;
  DryRun?: boolean;
}
export const EnableImageBlockPublicAccessRequest = S.suspend(() =>
  S.Struct({
    ImageBlockPublicAccessState: S.optional(ImageBlockPublicAccessEnabledState),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableImageBlockPublicAccessRequest",
}) as any as S.Schema<EnableImageBlockPublicAccessRequest>;
export interface EnableImageBlockPublicAccessResult {
  ImageBlockPublicAccessState?: ImageBlockPublicAccessEnabledState;
}
export const EnableImageBlockPublicAccessResult = S.suspend(() =>
  S.Struct({
    ImageBlockPublicAccessState: S.optional(
      ImageBlockPublicAccessEnabledState,
    ).pipe(
      T.XmlName("imageBlockPublicAccessState"),
      T.Ec2QueryName("ImageBlockPublicAccessState"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "EnableImageBlockPublicAccessResult",
}) as any as S.Schema<EnableImageBlockPublicAccessResult>;
export interface EnableImageDeprecationRequest {
  ImageId?: string;
  DeprecateAt?: Date;
  DryRun?: boolean;
}
export const EnableImageDeprecationRequest = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String),
    DeprecateAt: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableImageDeprecationRequest",
}) as any as S.Schema<EnableImageDeprecationRequest>;
export interface EnableImageDeprecationResult {
  Return?: boolean;
}
export const EnableImageDeprecationResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "EnableImageDeprecationResult",
}) as any as S.Schema<EnableImageDeprecationResult>;
export interface EnableImageDeregistrationProtectionRequest {
  ImageId?: string;
  WithCooldown?: boolean;
  DryRun?: boolean;
}
export const EnableImageDeregistrationProtectionRequest = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String),
    WithCooldown: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableImageDeregistrationProtectionRequest",
}) as any as S.Schema<EnableImageDeregistrationProtectionRequest>;
export interface EnableImageDeregistrationProtectionResult {
  Return?: string;
}
export const EnableImageDeregistrationProtectionResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.String).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "EnableImageDeregistrationProtectionResult",
}) as any as S.Schema<EnableImageDeregistrationProtectionResult>;
export interface EnableInstanceSqlHaStandbyDetectionsRequest {
  InstanceIds?: string[];
  SqlServerCredentials?: string;
  DryRun?: boolean;
}
export const EnableInstanceSqlHaStandbyDetectionsRequest = S.suspend(() =>
  S.Struct({
    InstanceIds: S.optional(InstanceIdUpdateStringList).pipe(
      T.XmlName("InstanceId"),
    ),
    SqlServerCredentials: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableInstanceSqlHaStandbyDetectionsRequest",
}) as any as S.Schema<EnableInstanceSqlHaStandbyDetectionsRequest>;
export interface EnableInstanceSqlHaStandbyDetectionsResult {
  Instances?: RegisteredInstance[];
}
export const EnableInstanceSqlHaStandbyDetectionsResult = S.suspend(() =>
  S.Struct({
    Instances: S.optional(RegisteredInstanceList).pipe(
      T.XmlName("instanceSet"),
      T.Ec2QueryName("InstanceSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "EnableInstanceSqlHaStandbyDetectionsResult",
}) as any as S.Schema<EnableInstanceSqlHaStandbyDetectionsResult>;
export interface EnableIpamOrganizationAdminAccountRequest {
  DryRun?: boolean;
  DelegatedAdminAccountId?: string;
}
export const EnableIpamOrganizationAdminAccountRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    DelegatedAdminAccountId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableIpamOrganizationAdminAccountRequest",
}) as any as S.Schema<EnableIpamOrganizationAdminAccountRequest>;
export interface EnableIpamOrganizationAdminAccountResult {
  Success?: boolean;
}
export const EnableIpamOrganizationAdminAccountResult = S.suspend(() =>
  S.Struct({
    Success: S.optional(S.Boolean).pipe(
      T.XmlName("success"),
      T.Ec2QueryName("Success"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "EnableIpamOrganizationAdminAccountResult",
}) as any as S.Schema<EnableIpamOrganizationAdminAccountResult>;
export interface EnableIpamPolicyRequest {
  DryRun?: boolean;
  IpamPolicyId?: string;
  OrganizationTargetId?: string;
}
export const EnableIpamPolicyRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPolicyId: S.optional(S.String),
    OrganizationTargetId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableIpamPolicyRequest",
}) as any as S.Schema<EnableIpamPolicyRequest>;
export interface EnableIpamPolicyResult {
  IpamPolicyId?: string;
}
export const EnableIpamPolicyResult = S.suspend(() =>
  S.Struct({
    IpamPolicyId: S.optional(S.String).pipe(
      T.XmlName("ipamPolicyId"),
      T.Ec2QueryName("IpamPolicyId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "EnableIpamPolicyResult",
}) as any as S.Schema<EnableIpamPolicyResult>;
export interface EnableReachabilityAnalyzerOrganizationSharingRequest {
  DryRun?: boolean;
}
export const EnableReachabilityAnalyzerOrganizationSharingRequest = S.suspend(
  () =>
    S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "EnableReachabilityAnalyzerOrganizationSharingRequest",
}) as any as S.Schema<EnableReachabilityAnalyzerOrganizationSharingRequest>;
export interface EnableReachabilityAnalyzerOrganizationSharingResult {
  ReturnValue?: boolean;
}
export const EnableReachabilityAnalyzerOrganizationSharingResult = S.suspend(
  () =>
    S.Struct({
      ReturnValue: S.optional(S.Boolean).pipe(
        T.XmlName("returnValue"),
        T.Ec2QueryName("ReturnValue"),
      ),
    }).pipe(ns),
).annotate({
  identifier: "EnableReachabilityAnalyzerOrganizationSharingResult",
}) as any as S.Schema<EnableReachabilityAnalyzerOrganizationSharingResult>;
export interface EnableRouteServerPropagationRequest {
  RouteServerId?: string;
  RouteTableId?: string;
  DryRun?: boolean;
}
export const EnableRouteServerPropagationRequest = S.suspend(() =>
  S.Struct({
    RouteServerId: S.optional(S.String),
    RouteTableId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableRouteServerPropagationRequest",
}) as any as S.Schema<EnableRouteServerPropagationRequest>;
export interface EnableRouteServerPropagationResult {
  RouteServerPropagation?: RouteServerPropagation;
}
export const EnableRouteServerPropagationResult = S.suspend(() =>
  S.Struct({
    RouteServerPropagation: S.optional(RouteServerPropagation)
      .pipe(
        T.XmlName("routeServerPropagation"),
        T.Ec2QueryName("RouteServerPropagation"),
      )
      .annotate({ identifier: "RouteServerPropagation" }),
  }).pipe(ns),
).annotate({
  identifier: "EnableRouteServerPropagationResult",
}) as any as S.Schema<EnableRouteServerPropagationResult>;
export interface EnableSerialConsoleAccessRequest {
  DryRun?: boolean;
}
export const EnableSerialConsoleAccessRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableSerialConsoleAccessRequest",
}) as any as S.Schema<EnableSerialConsoleAccessRequest>;
export interface EnableSerialConsoleAccessResult {
  SerialConsoleAccessEnabled?: boolean;
}
export const EnableSerialConsoleAccessResult = S.suspend(() =>
  S.Struct({
    SerialConsoleAccessEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("serialConsoleAccessEnabled"),
      T.Ec2QueryName("SerialConsoleAccessEnabled"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "EnableSerialConsoleAccessResult",
}) as any as S.Schema<EnableSerialConsoleAccessResult>;
export interface EnableSnapshotBlockPublicAccessRequest {
  State?: SnapshotBlockPublicAccessState;
  DryRun?: boolean;
}
export const EnableSnapshotBlockPublicAccessRequest = S.suspend(() =>
  S.Struct({
    State: S.optional(SnapshotBlockPublicAccessState),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableSnapshotBlockPublicAccessRequest",
}) as any as S.Schema<EnableSnapshotBlockPublicAccessRequest>;
export interface EnableSnapshotBlockPublicAccessResult {
  State?: SnapshotBlockPublicAccessState;
}
export const EnableSnapshotBlockPublicAccessResult = S.suspend(() =>
  S.Struct({
    State: S.optional(SnapshotBlockPublicAccessState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "EnableSnapshotBlockPublicAccessResult",
}) as any as S.Schema<EnableSnapshotBlockPublicAccessResult>;
export interface EnableTransitGatewayRouteTablePropagationRequest {
  TransitGatewayRouteTableId?: string;
  TransitGatewayAttachmentId?: string;
  DryRun?: boolean;
  TransitGatewayRouteTableAnnouncementId?: string;
}
export const EnableTransitGatewayRouteTablePropagationRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String),
    TransitGatewayAttachmentId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    TransitGatewayRouteTableAnnouncementId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableTransitGatewayRouteTablePropagationRequest",
}) as any as S.Schema<EnableTransitGatewayRouteTablePropagationRequest>;
export interface EnableTransitGatewayRouteTablePropagationResult {
  Propagation?: TransitGatewayPropagation;
}
export const EnableTransitGatewayRouteTablePropagationResult = S.suspend(() =>
  S.Struct({
    Propagation: S.optional(TransitGatewayPropagation)
      .pipe(T.XmlName("propagation"), T.Ec2QueryName("Propagation"))
      .annotate({ identifier: "TransitGatewayPropagation" }),
  }).pipe(ns),
).annotate({
  identifier: "EnableTransitGatewayRouteTablePropagationResult",
}) as any as S.Schema<EnableTransitGatewayRouteTablePropagationResult>;
export interface EnableVgwRoutePropagationRequest {
  GatewayId?: string;
  RouteTableId?: string;
  DryRun?: boolean;
}
export const EnableVgwRoutePropagationRequest = S.suspend(() =>
  S.Struct({
    GatewayId: S.optional(S.String),
    RouteTableId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableVgwRoutePropagationRequest",
}) as any as S.Schema<EnableVgwRoutePropagationRequest>;
export interface EnableVgwRoutePropagationResponse {}
export const EnableVgwRoutePropagationResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "EnableVgwRoutePropagationResponse",
}) as any as S.Schema<EnableVgwRoutePropagationResponse>;
export interface EnableVolumeIORequest {
  DryRun?: boolean;
  VolumeId?: string;
}
export const EnableVolumeIORequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    VolumeId: S.optional(S.String).pipe(
      T.XmlName("volumeId"),
      T.Ec2QueryName("VolumeId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableVolumeIORequest",
}) as any as S.Schema<EnableVolumeIORequest>;
export interface EnableVolumeIOResponse {}
export const EnableVolumeIOResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "EnableVolumeIOResponse",
}) as any as S.Schema<EnableVolumeIOResponse>;
export interface EnableVpcClassicLinkRequest {
  DryRun?: boolean;
  VpcId?: string;
}
export const EnableVpcClassicLinkRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableVpcClassicLinkRequest",
}) as any as S.Schema<EnableVpcClassicLinkRequest>;
export interface EnableVpcClassicLinkResult {
  Return?: boolean;
}
export const EnableVpcClassicLinkResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "EnableVpcClassicLinkResult",
}) as any as S.Schema<EnableVpcClassicLinkResult>;
export interface EnableVpcClassicLinkDnsSupportRequest {
  VpcId?: string;
}
export const EnableVpcClassicLinkDnsSupportRequest = S.suspend(() =>
  S.Struct({ VpcId: S.optional(S.String).pipe(T.XmlName("VpcId")) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableVpcClassicLinkDnsSupportRequest",
}) as any as S.Schema<EnableVpcClassicLinkDnsSupportRequest>;
export interface EnableVpcClassicLinkDnsSupportResult {
  Return?: boolean;
}
export const EnableVpcClassicLinkDnsSupportResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "EnableVpcClassicLinkDnsSupportResult",
}) as any as S.Schema<EnableVpcClassicLinkDnsSupportResult>;
export interface ExportClientVpnClientCertificateRevocationListRequest {
  ClientVpnEndpointId?: string;
  DryRun?: boolean;
}
export const ExportClientVpnClientCertificateRevocationListRequest = S.suspend(
  () =>
    S.Struct({
      ClientVpnEndpointId: S.optional(S.String),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "ExportClientVpnClientCertificateRevocationListRequest",
}) as any as S.Schema<ExportClientVpnClientCertificateRevocationListRequest>;
export type ClientCertificateRevocationListStatusCode =
  | "pending"
  | "active"
  | (string & {});
export const ClientCertificateRevocationListStatusCode = S.String;
export interface ClientCertificateRevocationListStatus {
  Code?: ClientCertificateRevocationListStatusCode;
  Message?: string;
}
export const ClientCertificateRevocationListStatus = S.suspend(() =>
  S.Struct({
    Code: S.optional(ClientCertificateRevocationListStatusCode).pipe(
      T.XmlName("code"),
      T.Ec2QueryName("Code"),
    ),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "ClientCertificateRevocationListStatus",
}) as any as S.Schema<ClientCertificateRevocationListStatus>;
export interface ExportClientVpnClientCertificateRevocationListResult {
  CertificateRevocationList?: string;
  Status?: ClientCertificateRevocationListStatus;
}
export const ExportClientVpnClientCertificateRevocationListResult = S.suspend(
  () =>
    S.Struct({
      CertificateRevocationList: S.optional(S.String).pipe(
        T.XmlName("certificateRevocationList"),
        T.Ec2QueryName("CertificateRevocationList"),
      ),
      Status: S.optional(ClientCertificateRevocationListStatus)
        .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
        .annotate({ identifier: "ClientCertificateRevocationListStatus" }),
    }).pipe(ns),
).annotate({
  identifier: "ExportClientVpnClientCertificateRevocationListResult",
}) as any as S.Schema<ExportClientVpnClientCertificateRevocationListResult>;
export interface ExportClientVpnClientConfigurationRequest {
  ClientVpnEndpointId?: string;
  DryRun?: boolean;
}
export const ExportClientVpnClientConfigurationRequest = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ExportClientVpnClientConfigurationRequest",
}) as any as S.Schema<ExportClientVpnClientConfigurationRequest>;
export interface ExportClientVpnClientConfigurationResult {
  ClientConfiguration?: string;
}
export const ExportClientVpnClientConfigurationResult = S.suspend(() =>
  S.Struct({
    ClientConfiguration: S.optional(S.String).pipe(
      T.XmlName("clientConfiguration"),
      T.Ec2QueryName("ClientConfiguration"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ExportClientVpnClientConfigurationResult",
}) as any as S.Schema<ExportClientVpnClientConfigurationResult>;
export interface ExportTaskS3LocationRequest {
  S3Bucket?: string;
  S3Prefix?: string;
}
export const ExportTaskS3LocationRequest = S.suspend(() =>
  S.Struct({ S3Bucket: S.optional(S.String), S3Prefix: S.optional(S.String) }),
).annotate({
  identifier: "ExportTaskS3LocationRequest",
}) as any as S.Schema<ExportTaskS3LocationRequest>;
export interface ExportImageRequest {
  ClientToken?: string;
  Description?: string;
  DiskImageFormat?: DiskImageFormat;
  DryRun?: boolean;
  ImageId?: string;
  S3ExportLocation?: ExportTaskS3LocationRequest;
  RoleName?: string;
  TagSpecifications?: TagSpecification[];
}
export const ExportImageRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    Description: S.optional(S.String),
    DiskImageFormat: S.optional(DiskImageFormat),
    DryRun: S.optional(S.Boolean),
    ImageId: S.optional(S.String),
    S3ExportLocation: S.optional(ExportTaskS3LocationRequest),
    RoleName: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ExportImageRequest",
}) as any as S.Schema<ExportImageRequest>;
export interface ExportImageResult {
  Description?: string;
  DiskImageFormat?: DiskImageFormat;
  ExportImageTaskId?: string;
  ImageId?: string;
  RoleName?: string;
  Progress?: string;
  S3ExportLocation?: ExportTaskS3Location;
  Status?: string;
  StatusMessage?: string;
  Tags?: Tag[];
}
export const ExportImageResult = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    DiskImageFormat: S.optional(DiskImageFormat).pipe(
      T.XmlName("diskImageFormat"),
      T.Ec2QueryName("DiskImageFormat"),
    ),
    ExportImageTaskId: S.optional(S.String).pipe(
      T.XmlName("exportImageTaskId"),
      T.Ec2QueryName("ExportImageTaskId"),
    ),
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    RoleName: S.optional(S.String).pipe(
      T.XmlName("roleName"),
      T.Ec2QueryName("RoleName"),
    ),
    Progress: S.optional(S.String).pipe(
      T.XmlName("progress"),
      T.Ec2QueryName("Progress"),
    ),
    S3ExportLocation: S.optional(ExportTaskS3Location)
      .pipe(T.XmlName("s3ExportLocation"), T.Ec2QueryName("S3ExportLocation"))
      .annotate({ identifier: "ExportTaskS3Location" }),
    Status: S.optional(S.String).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ExportImageResult",
}) as any as S.Schema<ExportImageResult>;
export interface ExportTransitGatewayRoutesRequest {
  TransitGatewayRouteTableId?: string;
  Filters?: Filter[];
  S3Bucket?: string;
  DryRun?: boolean;
}
export const ExportTransitGatewayRoutesRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    S3Bucket: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ExportTransitGatewayRoutesRequest",
}) as any as S.Schema<ExportTransitGatewayRoutesRequest>;
export interface ExportTransitGatewayRoutesResult {
  S3Location?: string;
}
export const ExportTransitGatewayRoutesResult = S.suspend(() =>
  S.Struct({
    S3Location: S.optional(S.String).pipe(
      T.XmlName("s3Location"),
      T.Ec2QueryName("S3Location"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ExportTransitGatewayRoutesResult",
}) as any as S.Schema<ExportTransitGatewayRoutesResult>;
export interface ExportVerifiedAccessInstanceClientConfigurationRequest {
  VerifiedAccessInstanceId?: string;
  DryRun?: boolean;
}
export const ExportVerifiedAccessInstanceClientConfigurationRequest = S.suspend(
  () =>
    S.Struct({
      VerifiedAccessInstanceId: S.optional(S.String),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "ExportVerifiedAccessInstanceClientConfigurationRequest",
}) as any as S.Schema<ExportVerifiedAccessInstanceClientConfigurationRequest>;
export type DeviceTrustProviderTypeList = DeviceTrustProviderType[];
export const DeviceTrustProviderTypeList = S.Array(
  DeviceTrustProviderType.pipe(T.XmlName("item")),
);
export interface VerifiedAccessInstanceUserTrustProviderClientConfiguration {
  Type?: UserTrustProviderType;
  Scopes?: string;
  Issuer?: string;
  AuthorizationEndpoint?: string;
  PublicSigningKeyEndpoint?: string;
  TokenEndpoint?: string;
  UserInfoEndpoint?: string;
  ClientId?: string;
  ClientSecret?: string | redacted.Redacted<string>;
  PkceEnabled?: boolean;
}
export const VerifiedAccessInstanceUserTrustProviderClientConfiguration =
  S.suspend(() =>
    S.Struct({
      Type: S.optional(UserTrustProviderType).pipe(
        T.XmlName("type"),
        T.Ec2QueryName("Type"),
      ),
      Scopes: S.optional(S.String).pipe(
        T.XmlName("scopes"),
        T.Ec2QueryName("Scopes"),
      ),
      Issuer: S.optional(S.String).pipe(
        T.XmlName("issuer"),
        T.Ec2QueryName("Issuer"),
      ),
      AuthorizationEndpoint: S.optional(S.String).pipe(
        T.XmlName("authorizationEndpoint"),
        T.Ec2QueryName("AuthorizationEndpoint"),
      ),
      PublicSigningKeyEndpoint: S.optional(S.String).pipe(
        T.XmlName("publicSigningKeyEndpoint"),
        T.Ec2QueryName("PublicSigningKeyEndpoint"),
      ),
      TokenEndpoint: S.optional(S.String).pipe(
        T.XmlName("tokenEndpoint"),
        T.Ec2QueryName("TokenEndpoint"),
      ),
      UserInfoEndpoint: S.optional(S.String).pipe(
        T.XmlName("userInfoEndpoint"),
        T.Ec2QueryName("UserInfoEndpoint"),
      ),
      ClientId: S.optional(S.String).pipe(
        T.XmlName("clientId"),
        T.Ec2QueryName("ClientId"),
      ),
      ClientSecret: S.optional(SensitiveString).pipe(
        T.XmlName("clientSecret"),
        T.Ec2QueryName("ClientSecret"),
      ),
      PkceEnabled: S.optional(S.Boolean).pipe(
        T.XmlName("pkceEnabled"),
        T.Ec2QueryName("PkceEnabled"),
      ),
    }),
  ).annotate({
    identifier: "VerifiedAccessInstanceUserTrustProviderClientConfiguration",
  }) as any as S.Schema<VerifiedAccessInstanceUserTrustProviderClientConfiguration>;
export interface VerifiedAccessInstanceOpenVpnClientConfigurationRoute {
  Cidr?: string;
}
export const VerifiedAccessInstanceOpenVpnClientConfigurationRoute = S.suspend(
  () =>
    S.Struct({
      Cidr: S.optional(S.String).pipe(
        T.XmlName("cidr"),
        T.Ec2QueryName("Cidr"),
      ),
    }),
).annotate({
  identifier: "VerifiedAccessInstanceOpenVpnClientConfigurationRoute",
}) as any as S.Schema<VerifiedAccessInstanceOpenVpnClientConfigurationRoute>;
export type VerifiedAccessInstanceOpenVpnClientConfigurationRouteList =
  VerifiedAccessInstanceOpenVpnClientConfigurationRoute[];
export const VerifiedAccessInstanceOpenVpnClientConfigurationRouteList =
  S.Array(
    VerifiedAccessInstanceOpenVpnClientConfigurationRoute.pipe(
      T.XmlName("item"),
    ).annotate({
      identifier: "VerifiedAccessInstanceOpenVpnClientConfigurationRoute",
    }),
  );
export interface VerifiedAccessInstanceOpenVpnClientConfiguration {
  Config?: string;
  Routes?: VerifiedAccessInstanceOpenVpnClientConfigurationRoute[];
}
export const VerifiedAccessInstanceOpenVpnClientConfiguration = S.suspend(() =>
  S.Struct({
    Config: S.optional(S.String).pipe(
      T.XmlName("config"),
      T.Ec2QueryName("Config"),
    ),
    Routes: S.optional(
      VerifiedAccessInstanceOpenVpnClientConfigurationRouteList,
    ).pipe(T.XmlName("routeSet"), T.Ec2QueryName("RouteSet")),
  }),
).annotate({
  identifier: "VerifiedAccessInstanceOpenVpnClientConfiguration",
}) as any as S.Schema<VerifiedAccessInstanceOpenVpnClientConfiguration>;
export type VerifiedAccessInstanceOpenVpnClientConfigurationList =
  VerifiedAccessInstanceOpenVpnClientConfiguration[];
export const VerifiedAccessInstanceOpenVpnClientConfigurationList = S.Array(
  VerifiedAccessInstanceOpenVpnClientConfiguration.pipe(
    T.XmlName("item"),
  ).annotate({
    identifier: "VerifiedAccessInstanceOpenVpnClientConfiguration",
  }),
);
export interface ExportVerifiedAccessInstanceClientConfigurationResult {
  Version?: string;
  VerifiedAccessInstanceId?: string;
  Region?: string;
  DeviceTrustProviders?: DeviceTrustProviderType[];
  UserTrustProvider?: VerifiedAccessInstanceUserTrustProviderClientConfiguration;
  OpenVpnConfigurations?: VerifiedAccessInstanceOpenVpnClientConfiguration[];
}
export const ExportVerifiedAccessInstanceClientConfigurationResult = S.suspend(
  () =>
    S.Struct({
      Version: S.optional(S.String).pipe(
        T.XmlName("version"),
        T.Ec2QueryName("Version"),
      ),
      VerifiedAccessInstanceId: S.optional(S.String).pipe(
        T.XmlName("verifiedAccessInstanceId"),
        T.Ec2QueryName("VerifiedAccessInstanceId"),
      ),
      Region: S.optional(S.String).pipe(
        T.XmlName("region"),
        T.Ec2QueryName("Region"),
      ),
      DeviceTrustProviders: S.optional(DeviceTrustProviderTypeList).pipe(
        T.XmlName("deviceTrustProviderSet"),
        T.Ec2QueryName("DeviceTrustProviderSet"),
      ),
      UserTrustProvider: S.optional(
        VerifiedAccessInstanceUserTrustProviderClientConfiguration,
      )
        .pipe(
          T.XmlName("userTrustProvider"),
          T.Ec2QueryName("UserTrustProvider"),
        )
        .annotate({
          identifier:
            "VerifiedAccessInstanceUserTrustProviderClientConfiguration",
        }),
      OpenVpnConfigurations: S.optional(
        VerifiedAccessInstanceOpenVpnClientConfigurationList,
      ).pipe(
        T.XmlName("openVpnConfigurationSet"),
        T.Ec2QueryName("OpenVpnConfigurationSet"),
      ),
    }).pipe(ns),
).annotate({
  identifier: "ExportVerifiedAccessInstanceClientConfigurationResult",
}) as any as S.Schema<ExportVerifiedAccessInstanceClientConfigurationResult>;
export interface GetActiveVpnTunnelStatusRequest {
  VpnConnectionId?: string;
  VpnTunnelOutsideIpAddress?: string;
  DryRun?: boolean;
}
export const GetActiveVpnTunnelStatusRequest = S.suspend(() =>
  S.Struct({
    VpnConnectionId: S.optional(S.String),
    VpnTunnelOutsideIpAddress: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetActiveVpnTunnelStatusRequest",
}) as any as S.Schema<GetActiveVpnTunnelStatusRequest>;
export type VpnTunnelProvisioningStatus =
  | "available"
  | "pending"
  | "failed"
  | (string & {});
export const VpnTunnelProvisioningStatus = S.String;
export interface ActiveVpnTunnelStatus {
  Phase1EncryptionAlgorithm?: string;
  Phase2EncryptionAlgorithm?: string;
  Phase1IntegrityAlgorithm?: string;
  Phase2IntegrityAlgorithm?: string;
  Phase1DHGroup?: number;
  Phase2DHGroup?: number;
  IkeVersion?: string;
  ProvisioningStatus?: VpnTunnelProvisioningStatus;
  ProvisioningStatusReason?: string;
}
export const ActiveVpnTunnelStatus = S.suspend(() =>
  S.Struct({
    Phase1EncryptionAlgorithm: S.optional(S.String).pipe(
      T.XmlName("phase1EncryptionAlgorithm"),
      T.Ec2QueryName("Phase1EncryptionAlgorithm"),
    ),
    Phase2EncryptionAlgorithm: S.optional(S.String).pipe(
      T.XmlName("phase2EncryptionAlgorithm"),
      T.Ec2QueryName("Phase2EncryptionAlgorithm"),
    ),
    Phase1IntegrityAlgorithm: S.optional(S.String).pipe(
      T.XmlName("phase1IntegrityAlgorithm"),
      T.Ec2QueryName("Phase1IntegrityAlgorithm"),
    ),
    Phase2IntegrityAlgorithm: S.optional(S.String).pipe(
      T.XmlName("phase2IntegrityAlgorithm"),
      T.Ec2QueryName("Phase2IntegrityAlgorithm"),
    ),
    Phase1DHGroup: S.optional(S.Number).pipe(
      T.XmlName("phase1DHGroup"),
      T.Ec2QueryName("Phase1DHGroup"),
    ),
    Phase2DHGroup: S.optional(S.Number).pipe(
      T.XmlName("phase2DHGroup"),
      T.Ec2QueryName("Phase2DHGroup"),
    ),
    IkeVersion: S.optional(S.String).pipe(
      T.XmlName("ikeVersion"),
      T.Ec2QueryName("IkeVersion"),
    ),
    ProvisioningStatus: S.optional(VpnTunnelProvisioningStatus).pipe(
      T.XmlName("provisioningStatus"),
      T.Ec2QueryName("ProvisioningStatus"),
    ),
    ProvisioningStatusReason: S.optional(S.String).pipe(
      T.XmlName("provisioningStatusReason"),
      T.Ec2QueryName("ProvisioningStatusReason"),
    ),
  }),
).annotate({
  identifier: "ActiveVpnTunnelStatus",
}) as any as S.Schema<ActiveVpnTunnelStatus>;
export interface GetActiveVpnTunnelStatusResult {
  ActiveVpnTunnelStatus?: ActiveVpnTunnelStatus;
}
export const GetActiveVpnTunnelStatusResult = S.suspend(() =>
  S.Struct({
    ActiveVpnTunnelStatus: S.optional(ActiveVpnTunnelStatus)
      .pipe(
        T.XmlName("activeVpnTunnelStatus"),
        T.Ec2QueryName("ActiveVpnTunnelStatus"),
      )
      .annotate({ identifier: "ActiveVpnTunnelStatus" }),
  }).pipe(ns),
).annotate({
  identifier: "GetActiveVpnTunnelStatusResult",
}) as any as S.Schema<GetActiveVpnTunnelStatusResult>;
export interface GetAllowedImagesSettingsRequest {
  DryRun?: boolean;
}
export const GetAllowedImagesSettingsRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetAllowedImagesSettingsRequest",
}) as any as S.Schema<GetAllowedImagesSettingsRequest>;
export type ImageProviderList = string[];
export const ImageProviderList = S.Array(S.String.pipe(T.XmlName("item")));
export type MarketplaceProductCodeList = string[];
export const MarketplaceProductCodeList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export type ImageNameList = string[];
export const ImageNameList = S.Array(S.String.pipe(T.XmlName("item")));
export interface DeprecationTimeCondition {
  MaximumDaysSinceDeprecated?: number;
}
export const DeprecationTimeCondition = S.suspend(() =>
  S.Struct({
    MaximumDaysSinceDeprecated: S.optional(S.Number).pipe(
      T.XmlName("maximumDaysSinceDeprecated"),
      T.Ec2QueryName("MaximumDaysSinceDeprecated"),
    ),
  }),
).annotate({
  identifier: "DeprecationTimeCondition",
}) as any as S.Schema<DeprecationTimeCondition>;
export interface CreationDateCondition {
  MaximumDaysSinceCreated?: number;
}
export const CreationDateCondition = S.suspend(() =>
  S.Struct({
    MaximumDaysSinceCreated: S.optional(S.Number).pipe(
      T.XmlName("maximumDaysSinceCreated"),
      T.Ec2QueryName("MaximumDaysSinceCreated"),
    ),
  }),
).annotate({
  identifier: "CreationDateCondition",
}) as any as S.Schema<CreationDateCondition>;
export interface ImageCriterion {
  ImageProviders?: string[];
  MarketplaceProductCodes?: string[];
  ImageNames?: string[];
  DeprecationTimeCondition?: DeprecationTimeCondition;
  CreationDateCondition?: CreationDateCondition;
}
export const ImageCriterion = S.suspend(() =>
  S.Struct({
    ImageProviders: S.optional(ImageProviderList).pipe(
      T.XmlName("imageProviderSet"),
      T.Ec2QueryName("ImageProviderSet"),
    ),
    MarketplaceProductCodes: S.optional(MarketplaceProductCodeList).pipe(
      T.XmlName("marketplaceProductCodeSet"),
      T.Ec2QueryName("MarketplaceProductCodeSet"),
    ),
    ImageNames: S.optional(ImageNameList).pipe(
      T.XmlName("imageNameSet"),
      T.Ec2QueryName("ImageNameSet"),
    ),
    DeprecationTimeCondition: S.optional(DeprecationTimeCondition)
      .pipe(
        T.XmlName("deprecationTimeCondition"),
        T.Ec2QueryName("DeprecationTimeCondition"),
      )
      .annotate({ identifier: "DeprecationTimeCondition" }),
    CreationDateCondition: S.optional(CreationDateCondition)
      .pipe(
        T.XmlName("creationDateCondition"),
        T.Ec2QueryName("CreationDateCondition"),
      )
      .annotate({ identifier: "CreationDateCondition" }),
  }),
).annotate({ identifier: "ImageCriterion" }) as any as S.Schema<ImageCriterion>;
export type ImageCriterionList = ImageCriterion[];
export const ImageCriterionList = S.Array(
  ImageCriterion.pipe(T.XmlName("item")).annotate({
    identifier: "ImageCriterion",
  }),
);
export interface GetAllowedImagesSettingsResult {
  State?: string;
  ImageCriteria?: ImageCriterion[];
  ManagedBy?: ManagedBy;
}
export const GetAllowedImagesSettingsResult = S.suspend(() =>
  S.Struct({
    State: S.optional(S.String).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    ImageCriteria: S.optional(ImageCriterionList).pipe(
      T.XmlName("imageCriterionSet"),
      T.Ec2QueryName("ImageCriterionSet"),
    ),
    ManagedBy: S.optional(ManagedBy).pipe(
      T.XmlName("managedBy"),
      T.Ec2QueryName("ManagedBy"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetAllowedImagesSettingsResult",
}) as any as S.Schema<GetAllowedImagesSettingsResult>;
export interface GetAssociatedEnclaveCertificateIamRolesRequest {
  CertificateArn?: string;
  DryRun?: boolean;
}
export const GetAssociatedEnclaveCertificateIamRolesRequest = S.suspend(() =>
  S.Struct({
    CertificateArn: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetAssociatedEnclaveCertificateIamRolesRequest",
}) as any as S.Schema<GetAssociatedEnclaveCertificateIamRolesRequest>;
export interface AssociatedRole {
  AssociatedRoleArn?: string;
  CertificateS3BucketName?: string;
  CertificateS3ObjectKey?: string;
  EncryptionKmsKeyId?: string;
}
export const AssociatedRole = S.suspend(() =>
  S.Struct({
    AssociatedRoleArn: S.optional(S.String).pipe(
      T.XmlName("associatedRoleArn"),
      T.Ec2QueryName("AssociatedRoleArn"),
    ),
    CertificateS3BucketName: S.optional(S.String).pipe(
      T.XmlName("certificateS3BucketName"),
      T.Ec2QueryName("CertificateS3BucketName"),
    ),
    CertificateS3ObjectKey: S.optional(S.String).pipe(
      T.XmlName("certificateS3ObjectKey"),
      T.Ec2QueryName("CertificateS3ObjectKey"),
    ),
    EncryptionKmsKeyId: S.optional(S.String).pipe(
      T.XmlName("encryptionKmsKeyId"),
      T.Ec2QueryName("EncryptionKmsKeyId"),
    ),
  }),
).annotate({ identifier: "AssociatedRole" }) as any as S.Schema<AssociatedRole>;
export type AssociatedRolesList = AssociatedRole[];
export const AssociatedRolesList = S.Array(
  AssociatedRole.pipe(T.XmlName("item")).annotate({
    identifier: "AssociatedRole",
  }),
);
export interface GetAssociatedEnclaveCertificateIamRolesResult {
  AssociatedRoles?: AssociatedRole[];
}
export const GetAssociatedEnclaveCertificateIamRolesResult = S.suspend(() =>
  S.Struct({
    AssociatedRoles: S.optional(AssociatedRolesList).pipe(
      T.XmlName("associatedRoleSet"),
      T.Ec2QueryName("AssociatedRoleSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetAssociatedEnclaveCertificateIamRolesResult",
}) as any as S.Schema<GetAssociatedEnclaveCertificateIamRolesResult>;
export interface GetAssociatedIpv6PoolCidrsRequest {
  PoolId?: string;
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
}
export const GetAssociatedIpv6PoolCidrsRequest = S.suspend(() =>
  S.Struct({
    PoolId: S.optional(S.String),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetAssociatedIpv6PoolCidrsRequest",
}) as any as S.Schema<GetAssociatedIpv6PoolCidrsRequest>;
export interface Ipv6CidrAssociation {
  Ipv6Cidr?: string;
  AssociatedResource?: string;
}
export const Ipv6CidrAssociation = S.suspend(() =>
  S.Struct({
    Ipv6Cidr: S.optional(S.String).pipe(
      T.XmlName("ipv6Cidr"),
      T.Ec2QueryName("Ipv6Cidr"),
    ),
    AssociatedResource: S.optional(S.String).pipe(
      T.XmlName("associatedResource"),
      T.Ec2QueryName("AssociatedResource"),
    ),
  }),
).annotate({
  identifier: "Ipv6CidrAssociation",
}) as any as S.Schema<Ipv6CidrAssociation>;
export type Ipv6CidrAssociationSet = Ipv6CidrAssociation[];
export const Ipv6CidrAssociationSet = S.Array(
  Ipv6CidrAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "Ipv6CidrAssociation",
  }),
);
export interface GetAssociatedIpv6PoolCidrsResult {
  Ipv6CidrAssociations?: Ipv6CidrAssociation[];
  NextToken?: string;
}
export const GetAssociatedIpv6PoolCidrsResult = S.suspend(() =>
  S.Struct({
    Ipv6CidrAssociations: S.optional(Ipv6CidrAssociationSet).pipe(
      T.XmlName("ipv6CidrAssociationSet"),
      T.Ec2QueryName("Ipv6CidrAssociationSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetAssociatedIpv6PoolCidrsResult",
}) as any as S.Schema<GetAssociatedIpv6PoolCidrsResult>;
export interface DataQuery {
  Id?: string;
  Source?: string;
  Destination?: string;
  Metric?: MetricType;
  Statistic?: StatisticType;
  Period?: PeriodType;
}
export const DataQuery = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Source: S.optional(S.String),
    Destination: S.optional(S.String),
    Metric: S.optional(MetricType),
    Statistic: S.optional(StatisticType),
    Period: S.optional(PeriodType),
  }),
).annotate({ identifier: "DataQuery" }) as any as S.Schema<DataQuery>;
export type DataQueries = DataQuery[];
export const DataQueries = S.Array(DataQuery);
export interface GetAwsNetworkPerformanceDataRequest {
  DataQueries?: DataQuery[];
  StartTime?: Date;
  EndTime?: Date;
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const GetAwsNetworkPerformanceDataRequest = S.suspend(() =>
  S.Struct({
    DataQueries: S.optional(DataQueries).pipe(T.XmlName("DataQuery")),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    EndTime: S.optional(T.DateFromString.pipe(T.TimestampFormat("date-time"))),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetAwsNetworkPerformanceDataRequest",
}) as any as S.Schema<GetAwsNetworkPerformanceDataRequest>;
export interface MetricPoint {
  StartDate?: Date;
  EndDate?: Date;
  Value?: number;
  Status?: string;
}
export const MetricPoint = S.suspend(() =>
  S.Struct({
    StartDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startDate"), T.Ec2QueryName("StartDate")),
    EndDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("endDate"), T.Ec2QueryName("EndDate")),
    Value: S.optional(S.Number).pipe(
      T.XmlName("value"),
      T.Ec2QueryName("Value"),
    ),
    Status: S.optional(S.String).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
  }),
).annotate({ identifier: "MetricPoint" }) as any as S.Schema<MetricPoint>;
export type MetricPoints = MetricPoint[];
export const MetricPoints = S.Array(
  MetricPoint.pipe(T.XmlName("item")).annotate({ identifier: "MetricPoint" }),
);
export interface DataResponse {
  Id?: string;
  Source?: string;
  Destination?: string;
  Metric?: MetricType;
  Statistic?: StatisticType;
  Period?: PeriodType;
  MetricPoints?: MetricPoint[];
}
export const DataResponse = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String).pipe(T.XmlName("id"), T.Ec2QueryName("Id")),
    Source: S.optional(S.String).pipe(
      T.XmlName("source"),
      T.Ec2QueryName("Source"),
    ),
    Destination: S.optional(S.String).pipe(
      T.XmlName("destination"),
      T.Ec2QueryName("Destination"),
    ),
    Metric: S.optional(MetricType).pipe(
      T.XmlName("metric"),
      T.Ec2QueryName("Metric"),
    ),
    Statistic: S.optional(StatisticType).pipe(
      T.XmlName("statistic"),
      T.Ec2QueryName("Statistic"),
    ),
    Period: S.optional(PeriodType).pipe(
      T.XmlName("period"),
      T.Ec2QueryName("Period"),
    ),
    MetricPoints: S.optional(MetricPoints).pipe(
      T.XmlName("metricPointSet"),
      T.Ec2QueryName("MetricPointSet"),
    ),
  }),
).annotate({ identifier: "DataResponse" }) as any as S.Schema<DataResponse>;
export type DataResponses = DataResponse[];
export const DataResponses = S.Array(
  DataResponse.pipe(T.XmlName("item")).annotate({ identifier: "DataResponse" }),
);
export interface GetAwsNetworkPerformanceDataResult {
  DataResponses?: DataResponse[];
  NextToken?: string;
}
export const GetAwsNetworkPerformanceDataResult = S.suspend(() =>
  S.Struct({
    DataResponses: S.optional(DataResponses).pipe(
      T.XmlName("dataResponseSet"),
      T.Ec2QueryName("DataResponseSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetAwsNetworkPerformanceDataResult",
}) as any as S.Schema<GetAwsNetworkPerformanceDataResult>;
export interface GetCapacityManagerAttributesRequest {
  DryRun?: boolean;
}
export const GetCapacityManagerAttributesRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetCapacityManagerAttributesRequest",
}) as any as S.Schema<GetCapacityManagerAttributesRequest>;
export type IngestionStatus =
  | "initial-ingestion-in-progress"
  | "ingestion-complete"
  | "ingestion-failed"
  | (string & {});
export const IngestionStatus = S.String;
export interface GetCapacityManagerAttributesResult {
  CapacityManagerStatus?: CapacityManagerStatus;
  OrganizationsAccess?: boolean;
  DataExportCount?: number;
  IngestionStatus?: IngestionStatus;
  IngestionStatusMessage?: string;
  EarliestDatapointTimestamp?: Date;
  LatestDatapointTimestamp?: Date;
}
export const GetCapacityManagerAttributesResult = S.suspend(() =>
  S.Struct({
    CapacityManagerStatus: S.optional(CapacityManagerStatus).pipe(
      T.XmlName("capacityManagerStatus"),
      T.Ec2QueryName("CapacityManagerStatus"),
    ),
    OrganizationsAccess: S.optional(S.Boolean).pipe(
      T.XmlName("organizationsAccess"),
      T.Ec2QueryName("OrganizationsAccess"),
    ),
    DataExportCount: S.optional(S.Number).pipe(
      T.XmlName("dataExportCount"),
      T.Ec2QueryName("DataExportCount"),
    ),
    IngestionStatus: S.optional(IngestionStatus).pipe(
      T.XmlName("ingestionStatus"),
      T.Ec2QueryName("IngestionStatus"),
    ),
    IngestionStatusMessage: S.optional(S.String).pipe(
      T.XmlName("ingestionStatusMessage"),
      T.Ec2QueryName("IngestionStatusMessage"),
    ),
    EarliestDatapointTimestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("earliestDatapointTimestamp"),
      T.Ec2QueryName("EarliestDatapointTimestamp"),
    ),
    LatestDatapointTimestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("latestDatapointTimestamp"),
      T.Ec2QueryName("LatestDatapointTimestamp"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetCapacityManagerAttributesResult",
}) as any as S.Schema<GetCapacityManagerAttributesResult>;
export type Metric =
  | "reservation-total-capacity-hrs-vcpu"
  | "reservation-total-capacity-hrs-inst"
  | "reservation-max-size-vcpu"
  | "reservation-max-size-inst"
  | "reservation-min-size-vcpu"
  | "reservation-min-size-inst"
  | "reservation-unused-total-capacity-hrs-vcpu"
  | "reservation-unused-total-capacity-hrs-inst"
  | "reservation-unused-total-estimated-cost"
  | "reservation-max-unused-size-vcpu"
  | "reservation-max-unused-size-inst"
  | "reservation-min-unused-size-vcpu"
  | "reservation-min-unused-size-inst"
  | "reservation-max-utilization"
  | "reservation-min-utilization"
  | "reservation-avg-utilization-vcpu"
  | "reservation-avg-utilization-inst"
  | "reservation-total-count"
  | "reservation-total-estimated-cost"
  | "reservation-avg-future-size-vcpu"
  | "reservation-avg-future-size-inst"
  | "reservation-min-future-size-vcpu"
  | "reservation-min-future-size-inst"
  | "reservation-max-future-size-vcpu"
  | "reservation-max-future-size-inst"
  | "reservation-avg-committed-size-vcpu"
  | "reservation-avg-committed-size-inst"
  | "reservation-max-committed-size-vcpu"
  | "reservation-max-committed-size-inst"
  | "reservation-min-committed-size-vcpu"
  | "reservation-min-committed-size-inst"
  | "reserved-total-usage-hrs-vcpu"
  | "reserved-total-usage-hrs-inst"
  | "reserved-total-estimated-cost"
  | "unreserved-total-usage-hrs-vcpu"
  | "unreserved-total-usage-hrs-inst"
  | "unreserved-total-estimated-cost"
  | "spot-total-usage-hrs-vcpu"
  | "spot-total-usage-hrs-inst"
  | "spot-total-estimated-cost"
  | "spot-avg-run-time-before-interruption-inst"
  | "spot-max-run-time-before-interruption-inst"
  | "spot-min-run-time-before-interruption-inst"
  | "spot-total-interruptions-inst"
  | "spot-total-interruptions-vcpu"
  | "spot-total-count-inst"
  | "spot-total-count-vcpu"
  | "spot-interruption-rate-inst"
  | "spot-interruption-rate-vcpu"
  | (string & {});
export const Metric = S.String;
export type MetricSet = Metric[];
export const MetricSet = S.Array(Metric.pipe(T.XmlName("item")));
export type GroupBy =
  | "resource-region"
  | "availability-zone-id"
  | "account-id"
  | "instance-family"
  | "instance-type"
  | "instance-platform"
  | "reservation-arn"
  | "reservation-id"
  | "reservation-type"
  | "reservation-create-timestamp"
  | "reservation-start-timestamp"
  | "reservation-end-timestamp"
  | "reservation-end-date-type"
  | "tenancy"
  | "reservation-state"
  | "reservation-instance-match-criteria"
  | "reservation-unused-financial-owner"
  | (string & {});
export const GroupBy = S.String;
export type GroupBySet = GroupBy[];
export const GroupBySet = S.Array(GroupBy.pipe(T.XmlName("item")));
export type FilterByDimension =
  | "resource-region"
  | "availability-zone-id"
  | "account-id"
  | "instance-family"
  | "instance-type"
  | "instance-platform"
  | "reservation-arn"
  | "reservation-id"
  | "reservation-type"
  | "reservation-create-timestamp"
  | "reservation-start-timestamp"
  | "reservation-end-timestamp"
  | "reservation-end-date-type"
  | "tenancy"
  | "reservation-state"
  | "reservation-instance-match-criteria"
  | "reservation-unused-financial-owner"
  | (string & {});
export const FilterByDimension = S.String;
export type Comparison = "equals" | "in" | (string & {});
export const Comparison = S.String;
export type ConditionValueList = string[];
export const ConditionValueList = S.Array(S.String.pipe(T.XmlName("item")));
export interface DimensionCondition {
  Dimension?: FilterByDimension;
  Comparison?: Comparison;
  Values?: string[];
}
export const DimensionCondition = S.suspend(() =>
  S.Struct({
    Dimension: S.optional(FilterByDimension),
    Comparison: S.optional(Comparison),
    Values: S.optional(ConditionValueList).pipe(T.XmlName("Value")),
  }),
).annotate({
  identifier: "DimensionCondition",
}) as any as S.Schema<DimensionCondition>;
export interface CapacityManagerCondition {
  DimensionCondition?: DimensionCondition;
}
export const CapacityManagerCondition = S.suspend(() =>
  S.Struct({ DimensionCondition: S.optional(DimensionCondition) }),
).annotate({
  identifier: "CapacityManagerCondition",
}) as any as S.Schema<CapacityManagerCondition>;
export type CapacityManagerConditionSet = CapacityManagerCondition[];
export const CapacityManagerConditionSet = S.Array(
  CapacityManagerCondition.pipe(T.XmlName("item")).annotate({
    identifier: "CapacityManagerCondition",
  }),
);
export interface GetCapacityManagerMetricDataRequest {
  MetricNames?: Metric[];
  StartTime?: Date;
  EndTime?: Date;
  Period?: number;
  GroupBy?: GroupBy[];
  FilterBy?: CapacityManagerCondition[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const GetCapacityManagerMetricDataRequest = S.suspend(() =>
  S.Struct({
    MetricNames: S.optional(MetricSet).pipe(T.XmlName("MetricName")),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    EndTime: S.optional(T.DateFromString.pipe(T.TimestampFormat("date-time"))),
    Period: S.optional(S.Number),
    GroupBy: S.optional(GroupBySet).pipe(T.XmlName("GroupBy")),
    FilterBy: S.optional(CapacityManagerConditionSet),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetCapacityManagerMetricDataRequest",
}) as any as S.Schema<GetCapacityManagerMetricDataRequest>;
export type ReservationType = "capacity-block" | "odcr" | (string & {});
export const ReservationType = S.String;
export type ReservationEndDateType = "limited" | "unlimited" | (string & {});
export const ReservationEndDateType = S.String;
export type CapacityTenancy = "default" | "dedicated" | (string & {});
export const CapacityTenancy = S.String;
export interface CapacityManagerDimension {
  ResourceRegion?: string;
  AvailabilityZoneId?: string;
  AccountId?: string;
  InstanceFamily?: string;
  InstanceType?: string;
  InstancePlatform?: string;
  ReservationArn?: string;
  ReservationId?: string;
  ReservationType?: ReservationType;
  ReservationCreateTimestamp?: Date;
  ReservationStartTimestamp?: Date;
  ReservationEndTimestamp?: Date;
  ReservationEndDateType?: ReservationEndDateType;
  Tenancy?: CapacityTenancy;
  ReservationState?: ReservationState;
  ReservationInstanceMatchCriteria?: string;
  ReservationUnusedFinancialOwner?: string;
}
export const CapacityManagerDimension = S.suspend(() =>
  S.Struct({
    ResourceRegion: S.optional(S.String).pipe(
      T.XmlName("resourceRegion"),
      T.Ec2QueryName("ResourceRegion"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    AccountId: S.optional(S.String).pipe(
      T.XmlName("accountId"),
      T.Ec2QueryName("AccountId"),
    ),
    InstanceFamily: S.optional(S.String).pipe(
      T.XmlName("instanceFamily"),
      T.Ec2QueryName("InstanceFamily"),
    ),
    InstanceType: S.optional(S.String).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    InstancePlatform: S.optional(S.String).pipe(
      T.XmlName("instancePlatform"),
      T.Ec2QueryName("InstancePlatform"),
    ),
    ReservationArn: S.optional(S.String).pipe(
      T.XmlName("reservationArn"),
      T.Ec2QueryName("ReservationArn"),
    ),
    ReservationId: S.optional(S.String).pipe(
      T.XmlName("reservationId"),
      T.Ec2QueryName("ReservationId"),
    ),
    ReservationType: S.optional(ReservationType).pipe(
      T.XmlName("reservationType"),
      T.Ec2QueryName("ReservationType"),
    ),
    ReservationCreateTimestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("reservationCreateTimestamp"),
      T.Ec2QueryName("ReservationCreateTimestamp"),
    ),
    ReservationStartTimestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("reservationStartTimestamp"),
      T.Ec2QueryName("ReservationStartTimestamp"),
    ),
    ReservationEndTimestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("reservationEndTimestamp"),
      T.Ec2QueryName("ReservationEndTimestamp"),
    ),
    ReservationEndDateType: S.optional(ReservationEndDateType).pipe(
      T.XmlName("reservationEndDateType"),
      T.Ec2QueryName("ReservationEndDateType"),
    ),
    Tenancy: S.optional(CapacityTenancy).pipe(
      T.XmlName("tenancy"),
      T.Ec2QueryName("Tenancy"),
    ),
    ReservationState: S.optional(ReservationState).pipe(
      T.XmlName("reservationState"),
      T.Ec2QueryName("ReservationState"),
    ),
    ReservationInstanceMatchCriteria: S.optional(S.String).pipe(
      T.XmlName("reservationInstanceMatchCriteria"),
      T.Ec2QueryName("ReservationInstanceMatchCriteria"),
    ),
    ReservationUnusedFinancialOwner: S.optional(S.String).pipe(
      T.XmlName("reservationUnusedFinancialOwner"),
      T.Ec2QueryName("ReservationUnusedFinancialOwner"),
    ),
  }),
).annotate({
  identifier: "CapacityManagerDimension",
}) as any as S.Schema<CapacityManagerDimension>;
export interface MetricValue {
  Metric?: Metric;
  Value?: number;
}
export const MetricValue = S.suspend(() =>
  S.Struct({
    Metric: S.optional(Metric).pipe(
      T.XmlName("metric"),
      T.Ec2QueryName("Metric"),
    ),
    Value: S.optional(S.Number).pipe(
      T.XmlName("value"),
      T.Ec2QueryName("Value"),
    ),
  }),
).annotate({ identifier: "MetricValue" }) as any as S.Schema<MetricValue>;
export type MetricValueSet = MetricValue[];
export const MetricValueSet = S.Array(
  MetricValue.pipe(T.XmlName("item")).annotate({ identifier: "MetricValue" }),
);
export interface MetricDataResult {
  Dimension?: CapacityManagerDimension;
  Timestamp?: Date;
  MetricValues?: MetricValue[];
}
export const MetricDataResult = S.suspend(() =>
  S.Struct({
    Dimension: S.optional(CapacityManagerDimension)
      .pipe(T.XmlName("dimension"), T.Ec2QueryName("Dimension"))
      .annotate({ identifier: "CapacityManagerDimension" }),
    Timestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("timestamp"), T.Ec2QueryName("Timestamp")),
    MetricValues: S.optional(MetricValueSet).pipe(
      T.XmlName("metricValueSet"),
      T.Ec2QueryName("MetricValueSet"),
    ),
  }),
).annotate({
  identifier: "MetricDataResult",
}) as any as S.Schema<MetricDataResult>;
export type MetricDataResultSet = MetricDataResult[];
export const MetricDataResultSet = S.Array(
  MetricDataResult.pipe(T.XmlName("item")).annotate({
    identifier: "MetricDataResult",
  }),
);
export interface GetCapacityManagerMetricDataResult {
  MetricDataResults?: MetricDataResult[];
  NextToken?: string;
}
export const GetCapacityManagerMetricDataResult = S.suspend(() =>
  S.Struct({
    MetricDataResults: S.optional(MetricDataResultSet).pipe(
      T.XmlName("metricDataResultSet"),
      T.Ec2QueryName("MetricDataResultSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetCapacityManagerMetricDataResult",
}) as any as S.Schema<GetCapacityManagerMetricDataResult>;
export interface GetCapacityManagerMetricDimensionsRequest {
  GroupBy?: GroupBy[];
  FilterBy?: CapacityManagerCondition[];
  StartTime?: Date;
  EndTime?: Date;
  MetricNames?: Metric[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const GetCapacityManagerMetricDimensionsRequest = S.suspend(() =>
  S.Struct({
    GroupBy: S.optional(GroupBySet).pipe(T.XmlName("GroupBy")),
    FilterBy: S.optional(CapacityManagerConditionSet),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    EndTime: S.optional(T.DateFromString.pipe(T.TimestampFormat("date-time"))),
    MetricNames: S.optional(MetricSet).pipe(T.XmlName("MetricName")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetCapacityManagerMetricDimensionsRequest",
}) as any as S.Schema<GetCapacityManagerMetricDimensionsRequest>;
export type MetricDimensionResultSet = CapacityManagerDimension[];
export const MetricDimensionResultSet = S.Array(
  CapacityManagerDimension.pipe(T.XmlName("item")).annotate({
    identifier: "CapacityManagerDimension",
  }),
);
export interface GetCapacityManagerMetricDimensionsResult {
  MetricDimensionResults?: CapacityManagerDimension[];
  NextToken?: string;
}
export const GetCapacityManagerMetricDimensionsResult = S.suspend(() =>
  S.Struct({
    MetricDimensionResults: S.optional(MetricDimensionResultSet).pipe(
      T.XmlName("metricDimensionResultSet"),
      T.Ec2QueryName("MetricDimensionResultSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetCapacityManagerMetricDimensionsResult",
}) as any as S.Schema<GetCapacityManagerMetricDimensionsResult>;
export interface GetCapacityReservationUsageRequest {
  CapacityReservationId?: string;
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
}
export const GetCapacityReservationUsageRequest = S.suspend(() =>
  S.Struct({
    CapacityReservationId: S.optional(S.String),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetCapacityReservationUsageRequest",
}) as any as S.Schema<GetCapacityReservationUsageRequest>;
export interface InstanceUsage {
  AccountId?: string;
  UsedInstanceCount?: number;
}
export const InstanceUsage = S.suspend(() =>
  S.Struct({
    AccountId: S.optional(S.String).pipe(
      T.XmlName("accountId"),
      T.Ec2QueryName("AccountId"),
    ),
    UsedInstanceCount: S.optional(S.Number).pipe(
      T.XmlName("usedInstanceCount"),
      T.Ec2QueryName("UsedInstanceCount"),
    ),
  }),
).annotate({ identifier: "InstanceUsage" }) as any as S.Schema<InstanceUsage>;
export type InstanceUsageSet = InstanceUsage[];
export const InstanceUsageSet = S.Array(
  InstanceUsage.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceUsage",
  }),
);
export interface GetCapacityReservationUsageResult {
  NextToken?: string;
  CapacityReservationId?: string;
  InstanceType?: string;
  TotalInstanceCount?: number;
  AvailableInstanceCount?: number;
  State?: CapacityReservationState;
  InstanceUsages?: InstanceUsage[];
  Interruptible?: boolean;
  InterruptibleCapacityAllocation?: InterruptibleCapacityAllocation;
  InterruptionInfo?: InterruptionInfo;
}
export const GetCapacityReservationUsageResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    CapacityReservationId: S.optional(S.String).pipe(
      T.XmlName("capacityReservationId"),
      T.Ec2QueryName("CapacityReservationId"),
    ),
    InstanceType: S.optional(S.String).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    TotalInstanceCount: S.optional(S.Number).pipe(
      T.XmlName("totalInstanceCount"),
      T.Ec2QueryName("TotalInstanceCount"),
    ),
    AvailableInstanceCount: S.optional(S.Number).pipe(
      T.XmlName("availableInstanceCount"),
      T.Ec2QueryName("AvailableInstanceCount"),
    ),
    State: S.optional(CapacityReservationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    InstanceUsages: S.optional(InstanceUsageSet).pipe(
      T.XmlName("instanceUsageSet"),
      T.Ec2QueryName("InstanceUsageSet"),
    ),
    Interruptible: S.optional(S.Boolean).pipe(
      T.XmlName("interruptible"),
      T.Ec2QueryName("Interruptible"),
    ),
    InterruptibleCapacityAllocation: S.optional(InterruptibleCapacityAllocation)
      .pipe(
        T.XmlName("interruptibleCapacityAllocation"),
        T.Ec2QueryName("InterruptibleCapacityAllocation"),
      )
      .annotate({ identifier: "InterruptibleCapacityAllocation" }),
    InterruptionInfo: S.optional(InterruptionInfo)
      .pipe(T.XmlName("interruptionInfo"), T.Ec2QueryName("InterruptionInfo"))
      .annotate({ identifier: "InterruptionInfo" }),
  }).pipe(ns),
).annotate({
  identifier: "GetCapacityReservationUsageResult",
}) as any as S.Schema<GetCapacityReservationUsageResult>;
export interface GetCoipPoolUsageRequest {
  PoolId?: string;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const GetCoipPoolUsageRequest = S.suspend(() =>
  S.Struct({
    PoolId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetCoipPoolUsageRequest",
}) as any as S.Schema<GetCoipPoolUsageRequest>;
export interface CoipAddressUsage {
  AllocationId?: string;
  AwsAccountId?: string;
  AwsService?: string;
  CoIp?: string;
}
export const CoipAddressUsage = S.suspend(() =>
  S.Struct({
    AllocationId: S.optional(S.String).pipe(
      T.XmlName("allocationId"),
      T.Ec2QueryName("AllocationId"),
    ),
    AwsAccountId: S.optional(S.String).pipe(
      T.XmlName("awsAccountId"),
      T.Ec2QueryName("AwsAccountId"),
    ),
    AwsService: S.optional(S.String).pipe(
      T.XmlName("awsService"),
      T.Ec2QueryName("AwsService"),
    ),
    CoIp: S.optional(S.String).pipe(T.XmlName("coIp"), T.Ec2QueryName("CoIp")),
  }),
).annotate({
  identifier: "CoipAddressUsage",
}) as any as S.Schema<CoipAddressUsage>;
export type CoipAddressUsageSet = CoipAddressUsage[];
export const CoipAddressUsageSet = S.Array(
  CoipAddressUsage.pipe(T.XmlName("item")).annotate({
    identifier: "CoipAddressUsage",
  }),
);
export interface GetCoipPoolUsageResult {
  CoipPoolId?: string;
  CoipAddressUsages?: CoipAddressUsage[];
  LocalGatewayRouteTableId?: string;
  NextToken?: string;
}
export const GetCoipPoolUsageResult = S.suspend(() =>
  S.Struct({
    CoipPoolId: S.optional(S.String).pipe(
      T.XmlName("coipPoolId"),
      T.Ec2QueryName("CoipPoolId"),
    ),
    CoipAddressUsages: S.optional(CoipAddressUsageSet).pipe(
      T.XmlName("coipAddressUsageSet"),
      T.Ec2QueryName("CoipAddressUsageSet"),
    ),
    LocalGatewayRouteTableId: S.optional(S.String).pipe(
      T.XmlName("localGatewayRouteTableId"),
      T.Ec2QueryName("LocalGatewayRouteTableId"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetCoipPoolUsageResult",
}) as any as S.Schema<GetCoipPoolUsageResult>;
export interface GetConsoleOutputRequest {
  InstanceId?: string;
  Latest?: boolean;
  DryRun?: boolean;
}
export const GetConsoleOutputRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    Latest: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetConsoleOutputRequest",
}) as any as S.Schema<GetConsoleOutputRequest>;
export interface GetConsoleOutputResult {
  InstanceId?: string;
  Timestamp?: Date;
  Output?: string;
}
export const GetConsoleOutputResult = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    Timestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("timestamp"), T.Ec2QueryName("Timestamp")),
    Output: S.optional(S.String).pipe(
      T.XmlName("output"),
      T.Ec2QueryName("Output"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetConsoleOutputResult",
}) as any as S.Schema<GetConsoleOutputResult>;
export interface GetConsoleScreenshotRequest {
  DryRun?: boolean;
  InstanceId?: string;
  WakeUp?: boolean;
}
export const GetConsoleScreenshotRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    InstanceId: S.optional(S.String),
    WakeUp: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetConsoleScreenshotRequest",
}) as any as S.Schema<GetConsoleScreenshotRequest>;
export interface GetConsoleScreenshotResult {
  ImageData?: string;
  InstanceId?: string;
}
export const GetConsoleScreenshotResult = S.suspend(() =>
  S.Struct({
    ImageData: S.optional(S.String).pipe(
      T.XmlName("imageData"),
      T.Ec2QueryName("ImageData"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetConsoleScreenshotResult",
}) as any as S.Schema<GetConsoleScreenshotResult>;
export interface GetDeclarativePoliciesReportSummaryRequest {
  DryRun?: boolean;
  ReportId?: string;
}
export const GetDeclarativePoliciesReportSummaryRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ReportId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetDeclarativePoliciesReportSummaryRequest",
}) as any as S.Schema<GetDeclarativePoliciesReportSummaryRequest>;
export interface RegionalSummary {
  RegionName?: string;
  NumberOfMatchedAccounts?: number;
  NumberOfUnmatchedAccounts?: number;
}
export const RegionalSummary = S.suspend(() =>
  S.Struct({
    RegionName: S.optional(S.String).pipe(
      T.XmlName("regionName"),
      T.Ec2QueryName("RegionName"),
    ),
    NumberOfMatchedAccounts: S.optional(S.Number).pipe(
      T.XmlName("numberOfMatchedAccounts"),
      T.Ec2QueryName("NumberOfMatchedAccounts"),
    ),
    NumberOfUnmatchedAccounts: S.optional(S.Number).pipe(
      T.XmlName("numberOfUnmatchedAccounts"),
      T.Ec2QueryName("NumberOfUnmatchedAccounts"),
    ),
  }),
).annotate({
  identifier: "RegionalSummary",
}) as any as S.Schema<RegionalSummary>;
export type RegionalSummaryList = RegionalSummary[];
export const RegionalSummaryList = S.Array(
  RegionalSummary.pipe(T.XmlName("item")).annotate({
    identifier: "RegionalSummary",
  }),
);
export interface AttributeSummary {
  AttributeName?: string;
  MostFrequentValue?: string;
  NumberOfMatchedAccounts?: number;
  NumberOfUnmatchedAccounts?: number;
  RegionalSummaries?: RegionalSummary[];
}
export const AttributeSummary = S.suspend(() =>
  S.Struct({
    AttributeName: S.optional(S.String).pipe(
      T.XmlName("attributeName"),
      T.Ec2QueryName("AttributeName"),
    ),
    MostFrequentValue: S.optional(S.String).pipe(
      T.XmlName("mostFrequentValue"),
      T.Ec2QueryName("MostFrequentValue"),
    ),
    NumberOfMatchedAccounts: S.optional(S.Number).pipe(
      T.XmlName("numberOfMatchedAccounts"),
      T.Ec2QueryName("NumberOfMatchedAccounts"),
    ),
    NumberOfUnmatchedAccounts: S.optional(S.Number).pipe(
      T.XmlName("numberOfUnmatchedAccounts"),
      T.Ec2QueryName("NumberOfUnmatchedAccounts"),
    ),
    RegionalSummaries: S.optional(RegionalSummaryList).pipe(
      T.XmlName("regionalSummarySet"),
      T.Ec2QueryName("RegionalSummarySet"),
    ),
  }),
).annotate({
  identifier: "AttributeSummary",
}) as any as S.Schema<AttributeSummary>;
export type AttributeSummaryList = AttributeSummary[];
export const AttributeSummaryList = S.Array(
  AttributeSummary.pipe(T.XmlName("item")).annotate({
    identifier: "AttributeSummary",
  }),
);
export interface GetDeclarativePoliciesReportSummaryResult {
  ReportId?: string;
  S3Bucket?: string;
  S3Prefix?: string;
  TargetId?: string;
  StartTime?: Date;
  EndTime?: Date;
  NumberOfAccounts?: number;
  NumberOfFailedAccounts?: number;
  AttributeSummaries?: AttributeSummary[];
}
export const GetDeclarativePoliciesReportSummaryResult = S.suspend(() =>
  S.Struct({
    ReportId: S.optional(S.String).pipe(
      T.XmlName("reportId"),
      T.Ec2QueryName("ReportId"),
    ),
    S3Bucket: S.optional(S.String).pipe(
      T.XmlName("s3Bucket"),
      T.Ec2QueryName("S3Bucket"),
    ),
    S3Prefix: S.optional(S.String).pipe(
      T.XmlName("s3Prefix"),
      T.Ec2QueryName("S3Prefix"),
    ),
    TargetId: S.optional(S.String).pipe(
      T.XmlName("targetId"),
      T.Ec2QueryName("TargetId"),
    ),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startTime"), T.Ec2QueryName("StartTime")),
    EndTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("endTime"), T.Ec2QueryName("EndTime")),
    NumberOfAccounts: S.optional(S.Number).pipe(
      T.XmlName("numberOfAccounts"),
      T.Ec2QueryName("NumberOfAccounts"),
    ),
    NumberOfFailedAccounts: S.optional(S.Number).pipe(
      T.XmlName("numberOfFailedAccounts"),
      T.Ec2QueryName("NumberOfFailedAccounts"),
    ),
    AttributeSummaries: S.optional(AttributeSummaryList).pipe(
      T.XmlName("attributeSummarySet"),
      T.Ec2QueryName("AttributeSummarySet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetDeclarativePoliciesReportSummaryResult",
}) as any as S.Schema<GetDeclarativePoliciesReportSummaryResult>;
export type UnlimitedSupportedInstanceFamily =
  | "t2"
  | "t3"
  | "t3a"
  | "t4g"
  | (string & {});
export const UnlimitedSupportedInstanceFamily = S.String;
export interface GetDefaultCreditSpecificationRequest {
  DryRun?: boolean;
  InstanceFamily?: UnlimitedSupportedInstanceFamily;
}
export const GetDefaultCreditSpecificationRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    InstanceFamily: S.optional(UnlimitedSupportedInstanceFamily),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetDefaultCreditSpecificationRequest",
}) as any as S.Schema<GetDefaultCreditSpecificationRequest>;
export interface InstanceFamilyCreditSpecification {
  InstanceFamily?: UnlimitedSupportedInstanceFamily;
  CpuCredits?: string;
}
export const InstanceFamilyCreditSpecification = S.suspend(() =>
  S.Struct({
    InstanceFamily: S.optional(UnlimitedSupportedInstanceFamily).pipe(
      T.XmlName("instanceFamily"),
      T.Ec2QueryName("InstanceFamily"),
    ),
    CpuCredits: S.optional(S.String).pipe(
      T.XmlName("cpuCredits"),
      T.Ec2QueryName("CpuCredits"),
    ),
  }),
).annotate({
  identifier: "InstanceFamilyCreditSpecification",
}) as any as S.Schema<InstanceFamilyCreditSpecification>;
export interface GetDefaultCreditSpecificationResult {
  InstanceFamilyCreditSpecification?: InstanceFamilyCreditSpecification;
}
export const GetDefaultCreditSpecificationResult = S.suspend(() =>
  S.Struct({
    InstanceFamilyCreditSpecification: S.optional(
      InstanceFamilyCreditSpecification,
    )
      .pipe(
        T.XmlName("instanceFamilyCreditSpecification"),
        T.Ec2QueryName("InstanceFamilyCreditSpecification"),
      )
      .annotate({ identifier: "InstanceFamilyCreditSpecification" }),
  }).pipe(ns),
).annotate({
  identifier: "GetDefaultCreditSpecificationResult",
}) as any as S.Schema<GetDefaultCreditSpecificationResult>;
export interface GetEbsDefaultKmsKeyIdRequest {
  DryRun?: boolean;
}
export const GetEbsDefaultKmsKeyIdRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetEbsDefaultKmsKeyIdRequest",
}) as any as S.Schema<GetEbsDefaultKmsKeyIdRequest>;
export interface GetEbsDefaultKmsKeyIdResult {
  KmsKeyId?: string;
}
export const GetEbsDefaultKmsKeyIdResult = S.suspend(() =>
  S.Struct({
    KmsKeyId: S.optional(S.String).pipe(
      T.XmlName("kmsKeyId"),
      T.Ec2QueryName("KmsKeyId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetEbsDefaultKmsKeyIdResult",
}) as any as S.Schema<GetEbsDefaultKmsKeyIdResult>;
export interface GetEbsEncryptionByDefaultRequest {
  DryRun?: boolean;
}
export const GetEbsEncryptionByDefaultRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetEbsEncryptionByDefaultRequest",
}) as any as S.Schema<GetEbsEncryptionByDefaultRequest>;
export interface GetEbsEncryptionByDefaultResult {
  EbsEncryptionByDefault?: boolean;
  SseType?: SSEType;
}
export const GetEbsEncryptionByDefaultResult = S.suspend(() =>
  S.Struct({
    EbsEncryptionByDefault: S.optional(S.Boolean).pipe(
      T.XmlName("ebsEncryptionByDefault"),
      T.Ec2QueryName("EbsEncryptionByDefault"),
    ),
    SseType: S.optional(SSEType).pipe(
      T.XmlName("sseType"),
      T.Ec2QueryName("SseType"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetEbsEncryptionByDefaultResult",
}) as any as S.Schema<GetEbsEncryptionByDefaultResult>;
export interface GetEnabledIpamPolicyRequest {
  DryRun?: boolean;
}
export const GetEnabledIpamPolicyRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetEnabledIpamPolicyRequest",
}) as any as S.Schema<GetEnabledIpamPolicyRequest>;
export type IpamPolicyManagedBy =
  | "account"
  | "delegated-administrator-for-ipam"
  | (string & {});
export const IpamPolicyManagedBy = S.String;
export interface GetEnabledIpamPolicyResult {
  IpamPolicyEnabled?: boolean;
  IpamPolicyId?: string;
  ManagedBy?: IpamPolicyManagedBy;
}
export const GetEnabledIpamPolicyResult = S.suspend(() =>
  S.Struct({
    IpamPolicyEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("ipamPolicyEnabled"),
      T.Ec2QueryName("IpamPolicyEnabled"),
    ),
    IpamPolicyId: S.optional(S.String).pipe(
      T.XmlName("ipamPolicyId"),
      T.Ec2QueryName("IpamPolicyId"),
    ),
    ManagedBy: S.optional(IpamPolicyManagedBy).pipe(
      T.XmlName("managedBy"),
      T.Ec2QueryName("ManagedBy"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetEnabledIpamPolicyResult",
}) as any as S.Schema<GetEnabledIpamPolicyResult>;
export type PartitionLoadFrequency =
  | "none"
  | "daily"
  | "weekly"
  | "monthly"
  | (string & {});
export const PartitionLoadFrequency = S.String;
export interface AthenaIntegration {
  IntegrationResultS3DestinationArn?: string;
  PartitionLoadFrequency?: PartitionLoadFrequency;
  PartitionStartDate?: Date;
  PartitionEndDate?: Date;
}
export const AthenaIntegration = S.suspend(() =>
  S.Struct({
    IntegrationResultS3DestinationArn: S.optional(S.String),
    PartitionLoadFrequency: S.optional(PartitionLoadFrequency),
    PartitionStartDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    PartitionEndDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
  }),
).annotate({
  identifier: "AthenaIntegration",
}) as any as S.Schema<AthenaIntegration>;
export type AthenaIntegrationsSet = AthenaIntegration[];
export const AthenaIntegrationsSet = S.Array(
  AthenaIntegration.pipe(T.XmlName("item")).annotate({
    identifier: "AthenaIntegration",
  }),
);
export interface IntegrateServices {
  AthenaIntegrations?: AthenaIntegration[];
}
export const IntegrateServices = S.suspend(() =>
  S.Struct({
    AthenaIntegrations: S.optional(AthenaIntegrationsSet).pipe(
      T.XmlName("AthenaIntegration"),
    ),
  }),
).annotate({
  identifier: "IntegrateServices",
}) as any as S.Schema<IntegrateServices>;
export interface GetFlowLogsIntegrationTemplateRequest {
  DryRun?: boolean;
  FlowLogId?: string;
  ConfigDeliveryS3DestinationArn?: string;
  IntegrateServices?: IntegrateServices;
}
export const GetFlowLogsIntegrationTemplateRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    FlowLogId: S.optional(S.String),
    ConfigDeliveryS3DestinationArn: S.optional(S.String),
    IntegrateServices: S.optional(IntegrateServices)
      .pipe(T.XmlName("IntegrateService"))
      .annotate({ identifier: "IntegrateServices" }),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetFlowLogsIntegrationTemplateRequest",
}) as any as S.Schema<GetFlowLogsIntegrationTemplateRequest>;
export interface GetFlowLogsIntegrationTemplateResult {
  Result?: string;
}
export const GetFlowLogsIntegrationTemplateResult = S.suspend(() =>
  S.Struct({
    Result: S.optional(S.String).pipe(
      T.XmlName("result"),
      T.Ec2QueryName("Result"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetFlowLogsIntegrationTemplateResult",
}) as any as S.Schema<GetFlowLogsIntegrationTemplateResult>;
export interface GetGroupsForCapacityReservationRequest {
  CapacityReservationId?: string;
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
}
export const GetGroupsForCapacityReservationRequest = S.suspend(() =>
  S.Struct({
    CapacityReservationId: S.optional(S.String),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetGroupsForCapacityReservationRequest",
}) as any as S.Schema<GetGroupsForCapacityReservationRequest>;
export interface CapacityReservationGroup {
  GroupArn?: string;
  OwnerId?: string;
}
export const CapacityReservationGroup = S.suspend(() =>
  S.Struct({
    GroupArn: S.optional(S.String).pipe(
      T.XmlName("groupArn"),
      T.Ec2QueryName("GroupArn"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
  }),
).annotate({
  identifier: "CapacityReservationGroup",
}) as any as S.Schema<CapacityReservationGroup>;
export type CapacityReservationGroupSet = CapacityReservationGroup[];
export const CapacityReservationGroupSet = S.Array(
  CapacityReservationGroup.pipe(T.XmlName("item")).annotate({
    identifier: "CapacityReservationGroup",
  }),
);
export interface GetGroupsForCapacityReservationResult {
  NextToken?: string;
  CapacityReservationGroups?: CapacityReservationGroup[];
}
export const GetGroupsForCapacityReservationResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    CapacityReservationGroups: S.optional(CapacityReservationGroupSet).pipe(
      T.XmlName("capacityReservationGroupSet"),
      T.Ec2QueryName("CapacityReservationGroupSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetGroupsForCapacityReservationResult",
}) as any as S.Schema<GetGroupsForCapacityReservationResult>;
export type RequestHostIdSet = string[];
export const RequestHostIdSet = S.Array(S.String.pipe(T.XmlName("item")));
export interface GetHostReservationPurchasePreviewRequest {
  HostIdSet?: string[];
  OfferingId?: string;
}
export const GetHostReservationPurchasePreviewRequest = S.suspend(() =>
  S.Struct({
    HostIdSet: S.optional(RequestHostIdSet),
    OfferingId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetHostReservationPurchasePreviewRequest",
}) as any as S.Schema<GetHostReservationPurchasePreviewRequest>;
export interface Purchase {
  CurrencyCode?: CurrencyCodeValues;
  Duration?: number;
  HostIdSet?: string[];
  HostReservationId?: string;
  HourlyPrice?: string;
  InstanceFamily?: string;
  PaymentOption?: PaymentOption;
  UpfrontPrice?: string;
}
export const Purchase = S.suspend(() =>
  S.Struct({
    CurrencyCode: S.optional(CurrencyCodeValues).pipe(
      T.XmlName("currencyCode"),
      T.Ec2QueryName("CurrencyCode"),
    ),
    Duration: S.optional(S.Number).pipe(
      T.XmlName("duration"),
      T.Ec2QueryName("Duration"),
    ),
    HostIdSet: S.optional(ResponseHostIdSet).pipe(
      T.XmlName("hostIdSet"),
      T.Ec2QueryName("HostIdSet"),
    ),
    HostReservationId: S.optional(S.String).pipe(
      T.XmlName("hostReservationId"),
      T.Ec2QueryName("HostReservationId"),
    ),
    HourlyPrice: S.optional(S.String).pipe(
      T.XmlName("hourlyPrice"),
      T.Ec2QueryName("HourlyPrice"),
    ),
    InstanceFamily: S.optional(S.String).pipe(
      T.XmlName("instanceFamily"),
      T.Ec2QueryName("InstanceFamily"),
    ),
    PaymentOption: S.optional(PaymentOption).pipe(
      T.XmlName("paymentOption"),
      T.Ec2QueryName("PaymentOption"),
    ),
    UpfrontPrice: S.optional(S.String).pipe(
      T.XmlName("upfrontPrice"),
      T.Ec2QueryName("UpfrontPrice"),
    ),
  }),
).annotate({ identifier: "Purchase" }) as any as S.Schema<Purchase>;
export type PurchaseSet = Purchase[];
export const PurchaseSet = S.Array(
  Purchase.pipe(T.XmlName("item")).annotate({ identifier: "Purchase" }),
);
export interface GetHostReservationPurchasePreviewResult {
  CurrencyCode?: CurrencyCodeValues;
  Purchase?: Purchase[];
  TotalHourlyPrice?: string;
  TotalUpfrontPrice?: string;
}
export const GetHostReservationPurchasePreviewResult = S.suspend(() =>
  S.Struct({
    CurrencyCode: S.optional(CurrencyCodeValues).pipe(
      T.XmlName("currencyCode"),
      T.Ec2QueryName("CurrencyCode"),
    ),
    Purchase: S.optional(PurchaseSet).pipe(
      T.XmlName("purchase"),
      T.Ec2QueryName("Purchase"),
    ),
    TotalHourlyPrice: S.optional(S.String).pipe(
      T.XmlName("totalHourlyPrice"),
      T.Ec2QueryName("TotalHourlyPrice"),
    ),
    TotalUpfrontPrice: S.optional(S.String).pipe(
      T.XmlName("totalUpfrontPrice"),
      T.Ec2QueryName("TotalUpfrontPrice"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetHostReservationPurchasePreviewResult",
}) as any as S.Schema<GetHostReservationPurchasePreviewResult>;
export interface GetImageAncestryRequest {
  ImageId?: string;
  DryRun?: boolean;
}
export const GetImageAncestryRequest = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetImageAncestryRequest",
}) as any as S.Schema<GetImageAncestryRequest>;
export interface ImageAncestryEntry {
  CreationDate?: Date;
  ImageId?: string;
  ImageOwnerAlias?: string;
  SourceImageId?: string;
  SourceImageRegion?: string;
}
export const ImageAncestryEntry = S.suspend(() =>
  S.Struct({
    CreationDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("creationDate"), T.Ec2QueryName("CreationDate")),
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    ImageOwnerAlias: S.optional(S.String).pipe(
      T.XmlName("imageOwnerAlias"),
      T.Ec2QueryName("ImageOwnerAlias"),
    ),
    SourceImageId: S.optional(S.String).pipe(
      T.XmlName("sourceImageId"),
      T.Ec2QueryName("SourceImageId"),
    ),
    SourceImageRegion: S.optional(S.String).pipe(
      T.XmlName("sourceImageRegion"),
      T.Ec2QueryName("SourceImageRegion"),
    ),
  }),
).annotate({
  identifier: "ImageAncestryEntry",
}) as any as S.Schema<ImageAncestryEntry>;
export type ImageAncestryEntryList = ImageAncestryEntry[];
export const ImageAncestryEntryList = S.Array(
  ImageAncestryEntry.pipe(T.XmlName("item")).annotate({
    identifier: "ImageAncestryEntry",
  }),
);
export interface GetImageAncestryResult {
  ImageAncestryEntries?: ImageAncestryEntry[];
}
export const GetImageAncestryResult = S.suspend(() =>
  S.Struct({
    ImageAncestryEntries: S.optional(ImageAncestryEntryList).pipe(
      T.XmlName("imageAncestryEntrySet"),
      T.Ec2QueryName("ImageAncestryEntrySet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetImageAncestryResult",
}) as any as S.Schema<GetImageAncestryResult>;
export interface GetImageBlockPublicAccessStateRequest {
  DryRun?: boolean;
}
export const GetImageBlockPublicAccessStateRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetImageBlockPublicAccessStateRequest",
}) as any as S.Schema<GetImageBlockPublicAccessStateRequest>;
export interface GetImageBlockPublicAccessStateResult {
  ImageBlockPublicAccessState?: string;
  ManagedBy?: ManagedBy;
}
export const GetImageBlockPublicAccessStateResult = S.suspend(() =>
  S.Struct({
    ImageBlockPublicAccessState: S.optional(S.String).pipe(
      T.XmlName("imageBlockPublicAccessState"),
      T.Ec2QueryName("ImageBlockPublicAccessState"),
    ),
    ManagedBy: S.optional(ManagedBy).pipe(
      T.XmlName("managedBy"),
      T.Ec2QueryName("ManagedBy"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetImageBlockPublicAccessStateResult",
}) as any as S.Schema<GetImageBlockPublicAccessStateResult>;
export interface GetInstanceMetadataDefaultsRequest {
  DryRun?: boolean;
}
export const GetInstanceMetadataDefaultsRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetInstanceMetadataDefaultsRequest",
}) as any as S.Schema<GetInstanceMetadataDefaultsRequest>;
export type HttpTokensEnforcedState = "disabled" | "enabled" | (string & {});
export const HttpTokensEnforcedState = S.String;
export interface InstanceMetadataDefaultsResponse {
  HttpTokens?: HttpTokensState;
  HttpPutResponseHopLimit?: number;
  HttpEndpoint?: InstanceMetadataEndpointState;
  InstanceMetadataTags?: InstanceMetadataTagsState;
  ManagedBy?: ManagedBy;
  ManagedExceptionMessage?: string;
  HttpTokensEnforced?: HttpTokensEnforcedState;
}
export const InstanceMetadataDefaultsResponse = S.suspend(() =>
  S.Struct({
    HttpTokens: S.optional(HttpTokensState).pipe(
      T.XmlName("httpTokens"),
      T.Ec2QueryName("HttpTokens"),
    ),
    HttpPutResponseHopLimit: S.optional(S.Number).pipe(
      T.XmlName("httpPutResponseHopLimit"),
      T.Ec2QueryName("HttpPutResponseHopLimit"),
    ),
    HttpEndpoint: S.optional(InstanceMetadataEndpointState).pipe(
      T.XmlName("httpEndpoint"),
      T.Ec2QueryName("HttpEndpoint"),
    ),
    InstanceMetadataTags: S.optional(InstanceMetadataTagsState).pipe(
      T.XmlName("instanceMetadataTags"),
      T.Ec2QueryName("InstanceMetadataTags"),
    ),
    ManagedBy: S.optional(ManagedBy).pipe(
      T.XmlName("managedBy"),
      T.Ec2QueryName("ManagedBy"),
    ),
    ManagedExceptionMessage: S.optional(S.String).pipe(
      T.XmlName("managedExceptionMessage"),
      T.Ec2QueryName("ManagedExceptionMessage"),
    ),
    HttpTokensEnforced: S.optional(HttpTokensEnforcedState).pipe(
      T.XmlName("httpTokensEnforced"),
      T.Ec2QueryName("HttpTokensEnforced"),
    ),
  }),
).annotate({
  identifier: "InstanceMetadataDefaultsResponse",
}) as any as S.Schema<InstanceMetadataDefaultsResponse>;
export interface GetInstanceMetadataDefaultsResult {
  AccountLevel?: InstanceMetadataDefaultsResponse;
}
export const GetInstanceMetadataDefaultsResult = S.suspend(() =>
  S.Struct({
    AccountLevel: S.optional(InstanceMetadataDefaultsResponse)
      .pipe(T.XmlName("accountLevel"), T.Ec2QueryName("AccountLevel"))
      .annotate({ identifier: "InstanceMetadataDefaultsResponse" }),
  }).pipe(ns),
).annotate({
  identifier: "GetInstanceMetadataDefaultsResult",
}) as any as S.Schema<GetInstanceMetadataDefaultsResult>;
export type EkPubKeyType = "rsa-2048" | "ecc-sec-p384" | (string & {});
export const EkPubKeyType = S.String;
export type EkPubKeyFormat = "der" | "tpmt" | (string & {});
export const EkPubKeyFormat = S.String;
export interface GetInstanceTpmEkPubRequest {
  InstanceId?: string;
  KeyType?: EkPubKeyType;
  KeyFormat?: EkPubKeyFormat;
  DryRun?: boolean;
}
export const GetInstanceTpmEkPubRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(T.XmlName("InstanceId")),
    KeyType: S.optional(EkPubKeyType),
    KeyFormat: S.optional(EkPubKeyFormat),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetInstanceTpmEkPubRequest",
}) as any as S.Schema<GetInstanceTpmEkPubRequest>;
export interface GetInstanceTpmEkPubResult {
  InstanceId?: string;
  KeyType?: EkPubKeyType;
  KeyFormat?: EkPubKeyFormat;
  KeyValue?: string | redacted.Redacted<string>;
}
export const GetInstanceTpmEkPubResult = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    KeyType: S.optional(EkPubKeyType).pipe(
      T.XmlName("keyType"),
      T.Ec2QueryName("KeyType"),
    ),
    KeyFormat: S.optional(EkPubKeyFormat).pipe(
      T.XmlName("keyFormat"),
      T.Ec2QueryName("KeyFormat"),
    ),
    KeyValue: S.optional(SensitiveString).pipe(
      T.XmlName("keyValue"),
      T.Ec2QueryName("KeyValue"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetInstanceTpmEkPubResult",
}) as any as S.Schema<GetInstanceTpmEkPubResult>;
export type ArchitectureTypeSet = ArchitectureType[];
export const ArchitectureTypeSet = S.Array(
  ArchitectureType.pipe(T.XmlName("item")),
);
export type VirtualizationTypeSet = VirtualizationType[];
export const VirtualizationTypeSet = S.Array(
  VirtualizationType.pipe(T.XmlName("item")),
);
export interface GetInstanceTypesFromInstanceRequirementsRequest {
  DryRun?: boolean;
  ArchitectureTypes?: ArchitectureType[];
  VirtualizationTypes?: VirtualizationType[];
  InstanceRequirements?: InstanceRequirementsRequest;
  MaxResults?: number;
  NextToken?: string;
  Context?: string;
}
export const GetInstanceTypesFromInstanceRequirementsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ArchitectureTypes: S.optional(ArchitectureTypeSet).pipe(
      T.XmlName("ArchitectureType"),
    ),
    VirtualizationTypes: S.optional(VirtualizationTypeSet).pipe(
      T.XmlName("VirtualizationType"),
    ),
    InstanceRequirements: S.optional(InstanceRequirementsRequest),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    Context: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetInstanceTypesFromInstanceRequirementsRequest",
}) as any as S.Schema<GetInstanceTypesFromInstanceRequirementsRequest>;
export interface InstanceTypeInfoFromInstanceRequirements {
  InstanceType?: string;
}
export const InstanceTypeInfoFromInstanceRequirements = S.suspend(() =>
  S.Struct({
    InstanceType: S.optional(S.String).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
  }),
).annotate({
  identifier: "InstanceTypeInfoFromInstanceRequirements",
}) as any as S.Schema<InstanceTypeInfoFromInstanceRequirements>;
export type InstanceTypeInfoFromInstanceRequirementsSet =
  InstanceTypeInfoFromInstanceRequirements[];
export const InstanceTypeInfoFromInstanceRequirementsSet = S.Array(
  InstanceTypeInfoFromInstanceRequirements.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceTypeInfoFromInstanceRequirements",
  }),
);
export interface GetInstanceTypesFromInstanceRequirementsResult {
  InstanceTypes?: InstanceTypeInfoFromInstanceRequirements[];
  NextToken?: string;
}
export const GetInstanceTypesFromInstanceRequirementsResult = S.suspend(() =>
  S.Struct({
    InstanceTypes: S.optional(InstanceTypeInfoFromInstanceRequirementsSet).pipe(
      T.XmlName("instanceTypeSet"),
      T.Ec2QueryName("InstanceTypeSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetInstanceTypesFromInstanceRequirementsResult",
}) as any as S.Schema<GetInstanceTypesFromInstanceRequirementsResult>;
export interface GetInstanceUefiDataRequest {
  InstanceId?: string;
  DryRun?: boolean;
}
export const GetInstanceUefiDataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(T.XmlName("InstanceId")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetInstanceUefiDataRequest",
}) as any as S.Schema<GetInstanceUefiDataRequest>;
export interface GetInstanceUefiDataResult {
  InstanceId?: string;
  UefiData?: string;
}
export const GetInstanceUefiDataResult = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    UefiData: S.optional(S.String).pipe(
      T.XmlName("uefiData"),
      T.Ec2QueryName("UefiData"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetInstanceUefiDataResult",
}) as any as S.Schema<GetInstanceUefiDataResult>;
export interface GetIpamAddressHistoryRequest {
  DryRun?: boolean;
  Cidr?: string;
  IpamScopeId?: string;
  VpcId?: string;
  StartTime?: Date;
  EndTime?: Date;
  MaxResults?: number;
  NextToken?: string;
}
export const GetIpamAddressHistoryRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Cidr: S.optional(S.String),
    IpamScopeId: S.optional(S.String),
    VpcId: S.optional(S.String),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    EndTime: S.optional(T.DateFromString.pipe(T.TimestampFormat("date-time"))),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetIpamAddressHistoryRequest",
}) as any as S.Schema<GetIpamAddressHistoryRequest>;
export type IpamAddressHistoryResourceType =
  | "eip"
  | "vpc"
  | "subnet"
  | "network-interface"
  | "instance"
  | (string & {});
export const IpamAddressHistoryResourceType = S.String;
export type IpamComplianceStatus =
  | "compliant"
  | "noncompliant"
  | "unmanaged"
  | "ignored"
  | (string & {});
export const IpamComplianceStatus = S.String;
export type IpamOverlapStatus =
  | "overlapping"
  | "nonoverlapping"
  | "ignored"
  | (string & {});
export const IpamOverlapStatus = S.String;
export interface IpamAddressHistoryRecord {
  ResourceOwnerId?: string;
  ResourceRegion?: string;
  ResourceType?: IpamAddressHistoryResourceType;
  ResourceId?: string;
  ResourceCidr?: string;
  ResourceName?: string;
  ResourceComplianceStatus?: IpamComplianceStatus;
  ResourceOverlapStatus?: IpamOverlapStatus;
  VpcId?: string;
  SampledStartTime?: Date;
  SampledEndTime?: Date;
}
export const IpamAddressHistoryRecord = S.suspend(() =>
  S.Struct({
    ResourceOwnerId: S.optional(S.String).pipe(
      T.XmlName("resourceOwnerId"),
      T.Ec2QueryName("ResourceOwnerId"),
    ),
    ResourceRegion: S.optional(S.String).pipe(
      T.XmlName("resourceRegion"),
      T.Ec2QueryName("ResourceRegion"),
    ),
    ResourceType: S.optional(IpamAddressHistoryResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    ResourceCidr: S.optional(S.String).pipe(
      T.XmlName("resourceCidr"),
      T.Ec2QueryName("ResourceCidr"),
    ),
    ResourceName: S.optional(S.String).pipe(
      T.XmlName("resourceName"),
      T.Ec2QueryName("ResourceName"),
    ),
    ResourceComplianceStatus: S.optional(IpamComplianceStatus).pipe(
      T.XmlName("resourceComplianceStatus"),
      T.Ec2QueryName("ResourceComplianceStatus"),
    ),
    ResourceOverlapStatus: S.optional(IpamOverlapStatus).pipe(
      T.XmlName("resourceOverlapStatus"),
      T.Ec2QueryName("ResourceOverlapStatus"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    SampledStartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("sampledStartTime"), T.Ec2QueryName("SampledStartTime")),
    SampledEndTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("sampledEndTime"), T.Ec2QueryName("SampledEndTime")),
  }),
).annotate({
  identifier: "IpamAddressHistoryRecord",
}) as any as S.Schema<IpamAddressHistoryRecord>;
export type IpamAddressHistoryRecordSet = IpamAddressHistoryRecord[];
export const IpamAddressHistoryRecordSet = S.Array(
  IpamAddressHistoryRecord.pipe(T.XmlName("item")).annotate({
    identifier: "IpamAddressHistoryRecord",
  }),
);
export interface GetIpamAddressHistoryResult {
  HistoryRecords?: IpamAddressHistoryRecord[];
  NextToken?: string;
}
export const GetIpamAddressHistoryResult = S.suspend(() =>
  S.Struct({
    HistoryRecords: S.optional(IpamAddressHistoryRecordSet).pipe(
      T.XmlName("historyRecordSet"),
      T.Ec2QueryName("HistoryRecordSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetIpamAddressHistoryResult",
}) as any as S.Schema<GetIpamAddressHistoryResult>;
export interface GetIpamDiscoveredAccountsRequest {
  DryRun?: boolean;
  IpamResourceDiscoveryId?: string;
  DiscoveryRegion?: string;
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export const GetIpamDiscoveredAccountsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamResourceDiscoveryId: S.optional(S.String),
    DiscoveryRegion: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetIpamDiscoveredAccountsRequest",
}) as any as S.Schema<GetIpamDiscoveredAccountsRequest>;
export type IpamDiscoveryFailureCode =
  | "assume-role-failure"
  | "throttling-failure"
  | "unauthorized-failure"
  | (string & {});
export const IpamDiscoveryFailureCode = S.String;
export interface IpamDiscoveryFailureReason {
  Code?: IpamDiscoveryFailureCode;
  Message?: string;
}
export const IpamDiscoveryFailureReason = S.suspend(() =>
  S.Struct({
    Code: S.optional(IpamDiscoveryFailureCode).pipe(
      T.XmlName("code"),
      T.Ec2QueryName("Code"),
    ),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "IpamDiscoveryFailureReason",
}) as any as S.Schema<IpamDiscoveryFailureReason>;
export interface IpamDiscoveredAccount {
  AccountId?: string;
  DiscoveryRegion?: string;
  FailureReason?: IpamDiscoveryFailureReason;
  LastAttemptedDiscoveryTime?: Date;
  LastSuccessfulDiscoveryTime?: Date;
  OrganizationalUnitId?: string;
}
export const IpamDiscoveredAccount = S.suspend(() =>
  S.Struct({
    AccountId: S.optional(S.String).pipe(
      T.XmlName("accountId"),
      T.Ec2QueryName("AccountId"),
    ),
    DiscoveryRegion: S.optional(S.String).pipe(
      T.XmlName("discoveryRegion"),
      T.Ec2QueryName("DiscoveryRegion"),
    ),
    FailureReason: S.optional(IpamDiscoveryFailureReason)
      .pipe(T.XmlName("failureReason"), T.Ec2QueryName("FailureReason"))
      .annotate({ identifier: "IpamDiscoveryFailureReason" }),
    LastAttemptedDiscoveryTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("lastAttemptedDiscoveryTime"),
      T.Ec2QueryName("LastAttemptedDiscoveryTime"),
    ),
    LastSuccessfulDiscoveryTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("lastSuccessfulDiscoveryTime"),
      T.Ec2QueryName("LastSuccessfulDiscoveryTime"),
    ),
    OrganizationalUnitId: S.optional(S.String).pipe(
      T.XmlName("organizationalUnitId"),
      T.Ec2QueryName("OrganizationalUnitId"),
    ),
  }),
).annotate({
  identifier: "IpamDiscoveredAccount",
}) as any as S.Schema<IpamDiscoveredAccount>;
export type IpamDiscoveredAccountSet = IpamDiscoveredAccount[];
export const IpamDiscoveredAccountSet = S.Array(
  IpamDiscoveredAccount.pipe(T.XmlName("item")).annotate({
    identifier: "IpamDiscoveredAccount",
  }),
);
export interface GetIpamDiscoveredAccountsResult {
  IpamDiscoveredAccounts?: IpamDiscoveredAccount[];
  NextToken?: string;
}
export const GetIpamDiscoveredAccountsResult = S.suspend(() =>
  S.Struct({
    IpamDiscoveredAccounts: S.optional(IpamDiscoveredAccountSet).pipe(
      T.XmlName("ipamDiscoveredAccountSet"),
      T.Ec2QueryName("IpamDiscoveredAccountSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetIpamDiscoveredAccountsResult",
}) as any as S.Schema<GetIpamDiscoveredAccountsResult>;
export interface GetIpamDiscoveredPublicAddressesRequest {
  DryRun?: boolean;
  IpamResourceDiscoveryId?: string;
  AddressRegion?: string;
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export const GetIpamDiscoveredPublicAddressesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamResourceDiscoveryId: S.optional(S.String),
    AddressRegion: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetIpamDiscoveredPublicAddressesRequest",
}) as any as S.Schema<GetIpamDiscoveredPublicAddressesRequest>;
export type IpamPublicAddressAssociationStatus =
  | "associated"
  | "disassociated"
  | (string & {});
export const IpamPublicAddressAssociationStatus = S.String;
export type IpamPublicAddressType =
  | "service-managed-ip"
  | "service-managed-byoip"
  | "amazon-owned-eip"
  | "amazon-owned-contig"
  | "byoip"
  | "ec2-public-ip"
  | "anycast-ip-list-ip"
  | (string & {});
export const IpamPublicAddressType = S.String;
export type IpamPublicAddressAwsService =
  | "nat-gateway"
  | "database-migration-service"
  | "redshift"
  | "elastic-container-service"
  | "relational-database-service"
  | "site-to-site-vpn"
  | "load-balancer"
  | "global-accelerator"
  | "cloudfront"
  | "other"
  | (string & {});
export const IpamPublicAddressAwsService = S.String;
export interface IpamPublicAddressTag {
  Key?: string;
  Value?: string;
}
export const IpamPublicAddressTag = S.suspend(() =>
  S.Struct({
    Key: S.optional(S.String).pipe(T.XmlName("key"), T.Ec2QueryName("Key")),
    Value: S.optional(S.String).pipe(
      T.XmlName("value"),
      T.Ec2QueryName("Value"),
    ),
  }),
).annotate({
  identifier: "IpamPublicAddressTag",
}) as any as S.Schema<IpamPublicAddressTag>;
export type IpamPublicAddressTagList = IpamPublicAddressTag[];
export const IpamPublicAddressTagList = S.Array(
  IpamPublicAddressTag.pipe(T.XmlName("item")).annotate({
    identifier: "IpamPublicAddressTag",
  }),
);
export interface IpamPublicAddressTags {
  EipTags?: IpamPublicAddressTag[];
}
export const IpamPublicAddressTags = S.suspend(() =>
  S.Struct({
    EipTags: S.optional(IpamPublicAddressTagList).pipe(
      T.XmlName("eipTagSet"),
      T.Ec2QueryName("EipTagSet"),
    ),
  }),
).annotate({
  identifier: "IpamPublicAddressTags",
}) as any as S.Schema<IpamPublicAddressTags>;
export interface IpamPublicAddressSecurityGroup {
  GroupName?: string;
  GroupId?: string;
}
export const IpamPublicAddressSecurityGroup = S.suspend(() =>
  S.Struct({
    GroupName: S.optional(S.String).pipe(
      T.XmlName("groupName"),
      T.Ec2QueryName("GroupName"),
    ),
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
  }),
).annotate({
  identifier: "IpamPublicAddressSecurityGroup",
}) as any as S.Schema<IpamPublicAddressSecurityGroup>;
export type IpamPublicAddressSecurityGroupList =
  IpamPublicAddressSecurityGroup[];
export const IpamPublicAddressSecurityGroupList = S.Array(
  IpamPublicAddressSecurityGroup.pipe(T.XmlName("item")).annotate({
    identifier: "IpamPublicAddressSecurityGroup",
  }),
);
export interface IpamDiscoveredPublicAddress {
  IpamResourceDiscoveryId?: string;
  AddressRegion?: string;
  Address?: string;
  AddressOwnerId?: string;
  AddressAllocationId?: string;
  AssociationStatus?: IpamPublicAddressAssociationStatus;
  AddressType?: IpamPublicAddressType;
  Service?: IpamPublicAddressAwsService;
  ServiceResource?: string;
  VpcId?: string;
  SubnetId?: string;
  PublicIpv4PoolId?: string;
  NetworkInterfaceId?: string;
  NetworkInterfaceDescription?: string;
  InstanceId?: string;
  Tags?: IpamPublicAddressTags;
  NetworkBorderGroup?: string;
  SecurityGroups?: IpamPublicAddressSecurityGroup[];
  SampleTime?: Date;
}
export const IpamDiscoveredPublicAddress = S.suspend(() =>
  S.Struct({
    IpamResourceDiscoveryId: S.optional(S.String).pipe(
      T.XmlName("ipamResourceDiscoveryId"),
      T.Ec2QueryName("IpamResourceDiscoveryId"),
    ),
    AddressRegion: S.optional(S.String).pipe(
      T.XmlName("addressRegion"),
      T.Ec2QueryName("AddressRegion"),
    ),
    Address: S.optional(S.String).pipe(
      T.XmlName("address"),
      T.Ec2QueryName("Address"),
    ),
    AddressOwnerId: S.optional(S.String).pipe(
      T.XmlName("addressOwnerId"),
      T.Ec2QueryName("AddressOwnerId"),
    ),
    AddressAllocationId: S.optional(S.String).pipe(
      T.XmlName("addressAllocationId"),
      T.Ec2QueryName("AddressAllocationId"),
    ),
    AssociationStatus: S.optional(IpamPublicAddressAssociationStatus).pipe(
      T.XmlName("associationStatus"),
      T.Ec2QueryName("AssociationStatus"),
    ),
    AddressType: S.optional(IpamPublicAddressType).pipe(
      T.XmlName("addressType"),
      T.Ec2QueryName("AddressType"),
    ),
    Service: S.optional(IpamPublicAddressAwsService).pipe(
      T.XmlName("service"),
      T.Ec2QueryName("Service"),
    ),
    ServiceResource: S.optional(S.String).pipe(
      T.XmlName("serviceResource"),
      T.Ec2QueryName("ServiceResource"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    PublicIpv4PoolId: S.optional(S.String).pipe(
      T.XmlName("publicIpv4PoolId"),
      T.Ec2QueryName("PublicIpv4PoolId"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    NetworkInterfaceDescription: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceDescription"),
      T.Ec2QueryName("NetworkInterfaceDescription"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    Tags: S.optional(IpamPublicAddressTags)
      .pipe(T.XmlName("tags"), T.Ec2QueryName("Tags"))
      .annotate({ identifier: "IpamPublicAddressTags" }),
    NetworkBorderGroup: S.optional(S.String).pipe(
      T.XmlName("networkBorderGroup"),
      T.Ec2QueryName("NetworkBorderGroup"),
    ),
    SecurityGroups: S.optional(IpamPublicAddressSecurityGroupList).pipe(
      T.XmlName("securityGroupSet"),
      T.Ec2QueryName("SecurityGroupSet"),
    ),
    SampleTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("sampleTime"), T.Ec2QueryName("SampleTime")),
  }),
).annotate({
  identifier: "IpamDiscoveredPublicAddress",
}) as any as S.Schema<IpamDiscoveredPublicAddress>;
export type IpamDiscoveredPublicAddressSet = IpamDiscoveredPublicAddress[];
export const IpamDiscoveredPublicAddressSet = S.Array(
  IpamDiscoveredPublicAddress.pipe(T.XmlName("item")).annotate({
    identifier: "IpamDiscoveredPublicAddress",
  }),
);
export interface GetIpamDiscoveredPublicAddressesResult {
  IpamDiscoveredPublicAddresses?: IpamDiscoveredPublicAddress[];
  OldestSampleTime?: Date;
  NextToken?: string;
}
export const GetIpamDiscoveredPublicAddressesResult = S.suspend(() =>
  S.Struct({
    IpamDiscoveredPublicAddresses: S.optional(
      IpamDiscoveredPublicAddressSet,
    ).pipe(
      T.XmlName("ipamDiscoveredPublicAddressSet"),
      T.Ec2QueryName("IpamDiscoveredPublicAddressSet"),
    ),
    OldestSampleTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("oldestSampleTime"), T.Ec2QueryName("OldestSampleTime")),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetIpamDiscoveredPublicAddressesResult",
}) as any as S.Schema<GetIpamDiscoveredPublicAddressesResult>;
export interface GetIpamDiscoveredResourceCidrsRequest {
  DryRun?: boolean;
  IpamResourceDiscoveryId?: string;
  ResourceRegion?: string;
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export const GetIpamDiscoveredResourceCidrsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamResourceDiscoveryId: S.optional(S.String),
    ResourceRegion: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetIpamDiscoveredResourceCidrsRequest",
}) as any as S.Schema<GetIpamDiscoveredResourceCidrsRequest>;
export type IpamResourceCidrIpSource =
  | "amazon"
  | "byoip"
  | "none"
  | (string & {});
export const IpamResourceCidrIpSource = S.String;
export type IpamNetworkInterfaceAttachmentStatus =
  | "available"
  | "in-use"
  | (string & {});
export const IpamNetworkInterfaceAttachmentStatus = S.String;
export interface IpamDiscoveredResourceCidr {
  IpamResourceDiscoveryId?: string;
  ResourceRegion?: string;
  ResourceId?: string;
  ResourceOwnerId?: string;
  ResourceCidr?: string;
  IpSource?: IpamResourceCidrIpSource;
  ResourceType?: IpamResourceType;
  ResourceTags?: IpamResourceTag[];
  IpUsage?: number;
  VpcId?: string;
  SubnetId?: string;
  NetworkInterfaceAttachmentStatus?: IpamNetworkInterfaceAttachmentStatus;
  SampleTime?: Date;
  AvailabilityZoneId?: string;
}
export const IpamDiscoveredResourceCidr = S.suspend(() =>
  S.Struct({
    IpamResourceDiscoveryId: S.optional(S.String).pipe(
      T.XmlName("ipamResourceDiscoveryId"),
      T.Ec2QueryName("IpamResourceDiscoveryId"),
    ),
    ResourceRegion: S.optional(S.String).pipe(
      T.XmlName("resourceRegion"),
      T.Ec2QueryName("ResourceRegion"),
    ),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    ResourceOwnerId: S.optional(S.String).pipe(
      T.XmlName("resourceOwnerId"),
      T.Ec2QueryName("ResourceOwnerId"),
    ),
    ResourceCidr: S.optional(S.String).pipe(
      T.XmlName("resourceCidr"),
      T.Ec2QueryName("ResourceCidr"),
    ),
    IpSource: S.optional(IpamResourceCidrIpSource).pipe(
      T.XmlName("ipSource"),
      T.Ec2QueryName("IpSource"),
    ),
    ResourceType: S.optional(IpamResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    ResourceTags: S.optional(IpamResourceTagList).pipe(
      T.XmlName("resourceTagSet"),
      T.Ec2QueryName("ResourceTagSet"),
    ),
    IpUsage: S.optional(S.Number).pipe(
      T.XmlName("ipUsage"),
      T.Ec2QueryName("IpUsage"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    NetworkInterfaceAttachmentStatus: S.optional(
      IpamNetworkInterfaceAttachmentStatus,
    ).pipe(
      T.XmlName("networkInterfaceAttachmentStatus"),
      T.Ec2QueryName("NetworkInterfaceAttachmentStatus"),
    ),
    SampleTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("sampleTime"), T.Ec2QueryName("SampleTime")),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
  }),
).annotate({
  identifier: "IpamDiscoveredResourceCidr",
}) as any as S.Schema<IpamDiscoveredResourceCidr>;
export type IpamDiscoveredResourceCidrSet = IpamDiscoveredResourceCidr[];
export const IpamDiscoveredResourceCidrSet = S.Array(
  IpamDiscoveredResourceCidr.pipe(T.XmlName("item")).annotate({
    identifier: "IpamDiscoveredResourceCidr",
  }),
);
export interface GetIpamDiscoveredResourceCidrsResult {
  IpamDiscoveredResourceCidrs?: IpamDiscoveredResourceCidr[];
  NextToken?: string;
}
export const GetIpamDiscoveredResourceCidrsResult = S.suspend(() =>
  S.Struct({
    IpamDiscoveredResourceCidrs: S.optional(IpamDiscoveredResourceCidrSet).pipe(
      T.XmlName("ipamDiscoveredResourceCidrSet"),
      T.Ec2QueryName("IpamDiscoveredResourceCidrSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetIpamDiscoveredResourceCidrsResult",
}) as any as S.Schema<GetIpamDiscoveredResourceCidrsResult>;
export type IpamPolicyResourceType =
  | "alb"
  | "eip"
  | "rds"
  | "rnat"
  | (string & {});
export const IpamPolicyResourceType = S.String;
export interface GetIpamPolicyAllocationRulesRequest {
  DryRun?: boolean;
  IpamPolicyId?: string;
  Filters?: Filter[];
  Locale?: string;
  ResourceType?: IpamPolicyResourceType;
  MaxResults?: number;
  NextToken?: string;
}
export const GetIpamPolicyAllocationRulesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPolicyId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    Locale: S.optional(S.String),
    ResourceType: S.optional(IpamPolicyResourceType),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetIpamPolicyAllocationRulesRequest",
}) as any as S.Schema<GetIpamPolicyAllocationRulesRequest>;
export interface IpamPolicyAllocationRule {
  SourceIpamPoolId?: string;
}
export const IpamPolicyAllocationRule = S.suspend(() =>
  S.Struct({
    SourceIpamPoolId: S.optional(S.String).pipe(
      T.XmlName("sourceIpamPoolId"),
      T.Ec2QueryName("SourceIpamPoolId"),
    ),
  }),
).annotate({
  identifier: "IpamPolicyAllocationRule",
}) as any as S.Schema<IpamPolicyAllocationRule>;
export type IpamPolicyAllocationRuleList = IpamPolicyAllocationRule[];
export const IpamPolicyAllocationRuleList = S.Array(
  IpamPolicyAllocationRule.pipe(T.XmlName("item")).annotate({
    identifier: "IpamPolicyAllocationRule",
  }),
);
export interface IpamPolicyDocument {
  IpamPolicyId?: string;
  Locale?: string;
  ResourceType?: IpamPolicyResourceType;
  AllocationRules?: IpamPolicyAllocationRule[];
}
export const IpamPolicyDocument = S.suspend(() =>
  S.Struct({
    IpamPolicyId: S.optional(S.String).pipe(
      T.XmlName("ipamPolicyId"),
      T.Ec2QueryName("IpamPolicyId"),
    ),
    Locale: S.optional(S.String).pipe(
      T.XmlName("locale"),
      T.Ec2QueryName("Locale"),
    ),
    ResourceType: S.optional(IpamPolicyResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    AllocationRules: S.optional(IpamPolicyAllocationRuleList).pipe(
      T.XmlName("allocationRuleSet"),
      T.Ec2QueryName("AllocationRuleSet"),
    ),
  }),
).annotate({
  identifier: "IpamPolicyDocument",
}) as any as S.Schema<IpamPolicyDocument>;
export type IpamPolicyDocumentSet = IpamPolicyDocument[];
export const IpamPolicyDocumentSet = S.Array(
  IpamPolicyDocument.pipe(T.XmlName("item")).annotate({
    identifier: "IpamPolicyDocument",
  }),
);
export interface GetIpamPolicyAllocationRulesResult {
  IpamPolicyDocuments?: IpamPolicyDocument[];
  NextToken?: string;
}
export const GetIpamPolicyAllocationRulesResult = S.suspend(() =>
  S.Struct({
    IpamPolicyDocuments: S.optional(IpamPolicyDocumentSet).pipe(
      T.XmlName("ipamPolicyDocumentSet"),
      T.Ec2QueryName("IpamPolicyDocumentSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetIpamPolicyAllocationRulesResult",
}) as any as S.Schema<GetIpamPolicyAllocationRulesResult>;
export interface GetIpamPolicyOrganizationTargetsRequest {
  DryRun?: boolean;
  MaxResults?: number;
  NextToken?: string;
  IpamPolicyId?: string;
  Filters?: Filter[];
}
export const GetIpamPolicyOrganizationTargetsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    IpamPolicyId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetIpamPolicyOrganizationTargetsRequest",
}) as any as S.Schema<GetIpamPolicyOrganizationTargetsRequest>;
export interface IpamPolicyOrganizationTarget {
  OrganizationTargetId?: string;
}
export const IpamPolicyOrganizationTarget = S.suspend(() =>
  S.Struct({
    OrganizationTargetId: S.optional(S.String).pipe(
      T.XmlName("organizationTargetId"),
      T.Ec2QueryName("OrganizationTargetId"),
    ),
  }),
).annotate({
  identifier: "IpamPolicyOrganizationTarget",
}) as any as S.Schema<IpamPolicyOrganizationTarget>;
export type IpamPolicyOrganizationTargetSet = IpamPolicyOrganizationTarget[];
export const IpamPolicyOrganizationTargetSet = S.Array(
  IpamPolicyOrganizationTarget.pipe(T.XmlName("item")).annotate({
    identifier: "IpamPolicyOrganizationTarget",
  }),
);
export interface GetIpamPolicyOrganizationTargetsResult {
  OrganizationTargets?: IpamPolicyOrganizationTarget[];
  NextToken?: string;
}
export const GetIpamPolicyOrganizationTargetsResult = S.suspend(() =>
  S.Struct({
    OrganizationTargets: S.optional(IpamPolicyOrganizationTargetSet).pipe(
      T.XmlName("organizationTargetSet"),
      T.Ec2QueryName("OrganizationTargetSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetIpamPolicyOrganizationTargetsResult",
}) as any as S.Schema<GetIpamPolicyOrganizationTargetsResult>;
export interface GetIpamPoolAllocationsRequest {
  DryRun?: boolean;
  IpamPoolId?: string;
  IpamPoolAllocationId?: string;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const GetIpamPoolAllocationsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPoolId: S.optional(S.String),
    IpamPoolAllocationId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetIpamPoolAllocationsRequest",
}) as any as S.Schema<GetIpamPoolAllocationsRequest>;
export type IpamPoolAllocationSet = IpamPoolAllocation[];
export const IpamPoolAllocationSet = S.Array(
  IpamPoolAllocation.pipe(T.XmlName("item")).annotate({
    identifier: "IpamPoolAllocation",
  }),
);
export interface GetIpamPoolAllocationsResult {
  IpamPoolAllocations?: IpamPoolAllocation[];
  NextToken?: string;
}
export const GetIpamPoolAllocationsResult = S.suspend(() =>
  S.Struct({
    IpamPoolAllocations: S.optional(IpamPoolAllocationSet).pipe(
      T.XmlName("ipamPoolAllocationSet"),
      T.Ec2QueryName("IpamPoolAllocationSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetIpamPoolAllocationsResult",
}) as any as S.Schema<GetIpamPoolAllocationsResult>;
export interface GetIpamPoolCidrsRequest {
  DryRun?: boolean;
  IpamPoolId?: string;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const GetIpamPoolCidrsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPoolId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetIpamPoolCidrsRequest",
}) as any as S.Schema<GetIpamPoolCidrsRequest>;
export type IpamPoolCidrSet = IpamPoolCidr[];
export const IpamPoolCidrSet = S.Array(
  IpamPoolCidr.pipe(T.XmlName("item")).annotate({ identifier: "IpamPoolCidr" }),
);
export interface GetIpamPoolCidrsResult {
  IpamPoolCidrs?: IpamPoolCidr[];
  NextToken?: string;
}
export const GetIpamPoolCidrsResult = S.suspend(() =>
  S.Struct({
    IpamPoolCidrs: S.optional(IpamPoolCidrSet).pipe(
      T.XmlName("ipamPoolCidrSet"),
      T.Ec2QueryName("IpamPoolCidrSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetIpamPoolCidrsResult",
}) as any as S.Schema<GetIpamPoolCidrsResult>;
export interface GetIpamPrefixListResolverRulesRequest {
  DryRun?: boolean;
  IpamPrefixListResolverId?: string;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export const GetIpamPrefixListResolverRulesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPrefixListResolverId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetIpamPrefixListResolverRulesRequest",
}) as any as S.Schema<GetIpamPrefixListResolverRulesRequest>;
export interface IpamPrefixListResolverRuleCondition {
  Operation?: IpamPrefixListResolverRuleConditionOperation;
  IpamPoolId?: string;
  ResourceId?: string;
  ResourceOwner?: string;
  ResourceRegion?: string;
  ResourceTag?: IpamResourceTag;
  Cidr?: string;
}
export const IpamPrefixListResolverRuleCondition = S.suspend(() =>
  S.Struct({
    Operation: S.optional(IpamPrefixListResolverRuleConditionOperation).pipe(
      T.XmlName("operation"),
      T.Ec2QueryName("Operation"),
    ),
    IpamPoolId: S.optional(S.String).pipe(
      T.XmlName("ipamPoolId"),
      T.Ec2QueryName("IpamPoolId"),
    ),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    ResourceOwner: S.optional(S.String).pipe(
      T.XmlName("resourceOwner"),
      T.Ec2QueryName("ResourceOwner"),
    ),
    ResourceRegion: S.optional(S.String).pipe(
      T.XmlName("resourceRegion"),
      T.Ec2QueryName("ResourceRegion"),
    ),
    ResourceTag: S.optional(IpamResourceTag)
      .pipe(T.XmlName("resourceTag"), T.Ec2QueryName("ResourceTag"))
      .annotate({ identifier: "IpamResourceTag" }),
    Cidr: S.optional(S.String).pipe(T.XmlName("cidr"), T.Ec2QueryName("Cidr")),
  }),
).annotate({
  identifier: "IpamPrefixListResolverRuleCondition",
}) as any as S.Schema<IpamPrefixListResolverRuleCondition>;
export type IpamPrefixListResolverRuleConditionSet =
  IpamPrefixListResolverRuleCondition[];
export const IpamPrefixListResolverRuleConditionSet = S.Array(
  IpamPrefixListResolverRuleCondition.pipe(T.XmlName("item")).annotate({
    identifier: "IpamPrefixListResolverRuleCondition",
  }),
);
export interface IpamPrefixListResolverRule {
  RuleType?: IpamPrefixListResolverRuleType;
  StaticCidr?: string;
  IpamScopeId?: string;
  ResourceType?: IpamResourceType;
  Conditions?: IpamPrefixListResolverRuleCondition[];
}
export const IpamPrefixListResolverRule = S.suspend(() =>
  S.Struct({
    RuleType: S.optional(IpamPrefixListResolverRuleType).pipe(
      T.XmlName("ruleType"),
      T.Ec2QueryName("RuleType"),
    ),
    StaticCidr: S.optional(S.String).pipe(
      T.XmlName("staticCidr"),
      T.Ec2QueryName("StaticCidr"),
    ),
    IpamScopeId: S.optional(S.String).pipe(
      T.XmlName("ipamScopeId"),
      T.Ec2QueryName("IpamScopeId"),
    ),
    ResourceType: S.optional(IpamResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    Conditions: S.optional(IpamPrefixListResolverRuleConditionSet).pipe(
      T.XmlName("conditionSet"),
      T.Ec2QueryName("ConditionSet"),
    ),
  }),
).annotate({
  identifier: "IpamPrefixListResolverRule",
}) as any as S.Schema<IpamPrefixListResolverRule>;
export type IpamPrefixListResolverRuleSet = IpamPrefixListResolverRule[];
export const IpamPrefixListResolverRuleSet = S.Array(
  IpamPrefixListResolverRule.pipe(T.XmlName("item")).annotate({
    identifier: "IpamPrefixListResolverRule",
  }),
);
export interface GetIpamPrefixListResolverRulesResult {
  Rules?: IpamPrefixListResolverRule[];
  NextToken?: string;
}
export const GetIpamPrefixListResolverRulesResult = S.suspend(() =>
  S.Struct({
    Rules: S.optional(IpamPrefixListResolverRuleSet).pipe(
      T.XmlName("ruleSet"),
      T.Ec2QueryName("RuleSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetIpamPrefixListResolverRulesResult",
}) as any as S.Schema<GetIpamPrefixListResolverRulesResult>;
export interface GetIpamPrefixListResolverVersionEntriesRequest {
  DryRun?: boolean;
  IpamPrefixListResolverId?: string;
  IpamPrefixListResolverVersion?: number;
  MaxResults?: number;
  NextToken?: string;
}
export const GetIpamPrefixListResolverVersionEntriesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPrefixListResolverId: S.optional(S.String),
    IpamPrefixListResolverVersion: S.optional(S.Number),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetIpamPrefixListResolverVersionEntriesRequest",
}) as any as S.Schema<GetIpamPrefixListResolverVersionEntriesRequest>;
export interface IpamPrefixListResolverVersionEntry {
  Cidr?: string;
}
export const IpamPrefixListResolverVersionEntry = S.suspend(() =>
  S.Struct({
    Cidr: S.optional(S.String).pipe(T.XmlName("cidr"), T.Ec2QueryName("Cidr")),
  }),
).annotate({
  identifier: "IpamPrefixListResolverVersionEntry",
}) as any as S.Schema<IpamPrefixListResolverVersionEntry>;
export type IpamPrefixListResolverVersionEntrySet =
  IpamPrefixListResolverVersionEntry[];
export const IpamPrefixListResolverVersionEntrySet = S.Array(
  IpamPrefixListResolverVersionEntry.pipe(T.XmlName("item")).annotate({
    identifier: "IpamPrefixListResolverVersionEntry",
  }),
);
export interface GetIpamPrefixListResolverVersionEntriesResult {
  Entries?: IpamPrefixListResolverVersionEntry[];
  NextToken?: string;
}
export const GetIpamPrefixListResolverVersionEntriesResult = S.suspend(() =>
  S.Struct({
    Entries: S.optional(IpamPrefixListResolverVersionEntrySet).pipe(
      T.XmlName("entrySet"),
      T.Ec2QueryName("EntrySet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetIpamPrefixListResolverVersionEntriesResult",
}) as any as S.Schema<GetIpamPrefixListResolverVersionEntriesResult>;
export type IpamPrefixListResolverVersionNumberSet = number[];
export const IpamPrefixListResolverVersionNumberSet = S.Array(
  S.Number.pipe(T.XmlName("item")),
);
export interface GetIpamPrefixListResolverVersionsRequest {
  DryRun?: boolean;
  IpamPrefixListResolverId?: string;
  IpamPrefixListResolverVersions?: number[];
  MaxResults?: number;
  Filters?: Filter[];
  NextToken?: string;
}
export const GetIpamPrefixListResolverVersionsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPrefixListResolverId: S.optional(S.String),
    IpamPrefixListResolverVersions: S.optional(
      IpamPrefixListResolverVersionNumberSet,
    ).pipe(T.XmlName("IpamPrefixListResolverVersion")),
    MaxResults: S.optional(S.Number),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetIpamPrefixListResolverVersionsRequest",
}) as any as S.Schema<GetIpamPrefixListResolverVersionsRequest>;
export interface IpamPrefixListResolverVersion {
  Version?: number;
}
export const IpamPrefixListResolverVersion = S.suspend(() =>
  S.Struct({
    Version: S.optional(S.Number).pipe(
      T.XmlName("version"),
      T.Ec2QueryName("Version"),
    ),
  }),
).annotate({
  identifier: "IpamPrefixListResolverVersion",
}) as any as S.Schema<IpamPrefixListResolverVersion>;
export type IpamPrefixListResolverVersionSet = IpamPrefixListResolverVersion[];
export const IpamPrefixListResolverVersionSet = S.Array(
  IpamPrefixListResolverVersion.pipe(T.XmlName("item")).annotate({
    identifier: "IpamPrefixListResolverVersion",
  }),
);
export interface GetIpamPrefixListResolverVersionsResult {
  IpamPrefixListResolverVersions?: IpamPrefixListResolverVersion[];
  NextToken?: string;
}
export const GetIpamPrefixListResolverVersionsResult = S.suspend(() =>
  S.Struct({
    IpamPrefixListResolverVersions: S.optional(
      IpamPrefixListResolverVersionSet,
    ).pipe(
      T.XmlName("ipamPrefixListResolverVersionSet"),
      T.Ec2QueryName("IpamPrefixListResolverVersionSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetIpamPrefixListResolverVersionsResult",
}) as any as S.Schema<GetIpamPrefixListResolverVersionsResult>;
export interface GetIpamResourceCidrsRequest {
  DryRun?: boolean;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  IpamScopeId?: string;
  IpamPoolId?: string;
  ResourceId?: string;
  ResourceType?: IpamResourceType;
  ResourceTag?: RequestIpamResourceTag;
  ResourceOwner?: string;
}
export const GetIpamResourceCidrsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    IpamScopeId: S.optional(S.String),
    IpamPoolId: S.optional(S.String),
    ResourceId: S.optional(S.String),
    ResourceType: S.optional(IpamResourceType),
    ResourceTag: S.optional(RequestIpamResourceTag),
    ResourceOwner: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetIpamResourceCidrsRequest",
}) as any as S.Schema<GetIpamResourceCidrsRequest>;
export type IpamManagementState =
  | "managed"
  | "unmanaged"
  | "ignored"
  | (string & {});
export const IpamManagementState = S.String;
export interface IpamResourceCidr {
  IpamId?: string;
  IpamScopeId?: string;
  IpamPoolId?: string;
  ResourceRegion?: string;
  ResourceOwnerId?: string;
  ResourceId?: string;
  ResourceName?: string;
  ResourceCidr?: string;
  ResourceType?: IpamResourceType;
  ResourceTags?: IpamResourceTag[];
  IpUsage?: number;
  ComplianceStatus?: IpamComplianceStatus;
  ManagementState?: IpamManagementState;
  OverlapStatus?: IpamOverlapStatus;
  VpcId?: string;
  AvailabilityZoneId?: string;
}
export const IpamResourceCidr = S.suspend(() =>
  S.Struct({
    IpamId: S.optional(S.String).pipe(
      T.XmlName("ipamId"),
      T.Ec2QueryName("IpamId"),
    ),
    IpamScopeId: S.optional(S.String).pipe(
      T.XmlName("ipamScopeId"),
      T.Ec2QueryName("IpamScopeId"),
    ),
    IpamPoolId: S.optional(S.String).pipe(
      T.XmlName("ipamPoolId"),
      T.Ec2QueryName("IpamPoolId"),
    ),
    ResourceRegion: S.optional(S.String).pipe(
      T.XmlName("resourceRegion"),
      T.Ec2QueryName("ResourceRegion"),
    ),
    ResourceOwnerId: S.optional(S.String).pipe(
      T.XmlName("resourceOwnerId"),
      T.Ec2QueryName("ResourceOwnerId"),
    ),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    ResourceName: S.optional(S.String).pipe(
      T.XmlName("resourceName"),
      T.Ec2QueryName("ResourceName"),
    ),
    ResourceCidr: S.optional(S.String).pipe(
      T.XmlName("resourceCidr"),
      T.Ec2QueryName("ResourceCidr"),
    ),
    ResourceType: S.optional(IpamResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    ResourceTags: S.optional(IpamResourceTagList).pipe(
      T.XmlName("resourceTagSet"),
      T.Ec2QueryName("ResourceTagSet"),
    ),
    IpUsage: S.optional(S.Number).pipe(
      T.XmlName("ipUsage"),
      T.Ec2QueryName("IpUsage"),
    ),
    ComplianceStatus: S.optional(IpamComplianceStatus).pipe(
      T.XmlName("complianceStatus"),
      T.Ec2QueryName("ComplianceStatus"),
    ),
    ManagementState: S.optional(IpamManagementState).pipe(
      T.XmlName("managementState"),
      T.Ec2QueryName("ManagementState"),
    ),
    OverlapStatus: S.optional(IpamOverlapStatus).pipe(
      T.XmlName("overlapStatus"),
      T.Ec2QueryName("OverlapStatus"),
    ),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
  }),
).annotate({
  identifier: "IpamResourceCidr",
}) as any as S.Schema<IpamResourceCidr>;
export type IpamResourceCidrSet = IpamResourceCidr[];
export const IpamResourceCidrSet = S.Array(
  IpamResourceCidr.pipe(T.XmlName("item")).annotate({
    identifier: "IpamResourceCidr",
  }),
);
export interface GetIpamResourceCidrsResult {
  NextToken?: string;
  IpamResourceCidrs?: IpamResourceCidr[];
}
export const GetIpamResourceCidrsResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    IpamResourceCidrs: S.optional(IpamResourceCidrSet).pipe(
      T.XmlName("ipamResourceCidrSet"),
      T.Ec2QueryName("IpamResourceCidrSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetIpamResourceCidrsResult",
}) as any as S.Schema<GetIpamResourceCidrsResult>;
export interface GetLaunchTemplateDataRequest {
  DryRun?: boolean;
  InstanceId?: string;
}
export const GetLaunchTemplateDataRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    InstanceId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetLaunchTemplateDataRequest",
}) as any as S.Schema<GetLaunchTemplateDataRequest>;
export interface GetLaunchTemplateDataResult {
  LaunchTemplateData?: ResponseLaunchTemplateData;
}
export const GetLaunchTemplateDataResult = S.suspend(() =>
  S.Struct({
    LaunchTemplateData: S.optional(ResponseLaunchTemplateData)
      .pipe(
        T.XmlName("launchTemplateData"),
        T.Ec2QueryName("LaunchTemplateData"),
      )
      .annotate({ identifier: "ResponseLaunchTemplateData" }),
  }).pipe(ns),
).annotate({
  identifier: "GetLaunchTemplateDataResult",
}) as any as S.Schema<GetLaunchTemplateDataResult>;
export interface GetManagedPrefixListAssociationsRequest {
  DryRun?: boolean;
  PrefixListId?: string;
  MaxResults?: number;
  NextToken?: string;
}
export const GetManagedPrefixListAssociationsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    PrefixListId: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetManagedPrefixListAssociationsRequest",
}) as any as S.Schema<GetManagedPrefixListAssociationsRequest>;
export interface PrefixListAssociation {
  ResourceId?: string;
  ResourceOwner?: string;
}
export const PrefixListAssociation = S.suspend(() =>
  S.Struct({
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    ResourceOwner: S.optional(S.String).pipe(
      T.XmlName("resourceOwner"),
      T.Ec2QueryName("ResourceOwner"),
    ),
  }),
).annotate({
  identifier: "PrefixListAssociation",
}) as any as S.Schema<PrefixListAssociation>;
export type PrefixListAssociationSet = PrefixListAssociation[];
export const PrefixListAssociationSet = S.Array(
  PrefixListAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "PrefixListAssociation",
  }),
);
export interface GetManagedPrefixListAssociationsResult {
  PrefixListAssociations?: PrefixListAssociation[];
  NextToken?: string;
}
export const GetManagedPrefixListAssociationsResult = S.suspend(() =>
  S.Struct({
    PrefixListAssociations: S.optional(PrefixListAssociationSet).pipe(
      T.XmlName("prefixListAssociationSet"),
      T.Ec2QueryName("PrefixListAssociationSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetManagedPrefixListAssociationsResult",
}) as any as S.Schema<GetManagedPrefixListAssociationsResult>;
export interface GetManagedPrefixListEntriesRequest {
  DryRun?: boolean;
  PrefixListId?: string;
  TargetVersion?: number;
  MaxResults?: number;
  NextToken?: string;
}
export const GetManagedPrefixListEntriesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    PrefixListId: S.optional(S.String),
    TargetVersion: S.optional(S.Number),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetManagedPrefixListEntriesRequest",
}) as any as S.Schema<GetManagedPrefixListEntriesRequest>;
export interface PrefixListEntry {
  Cidr?: string;
  Description?: string;
}
export const PrefixListEntry = S.suspend(() =>
  S.Struct({
    Cidr: S.optional(S.String).pipe(T.XmlName("cidr"), T.Ec2QueryName("Cidr")),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
  }),
).annotate({
  identifier: "PrefixListEntry",
}) as any as S.Schema<PrefixListEntry>;
export type PrefixListEntrySet = PrefixListEntry[];
export const PrefixListEntrySet = S.Array(
  PrefixListEntry.pipe(T.XmlName("item")).annotate({
    identifier: "PrefixListEntry",
  }),
);
export interface GetManagedPrefixListEntriesResult {
  Entries?: PrefixListEntry[];
  NextToken?: string;
}
export const GetManagedPrefixListEntriesResult = S.suspend(() =>
  S.Struct({
    Entries: S.optional(PrefixListEntrySet).pipe(
      T.XmlName("entrySet"),
      T.Ec2QueryName("EntrySet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetManagedPrefixListEntriesResult",
}) as any as S.Schema<GetManagedPrefixListEntriesResult>;
export interface GetNetworkInsightsAccessScopeAnalysisFindingsRequest {
  NetworkInsightsAccessScopeAnalysisId?: string;
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const GetNetworkInsightsAccessScopeAnalysisFindingsRequest = S.suspend(
  () =>
    S.Struct({
      NetworkInsightsAccessScopeAnalysisId: S.optional(S.String),
      MaxResults: S.optional(S.Number),
      NextToken: S.optional(S.String),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "GetNetworkInsightsAccessScopeAnalysisFindingsRequest",
}) as any as S.Schema<GetNetworkInsightsAccessScopeAnalysisFindingsRequest>;
export interface AccessScopeAnalysisFinding {
  NetworkInsightsAccessScopeAnalysisId?: string;
  NetworkInsightsAccessScopeId?: string;
  FindingId?: string;
  FindingComponents?: PathComponent[];
}
export const AccessScopeAnalysisFinding = S.suspend(() =>
  S.Struct({
    NetworkInsightsAccessScopeAnalysisId: S.optional(S.String).pipe(
      T.XmlName("networkInsightsAccessScopeAnalysisId"),
      T.Ec2QueryName("NetworkInsightsAccessScopeAnalysisId"),
    ),
    NetworkInsightsAccessScopeId: S.optional(S.String).pipe(
      T.XmlName("networkInsightsAccessScopeId"),
      T.Ec2QueryName("NetworkInsightsAccessScopeId"),
    ),
    FindingId: S.optional(S.String).pipe(
      T.XmlName("findingId"),
      T.Ec2QueryName("FindingId"),
    ),
    FindingComponents: S.optional(PathComponentList).pipe(
      T.XmlName("findingComponentSet"),
      T.Ec2QueryName("FindingComponentSet"),
    ),
  }),
).annotate({
  identifier: "AccessScopeAnalysisFinding",
}) as any as S.Schema<AccessScopeAnalysisFinding>;
export type AccessScopeAnalysisFindingList = AccessScopeAnalysisFinding[];
export const AccessScopeAnalysisFindingList = S.Array(
  AccessScopeAnalysisFinding.pipe(T.XmlName("item")).annotate({
    identifier: "AccessScopeAnalysisFinding",
  }),
);
export interface GetNetworkInsightsAccessScopeAnalysisFindingsResult {
  NetworkInsightsAccessScopeAnalysisId?: string;
  AnalysisStatus?: AnalysisStatus;
  AnalysisFindings?: AccessScopeAnalysisFinding[];
  NextToken?: string;
}
export const GetNetworkInsightsAccessScopeAnalysisFindingsResult = S.suspend(
  () =>
    S.Struct({
      NetworkInsightsAccessScopeAnalysisId: S.optional(S.String).pipe(
        T.XmlName("networkInsightsAccessScopeAnalysisId"),
        T.Ec2QueryName("NetworkInsightsAccessScopeAnalysisId"),
      ),
      AnalysisStatus: S.optional(AnalysisStatus).pipe(
        T.XmlName("analysisStatus"),
        T.Ec2QueryName("AnalysisStatus"),
      ),
      AnalysisFindings: S.optional(AccessScopeAnalysisFindingList).pipe(
        T.XmlName("analysisFindingSet"),
        T.Ec2QueryName("AnalysisFindingSet"),
      ),
      NextToken: S.optional(S.String).pipe(
        T.XmlName("nextToken"),
        T.Ec2QueryName("NextToken"),
      ),
    }).pipe(ns),
).annotate({
  identifier: "GetNetworkInsightsAccessScopeAnalysisFindingsResult",
}) as any as S.Schema<GetNetworkInsightsAccessScopeAnalysisFindingsResult>;
export interface GetNetworkInsightsAccessScopeContentRequest {
  NetworkInsightsAccessScopeId?: string;
  DryRun?: boolean;
}
export const GetNetworkInsightsAccessScopeContentRequest = S.suspend(() =>
  S.Struct({
    NetworkInsightsAccessScopeId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetNetworkInsightsAccessScopeContentRequest",
}) as any as S.Schema<GetNetworkInsightsAccessScopeContentRequest>;
export interface GetNetworkInsightsAccessScopeContentResult {
  NetworkInsightsAccessScopeContent?: NetworkInsightsAccessScopeContent;
}
export const GetNetworkInsightsAccessScopeContentResult = S.suspend(() =>
  S.Struct({
    NetworkInsightsAccessScopeContent: S.optional(
      NetworkInsightsAccessScopeContent,
    )
      .pipe(
        T.XmlName("networkInsightsAccessScopeContent"),
        T.Ec2QueryName("NetworkInsightsAccessScopeContent"),
      )
      .annotate({ identifier: "NetworkInsightsAccessScopeContent" }),
  }).pipe(ns),
).annotate({
  identifier: "GetNetworkInsightsAccessScopeContentResult",
}) as any as S.Schema<GetNetworkInsightsAccessScopeContentResult>;
export interface GetPasswordDataRequest {
  InstanceId?: string;
  DryRun?: boolean;
}
export const GetPasswordDataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetPasswordDataRequest",
}) as any as S.Schema<GetPasswordDataRequest>;
export interface GetPasswordDataResult {
  InstanceId?: string;
  Timestamp?: Date;
  PasswordData?: string | redacted.Redacted<string>;
}
export const GetPasswordDataResult = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    Timestamp: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("timestamp"), T.Ec2QueryName("Timestamp")),
    PasswordData: S.optional(SensitiveString).pipe(
      T.XmlName("passwordData"),
      T.Ec2QueryName("PasswordData"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetPasswordDataResult",
}) as any as S.Schema<GetPasswordDataResult>;
export interface GetReservedInstancesExchangeQuoteRequest {
  DryRun?: boolean;
  ReservedInstanceIds?: string[];
  TargetConfigurations?: TargetConfigurationRequest[];
}
export const GetReservedInstancesExchangeQuoteRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ReservedInstanceIds: S.optional(ReservedInstanceIdSet).pipe(
      T.XmlName("ReservedInstanceId"),
    ),
    TargetConfigurations: S.optional(TargetConfigurationRequestSet).pipe(
      T.XmlName("TargetConfiguration"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetReservedInstancesExchangeQuoteRequest",
}) as any as S.Schema<GetReservedInstancesExchangeQuoteRequest>;
export interface ReservationValue {
  HourlyPrice?: string;
  RemainingTotalValue?: string;
  RemainingUpfrontValue?: string;
}
export const ReservationValue = S.suspend(() =>
  S.Struct({
    HourlyPrice: S.optional(S.String).pipe(
      T.XmlName("hourlyPrice"),
      T.Ec2QueryName("HourlyPrice"),
    ),
    RemainingTotalValue: S.optional(S.String).pipe(
      T.XmlName("remainingTotalValue"),
      T.Ec2QueryName("RemainingTotalValue"),
    ),
    RemainingUpfrontValue: S.optional(S.String).pipe(
      T.XmlName("remainingUpfrontValue"),
      T.Ec2QueryName("RemainingUpfrontValue"),
    ),
  }),
).annotate({
  identifier: "ReservationValue",
}) as any as S.Schema<ReservationValue>;
export interface ReservedInstanceReservationValue {
  ReservationValue?: ReservationValue;
  ReservedInstanceId?: string;
}
export const ReservedInstanceReservationValue = S.suspend(() =>
  S.Struct({
    ReservationValue: S.optional(ReservationValue)
      .pipe(T.XmlName("reservationValue"), T.Ec2QueryName("ReservationValue"))
      .annotate({ identifier: "ReservationValue" }),
    ReservedInstanceId: S.optional(S.String).pipe(
      T.XmlName("reservedInstanceId"),
      T.Ec2QueryName("ReservedInstanceId"),
    ),
  }),
).annotate({
  identifier: "ReservedInstanceReservationValue",
}) as any as S.Schema<ReservedInstanceReservationValue>;
export type ReservedInstanceReservationValueSet =
  ReservedInstanceReservationValue[];
export const ReservedInstanceReservationValueSet = S.Array(
  ReservedInstanceReservationValue.pipe(T.XmlName("item")).annotate({
    identifier: "ReservedInstanceReservationValue",
  }),
);
export interface TargetConfiguration {
  InstanceCount?: number;
  OfferingId?: string;
}
export const TargetConfiguration = S.suspend(() =>
  S.Struct({
    InstanceCount: S.optional(S.Number).pipe(
      T.XmlName("instanceCount"),
      T.Ec2QueryName("InstanceCount"),
    ),
    OfferingId: S.optional(S.String).pipe(
      T.XmlName("offeringId"),
      T.Ec2QueryName("OfferingId"),
    ),
  }),
).annotate({
  identifier: "TargetConfiguration",
}) as any as S.Schema<TargetConfiguration>;
export interface TargetReservationValue {
  ReservationValue?: ReservationValue;
  TargetConfiguration?: TargetConfiguration;
}
export const TargetReservationValue = S.suspend(() =>
  S.Struct({
    ReservationValue: S.optional(ReservationValue)
      .pipe(T.XmlName("reservationValue"), T.Ec2QueryName("ReservationValue"))
      .annotate({ identifier: "ReservationValue" }),
    TargetConfiguration: S.optional(TargetConfiguration)
      .pipe(
        T.XmlName("targetConfiguration"),
        T.Ec2QueryName("TargetConfiguration"),
      )
      .annotate({ identifier: "TargetConfiguration" }),
  }),
).annotate({
  identifier: "TargetReservationValue",
}) as any as S.Schema<TargetReservationValue>;
export type TargetReservationValueSet = TargetReservationValue[];
export const TargetReservationValueSet = S.Array(
  TargetReservationValue.pipe(T.XmlName("item")).annotate({
    identifier: "TargetReservationValue",
  }),
);
export interface GetReservedInstancesExchangeQuoteResult {
  CurrencyCode?: string;
  IsValidExchange?: boolean;
  OutputReservedInstancesWillExpireAt?: Date;
  PaymentDue?: string;
  ReservedInstanceValueRollup?: ReservationValue;
  ReservedInstanceValueSet?: ReservedInstanceReservationValue[];
  TargetConfigurationValueRollup?: ReservationValue;
  TargetConfigurationValueSet?: TargetReservationValue[];
  ValidationFailureReason?: string;
}
export const GetReservedInstancesExchangeQuoteResult = S.suspend(() =>
  S.Struct({
    CurrencyCode: S.optional(S.String).pipe(
      T.XmlName("currencyCode"),
      T.Ec2QueryName("CurrencyCode"),
    ),
    IsValidExchange: S.optional(S.Boolean).pipe(
      T.XmlName("isValidExchange"),
      T.Ec2QueryName("IsValidExchange"),
    ),
    OutputReservedInstancesWillExpireAt: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("outputReservedInstancesWillExpireAt"),
      T.Ec2QueryName("OutputReservedInstancesWillExpireAt"),
    ),
    PaymentDue: S.optional(S.String).pipe(
      T.XmlName("paymentDue"),
      T.Ec2QueryName("PaymentDue"),
    ),
    ReservedInstanceValueRollup: S.optional(ReservationValue)
      .pipe(
        T.XmlName("reservedInstanceValueRollup"),
        T.Ec2QueryName("ReservedInstanceValueRollup"),
      )
      .annotate({ identifier: "ReservationValue" }),
    ReservedInstanceValueSet: S.optional(
      ReservedInstanceReservationValueSet,
    ).pipe(
      T.XmlName("reservedInstanceValueSet"),
      T.Ec2QueryName("ReservedInstanceValueSet"),
    ),
    TargetConfigurationValueRollup: S.optional(ReservationValue)
      .pipe(
        T.XmlName("targetConfigurationValueRollup"),
        T.Ec2QueryName("TargetConfigurationValueRollup"),
      )
      .annotate({ identifier: "ReservationValue" }),
    TargetConfigurationValueSet: S.optional(TargetReservationValueSet).pipe(
      T.XmlName("targetConfigurationValueSet"),
      T.Ec2QueryName("TargetConfigurationValueSet"),
    ),
    ValidationFailureReason: S.optional(S.String).pipe(
      T.XmlName("validationFailureReason"),
      T.Ec2QueryName("ValidationFailureReason"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetReservedInstancesExchangeQuoteResult",
}) as any as S.Schema<GetReservedInstancesExchangeQuoteResult>;
export interface GetRouteServerAssociationsRequest {
  RouteServerId?: string;
  DryRun?: boolean;
}
export const GetRouteServerAssociationsRequest = S.suspend(() =>
  S.Struct({
    RouteServerId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetRouteServerAssociationsRequest",
}) as any as S.Schema<GetRouteServerAssociationsRequest>;
export type RouteServerAssociationsList = RouteServerAssociation[];
export const RouteServerAssociationsList = S.Array(
  RouteServerAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "RouteServerAssociation",
  }),
);
export interface GetRouteServerAssociationsResult {
  RouteServerAssociations?: RouteServerAssociation[];
}
export const GetRouteServerAssociationsResult = S.suspend(() =>
  S.Struct({
    RouteServerAssociations: S.optional(RouteServerAssociationsList).pipe(
      T.XmlName("routeServerAssociationSet"),
      T.Ec2QueryName("RouteServerAssociationSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetRouteServerAssociationsResult",
}) as any as S.Schema<GetRouteServerAssociationsResult>;
export interface GetRouteServerPropagationsRequest {
  RouteServerId?: string;
  RouteTableId?: string;
  DryRun?: boolean;
}
export const GetRouteServerPropagationsRequest = S.suspend(() =>
  S.Struct({
    RouteServerId: S.optional(S.String),
    RouteTableId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetRouteServerPropagationsRequest",
}) as any as S.Schema<GetRouteServerPropagationsRequest>;
export type RouteServerPropagationsList = RouteServerPropagation[];
export const RouteServerPropagationsList = S.Array(
  RouteServerPropagation.pipe(T.XmlName("item")).annotate({
    identifier: "RouteServerPropagation",
  }),
);
export interface GetRouteServerPropagationsResult {
  RouteServerPropagations?: RouteServerPropagation[];
}
export const GetRouteServerPropagationsResult = S.suspend(() =>
  S.Struct({
    RouteServerPropagations: S.optional(RouteServerPropagationsList).pipe(
      T.XmlName("routeServerPropagationSet"),
      T.Ec2QueryName("RouteServerPropagationSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetRouteServerPropagationsResult",
}) as any as S.Schema<GetRouteServerPropagationsResult>;
export interface GetRouteServerRoutingDatabaseRequest {
  RouteServerId?: string;
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
  Filters?: Filter[];
}
export const GetRouteServerRoutingDatabaseRequest = S.suspend(() =>
  S.Struct({
    RouteServerId: S.optional(S.String),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetRouteServerRoutingDatabaseRequest",
}) as any as S.Schema<GetRouteServerRoutingDatabaseRequest>;
export type RouteServerRouteInstallationStatus =
  | "installed"
  | "rejected"
  | (string & {});
export const RouteServerRouteInstallationStatus = S.String;
export interface RouteServerRouteInstallationDetail {
  RouteTableId?: string;
  RouteInstallationStatus?: RouteServerRouteInstallationStatus;
  RouteInstallationStatusReason?: string;
}
export const RouteServerRouteInstallationDetail = S.suspend(() =>
  S.Struct({
    RouteTableId: S.optional(S.String).pipe(
      T.XmlName("routeTableId"),
      T.Ec2QueryName("RouteTableId"),
    ),
    RouteInstallationStatus: S.optional(
      RouteServerRouteInstallationStatus,
    ).pipe(
      T.XmlName("routeInstallationStatus"),
      T.Ec2QueryName("RouteInstallationStatus"),
    ),
    RouteInstallationStatusReason: S.optional(S.String).pipe(
      T.XmlName("routeInstallationStatusReason"),
      T.Ec2QueryName("RouteInstallationStatusReason"),
    ),
  }),
).annotate({
  identifier: "RouteServerRouteInstallationDetail",
}) as any as S.Schema<RouteServerRouteInstallationDetail>;
export type RouteServerRouteInstallationDetails =
  RouteServerRouteInstallationDetail[];
export const RouteServerRouteInstallationDetails = S.Array(
  RouteServerRouteInstallationDetail.pipe(T.XmlName("item")).annotate({
    identifier: "RouteServerRouteInstallationDetail",
  }),
);
export type RouteServerRouteStatus = "in-rib" | "in-fib" | (string & {});
export const RouteServerRouteStatus = S.String;
export type AsPath = string[];
export const AsPath = S.Array(S.String.pipe(T.XmlName("item")));
export interface RouteServerRoute {
  RouteServerEndpointId?: string;
  RouteServerPeerId?: string;
  RouteInstallationDetails?: RouteServerRouteInstallationDetail[];
  RouteStatus?: RouteServerRouteStatus;
  Prefix?: string;
  AsPaths?: string[];
  Med?: number;
  NextHopIp?: string;
}
export const RouteServerRoute = S.suspend(() =>
  S.Struct({
    RouteServerEndpointId: S.optional(S.String).pipe(
      T.XmlName("routeServerEndpointId"),
      T.Ec2QueryName("RouteServerEndpointId"),
    ),
    RouteServerPeerId: S.optional(S.String).pipe(
      T.XmlName("routeServerPeerId"),
      T.Ec2QueryName("RouteServerPeerId"),
    ),
    RouteInstallationDetails: S.optional(
      RouteServerRouteInstallationDetails,
    ).pipe(
      T.XmlName("routeInstallationDetailSet"),
      T.Ec2QueryName("RouteInstallationDetailSet"),
    ),
    RouteStatus: S.optional(RouteServerRouteStatus).pipe(
      T.XmlName("routeStatus"),
      T.Ec2QueryName("RouteStatus"),
    ),
    Prefix: S.optional(S.String).pipe(
      T.XmlName("prefix"),
      T.Ec2QueryName("Prefix"),
    ),
    AsPaths: S.optional(AsPath).pipe(
      T.XmlName("asPathSet"),
      T.Ec2QueryName("AsPathSet"),
    ),
    Med: S.optional(S.Number).pipe(T.XmlName("med"), T.Ec2QueryName("Med")),
    NextHopIp: S.optional(S.String).pipe(
      T.XmlName("nextHopIp"),
      T.Ec2QueryName("NextHopIp"),
    ),
  }),
).annotate({
  identifier: "RouteServerRoute",
}) as any as S.Schema<RouteServerRoute>;
export type RouteServerRouteList = RouteServerRoute[];
export const RouteServerRouteList = S.Array(
  RouteServerRoute.pipe(T.XmlName("item")).annotate({
    identifier: "RouteServerRoute",
  }),
);
export interface GetRouteServerRoutingDatabaseResult {
  AreRoutesPersisted?: boolean;
  Routes?: RouteServerRoute[];
  NextToken?: string;
}
export const GetRouteServerRoutingDatabaseResult = S.suspend(() =>
  S.Struct({
    AreRoutesPersisted: S.optional(S.Boolean).pipe(
      T.XmlName("areRoutesPersisted"),
      T.Ec2QueryName("AreRoutesPersisted"),
    ),
    Routes: S.optional(RouteServerRouteList).pipe(
      T.XmlName("routeSet"),
      T.Ec2QueryName("RouteSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetRouteServerRoutingDatabaseResult",
}) as any as S.Schema<GetRouteServerRoutingDatabaseResult>;
export interface GetSecurityGroupsForVpcRequest {
  VpcId?: string;
  NextToken?: string;
  MaxResults?: number;
  Filters?: Filter[];
  DryRun?: boolean;
}
export const GetSecurityGroupsForVpcRequest = S.suspend(() =>
  S.Struct({
    VpcId: S.optional(S.String),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetSecurityGroupsForVpcRequest",
}) as any as S.Schema<GetSecurityGroupsForVpcRequest>;
export interface SecurityGroupForVpc {
  Description?: string;
  GroupName?: string;
  OwnerId?: string;
  GroupId?: string;
  Tags?: Tag[];
  PrimaryVpcId?: string;
}
export const SecurityGroupForVpc = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    GroupName: S.optional(S.String).pipe(
      T.XmlName("groupName"),
      T.Ec2QueryName("GroupName"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    PrimaryVpcId: S.optional(S.String).pipe(
      T.XmlName("primaryVpcId"),
      T.Ec2QueryName("PrimaryVpcId"),
    ),
  }),
).annotate({
  identifier: "SecurityGroupForVpc",
}) as any as S.Schema<SecurityGroupForVpc>;
export type SecurityGroupForVpcList = SecurityGroupForVpc[];
export const SecurityGroupForVpcList = S.Array(
  SecurityGroupForVpc.pipe(T.XmlName("item")).annotate({
    identifier: "SecurityGroupForVpc",
  }),
);
export interface GetSecurityGroupsForVpcResult {
  NextToken?: string;
  SecurityGroupForVpcs?: SecurityGroupForVpc[];
}
export const GetSecurityGroupsForVpcResult = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
    SecurityGroupForVpcs: S.optional(SecurityGroupForVpcList).pipe(
      T.XmlName("securityGroupForVpcSet"),
      T.Ec2QueryName("SecurityGroupForVpcSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetSecurityGroupsForVpcResult",
}) as any as S.Schema<GetSecurityGroupsForVpcResult>;
export interface GetSerialConsoleAccessStatusRequest {
  DryRun?: boolean;
}
export const GetSerialConsoleAccessStatusRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetSerialConsoleAccessStatusRequest",
}) as any as S.Schema<GetSerialConsoleAccessStatusRequest>;
export interface GetSerialConsoleAccessStatusResult {
  SerialConsoleAccessEnabled?: boolean;
  ManagedBy?: ManagedBy;
}
export const GetSerialConsoleAccessStatusResult = S.suspend(() =>
  S.Struct({
    SerialConsoleAccessEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("serialConsoleAccessEnabled"),
      T.Ec2QueryName("SerialConsoleAccessEnabled"),
    ),
    ManagedBy: S.optional(ManagedBy).pipe(
      T.XmlName("managedBy"),
      T.Ec2QueryName("ManagedBy"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetSerialConsoleAccessStatusResult",
}) as any as S.Schema<GetSerialConsoleAccessStatusResult>;
export interface GetSnapshotBlockPublicAccessStateRequest {
  DryRun?: boolean;
}
export const GetSnapshotBlockPublicAccessStateRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetSnapshotBlockPublicAccessStateRequest",
}) as any as S.Schema<GetSnapshotBlockPublicAccessStateRequest>;
export interface GetSnapshotBlockPublicAccessStateResult {
  State?: SnapshotBlockPublicAccessState;
  ManagedBy?: ManagedBy;
}
export const GetSnapshotBlockPublicAccessStateResult = S.suspend(() =>
  S.Struct({
    State: S.optional(SnapshotBlockPublicAccessState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    ManagedBy: S.optional(ManagedBy).pipe(
      T.XmlName("managedBy"),
      T.Ec2QueryName("ManagedBy"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetSnapshotBlockPublicAccessStateResult",
}) as any as S.Schema<GetSnapshotBlockPublicAccessStateResult>;
export type InstanceTypes = string[];
export const InstanceTypes = S.Array(S.String);
export type RegionNames = string[];
export const RegionNames = S.Array(S.String);
export interface InstanceRequirementsWithMetadataRequest {
  ArchitectureTypes?: ArchitectureType[];
  VirtualizationTypes?: VirtualizationType[];
  InstanceRequirements?: InstanceRequirementsRequest;
}
export const InstanceRequirementsWithMetadataRequest = S.suspend(() =>
  S.Struct({
    ArchitectureTypes: S.optional(ArchitectureTypeSet).pipe(
      T.XmlName("ArchitectureType"),
    ),
    VirtualizationTypes: S.optional(VirtualizationTypeSet).pipe(
      T.XmlName("VirtualizationType"),
    ),
    InstanceRequirements: S.optional(InstanceRequirementsRequest),
  }),
).annotate({
  identifier: "InstanceRequirementsWithMetadataRequest",
}) as any as S.Schema<InstanceRequirementsWithMetadataRequest>;
export interface GetSpotPlacementScoresRequest {
  InstanceTypes?: string[];
  TargetCapacity?: number;
  TargetCapacityUnitType?: TargetCapacityUnitType;
  SingleAvailabilityZone?: boolean;
  RegionNames?: string[];
  InstanceRequirementsWithMetadata?: InstanceRequirementsWithMetadataRequest;
  DryRun?: boolean;
  MaxResults?: number;
  NextToken?: string;
}
export const GetSpotPlacementScoresRequest = S.suspend(() =>
  S.Struct({
    InstanceTypes: S.optional(InstanceTypes).pipe(T.XmlName("InstanceType")),
    TargetCapacity: S.optional(S.Number),
    TargetCapacityUnitType: S.optional(TargetCapacityUnitType),
    SingleAvailabilityZone: S.optional(S.Boolean),
    RegionNames: S.optional(RegionNames).pipe(T.XmlName("RegionName")),
    InstanceRequirementsWithMetadata: S.optional(
      InstanceRequirementsWithMetadataRequest,
    ),
    DryRun: S.optional(S.Boolean),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetSpotPlacementScoresRequest",
}) as any as S.Schema<GetSpotPlacementScoresRequest>;
export interface SpotPlacementScore {
  Region?: string;
  AvailabilityZoneId?: string;
  Score?: number;
}
export const SpotPlacementScore = S.suspend(() =>
  S.Struct({
    Region: S.optional(S.String).pipe(
      T.XmlName("region"),
      T.Ec2QueryName("Region"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    Score: S.optional(S.Number).pipe(
      T.XmlName("score"),
      T.Ec2QueryName("Score"),
    ),
  }),
).annotate({
  identifier: "SpotPlacementScore",
}) as any as S.Schema<SpotPlacementScore>;
export type SpotPlacementScores = SpotPlacementScore[];
export const SpotPlacementScores = S.Array(
  SpotPlacementScore.pipe(T.XmlName("item")).annotate({
    identifier: "SpotPlacementScore",
  }),
);
export interface GetSpotPlacementScoresResult {
  SpotPlacementScores?: SpotPlacementScore[];
  NextToken?: string;
}
export const GetSpotPlacementScoresResult = S.suspend(() =>
  S.Struct({
    SpotPlacementScores: S.optional(SpotPlacementScores).pipe(
      T.XmlName("spotPlacementScoreSet"),
      T.Ec2QueryName("SpotPlacementScoreSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetSpotPlacementScoresResult",
}) as any as S.Schema<GetSpotPlacementScoresResult>;
export interface GetSubnetCidrReservationsRequest {
  Filters?: Filter[];
  SubnetId?: string;
  DryRun?: boolean;
  NextToken?: string;
  MaxResults?: number;
}
export const GetSubnetCidrReservationsRequest = S.suspend(() =>
  S.Struct({
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    SubnetId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetSubnetCidrReservationsRequest",
}) as any as S.Schema<GetSubnetCidrReservationsRequest>;
export type SubnetCidrReservationList = SubnetCidrReservation[];
export const SubnetCidrReservationList = S.Array(
  SubnetCidrReservation.pipe(T.XmlName("item")).annotate({
    identifier: "SubnetCidrReservation",
  }),
);
export interface GetSubnetCidrReservationsResult {
  SubnetIpv4CidrReservations?: SubnetCidrReservation[];
  SubnetIpv6CidrReservations?: SubnetCidrReservation[];
  NextToken?: string;
}
export const GetSubnetCidrReservationsResult = S.suspend(() =>
  S.Struct({
    SubnetIpv4CidrReservations: S.optional(SubnetCidrReservationList).pipe(
      T.XmlName("subnetIpv4CidrReservationSet"),
      T.Ec2QueryName("SubnetIpv4CidrReservationSet"),
    ),
    SubnetIpv6CidrReservations: S.optional(SubnetCidrReservationList).pipe(
      T.XmlName("subnetIpv6CidrReservationSet"),
      T.Ec2QueryName("SubnetIpv6CidrReservationSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetSubnetCidrReservationsResult",
}) as any as S.Schema<GetSubnetCidrReservationsResult>;
export interface GetTransitGatewayAttachmentPropagationsRequest {
  TransitGatewayAttachmentId?: string;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const GetTransitGatewayAttachmentPropagationsRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetTransitGatewayAttachmentPropagationsRequest",
}) as any as S.Schema<GetTransitGatewayAttachmentPropagationsRequest>;
export interface TransitGatewayAttachmentPropagation {
  TransitGatewayRouteTableId?: string;
  State?: TransitGatewayPropagationState;
}
export const TransitGatewayAttachmentPropagation = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayRouteTableId"),
      T.Ec2QueryName("TransitGatewayRouteTableId"),
    ),
    State: S.optional(TransitGatewayPropagationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayAttachmentPropagation",
}) as any as S.Schema<TransitGatewayAttachmentPropagation>;
export type TransitGatewayAttachmentPropagationList =
  TransitGatewayAttachmentPropagation[];
export const TransitGatewayAttachmentPropagationList = S.Array(
  TransitGatewayAttachmentPropagation.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayAttachmentPropagation",
  }),
);
export interface GetTransitGatewayAttachmentPropagationsResult {
  TransitGatewayAttachmentPropagations?: TransitGatewayAttachmentPropagation[];
  NextToken?: string;
}
export const GetTransitGatewayAttachmentPropagationsResult = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentPropagations: S.optional(
      TransitGatewayAttachmentPropagationList,
    ).pipe(
      T.XmlName("transitGatewayAttachmentPropagations"),
      T.Ec2QueryName("TransitGatewayAttachmentPropagations"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetTransitGatewayAttachmentPropagationsResult",
}) as any as S.Schema<GetTransitGatewayAttachmentPropagationsResult>;
export interface GetTransitGatewayMeteringPolicyEntriesRequest {
  TransitGatewayMeteringPolicyId?: string;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const GetTransitGatewayMeteringPolicyEntriesRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayMeteringPolicyId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetTransitGatewayMeteringPolicyEntriesRequest",
}) as any as S.Schema<GetTransitGatewayMeteringPolicyEntriesRequest>;
export type TransitGatewayMeteringPolicyEntryList =
  TransitGatewayMeteringPolicyEntry[];
export const TransitGatewayMeteringPolicyEntryList = S.Array(
  TransitGatewayMeteringPolicyEntry.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayMeteringPolicyEntry",
  }),
);
export interface GetTransitGatewayMeteringPolicyEntriesResult {
  TransitGatewayMeteringPolicyEntries?: TransitGatewayMeteringPolicyEntry[];
  NextToken?: string;
}
export const GetTransitGatewayMeteringPolicyEntriesResult = S.suspend(() =>
  S.Struct({
    TransitGatewayMeteringPolicyEntries: S.optional(
      TransitGatewayMeteringPolicyEntryList,
    ).pipe(
      T.XmlName("transitGatewayMeteringPolicyEntries"),
      T.Ec2QueryName("TransitGatewayMeteringPolicyEntries"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetTransitGatewayMeteringPolicyEntriesResult",
}) as any as S.Schema<GetTransitGatewayMeteringPolicyEntriesResult>;
export interface GetTransitGatewayMulticastDomainAssociationsRequest {
  TransitGatewayMulticastDomainId?: string;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const GetTransitGatewayMulticastDomainAssociationsRequest = S.suspend(
  () =>
    S.Struct({
      TransitGatewayMulticastDomainId: S.optional(S.String),
      Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
      MaxResults: S.optional(S.Number),
      NextToken: S.optional(S.String),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "GetTransitGatewayMulticastDomainAssociationsRequest",
}) as any as S.Schema<GetTransitGatewayMulticastDomainAssociationsRequest>;
export interface TransitGatewayMulticastDomainAssociation {
  TransitGatewayAttachmentId?: string;
  ResourceId?: string;
  ResourceType?: TransitGatewayAttachmentResourceType;
  ResourceOwnerId?: string;
  Subnet?: SubnetAssociation;
}
export const TransitGatewayMulticastDomainAssociation = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayAttachmentId"),
      T.Ec2QueryName("TransitGatewayAttachmentId"),
    ),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    ResourceType: S.optional(TransitGatewayAttachmentResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    ResourceOwnerId: S.optional(S.String).pipe(
      T.XmlName("resourceOwnerId"),
      T.Ec2QueryName("ResourceOwnerId"),
    ),
    Subnet: S.optional(SubnetAssociation)
      .pipe(T.XmlName("subnet"), T.Ec2QueryName("Subnet"))
      .annotate({ identifier: "SubnetAssociation" }),
  }),
).annotate({
  identifier: "TransitGatewayMulticastDomainAssociation",
}) as any as S.Schema<TransitGatewayMulticastDomainAssociation>;
export type TransitGatewayMulticastDomainAssociationList =
  TransitGatewayMulticastDomainAssociation[];
export const TransitGatewayMulticastDomainAssociationList = S.Array(
  TransitGatewayMulticastDomainAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayMulticastDomainAssociation",
  }),
);
export interface GetTransitGatewayMulticastDomainAssociationsResult {
  MulticastDomainAssociations?: TransitGatewayMulticastDomainAssociation[];
  NextToken?: string;
}
export const GetTransitGatewayMulticastDomainAssociationsResult = S.suspend(
  () =>
    S.Struct({
      MulticastDomainAssociations: S.optional(
        TransitGatewayMulticastDomainAssociationList,
      ).pipe(
        T.XmlName("multicastDomainAssociations"),
        T.Ec2QueryName("MulticastDomainAssociations"),
      ),
      NextToken: S.optional(S.String).pipe(
        T.XmlName("nextToken"),
        T.Ec2QueryName("NextToken"),
      ),
    }).pipe(ns),
).annotate({
  identifier: "GetTransitGatewayMulticastDomainAssociationsResult",
}) as any as S.Schema<GetTransitGatewayMulticastDomainAssociationsResult>;
export interface GetTransitGatewayPolicyTableAssociationsRequest {
  TransitGatewayPolicyTableId?: string;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const GetTransitGatewayPolicyTableAssociationsRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayPolicyTableId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetTransitGatewayPolicyTableAssociationsRequest",
}) as any as S.Schema<GetTransitGatewayPolicyTableAssociationsRequest>;
export type TransitGatewayPolicyTableAssociationList =
  TransitGatewayPolicyTableAssociation[];
export const TransitGatewayPolicyTableAssociationList = S.Array(
  TransitGatewayPolicyTableAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayPolicyTableAssociation",
  }),
);
export interface GetTransitGatewayPolicyTableAssociationsResult {
  Associations?: TransitGatewayPolicyTableAssociation[];
  NextToken?: string;
}
export const GetTransitGatewayPolicyTableAssociationsResult = S.suspend(() =>
  S.Struct({
    Associations: S.optional(TransitGatewayPolicyTableAssociationList).pipe(
      T.XmlName("associations"),
      T.Ec2QueryName("Associations"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetTransitGatewayPolicyTableAssociationsResult",
}) as any as S.Schema<GetTransitGatewayPolicyTableAssociationsResult>;
export interface GetTransitGatewayPolicyTableEntriesRequest {
  TransitGatewayPolicyTableId?: string;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const GetTransitGatewayPolicyTableEntriesRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayPolicyTableId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetTransitGatewayPolicyTableEntriesRequest",
}) as any as S.Schema<GetTransitGatewayPolicyTableEntriesRequest>;
export interface TransitGatewayPolicyRuleMetaData {
  MetaDataKey?: string;
  MetaDataValue?: string;
}
export const TransitGatewayPolicyRuleMetaData = S.suspend(() =>
  S.Struct({
    MetaDataKey: S.optional(S.String).pipe(
      T.XmlName("metaDataKey"),
      T.Ec2QueryName("MetaDataKey"),
    ),
    MetaDataValue: S.optional(S.String).pipe(
      T.XmlName("metaDataValue"),
      T.Ec2QueryName("MetaDataValue"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayPolicyRuleMetaData",
}) as any as S.Schema<TransitGatewayPolicyRuleMetaData>;
export interface TransitGatewayPolicyRule {
  SourceCidrBlock?: string;
  SourcePortRange?: string;
  DestinationCidrBlock?: string;
  DestinationPortRange?: string;
  Protocol?: string;
  MetaData?: TransitGatewayPolicyRuleMetaData;
}
export const TransitGatewayPolicyRule = S.suspend(() =>
  S.Struct({
    SourceCidrBlock: S.optional(S.String).pipe(
      T.XmlName("sourceCidrBlock"),
      T.Ec2QueryName("SourceCidrBlock"),
    ),
    SourcePortRange: S.optional(S.String).pipe(
      T.XmlName("sourcePortRange"),
      T.Ec2QueryName("SourcePortRange"),
    ),
    DestinationCidrBlock: S.optional(S.String).pipe(
      T.XmlName("destinationCidrBlock"),
      T.Ec2QueryName("DestinationCidrBlock"),
    ),
    DestinationPortRange: S.optional(S.String).pipe(
      T.XmlName("destinationPortRange"),
      T.Ec2QueryName("DestinationPortRange"),
    ),
    Protocol: S.optional(S.String).pipe(
      T.XmlName("protocol"),
      T.Ec2QueryName("Protocol"),
    ),
    MetaData: S.optional(TransitGatewayPolicyRuleMetaData)
      .pipe(T.XmlName("metaData"), T.Ec2QueryName("MetaData"))
      .annotate({ identifier: "TransitGatewayPolicyRuleMetaData" }),
  }),
).annotate({
  identifier: "TransitGatewayPolicyRule",
}) as any as S.Schema<TransitGatewayPolicyRule>;
export interface TransitGatewayPolicyTableEntry {
  PolicyRuleNumber?: string;
  PolicyRule?: TransitGatewayPolicyRule;
  TargetRouteTableId?: string;
}
export const TransitGatewayPolicyTableEntry = S.suspend(() =>
  S.Struct({
    PolicyRuleNumber: S.optional(S.String).pipe(
      T.XmlName("policyRuleNumber"),
      T.Ec2QueryName("PolicyRuleNumber"),
    ),
    PolicyRule: S.optional(TransitGatewayPolicyRule)
      .pipe(T.XmlName("policyRule"), T.Ec2QueryName("PolicyRule"))
      .annotate({ identifier: "TransitGatewayPolicyRule" }),
    TargetRouteTableId: S.optional(S.String).pipe(
      T.XmlName("targetRouteTableId"),
      T.Ec2QueryName("TargetRouteTableId"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayPolicyTableEntry",
}) as any as S.Schema<TransitGatewayPolicyTableEntry>;
export type TransitGatewayPolicyTableEntryList =
  TransitGatewayPolicyTableEntry[];
export const TransitGatewayPolicyTableEntryList = S.Array(
  TransitGatewayPolicyTableEntry.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayPolicyTableEntry",
  }),
);
export interface GetTransitGatewayPolicyTableEntriesResult {
  TransitGatewayPolicyTableEntries?: TransitGatewayPolicyTableEntry[];
}
export const GetTransitGatewayPolicyTableEntriesResult = S.suspend(() =>
  S.Struct({
    TransitGatewayPolicyTableEntries: S.optional(
      TransitGatewayPolicyTableEntryList,
    ).pipe(
      T.XmlName("transitGatewayPolicyTableEntries"),
      T.Ec2QueryName("TransitGatewayPolicyTableEntries"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetTransitGatewayPolicyTableEntriesResult",
}) as any as S.Schema<GetTransitGatewayPolicyTableEntriesResult>;
export interface GetTransitGatewayPrefixListReferencesRequest {
  TransitGatewayRouteTableId?: string;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const GetTransitGatewayPrefixListReferencesRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetTransitGatewayPrefixListReferencesRequest",
}) as any as S.Schema<GetTransitGatewayPrefixListReferencesRequest>;
export type TransitGatewayPrefixListReferenceSet =
  TransitGatewayPrefixListReference[];
export const TransitGatewayPrefixListReferenceSet = S.Array(
  TransitGatewayPrefixListReference.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayPrefixListReference",
  }),
);
export interface GetTransitGatewayPrefixListReferencesResult {
  TransitGatewayPrefixListReferences?: TransitGatewayPrefixListReference[];
  NextToken?: string;
}
export const GetTransitGatewayPrefixListReferencesResult = S.suspend(() =>
  S.Struct({
    TransitGatewayPrefixListReferences: S.optional(
      TransitGatewayPrefixListReferenceSet,
    ).pipe(
      T.XmlName("transitGatewayPrefixListReferenceSet"),
      T.Ec2QueryName("TransitGatewayPrefixListReferenceSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetTransitGatewayPrefixListReferencesResult",
}) as any as S.Schema<GetTransitGatewayPrefixListReferencesResult>;
export interface GetTransitGatewayRouteTableAssociationsRequest {
  TransitGatewayRouteTableId?: string;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const GetTransitGatewayRouteTableAssociationsRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetTransitGatewayRouteTableAssociationsRequest",
}) as any as S.Schema<GetTransitGatewayRouteTableAssociationsRequest>;
export interface TransitGatewayRouteTableAssociation {
  TransitGatewayAttachmentId?: string;
  ResourceId?: string;
  ResourceType?: TransitGatewayAttachmentResourceType;
  State?: TransitGatewayAssociationState;
}
export const TransitGatewayRouteTableAssociation = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayAttachmentId"),
      T.Ec2QueryName("TransitGatewayAttachmentId"),
    ),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    ResourceType: S.optional(TransitGatewayAttachmentResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    State: S.optional(TransitGatewayAssociationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayRouteTableAssociation",
}) as any as S.Schema<TransitGatewayRouteTableAssociation>;
export type TransitGatewayRouteTableAssociationList =
  TransitGatewayRouteTableAssociation[];
export const TransitGatewayRouteTableAssociationList = S.Array(
  TransitGatewayRouteTableAssociation.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayRouteTableAssociation",
  }),
);
export interface GetTransitGatewayRouteTableAssociationsResult {
  Associations?: TransitGatewayRouteTableAssociation[];
  NextToken?: string;
}
export const GetTransitGatewayRouteTableAssociationsResult = S.suspend(() =>
  S.Struct({
    Associations: S.optional(TransitGatewayRouteTableAssociationList).pipe(
      T.XmlName("associations"),
      T.Ec2QueryName("Associations"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetTransitGatewayRouteTableAssociationsResult",
}) as any as S.Schema<GetTransitGatewayRouteTableAssociationsResult>;
export interface GetTransitGatewayRouteTablePropagationsRequest {
  TransitGatewayRouteTableId?: string;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const GetTransitGatewayRouteTablePropagationsRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetTransitGatewayRouteTablePropagationsRequest",
}) as any as S.Schema<GetTransitGatewayRouteTablePropagationsRequest>;
export interface TransitGatewayRouteTablePropagation {
  TransitGatewayAttachmentId?: string;
  ResourceId?: string;
  ResourceType?: TransitGatewayAttachmentResourceType;
  State?: TransitGatewayPropagationState;
  TransitGatewayRouteTableAnnouncementId?: string;
}
export const TransitGatewayRouteTablePropagation = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayAttachmentId"),
      T.Ec2QueryName("TransitGatewayAttachmentId"),
    ),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    ResourceType: S.optional(TransitGatewayAttachmentResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    State: S.optional(TransitGatewayPropagationState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    TransitGatewayRouteTableAnnouncementId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayRouteTableAnnouncementId"),
      T.Ec2QueryName("TransitGatewayRouteTableAnnouncementId"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayRouteTablePropagation",
}) as any as S.Schema<TransitGatewayRouteTablePropagation>;
export type TransitGatewayRouteTablePropagationList =
  TransitGatewayRouteTablePropagation[];
export const TransitGatewayRouteTablePropagationList = S.Array(
  TransitGatewayRouteTablePropagation.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayRouteTablePropagation",
  }),
);
export interface GetTransitGatewayRouteTablePropagationsResult {
  TransitGatewayRouteTablePropagations?: TransitGatewayRouteTablePropagation[];
  NextToken?: string;
}
export const GetTransitGatewayRouteTablePropagationsResult = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTablePropagations: S.optional(
      TransitGatewayRouteTablePropagationList,
    ).pipe(
      T.XmlName("transitGatewayRouteTablePropagations"),
      T.Ec2QueryName("TransitGatewayRouteTablePropagations"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetTransitGatewayRouteTablePropagationsResult",
}) as any as S.Schema<GetTransitGatewayRouteTablePropagationsResult>;
export interface GetVerifiedAccessEndpointPolicyRequest {
  VerifiedAccessEndpointId?: string;
  DryRun?: boolean;
}
export const GetVerifiedAccessEndpointPolicyRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessEndpointId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetVerifiedAccessEndpointPolicyRequest",
}) as any as S.Schema<GetVerifiedAccessEndpointPolicyRequest>;
export interface GetVerifiedAccessEndpointPolicyResult {
  PolicyEnabled?: boolean;
  PolicyDocument?: string;
}
export const GetVerifiedAccessEndpointPolicyResult = S.suspend(() =>
  S.Struct({
    PolicyEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("policyEnabled"),
      T.Ec2QueryName("PolicyEnabled"),
    ),
    PolicyDocument: S.optional(S.String).pipe(
      T.XmlName("policyDocument"),
      T.Ec2QueryName("PolicyDocument"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetVerifiedAccessEndpointPolicyResult",
}) as any as S.Schema<GetVerifiedAccessEndpointPolicyResult>;
export interface GetVerifiedAccessEndpointTargetsRequest {
  VerifiedAccessEndpointId?: string;
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const GetVerifiedAccessEndpointTargetsRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessEndpointId: S.optional(S.String).pipe(
      T.XmlName("VerifiedAccessEndpointId"),
    ),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetVerifiedAccessEndpointTargetsRequest",
}) as any as S.Schema<GetVerifiedAccessEndpointTargetsRequest>;
export interface VerifiedAccessEndpointTarget {
  VerifiedAccessEndpointId?: string;
  VerifiedAccessEndpointTargetIpAddress?: string;
  VerifiedAccessEndpointTargetDns?: string;
}
export const VerifiedAccessEndpointTarget = S.suspend(() =>
  S.Struct({
    VerifiedAccessEndpointId: S.optional(S.String).pipe(
      T.XmlName("verifiedAccessEndpointId"),
      T.Ec2QueryName("VerifiedAccessEndpointId"),
    ),
    VerifiedAccessEndpointTargetIpAddress: S.optional(S.String).pipe(
      T.XmlName("verifiedAccessEndpointTargetIpAddress"),
      T.Ec2QueryName("VerifiedAccessEndpointTargetIpAddress"),
    ),
    VerifiedAccessEndpointTargetDns: S.optional(S.String).pipe(
      T.XmlName("verifiedAccessEndpointTargetDns"),
      T.Ec2QueryName("VerifiedAccessEndpointTargetDns"),
    ),
  }),
).annotate({
  identifier: "VerifiedAccessEndpointTarget",
}) as any as S.Schema<VerifiedAccessEndpointTarget>;
export type VerifiedAccessEndpointTargetList = VerifiedAccessEndpointTarget[];
export const VerifiedAccessEndpointTargetList = S.Array(
  VerifiedAccessEndpointTarget.pipe(T.XmlName("item")).annotate({
    identifier: "VerifiedAccessEndpointTarget",
  }),
);
export interface GetVerifiedAccessEndpointTargetsResult {
  VerifiedAccessEndpointTargets?: VerifiedAccessEndpointTarget[];
  NextToken?: string;
}
export const GetVerifiedAccessEndpointTargetsResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessEndpointTargets: S.optional(
      VerifiedAccessEndpointTargetList,
    ).pipe(
      T.XmlName("verifiedAccessEndpointTargetSet"),
      T.Ec2QueryName("VerifiedAccessEndpointTargetSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetVerifiedAccessEndpointTargetsResult",
}) as any as S.Schema<GetVerifiedAccessEndpointTargetsResult>;
export interface GetVerifiedAccessGroupPolicyRequest {
  VerifiedAccessGroupId?: string;
  DryRun?: boolean;
}
export const GetVerifiedAccessGroupPolicyRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessGroupId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetVerifiedAccessGroupPolicyRequest",
}) as any as S.Schema<GetVerifiedAccessGroupPolicyRequest>;
export interface GetVerifiedAccessGroupPolicyResult {
  PolicyEnabled?: boolean;
  PolicyDocument?: string;
}
export const GetVerifiedAccessGroupPolicyResult = S.suspend(() =>
  S.Struct({
    PolicyEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("policyEnabled"),
      T.Ec2QueryName("PolicyEnabled"),
    ),
    PolicyDocument: S.optional(S.String).pipe(
      T.XmlName("policyDocument"),
      T.Ec2QueryName("PolicyDocument"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetVerifiedAccessGroupPolicyResult",
}) as any as S.Schema<GetVerifiedAccessGroupPolicyResult>;
export interface GetVpcResourcesBlockingEncryptionEnforcementRequest {
  VpcId?: string;
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const GetVpcResourcesBlockingEncryptionEnforcementRequest = S.suspend(
  () =>
    S.Struct({
      VpcId: S.optional(S.String),
      MaxResults: S.optional(S.Number),
      NextToken: S.optional(S.String),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "GetVpcResourcesBlockingEncryptionEnforcementRequest",
}) as any as S.Schema<GetVpcResourcesBlockingEncryptionEnforcementRequest>;
export interface VpcEncryptionNonCompliantResource {
  Id?: string;
  Type?: string;
  Description?: string;
  IsExcludable?: boolean;
}
export const VpcEncryptionNonCompliantResource = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String).pipe(T.XmlName("id"), T.Ec2QueryName("Id")),
    Type: S.optional(S.String).pipe(T.XmlName("type"), T.Ec2QueryName("Type")),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    IsExcludable: S.optional(S.Boolean).pipe(
      T.XmlName("isExcludable"),
      T.Ec2QueryName("IsExcludable"),
    ),
  }),
).annotate({
  identifier: "VpcEncryptionNonCompliantResource",
}) as any as S.Schema<VpcEncryptionNonCompliantResource>;
export type VpcEncryptionNonCompliantResourceList =
  VpcEncryptionNonCompliantResource[];
export const VpcEncryptionNonCompliantResourceList = S.Array(
  VpcEncryptionNonCompliantResource.pipe(T.XmlName("item")).annotate({
    identifier: "VpcEncryptionNonCompliantResource",
  }),
);
export interface GetVpcResourcesBlockingEncryptionEnforcementResult {
  NonCompliantResources?: VpcEncryptionNonCompliantResource[];
  NextToken?: string;
}
export const GetVpcResourcesBlockingEncryptionEnforcementResult = S.suspend(
  () =>
    S.Struct({
      NonCompliantResources: S.optional(
        VpcEncryptionNonCompliantResourceList,
      ).pipe(
        T.XmlName("nonCompliantResourceSet"),
        T.Ec2QueryName("NonCompliantResourceSet"),
      ),
      NextToken: S.optional(S.String).pipe(
        T.XmlName("nextToken"),
        T.Ec2QueryName("NextToken"),
      ),
    }).pipe(ns),
).annotate({
  identifier: "GetVpcResourcesBlockingEncryptionEnforcementResult",
}) as any as S.Schema<GetVpcResourcesBlockingEncryptionEnforcementResult>;
export interface GetVpnConnectionDeviceSampleConfigurationRequest {
  VpnConnectionId?: string;
  VpnConnectionDeviceTypeId?: string;
  InternetKeyExchangeVersion?: string;
  SampleType?: string;
  DryRun?: boolean;
}
export const GetVpnConnectionDeviceSampleConfigurationRequest = S.suspend(() =>
  S.Struct({
    VpnConnectionId: S.optional(S.String),
    VpnConnectionDeviceTypeId: S.optional(S.String),
    InternetKeyExchangeVersion: S.optional(S.String),
    SampleType: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetVpnConnectionDeviceSampleConfigurationRequest",
}) as any as S.Schema<GetVpnConnectionDeviceSampleConfigurationRequest>;
export interface GetVpnConnectionDeviceSampleConfigurationResult {
  VpnConnectionDeviceSampleConfiguration?: string | redacted.Redacted<string>;
}
export const GetVpnConnectionDeviceSampleConfigurationResult = S.suspend(() =>
  S.Struct({
    VpnConnectionDeviceSampleConfiguration: S.optional(SensitiveString).pipe(
      T.XmlName("vpnConnectionDeviceSampleConfiguration"),
      T.Ec2QueryName("VpnConnectionDeviceSampleConfiguration"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetVpnConnectionDeviceSampleConfigurationResult",
}) as any as S.Schema<GetVpnConnectionDeviceSampleConfigurationResult>;
export interface GetVpnConnectionDeviceTypesRequest {
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const GetVpnConnectionDeviceTypesRequest = S.suspend(() =>
  S.Struct({
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetVpnConnectionDeviceTypesRequest",
}) as any as S.Schema<GetVpnConnectionDeviceTypesRequest>;
export interface VpnConnectionDeviceType {
  VpnConnectionDeviceTypeId?: string;
  Vendor?: string;
  Platform?: string;
  Software?: string;
}
export const VpnConnectionDeviceType = S.suspend(() =>
  S.Struct({
    VpnConnectionDeviceTypeId: S.optional(S.String).pipe(
      T.XmlName("vpnConnectionDeviceTypeId"),
      T.Ec2QueryName("VpnConnectionDeviceTypeId"),
    ),
    Vendor: S.optional(S.String).pipe(
      T.XmlName("vendor"),
      T.Ec2QueryName("Vendor"),
    ),
    Platform: S.optional(S.String).pipe(
      T.XmlName("platform"),
      T.Ec2QueryName("Platform"),
    ),
    Software: S.optional(S.String).pipe(
      T.XmlName("software"),
      T.Ec2QueryName("Software"),
    ),
  }),
).annotate({
  identifier: "VpnConnectionDeviceType",
}) as any as S.Schema<VpnConnectionDeviceType>;
export type VpnConnectionDeviceTypeList = VpnConnectionDeviceType[];
export const VpnConnectionDeviceTypeList = S.Array(
  VpnConnectionDeviceType.pipe(T.XmlName("item")).annotate({
    identifier: "VpnConnectionDeviceType",
  }),
);
export interface GetVpnConnectionDeviceTypesResult {
  VpnConnectionDeviceTypes?: VpnConnectionDeviceType[];
  NextToken?: string;
}
export const GetVpnConnectionDeviceTypesResult = S.suspend(() =>
  S.Struct({
    VpnConnectionDeviceTypes: S.optional(VpnConnectionDeviceTypeList).pipe(
      T.XmlName("vpnConnectionDeviceTypeSet"),
      T.Ec2QueryName("VpnConnectionDeviceTypeSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "GetVpnConnectionDeviceTypesResult",
}) as any as S.Schema<GetVpnConnectionDeviceTypesResult>;
export interface GetVpnTunnelReplacementStatusRequest {
  VpnConnectionId?: string;
  VpnTunnelOutsideIpAddress?: string;
  DryRun?: boolean;
}
export const GetVpnTunnelReplacementStatusRequest = S.suspend(() =>
  S.Struct({
    VpnConnectionId: S.optional(S.String),
    VpnTunnelOutsideIpAddress: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetVpnTunnelReplacementStatusRequest",
}) as any as S.Schema<GetVpnTunnelReplacementStatusRequest>;
export interface MaintenanceDetails {
  PendingMaintenance?: string;
  MaintenanceAutoAppliedAfter?: Date;
  LastMaintenanceApplied?: Date;
}
export const MaintenanceDetails = S.suspend(() =>
  S.Struct({
    PendingMaintenance: S.optional(S.String).pipe(
      T.XmlName("pendingMaintenance"),
      T.Ec2QueryName("PendingMaintenance"),
    ),
    MaintenanceAutoAppliedAfter: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("maintenanceAutoAppliedAfter"),
      T.Ec2QueryName("MaintenanceAutoAppliedAfter"),
    ),
    LastMaintenanceApplied: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("lastMaintenanceApplied"),
      T.Ec2QueryName("LastMaintenanceApplied"),
    ),
  }),
).annotate({
  identifier: "MaintenanceDetails",
}) as any as S.Schema<MaintenanceDetails>;
export interface GetVpnTunnelReplacementStatusResult {
  VpnConnectionId?: string;
  TransitGatewayId?: string;
  CustomerGatewayId?: string;
  VpnGatewayId?: string;
  VpnTunnelOutsideIpAddress?: string;
  MaintenanceDetails?: MaintenanceDetails;
}
export const GetVpnTunnelReplacementStatusResult = S.suspend(() =>
  S.Struct({
    VpnConnectionId: S.optional(S.String).pipe(
      T.XmlName("vpnConnectionId"),
      T.Ec2QueryName("VpnConnectionId"),
    ),
    TransitGatewayId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayId"),
      T.Ec2QueryName("TransitGatewayId"),
    ),
    CustomerGatewayId: S.optional(S.String).pipe(
      T.XmlName("customerGatewayId"),
      T.Ec2QueryName("CustomerGatewayId"),
    ),
    VpnGatewayId: S.optional(S.String).pipe(
      T.XmlName("vpnGatewayId"),
      T.Ec2QueryName("VpnGatewayId"),
    ),
    VpnTunnelOutsideIpAddress: S.optional(S.String).pipe(
      T.XmlName("vpnTunnelOutsideIpAddress"),
      T.Ec2QueryName("VpnTunnelOutsideIpAddress"),
    ),
    MaintenanceDetails: S.optional(MaintenanceDetails)
      .pipe(
        T.XmlName("maintenanceDetails"),
        T.Ec2QueryName("MaintenanceDetails"),
      )
      .annotate({ identifier: "MaintenanceDetails" }),
  }).pipe(ns),
).annotate({
  identifier: "GetVpnTunnelReplacementStatusResult",
}) as any as S.Schema<GetVpnTunnelReplacementStatusResult>;
export interface ImportClientVpnClientCertificateRevocationListRequest {
  ClientVpnEndpointId?: string;
  CertificateRevocationList?: string;
  DryRun?: boolean;
}
export const ImportClientVpnClientCertificateRevocationListRequest = S.suspend(
  () =>
    S.Struct({
      ClientVpnEndpointId: S.optional(S.String),
      CertificateRevocationList: S.optional(S.String),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "ImportClientVpnClientCertificateRevocationListRequest",
}) as any as S.Schema<ImportClientVpnClientCertificateRevocationListRequest>;
export interface ImportClientVpnClientCertificateRevocationListResult {
  Return?: boolean;
}
export const ImportClientVpnClientCertificateRevocationListResult = S.suspend(
  () =>
    S.Struct({
      Return: S.optional(S.Boolean).pipe(
        T.XmlName("return"),
        T.Ec2QueryName("Return"),
      ),
    }).pipe(ns),
).annotate({
  identifier: "ImportClientVpnClientCertificateRevocationListResult",
}) as any as S.Schema<ImportClientVpnClientCertificateRevocationListResult>;
export interface ClientData {
  Comment?: string;
  UploadEnd?: Date;
  UploadSize?: number;
  UploadStart?: Date;
}
export const ClientData = S.suspend(() =>
  S.Struct({
    Comment: S.optional(S.String),
    UploadEnd: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    UploadSize: S.optional(S.Number),
    UploadStart: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
  }),
).annotate({ identifier: "ClientData" }) as any as S.Schema<ClientData>;
export interface UserBucket {
  S3Bucket?: string;
  S3Key?: string;
}
export const UserBucket = S.suspend(() =>
  S.Struct({ S3Bucket: S.optional(S.String), S3Key: S.optional(S.String) }),
).annotate({ identifier: "UserBucket" }) as any as S.Schema<UserBucket>;
export interface ImageDiskContainer {
  Description?: string;
  DeviceName?: string;
  Format?: string;
  SnapshotId?: string;
  Url?: string | redacted.Redacted<string>;
  UserBucket?: UserBucket;
}
export const ImageDiskContainer = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String),
    DeviceName: S.optional(S.String),
    Format: S.optional(S.String),
    SnapshotId: S.optional(S.String),
    Url: S.optional(SensitiveString),
    UserBucket: S.optional(UserBucket),
  }),
).annotate({
  identifier: "ImageDiskContainer",
}) as any as S.Schema<ImageDiskContainer>;
export type ImageDiskContainerList = ImageDiskContainer[];
export const ImageDiskContainerList = S.Array(
  ImageDiskContainer.pipe(T.XmlName("item")).annotate({
    identifier: "ImageDiskContainer",
  }),
);
export interface ImportImageLicenseConfigurationRequest {
  LicenseConfigurationArn?: string;
}
export const ImportImageLicenseConfigurationRequest = S.suspend(() =>
  S.Struct({ LicenseConfigurationArn: S.optional(S.String) }),
).annotate({
  identifier: "ImportImageLicenseConfigurationRequest",
}) as any as S.Schema<ImportImageLicenseConfigurationRequest>;
export type ImportImageLicenseSpecificationListRequest =
  ImportImageLicenseConfigurationRequest[];
export const ImportImageLicenseSpecificationListRequest = S.Array(
  ImportImageLicenseConfigurationRequest.pipe(T.XmlName("item")).annotate({
    identifier: "ImportImageLicenseConfigurationRequest",
  }),
);
export interface ImportImageRequest {
  Architecture?: string;
  ClientData?: ClientData;
  ClientToken?: string;
  Description?: string;
  DiskContainers?: ImageDiskContainer[];
  DryRun?: boolean;
  Encrypted?: boolean;
  Hypervisor?: string;
  KmsKeyId?: string;
  LicenseType?: string;
  Platform?: string;
  RoleName?: string;
  LicenseSpecifications?: ImportImageLicenseConfigurationRequest[];
  TagSpecifications?: TagSpecification[];
  UsageOperation?: string;
  BootMode?: BootModeValues;
}
export const ImportImageRequest = S.suspend(() =>
  S.Struct({
    Architecture: S.optional(S.String),
    ClientData: S.optional(ClientData),
    ClientToken: S.optional(S.String),
    Description: S.optional(S.String),
    DiskContainers: S.optional(ImageDiskContainerList).pipe(
      T.XmlName("DiskContainer"),
    ),
    DryRun: S.optional(S.Boolean),
    Encrypted: S.optional(S.Boolean),
    Hypervisor: S.optional(S.String),
    KmsKeyId: S.optional(S.String),
    LicenseType: S.optional(S.String),
    Platform: S.optional(S.String),
    RoleName: S.optional(S.String),
    LicenseSpecifications: S.optional(
      ImportImageLicenseSpecificationListRequest,
    ),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    UsageOperation: S.optional(S.String),
    BootMode: S.optional(BootModeValues),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ImportImageRequest",
}) as any as S.Schema<ImportImageRequest>;
export interface ImportImageResult {
  Architecture?: string;
  Description?: string;
  Encrypted?: boolean;
  Hypervisor?: string;
  ImageId?: string;
  ImportTaskId?: string;
  KmsKeyId?: string;
  LicenseType?: string;
  Platform?: string;
  Progress?: string;
  SnapshotDetails?: SnapshotDetail[];
  Status?: string;
  StatusMessage?: string;
  LicenseSpecifications?: ImportImageLicenseConfigurationResponse[];
  Tags?: Tag[];
  UsageOperation?: string;
}
export const ImportImageResult = S.suspend(() =>
  S.Struct({
    Architecture: S.optional(S.String).pipe(
      T.XmlName("architecture"),
      T.Ec2QueryName("Architecture"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    Encrypted: S.optional(S.Boolean).pipe(
      T.XmlName("encrypted"),
      T.Ec2QueryName("Encrypted"),
    ),
    Hypervisor: S.optional(S.String).pipe(
      T.XmlName("hypervisor"),
      T.Ec2QueryName("Hypervisor"),
    ),
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    ImportTaskId: S.optional(S.String).pipe(
      T.XmlName("importTaskId"),
      T.Ec2QueryName("ImportTaskId"),
    ),
    KmsKeyId: S.optional(S.String).pipe(
      T.XmlName("kmsKeyId"),
      T.Ec2QueryName("KmsKeyId"),
    ),
    LicenseType: S.optional(S.String).pipe(
      T.XmlName("licenseType"),
      T.Ec2QueryName("LicenseType"),
    ),
    Platform: S.optional(S.String).pipe(
      T.XmlName("platform"),
      T.Ec2QueryName("Platform"),
    ),
    Progress: S.optional(S.String).pipe(
      T.XmlName("progress"),
      T.Ec2QueryName("Progress"),
    ),
    SnapshotDetails: S.optional(SnapshotDetailList).pipe(
      T.XmlName("snapshotDetailSet"),
      T.Ec2QueryName("SnapshotDetailSet"),
    ),
    Status: S.optional(S.String).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    StatusMessage: S.optional(S.String).pipe(
      T.XmlName("statusMessage"),
      T.Ec2QueryName("StatusMessage"),
    ),
    LicenseSpecifications: S.optional(
      ImportImageLicenseSpecificationListResponse,
    ).pipe(
      T.XmlName("licenseSpecifications"),
      T.Ec2QueryName("LicenseSpecifications"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
    UsageOperation: S.optional(S.String).pipe(
      T.XmlName("usageOperation"),
      T.Ec2QueryName("UsageOperation"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ImportImageResult",
}) as any as S.Schema<ImportImageResult>;
export interface UserData {
  Data?: string;
}
export const UserData = S.suspend(() =>
  S.Struct({
    Data: S.optional(S.String).pipe(T.XmlName("data"), T.Ec2QueryName("Data")),
  }),
).annotate({ identifier: "UserData" }) as any as S.Schema<UserData>;
export interface ImportInstanceLaunchSpecification {
  Architecture?: ArchitectureValues;
  GroupNames?: string[];
  GroupIds?: string[];
  AdditionalInfo?: string;
  UserData?: UserData;
  InstanceType?: InstanceType;
  Placement?: Placement;
  Monitoring?: boolean;
  SubnetId?: string;
  InstanceInitiatedShutdownBehavior?: ShutdownBehavior;
  PrivateIpAddress?: string;
}
export const ImportInstanceLaunchSpecification = S.suspend(() =>
  S.Struct({
    Architecture: S.optional(ArchitectureValues).pipe(
      T.XmlName("architecture"),
      T.Ec2QueryName("Architecture"),
    ),
    GroupNames: S.optional(SecurityGroupStringList).pipe(
      T.XmlName("GroupName"),
    ),
    GroupIds: S.optional(SecurityGroupIdStringList).pipe(T.XmlName("GroupId")),
    AdditionalInfo: S.optional(S.String).pipe(
      T.XmlName("additionalInfo"),
      T.Ec2QueryName("AdditionalInfo"),
    ),
    UserData: S.optional(UserData)
      .pipe(T.XmlName("userData"), T.Ec2QueryName("UserData"))
      .annotate({ identifier: "UserData" }),
    InstanceType: S.optional(InstanceType).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    Placement: S.optional(Placement)
      .pipe(T.XmlName("placement"), T.Ec2QueryName("Placement"))
      .annotate({ identifier: "Placement" }),
    Monitoring: S.optional(S.Boolean).pipe(
      T.XmlName("monitoring"),
      T.Ec2QueryName("Monitoring"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    InstanceInitiatedShutdownBehavior: S.optional(ShutdownBehavior).pipe(
      T.XmlName("instanceInitiatedShutdownBehavior"),
      T.Ec2QueryName("InstanceInitiatedShutdownBehavior"),
    ),
    PrivateIpAddress: S.optional(S.String).pipe(
      T.XmlName("privateIpAddress"),
      T.Ec2QueryName("PrivateIpAddress"),
    ),
  }),
).annotate({
  identifier: "ImportInstanceLaunchSpecification",
}) as any as S.Schema<ImportInstanceLaunchSpecification>;
export interface DiskImageDetail {
  Format?: DiskImageFormat;
  Bytes?: number;
  ImportManifestUrl?: string | redacted.Redacted<string>;
}
export const DiskImageDetail = S.suspend(() =>
  S.Struct({
    Format: S.optional(DiskImageFormat).pipe(
      T.XmlName("format"),
      T.Ec2QueryName("Format"),
    ),
    Bytes: S.optional(S.Number).pipe(
      T.XmlName("bytes"),
      T.Ec2QueryName("Bytes"),
    ),
    ImportManifestUrl: S.optional(SensitiveString).pipe(
      T.XmlName("importManifestUrl"),
      T.Ec2QueryName("ImportManifestUrl"),
    ),
  }),
).annotate({
  identifier: "DiskImageDetail",
}) as any as S.Schema<DiskImageDetail>;
export interface VolumeDetail {
  Size?: number;
}
export const VolumeDetail = S.suspend(() =>
  S.Struct({
    Size: S.optional(S.Number).pipe(T.XmlName("size"), T.Ec2QueryName("Size")),
  }),
).annotate({ identifier: "VolumeDetail" }) as any as S.Schema<VolumeDetail>;
export interface DiskImage {
  Description?: string;
  Image?: DiskImageDetail;
  Volume?: VolumeDetail;
}
export const DiskImage = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String),
    Image: S.optional(DiskImageDetail),
    Volume: S.optional(VolumeDetail),
  }),
).annotate({ identifier: "DiskImage" }) as any as S.Schema<DiskImage>;
export type DiskImageList = DiskImage[];
export const DiskImageList = S.Array(DiskImage);
export interface ImportInstanceRequest {
  DryRun?: boolean;
  Description?: string;
  LaunchSpecification?: ImportInstanceLaunchSpecification;
  DiskImages?: DiskImage[];
  Platform?: PlatformValues;
}
export const ImportInstanceRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    LaunchSpecification: S.optional(ImportInstanceLaunchSpecification)
      .pipe(
        T.XmlName("launchSpecification"),
        T.Ec2QueryName("LaunchSpecification"),
      )
      .annotate({ identifier: "ImportInstanceLaunchSpecification" }),
    DiskImages: S.optional(DiskImageList).pipe(
      T.XmlName("diskImage"),
      T.Ec2QueryName("DiskImage"),
    ),
    Platform: S.optional(PlatformValues).pipe(
      T.XmlName("platform"),
      T.Ec2QueryName("Platform"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ImportInstanceRequest",
}) as any as S.Schema<ImportInstanceRequest>;
export interface ImportInstanceResult {
  ConversionTask?: ConversionTask;
}
export const ImportInstanceResult = S.suspend(() =>
  S.Struct({
    ConversionTask: S.optional(ConversionTask)
      .pipe(T.XmlName("conversionTask"), T.Ec2QueryName("ConversionTask"))
      .annotate({ identifier: "ConversionTask" }),
  }).pipe(ns),
).annotate({
  identifier: "ImportInstanceResult",
}) as any as S.Schema<ImportInstanceResult>;
export interface ImportKeyPairRequest {
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
  KeyName?: string;
  PublicKeyMaterial?: Uint8Array;
}
export const ImportKeyPairRequest = S.suspend(() =>
  S.Struct({
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    KeyName: S.optional(S.String).pipe(
      T.XmlName("keyName"),
      T.Ec2QueryName("KeyName"),
    ),
    PublicKeyMaterial: S.optional(T.Blob).pipe(
      T.XmlName("publicKeyMaterial"),
      T.Ec2QueryName("PublicKeyMaterial"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ImportKeyPairRequest",
}) as any as S.Schema<ImportKeyPairRequest>;
export interface ImportKeyPairResult {
  KeyFingerprint?: string;
  KeyName?: string;
  KeyPairId?: string;
  Tags?: Tag[];
}
export const ImportKeyPairResult = S.suspend(() =>
  S.Struct({
    KeyFingerprint: S.optional(S.String).pipe(
      T.XmlName("keyFingerprint"),
      T.Ec2QueryName("KeyFingerprint"),
    ),
    KeyName: S.optional(S.String).pipe(
      T.XmlName("keyName"),
      T.Ec2QueryName("KeyName"),
    ),
    KeyPairId: S.optional(S.String).pipe(
      T.XmlName("keyPairId"),
      T.Ec2QueryName("KeyPairId"),
    ),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ImportKeyPairResult",
}) as any as S.Schema<ImportKeyPairResult>;
export interface SnapshotDiskContainer {
  Description?: string;
  Format?: string;
  Url?: string | redacted.Redacted<string>;
  UserBucket?: UserBucket;
}
export const SnapshotDiskContainer = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String),
    Format: S.optional(S.String),
    Url: S.optional(SensitiveString),
    UserBucket: S.optional(UserBucket),
  }),
).annotate({
  identifier: "SnapshotDiskContainer",
}) as any as S.Schema<SnapshotDiskContainer>;
export interface ImportSnapshotRequest {
  ClientData?: ClientData;
  ClientToken?: string;
  Description?: string;
  DiskContainer?: SnapshotDiskContainer;
  DryRun?: boolean;
  Encrypted?: boolean;
  KmsKeyId?: string;
  RoleName?: string;
  TagSpecifications?: TagSpecification[];
}
export const ImportSnapshotRequest = S.suspend(() =>
  S.Struct({
    ClientData: S.optional(ClientData),
    ClientToken: S.optional(S.String),
    Description: S.optional(S.String),
    DiskContainer: S.optional(SnapshotDiskContainer),
    DryRun: S.optional(S.Boolean),
    Encrypted: S.optional(S.Boolean),
    KmsKeyId: S.optional(S.String),
    RoleName: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ImportSnapshotRequest",
}) as any as S.Schema<ImportSnapshotRequest>;
export interface ImportSnapshotResult {
  Description?: string;
  ImportTaskId?: string;
  SnapshotTaskDetail?: SnapshotTaskDetail;
  Tags?: Tag[];
}
export const ImportSnapshotResult = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    ImportTaskId: S.optional(S.String).pipe(
      T.XmlName("importTaskId"),
      T.Ec2QueryName("ImportTaskId"),
    ),
    SnapshotTaskDetail: S.optional(SnapshotTaskDetail)
      .pipe(
        T.XmlName("snapshotTaskDetail"),
        T.Ec2QueryName("SnapshotTaskDetail"),
      )
      .annotate({ identifier: "SnapshotTaskDetail" }),
    Tags: S.optional(TagList).pipe(
      T.XmlName("tagSet"),
      T.Ec2QueryName("TagSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ImportSnapshotResult",
}) as any as S.Schema<ImportSnapshotResult>;
export interface ImportVolumeRequest {
  AvailabilityZoneId?: string;
  DryRun?: boolean;
  AvailabilityZone?: string;
  Image?: DiskImageDetail;
  Description?: string;
  Volume?: VolumeDetail;
}
export const ImportVolumeRequest = S.suspend(() =>
  S.Struct({
    AvailabilityZoneId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    Image: S.optional(DiskImageDetail)
      .pipe(T.XmlName("image"), T.Ec2QueryName("Image"))
      .annotate({ identifier: "DiskImageDetail" }),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    Volume: S.optional(VolumeDetail)
      .pipe(T.XmlName("volume"), T.Ec2QueryName("Volume"))
      .annotate({ identifier: "VolumeDetail" }),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ImportVolumeRequest",
}) as any as S.Schema<ImportVolumeRequest>;
export interface ImportVolumeResult {
  ConversionTask?: ConversionTask;
}
export const ImportVolumeResult = S.suspend(() =>
  S.Struct({
    ConversionTask: S.optional(ConversionTask)
      .pipe(T.XmlName("conversionTask"), T.Ec2QueryName("ConversionTask"))
      .annotate({ identifier: "ConversionTask" }),
  }).pipe(ns),
).annotate({
  identifier: "ImportVolumeResult",
}) as any as S.Schema<ImportVolumeResult>;
export interface ListImagesInRecycleBinRequest {
  ImageIds?: string[];
  NextToken?: string;
  MaxResults?: number;
  DryRun?: boolean;
}
export const ListImagesInRecycleBinRequest = S.suspend(() =>
  S.Struct({
    ImageIds: S.optional(ImageIdStringList).pipe(T.XmlName("ImageId")),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListImagesInRecycleBinRequest",
}) as any as S.Schema<ListImagesInRecycleBinRequest>;
export interface ImageRecycleBinInfo {
  ImageId?: string;
  Name?: string;
  Description?: string;
  RecycleBinEnterTime?: Date;
  RecycleBinExitTime?: Date;
}
export const ImageRecycleBinInfo = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    RecycleBinEnterTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("recycleBinEnterTime"),
      T.Ec2QueryName("RecycleBinEnterTime"),
    ),
    RecycleBinExitTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("recycleBinExitTime"),
      T.Ec2QueryName("RecycleBinExitTime"),
    ),
  }),
).annotate({
  identifier: "ImageRecycleBinInfo",
}) as any as S.Schema<ImageRecycleBinInfo>;
export type ImageRecycleBinInfoList = ImageRecycleBinInfo[];
export const ImageRecycleBinInfoList = S.Array(
  ImageRecycleBinInfo.pipe(T.XmlName("item")).annotate({
    identifier: "ImageRecycleBinInfo",
  }),
);
export interface ListImagesInRecycleBinResult {
  Images?: ImageRecycleBinInfo[];
  NextToken?: string;
}
export const ListImagesInRecycleBinResult = S.suspend(() =>
  S.Struct({
    Images: S.optional(ImageRecycleBinInfoList).pipe(
      T.XmlName("imageSet"),
      T.Ec2QueryName("ImageSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ListImagesInRecycleBinResult",
}) as any as S.Schema<ListImagesInRecycleBinResult>;
export interface ListSnapshotsInRecycleBinRequest {
  MaxResults?: number;
  NextToken?: string;
  SnapshotIds?: string[];
  DryRun?: boolean;
}
export const ListSnapshotsInRecycleBinRequest = S.suspend(() =>
  S.Struct({
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    SnapshotIds: S.optional(SnapshotIdStringList).pipe(T.XmlName("SnapshotId")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListSnapshotsInRecycleBinRequest",
}) as any as S.Schema<ListSnapshotsInRecycleBinRequest>;
export interface SnapshotRecycleBinInfo {
  SnapshotId?: string;
  RecycleBinEnterTime?: Date;
  RecycleBinExitTime?: Date;
  Description?: string;
  VolumeId?: string;
}
export const SnapshotRecycleBinInfo = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    RecycleBinEnterTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("recycleBinEnterTime"),
      T.Ec2QueryName("RecycleBinEnterTime"),
    ),
    RecycleBinExitTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("recycleBinExitTime"),
      T.Ec2QueryName("RecycleBinExitTime"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    VolumeId: S.optional(S.String).pipe(
      T.XmlName("volumeId"),
      T.Ec2QueryName("VolumeId"),
    ),
  }),
).annotate({
  identifier: "SnapshotRecycleBinInfo",
}) as any as S.Schema<SnapshotRecycleBinInfo>;
export type SnapshotRecycleBinInfoList = SnapshotRecycleBinInfo[];
export const SnapshotRecycleBinInfoList = S.Array(
  SnapshotRecycleBinInfo.pipe(T.XmlName("item")).annotate({
    identifier: "SnapshotRecycleBinInfo",
  }),
);
export interface ListSnapshotsInRecycleBinResult {
  Snapshots?: SnapshotRecycleBinInfo[];
  NextToken?: string;
}
export const ListSnapshotsInRecycleBinResult = S.suspend(() =>
  S.Struct({
    Snapshots: S.optional(SnapshotRecycleBinInfoList).pipe(
      T.XmlName("snapshotSet"),
      T.Ec2QueryName("SnapshotSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ListSnapshotsInRecycleBinResult",
}) as any as S.Schema<ListSnapshotsInRecycleBinResult>;
export interface ListVolumesInRecycleBinRequest {
  VolumeIds?: string[];
  DryRun?: boolean;
  MaxResults?: number;
  NextToken?: string;
}
export const ListVolumesInRecycleBinRequest = S.suspend(() =>
  S.Struct({
    VolumeIds: S.optional(VolumeIdStringList).pipe(T.XmlName("VolumeId")),
    DryRun: S.optional(S.Boolean),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListVolumesInRecycleBinRequest",
}) as any as S.Schema<ListVolumesInRecycleBinRequest>;
export interface VolumeRecycleBinInfo {
  VolumeId?: string;
  VolumeType?: VolumeType;
  State?: VolumeState;
  Size?: number;
  Iops?: number;
  Throughput?: number;
  OutpostArn?: string;
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  SourceVolumeId?: string;
  SnapshotId?: string;
  Operator?: OperatorResponse;
  CreateTime?: Date;
  RecycleBinEnterTime?: Date;
  RecycleBinExitTime?: Date;
}
export const VolumeRecycleBinInfo = S.suspend(() =>
  S.Struct({
    VolumeId: S.optional(S.String).pipe(
      T.XmlName("volumeId"),
      T.Ec2QueryName("VolumeId"),
    ),
    VolumeType: S.optional(VolumeType).pipe(
      T.XmlName("volumeType"),
      T.Ec2QueryName("VolumeType"),
    ),
    State: S.optional(VolumeState).pipe(
      T.XmlName("state"),
      T.Ec2QueryName("State"),
    ),
    Size: S.optional(S.Number).pipe(T.XmlName("size"), T.Ec2QueryName("Size")),
    Iops: S.optional(S.Number).pipe(T.XmlName("iops"), T.Ec2QueryName("Iops")),
    Throughput: S.optional(S.Number).pipe(
      T.XmlName("throughput"),
      T.Ec2QueryName("Throughput"),
    ),
    OutpostArn: S.optional(S.String).pipe(
      T.XmlName("outpostArn"),
      T.Ec2QueryName("OutpostArn"),
    ),
    AvailabilityZone: S.optional(S.String).pipe(
      T.XmlName("availabilityZone"),
      T.Ec2QueryName("AvailabilityZone"),
    ),
    AvailabilityZoneId: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneId"),
      T.Ec2QueryName("AvailabilityZoneId"),
    ),
    SourceVolumeId: S.optional(S.String).pipe(
      T.XmlName("sourceVolumeId"),
      T.Ec2QueryName("SourceVolumeId"),
    ),
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    Operator: S.optional(OperatorResponse)
      .pipe(T.XmlName("operator"), T.Ec2QueryName("Operator"))
      .annotate({ identifier: "OperatorResponse" }),
    CreateTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("createTime"), T.Ec2QueryName("CreateTime")),
    RecycleBinEnterTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("recycleBinEnterTime"),
      T.Ec2QueryName("RecycleBinEnterTime"),
    ),
    RecycleBinExitTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("recycleBinExitTime"),
      T.Ec2QueryName("RecycleBinExitTime"),
    ),
  }),
).annotate({
  identifier: "VolumeRecycleBinInfo",
}) as any as S.Schema<VolumeRecycleBinInfo>;
export type VolumeRecycleBinInfoList = VolumeRecycleBinInfo[];
export const VolumeRecycleBinInfoList = S.Array(
  VolumeRecycleBinInfo.pipe(T.XmlName("item")).annotate({
    identifier: "VolumeRecycleBinInfo",
  }),
);
export interface ListVolumesInRecycleBinResult {
  Volumes?: VolumeRecycleBinInfo[];
  NextToken?: string;
}
export const ListVolumesInRecycleBinResult = S.suspend(() =>
  S.Struct({
    Volumes: S.optional(VolumeRecycleBinInfoList).pipe(
      T.XmlName("volumeSet"),
      T.Ec2QueryName("VolumeSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ListVolumesInRecycleBinResult",
}) as any as S.Schema<ListVolumesInRecycleBinResult>;
export type LockMode = "compliance" | "governance" | (string & {});
export const LockMode = S.String;
export interface LockSnapshotRequest {
  SnapshotId?: string;
  DryRun?: boolean;
  LockMode?: LockMode;
  CoolOffPeriod?: number;
  LockDuration?: number;
  ExpirationDate?: Date;
}
export const LockSnapshotRequest = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    LockMode: S.optional(LockMode),
    CoolOffPeriod: S.optional(S.Number),
    LockDuration: S.optional(S.Number),
    ExpirationDate: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "LockSnapshotRequest",
}) as any as S.Schema<LockSnapshotRequest>;
export interface LockSnapshotResult {
  SnapshotId?: string;
  LockState?: LockState;
  LockDuration?: number;
  CoolOffPeriod?: number;
  CoolOffPeriodExpiresOn?: Date;
  LockCreatedOn?: Date;
  LockExpiresOn?: Date;
  LockDurationStartTime?: Date;
}
export const LockSnapshotResult = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    LockState: S.optional(LockState).pipe(
      T.XmlName("lockState"),
      T.Ec2QueryName("LockState"),
    ),
    LockDuration: S.optional(S.Number).pipe(
      T.XmlName("lockDuration"),
      T.Ec2QueryName("LockDuration"),
    ),
    CoolOffPeriod: S.optional(S.Number).pipe(
      T.XmlName("coolOffPeriod"),
      T.Ec2QueryName("CoolOffPeriod"),
    ),
    CoolOffPeriodExpiresOn: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("coolOffPeriodExpiresOn"),
      T.Ec2QueryName("CoolOffPeriodExpiresOn"),
    ),
    LockCreatedOn: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("lockCreatedOn"), T.Ec2QueryName("LockCreatedOn")),
    LockExpiresOn: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("lockExpiresOn"), T.Ec2QueryName("LockExpiresOn")),
    LockDurationStartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(
      T.XmlName("lockDurationStartTime"),
      T.Ec2QueryName("LockDurationStartTime"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "LockSnapshotResult",
}) as any as S.Schema<LockSnapshotResult>;
export interface ModifyAddressAttributeRequest {
  AllocationId?: string;
  DomainName?: string;
  DryRun?: boolean;
}
export const ModifyAddressAttributeRequest = S.suspend(() =>
  S.Struct({
    AllocationId: S.optional(S.String),
    DomainName: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyAddressAttributeRequest",
}) as any as S.Schema<ModifyAddressAttributeRequest>;
export interface ModifyAddressAttributeResult {
  Address?: AddressAttribute;
}
export const ModifyAddressAttributeResult = S.suspend(() =>
  S.Struct({
    Address: S.optional(AddressAttribute)
      .pipe(T.XmlName("address"), T.Ec2QueryName("Address"))
      .annotate({ identifier: "AddressAttribute" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyAddressAttributeResult",
}) as any as S.Schema<ModifyAddressAttributeResult>;
export type ModifyAvailabilityZoneOptInStatus =
  | "opted-in"
  | "not-opted-in"
  | (string & {});
export const ModifyAvailabilityZoneOptInStatus = S.String;
export interface ModifyAvailabilityZoneGroupRequest {
  GroupName?: string;
  OptInStatus?: ModifyAvailabilityZoneOptInStatus;
  DryRun?: boolean;
}
export const ModifyAvailabilityZoneGroupRequest = S.suspend(() =>
  S.Struct({
    GroupName: S.optional(S.String),
    OptInStatus: S.optional(ModifyAvailabilityZoneOptInStatus),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyAvailabilityZoneGroupRequest",
}) as any as S.Schema<ModifyAvailabilityZoneGroupRequest>;
export interface ModifyAvailabilityZoneGroupResult {
  Return?: boolean;
}
export const ModifyAvailabilityZoneGroupResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyAvailabilityZoneGroupResult",
}) as any as S.Schema<ModifyAvailabilityZoneGroupResult>;
export interface ModifyCapacityReservationRequest {
  CapacityReservationId?: string;
  InstanceCount?: number;
  EndDate?: Date;
  EndDateType?: EndDateType;
  Accept?: boolean;
  DryRun?: boolean;
  AdditionalInfo?: string;
  InstanceMatchCriteria?: InstanceMatchCriteria;
}
export const ModifyCapacityReservationRequest = S.suspend(() =>
  S.Struct({
    CapacityReservationId: S.optional(S.String),
    InstanceCount: S.optional(S.Number),
    EndDate: S.optional(T.DateFromString.pipe(T.TimestampFormat("date-time"))),
    EndDateType: S.optional(EndDateType),
    Accept: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean),
    AdditionalInfo: S.optional(S.String),
    InstanceMatchCriteria: S.optional(InstanceMatchCriteria),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyCapacityReservationRequest",
}) as any as S.Schema<ModifyCapacityReservationRequest>;
export interface ModifyCapacityReservationResult {
  Return?: boolean;
}
export const ModifyCapacityReservationResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyCapacityReservationResult",
}) as any as S.Schema<ModifyCapacityReservationResult>;
export interface ModifyCapacityReservationFleetRequest {
  CapacityReservationFleetId?: string;
  TotalTargetCapacity?: number;
  EndDate?: Date;
  DryRun?: boolean;
  RemoveEndDate?: boolean;
}
export const ModifyCapacityReservationFleetRequest = S.suspend(() =>
  S.Struct({
    CapacityReservationFleetId: S.optional(S.String),
    TotalTargetCapacity: S.optional(S.Number),
    EndDate: S.optional(T.DateFromString.pipe(T.TimestampFormat("date-time"))),
    DryRun: S.optional(S.Boolean),
    RemoveEndDate: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyCapacityReservationFleetRequest",
}) as any as S.Schema<ModifyCapacityReservationFleetRequest>;
export interface ModifyCapacityReservationFleetResult {
  Return?: boolean;
}
export const ModifyCapacityReservationFleetResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyCapacityReservationFleetResult",
}) as any as S.Schema<ModifyCapacityReservationFleetResult>;
export interface DnsServersOptionsModifyStructure {
  CustomDnsServers?: string[];
  Enabled?: boolean;
}
export const DnsServersOptionsModifyStructure = S.suspend(() =>
  S.Struct({
    CustomDnsServers: S.optional(ValueStringList),
    Enabled: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "DnsServersOptionsModifyStructure",
}) as any as S.Schema<DnsServersOptionsModifyStructure>;
export interface ModifyClientVpnEndpointRequest {
  ClientVpnEndpointId?: string;
  ServerCertificateArn?: string;
  ConnectionLogOptions?: ConnectionLogOptions;
  DnsServers?: DnsServersOptionsModifyStructure;
  VpnPort?: number;
  Description?: string;
  SplitTunnel?: boolean;
  DryRun?: boolean;
  SecurityGroupIds?: string[];
  VpcId?: string;
  SelfServicePortal?: SelfServicePortal;
  ClientConnectOptions?: ClientConnectOptions;
  SessionTimeoutHours?: number;
  ClientLoginBannerOptions?: ClientLoginBannerOptions;
  ClientRouteEnforcementOptions?: ClientRouteEnforcementOptions;
  DisconnectOnSessionTimeout?: boolean;
}
export const ModifyClientVpnEndpointRequest = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String),
    ServerCertificateArn: S.optional(S.String),
    ConnectionLogOptions: S.optional(ConnectionLogOptions),
    DnsServers: S.optional(DnsServersOptionsModifyStructure),
    VpnPort: S.optional(S.Number),
    Description: S.optional(S.String),
    SplitTunnel: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean),
    SecurityGroupIds: S.optional(ClientVpnSecurityGroupIdSet).pipe(
      T.XmlName("SecurityGroupId"),
    ),
    VpcId: S.optional(S.String),
    SelfServicePortal: S.optional(SelfServicePortal),
    ClientConnectOptions: S.optional(ClientConnectOptions),
    SessionTimeoutHours: S.optional(S.Number),
    ClientLoginBannerOptions: S.optional(ClientLoginBannerOptions),
    ClientRouteEnforcementOptions: S.optional(ClientRouteEnforcementOptions),
    DisconnectOnSessionTimeout: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyClientVpnEndpointRequest",
}) as any as S.Schema<ModifyClientVpnEndpointRequest>;
export interface ModifyClientVpnEndpointResult {
  Return?: boolean;
}
export const ModifyClientVpnEndpointResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyClientVpnEndpointResult",
}) as any as S.Schema<ModifyClientVpnEndpointResult>;
export interface ModifyDefaultCreditSpecificationRequest {
  DryRun?: boolean;
  InstanceFamily?: UnlimitedSupportedInstanceFamily;
  CpuCredits?: string;
}
export const ModifyDefaultCreditSpecificationRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    InstanceFamily: S.optional(UnlimitedSupportedInstanceFamily),
    CpuCredits: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyDefaultCreditSpecificationRequest",
}) as any as S.Schema<ModifyDefaultCreditSpecificationRequest>;
export interface ModifyDefaultCreditSpecificationResult {
  InstanceFamilyCreditSpecification?: InstanceFamilyCreditSpecification;
}
export const ModifyDefaultCreditSpecificationResult = S.suspend(() =>
  S.Struct({
    InstanceFamilyCreditSpecification: S.optional(
      InstanceFamilyCreditSpecification,
    )
      .pipe(
        T.XmlName("instanceFamilyCreditSpecification"),
        T.Ec2QueryName("InstanceFamilyCreditSpecification"),
      )
      .annotate({ identifier: "InstanceFamilyCreditSpecification" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyDefaultCreditSpecificationResult",
}) as any as S.Schema<ModifyDefaultCreditSpecificationResult>;
export interface ModifyEbsDefaultKmsKeyIdRequest {
  KmsKeyId?: string;
  DryRun?: boolean;
}
export const ModifyEbsDefaultKmsKeyIdRequest = S.suspend(() =>
  S.Struct({
    KmsKeyId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyEbsDefaultKmsKeyIdRequest",
}) as any as S.Schema<ModifyEbsDefaultKmsKeyIdRequest>;
export interface ModifyEbsDefaultKmsKeyIdResult {
  KmsKeyId?: string;
}
export const ModifyEbsDefaultKmsKeyIdResult = S.suspend(() =>
  S.Struct({
    KmsKeyId: S.optional(S.String).pipe(
      T.XmlName("kmsKeyId"),
      T.Ec2QueryName("KmsKeyId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyEbsDefaultKmsKeyIdResult",
}) as any as S.Schema<ModifyEbsDefaultKmsKeyIdResult>;
export interface ModifyFleetRequest {
  DryRun?: boolean;
  ExcessCapacityTerminationPolicy?: FleetExcessCapacityTerminationPolicy;
  LaunchTemplateConfigs?: FleetLaunchTemplateConfigRequest[];
  FleetId?: string;
  TargetCapacitySpecification?: TargetCapacitySpecificationRequest;
  Context?: string;
}
export const ModifyFleetRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ExcessCapacityTerminationPolicy: S.optional(
      FleetExcessCapacityTerminationPolicy,
    ),
    LaunchTemplateConfigs: S.optional(
      FleetLaunchTemplateConfigListRequest,
    ).pipe(T.XmlName("LaunchTemplateConfig")),
    FleetId: S.optional(S.String),
    TargetCapacitySpecification: S.optional(TargetCapacitySpecificationRequest),
    Context: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyFleetRequest",
}) as any as S.Schema<ModifyFleetRequest>;
export interface ModifyFleetResult {
  Return?: boolean;
}
export const ModifyFleetResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyFleetResult",
}) as any as S.Schema<ModifyFleetResult>;
export type OperationType = "add" | "remove" | (string & {});
export const OperationType = S.String;
export type UserIdStringList = string[];
export const UserIdStringList = S.Array(S.String.pipe(T.XmlName("UserId")));
export type UserGroupStringList = string[];
export const UserGroupStringList = S.Array(
  S.String.pipe(T.XmlName("UserGroup")),
);
export type ProductCodeStringList = string[];
export const ProductCodeStringList = S.Array(
  S.String.pipe(T.XmlName("ProductCode")),
);
export interface LoadPermissionRequest {
  Group?: PermissionGroup;
  UserId?: string;
}
export const LoadPermissionRequest = S.suspend(() =>
  S.Struct({
    Group: S.optional(PermissionGroup),
    UserId: S.optional(S.String),
  }),
).annotate({
  identifier: "LoadPermissionRequest",
}) as any as S.Schema<LoadPermissionRequest>;
export type LoadPermissionListRequest = LoadPermissionRequest[];
export const LoadPermissionListRequest = S.Array(
  LoadPermissionRequest.pipe(T.XmlName("item")).annotate({
    identifier: "LoadPermissionRequest",
  }),
);
export interface LoadPermissionModifications {
  Add?: LoadPermissionRequest[];
  Remove?: LoadPermissionRequest[];
}
export const LoadPermissionModifications = S.suspend(() =>
  S.Struct({
    Add: S.optional(LoadPermissionListRequest),
    Remove: S.optional(LoadPermissionListRequest),
  }),
).annotate({
  identifier: "LoadPermissionModifications",
}) as any as S.Schema<LoadPermissionModifications>;
export interface ModifyFpgaImageAttributeRequest {
  DryRun?: boolean;
  FpgaImageId?: string;
  Attribute?: FpgaImageAttributeName;
  OperationType?: OperationType;
  UserIds?: string[];
  UserGroups?: string[];
  ProductCodes?: string[];
  LoadPermission?: LoadPermissionModifications;
  Description?: string;
  Name?: string;
}
export const ModifyFpgaImageAttributeRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    FpgaImageId: S.optional(S.String),
    Attribute: S.optional(FpgaImageAttributeName),
    OperationType: S.optional(OperationType),
    UserIds: S.optional(UserIdStringList).pipe(T.XmlName("UserId")),
    UserGroups: S.optional(UserGroupStringList).pipe(T.XmlName("UserGroup")),
    ProductCodes: S.optional(ProductCodeStringList).pipe(
      T.XmlName("ProductCode"),
    ),
    LoadPermission: S.optional(LoadPermissionModifications),
    Description: S.optional(S.String),
    Name: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyFpgaImageAttributeRequest",
}) as any as S.Schema<ModifyFpgaImageAttributeRequest>;
export interface ModifyFpgaImageAttributeResult {
  FpgaImageAttribute?: FpgaImageAttribute;
}
export const ModifyFpgaImageAttributeResult = S.suspend(() =>
  S.Struct({
    FpgaImageAttribute: S.optional(FpgaImageAttribute)
      .pipe(
        T.XmlName("fpgaImageAttribute"),
        T.Ec2QueryName("FpgaImageAttribute"),
      )
      .annotate({ identifier: "FpgaImageAttribute" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyFpgaImageAttributeResult",
}) as any as S.Schema<ModifyFpgaImageAttributeResult>;
export interface ModifyHostsRequest {
  HostRecovery?: HostRecovery;
  InstanceType?: string;
  InstanceFamily?: string;
  HostMaintenance?: HostMaintenance;
  HostIds?: string[];
  AutoPlacement?: AutoPlacement;
}
export const ModifyHostsRequest = S.suspend(() =>
  S.Struct({
    HostRecovery: S.optional(HostRecovery),
    InstanceType: S.optional(S.String),
    InstanceFamily: S.optional(S.String),
    HostMaintenance: S.optional(HostMaintenance),
    HostIds: S.optional(RequestHostIdList).pipe(
      T.XmlName("hostId"),
      T.Ec2QueryName("HostId"),
    ),
    AutoPlacement: S.optional(AutoPlacement).pipe(
      T.XmlName("autoPlacement"),
      T.Ec2QueryName("AutoPlacement"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyHostsRequest",
}) as any as S.Schema<ModifyHostsRequest>;
export type UnsuccessfulItemList = UnsuccessfulItem[];
export const UnsuccessfulItemList = S.Array(
  UnsuccessfulItem.pipe(T.XmlName("item")).annotate({
    identifier: "UnsuccessfulItem",
  }),
);
export interface ModifyHostsResult {
  Successful?: string[];
  Unsuccessful?: UnsuccessfulItem[];
}
export const ModifyHostsResult = S.suspend(() =>
  S.Struct({
    Successful: S.optional(ResponseHostIdList).pipe(
      T.XmlName("successful"),
      T.Ec2QueryName("Successful"),
    ),
    Unsuccessful: S.optional(UnsuccessfulItemList).pipe(
      T.XmlName("unsuccessful"),
      T.Ec2QueryName("Unsuccessful"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyHostsResult",
}) as any as S.Schema<ModifyHostsResult>;
export interface ModifyIdentityIdFormatRequest {
  Resource?: string;
  UseLongIds?: boolean;
  PrincipalArn?: string;
}
export const ModifyIdentityIdFormatRequest = S.suspend(() =>
  S.Struct({
    Resource: S.optional(S.String).pipe(
      T.XmlName("resource"),
      T.Ec2QueryName("Resource"),
    ),
    UseLongIds: S.optional(S.Boolean).pipe(
      T.XmlName("useLongIds"),
      T.Ec2QueryName("UseLongIds"),
    ),
    PrincipalArn: S.optional(S.String).pipe(
      T.XmlName("principalArn"),
      T.Ec2QueryName("PrincipalArn"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyIdentityIdFormatRequest",
}) as any as S.Schema<ModifyIdentityIdFormatRequest>;
export interface ModifyIdentityIdFormatResponse {}
export const ModifyIdentityIdFormatResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "ModifyIdentityIdFormatResponse",
}) as any as S.Schema<ModifyIdentityIdFormatResponse>;
export interface ModifyIdFormatRequest {
  Resource?: string;
  UseLongIds?: boolean;
}
export const ModifyIdFormatRequest = S.suspend(() =>
  S.Struct({
    Resource: S.optional(S.String),
    UseLongIds: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyIdFormatRequest",
}) as any as S.Schema<ModifyIdFormatRequest>;
export interface ModifyIdFormatResponse {}
export const ModifyIdFormatResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "ModifyIdFormatResponse",
}) as any as S.Schema<ModifyIdFormatResponse>;
export interface LaunchPermissionModifications {
  Add?: LaunchPermission[];
  Remove?: LaunchPermission[];
}
export const LaunchPermissionModifications = S.suspend(() =>
  S.Struct({
    Add: S.optional(LaunchPermissionList),
    Remove: S.optional(LaunchPermissionList),
  }),
).annotate({
  identifier: "LaunchPermissionModifications",
}) as any as S.Schema<LaunchPermissionModifications>;
export type OrganizationArnStringList = string[];
export const OrganizationArnStringList = S.Array(
  S.String.pipe(T.XmlName("OrganizationArn")),
);
export type OrganizationalUnitArnStringList = string[];
export const OrganizationalUnitArnStringList = S.Array(
  S.String.pipe(T.XmlName("OrganizationalUnitArn")),
);
export interface ModifyImageAttributeRequest {
  Attribute?: string;
  Description?: AttributeValue;
  ImageId?: string;
  LaunchPermission?: LaunchPermissionModifications;
  OperationType?: OperationType;
  ProductCodes?: string[];
  UserGroups?: string[];
  UserIds?: string[];
  Value?: string;
  OrganizationArns?: string[];
  OrganizationalUnitArns?: string[];
  ImdsSupport?: AttributeValue;
  DryRun?: boolean;
}
export const ModifyImageAttributeRequest = S.suspend(() =>
  S.Struct({
    Attribute: S.optional(S.String),
    Description: S.optional(AttributeValue),
    ImageId: S.optional(S.String),
    LaunchPermission: S.optional(LaunchPermissionModifications),
    OperationType: S.optional(OperationType),
    ProductCodes: S.optional(ProductCodeStringList).pipe(
      T.XmlName("ProductCode"),
    ),
    UserGroups: S.optional(UserGroupStringList).pipe(T.XmlName("UserGroup")),
    UserIds: S.optional(UserIdStringList).pipe(T.XmlName("UserId")),
    Value: S.optional(S.String),
    OrganizationArns: S.optional(OrganizationArnStringList).pipe(
      T.XmlName("OrganizationArn"),
    ),
    OrganizationalUnitArns: S.optional(OrganizationalUnitArnStringList).pipe(
      T.XmlName("OrganizationalUnitArn"),
    ),
    ImdsSupport: S.optional(AttributeValue),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyImageAttributeRequest",
}) as any as S.Schema<ModifyImageAttributeRequest>;
export interface ModifyImageAttributeResponse {}
export const ModifyImageAttributeResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "ModifyImageAttributeResponse",
}) as any as S.Schema<ModifyImageAttributeResponse>;
export interface EbsInstanceBlockDeviceSpecification {
  VolumeId?: string;
  DeleteOnTermination?: boolean;
}
export const EbsInstanceBlockDeviceSpecification = S.suspend(() =>
  S.Struct({
    VolumeId: S.optional(S.String).pipe(
      T.XmlName("volumeId"),
      T.Ec2QueryName("VolumeId"),
    ),
    DeleteOnTermination: S.optional(S.Boolean).pipe(
      T.XmlName("deleteOnTermination"),
      T.Ec2QueryName("DeleteOnTermination"),
    ),
  }),
).annotate({
  identifier: "EbsInstanceBlockDeviceSpecification",
}) as any as S.Schema<EbsInstanceBlockDeviceSpecification>;
export interface InstanceBlockDeviceMappingSpecification {
  DeviceName?: string;
  Ebs?: EbsInstanceBlockDeviceSpecification;
  VirtualName?: string;
  NoDevice?: string;
}
export const InstanceBlockDeviceMappingSpecification = S.suspend(() =>
  S.Struct({
    DeviceName: S.optional(S.String).pipe(
      T.XmlName("deviceName"),
      T.Ec2QueryName("DeviceName"),
    ),
    Ebs: S.optional(EbsInstanceBlockDeviceSpecification)
      .pipe(T.XmlName("ebs"), T.Ec2QueryName("Ebs"))
      .annotate({ identifier: "EbsInstanceBlockDeviceSpecification" }),
    VirtualName: S.optional(S.String).pipe(
      T.XmlName("virtualName"),
      T.Ec2QueryName("VirtualName"),
    ),
    NoDevice: S.optional(S.String).pipe(
      T.XmlName("noDevice"),
      T.Ec2QueryName("NoDevice"),
    ),
  }),
).annotate({
  identifier: "InstanceBlockDeviceMappingSpecification",
}) as any as S.Schema<InstanceBlockDeviceMappingSpecification>;
export type InstanceBlockDeviceMappingSpecificationList =
  InstanceBlockDeviceMappingSpecification[];
export const InstanceBlockDeviceMappingSpecificationList = S.Array(
  InstanceBlockDeviceMappingSpecification.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceBlockDeviceMappingSpecification",
  }),
);
export interface BlobAttributeValue {
  Value?: Uint8Array;
}
export const BlobAttributeValue = S.suspend(() =>
  S.Struct({
    Value: S.optional(T.Blob).pipe(T.XmlName("value"), T.Ec2QueryName("Value")),
  }),
).annotate({
  identifier: "BlobAttributeValue",
}) as any as S.Schema<BlobAttributeValue>;
export interface ModifyInstanceAttributeRequest {
  SourceDestCheck?: AttributeBooleanValue;
  DisableApiStop?: AttributeBooleanValue;
  DryRun?: boolean;
  InstanceId?: string;
  Attribute?: InstanceAttributeName;
  Value?: string;
  BlockDeviceMappings?: InstanceBlockDeviceMappingSpecification[];
  DisableApiTermination?: AttributeBooleanValue;
  InstanceType?: AttributeValue;
  Kernel?: AttributeValue;
  Ramdisk?: AttributeValue;
  UserData?: BlobAttributeValue;
  InstanceInitiatedShutdownBehavior?: AttributeValue;
  Groups?: string[];
  EbsOptimized?: AttributeBooleanValue;
  SriovNetSupport?: AttributeValue;
  EnaSupport?: AttributeBooleanValue;
}
export const ModifyInstanceAttributeRequest = S.suspend(() =>
  S.Struct({
    SourceDestCheck: S.optional(AttributeBooleanValue),
    DisableApiStop: S.optional(AttributeBooleanValue),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    Attribute: S.optional(InstanceAttributeName).pipe(
      T.XmlName("attribute"),
      T.Ec2QueryName("Attribute"),
    ),
    Value: S.optional(S.String).pipe(
      T.XmlName("value"),
      T.Ec2QueryName("Value"),
    ),
    BlockDeviceMappings: S.optional(
      InstanceBlockDeviceMappingSpecificationList,
    ).pipe(
      T.XmlName("blockDeviceMapping"),
      T.Ec2QueryName("BlockDeviceMapping"),
    ),
    DisableApiTermination: S.optional(AttributeBooleanValue)
      .pipe(
        T.XmlName("disableApiTermination"),
        T.Ec2QueryName("DisableApiTermination"),
      )
      .annotate({ identifier: "AttributeBooleanValue" }),
    InstanceType: S.optional(AttributeValue)
      .pipe(T.XmlName("instanceType"), T.Ec2QueryName("InstanceType"))
      .annotate({ identifier: "AttributeValue" }),
    Kernel: S.optional(AttributeValue)
      .pipe(T.XmlName("kernel"), T.Ec2QueryName("Kernel"))
      .annotate({ identifier: "AttributeValue" }),
    Ramdisk: S.optional(AttributeValue)
      .pipe(T.XmlName("ramdisk"), T.Ec2QueryName("Ramdisk"))
      .annotate({ identifier: "AttributeValue" }),
    UserData: S.optional(BlobAttributeValue)
      .pipe(T.XmlName("userData"), T.Ec2QueryName("UserData"))
      .annotate({ identifier: "BlobAttributeValue" }),
    InstanceInitiatedShutdownBehavior: S.optional(AttributeValue)
      .pipe(
        T.XmlName("instanceInitiatedShutdownBehavior"),
        T.Ec2QueryName("InstanceInitiatedShutdownBehavior"),
      )
      .annotate({ identifier: "AttributeValue" }),
    Groups: S.optional(GroupIdStringList).pipe(T.XmlName("GroupId")),
    EbsOptimized: S.optional(AttributeBooleanValue)
      .pipe(T.XmlName("ebsOptimized"), T.Ec2QueryName("EbsOptimized"))
      .annotate({ identifier: "AttributeBooleanValue" }),
    SriovNetSupport: S.optional(AttributeValue)
      .pipe(T.XmlName("sriovNetSupport"), T.Ec2QueryName("SriovNetSupport"))
      .annotate({ identifier: "AttributeValue" }),
    EnaSupport: S.optional(AttributeBooleanValue)
      .pipe(T.XmlName("enaSupport"), T.Ec2QueryName("EnaSupport"))
      .annotate({ identifier: "AttributeBooleanValue" }),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyInstanceAttributeRequest",
}) as any as S.Schema<ModifyInstanceAttributeRequest>;
export interface ModifyInstanceAttributeResponse {}
export const ModifyInstanceAttributeResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "ModifyInstanceAttributeResponse",
}) as any as S.Schema<ModifyInstanceAttributeResponse>;
export interface CapacityReservationSpecification {
  CapacityReservationPreference?: CapacityReservationPreference;
  CapacityReservationTarget?: CapacityReservationTarget;
}
export const CapacityReservationSpecification = S.suspend(() =>
  S.Struct({
    CapacityReservationPreference: S.optional(CapacityReservationPreference),
    CapacityReservationTarget: S.optional(CapacityReservationTarget),
  }),
).annotate({
  identifier: "CapacityReservationSpecification",
}) as any as S.Schema<CapacityReservationSpecification>;
export interface ModifyInstanceCapacityReservationAttributesRequest {
  InstanceId?: string;
  CapacityReservationSpecification?: CapacityReservationSpecification;
  DryRun?: boolean;
}
export const ModifyInstanceCapacityReservationAttributesRequest = S.suspend(
  () =>
    S.Struct({
      InstanceId: S.optional(S.String),
      CapacityReservationSpecification: S.optional(
        CapacityReservationSpecification,
      ),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "ModifyInstanceCapacityReservationAttributesRequest",
}) as any as S.Schema<ModifyInstanceCapacityReservationAttributesRequest>;
export interface ModifyInstanceCapacityReservationAttributesResult {
  Return?: boolean;
}
export const ModifyInstanceCapacityReservationAttributesResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyInstanceCapacityReservationAttributesResult",
}) as any as S.Schema<ModifyInstanceCapacityReservationAttributesResult>;
export interface ModifyInstanceConnectEndpointRequest {
  DryRun?: boolean;
  InstanceConnectEndpointId?: string;
  IpAddressType?: IpAddressType;
  SecurityGroupIds?: string[];
  PreserveClientIp?: boolean;
}
export const ModifyInstanceConnectEndpointRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    InstanceConnectEndpointId: S.optional(S.String),
    IpAddressType: S.optional(IpAddressType),
    SecurityGroupIds: S.optional(SecurityGroupIdStringListRequest).pipe(
      T.XmlName("SecurityGroupId"),
    ),
    PreserveClientIp: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyInstanceConnectEndpointRequest",
}) as any as S.Schema<ModifyInstanceConnectEndpointRequest>;
export interface ModifyInstanceConnectEndpointResult {
  Return?: boolean;
}
export const ModifyInstanceConnectEndpointResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyInstanceConnectEndpointResult",
}) as any as S.Schema<ModifyInstanceConnectEndpointResult>;
export interface ModifyInstanceCpuOptionsRequest {
  InstanceId?: string;
  CoreCount?: number;
  ThreadsPerCore?: number;
  NestedVirtualization?: NestedVirtualizationSpecification;
  DryRun?: boolean;
}
export const ModifyInstanceCpuOptionsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    CoreCount: S.optional(S.Number),
    ThreadsPerCore: S.optional(S.Number),
    NestedVirtualization: S.optional(NestedVirtualizationSpecification),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyInstanceCpuOptionsRequest",
}) as any as S.Schema<ModifyInstanceCpuOptionsRequest>;
export interface ModifyInstanceCpuOptionsResult {
  InstanceId?: string;
  CoreCount?: number;
  ThreadsPerCore?: number;
  NestedVirtualization?: NestedVirtualizationSpecification;
}
export const ModifyInstanceCpuOptionsResult = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    CoreCount: S.optional(S.Number).pipe(
      T.XmlName("coreCount"),
      T.Ec2QueryName("CoreCount"),
    ),
    ThreadsPerCore: S.optional(S.Number).pipe(
      T.XmlName("threadsPerCore"),
      T.Ec2QueryName("ThreadsPerCore"),
    ),
    NestedVirtualization: S.optional(NestedVirtualizationSpecification).pipe(
      T.XmlName("nestedVirtualization"),
      T.Ec2QueryName("NestedVirtualization"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyInstanceCpuOptionsResult",
}) as any as S.Schema<ModifyInstanceCpuOptionsResult>;
export interface InstanceCreditSpecificationRequest {
  InstanceId?: string;
  CpuCredits?: string;
}
export const InstanceCreditSpecificationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    CpuCredits: S.optional(S.String),
  }),
).annotate({
  identifier: "InstanceCreditSpecificationRequest",
}) as any as S.Schema<InstanceCreditSpecificationRequest>;
export type InstanceCreditSpecificationListRequest =
  InstanceCreditSpecificationRequest[];
export const InstanceCreditSpecificationListRequest = S.Array(
  InstanceCreditSpecificationRequest.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceCreditSpecificationRequest",
  }),
);
export interface ModifyInstanceCreditSpecificationRequest {
  DryRun?: boolean;
  ClientToken?: string;
  InstanceCreditSpecifications?: InstanceCreditSpecificationRequest[];
}
export const ModifyInstanceCreditSpecificationRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String),
    InstanceCreditSpecifications: S.optional(
      InstanceCreditSpecificationListRequest,
    ).pipe(T.XmlName("InstanceCreditSpecification")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyInstanceCreditSpecificationRequest",
}) as any as S.Schema<ModifyInstanceCreditSpecificationRequest>;
export interface SuccessfulInstanceCreditSpecificationItem {
  InstanceId?: string;
}
export const SuccessfulInstanceCreditSpecificationItem = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
  }),
).annotate({
  identifier: "SuccessfulInstanceCreditSpecificationItem",
}) as any as S.Schema<SuccessfulInstanceCreditSpecificationItem>;
export type SuccessfulInstanceCreditSpecificationSet =
  SuccessfulInstanceCreditSpecificationItem[];
export const SuccessfulInstanceCreditSpecificationSet = S.Array(
  SuccessfulInstanceCreditSpecificationItem.pipe(T.XmlName("item")).annotate({
    identifier: "SuccessfulInstanceCreditSpecificationItem",
  }),
);
export type UnsuccessfulInstanceCreditSpecificationErrorCode =
  | "InvalidInstanceID.Malformed"
  | "InvalidInstanceID.NotFound"
  | "IncorrectInstanceState"
  | "InstanceCreditSpecification.NotSupported"
  | (string & {});
export const UnsuccessfulInstanceCreditSpecificationErrorCode = S.String;
export interface UnsuccessfulInstanceCreditSpecificationItemError {
  Code?: UnsuccessfulInstanceCreditSpecificationErrorCode;
  Message?: string;
}
export const UnsuccessfulInstanceCreditSpecificationItemError = S.suspend(() =>
  S.Struct({
    Code: S.optional(UnsuccessfulInstanceCreditSpecificationErrorCode).pipe(
      T.XmlName("code"),
      T.Ec2QueryName("Code"),
    ),
    Message: S.optional(S.String).pipe(
      T.XmlName("message"),
      T.Ec2QueryName("Message"),
    ),
  }),
).annotate({
  identifier: "UnsuccessfulInstanceCreditSpecificationItemError",
}) as any as S.Schema<UnsuccessfulInstanceCreditSpecificationItemError>;
export interface UnsuccessfulInstanceCreditSpecificationItem {
  InstanceId?: string;
  Error?: UnsuccessfulInstanceCreditSpecificationItemError;
}
export const UnsuccessfulInstanceCreditSpecificationItem = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    Error: S.optional(UnsuccessfulInstanceCreditSpecificationItemError)
      .pipe(T.XmlName("error"), T.Ec2QueryName("Error"))
      .annotate({
        identifier: "UnsuccessfulInstanceCreditSpecificationItemError",
      }),
  }),
).annotate({
  identifier: "UnsuccessfulInstanceCreditSpecificationItem",
}) as any as S.Schema<UnsuccessfulInstanceCreditSpecificationItem>;
export type UnsuccessfulInstanceCreditSpecificationSet =
  UnsuccessfulInstanceCreditSpecificationItem[];
export const UnsuccessfulInstanceCreditSpecificationSet = S.Array(
  UnsuccessfulInstanceCreditSpecificationItem.pipe(T.XmlName("item")).annotate({
    identifier: "UnsuccessfulInstanceCreditSpecificationItem",
  }),
);
export interface ModifyInstanceCreditSpecificationResult {
  SuccessfulInstanceCreditSpecifications?: SuccessfulInstanceCreditSpecificationItem[];
  UnsuccessfulInstanceCreditSpecifications?: UnsuccessfulInstanceCreditSpecificationItem[];
}
export const ModifyInstanceCreditSpecificationResult = S.suspend(() =>
  S.Struct({
    SuccessfulInstanceCreditSpecifications: S.optional(
      SuccessfulInstanceCreditSpecificationSet,
    ).pipe(
      T.XmlName("successfulInstanceCreditSpecificationSet"),
      T.Ec2QueryName("SuccessfulInstanceCreditSpecificationSet"),
    ),
    UnsuccessfulInstanceCreditSpecifications: S.optional(
      UnsuccessfulInstanceCreditSpecificationSet,
    ).pipe(
      T.XmlName("unsuccessfulInstanceCreditSpecificationSet"),
      T.Ec2QueryName("UnsuccessfulInstanceCreditSpecificationSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyInstanceCreditSpecificationResult",
}) as any as S.Schema<ModifyInstanceCreditSpecificationResult>;
export interface ModifyInstanceEventStartTimeRequest {
  DryRun?: boolean;
  InstanceId?: string;
  InstanceEventId?: string;
  NotBefore?: Date;
}
export const ModifyInstanceEventStartTimeRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    InstanceId: S.optional(S.String),
    InstanceEventId: S.optional(S.String),
    NotBefore: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyInstanceEventStartTimeRequest",
}) as any as S.Schema<ModifyInstanceEventStartTimeRequest>;
export interface ModifyInstanceEventStartTimeResult {
  Event?: InstanceStatusEvent;
}
export const ModifyInstanceEventStartTimeResult = S.suspend(() =>
  S.Struct({
    Event: S.optional(InstanceStatusEvent)
      .pipe(T.XmlName("event"), T.Ec2QueryName("Event"))
      .annotate({ identifier: "InstanceStatusEvent" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyInstanceEventStartTimeResult",
}) as any as S.Schema<ModifyInstanceEventStartTimeResult>;
export interface ModifyInstanceEventWindowRequest {
  DryRun?: boolean;
  Name?: string;
  InstanceEventWindowId?: string;
  TimeRanges?: InstanceEventWindowTimeRangeRequest[];
  CronExpression?: string;
}
export const ModifyInstanceEventWindowRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Name: S.optional(S.String),
    InstanceEventWindowId: S.optional(S.String),
    TimeRanges: S.optional(InstanceEventWindowTimeRangeRequestSet).pipe(
      T.XmlName("TimeRange"),
    ),
    CronExpression: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyInstanceEventWindowRequest",
}) as any as S.Schema<ModifyInstanceEventWindowRequest>;
export interface ModifyInstanceEventWindowResult {
  InstanceEventWindow?: InstanceEventWindow;
}
export const ModifyInstanceEventWindowResult = S.suspend(() =>
  S.Struct({
    InstanceEventWindow: S.optional(InstanceEventWindow)
      .pipe(
        T.XmlName("instanceEventWindow"),
        T.Ec2QueryName("InstanceEventWindow"),
      )
      .annotate({ identifier: "InstanceEventWindow" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyInstanceEventWindowResult",
}) as any as S.Schema<ModifyInstanceEventWindowResult>;
export interface ModifyInstanceMaintenanceOptionsRequest {
  InstanceId?: string;
  AutoRecovery?: InstanceAutoRecoveryState;
  RebootMigration?: InstanceRebootMigrationState;
  DryRun?: boolean;
}
export const ModifyInstanceMaintenanceOptionsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    AutoRecovery: S.optional(InstanceAutoRecoveryState),
    RebootMigration: S.optional(InstanceRebootMigrationState),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyInstanceMaintenanceOptionsRequest",
}) as any as S.Schema<ModifyInstanceMaintenanceOptionsRequest>;
export interface ModifyInstanceMaintenanceOptionsResult {
  InstanceId?: string;
  AutoRecovery?: InstanceAutoRecoveryState;
  RebootMigration?: InstanceRebootMigrationState;
}
export const ModifyInstanceMaintenanceOptionsResult = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    AutoRecovery: S.optional(InstanceAutoRecoveryState).pipe(
      T.XmlName("autoRecovery"),
      T.Ec2QueryName("AutoRecovery"),
    ),
    RebootMigration: S.optional(InstanceRebootMigrationState).pipe(
      T.XmlName("rebootMigration"),
      T.Ec2QueryName("RebootMigration"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyInstanceMaintenanceOptionsResult",
}) as any as S.Schema<ModifyInstanceMaintenanceOptionsResult>;
export type MetadataDefaultHttpTokensState =
  | "optional"
  | "required"
  | "no-preference"
  | (string & {});
export const MetadataDefaultHttpTokensState = S.String;
export type DefaultInstanceMetadataEndpointState =
  | "disabled"
  | "enabled"
  | "no-preference"
  | (string & {});
export const DefaultInstanceMetadataEndpointState = S.String;
export type DefaultInstanceMetadataTagsState =
  | "disabled"
  | "enabled"
  | "no-preference"
  | (string & {});
export const DefaultInstanceMetadataTagsState = S.String;
export type DefaultHttpTokensEnforcedState =
  | "disabled"
  | "enabled"
  | "no-preference"
  | (string & {});
export const DefaultHttpTokensEnforcedState = S.String;
export interface ModifyInstanceMetadataDefaultsRequest {
  HttpTokens?: MetadataDefaultHttpTokensState;
  HttpPutResponseHopLimit?: number;
  HttpEndpoint?: DefaultInstanceMetadataEndpointState;
  InstanceMetadataTags?: DefaultInstanceMetadataTagsState;
  DryRun?: boolean;
  HttpTokensEnforced?: DefaultHttpTokensEnforcedState;
}
export const ModifyInstanceMetadataDefaultsRequest = S.suspend(() =>
  S.Struct({
    HttpTokens: S.optional(MetadataDefaultHttpTokensState),
    HttpPutResponseHopLimit: S.optional(S.Number),
    HttpEndpoint: S.optional(DefaultInstanceMetadataEndpointState),
    InstanceMetadataTags: S.optional(DefaultInstanceMetadataTagsState),
    DryRun: S.optional(S.Boolean),
    HttpTokensEnforced: S.optional(DefaultHttpTokensEnforcedState),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyInstanceMetadataDefaultsRequest",
}) as any as S.Schema<ModifyInstanceMetadataDefaultsRequest>;
export interface ModifyInstanceMetadataDefaultsResult {
  Return?: boolean;
}
export const ModifyInstanceMetadataDefaultsResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyInstanceMetadataDefaultsResult",
}) as any as S.Schema<ModifyInstanceMetadataDefaultsResult>;
export interface ModifyInstanceMetadataOptionsRequest {
  InstanceId?: string;
  HttpTokens?: HttpTokensState;
  HttpPutResponseHopLimit?: number;
  HttpEndpoint?: InstanceMetadataEndpointState;
  DryRun?: boolean;
  HttpProtocolIpv6?: InstanceMetadataProtocolState;
  InstanceMetadataTags?: InstanceMetadataTagsState;
}
export const ModifyInstanceMetadataOptionsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    HttpTokens: S.optional(HttpTokensState),
    HttpPutResponseHopLimit: S.optional(S.Number),
    HttpEndpoint: S.optional(InstanceMetadataEndpointState),
    DryRun: S.optional(S.Boolean),
    HttpProtocolIpv6: S.optional(InstanceMetadataProtocolState),
    InstanceMetadataTags: S.optional(InstanceMetadataTagsState),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyInstanceMetadataOptionsRequest",
}) as any as S.Schema<ModifyInstanceMetadataOptionsRequest>;
export interface ModifyInstanceMetadataOptionsResult {
  InstanceId?: string;
  InstanceMetadataOptions?: InstanceMetadataOptionsResponse;
}
export const ModifyInstanceMetadataOptionsResult = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    InstanceMetadataOptions: S.optional(InstanceMetadataOptionsResponse)
      .pipe(
        T.XmlName("instanceMetadataOptions"),
        T.Ec2QueryName("InstanceMetadataOptions"),
      )
      .annotate({ identifier: "InstanceMetadataOptionsResponse" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyInstanceMetadataOptionsResult",
}) as any as S.Schema<ModifyInstanceMetadataOptionsResult>;
export interface ModifyInstanceNetworkPerformanceRequest {
  InstanceId?: string;
  BandwidthWeighting?: InstanceBandwidthWeighting;
  DryRun?: boolean;
}
export const ModifyInstanceNetworkPerformanceRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    BandwidthWeighting: S.optional(InstanceBandwidthWeighting),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyInstanceNetworkPerformanceRequest",
}) as any as S.Schema<ModifyInstanceNetworkPerformanceRequest>;
export interface ModifyInstanceNetworkPerformanceResult {
  InstanceId?: string;
  BandwidthWeighting?: InstanceBandwidthWeighting;
}
export const ModifyInstanceNetworkPerformanceResult = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    BandwidthWeighting: S.optional(InstanceBandwidthWeighting).pipe(
      T.XmlName("bandwidthWeighting"),
      T.Ec2QueryName("BandwidthWeighting"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyInstanceNetworkPerformanceResult",
}) as any as S.Schema<ModifyInstanceNetworkPerformanceResult>;
export type HostTenancy = "default" | "dedicated" | "host" | (string & {});
export const HostTenancy = S.String;
export type Affinity = "default" | "host" | (string & {});
export const Affinity = S.String;
export interface ModifyInstancePlacementRequest {
  GroupName?: string;
  PartitionNumber?: number;
  HostResourceGroupArn?: string;
  GroupId?: string;
  InstanceId?: string;
  Tenancy?: HostTenancy;
  Affinity?: Affinity;
  HostId?: string;
}
export const ModifyInstancePlacementRequest = S.suspend(() =>
  S.Struct({
    GroupName: S.optional(S.String),
    PartitionNumber: S.optional(S.Number),
    HostResourceGroupArn: S.optional(S.String),
    GroupId: S.optional(S.String),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    Tenancy: S.optional(HostTenancy).pipe(
      T.XmlName("tenancy"),
      T.Ec2QueryName("Tenancy"),
    ),
    Affinity: S.optional(Affinity).pipe(
      T.XmlName("affinity"),
      T.Ec2QueryName("Affinity"),
    ),
    HostId: S.optional(S.String).pipe(
      T.XmlName("hostId"),
      T.Ec2QueryName("HostId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyInstancePlacementRequest",
}) as any as S.Schema<ModifyInstancePlacementRequest>;
export interface ModifyInstancePlacementResult {
  Return?: boolean;
}
export const ModifyInstancePlacementResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyInstancePlacementResult",
}) as any as S.Schema<ModifyInstancePlacementResult>;
export interface RemoveIpamOperatingRegion {
  RegionName?: string;
}
export const RemoveIpamOperatingRegion = S.suspend(() =>
  S.Struct({ RegionName: S.optional(S.String) }),
).annotate({
  identifier: "RemoveIpamOperatingRegion",
}) as any as S.Schema<RemoveIpamOperatingRegion>;
export type RemoveIpamOperatingRegionSet = RemoveIpamOperatingRegion[];
export const RemoveIpamOperatingRegionSet = S.Array(RemoveIpamOperatingRegion);
export interface ModifyIpamRequest {
  DryRun?: boolean;
  IpamId?: string;
  Description?: string;
  AddOperatingRegions?: AddIpamOperatingRegion[];
  RemoveOperatingRegions?: RemoveIpamOperatingRegion[];
  Tier?: IpamTier;
  EnablePrivateGua?: boolean;
  MeteredAccount?: IpamMeteredAccount;
}
export const ModifyIpamRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamId: S.optional(S.String),
    Description: S.optional(S.String),
    AddOperatingRegions: S.optional(AddIpamOperatingRegionSet).pipe(
      T.XmlName("AddOperatingRegion"),
    ),
    RemoveOperatingRegions: S.optional(RemoveIpamOperatingRegionSet).pipe(
      T.XmlName("RemoveOperatingRegion"),
    ),
    Tier: S.optional(IpamTier),
    EnablePrivateGua: S.optional(S.Boolean),
    MeteredAccount: S.optional(IpamMeteredAccount),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyIpamRequest",
}) as any as S.Schema<ModifyIpamRequest>;
export interface ModifyIpamResult {
  Ipam?: Ipam;
}
export const ModifyIpamResult = S.suspend(() =>
  S.Struct({
    Ipam: S.optional(Ipam)
      .pipe(T.XmlName("ipam"), T.Ec2QueryName("Ipam"))
      .annotate({ identifier: "Ipam" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyIpamResult",
}) as any as S.Schema<ModifyIpamResult>;
export interface IpamPolicyAllocationRuleRequest {
  SourceIpamPoolId?: string;
}
export const IpamPolicyAllocationRuleRequest = S.suspend(() =>
  S.Struct({ SourceIpamPoolId: S.optional(S.String) }),
).annotate({
  identifier: "IpamPolicyAllocationRuleRequest",
}) as any as S.Schema<IpamPolicyAllocationRuleRequest>;
export type IpamPolicyAllocationRuleListRequest =
  IpamPolicyAllocationRuleRequest[];
export const IpamPolicyAllocationRuleListRequest = S.Array(
  IpamPolicyAllocationRuleRequest.pipe(T.XmlName("item")).annotate({
    identifier: "IpamPolicyAllocationRuleRequest",
  }),
);
export interface ModifyIpamPolicyAllocationRulesRequest {
  DryRun?: boolean;
  IpamPolicyId?: string;
  Locale?: string;
  ResourceType?: IpamPolicyResourceType;
  AllocationRules?: IpamPolicyAllocationRuleRequest[];
}
export const ModifyIpamPolicyAllocationRulesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPolicyId: S.optional(S.String),
    Locale: S.optional(S.String),
    ResourceType: S.optional(IpamPolicyResourceType),
    AllocationRules: S.optional(IpamPolicyAllocationRuleListRequest).pipe(
      T.XmlName("AllocationRule"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyIpamPolicyAllocationRulesRequest",
}) as any as S.Schema<ModifyIpamPolicyAllocationRulesRequest>;
export interface ModifyIpamPolicyAllocationRulesResult {
  IpamPolicyDocument?: IpamPolicyDocument;
}
export const ModifyIpamPolicyAllocationRulesResult = S.suspend(() =>
  S.Struct({
    IpamPolicyDocument: S.optional(IpamPolicyDocument)
      .pipe(
        T.XmlName("ipamPolicyDocument"),
        T.Ec2QueryName("IpamPolicyDocument"),
      )
      .annotate({ identifier: "IpamPolicyDocument" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyIpamPolicyAllocationRulesResult",
}) as any as S.Schema<ModifyIpamPolicyAllocationRulesResult>;
export interface ModifyIpamPoolRequest {
  DryRun?: boolean;
  IpamPoolId?: string;
  Description?: string;
  AutoImport?: boolean;
  AllocationMinNetmaskLength?: number;
  AllocationMaxNetmaskLength?: number;
  AllocationDefaultNetmaskLength?: number;
  ClearAllocationDefaultNetmaskLength?: boolean;
  AddAllocationResourceTags?: RequestIpamResourceTag[];
  RemoveAllocationResourceTags?: RequestIpamResourceTag[];
}
export const ModifyIpamPoolRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPoolId: S.optional(S.String),
    Description: S.optional(S.String),
    AutoImport: S.optional(S.Boolean),
    AllocationMinNetmaskLength: S.optional(S.Number),
    AllocationMaxNetmaskLength: S.optional(S.Number),
    AllocationDefaultNetmaskLength: S.optional(S.Number),
    ClearAllocationDefaultNetmaskLength: S.optional(S.Boolean),
    AddAllocationResourceTags: S.optional(RequestIpamResourceTagList).pipe(
      T.XmlName("AddAllocationResourceTag"),
    ),
    RemoveAllocationResourceTags: S.optional(RequestIpamResourceTagList).pipe(
      T.XmlName("RemoveAllocationResourceTag"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyIpamPoolRequest",
}) as any as S.Schema<ModifyIpamPoolRequest>;
export interface ModifyIpamPoolResult {
  IpamPool?: IpamPool;
}
export const ModifyIpamPoolResult = S.suspend(() =>
  S.Struct({
    IpamPool: S.optional(IpamPool)
      .pipe(T.XmlName("ipamPool"), T.Ec2QueryName("IpamPool"))
      .annotate({ identifier: "IpamPool" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyIpamPoolResult",
}) as any as S.Schema<ModifyIpamPoolResult>;
export interface ModifyIpamPrefixListResolverRequest {
  DryRun?: boolean;
  IpamPrefixListResolverId?: string;
  Description?: string;
  Rules?: IpamPrefixListResolverRuleRequest[];
}
export const ModifyIpamPrefixListResolverRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPrefixListResolverId: S.optional(S.String),
    Description: S.optional(S.String),
    Rules: S.optional(IpamPrefixListResolverRuleRequestSet).pipe(
      T.XmlName("Rule"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyIpamPrefixListResolverRequest",
}) as any as S.Schema<ModifyIpamPrefixListResolverRequest>;
export interface ModifyIpamPrefixListResolverResult {
  IpamPrefixListResolver?: IpamPrefixListResolver;
}
export const ModifyIpamPrefixListResolverResult = S.suspend(() =>
  S.Struct({
    IpamPrefixListResolver: S.optional(IpamPrefixListResolver)
      .pipe(
        T.XmlName("ipamPrefixListResolver"),
        T.Ec2QueryName("IpamPrefixListResolver"),
      )
      .annotate({ identifier: "IpamPrefixListResolver" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyIpamPrefixListResolverResult",
}) as any as S.Schema<ModifyIpamPrefixListResolverResult>;
export interface ModifyIpamPrefixListResolverTargetRequest {
  DryRun?: boolean;
  IpamPrefixListResolverTargetId?: string;
  DesiredVersion?: number;
  TrackLatestVersion?: boolean;
  ClientToken?: string;
}
export const ModifyIpamPrefixListResolverTargetRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPrefixListResolverTargetId: S.optional(S.String),
    DesiredVersion: S.optional(S.Number),
    TrackLatestVersion: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyIpamPrefixListResolverTargetRequest",
}) as any as S.Schema<ModifyIpamPrefixListResolverTargetRequest>;
export interface ModifyIpamPrefixListResolverTargetResult {
  IpamPrefixListResolverTarget?: IpamPrefixListResolverTarget;
}
export const ModifyIpamPrefixListResolverTargetResult = S.suspend(() =>
  S.Struct({
    IpamPrefixListResolverTarget: S.optional(IpamPrefixListResolverTarget)
      .pipe(
        T.XmlName("ipamPrefixListResolverTarget"),
        T.Ec2QueryName("IpamPrefixListResolverTarget"),
      )
      .annotate({ identifier: "IpamPrefixListResolverTarget" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyIpamPrefixListResolverTargetResult",
}) as any as S.Schema<ModifyIpamPrefixListResolverTargetResult>;
export interface ModifyIpamResourceCidrRequest {
  DryRun?: boolean;
  ResourceId?: string;
  ResourceCidr?: string;
  ResourceRegion?: string;
  CurrentIpamScopeId?: string;
  DestinationIpamScopeId?: string;
  Monitored?: boolean;
}
export const ModifyIpamResourceCidrRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ResourceId: S.optional(S.String),
    ResourceCidr: S.optional(S.String),
    ResourceRegion: S.optional(S.String),
    CurrentIpamScopeId: S.optional(S.String),
    DestinationIpamScopeId: S.optional(S.String),
    Monitored: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyIpamResourceCidrRequest",
}) as any as S.Schema<ModifyIpamResourceCidrRequest>;
export interface ModifyIpamResourceCidrResult {
  IpamResourceCidr?: IpamResourceCidr;
}
export const ModifyIpamResourceCidrResult = S.suspend(() =>
  S.Struct({
    IpamResourceCidr: S.optional(IpamResourceCidr)
      .pipe(T.XmlName("ipamResourceCidr"), T.Ec2QueryName("IpamResourceCidr"))
      .annotate({ identifier: "IpamResourceCidr" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyIpamResourceCidrResult",
}) as any as S.Schema<ModifyIpamResourceCidrResult>;
export interface AddIpamOrganizationalUnitExclusion {
  OrganizationsEntityPath?: string;
}
export const AddIpamOrganizationalUnitExclusion = S.suspend(() =>
  S.Struct({ OrganizationsEntityPath: S.optional(S.String) }),
).annotate({
  identifier: "AddIpamOrganizationalUnitExclusion",
}) as any as S.Schema<AddIpamOrganizationalUnitExclusion>;
export type AddIpamOrganizationalUnitExclusionSet =
  AddIpamOrganizationalUnitExclusion[];
export const AddIpamOrganizationalUnitExclusionSet = S.Array(
  AddIpamOrganizationalUnitExclusion,
);
export interface RemoveIpamOrganizationalUnitExclusion {
  OrganizationsEntityPath?: string;
}
export const RemoveIpamOrganizationalUnitExclusion = S.suspend(() =>
  S.Struct({ OrganizationsEntityPath: S.optional(S.String) }),
).annotate({
  identifier: "RemoveIpamOrganizationalUnitExclusion",
}) as any as S.Schema<RemoveIpamOrganizationalUnitExclusion>;
export type RemoveIpamOrganizationalUnitExclusionSet =
  RemoveIpamOrganizationalUnitExclusion[];
export const RemoveIpamOrganizationalUnitExclusionSet = S.Array(
  RemoveIpamOrganizationalUnitExclusion,
);
export interface ModifyIpamResourceDiscoveryRequest {
  DryRun?: boolean;
  IpamResourceDiscoveryId?: string;
  Description?: string;
  AddOperatingRegions?: AddIpamOperatingRegion[];
  RemoveOperatingRegions?: RemoveIpamOperatingRegion[];
  AddOrganizationalUnitExclusions?: AddIpamOrganizationalUnitExclusion[];
  RemoveOrganizationalUnitExclusions?: RemoveIpamOrganizationalUnitExclusion[];
}
export const ModifyIpamResourceDiscoveryRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamResourceDiscoveryId: S.optional(S.String),
    Description: S.optional(S.String),
    AddOperatingRegions: S.optional(AddIpamOperatingRegionSet).pipe(
      T.XmlName("AddOperatingRegion"),
    ),
    RemoveOperatingRegions: S.optional(RemoveIpamOperatingRegionSet).pipe(
      T.XmlName("RemoveOperatingRegion"),
    ),
    AddOrganizationalUnitExclusions: S.optional(
      AddIpamOrganizationalUnitExclusionSet,
    ).pipe(T.XmlName("AddOrganizationalUnitExclusion")),
    RemoveOrganizationalUnitExclusions: S.optional(
      RemoveIpamOrganizationalUnitExclusionSet,
    ).pipe(T.XmlName("RemoveOrganizationalUnitExclusion")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyIpamResourceDiscoveryRequest",
}) as any as S.Schema<ModifyIpamResourceDiscoveryRequest>;
export interface ModifyIpamResourceDiscoveryResult {
  IpamResourceDiscovery?: IpamResourceDiscovery;
}
export const ModifyIpamResourceDiscoveryResult = S.suspend(() =>
  S.Struct({
    IpamResourceDiscovery: S.optional(IpamResourceDiscovery)
      .pipe(
        T.XmlName("ipamResourceDiscovery"),
        T.Ec2QueryName("IpamResourceDiscovery"),
      )
      .annotate({ identifier: "IpamResourceDiscovery" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyIpamResourceDiscoveryResult",
}) as any as S.Schema<ModifyIpamResourceDiscoveryResult>;
export interface ModifyIpamScopeRequest {
  DryRun?: boolean;
  IpamScopeId?: string;
  Description?: string;
  ExternalAuthorityConfiguration?: ExternalAuthorityConfiguration;
  RemoveExternalAuthorityConfiguration?: boolean;
}
export const ModifyIpamScopeRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamScopeId: S.optional(S.String),
    Description: S.optional(S.String),
    ExternalAuthorityConfiguration: S.optional(ExternalAuthorityConfiguration),
    RemoveExternalAuthorityConfiguration: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyIpamScopeRequest",
}) as any as S.Schema<ModifyIpamScopeRequest>;
export interface ModifyIpamScopeResult {
  IpamScope?: IpamScope;
}
export const ModifyIpamScopeResult = S.suspend(() =>
  S.Struct({
    IpamScope: S.optional(IpamScope)
      .pipe(T.XmlName("ipamScope"), T.Ec2QueryName("IpamScope"))
      .annotate({ identifier: "IpamScope" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyIpamScopeResult",
}) as any as S.Schema<ModifyIpamScopeResult>;
export interface ModifyLaunchTemplateRequest {
  DryRun?: boolean;
  ClientToken?: string;
  LaunchTemplateId?: string;
  LaunchTemplateName?: string;
  DefaultVersion?: string;
}
export const ModifyLaunchTemplateRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    LaunchTemplateId: S.optional(S.String),
    LaunchTemplateName: S.optional(S.String),
    DefaultVersion: S.optional(S.String).pipe(T.XmlName("SetDefaultVersion")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyLaunchTemplateRequest",
}) as any as S.Schema<ModifyLaunchTemplateRequest>;
export interface ModifyLaunchTemplateResult {
  LaunchTemplate?: LaunchTemplate;
}
export const ModifyLaunchTemplateResult = S.suspend(() =>
  S.Struct({
    LaunchTemplate: S.optional(LaunchTemplate)
      .pipe(T.XmlName("launchTemplate"), T.Ec2QueryName("LaunchTemplate"))
      .annotate({ identifier: "LaunchTemplate" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyLaunchTemplateResult",
}) as any as S.Schema<ModifyLaunchTemplateResult>;
export interface ModifyLocalGatewayRouteRequest {
  DestinationCidrBlock?: string;
  LocalGatewayRouteTableId?: string;
  LocalGatewayVirtualInterfaceGroupId?: string;
  NetworkInterfaceId?: string;
  DryRun?: boolean;
  DestinationPrefixListId?: string;
}
export const ModifyLocalGatewayRouteRequest = S.suspend(() =>
  S.Struct({
    DestinationCidrBlock: S.optional(S.String),
    LocalGatewayRouteTableId: S.optional(S.String),
    LocalGatewayVirtualInterfaceGroupId: S.optional(S.String),
    NetworkInterfaceId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    DestinationPrefixListId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyLocalGatewayRouteRequest",
}) as any as S.Schema<ModifyLocalGatewayRouteRequest>;
export interface ModifyLocalGatewayRouteResult {
  Route?: LocalGatewayRoute;
}
export const ModifyLocalGatewayRouteResult = S.suspend(() =>
  S.Struct({
    Route: S.optional(LocalGatewayRoute)
      .pipe(T.XmlName("route"), T.Ec2QueryName("Route"))
      .annotate({ identifier: "LocalGatewayRoute" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyLocalGatewayRouteResult",
}) as any as S.Schema<ModifyLocalGatewayRouteResult>;
export interface RemovePrefixListEntry {
  Cidr?: string;
}
export const RemovePrefixListEntry = S.suspend(() =>
  S.Struct({ Cidr: S.optional(S.String) }),
).annotate({
  identifier: "RemovePrefixListEntry",
}) as any as S.Schema<RemovePrefixListEntry>;
export type RemovePrefixListEntries = RemovePrefixListEntry[];
export const RemovePrefixListEntries = S.Array(RemovePrefixListEntry);
export interface ModifyManagedPrefixListRequest {
  DryRun?: boolean;
  PrefixListId?: string;
  CurrentVersion?: number;
  PrefixListName?: string;
  AddEntries?: AddPrefixListEntry[];
  RemoveEntries?: RemovePrefixListEntry[];
  MaxEntries?: number;
  IpamPrefixListResolverSyncEnabled?: boolean;
}
export const ModifyManagedPrefixListRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    PrefixListId: S.optional(S.String),
    CurrentVersion: S.optional(S.Number),
    PrefixListName: S.optional(S.String),
    AddEntries: S.optional(AddPrefixListEntries).pipe(T.XmlName("AddEntry")),
    RemoveEntries: S.optional(RemovePrefixListEntries).pipe(
      T.XmlName("RemoveEntry"),
    ),
    MaxEntries: S.optional(S.Number),
    IpamPrefixListResolverSyncEnabled: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyManagedPrefixListRequest",
}) as any as S.Schema<ModifyManagedPrefixListRequest>;
export interface ModifyManagedPrefixListResult {
  PrefixList?: ManagedPrefixList;
}
export const ModifyManagedPrefixListResult = S.suspend(() =>
  S.Struct({
    PrefixList: S.optional(ManagedPrefixList)
      .pipe(T.XmlName("prefixList"), T.Ec2QueryName("PrefixList"))
      .annotate({ identifier: "ManagedPrefixList" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyManagedPrefixListResult",
}) as any as S.Schema<ModifyManagedPrefixListResult>;
export type SubnetIdList = string[];
export const SubnetIdList = S.Array(
  S.String.pipe(T.XmlName("AssociatedSubnetId")),
);
export interface NetworkInterfaceAttachmentChanges {
  DefaultEnaQueueCount?: boolean;
  EnaQueueCount?: number;
  AttachmentId?: string;
  DeleteOnTermination?: boolean;
}
export const NetworkInterfaceAttachmentChanges = S.suspend(() =>
  S.Struct({
    DefaultEnaQueueCount: S.optional(S.Boolean),
    EnaQueueCount: S.optional(S.Number),
    AttachmentId: S.optional(S.String).pipe(
      T.XmlName("attachmentId"),
      T.Ec2QueryName("AttachmentId"),
    ),
    DeleteOnTermination: S.optional(S.Boolean).pipe(
      T.XmlName("deleteOnTermination"),
      T.Ec2QueryName("DeleteOnTermination"),
    ),
  }),
).annotate({
  identifier: "NetworkInterfaceAttachmentChanges",
}) as any as S.Schema<NetworkInterfaceAttachmentChanges>;
export interface ModifyNetworkInterfaceAttributeRequest {
  EnaSrdSpecification?: EnaSrdSpecification;
  EnablePrimaryIpv6?: boolean;
  ConnectionTrackingSpecification?: ConnectionTrackingSpecificationRequest;
  AssociatePublicIpAddress?: boolean;
  AssociatedSubnetIds?: string[];
  DryRun?: boolean;
  NetworkInterfaceId?: string;
  Description?: AttributeValue;
  SourceDestCheck?: AttributeBooleanValue;
  Groups?: string[];
  Attachment?: NetworkInterfaceAttachmentChanges;
}
export const ModifyNetworkInterfaceAttributeRequest = S.suspend(() =>
  S.Struct({
    EnaSrdSpecification: S.optional(EnaSrdSpecification),
    EnablePrimaryIpv6: S.optional(S.Boolean),
    ConnectionTrackingSpecification: S.optional(
      ConnectionTrackingSpecificationRequest,
    ),
    AssociatePublicIpAddress: S.optional(S.Boolean),
    AssociatedSubnetIds: S.optional(SubnetIdList).pipe(
      T.XmlName("AssociatedSubnetId"),
    ),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    Description: S.optional(AttributeValue)
      .pipe(T.XmlName("description"), T.Ec2QueryName("Description"))
      .annotate({ identifier: "AttributeValue" }),
    SourceDestCheck: S.optional(AttributeBooleanValue)
      .pipe(T.XmlName("sourceDestCheck"), T.Ec2QueryName("SourceDestCheck"))
      .annotate({ identifier: "AttributeBooleanValue" }),
    Groups: S.optional(SecurityGroupIdStringList).pipe(
      T.XmlName("SecurityGroupId"),
    ),
    Attachment: S.optional(NetworkInterfaceAttachmentChanges)
      .pipe(T.XmlName("attachment"), T.Ec2QueryName("Attachment"))
      .annotate({ identifier: "NetworkInterfaceAttachmentChanges" }),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyNetworkInterfaceAttributeRequest",
}) as any as S.Schema<ModifyNetworkInterfaceAttributeRequest>;
export interface ModifyNetworkInterfaceAttributeResponse {}
export const ModifyNetworkInterfaceAttributeResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "ModifyNetworkInterfaceAttributeResponse",
}) as any as S.Schema<ModifyNetworkInterfaceAttributeResponse>;
export interface ModifyPrivateDnsNameOptionsRequest {
  DryRun?: boolean;
  InstanceId?: string;
  PrivateDnsHostnameType?: HostnameType;
  EnableResourceNameDnsARecord?: boolean;
  EnableResourceNameDnsAAAARecord?: boolean;
}
export const ModifyPrivateDnsNameOptionsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    InstanceId: S.optional(S.String),
    PrivateDnsHostnameType: S.optional(HostnameType),
    EnableResourceNameDnsARecord: S.optional(S.Boolean),
    EnableResourceNameDnsAAAARecord: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyPrivateDnsNameOptionsRequest",
}) as any as S.Schema<ModifyPrivateDnsNameOptionsRequest>;
export interface ModifyPrivateDnsNameOptionsResult {
  Return?: boolean;
}
export const ModifyPrivateDnsNameOptionsResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyPrivateDnsNameOptionsResult",
}) as any as S.Schema<ModifyPrivateDnsNameOptionsResult>;
export type PublicIpDnsOption =
  | "public-dual-stack-dns-name"
  | "public-ipv4-dns-name"
  | "public-ipv6-dns-name"
  | (string & {});
export const PublicIpDnsOption = S.String;
export interface ModifyPublicIpDnsNameOptionsRequest {
  NetworkInterfaceId?: string;
  HostnameType?: PublicIpDnsOption;
  DryRun?: boolean;
}
export const ModifyPublicIpDnsNameOptionsRequest = S.suspend(() =>
  S.Struct({
    NetworkInterfaceId: S.optional(S.String),
    HostnameType: S.optional(PublicIpDnsOption),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyPublicIpDnsNameOptionsRequest",
}) as any as S.Schema<ModifyPublicIpDnsNameOptionsRequest>;
export interface ModifyPublicIpDnsNameOptionsResult {
  Successful?: boolean;
}
export const ModifyPublicIpDnsNameOptionsResult = S.suspend(() =>
  S.Struct({
    Successful: S.optional(S.Boolean).pipe(
      T.XmlName("successful"),
      T.Ec2QueryName("Successful"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyPublicIpDnsNameOptionsResult",
}) as any as S.Schema<ModifyPublicIpDnsNameOptionsResult>;
export type ReservedInstancesConfigurationList =
  ReservedInstancesConfiguration[];
export const ReservedInstancesConfigurationList = S.Array(
  ReservedInstancesConfiguration.pipe(T.XmlName("item")).annotate({
    identifier: "ReservedInstancesConfiguration",
  }),
);
export interface ModifyReservedInstancesRequest {
  ReservedInstancesIds?: string[];
  ClientToken?: string;
  TargetConfigurations?: ReservedInstancesConfiguration[];
}
export const ModifyReservedInstancesRequest = S.suspend(() =>
  S.Struct({
    ReservedInstancesIds: S.optional(ReservedInstancesIdStringList).pipe(
      T.XmlName("ReservedInstancesId"),
    ),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
    TargetConfigurations: S.optional(ReservedInstancesConfigurationList).pipe(
      T.XmlName("ReservedInstancesConfigurationSetItemType"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyReservedInstancesRequest",
}) as any as S.Schema<ModifyReservedInstancesRequest>;
export interface ModifyReservedInstancesResult {
  ReservedInstancesModificationId?: string;
}
export const ModifyReservedInstancesResult = S.suspend(() =>
  S.Struct({
    ReservedInstancesModificationId: S.optional(S.String).pipe(
      T.XmlName("reservedInstancesModificationId"),
      T.Ec2QueryName("ReservedInstancesModificationId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyReservedInstancesResult",
}) as any as S.Schema<ModifyReservedInstancesResult>;
export interface ModifyRouteServerRequest {
  RouteServerId?: string;
  PersistRoutes?: RouteServerPersistRoutesAction;
  PersistRoutesDuration?: number;
  SnsNotificationsEnabled?: boolean;
  DryRun?: boolean;
}
export const ModifyRouteServerRequest = S.suspend(() =>
  S.Struct({
    RouteServerId: S.optional(S.String),
    PersistRoutes: S.optional(RouteServerPersistRoutesAction),
    PersistRoutesDuration: S.optional(S.Number),
    SnsNotificationsEnabled: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyRouteServerRequest",
}) as any as S.Schema<ModifyRouteServerRequest>;
export interface ModifyRouteServerResult {
  RouteServer?: RouteServer;
}
export const ModifyRouteServerResult = S.suspend(() =>
  S.Struct({
    RouteServer: S.optional(RouteServer)
      .pipe(T.XmlName("routeServer"), T.Ec2QueryName("RouteServer"))
      .annotate({ identifier: "RouteServer" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyRouteServerResult",
}) as any as S.Schema<ModifyRouteServerResult>;
export interface SecurityGroupRuleRequest {
  IpProtocol?: string;
  FromPort?: number;
  ToPort?: number;
  CidrIpv4?: string;
  CidrIpv6?: string;
  PrefixListId?: string;
  ReferencedGroupId?: string;
  Description?: string;
}
export const SecurityGroupRuleRequest = S.suspend(() =>
  S.Struct({
    IpProtocol: S.optional(S.String),
    FromPort: S.optional(S.Number),
    ToPort: S.optional(S.Number),
    CidrIpv4: S.optional(S.String),
    CidrIpv6: S.optional(S.String),
    PrefixListId: S.optional(S.String),
    ReferencedGroupId: S.optional(S.String),
    Description: S.optional(S.String),
  }),
).annotate({
  identifier: "SecurityGroupRuleRequest",
}) as any as S.Schema<SecurityGroupRuleRequest>;
export interface SecurityGroupRuleUpdate {
  SecurityGroupRuleId?: string;
  SecurityGroupRule?: SecurityGroupRuleRequest;
}
export const SecurityGroupRuleUpdate = S.suspend(() =>
  S.Struct({
    SecurityGroupRuleId: S.optional(S.String),
    SecurityGroupRule: S.optional(SecurityGroupRuleRequest),
  }),
).annotate({
  identifier: "SecurityGroupRuleUpdate",
}) as any as S.Schema<SecurityGroupRuleUpdate>;
export type SecurityGroupRuleUpdateList = SecurityGroupRuleUpdate[];
export const SecurityGroupRuleUpdateList = S.Array(
  SecurityGroupRuleUpdate.pipe(T.XmlName("item")).annotate({
    identifier: "SecurityGroupRuleUpdate",
  }),
);
export interface ModifySecurityGroupRulesRequest {
  GroupId?: string;
  SecurityGroupRules?: SecurityGroupRuleUpdate[];
  DryRun?: boolean;
}
export const ModifySecurityGroupRulesRequest = S.suspend(() =>
  S.Struct({
    GroupId: S.optional(S.String),
    SecurityGroupRules: S.optional(SecurityGroupRuleUpdateList).pipe(
      T.XmlName("SecurityGroupRule"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifySecurityGroupRulesRequest",
}) as any as S.Schema<ModifySecurityGroupRulesRequest>;
export interface ModifySecurityGroupRulesResult {
  Return?: boolean;
}
export const ModifySecurityGroupRulesResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifySecurityGroupRulesResult",
}) as any as S.Schema<ModifySecurityGroupRulesResult>;
export interface CreateVolumePermissionModifications {
  Add?: CreateVolumePermission[];
  Remove?: CreateVolumePermission[];
}
export const CreateVolumePermissionModifications = S.suspend(() =>
  S.Struct({
    Add: S.optional(CreateVolumePermissionList),
    Remove: S.optional(CreateVolumePermissionList),
  }),
).annotate({
  identifier: "CreateVolumePermissionModifications",
}) as any as S.Schema<CreateVolumePermissionModifications>;
export interface ModifySnapshotAttributeRequest {
  Attribute?: SnapshotAttributeName;
  CreateVolumePermission?: CreateVolumePermissionModifications;
  GroupNames?: string[];
  OperationType?: OperationType;
  SnapshotId?: string;
  UserIds?: string[];
  DryRun?: boolean;
}
export const ModifySnapshotAttributeRequest = S.suspend(() =>
  S.Struct({
    Attribute: S.optional(SnapshotAttributeName),
    CreateVolumePermission: S.optional(CreateVolumePermissionModifications),
    GroupNames: S.optional(GroupNameStringList).pipe(T.XmlName("UserGroup")),
    OperationType: S.optional(OperationType),
    SnapshotId: S.optional(S.String),
    UserIds: S.optional(UserIdStringList).pipe(T.XmlName("UserId")),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifySnapshotAttributeRequest",
}) as any as S.Schema<ModifySnapshotAttributeRequest>;
export interface ModifySnapshotAttributeResponse {}
export const ModifySnapshotAttributeResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "ModifySnapshotAttributeResponse",
}) as any as S.Schema<ModifySnapshotAttributeResponse>;
export type TargetStorageTier = "archive" | (string & {});
export const TargetStorageTier = S.String;
export interface ModifySnapshotTierRequest {
  SnapshotId?: string;
  StorageTier?: TargetStorageTier;
  DryRun?: boolean;
}
export const ModifySnapshotTierRequest = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String),
    StorageTier: S.optional(TargetStorageTier),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifySnapshotTierRequest",
}) as any as S.Schema<ModifySnapshotTierRequest>;
export interface ModifySnapshotTierResult {
  SnapshotId?: string;
  TieringStartTime?: Date;
}
export const ModifySnapshotTierResult = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    TieringStartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("tieringStartTime"), T.Ec2QueryName("TieringStartTime")),
  }).pipe(ns),
).annotate({
  identifier: "ModifySnapshotTierResult",
}) as any as S.Schema<ModifySnapshotTierResult>;
export interface ModifySpotFleetRequestRequest {
  LaunchTemplateConfigs?: LaunchTemplateConfig[];
  OnDemandTargetCapacity?: number;
  Context?: string;
  SpotFleetRequestId?: string;
  TargetCapacity?: number;
  ExcessCapacityTerminationPolicy?: ExcessCapacityTerminationPolicy;
}
export const ModifySpotFleetRequestRequest = S.suspend(() =>
  S.Struct({
    LaunchTemplateConfigs: S.optional(LaunchTemplateConfigList).pipe(
      T.XmlName("LaunchTemplateConfig"),
    ),
    OnDemandTargetCapacity: S.optional(S.Number),
    Context: S.optional(S.String),
    SpotFleetRequestId: S.optional(S.String).pipe(
      T.XmlName("spotFleetRequestId"),
      T.Ec2QueryName("SpotFleetRequestId"),
    ),
    TargetCapacity: S.optional(S.Number).pipe(
      T.XmlName("targetCapacity"),
      T.Ec2QueryName("TargetCapacity"),
    ),
    ExcessCapacityTerminationPolicy: S.optional(
      ExcessCapacityTerminationPolicy,
    ).pipe(
      T.XmlName("excessCapacityTerminationPolicy"),
      T.Ec2QueryName("ExcessCapacityTerminationPolicy"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifySpotFleetRequestRequest",
}) as any as S.Schema<ModifySpotFleetRequestRequest>;
export interface ModifySpotFleetRequestResponse {
  Return?: boolean;
}
export const ModifySpotFleetRequestResponse = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifySpotFleetRequestResponse",
}) as any as S.Schema<ModifySpotFleetRequestResponse>;
export interface ModifySubnetAttributeRequest {
  AssignIpv6AddressOnCreation?: AttributeBooleanValue;
  MapPublicIpOnLaunch?: AttributeBooleanValue;
  SubnetId?: string;
  MapCustomerOwnedIpOnLaunch?: AttributeBooleanValue;
  CustomerOwnedIpv4Pool?: string;
  EnableDns64?: AttributeBooleanValue;
  PrivateDnsHostnameTypeOnLaunch?: HostnameType;
  EnableResourceNameDnsARecordOnLaunch?: AttributeBooleanValue;
  EnableResourceNameDnsAAAARecordOnLaunch?: AttributeBooleanValue;
  EnableLniAtDeviceIndex?: number;
  DisableLniAtDeviceIndex?: AttributeBooleanValue;
}
export const ModifySubnetAttributeRequest = S.suspend(() =>
  S.Struct({
    AssignIpv6AddressOnCreation: S.optional(AttributeBooleanValue),
    MapPublicIpOnLaunch: S.optional(AttributeBooleanValue),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    MapCustomerOwnedIpOnLaunch: S.optional(AttributeBooleanValue),
    CustomerOwnedIpv4Pool: S.optional(S.String),
    EnableDns64: S.optional(AttributeBooleanValue),
    PrivateDnsHostnameTypeOnLaunch: S.optional(HostnameType),
    EnableResourceNameDnsARecordOnLaunch: S.optional(AttributeBooleanValue),
    EnableResourceNameDnsAAAARecordOnLaunch: S.optional(AttributeBooleanValue),
    EnableLniAtDeviceIndex: S.optional(S.Number),
    DisableLniAtDeviceIndex: S.optional(AttributeBooleanValue),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifySubnetAttributeRequest",
}) as any as S.Schema<ModifySubnetAttributeRequest>;
export interface ModifySubnetAttributeResponse {}
export const ModifySubnetAttributeResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "ModifySubnetAttributeResponse",
}) as any as S.Schema<ModifySubnetAttributeResponse>;
export interface ModifyTrafficMirrorFilterNetworkServicesRequest {
  TrafficMirrorFilterId?: string;
  AddNetworkServices?: TrafficMirrorNetworkService[];
  RemoveNetworkServices?: TrafficMirrorNetworkService[];
  DryRun?: boolean;
}
export const ModifyTrafficMirrorFilterNetworkServicesRequest = S.suspend(() =>
  S.Struct({
    TrafficMirrorFilterId: S.optional(S.String),
    AddNetworkServices: S.optional(TrafficMirrorNetworkServiceList).pipe(
      T.XmlName("AddNetworkService"),
    ),
    RemoveNetworkServices: S.optional(TrafficMirrorNetworkServiceList).pipe(
      T.XmlName("RemoveNetworkService"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyTrafficMirrorFilterNetworkServicesRequest",
}) as any as S.Schema<ModifyTrafficMirrorFilterNetworkServicesRequest>;
export interface ModifyTrafficMirrorFilterNetworkServicesResult {
  TrafficMirrorFilter?: TrafficMirrorFilter;
}
export const ModifyTrafficMirrorFilterNetworkServicesResult = S.suspend(() =>
  S.Struct({
    TrafficMirrorFilter: S.optional(TrafficMirrorFilter)
      .pipe(
        T.XmlName("trafficMirrorFilter"),
        T.Ec2QueryName("TrafficMirrorFilter"),
      )
      .annotate({ identifier: "TrafficMirrorFilter" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyTrafficMirrorFilterNetworkServicesResult",
}) as any as S.Schema<ModifyTrafficMirrorFilterNetworkServicesResult>;
export type TrafficMirrorFilterRuleField =
  | "destination-port-range"
  | "source-port-range"
  | "protocol"
  | "description"
  | (string & {});
export const TrafficMirrorFilterRuleField = S.String;
export type TrafficMirrorFilterRuleFieldList = TrafficMirrorFilterRuleField[];
export const TrafficMirrorFilterRuleFieldList = S.Array(
  TrafficMirrorFilterRuleField,
);
export interface ModifyTrafficMirrorFilterRuleRequest {
  TrafficMirrorFilterRuleId?: string;
  TrafficDirection?: TrafficDirection;
  RuleNumber?: number;
  RuleAction?: TrafficMirrorRuleAction;
  DestinationPortRange?: TrafficMirrorPortRangeRequest;
  SourcePortRange?: TrafficMirrorPortRangeRequest;
  Protocol?: number;
  DestinationCidrBlock?: string;
  SourceCidrBlock?: string;
  Description?: string;
  RemoveFields?: TrafficMirrorFilterRuleField[];
  DryRun?: boolean;
}
export const ModifyTrafficMirrorFilterRuleRequest = S.suspend(() =>
  S.Struct({
    TrafficMirrorFilterRuleId: S.optional(S.String),
    TrafficDirection: S.optional(TrafficDirection),
    RuleNumber: S.optional(S.Number),
    RuleAction: S.optional(TrafficMirrorRuleAction),
    DestinationPortRange: S.optional(TrafficMirrorPortRangeRequest),
    SourcePortRange: S.optional(TrafficMirrorPortRangeRequest),
    Protocol: S.optional(S.Number),
    DestinationCidrBlock: S.optional(S.String),
    SourceCidrBlock: S.optional(S.String),
    Description: S.optional(S.String),
    RemoveFields: S.optional(TrafficMirrorFilterRuleFieldList).pipe(
      T.XmlName("RemoveField"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyTrafficMirrorFilterRuleRequest",
}) as any as S.Schema<ModifyTrafficMirrorFilterRuleRequest>;
export interface ModifyTrafficMirrorFilterRuleResult {
  TrafficMirrorFilterRule?: TrafficMirrorFilterRule;
}
export const ModifyTrafficMirrorFilterRuleResult = S.suspend(() =>
  S.Struct({
    TrafficMirrorFilterRule: S.optional(TrafficMirrorFilterRule)
      .pipe(
        T.XmlName("trafficMirrorFilterRule"),
        T.Ec2QueryName("TrafficMirrorFilterRule"),
      )
      .annotate({ identifier: "TrafficMirrorFilterRule" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyTrafficMirrorFilterRuleResult",
}) as any as S.Schema<ModifyTrafficMirrorFilterRuleResult>;
export type TrafficMirrorSessionField =
  | "packet-length"
  | "description"
  | "virtual-network-id"
  | (string & {});
export const TrafficMirrorSessionField = S.String;
export type TrafficMirrorSessionFieldList = TrafficMirrorSessionField[];
export const TrafficMirrorSessionFieldList = S.Array(TrafficMirrorSessionField);
export interface ModifyTrafficMirrorSessionRequest {
  TrafficMirrorSessionId?: string;
  TrafficMirrorTargetId?: string;
  TrafficMirrorFilterId?: string;
  PacketLength?: number;
  SessionNumber?: number;
  VirtualNetworkId?: number;
  Description?: string;
  RemoveFields?: TrafficMirrorSessionField[];
  DryRun?: boolean;
}
export const ModifyTrafficMirrorSessionRequest = S.suspend(() =>
  S.Struct({
    TrafficMirrorSessionId: S.optional(S.String),
    TrafficMirrorTargetId: S.optional(S.String),
    TrafficMirrorFilterId: S.optional(S.String),
    PacketLength: S.optional(S.Number),
    SessionNumber: S.optional(S.Number),
    VirtualNetworkId: S.optional(S.Number),
    Description: S.optional(S.String),
    RemoveFields: S.optional(TrafficMirrorSessionFieldList).pipe(
      T.XmlName("RemoveField"),
    ),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyTrafficMirrorSessionRequest",
}) as any as S.Schema<ModifyTrafficMirrorSessionRequest>;
export interface ModifyTrafficMirrorSessionResult {
  TrafficMirrorSession?: TrafficMirrorSession;
}
export const ModifyTrafficMirrorSessionResult = S.suspend(() =>
  S.Struct({
    TrafficMirrorSession: S.optional(TrafficMirrorSession)
      .pipe(
        T.XmlName("trafficMirrorSession"),
        T.Ec2QueryName("TrafficMirrorSession"),
      )
      .annotate({ identifier: "TrafficMirrorSession" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyTrafficMirrorSessionResult",
}) as any as S.Schema<ModifyTrafficMirrorSessionResult>;
export type EncryptionSupportOptionValue = "enable" | "disable" | (string & {});
export const EncryptionSupportOptionValue = S.String;
export interface ModifyTransitGatewayOptions {
  AddTransitGatewayCidrBlocks?: string[];
  RemoveTransitGatewayCidrBlocks?: string[];
  VpnEcmpSupport?: VpnEcmpSupportValue;
  DnsSupport?: DnsSupportValue;
  SecurityGroupReferencingSupport?: SecurityGroupReferencingSupportValue;
  AutoAcceptSharedAttachments?: AutoAcceptSharedAttachmentsValue;
  DefaultRouteTableAssociation?: DefaultRouteTableAssociationValue;
  AssociationDefaultRouteTableId?: string;
  DefaultRouteTablePropagation?: DefaultRouteTablePropagationValue;
  PropagationDefaultRouteTableId?: string;
  AmazonSideAsn?: number;
  EncryptionSupport?: EncryptionSupportOptionValue;
}
export const ModifyTransitGatewayOptions = S.suspend(() =>
  S.Struct({
    AddTransitGatewayCidrBlocks: S.optional(TransitGatewayCidrBlockStringList),
    RemoveTransitGatewayCidrBlocks: S.optional(
      TransitGatewayCidrBlockStringList,
    ),
    VpnEcmpSupport: S.optional(VpnEcmpSupportValue),
    DnsSupport: S.optional(DnsSupportValue),
    SecurityGroupReferencingSupport: S.optional(
      SecurityGroupReferencingSupportValue,
    ),
    AutoAcceptSharedAttachments: S.optional(AutoAcceptSharedAttachmentsValue),
    DefaultRouteTableAssociation: S.optional(DefaultRouteTableAssociationValue),
    AssociationDefaultRouteTableId: S.optional(S.String),
    DefaultRouteTablePropagation: S.optional(DefaultRouteTablePropagationValue),
    PropagationDefaultRouteTableId: S.optional(S.String),
    AmazonSideAsn: S.optional(S.Number),
    EncryptionSupport: S.optional(EncryptionSupportOptionValue),
  }),
).annotate({
  identifier: "ModifyTransitGatewayOptions",
}) as any as S.Schema<ModifyTransitGatewayOptions>;
export interface ModifyTransitGatewayRequest {
  TransitGatewayId?: string;
  Description?: string;
  Options?: ModifyTransitGatewayOptions;
  DryRun?: boolean;
}
export const ModifyTransitGatewayRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayId: S.optional(S.String),
    Description: S.optional(S.String),
    Options: S.optional(ModifyTransitGatewayOptions),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyTransitGatewayRequest",
}) as any as S.Schema<ModifyTransitGatewayRequest>;
export interface ModifyTransitGatewayResult {
  TransitGateway?: TransitGateway;
}
export const ModifyTransitGatewayResult = S.suspend(() =>
  S.Struct({
    TransitGateway: S.optional(TransitGateway)
      .pipe(T.XmlName("transitGateway"), T.Ec2QueryName("TransitGateway"))
      .annotate({ identifier: "TransitGateway" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyTransitGatewayResult",
}) as any as S.Schema<ModifyTransitGatewayResult>;
export interface ModifyTransitGatewayMeteringPolicyRequest {
  TransitGatewayMeteringPolicyId?: string;
  AddMiddleboxAttachmentIds?: string[];
  RemoveMiddleboxAttachmentIds?: string[];
  DryRun?: boolean;
}
export const ModifyTransitGatewayMeteringPolicyRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayMeteringPolicyId: S.optional(S.String),
    AddMiddleboxAttachmentIds: S.optional(
      TransitGatewayAttachmentIdStringList,
    ).pipe(T.XmlName("AddMiddleboxAttachmentId")),
    RemoveMiddleboxAttachmentIds: S.optional(
      TransitGatewayAttachmentIdStringList,
    ).pipe(T.XmlName("RemoveMiddleboxAttachmentId")),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyTransitGatewayMeteringPolicyRequest",
}) as any as S.Schema<ModifyTransitGatewayMeteringPolicyRequest>;
export interface ModifyTransitGatewayMeteringPolicyResult {
  TransitGatewayMeteringPolicy?: TransitGatewayMeteringPolicy;
}
export const ModifyTransitGatewayMeteringPolicyResult = S.suspend(() =>
  S.Struct({
    TransitGatewayMeteringPolicy: S.optional(TransitGatewayMeteringPolicy)
      .pipe(
        T.XmlName("transitGatewayMeteringPolicy"),
        T.Ec2QueryName("TransitGatewayMeteringPolicy"),
      )
      .annotate({ identifier: "TransitGatewayMeteringPolicy" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyTransitGatewayMeteringPolicyResult",
}) as any as S.Schema<ModifyTransitGatewayMeteringPolicyResult>;
export interface ModifyTransitGatewayPrefixListReferenceRequest {
  TransitGatewayRouteTableId?: string;
  PrefixListId?: string;
  TransitGatewayAttachmentId?: string;
  Blackhole?: boolean;
  DryRun?: boolean;
}
export const ModifyTransitGatewayPrefixListReferenceRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String),
    PrefixListId: S.optional(S.String),
    TransitGatewayAttachmentId: S.optional(S.String),
    Blackhole: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyTransitGatewayPrefixListReferenceRequest",
}) as any as S.Schema<ModifyTransitGatewayPrefixListReferenceRequest>;
export interface ModifyTransitGatewayPrefixListReferenceResult {
  TransitGatewayPrefixListReference?: TransitGatewayPrefixListReference;
}
export const ModifyTransitGatewayPrefixListReferenceResult = S.suspend(() =>
  S.Struct({
    TransitGatewayPrefixListReference: S.optional(
      TransitGatewayPrefixListReference,
    )
      .pipe(
        T.XmlName("transitGatewayPrefixListReference"),
        T.Ec2QueryName("TransitGatewayPrefixListReference"),
      )
      .annotate({ identifier: "TransitGatewayPrefixListReference" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyTransitGatewayPrefixListReferenceResult",
}) as any as S.Schema<ModifyTransitGatewayPrefixListReferenceResult>;
export interface ModifyTransitGatewayVpcAttachmentRequestOptions {
  DnsSupport?: DnsSupportValue;
  SecurityGroupReferencingSupport?: SecurityGroupReferencingSupportValue;
  Ipv6Support?: Ipv6SupportValue;
  ApplianceModeSupport?: ApplianceModeSupportValue;
}
export const ModifyTransitGatewayVpcAttachmentRequestOptions = S.suspend(() =>
  S.Struct({
    DnsSupport: S.optional(DnsSupportValue),
    SecurityGroupReferencingSupport: S.optional(
      SecurityGroupReferencingSupportValue,
    ),
    Ipv6Support: S.optional(Ipv6SupportValue),
    ApplianceModeSupport: S.optional(ApplianceModeSupportValue),
  }),
).annotate({
  identifier: "ModifyTransitGatewayVpcAttachmentRequestOptions",
}) as any as S.Schema<ModifyTransitGatewayVpcAttachmentRequestOptions>;
export interface ModifyTransitGatewayVpcAttachmentRequest {
  TransitGatewayAttachmentId?: string;
  AddSubnetIds?: string[];
  RemoveSubnetIds?: string[];
  Options?: ModifyTransitGatewayVpcAttachmentRequestOptions;
  DryRun?: boolean;
}
export const ModifyTransitGatewayVpcAttachmentRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String),
    AddSubnetIds: S.optional(TransitGatewaySubnetIdList),
    RemoveSubnetIds: S.optional(TransitGatewaySubnetIdList),
    Options: S.optional(ModifyTransitGatewayVpcAttachmentRequestOptions),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyTransitGatewayVpcAttachmentRequest",
}) as any as S.Schema<ModifyTransitGatewayVpcAttachmentRequest>;
export interface ModifyTransitGatewayVpcAttachmentResult {
  TransitGatewayVpcAttachment?: TransitGatewayVpcAttachment;
}
export const ModifyTransitGatewayVpcAttachmentResult = S.suspend(() =>
  S.Struct({
    TransitGatewayVpcAttachment: S.optional(TransitGatewayVpcAttachment)
      .pipe(
        T.XmlName("transitGatewayVpcAttachment"),
        T.Ec2QueryName("TransitGatewayVpcAttachment"),
      )
      .annotate({ identifier: "TransitGatewayVpcAttachment" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyTransitGatewayVpcAttachmentResult",
}) as any as S.Schema<ModifyTransitGatewayVpcAttachmentResult>;
export type ModifyVerifiedAccessEndpointSubnetIdList = string[];
export const ModifyVerifiedAccessEndpointSubnetIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface ModifyVerifiedAccessEndpointPortRange {
  FromPort?: number;
  ToPort?: number;
}
export const ModifyVerifiedAccessEndpointPortRange = S.suspend(() =>
  S.Struct({ FromPort: S.optional(S.Number), ToPort: S.optional(S.Number) }),
).annotate({
  identifier: "ModifyVerifiedAccessEndpointPortRange",
}) as any as S.Schema<ModifyVerifiedAccessEndpointPortRange>;
export type ModifyVerifiedAccessEndpointPortRangeList =
  ModifyVerifiedAccessEndpointPortRange[];
export const ModifyVerifiedAccessEndpointPortRangeList = S.Array(
  ModifyVerifiedAccessEndpointPortRange.pipe(T.XmlName("item")).annotate({
    identifier: "ModifyVerifiedAccessEndpointPortRange",
  }),
);
export interface ModifyVerifiedAccessEndpointLoadBalancerOptions {
  SubnetIds?: string[];
  Protocol?: VerifiedAccessEndpointProtocol;
  Port?: number;
  PortRanges?: ModifyVerifiedAccessEndpointPortRange[];
}
export const ModifyVerifiedAccessEndpointLoadBalancerOptions = S.suspend(() =>
  S.Struct({
    SubnetIds: S.optional(ModifyVerifiedAccessEndpointSubnetIdList).pipe(
      T.XmlName("SubnetId"),
    ),
    Protocol: S.optional(VerifiedAccessEndpointProtocol),
    Port: S.optional(S.Number),
    PortRanges: S.optional(ModifyVerifiedAccessEndpointPortRangeList).pipe(
      T.XmlName("PortRange"),
    ),
  }),
).annotate({
  identifier: "ModifyVerifiedAccessEndpointLoadBalancerOptions",
}) as any as S.Schema<ModifyVerifiedAccessEndpointLoadBalancerOptions>;
export interface ModifyVerifiedAccessEndpointEniOptions {
  Protocol?: VerifiedAccessEndpointProtocol;
  Port?: number;
  PortRanges?: ModifyVerifiedAccessEndpointPortRange[];
}
export const ModifyVerifiedAccessEndpointEniOptions = S.suspend(() =>
  S.Struct({
    Protocol: S.optional(VerifiedAccessEndpointProtocol),
    Port: S.optional(S.Number),
    PortRanges: S.optional(ModifyVerifiedAccessEndpointPortRangeList).pipe(
      T.XmlName("PortRange"),
    ),
  }),
).annotate({
  identifier: "ModifyVerifiedAccessEndpointEniOptions",
}) as any as S.Schema<ModifyVerifiedAccessEndpointEniOptions>;
export interface ModifyVerifiedAccessEndpointRdsOptions {
  SubnetIds?: string[];
  Port?: number;
  RdsEndpoint?: string;
}
export const ModifyVerifiedAccessEndpointRdsOptions = S.suspend(() =>
  S.Struct({
    SubnetIds: S.optional(ModifyVerifiedAccessEndpointSubnetIdList).pipe(
      T.XmlName("SubnetId"),
    ),
    Port: S.optional(S.Number),
    RdsEndpoint: S.optional(S.String),
  }),
).annotate({
  identifier: "ModifyVerifiedAccessEndpointRdsOptions",
}) as any as S.Schema<ModifyVerifiedAccessEndpointRdsOptions>;
export interface ModifyVerifiedAccessEndpointCidrOptions {
  PortRanges?: ModifyVerifiedAccessEndpointPortRange[];
}
export const ModifyVerifiedAccessEndpointCidrOptions = S.suspend(() =>
  S.Struct({
    PortRanges: S.optional(ModifyVerifiedAccessEndpointPortRangeList).pipe(
      T.XmlName("PortRange"),
    ),
  }),
).annotate({
  identifier: "ModifyVerifiedAccessEndpointCidrOptions",
}) as any as S.Schema<ModifyVerifiedAccessEndpointCidrOptions>;
export interface ModifyVerifiedAccessEndpointRequest {
  VerifiedAccessEndpointId?: string;
  VerifiedAccessGroupId?: string;
  LoadBalancerOptions?: ModifyVerifiedAccessEndpointLoadBalancerOptions;
  NetworkInterfaceOptions?: ModifyVerifiedAccessEndpointEniOptions;
  Description?: string;
  ClientToken?: string;
  DryRun?: boolean;
  RdsOptions?: ModifyVerifiedAccessEndpointRdsOptions;
  CidrOptions?: ModifyVerifiedAccessEndpointCidrOptions;
}
export const ModifyVerifiedAccessEndpointRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessEndpointId: S.optional(S.String),
    VerifiedAccessGroupId: S.optional(S.String),
    LoadBalancerOptions: S.optional(
      ModifyVerifiedAccessEndpointLoadBalancerOptions,
    ),
    NetworkInterfaceOptions: S.optional(ModifyVerifiedAccessEndpointEniOptions),
    Description: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
    RdsOptions: S.optional(ModifyVerifiedAccessEndpointRdsOptions),
    CidrOptions: S.optional(ModifyVerifiedAccessEndpointCidrOptions),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVerifiedAccessEndpointRequest",
}) as any as S.Schema<ModifyVerifiedAccessEndpointRequest>;
export interface ModifyVerifiedAccessEndpointResult {
  VerifiedAccessEndpoint?: VerifiedAccessEndpoint;
}
export const ModifyVerifiedAccessEndpointResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessEndpoint: S.optional(VerifiedAccessEndpoint)
      .pipe(
        T.XmlName("verifiedAccessEndpoint"),
        T.Ec2QueryName("VerifiedAccessEndpoint"),
      )
      .annotate({ identifier: "VerifiedAccessEndpoint" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVerifiedAccessEndpointResult",
}) as any as S.Schema<ModifyVerifiedAccessEndpointResult>;
export interface ModifyVerifiedAccessEndpointPolicyRequest {
  VerifiedAccessEndpointId?: string;
  PolicyEnabled?: boolean;
  PolicyDocument?: string;
  ClientToken?: string;
  DryRun?: boolean;
  SseSpecification?: VerifiedAccessSseSpecificationRequest;
}
export const ModifyVerifiedAccessEndpointPolicyRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessEndpointId: S.optional(S.String),
    PolicyEnabled: S.optional(S.Boolean),
    PolicyDocument: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
    SseSpecification: S.optional(VerifiedAccessSseSpecificationRequest),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVerifiedAccessEndpointPolicyRequest",
}) as any as S.Schema<ModifyVerifiedAccessEndpointPolicyRequest>;
export interface ModifyVerifiedAccessEndpointPolicyResult {
  PolicyEnabled?: boolean;
  PolicyDocument?: string;
  SseSpecification?: VerifiedAccessSseSpecificationResponse;
}
export const ModifyVerifiedAccessEndpointPolicyResult = S.suspend(() =>
  S.Struct({
    PolicyEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("policyEnabled"),
      T.Ec2QueryName("PolicyEnabled"),
    ),
    PolicyDocument: S.optional(S.String).pipe(
      T.XmlName("policyDocument"),
      T.Ec2QueryName("PolicyDocument"),
    ),
    SseSpecification: S.optional(VerifiedAccessSseSpecificationResponse)
      .pipe(T.XmlName("sseSpecification"), T.Ec2QueryName("SseSpecification"))
      .annotate({ identifier: "VerifiedAccessSseSpecificationResponse" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVerifiedAccessEndpointPolicyResult",
}) as any as S.Schema<ModifyVerifiedAccessEndpointPolicyResult>;
export interface ModifyVerifiedAccessGroupRequest {
  VerifiedAccessGroupId?: string;
  VerifiedAccessInstanceId?: string;
  Description?: string;
  ClientToken?: string;
  DryRun?: boolean;
}
export const ModifyVerifiedAccessGroupRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessGroupId: S.optional(S.String),
    VerifiedAccessInstanceId: S.optional(S.String),
    Description: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVerifiedAccessGroupRequest",
}) as any as S.Schema<ModifyVerifiedAccessGroupRequest>;
export interface ModifyVerifiedAccessGroupResult {
  VerifiedAccessGroup?: VerifiedAccessGroup;
}
export const ModifyVerifiedAccessGroupResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessGroup: S.optional(VerifiedAccessGroup)
      .pipe(
        T.XmlName("verifiedAccessGroup"),
        T.Ec2QueryName("VerifiedAccessGroup"),
      )
      .annotate({ identifier: "VerifiedAccessGroup" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVerifiedAccessGroupResult",
}) as any as S.Schema<ModifyVerifiedAccessGroupResult>;
export interface ModifyVerifiedAccessGroupPolicyRequest {
  VerifiedAccessGroupId?: string;
  PolicyEnabled?: boolean;
  PolicyDocument?: string;
  ClientToken?: string;
  DryRun?: boolean;
  SseSpecification?: VerifiedAccessSseSpecificationRequest;
}
export const ModifyVerifiedAccessGroupPolicyRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessGroupId: S.optional(S.String),
    PolicyEnabled: S.optional(S.Boolean),
    PolicyDocument: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
    SseSpecification: S.optional(VerifiedAccessSseSpecificationRequest),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVerifiedAccessGroupPolicyRequest",
}) as any as S.Schema<ModifyVerifiedAccessGroupPolicyRequest>;
export interface ModifyVerifiedAccessGroupPolicyResult {
  PolicyEnabled?: boolean;
  PolicyDocument?: string;
  SseSpecification?: VerifiedAccessSseSpecificationResponse;
}
export const ModifyVerifiedAccessGroupPolicyResult = S.suspend(() =>
  S.Struct({
    PolicyEnabled: S.optional(S.Boolean).pipe(
      T.XmlName("policyEnabled"),
      T.Ec2QueryName("PolicyEnabled"),
    ),
    PolicyDocument: S.optional(S.String).pipe(
      T.XmlName("policyDocument"),
      T.Ec2QueryName("PolicyDocument"),
    ),
    SseSpecification: S.optional(VerifiedAccessSseSpecificationResponse)
      .pipe(T.XmlName("sseSpecification"), T.Ec2QueryName("SseSpecification"))
      .annotate({ identifier: "VerifiedAccessSseSpecificationResponse" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVerifiedAccessGroupPolicyResult",
}) as any as S.Schema<ModifyVerifiedAccessGroupPolicyResult>;
export interface ModifyVerifiedAccessInstanceRequest {
  VerifiedAccessInstanceId?: string;
  Description?: string;
  DryRun?: boolean;
  ClientToken?: string;
  CidrEndpointsCustomSubDomain?: string;
}
export const ModifyVerifiedAccessInstanceRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessInstanceId: S.optional(S.String),
    Description: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    CidrEndpointsCustomSubDomain: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVerifiedAccessInstanceRequest",
}) as any as S.Schema<ModifyVerifiedAccessInstanceRequest>;
export interface ModifyVerifiedAccessInstanceResult {
  VerifiedAccessInstance?: VerifiedAccessInstance;
}
export const ModifyVerifiedAccessInstanceResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessInstance: S.optional(VerifiedAccessInstance)
      .pipe(
        T.XmlName("verifiedAccessInstance"),
        T.Ec2QueryName("VerifiedAccessInstance"),
      )
      .annotate({ identifier: "VerifiedAccessInstance" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVerifiedAccessInstanceResult",
}) as any as S.Schema<ModifyVerifiedAccessInstanceResult>;
export interface VerifiedAccessLogS3DestinationOptions {
  Enabled?: boolean;
  BucketName?: string;
  Prefix?: string;
  BucketOwner?: string;
}
export const VerifiedAccessLogS3DestinationOptions = S.suspend(() =>
  S.Struct({
    Enabled: S.optional(S.Boolean),
    BucketName: S.optional(S.String),
    Prefix: S.optional(S.String),
    BucketOwner: S.optional(S.String),
  }),
).annotate({
  identifier: "VerifiedAccessLogS3DestinationOptions",
}) as any as S.Schema<VerifiedAccessLogS3DestinationOptions>;
export interface VerifiedAccessLogCloudWatchLogsDestinationOptions {
  Enabled?: boolean;
  LogGroup?: string;
}
export const VerifiedAccessLogCloudWatchLogsDestinationOptions = S.suspend(() =>
  S.Struct({ Enabled: S.optional(S.Boolean), LogGroup: S.optional(S.String) }),
).annotate({
  identifier: "VerifiedAccessLogCloudWatchLogsDestinationOptions",
}) as any as S.Schema<VerifiedAccessLogCloudWatchLogsDestinationOptions>;
export interface VerifiedAccessLogKinesisDataFirehoseDestinationOptions {
  Enabled?: boolean;
  DeliveryStream?: string;
}
export const VerifiedAccessLogKinesisDataFirehoseDestinationOptions = S.suspend(
  () =>
    S.Struct({
      Enabled: S.optional(S.Boolean),
      DeliveryStream: S.optional(S.String),
    }),
).annotate({
  identifier: "VerifiedAccessLogKinesisDataFirehoseDestinationOptions",
}) as any as S.Schema<VerifiedAccessLogKinesisDataFirehoseDestinationOptions>;
export interface VerifiedAccessLogOptions {
  S3?: VerifiedAccessLogS3DestinationOptions;
  CloudWatchLogs?: VerifiedAccessLogCloudWatchLogsDestinationOptions;
  KinesisDataFirehose?: VerifiedAccessLogKinesisDataFirehoseDestinationOptions;
  LogVersion?: string;
  IncludeTrustContext?: boolean;
}
export const VerifiedAccessLogOptions = S.suspend(() =>
  S.Struct({
    S3: S.optional(VerifiedAccessLogS3DestinationOptions),
    CloudWatchLogs: S.optional(
      VerifiedAccessLogCloudWatchLogsDestinationOptions,
    ),
    KinesisDataFirehose: S.optional(
      VerifiedAccessLogKinesisDataFirehoseDestinationOptions,
    ),
    LogVersion: S.optional(S.String),
    IncludeTrustContext: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "VerifiedAccessLogOptions",
}) as any as S.Schema<VerifiedAccessLogOptions>;
export interface ModifyVerifiedAccessInstanceLoggingConfigurationRequest {
  VerifiedAccessInstanceId?: string;
  AccessLogs?: VerifiedAccessLogOptions;
  DryRun?: boolean;
  ClientToken?: string;
}
export const ModifyVerifiedAccessInstanceLoggingConfigurationRequest =
  S.suspend(() =>
    S.Struct({
      VerifiedAccessInstanceId: S.optional(S.String),
      AccessLogs: S.optional(VerifiedAccessLogOptions),
      DryRun: S.optional(S.Boolean),
      ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
  ).annotate({
    identifier: "ModifyVerifiedAccessInstanceLoggingConfigurationRequest",
  }) as any as S.Schema<ModifyVerifiedAccessInstanceLoggingConfigurationRequest>;
export interface ModifyVerifiedAccessInstanceLoggingConfigurationResult {
  LoggingConfiguration?: VerifiedAccessInstanceLoggingConfiguration;
}
export const ModifyVerifiedAccessInstanceLoggingConfigurationResult = S.suspend(
  () =>
    S.Struct({
      LoggingConfiguration: S.optional(
        VerifiedAccessInstanceLoggingConfiguration,
      )
        .pipe(
          T.XmlName("loggingConfiguration"),
          T.Ec2QueryName("LoggingConfiguration"),
        )
        .annotate({ identifier: "VerifiedAccessInstanceLoggingConfiguration" }),
    }).pipe(ns),
).annotate({
  identifier: "ModifyVerifiedAccessInstanceLoggingConfigurationResult",
}) as any as S.Schema<ModifyVerifiedAccessInstanceLoggingConfigurationResult>;
export interface ModifyVerifiedAccessTrustProviderOidcOptions {
  Issuer?: string;
  AuthorizationEndpoint?: string;
  TokenEndpoint?: string;
  UserInfoEndpoint?: string;
  ClientId?: string;
  ClientSecret?: string | redacted.Redacted<string>;
  Scope?: string;
}
export const ModifyVerifiedAccessTrustProviderOidcOptions = S.suspend(() =>
  S.Struct({
    Issuer: S.optional(S.String),
    AuthorizationEndpoint: S.optional(S.String),
    TokenEndpoint: S.optional(S.String),
    UserInfoEndpoint: S.optional(S.String),
    ClientId: S.optional(S.String),
    ClientSecret: S.optional(SensitiveString),
    Scope: S.optional(S.String),
  }),
).annotate({
  identifier: "ModifyVerifiedAccessTrustProviderOidcOptions",
}) as any as S.Schema<ModifyVerifiedAccessTrustProviderOidcOptions>;
export interface ModifyVerifiedAccessTrustProviderDeviceOptions {
  PublicSigningKeyUrl?: string;
}
export const ModifyVerifiedAccessTrustProviderDeviceOptions = S.suspend(() =>
  S.Struct({ PublicSigningKeyUrl: S.optional(S.String) }),
).annotate({
  identifier: "ModifyVerifiedAccessTrustProviderDeviceOptions",
}) as any as S.Schema<ModifyVerifiedAccessTrustProviderDeviceOptions>;
export interface ModifyVerifiedAccessNativeApplicationOidcOptions {
  PublicSigningKeyEndpoint?: string;
  Issuer?: string;
  AuthorizationEndpoint?: string;
  TokenEndpoint?: string;
  UserInfoEndpoint?: string;
  ClientId?: string;
  ClientSecret?: string | redacted.Redacted<string>;
  Scope?: string;
}
export const ModifyVerifiedAccessNativeApplicationOidcOptions = S.suspend(() =>
  S.Struct({
    PublicSigningKeyEndpoint: S.optional(S.String),
    Issuer: S.optional(S.String),
    AuthorizationEndpoint: S.optional(S.String),
    TokenEndpoint: S.optional(S.String),
    UserInfoEndpoint: S.optional(S.String),
    ClientId: S.optional(S.String),
    ClientSecret: S.optional(SensitiveString),
    Scope: S.optional(S.String),
  }),
).annotate({
  identifier: "ModifyVerifiedAccessNativeApplicationOidcOptions",
}) as any as S.Schema<ModifyVerifiedAccessNativeApplicationOidcOptions>;
export interface ModifyVerifiedAccessTrustProviderRequest {
  VerifiedAccessTrustProviderId?: string;
  OidcOptions?: ModifyVerifiedAccessTrustProviderOidcOptions;
  DeviceOptions?: ModifyVerifiedAccessTrustProviderDeviceOptions;
  Description?: string;
  DryRun?: boolean;
  ClientToken?: string;
  SseSpecification?: VerifiedAccessSseSpecificationRequest;
  NativeApplicationOidcOptions?: ModifyVerifiedAccessNativeApplicationOidcOptions;
}
export const ModifyVerifiedAccessTrustProviderRequest = S.suspend(() =>
  S.Struct({
    VerifiedAccessTrustProviderId: S.optional(S.String),
    OidcOptions: S.optional(ModifyVerifiedAccessTrustProviderOidcOptions),
    DeviceOptions: S.optional(ModifyVerifiedAccessTrustProviderDeviceOptions),
    Description: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    SseSpecification: S.optional(VerifiedAccessSseSpecificationRequest),
    NativeApplicationOidcOptions: S.optional(
      ModifyVerifiedAccessNativeApplicationOidcOptions,
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVerifiedAccessTrustProviderRequest",
}) as any as S.Schema<ModifyVerifiedAccessTrustProviderRequest>;
export interface ModifyVerifiedAccessTrustProviderResult {
  VerifiedAccessTrustProvider?: VerifiedAccessTrustProvider;
}
export const ModifyVerifiedAccessTrustProviderResult = S.suspend(() =>
  S.Struct({
    VerifiedAccessTrustProvider: S.optional(VerifiedAccessTrustProvider)
      .pipe(
        T.XmlName("verifiedAccessTrustProvider"),
        T.Ec2QueryName("VerifiedAccessTrustProvider"),
      )
      .annotate({ identifier: "VerifiedAccessTrustProvider" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVerifiedAccessTrustProviderResult",
}) as any as S.Schema<ModifyVerifiedAccessTrustProviderResult>;
export interface ModifyVolumeRequest {
  DryRun?: boolean;
  VolumeId?: string;
  Size?: number;
  VolumeType?: VolumeType;
  Iops?: number;
  Throughput?: number;
  MultiAttachEnabled?: boolean;
}
export const ModifyVolumeRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    VolumeId: S.optional(S.String),
    Size: S.optional(S.Number),
    VolumeType: S.optional(VolumeType),
    Iops: S.optional(S.Number),
    Throughput: S.optional(S.Number),
    MultiAttachEnabled: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVolumeRequest",
}) as any as S.Schema<ModifyVolumeRequest>;
export interface ModifyVolumeResult {
  VolumeModification?: VolumeModification;
}
export const ModifyVolumeResult = S.suspend(() =>
  S.Struct({
    VolumeModification: S.optional(VolumeModification)
      .pipe(
        T.XmlName("volumeModification"),
        T.Ec2QueryName("VolumeModification"),
      )
      .annotate({ identifier: "VolumeModification" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVolumeResult",
}) as any as S.Schema<ModifyVolumeResult>;
export interface ModifyVolumeAttributeRequest {
  AutoEnableIO?: AttributeBooleanValue;
  VolumeId?: string;
  DryRun?: boolean;
}
export const ModifyVolumeAttributeRequest = S.suspend(() =>
  S.Struct({
    AutoEnableIO: S.optional(AttributeBooleanValue),
    VolumeId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVolumeAttributeRequest",
}) as any as S.Schema<ModifyVolumeAttributeRequest>;
export interface ModifyVolumeAttributeResponse {}
export const ModifyVolumeAttributeResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "ModifyVolumeAttributeResponse",
}) as any as S.Schema<ModifyVolumeAttributeResponse>;
export interface ModifyVpcAttributeRequest {
  EnableDnsHostnames?: AttributeBooleanValue;
  EnableDnsSupport?: AttributeBooleanValue;
  VpcId?: string;
  EnableNetworkAddressUsageMetrics?: AttributeBooleanValue;
}
export const ModifyVpcAttributeRequest = S.suspend(() =>
  S.Struct({
    EnableDnsHostnames: S.optional(AttributeBooleanValue),
    EnableDnsSupport: S.optional(AttributeBooleanValue),
    VpcId: S.optional(S.String).pipe(
      T.XmlName("vpcId"),
      T.Ec2QueryName("VpcId"),
    ),
    EnableNetworkAddressUsageMetrics: S.optional(AttributeBooleanValue),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVpcAttributeRequest",
}) as any as S.Schema<ModifyVpcAttributeRequest>;
export interface ModifyVpcAttributeResponse {}
export const ModifyVpcAttributeResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "ModifyVpcAttributeResponse",
}) as any as S.Schema<ModifyVpcAttributeResponse>;
export interface ModifyVpcBlockPublicAccessExclusionRequest {
  DryRun?: boolean;
  ExclusionId?: string;
  InternetGatewayExclusionMode?: InternetGatewayExclusionMode;
}
export const ModifyVpcBlockPublicAccessExclusionRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ExclusionId: S.optional(S.String),
    InternetGatewayExclusionMode: S.optional(InternetGatewayExclusionMode),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVpcBlockPublicAccessExclusionRequest",
}) as any as S.Schema<ModifyVpcBlockPublicAccessExclusionRequest>;
export interface ModifyVpcBlockPublicAccessExclusionResult {
  VpcBlockPublicAccessExclusion?: VpcBlockPublicAccessExclusion;
}
export const ModifyVpcBlockPublicAccessExclusionResult = S.suspend(() =>
  S.Struct({
    VpcBlockPublicAccessExclusion: S.optional(VpcBlockPublicAccessExclusion)
      .pipe(
        T.XmlName("vpcBlockPublicAccessExclusion"),
        T.Ec2QueryName("VpcBlockPublicAccessExclusion"),
      )
      .annotate({ identifier: "VpcBlockPublicAccessExclusion" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVpcBlockPublicAccessExclusionResult",
}) as any as S.Schema<ModifyVpcBlockPublicAccessExclusionResult>;
export interface ModifyVpcBlockPublicAccessOptionsRequest {
  DryRun?: boolean;
  InternetGatewayBlockMode?: InternetGatewayBlockMode;
}
export const ModifyVpcBlockPublicAccessOptionsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    InternetGatewayBlockMode: S.optional(InternetGatewayBlockMode),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVpcBlockPublicAccessOptionsRequest",
}) as any as S.Schema<ModifyVpcBlockPublicAccessOptionsRequest>;
export interface ModifyVpcBlockPublicAccessOptionsResult {
  VpcBlockPublicAccessOptions?: VpcBlockPublicAccessOptions;
}
export const ModifyVpcBlockPublicAccessOptionsResult = S.suspend(() =>
  S.Struct({
    VpcBlockPublicAccessOptions: S.optional(VpcBlockPublicAccessOptions)
      .pipe(
        T.XmlName("vpcBlockPublicAccessOptions"),
        T.Ec2QueryName("VpcBlockPublicAccessOptions"),
      )
      .annotate({ identifier: "VpcBlockPublicAccessOptions" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVpcBlockPublicAccessOptionsResult",
}) as any as S.Schema<ModifyVpcBlockPublicAccessOptionsResult>;
export interface ModifyVpcEncryptionControlRequest {
  DryRun?: boolean;
  VpcEncryptionControlId?: string;
  Mode?: VpcEncryptionControlMode;
  InternetGatewayExclusion?: VpcEncryptionControlExclusionStateInput;
  EgressOnlyInternetGatewayExclusion?: VpcEncryptionControlExclusionStateInput;
  NatGatewayExclusion?: VpcEncryptionControlExclusionStateInput;
  VirtualPrivateGatewayExclusion?: VpcEncryptionControlExclusionStateInput;
  VpcPeeringExclusion?: VpcEncryptionControlExclusionStateInput;
  LambdaExclusion?: VpcEncryptionControlExclusionStateInput;
  VpcLatticeExclusion?: VpcEncryptionControlExclusionStateInput;
  ElasticFileSystemExclusion?: VpcEncryptionControlExclusionStateInput;
}
export const ModifyVpcEncryptionControlRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    VpcEncryptionControlId: S.optional(S.String),
    Mode: S.optional(VpcEncryptionControlMode),
    InternetGatewayExclusion: S.optional(
      VpcEncryptionControlExclusionStateInput,
    ),
    EgressOnlyInternetGatewayExclusion: S.optional(
      VpcEncryptionControlExclusionStateInput,
    ),
    NatGatewayExclusion: S.optional(VpcEncryptionControlExclusionStateInput),
    VirtualPrivateGatewayExclusion: S.optional(
      VpcEncryptionControlExclusionStateInput,
    ),
    VpcPeeringExclusion: S.optional(VpcEncryptionControlExclusionStateInput),
    LambdaExclusion: S.optional(VpcEncryptionControlExclusionStateInput),
    VpcLatticeExclusion: S.optional(VpcEncryptionControlExclusionStateInput),
    ElasticFileSystemExclusion: S.optional(
      VpcEncryptionControlExclusionStateInput,
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVpcEncryptionControlRequest",
}) as any as S.Schema<ModifyVpcEncryptionControlRequest>;
export interface ModifyVpcEncryptionControlResult {
  VpcEncryptionControl?: VpcEncryptionControl;
}
export const ModifyVpcEncryptionControlResult = S.suspend(() =>
  S.Struct({
    VpcEncryptionControl: S.optional(VpcEncryptionControl)
      .pipe(
        T.XmlName("vpcEncryptionControl"),
        T.Ec2QueryName("VpcEncryptionControl"),
      )
      .annotate({ identifier: "VpcEncryptionControl" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVpcEncryptionControlResult",
}) as any as S.Schema<ModifyVpcEncryptionControlResult>;
export interface ModifyVpcEndpointRequest {
  DryRun?: boolean;
  VpcEndpointId?: string;
  ResetPolicy?: boolean;
  PolicyDocument?: string;
  AddRouteTableIds?: string[];
  RemoveRouteTableIds?: string[];
  AddSubnetIds?: string[];
  RemoveSubnetIds?: string[];
  AddSecurityGroupIds?: string[];
  RemoveSecurityGroupIds?: string[];
  IpAddressType?: IpAddressType;
  DnsOptions?: DnsOptionsSpecification;
  PrivateDnsEnabled?: boolean;
  SubnetConfigurations?: SubnetConfiguration[];
}
export const ModifyVpcEndpointRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    VpcEndpointId: S.optional(S.String),
    ResetPolicy: S.optional(S.Boolean),
    PolicyDocument: S.optional(S.String),
    AddRouteTableIds: S.optional(VpcEndpointRouteTableIdList).pipe(
      T.XmlName("AddRouteTableId"),
    ),
    RemoveRouteTableIds: S.optional(VpcEndpointRouteTableIdList).pipe(
      T.XmlName("RemoveRouteTableId"),
    ),
    AddSubnetIds: S.optional(VpcEndpointSubnetIdList).pipe(
      T.XmlName("AddSubnetId"),
    ),
    RemoveSubnetIds: S.optional(VpcEndpointSubnetIdList).pipe(
      T.XmlName("RemoveSubnetId"),
    ),
    AddSecurityGroupIds: S.optional(VpcEndpointSecurityGroupIdList).pipe(
      T.XmlName("AddSecurityGroupId"),
    ),
    RemoveSecurityGroupIds: S.optional(VpcEndpointSecurityGroupIdList).pipe(
      T.XmlName("RemoveSecurityGroupId"),
    ),
    IpAddressType: S.optional(IpAddressType),
    DnsOptions: S.optional(DnsOptionsSpecification),
    PrivateDnsEnabled: S.optional(S.Boolean),
    SubnetConfigurations: S.optional(SubnetConfigurationsList).pipe(
      T.XmlName("SubnetConfiguration"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVpcEndpointRequest",
}) as any as S.Schema<ModifyVpcEndpointRequest>;
export interface ModifyVpcEndpointResult {
  Return?: boolean;
}
export const ModifyVpcEndpointResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVpcEndpointResult",
}) as any as S.Schema<ModifyVpcEndpointResult>;
export interface ModifyVpcEndpointConnectionNotificationRequest {
  DryRun?: boolean;
  ConnectionNotificationId?: string;
  ConnectionNotificationArn?: string;
  ConnectionEvents?: string[];
}
export const ModifyVpcEndpointConnectionNotificationRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ConnectionNotificationId: S.optional(S.String),
    ConnectionNotificationArn: S.optional(S.String),
    ConnectionEvents: S.optional(ValueStringList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVpcEndpointConnectionNotificationRequest",
}) as any as S.Schema<ModifyVpcEndpointConnectionNotificationRequest>;
export interface ModifyVpcEndpointConnectionNotificationResult {
  ReturnValue?: boolean;
}
export const ModifyVpcEndpointConnectionNotificationResult = S.suspend(() =>
  S.Struct({
    ReturnValue: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVpcEndpointConnectionNotificationResult",
}) as any as S.Schema<ModifyVpcEndpointConnectionNotificationResult>;
export interface ModifyVpcEndpointServiceConfigurationRequest {
  DryRun?: boolean;
  ServiceId?: string;
  PrivateDnsName?: string;
  RemovePrivateDnsName?: boolean;
  AcceptanceRequired?: boolean;
  AddNetworkLoadBalancerArns?: string[];
  RemoveNetworkLoadBalancerArns?: string[];
  AddGatewayLoadBalancerArns?: string[];
  RemoveGatewayLoadBalancerArns?: string[];
  AddSupportedIpAddressTypes?: string[];
  RemoveSupportedIpAddressTypes?: string[];
  AddSupportedRegions?: string[];
  RemoveSupportedRegions?: string[];
}
export const ModifyVpcEndpointServiceConfigurationRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ServiceId: S.optional(S.String),
    PrivateDnsName: S.optional(S.String),
    RemovePrivateDnsName: S.optional(S.Boolean),
    AcceptanceRequired: S.optional(S.Boolean),
    AddNetworkLoadBalancerArns: S.optional(ValueStringList).pipe(
      T.XmlName("AddNetworkLoadBalancerArn"),
    ),
    RemoveNetworkLoadBalancerArns: S.optional(ValueStringList).pipe(
      T.XmlName("RemoveNetworkLoadBalancerArn"),
    ),
    AddGatewayLoadBalancerArns: S.optional(ValueStringList).pipe(
      T.XmlName("AddGatewayLoadBalancerArn"),
    ),
    RemoveGatewayLoadBalancerArns: S.optional(ValueStringList).pipe(
      T.XmlName("RemoveGatewayLoadBalancerArn"),
    ),
    AddSupportedIpAddressTypes: S.optional(ValueStringList).pipe(
      T.XmlName("AddSupportedIpAddressType"),
    ),
    RemoveSupportedIpAddressTypes: S.optional(ValueStringList).pipe(
      T.XmlName("RemoveSupportedIpAddressType"),
    ),
    AddSupportedRegions: S.optional(ValueStringList).pipe(
      T.XmlName("AddSupportedRegion"),
    ),
    RemoveSupportedRegions: S.optional(ValueStringList).pipe(
      T.XmlName("RemoveSupportedRegion"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVpcEndpointServiceConfigurationRequest",
}) as any as S.Schema<ModifyVpcEndpointServiceConfigurationRequest>;
export interface ModifyVpcEndpointServiceConfigurationResult {
  Return?: boolean;
}
export const ModifyVpcEndpointServiceConfigurationResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVpcEndpointServiceConfigurationResult",
}) as any as S.Schema<ModifyVpcEndpointServiceConfigurationResult>;
export interface ModifyVpcEndpointServicePayerResponsibilityRequest {
  DryRun?: boolean;
  ServiceId?: string;
  PayerResponsibility?: PayerResponsibility;
}
export const ModifyVpcEndpointServicePayerResponsibilityRequest = S.suspend(
  () =>
    S.Struct({
      DryRun: S.optional(S.Boolean),
      ServiceId: S.optional(S.String),
      PayerResponsibility: S.optional(PayerResponsibility),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "ModifyVpcEndpointServicePayerResponsibilityRequest",
}) as any as S.Schema<ModifyVpcEndpointServicePayerResponsibilityRequest>;
export interface ModifyVpcEndpointServicePayerResponsibilityResult {
  ReturnValue?: boolean;
}
export const ModifyVpcEndpointServicePayerResponsibilityResult = S.suspend(() =>
  S.Struct({
    ReturnValue: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVpcEndpointServicePayerResponsibilityResult",
}) as any as S.Schema<ModifyVpcEndpointServicePayerResponsibilityResult>;
export interface ModifyVpcEndpointServicePermissionsRequest {
  DryRun?: boolean;
  ServiceId?: string;
  AddAllowedPrincipals?: string[];
  RemoveAllowedPrincipals?: string[];
}
export const ModifyVpcEndpointServicePermissionsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ServiceId: S.optional(S.String),
    AddAllowedPrincipals: S.optional(ValueStringList),
    RemoveAllowedPrincipals: S.optional(ValueStringList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVpcEndpointServicePermissionsRequest",
}) as any as S.Schema<ModifyVpcEndpointServicePermissionsRequest>;
export interface AddedPrincipal {
  PrincipalType?: PrincipalType;
  Principal?: string;
  ServicePermissionId?: string;
  ServiceId?: string;
}
export const AddedPrincipal = S.suspend(() =>
  S.Struct({
    PrincipalType: S.optional(PrincipalType).pipe(
      T.XmlName("principalType"),
      T.Ec2QueryName("PrincipalType"),
    ),
    Principal: S.optional(S.String).pipe(
      T.XmlName("principal"),
      T.Ec2QueryName("Principal"),
    ),
    ServicePermissionId: S.optional(S.String).pipe(
      T.XmlName("servicePermissionId"),
      T.Ec2QueryName("ServicePermissionId"),
    ),
    ServiceId: S.optional(S.String).pipe(
      T.XmlName("serviceId"),
      T.Ec2QueryName("ServiceId"),
    ),
  }),
).annotate({ identifier: "AddedPrincipal" }) as any as S.Schema<AddedPrincipal>;
export type AddedPrincipalSet = AddedPrincipal[];
export const AddedPrincipalSet = S.Array(
  AddedPrincipal.pipe(T.XmlName("item")).annotate({
    identifier: "AddedPrincipal",
  }),
);
export interface ModifyVpcEndpointServicePermissionsResult {
  AddedPrincipals?: AddedPrincipal[];
  ReturnValue?: boolean;
}
export const ModifyVpcEndpointServicePermissionsResult = S.suspend(() =>
  S.Struct({
    AddedPrincipals: S.optional(AddedPrincipalSet).pipe(
      T.XmlName("addedPrincipalSet"),
      T.Ec2QueryName("AddedPrincipalSet"),
    ),
    ReturnValue: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVpcEndpointServicePermissionsResult",
}) as any as S.Schema<ModifyVpcEndpointServicePermissionsResult>;
export interface PeeringConnectionOptionsRequest {
  AllowDnsResolutionFromRemoteVpc?: boolean;
  AllowEgressFromLocalClassicLinkToRemoteVpc?: boolean;
  AllowEgressFromLocalVpcToRemoteClassicLink?: boolean;
}
export const PeeringConnectionOptionsRequest = S.suspend(() =>
  S.Struct({
    AllowDnsResolutionFromRemoteVpc: S.optional(S.Boolean),
    AllowEgressFromLocalClassicLinkToRemoteVpc: S.optional(S.Boolean),
    AllowEgressFromLocalVpcToRemoteClassicLink: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "PeeringConnectionOptionsRequest",
}) as any as S.Schema<PeeringConnectionOptionsRequest>;
export interface ModifyVpcPeeringConnectionOptionsRequest {
  AccepterPeeringConnectionOptions?: PeeringConnectionOptionsRequest;
  DryRun?: boolean;
  RequesterPeeringConnectionOptions?: PeeringConnectionOptionsRequest;
  VpcPeeringConnectionId?: string;
}
export const ModifyVpcPeeringConnectionOptionsRequest = S.suspend(() =>
  S.Struct({
    AccepterPeeringConnectionOptions: S.optional(
      PeeringConnectionOptionsRequest,
    ),
    DryRun: S.optional(S.Boolean),
    RequesterPeeringConnectionOptions: S.optional(
      PeeringConnectionOptionsRequest,
    ),
    VpcPeeringConnectionId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVpcPeeringConnectionOptionsRequest",
}) as any as S.Schema<ModifyVpcPeeringConnectionOptionsRequest>;
export interface PeeringConnectionOptions {
  AllowDnsResolutionFromRemoteVpc?: boolean;
  AllowEgressFromLocalClassicLinkToRemoteVpc?: boolean;
  AllowEgressFromLocalVpcToRemoteClassicLink?: boolean;
}
export const PeeringConnectionOptions = S.suspend(() =>
  S.Struct({
    AllowDnsResolutionFromRemoteVpc: S.optional(S.Boolean).pipe(
      T.XmlName("allowDnsResolutionFromRemoteVpc"),
      T.Ec2QueryName("AllowDnsResolutionFromRemoteVpc"),
    ),
    AllowEgressFromLocalClassicLinkToRemoteVpc: S.optional(S.Boolean).pipe(
      T.XmlName("allowEgressFromLocalClassicLinkToRemoteVpc"),
      T.Ec2QueryName("AllowEgressFromLocalClassicLinkToRemoteVpc"),
    ),
    AllowEgressFromLocalVpcToRemoteClassicLink: S.optional(S.Boolean).pipe(
      T.XmlName("allowEgressFromLocalVpcToRemoteClassicLink"),
      T.Ec2QueryName("AllowEgressFromLocalVpcToRemoteClassicLink"),
    ),
  }),
).annotate({
  identifier: "PeeringConnectionOptions",
}) as any as S.Schema<PeeringConnectionOptions>;
export interface ModifyVpcPeeringConnectionOptionsResult {
  AccepterPeeringConnectionOptions?: PeeringConnectionOptions;
  RequesterPeeringConnectionOptions?: PeeringConnectionOptions;
}
export const ModifyVpcPeeringConnectionOptionsResult = S.suspend(() =>
  S.Struct({
    AccepterPeeringConnectionOptions: S.optional(PeeringConnectionOptions)
      .pipe(
        T.XmlName("accepterPeeringConnectionOptions"),
        T.Ec2QueryName("AccepterPeeringConnectionOptions"),
      )
      .annotate({ identifier: "PeeringConnectionOptions" }),
    RequesterPeeringConnectionOptions: S.optional(PeeringConnectionOptions)
      .pipe(
        T.XmlName("requesterPeeringConnectionOptions"),
        T.Ec2QueryName("RequesterPeeringConnectionOptions"),
      )
      .annotate({ identifier: "PeeringConnectionOptions" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVpcPeeringConnectionOptionsResult",
}) as any as S.Schema<ModifyVpcPeeringConnectionOptionsResult>;
export type VpcTenancy = "default" | (string & {});
export const VpcTenancy = S.String;
export interface ModifyVpcTenancyRequest {
  VpcId?: string;
  InstanceTenancy?: VpcTenancy;
  DryRun?: boolean;
}
export const ModifyVpcTenancyRequest = S.suspend(() =>
  S.Struct({
    VpcId: S.optional(S.String),
    InstanceTenancy: S.optional(VpcTenancy),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVpcTenancyRequest",
}) as any as S.Schema<ModifyVpcTenancyRequest>;
export interface ModifyVpcTenancyResult {
  ReturnValue?: boolean;
}
export const ModifyVpcTenancyResult = S.suspend(() =>
  S.Struct({
    ReturnValue: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVpcTenancyResult",
}) as any as S.Schema<ModifyVpcTenancyResult>;
export interface ModifyVpnConnectionRequest {
  VpnConnectionId?: string;
  TransitGatewayId?: string;
  CustomerGatewayId?: string;
  VpnGatewayId?: string;
  DryRun?: boolean;
}
export const ModifyVpnConnectionRequest = S.suspend(() =>
  S.Struct({
    VpnConnectionId: S.optional(S.String),
    TransitGatewayId: S.optional(S.String),
    CustomerGatewayId: S.optional(S.String),
    VpnGatewayId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVpnConnectionRequest",
}) as any as S.Schema<ModifyVpnConnectionRequest>;
export interface ModifyVpnConnectionResult {
  VpnConnection?: VpnConnection;
}
export const ModifyVpnConnectionResult = S.suspend(() =>
  S.Struct({
    VpnConnection: S.optional(VpnConnection)
      .pipe(T.XmlName("vpnConnection"), T.Ec2QueryName("VpnConnection"))
      .annotate({ identifier: "VpnConnection" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVpnConnectionResult",
}) as any as S.Schema<ModifyVpnConnectionResult>;
export interface ModifyVpnConnectionOptionsRequest {
  VpnConnectionId?: string;
  LocalIpv4NetworkCidr?: string;
  RemoteIpv4NetworkCidr?: string;
  LocalIpv6NetworkCidr?: string;
  RemoteIpv6NetworkCidr?: string;
  DryRun?: boolean;
}
export const ModifyVpnConnectionOptionsRequest = S.suspend(() =>
  S.Struct({
    VpnConnectionId: S.optional(S.String),
    LocalIpv4NetworkCidr: S.optional(S.String),
    RemoteIpv4NetworkCidr: S.optional(S.String),
    LocalIpv6NetworkCidr: S.optional(S.String),
    RemoteIpv6NetworkCidr: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVpnConnectionOptionsRequest",
}) as any as S.Schema<ModifyVpnConnectionOptionsRequest>;
export interface ModifyVpnConnectionOptionsResult {
  VpnConnection?: VpnConnection;
}
export const ModifyVpnConnectionOptionsResult = S.suspend(() =>
  S.Struct({
    VpnConnection: S.optional(VpnConnection)
      .pipe(T.XmlName("vpnConnection"), T.Ec2QueryName("VpnConnection"))
      .annotate({ identifier: "VpnConnection" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVpnConnectionOptionsResult",
}) as any as S.Schema<ModifyVpnConnectionOptionsResult>;
export interface ModifyVpnTunnelCertificateRequest {
  VpnConnectionId?: string;
  VpnTunnelOutsideIpAddress?: string;
  DryRun?: boolean;
}
export const ModifyVpnTunnelCertificateRequest = S.suspend(() =>
  S.Struct({
    VpnConnectionId: S.optional(S.String),
    VpnTunnelOutsideIpAddress: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVpnTunnelCertificateRequest",
}) as any as S.Schema<ModifyVpnTunnelCertificateRequest>;
export interface ModifyVpnTunnelCertificateResult {
  VpnConnection?: VpnConnection;
}
export const ModifyVpnTunnelCertificateResult = S.suspend(() =>
  S.Struct({
    VpnConnection: S.optional(VpnConnection)
      .pipe(T.XmlName("vpnConnection"), T.Ec2QueryName("VpnConnection"))
      .annotate({ identifier: "VpnConnection" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVpnTunnelCertificateResult",
}) as any as S.Schema<ModifyVpnTunnelCertificateResult>;
export interface ModifyVpnTunnelOptionsSpecification {
  TunnelInsideCidr?: string;
  TunnelInsideIpv6Cidr?: string;
  PreSharedKey?: string | redacted.Redacted<string>;
  Phase1LifetimeSeconds?: number;
  Phase2LifetimeSeconds?: number;
  RekeyMarginTimeSeconds?: number;
  RekeyFuzzPercentage?: number;
  ReplayWindowSize?: number;
  DPDTimeoutSeconds?: number;
  DPDTimeoutAction?: string;
  Phase1EncryptionAlgorithms?: Phase1EncryptionAlgorithmsRequestListValue[];
  Phase2EncryptionAlgorithms?: Phase2EncryptionAlgorithmsRequestListValue[];
  Phase1IntegrityAlgorithms?: Phase1IntegrityAlgorithmsRequestListValue[];
  Phase2IntegrityAlgorithms?: Phase2IntegrityAlgorithmsRequestListValue[];
  Phase1DHGroupNumbers?: Phase1DHGroupNumbersRequestListValue[];
  Phase2DHGroupNumbers?: Phase2DHGroupNumbersRequestListValue[];
  IKEVersions?: IKEVersionsRequestListValue[];
  StartupAction?: string;
  LogOptions?: VpnTunnelLogOptionsSpecification;
  EnableTunnelLifecycleControl?: boolean;
}
export const ModifyVpnTunnelOptionsSpecification = S.suspend(() =>
  S.Struct({
    TunnelInsideCidr: S.optional(S.String),
    TunnelInsideIpv6Cidr: S.optional(S.String),
    PreSharedKey: S.optional(SensitiveString),
    Phase1LifetimeSeconds: S.optional(S.Number),
    Phase2LifetimeSeconds: S.optional(S.Number),
    RekeyMarginTimeSeconds: S.optional(S.Number),
    RekeyFuzzPercentage: S.optional(S.Number),
    ReplayWindowSize: S.optional(S.Number),
    DPDTimeoutSeconds: S.optional(S.Number),
    DPDTimeoutAction: S.optional(S.String),
    Phase1EncryptionAlgorithms: S.optional(
      Phase1EncryptionAlgorithmsRequestList,
    ).pipe(T.XmlName("Phase1EncryptionAlgorithm")),
    Phase2EncryptionAlgorithms: S.optional(
      Phase2EncryptionAlgorithmsRequestList,
    ).pipe(T.XmlName("Phase2EncryptionAlgorithm")),
    Phase1IntegrityAlgorithms: S.optional(
      Phase1IntegrityAlgorithmsRequestList,
    ).pipe(T.XmlName("Phase1IntegrityAlgorithm")),
    Phase2IntegrityAlgorithms: S.optional(
      Phase2IntegrityAlgorithmsRequestList,
    ).pipe(T.XmlName("Phase2IntegrityAlgorithm")),
    Phase1DHGroupNumbers: S.optional(Phase1DHGroupNumbersRequestList).pipe(
      T.XmlName("Phase1DHGroupNumber"),
    ),
    Phase2DHGroupNumbers: S.optional(Phase2DHGroupNumbersRequestList).pipe(
      T.XmlName("Phase2DHGroupNumber"),
    ),
    IKEVersions: S.optional(IKEVersionsRequestList).pipe(
      T.XmlName("IKEVersion"),
    ),
    StartupAction: S.optional(S.String),
    LogOptions: S.optional(VpnTunnelLogOptionsSpecification),
    EnableTunnelLifecycleControl: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "ModifyVpnTunnelOptionsSpecification",
}) as any as S.Schema<ModifyVpnTunnelOptionsSpecification>;
export interface ModifyVpnTunnelOptionsRequest {
  VpnConnectionId?: string;
  VpnTunnelOutsideIpAddress?: string;
  TunnelOptions?: ModifyVpnTunnelOptionsSpecification;
  DryRun?: boolean;
  SkipTunnelReplacement?: boolean;
  PreSharedKeyStorage?: string;
}
export const ModifyVpnTunnelOptionsRequest = S.suspend(() =>
  S.Struct({
    VpnConnectionId: S.optional(S.String),
    VpnTunnelOutsideIpAddress: S.optional(S.String),
    TunnelOptions: S.optional(ModifyVpnTunnelOptionsSpecification),
    DryRun: S.optional(S.Boolean),
    SkipTunnelReplacement: S.optional(S.Boolean),
    PreSharedKeyStorage: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ModifyVpnTunnelOptionsRequest",
}) as any as S.Schema<ModifyVpnTunnelOptionsRequest>;
export interface ModifyVpnTunnelOptionsResult {
  VpnConnection?: VpnConnection;
}
export const ModifyVpnTunnelOptionsResult = S.suspend(() =>
  S.Struct({
    VpnConnection: S.optional(VpnConnection)
      .pipe(T.XmlName("vpnConnection"), T.Ec2QueryName("VpnConnection"))
      .annotate({ identifier: "VpnConnection" }),
  }).pipe(ns),
).annotate({
  identifier: "ModifyVpnTunnelOptionsResult",
}) as any as S.Schema<ModifyVpnTunnelOptionsResult>;
export interface MonitorInstancesRequest {
  InstanceIds?: string[];
  DryRun?: boolean;
}
export const MonitorInstancesRequest = S.suspend(() =>
  S.Struct({
    InstanceIds: S.optional(InstanceIdStringList).pipe(T.XmlName("InstanceId")),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "MonitorInstancesRequest",
}) as any as S.Schema<MonitorInstancesRequest>;
export interface InstanceMonitoring {
  InstanceId?: string;
  Monitoring?: Monitoring;
}
export const InstanceMonitoring = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    Monitoring: S.optional(Monitoring)
      .pipe(T.XmlName("monitoring"), T.Ec2QueryName("Monitoring"))
      .annotate({ identifier: "Monitoring" }),
  }),
).annotate({
  identifier: "InstanceMonitoring",
}) as any as S.Schema<InstanceMonitoring>;
export type InstanceMonitoringList = InstanceMonitoring[];
export const InstanceMonitoringList = S.Array(
  InstanceMonitoring.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceMonitoring",
  }),
);
export interface MonitorInstancesResult {
  InstanceMonitorings?: InstanceMonitoring[];
}
export const MonitorInstancesResult = S.suspend(() =>
  S.Struct({
    InstanceMonitorings: S.optional(InstanceMonitoringList).pipe(
      T.XmlName("instancesSet"),
      T.Ec2QueryName("InstancesSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "MonitorInstancesResult",
}) as any as S.Schema<MonitorInstancesResult>;
export interface MoveAddressToVpcRequest {
  DryRun?: boolean;
  PublicIp?: string;
}
export const MoveAddressToVpcRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    PublicIp: S.optional(S.String).pipe(
      T.XmlName("publicIp"),
      T.Ec2QueryName("PublicIp"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "MoveAddressToVpcRequest",
}) as any as S.Schema<MoveAddressToVpcRequest>;
export type Status = "MoveInProgress" | "InVpc" | "InClassic" | (string & {});
export const Status = S.String;
export interface MoveAddressToVpcResult {
  AllocationId?: string;
  Status?: Status;
}
export const MoveAddressToVpcResult = S.suspend(() =>
  S.Struct({
    AllocationId: S.optional(S.String).pipe(
      T.XmlName("allocationId"),
      T.Ec2QueryName("AllocationId"),
    ),
    Status: S.optional(Status).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "MoveAddressToVpcResult",
}) as any as S.Schema<MoveAddressToVpcResult>;
export interface MoveByoipCidrToIpamRequest {
  DryRun?: boolean;
  Cidr?: string;
  IpamPoolId?: string;
  IpamPoolOwner?: string;
}
export const MoveByoipCidrToIpamRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    Cidr: S.optional(S.String),
    IpamPoolId: S.optional(S.String),
    IpamPoolOwner: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "MoveByoipCidrToIpamRequest",
}) as any as S.Schema<MoveByoipCidrToIpamRequest>;
export interface MoveByoipCidrToIpamResult {
  ByoipCidr?: ByoipCidr;
}
export const MoveByoipCidrToIpamResult = S.suspend(() =>
  S.Struct({
    ByoipCidr: S.optional(ByoipCidr)
      .pipe(T.XmlName("byoipCidr"), T.Ec2QueryName("ByoipCidr"))
      .annotate({ identifier: "ByoipCidr" }),
  }).pipe(ns),
).annotate({
  identifier: "MoveByoipCidrToIpamResult",
}) as any as S.Schema<MoveByoipCidrToIpamResult>;
export interface MoveCapacityReservationInstancesRequest {
  DryRun?: boolean;
  ClientToken?: string;
  SourceCapacityReservationId?: string;
  DestinationCapacityReservationId?: string;
  InstanceCount?: number;
}
export const MoveCapacityReservationInstancesRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    SourceCapacityReservationId: S.optional(S.String),
    DestinationCapacityReservationId: S.optional(S.String),
    InstanceCount: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "MoveCapacityReservationInstancesRequest",
}) as any as S.Schema<MoveCapacityReservationInstancesRequest>;
export interface MoveCapacityReservationInstancesResult {
  SourceCapacityReservation?: CapacityReservation;
  DestinationCapacityReservation?: CapacityReservation;
  InstanceCount?: number;
}
export const MoveCapacityReservationInstancesResult = S.suspend(() =>
  S.Struct({
    SourceCapacityReservation: S.optional(CapacityReservation)
      .pipe(
        T.XmlName("sourceCapacityReservation"),
        T.Ec2QueryName("SourceCapacityReservation"),
      )
      .annotate({ identifier: "CapacityReservation" }),
    DestinationCapacityReservation: S.optional(CapacityReservation)
      .pipe(
        T.XmlName("destinationCapacityReservation"),
        T.Ec2QueryName("DestinationCapacityReservation"),
      )
      .annotate({ identifier: "CapacityReservation" }),
    InstanceCount: S.optional(S.Number).pipe(
      T.XmlName("instanceCount"),
      T.Ec2QueryName("InstanceCount"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "MoveCapacityReservationInstancesResult",
}) as any as S.Schema<MoveCapacityReservationInstancesResult>;
export interface CidrAuthorizationContext {
  Message?: string;
  Signature?: string;
}
export const CidrAuthorizationContext = S.suspend(() =>
  S.Struct({ Message: S.optional(S.String), Signature: S.optional(S.String) }),
).annotate({
  identifier: "CidrAuthorizationContext",
}) as any as S.Schema<CidrAuthorizationContext>;
export interface ProvisionByoipCidrRequest {
  Cidr?: string;
  CidrAuthorizationContext?: CidrAuthorizationContext;
  PubliclyAdvertisable?: boolean;
  Description?: string;
  DryRun?: boolean;
  PoolTagSpecifications?: TagSpecification[];
  MultiRegion?: boolean;
  NetworkBorderGroup?: string;
}
export const ProvisionByoipCidrRequest = S.suspend(() =>
  S.Struct({
    Cidr: S.optional(S.String),
    CidrAuthorizationContext: S.optional(CidrAuthorizationContext),
    PubliclyAdvertisable: S.optional(S.Boolean),
    Description: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    PoolTagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("PoolTagSpecification"),
    ),
    MultiRegion: S.optional(S.Boolean),
    NetworkBorderGroup: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ProvisionByoipCidrRequest",
}) as any as S.Schema<ProvisionByoipCidrRequest>;
export interface ProvisionByoipCidrResult {
  ByoipCidr?: ByoipCidr;
}
export const ProvisionByoipCidrResult = S.suspend(() =>
  S.Struct({
    ByoipCidr: S.optional(ByoipCidr)
      .pipe(T.XmlName("byoipCidr"), T.Ec2QueryName("ByoipCidr"))
      .annotate({ identifier: "ByoipCidr" }),
  }).pipe(ns),
).annotate({
  identifier: "ProvisionByoipCidrResult",
}) as any as S.Schema<ProvisionByoipCidrResult>;
export interface AsnAuthorizationContext {
  Message?: string;
  Signature?: string;
}
export const AsnAuthorizationContext = S.suspend(() =>
  S.Struct({ Message: S.optional(S.String), Signature: S.optional(S.String) }),
).annotate({
  identifier: "AsnAuthorizationContext",
}) as any as S.Schema<AsnAuthorizationContext>;
export interface ProvisionIpamByoasnRequest {
  DryRun?: boolean;
  IpamId?: string;
  Asn?: string;
  AsnAuthorizationContext?: AsnAuthorizationContext;
}
export const ProvisionIpamByoasnRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamId: S.optional(S.String),
    Asn: S.optional(S.String),
    AsnAuthorizationContext: S.optional(AsnAuthorizationContext),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ProvisionIpamByoasnRequest",
}) as any as S.Schema<ProvisionIpamByoasnRequest>;
export interface ProvisionIpamByoasnResult {
  Byoasn?: Byoasn;
}
export const ProvisionIpamByoasnResult = S.suspend(() =>
  S.Struct({
    Byoasn: S.optional(Byoasn)
      .pipe(T.XmlName("byoasn"), T.Ec2QueryName("Byoasn"))
      .annotate({ identifier: "Byoasn" }),
  }).pipe(ns),
).annotate({
  identifier: "ProvisionIpamByoasnResult",
}) as any as S.Schema<ProvisionIpamByoasnResult>;
export interface IpamCidrAuthorizationContext {
  Message?: string;
  Signature?: string;
}
export const IpamCidrAuthorizationContext = S.suspend(() =>
  S.Struct({ Message: S.optional(S.String), Signature: S.optional(S.String) }),
).annotate({
  identifier: "IpamCidrAuthorizationContext",
}) as any as S.Schema<IpamCidrAuthorizationContext>;
export type VerificationMethod = "remarks-x509" | "dns-token" | (string & {});
export const VerificationMethod = S.String;
export interface ProvisionIpamPoolCidrRequest {
  DryRun?: boolean;
  IpamPoolId?: string;
  Cidr?: string;
  CidrAuthorizationContext?: IpamCidrAuthorizationContext;
  NetmaskLength?: number;
  ClientToken?: string;
  VerificationMethod?: VerificationMethod;
  IpamExternalResourceVerificationTokenId?: string;
}
export const ProvisionIpamPoolCidrRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPoolId: S.optional(S.String),
    Cidr: S.optional(S.String),
    CidrAuthorizationContext: S.optional(IpamCidrAuthorizationContext),
    NetmaskLength: S.optional(S.Number),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    VerificationMethod: S.optional(VerificationMethod),
    IpamExternalResourceVerificationTokenId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ProvisionIpamPoolCidrRequest",
}) as any as S.Schema<ProvisionIpamPoolCidrRequest>;
export interface ProvisionIpamPoolCidrResult {
  IpamPoolCidr?: IpamPoolCidr;
}
export const ProvisionIpamPoolCidrResult = S.suspend(() =>
  S.Struct({
    IpamPoolCidr: S.optional(IpamPoolCidr)
      .pipe(T.XmlName("ipamPoolCidr"), T.Ec2QueryName("IpamPoolCidr"))
      .annotate({ identifier: "IpamPoolCidr" }),
  }).pipe(ns),
).annotate({
  identifier: "ProvisionIpamPoolCidrResult",
}) as any as S.Schema<ProvisionIpamPoolCidrResult>;
export interface ProvisionPublicIpv4PoolCidrRequest {
  DryRun?: boolean;
  IpamPoolId?: string;
  PoolId?: string;
  NetmaskLength?: number;
  NetworkBorderGroup?: string;
}
export const ProvisionPublicIpv4PoolCidrRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPoolId: S.optional(S.String),
    PoolId: S.optional(S.String),
    NetmaskLength: S.optional(S.Number),
    NetworkBorderGroup: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ProvisionPublicIpv4PoolCidrRequest",
}) as any as S.Schema<ProvisionPublicIpv4PoolCidrRequest>;
export interface ProvisionPublicIpv4PoolCidrResult {
  PoolId?: string;
  PoolAddressRange?: PublicIpv4PoolRange;
}
export const ProvisionPublicIpv4PoolCidrResult = S.suspend(() =>
  S.Struct({
    PoolId: S.optional(S.String).pipe(
      T.XmlName("poolId"),
      T.Ec2QueryName("PoolId"),
    ),
    PoolAddressRange: S.optional(PublicIpv4PoolRange)
      .pipe(T.XmlName("poolAddressRange"), T.Ec2QueryName("PoolAddressRange"))
      .annotate({ identifier: "PublicIpv4PoolRange" }),
  }).pipe(ns),
).annotate({
  identifier: "ProvisionPublicIpv4PoolCidrResult",
}) as any as S.Schema<ProvisionPublicIpv4PoolCidrResult>;
export interface PurchaseCapacityBlockRequest {
  DryRun?: boolean;
  TagSpecifications?: TagSpecification[];
  CapacityBlockOfferingId?: string;
  InstancePlatform?: CapacityReservationInstancePlatform;
}
export const PurchaseCapacityBlockRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    CapacityBlockOfferingId: S.optional(S.String),
    InstancePlatform: S.optional(CapacityReservationInstancePlatform),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "PurchaseCapacityBlockRequest",
}) as any as S.Schema<PurchaseCapacityBlockRequest>;
export interface PurchaseCapacityBlockResult {
  CapacityReservation?: CapacityReservation;
  CapacityBlocks?: CapacityBlock[];
}
export const PurchaseCapacityBlockResult = S.suspend(() =>
  S.Struct({
    CapacityReservation: S.optional(CapacityReservation)
      .pipe(
        T.XmlName("capacityReservation"),
        T.Ec2QueryName("CapacityReservation"),
      )
      .annotate({ identifier: "CapacityReservation" }),
    CapacityBlocks: S.optional(CapacityBlockSet).pipe(
      T.XmlName("capacityBlockSet"),
      T.Ec2QueryName("CapacityBlockSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "PurchaseCapacityBlockResult",
}) as any as S.Schema<PurchaseCapacityBlockResult>;
export interface PurchaseCapacityBlockExtensionRequest {
  CapacityBlockExtensionOfferingId?: string;
  CapacityReservationId?: string;
  DryRun?: boolean;
}
export const PurchaseCapacityBlockExtensionRequest = S.suspend(() =>
  S.Struct({
    CapacityBlockExtensionOfferingId: S.optional(S.String),
    CapacityReservationId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "PurchaseCapacityBlockExtensionRequest",
}) as any as S.Schema<PurchaseCapacityBlockExtensionRequest>;
export interface PurchaseCapacityBlockExtensionResult {
  CapacityBlockExtensions?: CapacityBlockExtension[];
}
export const PurchaseCapacityBlockExtensionResult = S.suspend(() =>
  S.Struct({
    CapacityBlockExtensions: S.optional(CapacityBlockExtensionSet).pipe(
      T.XmlName("capacityBlockExtensionSet"),
      T.Ec2QueryName("CapacityBlockExtensionSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "PurchaseCapacityBlockExtensionResult",
}) as any as S.Schema<PurchaseCapacityBlockExtensionResult>;
export interface PurchaseHostReservationRequest {
  ClientToken?: string;
  CurrencyCode?: CurrencyCodeValues;
  HostIdSet?: string[];
  LimitPrice?: string;
  OfferingId?: string;
  TagSpecifications?: TagSpecification[];
}
export const PurchaseHostReservationRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String),
    CurrencyCode: S.optional(CurrencyCodeValues),
    HostIdSet: S.optional(RequestHostIdSet),
    LimitPrice: S.optional(S.String),
    OfferingId: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "PurchaseHostReservationRequest",
}) as any as S.Schema<PurchaseHostReservationRequest>;
export interface PurchaseHostReservationResult {
  ClientToken?: string;
  CurrencyCode?: CurrencyCodeValues;
  Purchase?: Purchase[];
  TotalHourlyPrice?: string;
  TotalUpfrontPrice?: string;
}
export const PurchaseHostReservationResult = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
    CurrencyCode: S.optional(CurrencyCodeValues).pipe(
      T.XmlName("currencyCode"),
      T.Ec2QueryName("CurrencyCode"),
    ),
    Purchase: S.optional(PurchaseSet).pipe(
      T.XmlName("purchase"),
      T.Ec2QueryName("Purchase"),
    ),
    TotalHourlyPrice: S.optional(S.String).pipe(
      T.XmlName("totalHourlyPrice"),
      T.Ec2QueryName("TotalHourlyPrice"),
    ),
    TotalUpfrontPrice: S.optional(S.String).pipe(
      T.XmlName("totalUpfrontPrice"),
      T.Ec2QueryName("TotalUpfrontPrice"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "PurchaseHostReservationResult",
}) as any as S.Schema<PurchaseHostReservationResult>;
export interface ReservedInstanceLimitPrice {
  Amount?: number;
  CurrencyCode?: CurrencyCodeValues;
}
export const ReservedInstanceLimitPrice = S.suspend(() =>
  S.Struct({
    Amount: S.optional(S.Number).pipe(
      T.XmlName("amount"),
      T.Ec2QueryName("Amount"),
    ),
    CurrencyCode: S.optional(CurrencyCodeValues).pipe(
      T.XmlName("currencyCode"),
      T.Ec2QueryName("CurrencyCode"),
    ),
  }),
).annotate({
  identifier: "ReservedInstanceLimitPrice",
}) as any as S.Schema<ReservedInstanceLimitPrice>;
export interface PurchaseReservedInstancesOfferingRequest {
  InstanceCount?: number;
  ReservedInstancesOfferingId?: string;
  PurchaseTime?: Date;
  DryRun?: boolean;
  LimitPrice?: ReservedInstanceLimitPrice;
}
export const PurchaseReservedInstancesOfferingRequest = S.suspend(() =>
  S.Struct({
    InstanceCount: S.optional(S.Number),
    ReservedInstancesOfferingId: S.optional(S.String),
    PurchaseTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    LimitPrice: S.optional(ReservedInstanceLimitPrice)
      .pipe(T.XmlName("limitPrice"), T.Ec2QueryName("LimitPrice"))
      .annotate({ identifier: "ReservedInstanceLimitPrice" }),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "PurchaseReservedInstancesOfferingRequest",
}) as any as S.Schema<PurchaseReservedInstancesOfferingRequest>;
export interface PurchaseReservedInstancesOfferingResult {
  ReservedInstancesId?: string;
}
export const PurchaseReservedInstancesOfferingResult = S.suspend(() =>
  S.Struct({
    ReservedInstancesId: S.optional(S.String).pipe(
      T.XmlName("reservedInstancesId"),
      T.Ec2QueryName("ReservedInstancesId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "PurchaseReservedInstancesOfferingResult",
}) as any as S.Schema<PurchaseReservedInstancesOfferingResult>;
export interface PurchaseRequest {
  InstanceCount?: number;
  PurchaseToken?: string;
}
export const PurchaseRequest = S.suspend(() =>
  S.Struct({
    InstanceCount: S.optional(S.Number),
    PurchaseToken: S.optional(S.String),
  }),
).annotate({
  identifier: "PurchaseRequest",
}) as any as S.Schema<PurchaseRequest>;
export type PurchaseRequestSet = PurchaseRequest[];
export const PurchaseRequestSet = S.Array(
  PurchaseRequest.pipe(T.XmlName("PurchaseRequest")).annotate({
    identifier: "PurchaseRequest",
  }),
);
export interface PurchaseScheduledInstancesRequest {
  ClientToken?: string;
  DryRun?: boolean;
  PurchaseRequests?: PurchaseRequest[];
}
export const PurchaseScheduledInstancesRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
    PurchaseRequests: S.optional(PurchaseRequestSet).pipe(
      T.XmlName("PurchaseRequest"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "PurchaseScheduledInstancesRequest",
}) as any as S.Schema<PurchaseScheduledInstancesRequest>;
export type PurchasedScheduledInstanceSet = ScheduledInstance[];
export const PurchasedScheduledInstanceSet = S.Array(
  ScheduledInstance.pipe(T.XmlName("item")).annotate({
    identifier: "ScheduledInstance",
  }),
);
export interface PurchaseScheduledInstancesResult {
  ScheduledInstanceSet?: ScheduledInstance[];
}
export const PurchaseScheduledInstancesResult = S.suspend(() =>
  S.Struct({
    ScheduledInstanceSet: S.optional(PurchasedScheduledInstanceSet).pipe(
      T.XmlName("scheduledInstanceSet"),
      T.Ec2QueryName("ScheduledInstanceSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "PurchaseScheduledInstancesResult",
}) as any as S.Schema<PurchaseScheduledInstancesResult>;
export interface RebootInstancesRequest {
  InstanceIds?: string[];
  DryRun?: boolean;
}
export const RebootInstancesRequest = S.suspend(() =>
  S.Struct({
    InstanceIds: S.optional(InstanceIdStringList).pipe(T.XmlName("InstanceId")),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RebootInstancesRequest",
}) as any as S.Schema<RebootInstancesRequest>;
export interface RebootInstancesResponse {}
export const RebootInstancesResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "RebootInstancesResponse",
}) as any as S.Schema<RebootInstancesResponse>;
export type BillingProductList = string[];
export const BillingProductList = S.Array(S.String.pipe(T.XmlName("item")));
export interface RegisterImageRequest {
  ImageLocation?: string;
  BillingProducts?: string[];
  BootMode?: BootModeValues;
  TpmSupport?: TpmSupportValues;
  UefiData?: string;
  ImdsSupport?: ImdsSupportValues;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
  Name?: string;
  Description?: string;
  Architecture?: ArchitectureValues;
  KernelId?: string;
  RamdiskId?: string;
  RootDeviceName?: string;
  BlockDeviceMappings?: BlockDeviceMapping[];
  VirtualizationType?: string;
  SriovNetSupport?: string;
  EnaSupport?: boolean;
}
export const RegisterImageRequest = S.suspend(() =>
  S.Struct({
    ImageLocation: S.optional(S.String),
    BillingProducts: S.optional(BillingProductList).pipe(
      T.XmlName("BillingProduct"),
    ),
    BootMode: S.optional(BootModeValues),
    TpmSupport: S.optional(TpmSupportValues),
    UefiData: S.optional(S.String),
    ImdsSupport: S.optional(ImdsSupportValues),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Name: S.optional(S.String).pipe(T.XmlName("name"), T.Ec2QueryName("Name")),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    Architecture: S.optional(ArchitectureValues).pipe(
      T.XmlName("architecture"),
      T.Ec2QueryName("Architecture"),
    ),
    KernelId: S.optional(S.String).pipe(
      T.XmlName("kernelId"),
      T.Ec2QueryName("KernelId"),
    ),
    RamdiskId: S.optional(S.String).pipe(
      T.XmlName("ramdiskId"),
      T.Ec2QueryName("RamdiskId"),
    ),
    RootDeviceName: S.optional(S.String).pipe(
      T.XmlName("rootDeviceName"),
      T.Ec2QueryName("RootDeviceName"),
    ),
    BlockDeviceMappings: S.optional(BlockDeviceMappingRequestList).pipe(
      T.XmlName("BlockDeviceMapping"),
    ),
    VirtualizationType: S.optional(S.String).pipe(
      T.XmlName("virtualizationType"),
      T.Ec2QueryName("VirtualizationType"),
    ),
    SriovNetSupport: S.optional(S.String).pipe(
      T.XmlName("sriovNetSupport"),
      T.Ec2QueryName("SriovNetSupport"),
    ),
    EnaSupport: S.optional(S.Boolean).pipe(
      T.XmlName("enaSupport"),
      T.Ec2QueryName("EnaSupport"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RegisterImageRequest",
}) as any as S.Schema<RegisterImageRequest>;
export interface RegisterImageResult {
  ImageId?: string;
}
export const RegisterImageResult = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "RegisterImageResult",
}) as any as S.Schema<RegisterImageResult>;
export interface RegisterInstanceTagAttributeRequest {
  IncludeAllTagsOfInstance?: boolean;
  InstanceTagKeys?: string[];
}
export const RegisterInstanceTagAttributeRequest = S.suspend(() =>
  S.Struct({
    IncludeAllTagsOfInstance: S.optional(S.Boolean),
    InstanceTagKeys: S.optional(InstanceTagKeySet).pipe(
      T.XmlName("InstanceTagKey"),
    ),
  }),
).annotate({
  identifier: "RegisterInstanceTagAttributeRequest",
}) as any as S.Schema<RegisterInstanceTagAttributeRequest>;
export interface RegisterInstanceEventNotificationAttributesRequest {
  DryRun?: boolean;
  InstanceTagAttribute?: RegisterInstanceTagAttributeRequest;
}
export const RegisterInstanceEventNotificationAttributesRequest = S.suspend(
  () =>
    S.Struct({
      DryRun: S.optional(S.Boolean),
      InstanceTagAttribute: S.optional(RegisterInstanceTagAttributeRequest),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "RegisterInstanceEventNotificationAttributesRequest",
}) as any as S.Schema<RegisterInstanceEventNotificationAttributesRequest>;
export interface RegisterInstanceEventNotificationAttributesResult {
  InstanceTagAttribute?: InstanceTagNotificationAttribute;
}
export const RegisterInstanceEventNotificationAttributesResult = S.suspend(() =>
  S.Struct({
    InstanceTagAttribute: S.optional(InstanceTagNotificationAttribute)
      .pipe(
        T.XmlName("instanceTagAttribute"),
        T.Ec2QueryName("InstanceTagAttribute"),
      )
      .annotate({ identifier: "InstanceTagNotificationAttribute" }),
  }).pipe(ns),
).annotate({
  identifier: "RegisterInstanceEventNotificationAttributesResult",
}) as any as S.Schema<RegisterInstanceEventNotificationAttributesResult>;
export interface RegisterTransitGatewayMulticastGroupMembersRequest {
  TransitGatewayMulticastDomainId?: string;
  GroupIpAddress?: string;
  NetworkInterfaceIds?: string[];
  DryRun?: boolean;
}
export const RegisterTransitGatewayMulticastGroupMembersRequest = S.suspend(
  () =>
    S.Struct({
      TransitGatewayMulticastDomainId: S.optional(S.String),
      GroupIpAddress: S.optional(S.String),
      NetworkInterfaceIds: S.optional(TransitGatewayNetworkInterfaceIdList),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "RegisterTransitGatewayMulticastGroupMembersRequest",
}) as any as S.Schema<RegisterTransitGatewayMulticastGroupMembersRequest>;
export interface TransitGatewayMulticastRegisteredGroupMembers {
  TransitGatewayMulticastDomainId?: string;
  RegisteredNetworkInterfaceIds?: string[];
  GroupIpAddress?: string;
}
export const TransitGatewayMulticastRegisteredGroupMembers = S.suspend(() =>
  S.Struct({
    TransitGatewayMulticastDomainId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayMulticastDomainId"),
      T.Ec2QueryName("TransitGatewayMulticastDomainId"),
    ),
    RegisteredNetworkInterfaceIds: S.optional(ValueStringList).pipe(
      T.XmlName("registeredNetworkInterfaceIds"),
      T.Ec2QueryName("RegisteredNetworkInterfaceIds"),
    ),
    GroupIpAddress: S.optional(S.String).pipe(
      T.XmlName("groupIpAddress"),
      T.Ec2QueryName("GroupIpAddress"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayMulticastRegisteredGroupMembers",
}) as any as S.Schema<TransitGatewayMulticastRegisteredGroupMembers>;
export interface RegisterTransitGatewayMulticastGroupMembersResult {
  RegisteredMulticastGroupMembers?: TransitGatewayMulticastRegisteredGroupMembers;
}
export const RegisterTransitGatewayMulticastGroupMembersResult = S.suspend(() =>
  S.Struct({
    RegisteredMulticastGroupMembers: S.optional(
      TransitGatewayMulticastRegisteredGroupMembers,
    )
      .pipe(
        T.XmlName("registeredMulticastGroupMembers"),
        T.Ec2QueryName("RegisteredMulticastGroupMembers"),
      )
      .annotate({
        identifier: "TransitGatewayMulticastRegisteredGroupMembers",
      }),
  }).pipe(ns),
).annotate({
  identifier: "RegisterTransitGatewayMulticastGroupMembersResult",
}) as any as S.Schema<RegisterTransitGatewayMulticastGroupMembersResult>;
export interface RegisterTransitGatewayMulticastGroupSourcesRequest {
  TransitGatewayMulticastDomainId?: string;
  GroupIpAddress?: string;
  NetworkInterfaceIds?: string[];
  DryRun?: boolean;
}
export const RegisterTransitGatewayMulticastGroupSourcesRequest = S.suspend(
  () =>
    S.Struct({
      TransitGatewayMulticastDomainId: S.optional(S.String),
      GroupIpAddress: S.optional(S.String),
      NetworkInterfaceIds: S.optional(TransitGatewayNetworkInterfaceIdList),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "RegisterTransitGatewayMulticastGroupSourcesRequest",
}) as any as S.Schema<RegisterTransitGatewayMulticastGroupSourcesRequest>;
export interface TransitGatewayMulticastRegisteredGroupSources {
  TransitGatewayMulticastDomainId?: string;
  RegisteredNetworkInterfaceIds?: string[];
  GroupIpAddress?: string;
}
export const TransitGatewayMulticastRegisteredGroupSources = S.suspend(() =>
  S.Struct({
    TransitGatewayMulticastDomainId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayMulticastDomainId"),
      T.Ec2QueryName("TransitGatewayMulticastDomainId"),
    ),
    RegisteredNetworkInterfaceIds: S.optional(ValueStringList).pipe(
      T.XmlName("registeredNetworkInterfaceIds"),
      T.Ec2QueryName("RegisteredNetworkInterfaceIds"),
    ),
    GroupIpAddress: S.optional(S.String).pipe(
      T.XmlName("groupIpAddress"),
      T.Ec2QueryName("GroupIpAddress"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayMulticastRegisteredGroupSources",
}) as any as S.Schema<TransitGatewayMulticastRegisteredGroupSources>;
export interface RegisterTransitGatewayMulticastGroupSourcesResult {
  RegisteredMulticastGroupSources?: TransitGatewayMulticastRegisteredGroupSources;
}
export const RegisterTransitGatewayMulticastGroupSourcesResult = S.suspend(() =>
  S.Struct({
    RegisteredMulticastGroupSources: S.optional(
      TransitGatewayMulticastRegisteredGroupSources,
    )
      .pipe(
        T.XmlName("registeredMulticastGroupSources"),
        T.Ec2QueryName("RegisteredMulticastGroupSources"),
      )
      .annotate({
        identifier: "TransitGatewayMulticastRegisteredGroupSources",
      }),
  }).pipe(ns),
).annotate({
  identifier: "RegisterTransitGatewayMulticastGroupSourcesResult",
}) as any as S.Schema<RegisterTransitGatewayMulticastGroupSourcesResult>;
export interface RejectCapacityReservationBillingOwnershipRequest {
  DryRun?: boolean;
  CapacityReservationId?: string;
}
export const RejectCapacityReservationBillingOwnershipRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    CapacityReservationId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RejectCapacityReservationBillingOwnershipRequest",
}) as any as S.Schema<RejectCapacityReservationBillingOwnershipRequest>;
export interface RejectCapacityReservationBillingOwnershipResult {
  Return?: boolean;
}
export const RejectCapacityReservationBillingOwnershipResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "RejectCapacityReservationBillingOwnershipResult",
}) as any as S.Schema<RejectCapacityReservationBillingOwnershipResult>;
export interface RejectTransitGatewayMulticastDomainAssociationsRequest {
  TransitGatewayMulticastDomainId?: string;
  TransitGatewayAttachmentId?: string;
  SubnetIds?: string[];
  DryRun?: boolean;
}
export const RejectTransitGatewayMulticastDomainAssociationsRequest = S.suspend(
  () =>
    S.Struct({
      TransitGatewayMulticastDomainId: S.optional(S.String),
      TransitGatewayAttachmentId: S.optional(S.String),
      SubnetIds: S.optional(ValueStringList),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "RejectTransitGatewayMulticastDomainAssociationsRequest",
}) as any as S.Schema<RejectTransitGatewayMulticastDomainAssociationsRequest>;
export interface RejectTransitGatewayMulticastDomainAssociationsResult {
  Associations?: TransitGatewayMulticastDomainAssociations;
}
export const RejectTransitGatewayMulticastDomainAssociationsResult = S.suspend(
  () =>
    S.Struct({
      Associations: S.optional(TransitGatewayMulticastDomainAssociations)
        .pipe(T.XmlName("associations"), T.Ec2QueryName("Associations"))
        .annotate({ identifier: "TransitGatewayMulticastDomainAssociations" }),
    }).pipe(ns),
).annotate({
  identifier: "RejectTransitGatewayMulticastDomainAssociationsResult",
}) as any as S.Schema<RejectTransitGatewayMulticastDomainAssociationsResult>;
export interface RejectTransitGatewayPeeringAttachmentRequest {
  TransitGatewayAttachmentId?: string;
  DryRun?: boolean;
}
export const RejectTransitGatewayPeeringAttachmentRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RejectTransitGatewayPeeringAttachmentRequest",
}) as any as S.Schema<RejectTransitGatewayPeeringAttachmentRequest>;
export interface RejectTransitGatewayPeeringAttachmentResult {
  TransitGatewayPeeringAttachment?: TransitGatewayPeeringAttachment;
}
export const RejectTransitGatewayPeeringAttachmentResult = S.suspend(() =>
  S.Struct({
    TransitGatewayPeeringAttachment: S.optional(TransitGatewayPeeringAttachment)
      .pipe(
        T.XmlName("transitGatewayPeeringAttachment"),
        T.Ec2QueryName("TransitGatewayPeeringAttachment"),
      )
      .annotate({ identifier: "TransitGatewayPeeringAttachment" }),
  }).pipe(ns),
).annotate({
  identifier: "RejectTransitGatewayPeeringAttachmentResult",
}) as any as S.Schema<RejectTransitGatewayPeeringAttachmentResult>;
export interface RejectTransitGatewayVpcAttachmentRequest {
  TransitGatewayAttachmentId?: string;
  DryRun?: boolean;
}
export const RejectTransitGatewayVpcAttachmentRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayAttachmentId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RejectTransitGatewayVpcAttachmentRequest",
}) as any as S.Schema<RejectTransitGatewayVpcAttachmentRequest>;
export interface RejectTransitGatewayVpcAttachmentResult {
  TransitGatewayVpcAttachment?: TransitGatewayVpcAttachment;
}
export const RejectTransitGatewayVpcAttachmentResult = S.suspend(() =>
  S.Struct({
    TransitGatewayVpcAttachment: S.optional(TransitGatewayVpcAttachment)
      .pipe(
        T.XmlName("transitGatewayVpcAttachment"),
        T.Ec2QueryName("TransitGatewayVpcAttachment"),
      )
      .annotate({ identifier: "TransitGatewayVpcAttachment" }),
  }).pipe(ns),
).annotate({
  identifier: "RejectTransitGatewayVpcAttachmentResult",
}) as any as S.Schema<RejectTransitGatewayVpcAttachmentResult>;
export interface RejectVpcEndpointConnectionsRequest {
  DryRun?: boolean;
  ServiceId?: string;
  VpcEndpointIds?: string[];
}
export const RejectVpcEndpointConnectionsRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    ServiceId: S.optional(S.String),
    VpcEndpointIds: S.optional(VpcEndpointIdList).pipe(
      T.XmlName("VpcEndpointId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RejectVpcEndpointConnectionsRequest",
}) as any as S.Schema<RejectVpcEndpointConnectionsRequest>;
export interface RejectVpcEndpointConnectionsResult {
  Unsuccessful?: UnsuccessfulItem[];
}
export const RejectVpcEndpointConnectionsResult = S.suspend(() =>
  S.Struct({
    Unsuccessful: S.optional(UnsuccessfulItemSet).pipe(
      T.XmlName("unsuccessful"),
      T.Ec2QueryName("Unsuccessful"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "RejectVpcEndpointConnectionsResult",
}) as any as S.Schema<RejectVpcEndpointConnectionsResult>;
export interface RejectVpcPeeringConnectionRequest {
  DryRun?: boolean;
  VpcPeeringConnectionId?: string;
}
export const RejectVpcPeeringConnectionRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    VpcPeeringConnectionId: S.optional(S.String).pipe(
      T.XmlName("vpcPeeringConnectionId"),
      T.Ec2QueryName("VpcPeeringConnectionId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RejectVpcPeeringConnectionRequest",
}) as any as S.Schema<RejectVpcPeeringConnectionRequest>;
export interface RejectVpcPeeringConnectionResult {
  Return?: boolean;
}
export const RejectVpcPeeringConnectionResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "RejectVpcPeeringConnectionResult",
}) as any as S.Schema<RejectVpcPeeringConnectionResult>;
export interface ReleaseAddressRequest {
  AllocationId?: string;
  PublicIp?: string;
  NetworkBorderGroup?: string;
  DryRun?: boolean;
}
export const ReleaseAddressRequest = S.suspend(() =>
  S.Struct({
    AllocationId: S.optional(S.String),
    PublicIp: S.optional(S.String),
    NetworkBorderGroup: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ReleaseAddressRequest",
}) as any as S.Schema<ReleaseAddressRequest>;
export interface ReleaseAddressResponse {}
export const ReleaseAddressResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "ReleaseAddressResponse",
}) as any as S.Schema<ReleaseAddressResponse>;
export interface ReleaseHostsRequest {
  HostIds?: string[];
}
export const ReleaseHostsRequest = S.suspend(() =>
  S.Struct({
    HostIds: S.optional(RequestHostIdList).pipe(
      T.XmlName("hostId"),
      T.Ec2QueryName("HostId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ReleaseHostsRequest",
}) as any as S.Schema<ReleaseHostsRequest>;
export interface ReleaseHostsResult {
  Successful?: string[];
  Unsuccessful?: UnsuccessfulItem[];
}
export const ReleaseHostsResult = S.suspend(() =>
  S.Struct({
    Successful: S.optional(ResponseHostIdList).pipe(
      T.XmlName("successful"),
      T.Ec2QueryName("Successful"),
    ),
    Unsuccessful: S.optional(UnsuccessfulItemList).pipe(
      T.XmlName("unsuccessful"),
      T.Ec2QueryName("Unsuccessful"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ReleaseHostsResult",
}) as any as S.Schema<ReleaseHostsResult>;
export interface ReleaseIpamPoolAllocationRequest {
  DryRun?: boolean;
  IpamPoolId?: string;
  Cidr?: string;
  IpamPoolAllocationId?: string;
}
export const ReleaseIpamPoolAllocationRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    IpamPoolId: S.optional(S.String),
    Cidr: S.optional(S.String),
    IpamPoolAllocationId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ReleaseIpamPoolAllocationRequest",
}) as any as S.Schema<ReleaseIpamPoolAllocationRequest>;
export interface ReleaseIpamPoolAllocationResult {
  Success?: boolean;
}
export const ReleaseIpamPoolAllocationResult = S.suspend(() =>
  S.Struct({
    Success: S.optional(S.Boolean).pipe(
      T.XmlName("success"),
      T.Ec2QueryName("Success"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ReleaseIpamPoolAllocationResult",
}) as any as S.Schema<ReleaseIpamPoolAllocationResult>;
export interface ReplaceIamInstanceProfileAssociationRequest {
  IamInstanceProfile?: IamInstanceProfileSpecification;
  AssociationId?: string;
}
export const ReplaceIamInstanceProfileAssociationRequest = S.suspend(() =>
  S.Struct({
    IamInstanceProfile: S.optional(IamInstanceProfileSpecification),
    AssociationId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ReplaceIamInstanceProfileAssociationRequest",
}) as any as S.Schema<ReplaceIamInstanceProfileAssociationRequest>;
export interface ReplaceIamInstanceProfileAssociationResult {
  IamInstanceProfileAssociation?: IamInstanceProfileAssociation;
}
export const ReplaceIamInstanceProfileAssociationResult = S.suspend(() =>
  S.Struct({
    IamInstanceProfileAssociation: S.optional(IamInstanceProfileAssociation)
      .pipe(
        T.XmlName("iamInstanceProfileAssociation"),
        T.Ec2QueryName("IamInstanceProfileAssociation"),
      )
      .annotate({ identifier: "IamInstanceProfileAssociation" }),
  }).pipe(ns),
).annotate({
  identifier: "ReplaceIamInstanceProfileAssociationResult",
}) as any as S.Schema<ReplaceIamInstanceProfileAssociationResult>;
export type ImageProviderRequestList = string[];
export const ImageProviderRequestList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export type MarketplaceProductCodeRequestList = string[];
export const MarketplaceProductCodeRequestList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export type ImageNameRequestList = string[];
export const ImageNameRequestList = S.Array(S.String.pipe(T.XmlName("item")));
export interface DeprecationTimeConditionRequest {
  MaximumDaysSinceDeprecated?: number;
}
export const DeprecationTimeConditionRequest = S.suspend(() =>
  S.Struct({ MaximumDaysSinceDeprecated: S.optional(S.Number) }),
).annotate({
  identifier: "DeprecationTimeConditionRequest",
}) as any as S.Schema<DeprecationTimeConditionRequest>;
export interface CreationDateConditionRequest {
  MaximumDaysSinceCreated?: number;
}
export const CreationDateConditionRequest = S.suspend(() =>
  S.Struct({ MaximumDaysSinceCreated: S.optional(S.Number) }),
).annotate({
  identifier: "CreationDateConditionRequest",
}) as any as S.Schema<CreationDateConditionRequest>;
export interface ImageCriterionRequest {
  ImageProviders?: string[];
  MarketplaceProductCodes?: string[];
  ImageNames?: string[];
  DeprecationTimeCondition?: DeprecationTimeConditionRequest;
  CreationDateCondition?: CreationDateConditionRequest;
}
export const ImageCriterionRequest = S.suspend(() =>
  S.Struct({
    ImageProviders: S.optional(ImageProviderRequestList).pipe(
      T.XmlName("ImageProvider"),
    ),
    MarketplaceProductCodes: S.optional(MarketplaceProductCodeRequestList).pipe(
      T.XmlName("MarketplaceProductCode"),
    ),
    ImageNames: S.optional(ImageNameRequestList).pipe(T.XmlName("ImageName")),
    DeprecationTimeCondition: S.optional(DeprecationTimeConditionRequest),
    CreationDateCondition: S.optional(CreationDateConditionRequest),
  }),
).annotate({
  identifier: "ImageCriterionRequest",
}) as any as S.Schema<ImageCriterionRequest>;
export type ImageCriterionRequestList = ImageCriterionRequest[];
export const ImageCriterionRequestList = S.Array(
  ImageCriterionRequest.pipe(T.XmlName("ImageCriterion")).annotate({
    identifier: "ImageCriterionRequest",
  }),
);
export interface ReplaceImageCriteriaInAllowedImagesSettingsRequest {
  ImageCriteria?: ImageCriterionRequest[];
  DryRun?: boolean;
}
export const ReplaceImageCriteriaInAllowedImagesSettingsRequest = S.suspend(
  () =>
    S.Struct({
      ImageCriteria: S.optional(ImageCriterionRequestList).pipe(
        T.XmlName("ImageCriterion"),
      ),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "ReplaceImageCriteriaInAllowedImagesSettingsRequest",
}) as any as S.Schema<ReplaceImageCriteriaInAllowedImagesSettingsRequest>;
export interface ReplaceImageCriteriaInAllowedImagesSettingsResult {
  ReturnValue?: boolean;
}
export const ReplaceImageCriteriaInAllowedImagesSettingsResult = S.suspend(() =>
  S.Struct({
    ReturnValue: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ReplaceImageCriteriaInAllowedImagesSettingsResult",
}) as any as S.Schema<ReplaceImageCriteriaInAllowedImagesSettingsResult>;
export interface ReplaceNetworkAclAssociationRequest {
  DryRun?: boolean;
  AssociationId?: string;
  NetworkAclId?: string;
}
export const ReplaceNetworkAclAssociationRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
    NetworkAclId: S.optional(S.String).pipe(
      T.XmlName("networkAclId"),
      T.Ec2QueryName("NetworkAclId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ReplaceNetworkAclAssociationRequest",
}) as any as S.Schema<ReplaceNetworkAclAssociationRequest>;
export interface ReplaceNetworkAclAssociationResult {
  NewAssociationId?: string;
}
export const ReplaceNetworkAclAssociationResult = S.suspend(() =>
  S.Struct({
    NewAssociationId: S.optional(S.String).pipe(
      T.XmlName("newAssociationId"),
      T.Ec2QueryName("NewAssociationId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ReplaceNetworkAclAssociationResult",
}) as any as S.Schema<ReplaceNetworkAclAssociationResult>;
export interface ReplaceNetworkAclEntryRequest {
  DryRun?: boolean;
  NetworkAclId?: string;
  RuleNumber?: number;
  Protocol?: string;
  RuleAction?: RuleAction;
  Egress?: boolean;
  CidrBlock?: string;
  Ipv6CidrBlock?: string;
  IcmpTypeCode?: IcmpTypeCode;
  PortRange?: PortRange;
}
export const ReplaceNetworkAclEntryRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    NetworkAclId: S.optional(S.String).pipe(
      T.XmlName("networkAclId"),
      T.Ec2QueryName("NetworkAclId"),
    ),
    RuleNumber: S.optional(S.Number).pipe(
      T.XmlName("ruleNumber"),
      T.Ec2QueryName("RuleNumber"),
    ),
    Protocol: S.optional(S.String).pipe(
      T.XmlName("protocol"),
      T.Ec2QueryName("Protocol"),
    ),
    RuleAction: S.optional(RuleAction).pipe(
      T.XmlName("ruleAction"),
      T.Ec2QueryName("RuleAction"),
    ),
    Egress: S.optional(S.Boolean).pipe(
      T.XmlName("egress"),
      T.Ec2QueryName("Egress"),
    ),
    CidrBlock: S.optional(S.String).pipe(
      T.XmlName("cidrBlock"),
      T.Ec2QueryName("CidrBlock"),
    ),
    Ipv6CidrBlock: S.optional(S.String).pipe(
      T.XmlName("ipv6CidrBlock"),
      T.Ec2QueryName("Ipv6CidrBlock"),
    ),
    IcmpTypeCode: S.optional(IcmpTypeCode)
      .pipe(T.XmlName("Icmp"))
      .annotate({ identifier: "IcmpTypeCode" }),
    PortRange: S.optional(PortRange)
      .pipe(T.XmlName("portRange"), T.Ec2QueryName("PortRange"))
      .annotate({ identifier: "PortRange" }),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ReplaceNetworkAclEntryRequest",
}) as any as S.Schema<ReplaceNetworkAclEntryRequest>;
export interface ReplaceNetworkAclEntryResponse {}
export const ReplaceNetworkAclEntryResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "ReplaceNetworkAclEntryResponse",
}) as any as S.Schema<ReplaceNetworkAclEntryResponse>;
export interface ReplaceRouteRequest {
  DestinationPrefixListId?: string;
  VpcEndpointId?: string;
  LocalTarget?: boolean;
  TransitGatewayId?: string;
  LocalGatewayId?: string;
  CarrierGatewayId?: string;
  CoreNetworkArn?: string;
  OdbNetworkArn?: string;
  DryRun?: boolean;
  RouteTableId?: string;
  DestinationCidrBlock?: string;
  GatewayId?: string;
  DestinationIpv6CidrBlock?: string;
  EgressOnlyInternetGatewayId?: string;
  InstanceId?: string;
  NetworkInterfaceId?: string;
  VpcPeeringConnectionId?: string;
  NatGatewayId?: string;
}
export const ReplaceRouteRequest = S.suspend(() =>
  S.Struct({
    DestinationPrefixListId: S.optional(S.String),
    VpcEndpointId: S.optional(S.String),
    LocalTarget: S.optional(S.Boolean),
    TransitGatewayId: S.optional(S.String),
    LocalGatewayId: S.optional(S.String),
    CarrierGatewayId: S.optional(S.String),
    CoreNetworkArn: S.optional(S.String),
    OdbNetworkArn: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    RouteTableId: S.optional(S.String).pipe(
      T.XmlName("routeTableId"),
      T.Ec2QueryName("RouteTableId"),
    ),
    DestinationCidrBlock: S.optional(S.String).pipe(
      T.XmlName("destinationCidrBlock"),
      T.Ec2QueryName("DestinationCidrBlock"),
    ),
    GatewayId: S.optional(S.String).pipe(
      T.XmlName("gatewayId"),
      T.Ec2QueryName("GatewayId"),
    ),
    DestinationIpv6CidrBlock: S.optional(S.String).pipe(
      T.XmlName("destinationIpv6CidrBlock"),
      T.Ec2QueryName("DestinationIpv6CidrBlock"),
    ),
    EgressOnlyInternetGatewayId: S.optional(S.String).pipe(
      T.XmlName("egressOnlyInternetGatewayId"),
      T.Ec2QueryName("EgressOnlyInternetGatewayId"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    VpcPeeringConnectionId: S.optional(S.String).pipe(
      T.XmlName("vpcPeeringConnectionId"),
      T.Ec2QueryName("VpcPeeringConnectionId"),
    ),
    NatGatewayId: S.optional(S.String).pipe(
      T.XmlName("natGatewayId"),
      T.Ec2QueryName("NatGatewayId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ReplaceRouteRequest",
}) as any as S.Schema<ReplaceRouteRequest>;
export interface ReplaceRouteResponse {}
export const ReplaceRouteResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "ReplaceRouteResponse",
}) as any as S.Schema<ReplaceRouteResponse>;
export interface ReplaceRouteTableAssociationRequest {
  DryRun?: boolean;
  AssociationId?: string;
  RouteTableId?: string;
}
export const ReplaceRouteTableAssociationRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    AssociationId: S.optional(S.String).pipe(
      T.XmlName("associationId"),
      T.Ec2QueryName("AssociationId"),
    ),
    RouteTableId: S.optional(S.String).pipe(
      T.XmlName("routeTableId"),
      T.Ec2QueryName("RouteTableId"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ReplaceRouteTableAssociationRequest",
}) as any as S.Schema<ReplaceRouteTableAssociationRequest>;
export interface ReplaceRouteTableAssociationResult {
  NewAssociationId?: string;
  AssociationState?: RouteTableAssociationState;
}
export const ReplaceRouteTableAssociationResult = S.suspend(() =>
  S.Struct({
    NewAssociationId: S.optional(S.String).pipe(
      T.XmlName("newAssociationId"),
      T.Ec2QueryName("NewAssociationId"),
    ),
    AssociationState: S.optional(RouteTableAssociationState)
      .pipe(T.XmlName("associationState"), T.Ec2QueryName("AssociationState"))
      .annotate({ identifier: "RouteTableAssociationState" }),
  }).pipe(ns),
).annotate({
  identifier: "ReplaceRouteTableAssociationResult",
}) as any as S.Schema<ReplaceRouteTableAssociationResult>;
export interface ReplaceTransitGatewayRouteRequest {
  DestinationCidrBlock?: string;
  TransitGatewayRouteTableId?: string;
  TransitGatewayAttachmentId?: string;
  Blackhole?: boolean;
  DryRun?: boolean;
}
export const ReplaceTransitGatewayRouteRequest = S.suspend(() =>
  S.Struct({
    DestinationCidrBlock: S.optional(S.String),
    TransitGatewayRouteTableId: S.optional(S.String),
    TransitGatewayAttachmentId: S.optional(S.String),
    Blackhole: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ReplaceTransitGatewayRouteRequest",
}) as any as S.Schema<ReplaceTransitGatewayRouteRequest>;
export interface ReplaceTransitGatewayRouteResult {
  Route?: TransitGatewayRoute;
}
export const ReplaceTransitGatewayRouteResult = S.suspend(() =>
  S.Struct({
    Route: S.optional(TransitGatewayRoute)
      .pipe(T.XmlName("route"), T.Ec2QueryName("Route"))
      .annotate({ identifier: "TransitGatewayRoute" }),
  }).pipe(ns),
).annotate({
  identifier: "ReplaceTransitGatewayRouteResult",
}) as any as S.Schema<ReplaceTransitGatewayRouteResult>;
export interface ReplaceVpnTunnelRequest {
  VpnConnectionId?: string;
  VpnTunnelOutsideIpAddress?: string;
  ApplyPendingMaintenance?: boolean;
  DryRun?: boolean;
}
export const ReplaceVpnTunnelRequest = S.suspend(() =>
  S.Struct({
    VpnConnectionId: S.optional(S.String),
    VpnTunnelOutsideIpAddress: S.optional(S.String),
    ApplyPendingMaintenance: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ReplaceVpnTunnelRequest",
}) as any as S.Schema<ReplaceVpnTunnelRequest>;
export interface ReplaceVpnTunnelResult {
  Return?: boolean;
}
export const ReplaceVpnTunnelResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ReplaceVpnTunnelResult",
}) as any as S.Schema<ReplaceVpnTunnelResult>;
export type ReportStatusType = "ok" | "impaired" | (string & {});
export const ReportStatusType = S.String;
export type ReportInstanceReasonCodes =
  | "instance-stuck-in-state"
  | "unresponsive"
  | "not-accepting-credentials"
  | "password-not-available"
  | "performance-network"
  | "performance-instance-store"
  | "performance-ebs-volume"
  | "performance-other"
  | "other"
  | (string & {});
export const ReportInstanceReasonCodes = S.String;
export type ReasonCodesList = ReportInstanceReasonCodes[];
export const ReasonCodesList = S.Array(
  ReportInstanceReasonCodes.pipe(T.XmlName("item")),
);
export interface ReportInstanceStatusRequest {
  DryRun?: boolean;
  Instances?: string[];
  Status?: ReportStatusType;
  StartTime?: Date;
  EndTime?: Date;
  ReasonCodes?: ReportInstanceReasonCodes[];
  Description?: string | redacted.Redacted<string>;
}
export const ReportInstanceStatusRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Instances: S.optional(InstanceIdStringList).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    Status: S.optional(ReportStatusType).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startTime"), T.Ec2QueryName("StartTime")),
    EndTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("endTime"), T.Ec2QueryName("EndTime")),
    ReasonCodes: S.optional(ReasonCodesList).pipe(
      T.XmlName("reasonCode"),
      T.Ec2QueryName("ReasonCode"),
    ),
    Description: S.optional(SensitiveString).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ReportInstanceStatusRequest",
}) as any as S.Schema<ReportInstanceStatusRequest>;
export interface ReportInstanceStatusResponse {}
export const ReportInstanceStatusResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "ReportInstanceStatusResponse",
}) as any as S.Schema<ReportInstanceStatusResponse>;
export interface RequestSpotFleetRequest {
  DryRun?: boolean;
  SpotFleetRequestConfig?: SpotFleetRequestConfigData;
}
export const RequestSpotFleetRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    SpotFleetRequestConfig: S.optional(SpotFleetRequestConfigData)
      .pipe(
        T.XmlName("spotFleetRequestConfig"),
        T.Ec2QueryName("SpotFleetRequestConfig"),
      )
      .annotate({ identifier: "SpotFleetRequestConfigData" }),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RequestSpotFleetRequest",
}) as any as S.Schema<RequestSpotFleetRequest>;
export interface RequestSpotFleetResponse {
  SpotFleetRequestId?: string;
}
export const RequestSpotFleetResponse = S.suspend(() =>
  S.Struct({
    SpotFleetRequestId: S.optional(S.String).pipe(
      T.XmlName("spotFleetRequestId"),
      T.Ec2QueryName("SpotFleetRequestId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "RequestSpotFleetResponse",
}) as any as S.Schema<RequestSpotFleetResponse>;
export type RequestSpotLaunchSpecificationSecurityGroupIdList = string[];
export const RequestSpotLaunchSpecificationSecurityGroupIdList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export type RequestSpotLaunchSpecificationSecurityGroupList = string[];
export const RequestSpotLaunchSpecificationSecurityGroupList = S.Array(
  S.String.pipe(T.XmlName("item")),
);
export interface RequestSpotLaunchSpecification {
  SecurityGroupIds?: string[];
  SecurityGroups?: string[];
  AddressingType?: string;
  BlockDeviceMappings?: BlockDeviceMapping[];
  EbsOptimized?: boolean;
  IamInstanceProfile?: IamInstanceProfileSpecification;
  ImageId?: string;
  InstanceType?: InstanceType;
  KernelId?: string;
  KeyName?: string;
  Monitoring?: RunInstancesMonitoringEnabled;
  NetworkInterfaces?: InstanceNetworkInterfaceSpecification[];
  Placement?: SpotPlacement;
  RamdiskId?: string;
  SubnetId?: string;
  UserData?: string | redacted.Redacted<string>;
}
export const RequestSpotLaunchSpecification = S.suspend(() =>
  S.Struct({
    SecurityGroupIds: S.optional(
      RequestSpotLaunchSpecificationSecurityGroupIdList,
    ).pipe(T.XmlName("SecurityGroupId")),
    SecurityGroups: S.optional(
      RequestSpotLaunchSpecificationSecurityGroupList,
    ).pipe(T.XmlName("SecurityGroup")),
    AddressingType: S.optional(S.String).pipe(
      T.XmlName("addressingType"),
      T.Ec2QueryName("AddressingType"),
    ),
    BlockDeviceMappings: S.optional(BlockDeviceMappingList).pipe(
      T.XmlName("blockDeviceMapping"),
      T.Ec2QueryName("BlockDeviceMapping"),
    ),
    EbsOptimized: S.optional(S.Boolean).pipe(
      T.XmlName("ebsOptimized"),
      T.Ec2QueryName("EbsOptimized"),
    ),
    IamInstanceProfile: S.optional(IamInstanceProfileSpecification)
      .pipe(
        T.XmlName("iamInstanceProfile"),
        T.Ec2QueryName("IamInstanceProfile"),
      )
      .annotate({ identifier: "IamInstanceProfileSpecification" }),
    ImageId: S.optional(S.String).pipe(
      T.XmlName("imageId"),
      T.Ec2QueryName("ImageId"),
    ),
    InstanceType: S.optional(InstanceType).pipe(
      T.XmlName("instanceType"),
      T.Ec2QueryName("InstanceType"),
    ),
    KernelId: S.optional(S.String).pipe(
      T.XmlName("kernelId"),
      T.Ec2QueryName("KernelId"),
    ),
    KeyName: S.optional(S.String).pipe(
      T.XmlName("keyName"),
      T.Ec2QueryName("KeyName"),
    ),
    Monitoring: S.optional(RunInstancesMonitoringEnabled)
      .pipe(T.XmlName("monitoring"), T.Ec2QueryName("Monitoring"))
      .annotate({ identifier: "RunInstancesMonitoringEnabled" }),
    NetworkInterfaces: S.optional(
      InstanceNetworkInterfaceSpecificationList,
    ).pipe(T.XmlName("NetworkInterface")),
    Placement: S.optional(SpotPlacement)
      .pipe(T.XmlName("placement"), T.Ec2QueryName("Placement"))
      .annotate({ identifier: "SpotPlacement" }),
    RamdiskId: S.optional(S.String).pipe(
      T.XmlName("ramdiskId"),
      T.Ec2QueryName("RamdiskId"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    UserData: S.optional(SensitiveString).pipe(
      T.XmlName("userData"),
      T.Ec2QueryName("UserData"),
    ),
  }),
).annotate({
  identifier: "RequestSpotLaunchSpecification",
}) as any as S.Schema<RequestSpotLaunchSpecification>;
export interface RequestSpotInstancesRequest {
  LaunchSpecification?: RequestSpotLaunchSpecification;
  TagSpecifications?: TagSpecification[];
  InstanceInterruptionBehavior?: InstanceInterruptionBehavior;
  DryRun?: boolean;
  SpotPrice?: string;
  ClientToken?: string;
  InstanceCount?: number;
  Type?: SpotInstanceType;
  ValidFrom?: Date;
  ValidUntil?: Date;
  LaunchGroup?: string;
  AvailabilityZoneGroup?: string;
  BlockDurationMinutes?: number;
}
export const RequestSpotInstancesRequest = S.suspend(() =>
  S.Struct({
    LaunchSpecification: S.optional(RequestSpotLaunchSpecification),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    InstanceInterruptionBehavior: S.optional(InstanceInterruptionBehavior),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    SpotPrice: S.optional(S.String).pipe(
      T.XmlName("spotPrice"),
      T.Ec2QueryName("SpotPrice"),
    ),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.Ec2QueryName("ClientToken"),
    ),
    InstanceCount: S.optional(S.Number).pipe(
      T.XmlName("instanceCount"),
      T.Ec2QueryName("InstanceCount"),
    ),
    Type: S.optional(SpotInstanceType).pipe(
      T.XmlName("type"),
      T.Ec2QueryName("Type"),
    ),
    ValidFrom: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("validFrom"), T.Ec2QueryName("ValidFrom")),
    ValidUntil: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("validUntil"), T.Ec2QueryName("ValidUntil")),
    LaunchGroup: S.optional(S.String).pipe(
      T.XmlName("launchGroup"),
      T.Ec2QueryName("LaunchGroup"),
    ),
    AvailabilityZoneGroup: S.optional(S.String).pipe(
      T.XmlName("availabilityZoneGroup"),
      T.Ec2QueryName("AvailabilityZoneGroup"),
    ),
    BlockDurationMinutes: S.optional(S.Number).pipe(
      T.XmlName("blockDurationMinutes"),
      T.Ec2QueryName("BlockDurationMinutes"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RequestSpotInstancesRequest",
}) as any as S.Schema<RequestSpotInstancesRequest>;
export interface RequestSpotInstancesResult {
  SpotInstanceRequests?: (SpotInstanceRequest & {
    LaunchSpecification: LaunchSpecification & {
      Monitoring: RunInstancesMonitoringEnabled & { Enabled: boolean };
    };
  })[];
}
export const RequestSpotInstancesResult = S.suspend(() =>
  S.Struct({
    SpotInstanceRequests: S.optional(SpotInstanceRequestList).pipe(
      T.XmlName("spotInstanceRequestSet"),
      T.Ec2QueryName("SpotInstanceRequestSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "RequestSpotInstancesResult",
}) as any as S.Schema<RequestSpotInstancesResult>;
export interface ResetAddressAttributeRequest {
  AllocationId?: string;
  Attribute?: AddressAttributeName;
  DryRun?: boolean;
}
export const ResetAddressAttributeRequest = S.suspend(() =>
  S.Struct({
    AllocationId: S.optional(S.String),
    Attribute: S.optional(AddressAttributeName),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ResetAddressAttributeRequest",
}) as any as S.Schema<ResetAddressAttributeRequest>;
export interface ResetAddressAttributeResult {
  Address?: AddressAttribute;
}
export const ResetAddressAttributeResult = S.suspend(() =>
  S.Struct({
    Address: S.optional(AddressAttribute)
      .pipe(T.XmlName("address"), T.Ec2QueryName("Address"))
      .annotate({ identifier: "AddressAttribute" }),
  }).pipe(ns),
).annotate({
  identifier: "ResetAddressAttributeResult",
}) as any as S.Schema<ResetAddressAttributeResult>;
export interface ResetEbsDefaultKmsKeyIdRequest {
  DryRun?: boolean;
}
export const ResetEbsDefaultKmsKeyIdRequest = S.suspend(() =>
  S.Struct({ DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ResetEbsDefaultKmsKeyIdRequest",
}) as any as S.Schema<ResetEbsDefaultKmsKeyIdRequest>;
export interface ResetEbsDefaultKmsKeyIdResult {
  KmsKeyId?: string;
}
export const ResetEbsDefaultKmsKeyIdResult = S.suspend(() =>
  S.Struct({
    KmsKeyId: S.optional(S.String).pipe(
      T.XmlName("kmsKeyId"),
      T.Ec2QueryName("KmsKeyId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ResetEbsDefaultKmsKeyIdResult",
}) as any as S.Schema<ResetEbsDefaultKmsKeyIdResult>;
export type ResetFpgaImageAttributeName = "loadPermission" | (string & {});
export const ResetFpgaImageAttributeName = S.String;
export interface ResetFpgaImageAttributeRequest {
  DryRun?: boolean;
  FpgaImageId?: string;
  Attribute?: ResetFpgaImageAttributeName;
}
export const ResetFpgaImageAttributeRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    FpgaImageId: S.optional(S.String),
    Attribute: S.optional(ResetFpgaImageAttributeName),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ResetFpgaImageAttributeRequest",
}) as any as S.Schema<ResetFpgaImageAttributeRequest>;
export interface ResetFpgaImageAttributeResult {
  Return?: boolean;
}
export const ResetFpgaImageAttributeResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "ResetFpgaImageAttributeResult",
}) as any as S.Schema<ResetFpgaImageAttributeResult>;
export type ResetImageAttributeName = "launchPermission" | (string & {});
export const ResetImageAttributeName = S.String;
export interface ResetImageAttributeRequest {
  Attribute?: ResetImageAttributeName;
  ImageId?: string;
  DryRun?: boolean;
}
export const ResetImageAttributeRequest = S.suspend(() =>
  S.Struct({
    Attribute: S.optional(ResetImageAttributeName),
    ImageId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ResetImageAttributeRequest",
}) as any as S.Schema<ResetImageAttributeRequest>;
export interface ResetImageAttributeResponse {}
export const ResetImageAttributeResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "ResetImageAttributeResponse",
}) as any as S.Schema<ResetImageAttributeResponse>;
export interface ResetInstanceAttributeRequest {
  DryRun?: boolean;
  InstanceId?: string;
  Attribute?: InstanceAttributeName;
}
export const ResetInstanceAttributeRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    Attribute: S.optional(InstanceAttributeName).pipe(
      T.XmlName("attribute"),
      T.Ec2QueryName("Attribute"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ResetInstanceAttributeRequest",
}) as any as S.Schema<ResetInstanceAttributeRequest>;
export interface ResetInstanceAttributeResponse {}
export const ResetInstanceAttributeResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "ResetInstanceAttributeResponse",
}) as any as S.Schema<ResetInstanceAttributeResponse>;
export interface ResetNetworkInterfaceAttributeRequest {
  DryRun?: boolean;
  NetworkInterfaceId?: string;
  SourceDestCheck?: string;
}
export const ResetNetworkInterfaceAttributeRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    SourceDestCheck: S.optional(S.String).pipe(
      T.XmlName("sourceDestCheck"),
      T.Ec2QueryName("SourceDestCheck"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ResetNetworkInterfaceAttributeRequest",
}) as any as S.Schema<ResetNetworkInterfaceAttributeRequest>;
export interface ResetNetworkInterfaceAttributeResponse {}
export const ResetNetworkInterfaceAttributeResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "ResetNetworkInterfaceAttributeResponse",
}) as any as S.Schema<ResetNetworkInterfaceAttributeResponse>;
export interface ResetSnapshotAttributeRequest {
  Attribute?: SnapshotAttributeName;
  SnapshotId?: string;
  DryRun?: boolean;
}
export const ResetSnapshotAttributeRequest = S.suspend(() =>
  S.Struct({
    Attribute: S.optional(SnapshotAttributeName),
    SnapshotId: S.optional(S.String),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ResetSnapshotAttributeRequest",
}) as any as S.Schema<ResetSnapshotAttributeRequest>;
export interface ResetSnapshotAttributeResponse {}
export const ResetSnapshotAttributeResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "ResetSnapshotAttributeResponse",
}) as any as S.Schema<ResetSnapshotAttributeResponse>;
export interface RestoreAddressToClassicRequest {
  DryRun?: boolean;
  PublicIp?: string;
}
export const RestoreAddressToClassicRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    PublicIp: S.optional(S.String).pipe(
      T.XmlName("publicIp"),
      T.Ec2QueryName("PublicIp"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RestoreAddressToClassicRequest",
}) as any as S.Schema<RestoreAddressToClassicRequest>;
export interface RestoreAddressToClassicResult {
  PublicIp?: string;
  Status?: Status;
}
export const RestoreAddressToClassicResult = S.suspend(() =>
  S.Struct({
    PublicIp: S.optional(S.String).pipe(
      T.XmlName("publicIp"),
      T.Ec2QueryName("PublicIp"),
    ),
    Status: S.optional(Status).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "RestoreAddressToClassicResult",
}) as any as S.Schema<RestoreAddressToClassicResult>;
export interface RestoreImageFromRecycleBinRequest {
  ImageId?: string;
  DryRun?: boolean;
}
export const RestoreImageFromRecycleBinRequest = S.suspend(() =>
  S.Struct({
    ImageId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RestoreImageFromRecycleBinRequest",
}) as any as S.Schema<RestoreImageFromRecycleBinRequest>;
export interface RestoreImageFromRecycleBinResult {
  Return?: boolean;
}
export const RestoreImageFromRecycleBinResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "RestoreImageFromRecycleBinResult",
}) as any as S.Schema<RestoreImageFromRecycleBinResult>;
export interface RestoreManagedPrefixListVersionRequest {
  DryRun?: boolean;
  PrefixListId?: string;
  PreviousVersion?: number;
  CurrentVersion?: number;
}
export const RestoreManagedPrefixListVersionRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    PrefixListId: S.optional(S.String),
    PreviousVersion: S.optional(S.Number),
    CurrentVersion: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RestoreManagedPrefixListVersionRequest",
}) as any as S.Schema<RestoreManagedPrefixListVersionRequest>;
export interface RestoreManagedPrefixListVersionResult {
  PrefixList?: ManagedPrefixList;
}
export const RestoreManagedPrefixListVersionResult = S.suspend(() =>
  S.Struct({
    PrefixList: S.optional(ManagedPrefixList)
      .pipe(T.XmlName("prefixList"), T.Ec2QueryName("PrefixList"))
      .annotate({ identifier: "ManagedPrefixList" }),
  }).pipe(ns),
).annotate({
  identifier: "RestoreManagedPrefixListVersionResult",
}) as any as S.Schema<RestoreManagedPrefixListVersionResult>;
export interface RestoreSnapshotFromRecycleBinRequest {
  SnapshotId?: string;
  DryRun?: boolean;
}
export const RestoreSnapshotFromRecycleBinRequest = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RestoreSnapshotFromRecycleBinRequest",
}) as any as S.Schema<RestoreSnapshotFromRecycleBinRequest>;
export interface RestoreSnapshotFromRecycleBinResult {
  SnapshotId?: string;
  OutpostArn?: string;
  Description?: string;
  Encrypted?: boolean;
  OwnerId?: string;
  Progress?: string;
  StartTime?: Date;
  State?: SnapshotState;
  VolumeId?: string;
  VolumeSize?: number;
  SseType?: SSEType;
}
export const RestoreSnapshotFromRecycleBinResult = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    OutpostArn: S.optional(S.String).pipe(
      T.XmlName("outpostArn"),
      T.Ec2QueryName("OutpostArn"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
    Encrypted: S.optional(S.Boolean).pipe(
      T.XmlName("encrypted"),
      T.Ec2QueryName("Encrypted"),
    ),
    OwnerId: S.optional(S.String).pipe(
      T.XmlName("ownerId"),
      T.Ec2QueryName("OwnerId"),
    ),
    Progress: S.optional(S.String).pipe(
      T.XmlName("progress"),
      T.Ec2QueryName("Progress"),
    ),
    StartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("startTime"), T.Ec2QueryName("StartTime")),
    State: S.optional(SnapshotState).pipe(
      T.XmlName("status"),
      T.Ec2QueryName("Status"),
    ),
    VolumeId: S.optional(S.String).pipe(
      T.XmlName("volumeId"),
      T.Ec2QueryName("VolumeId"),
    ),
    VolumeSize: S.optional(S.Number).pipe(
      T.XmlName("volumeSize"),
      T.Ec2QueryName("VolumeSize"),
    ),
    SseType: S.optional(SSEType).pipe(
      T.XmlName("sseType"),
      T.Ec2QueryName("SseType"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "RestoreSnapshotFromRecycleBinResult",
}) as any as S.Schema<RestoreSnapshotFromRecycleBinResult>;
export interface RestoreSnapshotTierRequest {
  SnapshotId?: string;
  TemporaryRestoreDays?: number;
  PermanentRestore?: boolean;
  DryRun?: boolean;
}
export const RestoreSnapshotTierRequest = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String),
    TemporaryRestoreDays: S.optional(S.Number),
    PermanentRestore: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RestoreSnapshotTierRequest",
}) as any as S.Schema<RestoreSnapshotTierRequest>;
export interface RestoreSnapshotTierResult {
  SnapshotId?: string;
  RestoreStartTime?: Date;
  RestoreDuration?: number;
  IsPermanentRestore?: boolean;
}
export const RestoreSnapshotTierResult = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
    RestoreStartTime: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ).pipe(T.XmlName("restoreStartTime"), T.Ec2QueryName("RestoreStartTime")),
    RestoreDuration: S.optional(S.Number).pipe(
      T.XmlName("restoreDuration"),
      T.Ec2QueryName("RestoreDuration"),
    ),
    IsPermanentRestore: S.optional(S.Boolean).pipe(
      T.XmlName("isPermanentRestore"),
      T.Ec2QueryName("IsPermanentRestore"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "RestoreSnapshotTierResult",
}) as any as S.Schema<RestoreSnapshotTierResult>;
export interface RestoreVolumeFromRecycleBinRequest {
  VolumeId?: string;
  DryRun?: boolean;
}
export const RestoreVolumeFromRecycleBinRequest = S.suspend(() =>
  S.Struct({
    VolumeId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RestoreVolumeFromRecycleBinRequest",
}) as any as S.Schema<RestoreVolumeFromRecycleBinRequest>;
export interface RestoreVolumeFromRecycleBinResult {
  Return?: boolean;
}
export const RestoreVolumeFromRecycleBinResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "RestoreVolumeFromRecycleBinResult",
}) as any as S.Schema<RestoreVolumeFromRecycleBinResult>;
export interface RevokeClientVpnIngressRequest {
  ClientVpnEndpointId?: string;
  TargetNetworkCidr?: string;
  AccessGroupId?: string;
  RevokeAllGroups?: boolean;
  DryRun?: boolean;
}
export const RevokeClientVpnIngressRequest = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String),
    TargetNetworkCidr: S.optional(S.String),
    AccessGroupId: S.optional(S.String),
    RevokeAllGroups: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RevokeClientVpnIngressRequest",
}) as any as S.Schema<RevokeClientVpnIngressRequest>;
export interface RevokeClientVpnIngressResult {
  Status?: ClientVpnAuthorizationRuleStatus;
}
export const RevokeClientVpnIngressResult = S.suspend(() =>
  S.Struct({
    Status: S.optional(ClientVpnAuthorizationRuleStatus)
      .pipe(T.XmlName("status"), T.Ec2QueryName("Status"))
      .annotate({ identifier: "ClientVpnAuthorizationRuleStatus" }),
  }).pipe(ns),
).annotate({
  identifier: "RevokeClientVpnIngressResult",
}) as any as S.Schema<RevokeClientVpnIngressResult>;
export interface RevokeSecurityGroupEgressRequest {
  SecurityGroupRuleIds?: string[];
  DryRun?: boolean;
  GroupId?: string;
  SourceSecurityGroupName?: string;
  SourceSecurityGroupOwnerId?: string;
  IpProtocol?: string;
  FromPort?: number;
  ToPort?: number;
  CidrIp?: string;
  IpPermissions?: IpPermission[];
}
export const RevokeSecurityGroupEgressRequest = S.suspend(() =>
  S.Struct({
    SecurityGroupRuleIds: S.optional(SecurityGroupRuleIdList).pipe(
      T.XmlName("SecurityGroupRuleId"),
    ),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
    SourceSecurityGroupName: S.optional(S.String).pipe(
      T.XmlName("sourceSecurityGroupName"),
      T.Ec2QueryName("SourceSecurityGroupName"),
    ),
    SourceSecurityGroupOwnerId: S.optional(S.String).pipe(
      T.XmlName("sourceSecurityGroupOwnerId"),
      T.Ec2QueryName("SourceSecurityGroupOwnerId"),
    ),
    IpProtocol: S.optional(S.String).pipe(
      T.XmlName("ipProtocol"),
      T.Ec2QueryName("IpProtocol"),
    ),
    FromPort: S.optional(S.Number).pipe(
      T.XmlName("fromPort"),
      T.Ec2QueryName("FromPort"),
    ),
    ToPort: S.optional(S.Number).pipe(
      T.XmlName("toPort"),
      T.Ec2QueryName("ToPort"),
    ),
    CidrIp: S.optional(S.String).pipe(
      T.XmlName("cidrIp"),
      T.Ec2QueryName("CidrIp"),
    ),
    IpPermissions: S.optional(IpPermissionList).pipe(
      T.XmlName("ipPermissions"),
      T.Ec2QueryName("IpPermissions"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RevokeSecurityGroupEgressRequest",
}) as any as S.Schema<RevokeSecurityGroupEgressRequest>;
export interface RevokedSecurityGroupRule {
  SecurityGroupRuleId?: string;
  GroupId?: string;
  IsEgress?: boolean;
  IpProtocol?: string;
  FromPort?: number;
  ToPort?: number;
  CidrIpv4?: string;
  CidrIpv6?: string;
  PrefixListId?: string;
  ReferencedGroupId?: string;
  Description?: string;
}
export const RevokedSecurityGroupRule = S.suspend(() =>
  S.Struct({
    SecurityGroupRuleId: S.optional(S.String).pipe(
      T.XmlName("securityGroupRuleId"),
      T.Ec2QueryName("SecurityGroupRuleId"),
    ),
    GroupId: S.optional(S.String).pipe(
      T.XmlName("groupId"),
      T.Ec2QueryName("GroupId"),
    ),
    IsEgress: S.optional(S.Boolean).pipe(
      T.XmlName("isEgress"),
      T.Ec2QueryName("IsEgress"),
    ),
    IpProtocol: S.optional(S.String).pipe(
      T.XmlName("ipProtocol"),
      T.Ec2QueryName("IpProtocol"),
    ),
    FromPort: S.optional(S.Number).pipe(
      T.XmlName("fromPort"),
      T.Ec2QueryName("FromPort"),
    ),
    ToPort: S.optional(S.Number).pipe(
      T.XmlName("toPort"),
      T.Ec2QueryName("ToPort"),
    ),
    CidrIpv4: S.optional(S.String).pipe(
      T.XmlName("cidrIpv4"),
      T.Ec2QueryName("CidrIpv4"),
    ),
    CidrIpv6: S.optional(S.String).pipe(
      T.XmlName("cidrIpv6"),
      T.Ec2QueryName("CidrIpv6"),
    ),
    PrefixListId: S.optional(S.String).pipe(
      T.XmlName("prefixListId"),
      T.Ec2QueryName("PrefixListId"),
    ),
    ReferencedGroupId: S.optional(S.String).pipe(
      T.XmlName("referencedGroupId"),
      T.Ec2QueryName("ReferencedGroupId"),
    ),
    Description: S.optional(S.String).pipe(
      T.XmlName("description"),
      T.Ec2QueryName("Description"),
    ),
  }),
).annotate({
  identifier: "RevokedSecurityGroupRule",
}) as any as S.Schema<RevokedSecurityGroupRule>;
export type RevokedSecurityGroupRuleList = RevokedSecurityGroupRule[];
export const RevokedSecurityGroupRuleList = S.Array(
  RevokedSecurityGroupRule.pipe(T.XmlName("item")).annotate({
    identifier: "RevokedSecurityGroupRule",
  }),
);
export interface RevokeSecurityGroupEgressResult {
  Return?: boolean;
  UnknownIpPermissions?: IpPermission[];
  RevokedSecurityGroupRules?: RevokedSecurityGroupRule[];
}
export const RevokeSecurityGroupEgressResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
    UnknownIpPermissions: S.optional(IpPermissionList).pipe(
      T.XmlName("unknownIpPermissionSet"),
      T.Ec2QueryName("UnknownIpPermissionSet"),
    ),
    RevokedSecurityGroupRules: S.optional(RevokedSecurityGroupRuleList).pipe(
      T.XmlName("revokedSecurityGroupRuleSet"),
      T.Ec2QueryName("RevokedSecurityGroupRuleSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "RevokeSecurityGroupEgressResult",
}) as any as S.Schema<RevokeSecurityGroupEgressResult>;
export interface RevokeSecurityGroupIngressRequest {
  CidrIp?: string;
  FromPort?: number;
  GroupId?: string;
  GroupName?: string;
  IpPermissions?: IpPermission[];
  IpProtocol?: string;
  SourceSecurityGroupName?: string;
  SourceSecurityGroupOwnerId?: string;
  ToPort?: number;
  SecurityGroupRuleIds?: string[];
  DryRun?: boolean;
}
export const RevokeSecurityGroupIngressRequest = S.suspend(() =>
  S.Struct({
    CidrIp: S.optional(S.String),
    FromPort: S.optional(S.Number),
    GroupId: S.optional(S.String),
    GroupName: S.optional(S.String),
    IpPermissions: S.optional(IpPermissionList),
    IpProtocol: S.optional(S.String),
    SourceSecurityGroupName: S.optional(S.String),
    SourceSecurityGroupOwnerId: S.optional(S.String),
    ToPort: S.optional(S.Number),
    SecurityGroupRuleIds: S.optional(SecurityGroupRuleIdList).pipe(
      T.XmlName("SecurityGroupRuleId"),
    ),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RevokeSecurityGroupIngressRequest",
}) as any as S.Schema<RevokeSecurityGroupIngressRequest>;
export interface RevokeSecurityGroupIngressResult {
  Return?: boolean;
  UnknownIpPermissions?: IpPermission[];
  RevokedSecurityGroupRules?: RevokedSecurityGroupRule[];
}
export const RevokeSecurityGroupIngressResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
    UnknownIpPermissions: S.optional(IpPermissionList).pipe(
      T.XmlName("unknownIpPermissionSet"),
      T.Ec2QueryName("UnknownIpPermissionSet"),
    ),
    RevokedSecurityGroupRules: S.optional(RevokedSecurityGroupRuleList).pipe(
      T.XmlName("revokedSecurityGroupRuleSet"),
      T.Ec2QueryName("RevokedSecurityGroupRuleSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "RevokeSecurityGroupIngressResult",
}) as any as S.Schema<RevokeSecurityGroupIngressResult>;
export type ElasticGpuSpecifications = ElasticGpuSpecification[];
export const ElasticGpuSpecifications = S.Array(
  ElasticGpuSpecification.pipe(T.XmlName("item")).annotate({
    identifier: "ElasticGpuSpecification",
  }),
);
export interface ElasticInferenceAccelerator {
  Type?: string;
  Count?: number;
}
export const ElasticInferenceAccelerator = S.suspend(() =>
  S.Struct({ Type: S.optional(S.String), Count: S.optional(S.Number) }),
).annotate({
  identifier: "ElasticInferenceAccelerator",
}) as any as S.Schema<ElasticInferenceAccelerator>;
export type ElasticInferenceAccelerators = ElasticInferenceAccelerator[];
export const ElasticInferenceAccelerators = S.Array(
  ElasticInferenceAccelerator.pipe(T.XmlName("item")).annotate({
    identifier: "ElasticInferenceAccelerator",
  }),
);
export interface LaunchTemplateSpecification {
  LaunchTemplateId?: string;
  LaunchTemplateName?: string;
  Version?: string;
}
export const LaunchTemplateSpecification = S.suspend(() =>
  S.Struct({
    LaunchTemplateId: S.optional(S.String),
    LaunchTemplateName: S.optional(S.String),
    Version: S.optional(S.String),
  }),
).annotate({
  identifier: "LaunchTemplateSpecification",
}) as any as S.Schema<LaunchTemplateSpecification>;
export interface SpotMarketOptions {
  MaxPrice?: string;
  SpotInstanceType?: SpotInstanceType;
  BlockDurationMinutes?: number;
  ValidUntil?: Date;
  InstanceInterruptionBehavior?: InstanceInterruptionBehavior;
}
export const SpotMarketOptions = S.suspend(() =>
  S.Struct({
    MaxPrice: S.optional(S.String),
    SpotInstanceType: S.optional(SpotInstanceType),
    BlockDurationMinutes: S.optional(S.Number),
    ValidUntil: S.optional(
      T.DateFromString.pipe(T.TimestampFormat("date-time")),
    ),
    InstanceInterruptionBehavior: S.optional(InstanceInterruptionBehavior),
  }),
).annotate({
  identifier: "SpotMarketOptions",
}) as any as S.Schema<SpotMarketOptions>;
export interface InstanceMarketOptionsRequest {
  MarketType?: MarketType;
  SpotOptions?: SpotMarketOptions;
}
export const InstanceMarketOptionsRequest = S.suspend(() =>
  S.Struct({
    MarketType: S.optional(MarketType),
    SpotOptions: S.optional(SpotMarketOptions),
  }),
).annotate({
  identifier: "InstanceMarketOptionsRequest",
}) as any as S.Schema<InstanceMarketOptionsRequest>;
export interface CpuOptionsRequest {
  CoreCount?: number;
  ThreadsPerCore?: number;
  AmdSevSnp?: AmdSevSnpSpecification;
  NestedVirtualization?: NestedVirtualizationSpecification;
}
export const CpuOptionsRequest = S.suspend(() =>
  S.Struct({
    CoreCount: S.optional(S.Number),
    ThreadsPerCore: S.optional(S.Number),
    AmdSevSnp: S.optional(AmdSevSnpSpecification),
    NestedVirtualization: S.optional(NestedVirtualizationSpecification),
  }),
).annotate({
  identifier: "CpuOptionsRequest",
}) as any as S.Schema<CpuOptionsRequest>;
export interface HibernationOptionsRequest {
  Configured?: boolean;
}
export const HibernationOptionsRequest = S.suspend(() =>
  S.Struct({ Configured: S.optional(S.Boolean) }),
).annotate({
  identifier: "HibernationOptionsRequest",
}) as any as S.Schema<HibernationOptionsRequest>;
export interface LicenseConfigurationRequest {
  LicenseConfigurationArn?: string;
}
export const LicenseConfigurationRequest = S.suspend(() =>
  S.Struct({ LicenseConfigurationArn: S.optional(S.String) }),
).annotate({
  identifier: "LicenseConfigurationRequest",
}) as any as S.Schema<LicenseConfigurationRequest>;
export type LicenseSpecificationListRequest = LicenseConfigurationRequest[];
export const LicenseSpecificationListRequest = S.Array(
  LicenseConfigurationRequest.pipe(T.XmlName("item")).annotate({
    identifier: "LicenseConfigurationRequest",
  }),
);
export interface InstanceMetadataOptionsRequest {
  HttpTokens?: HttpTokensState;
  HttpPutResponseHopLimit?: number;
  HttpEndpoint?: InstanceMetadataEndpointState;
  HttpProtocolIpv6?: InstanceMetadataProtocolState;
  InstanceMetadataTags?: InstanceMetadataTagsState;
}
export const InstanceMetadataOptionsRequest = S.suspend(() =>
  S.Struct({
    HttpTokens: S.optional(HttpTokensState),
    HttpPutResponseHopLimit: S.optional(S.Number),
    HttpEndpoint: S.optional(InstanceMetadataEndpointState),
    HttpProtocolIpv6: S.optional(InstanceMetadataProtocolState),
    InstanceMetadataTags: S.optional(InstanceMetadataTagsState),
  }),
).annotate({
  identifier: "InstanceMetadataOptionsRequest",
}) as any as S.Schema<InstanceMetadataOptionsRequest>;
export interface EnclaveOptionsRequest {
  Enabled?: boolean;
}
export const EnclaveOptionsRequest = S.suspend(() =>
  S.Struct({ Enabled: S.optional(S.Boolean) }),
).annotate({
  identifier: "EnclaveOptionsRequest",
}) as any as S.Schema<EnclaveOptionsRequest>;
export interface PrivateDnsNameOptionsRequest {
  HostnameType?: HostnameType;
  EnableResourceNameDnsARecord?: boolean;
  EnableResourceNameDnsAAAARecord?: boolean;
}
export const PrivateDnsNameOptionsRequest = S.suspend(() =>
  S.Struct({
    HostnameType: S.optional(HostnameType),
    EnableResourceNameDnsARecord: S.optional(S.Boolean),
    EnableResourceNameDnsAAAARecord: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "PrivateDnsNameOptionsRequest",
}) as any as S.Schema<PrivateDnsNameOptionsRequest>;
export interface InstanceMaintenanceOptionsRequest {
  AutoRecovery?: InstanceAutoRecoveryState;
}
export const InstanceMaintenanceOptionsRequest = S.suspend(() =>
  S.Struct({ AutoRecovery: S.optional(InstanceAutoRecoveryState) }),
).annotate({
  identifier: "InstanceMaintenanceOptionsRequest",
}) as any as S.Schema<InstanceMaintenanceOptionsRequest>;
export interface InstanceNetworkPerformanceOptionsRequest {
  BandwidthWeighting?: InstanceBandwidthWeighting;
}
export const InstanceNetworkPerformanceOptionsRequest = S.suspend(() =>
  S.Struct({ BandwidthWeighting: S.optional(InstanceBandwidthWeighting) }),
).annotate({
  identifier: "InstanceNetworkPerformanceOptionsRequest",
}) as any as S.Schema<InstanceNetworkPerformanceOptionsRequest>;
export interface InstanceSecondaryInterfacePrivateIpAddressRequest {
  PrivateIpAddress?: string;
}
export const InstanceSecondaryInterfacePrivateIpAddressRequest = S.suspend(() =>
  S.Struct({ PrivateIpAddress: S.optional(S.String) }),
).annotate({
  identifier: "InstanceSecondaryInterfacePrivateIpAddressRequest",
}) as any as S.Schema<InstanceSecondaryInterfacePrivateIpAddressRequest>;
export type InstanceSecondaryInterfacePrivateIpAddressListRequest =
  InstanceSecondaryInterfacePrivateIpAddressRequest[];
export const InstanceSecondaryInterfacePrivateIpAddressListRequest = S.Array(
  InstanceSecondaryInterfacePrivateIpAddressRequest.pipe(
    T.XmlName("item"),
  ).annotate({
    identifier: "InstanceSecondaryInterfacePrivateIpAddressRequest",
  }),
);
export interface InstanceSecondaryInterfaceSpecificationRequest {
  DeleteOnTermination?: boolean;
  DeviceIndex?: number;
  PrivateIpAddresses?: InstanceSecondaryInterfacePrivateIpAddressRequest[];
  PrivateIpAddressCount?: number;
  SecondarySubnetId?: string;
  InterfaceType?: SecondaryInterfaceType;
  NetworkCardIndex?: number;
}
export const InstanceSecondaryInterfaceSpecificationRequest = S.suspend(() =>
  S.Struct({
    DeleteOnTermination: S.optional(S.Boolean),
    DeviceIndex: S.optional(S.Number),
    PrivateIpAddresses: S.optional(
      InstanceSecondaryInterfacePrivateIpAddressListRequest,
    ).pipe(T.XmlName("PrivateIpAddress")),
    PrivateIpAddressCount: S.optional(S.Number),
    SecondarySubnetId: S.optional(S.String),
    InterfaceType: S.optional(SecondaryInterfaceType),
    NetworkCardIndex: S.optional(S.Number),
  }),
).annotate({
  identifier: "InstanceSecondaryInterfaceSpecificationRequest",
}) as any as S.Schema<InstanceSecondaryInterfaceSpecificationRequest>;
export type InstanceSecondaryInterfaceSpecificationListRequest =
  InstanceSecondaryInterfaceSpecificationRequest[];
export const InstanceSecondaryInterfaceSpecificationListRequest = S.Array(
  InstanceSecondaryInterfaceSpecificationRequest.pipe(
    T.XmlName("item"),
  ).annotate({ identifier: "InstanceSecondaryInterfaceSpecificationRequest" }),
);
export interface RunInstancesRequest {
  BlockDeviceMappings?: BlockDeviceMapping[];
  ImageId?: string;
  InstanceType?: InstanceType;
  Ipv6AddressCount?: number;
  Ipv6Addresses?: InstanceIpv6Address[];
  KernelId?: string;
  KeyName?: string;
  MaxCount?: number;
  MinCount?: number;
  Monitoring?: RunInstancesMonitoringEnabled;
  Placement?: Placement;
  RamdiskId?: string;
  SecurityGroupIds?: string[];
  SecurityGroups?: string[];
  SubnetId?: string;
  UserData?: string | redacted.Redacted<string>;
  ElasticGpuSpecification?: ElasticGpuSpecification[];
  ElasticInferenceAccelerators?: ElasticInferenceAccelerator[];
  TagSpecifications?: TagSpecification[];
  LaunchTemplate?: LaunchTemplateSpecification;
  InstanceMarketOptions?: InstanceMarketOptionsRequest;
  CreditSpecification?: CreditSpecificationRequest;
  CpuOptions?: CpuOptionsRequest;
  CapacityReservationSpecification?: CapacityReservationSpecification;
  HibernationOptions?: HibernationOptionsRequest;
  LicenseSpecifications?: LicenseConfigurationRequest[];
  MetadataOptions?: InstanceMetadataOptionsRequest;
  EnclaveOptions?: EnclaveOptionsRequest;
  PrivateDnsNameOptions?: PrivateDnsNameOptionsRequest;
  MaintenanceOptions?: InstanceMaintenanceOptionsRequest;
  DisableApiStop?: boolean;
  EnablePrimaryIpv6?: boolean;
  NetworkPerformanceOptions?: InstanceNetworkPerformanceOptionsRequest;
  Operator?: OperatorRequest;
  SecondaryInterfaces?: InstanceSecondaryInterfaceSpecificationRequest[];
  DryRun?: boolean;
  DisableApiTermination?: boolean;
  InstanceInitiatedShutdownBehavior?: ShutdownBehavior;
  PrivateIpAddress?: string;
  ClientToken?: string;
  AdditionalInfo?: string;
  NetworkInterfaces?: InstanceNetworkInterfaceSpecification[];
  IamInstanceProfile?: IamInstanceProfileSpecification;
  EbsOptimized?: boolean;
}
export const RunInstancesRequest = S.suspend(() =>
  S.Struct({
    BlockDeviceMappings: S.optional(BlockDeviceMappingRequestList).pipe(
      T.XmlName("BlockDeviceMapping"),
    ),
    ImageId: S.optional(S.String),
    InstanceType: S.optional(InstanceType),
    Ipv6AddressCount: S.optional(S.Number),
    Ipv6Addresses: S.optional(InstanceIpv6AddressList).pipe(
      T.XmlName("Ipv6Address"),
    ),
    KernelId: S.optional(S.String),
    KeyName: S.optional(S.String),
    MaxCount: S.optional(S.Number),
    MinCount: S.optional(S.Number),
    Monitoring: S.optional(RunInstancesMonitoringEnabled),
    Placement: S.optional(Placement),
    RamdiskId: S.optional(S.String),
    SecurityGroupIds: S.optional(SecurityGroupIdStringList).pipe(
      T.XmlName("SecurityGroupId"),
    ),
    SecurityGroups: S.optional(SecurityGroupStringList).pipe(
      T.XmlName("SecurityGroup"),
    ),
    SubnetId: S.optional(S.String),
    UserData: S.optional(SensitiveString),
    ElasticGpuSpecification: S.optional(ElasticGpuSpecifications),
    ElasticInferenceAccelerators: S.optional(ElasticInferenceAccelerators).pipe(
      T.XmlName("ElasticInferenceAccelerator"),
    ),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    LaunchTemplate: S.optional(LaunchTemplateSpecification),
    InstanceMarketOptions: S.optional(InstanceMarketOptionsRequest),
    CreditSpecification: S.optional(CreditSpecificationRequest),
    CpuOptions: S.optional(CpuOptionsRequest),
    CapacityReservationSpecification: S.optional(
      CapacityReservationSpecification,
    ),
    HibernationOptions: S.optional(HibernationOptionsRequest),
    LicenseSpecifications: S.optional(LicenseSpecificationListRequest).pipe(
      T.XmlName("LicenseSpecification"),
    ),
    MetadataOptions: S.optional(InstanceMetadataOptionsRequest),
    EnclaveOptions: S.optional(EnclaveOptionsRequest),
    PrivateDnsNameOptions: S.optional(PrivateDnsNameOptionsRequest),
    MaintenanceOptions: S.optional(InstanceMaintenanceOptionsRequest),
    DisableApiStop: S.optional(S.Boolean),
    EnablePrimaryIpv6: S.optional(S.Boolean),
    NetworkPerformanceOptions: S.optional(
      InstanceNetworkPerformanceOptionsRequest,
    ),
    Operator: S.optional(OperatorRequest),
    SecondaryInterfaces: S.optional(
      InstanceSecondaryInterfaceSpecificationListRequest,
    ).pipe(T.XmlName("SecondaryInterface")),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    DisableApiTermination: S.optional(S.Boolean).pipe(
      T.XmlName("disableApiTermination"),
      T.Ec2QueryName("DisableApiTermination"),
    ),
    InstanceInitiatedShutdownBehavior: S.optional(ShutdownBehavior).pipe(
      T.XmlName("instanceInitiatedShutdownBehavior"),
      T.Ec2QueryName("InstanceInitiatedShutdownBehavior"),
    ),
    PrivateIpAddress: S.optional(S.String).pipe(
      T.XmlName("privateIpAddress"),
      T.Ec2QueryName("PrivateIpAddress"),
    ),
    ClientToken: S.optional(S.String).pipe(
      T.XmlName("clientToken"),
      T.IdempotencyToken(),
      T.Ec2QueryName("ClientToken"),
    ),
    AdditionalInfo: S.optional(S.String).pipe(
      T.XmlName("additionalInfo"),
      T.Ec2QueryName("AdditionalInfo"),
    ),
    NetworkInterfaces: S.optional(
      InstanceNetworkInterfaceSpecificationList,
    ).pipe(T.XmlName("networkInterface"), T.Ec2QueryName("NetworkInterface")),
    IamInstanceProfile: S.optional(IamInstanceProfileSpecification)
      .pipe(
        T.XmlName("iamInstanceProfile"),
        T.Ec2QueryName("IamInstanceProfile"),
      )
      .annotate({ identifier: "IamInstanceProfileSpecification" }),
    EbsOptimized: S.optional(S.Boolean).pipe(
      T.XmlName("ebsOptimized"),
      T.Ec2QueryName("EbsOptimized"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RunInstancesRequest",
}) as any as S.Schema<RunInstancesRequest>;
export interface ScheduledInstancesEbs {
  DeleteOnTermination?: boolean;
  Encrypted?: boolean;
  Iops?: number;
  SnapshotId?: string;
  VolumeSize?: number;
  VolumeType?: string;
}
export const ScheduledInstancesEbs = S.suspend(() =>
  S.Struct({
    DeleteOnTermination: S.optional(S.Boolean),
    Encrypted: S.optional(S.Boolean),
    Iops: S.optional(S.Number),
    SnapshotId: S.optional(S.String),
    VolumeSize: S.optional(S.Number),
    VolumeType: S.optional(S.String),
  }),
).annotate({
  identifier: "ScheduledInstancesEbs",
}) as any as S.Schema<ScheduledInstancesEbs>;
export interface ScheduledInstancesBlockDeviceMapping {
  DeviceName?: string;
  Ebs?: ScheduledInstancesEbs;
  NoDevice?: string;
  VirtualName?: string;
}
export const ScheduledInstancesBlockDeviceMapping = S.suspend(() =>
  S.Struct({
    DeviceName: S.optional(S.String),
    Ebs: S.optional(ScheduledInstancesEbs),
    NoDevice: S.optional(S.String),
    VirtualName: S.optional(S.String),
  }),
).annotate({
  identifier: "ScheduledInstancesBlockDeviceMapping",
}) as any as S.Schema<ScheduledInstancesBlockDeviceMapping>;
export type ScheduledInstancesBlockDeviceMappingSet =
  ScheduledInstancesBlockDeviceMapping[];
export const ScheduledInstancesBlockDeviceMappingSet = S.Array(
  ScheduledInstancesBlockDeviceMapping.pipe(
    T.XmlName("BlockDeviceMapping"),
  ).annotate({ identifier: "ScheduledInstancesBlockDeviceMapping" }),
);
export interface ScheduledInstancesIamInstanceProfile {
  Arn?: string;
  Name?: string;
}
export const ScheduledInstancesIamInstanceProfile = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String), Name: S.optional(S.String) }),
).annotate({
  identifier: "ScheduledInstancesIamInstanceProfile",
}) as any as S.Schema<ScheduledInstancesIamInstanceProfile>;
export interface ScheduledInstancesMonitoring {
  Enabled?: boolean;
}
export const ScheduledInstancesMonitoring = S.suspend(() =>
  S.Struct({ Enabled: S.optional(S.Boolean) }),
).annotate({
  identifier: "ScheduledInstancesMonitoring",
}) as any as S.Schema<ScheduledInstancesMonitoring>;
export type ScheduledInstancesSecurityGroupIdSet = string[];
export const ScheduledInstancesSecurityGroupIdSet = S.Array(
  S.String.pipe(T.XmlName("SecurityGroupId")),
);
export interface ScheduledInstancesIpv6Address {
  Ipv6Address?: string;
}
export const ScheduledInstancesIpv6Address = S.suspend(() =>
  S.Struct({ Ipv6Address: S.optional(S.String) }),
).annotate({
  identifier: "ScheduledInstancesIpv6Address",
}) as any as S.Schema<ScheduledInstancesIpv6Address>;
export type ScheduledInstancesIpv6AddressList = ScheduledInstancesIpv6Address[];
export const ScheduledInstancesIpv6AddressList = S.Array(
  ScheduledInstancesIpv6Address.pipe(T.XmlName("Ipv6Address")).annotate({
    identifier: "ScheduledInstancesIpv6Address",
  }),
);
export interface ScheduledInstancesPrivateIpAddressConfig {
  Primary?: boolean;
  PrivateIpAddress?: string;
}
export const ScheduledInstancesPrivateIpAddressConfig = S.suspend(() =>
  S.Struct({
    Primary: S.optional(S.Boolean),
    PrivateIpAddress: S.optional(S.String),
  }),
).annotate({
  identifier: "ScheduledInstancesPrivateIpAddressConfig",
}) as any as S.Schema<ScheduledInstancesPrivateIpAddressConfig>;
export type PrivateIpAddressConfigSet =
  ScheduledInstancesPrivateIpAddressConfig[];
export const PrivateIpAddressConfigSet = S.Array(
  ScheduledInstancesPrivateIpAddressConfig.pipe(
    T.XmlName("PrivateIpAddressConfigSet"),
  ).annotate({ identifier: "ScheduledInstancesPrivateIpAddressConfig" }),
);
export interface ScheduledInstancesNetworkInterface {
  AssociatePublicIpAddress?: boolean;
  DeleteOnTermination?: boolean;
  Description?: string;
  DeviceIndex?: number;
  Groups?: string[];
  Ipv6AddressCount?: number;
  Ipv6Addresses?: ScheduledInstancesIpv6Address[];
  NetworkInterfaceId?: string;
  PrivateIpAddress?: string;
  PrivateIpAddressConfigs?: ScheduledInstancesPrivateIpAddressConfig[];
  SecondaryPrivateIpAddressCount?: number;
  SubnetId?: string;
}
export const ScheduledInstancesNetworkInterface = S.suspend(() =>
  S.Struct({
    AssociatePublicIpAddress: S.optional(S.Boolean),
    DeleteOnTermination: S.optional(S.Boolean),
    Description: S.optional(S.String),
    DeviceIndex: S.optional(S.Number),
    Groups: S.optional(ScheduledInstancesSecurityGroupIdSet).pipe(
      T.XmlName("Group"),
    ),
    Ipv6AddressCount: S.optional(S.Number),
    Ipv6Addresses: S.optional(ScheduledInstancesIpv6AddressList).pipe(
      T.XmlName("Ipv6Address"),
    ),
    NetworkInterfaceId: S.optional(S.String),
    PrivateIpAddress: S.optional(S.String),
    PrivateIpAddressConfigs: S.optional(PrivateIpAddressConfigSet).pipe(
      T.XmlName("PrivateIpAddressConfig"),
    ),
    SecondaryPrivateIpAddressCount: S.optional(S.Number),
    SubnetId: S.optional(S.String),
  }),
).annotate({
  identifier: "ScheduledInstancesNetworkInterface",
}) as any as S.Schema<ScheduledInstancesNetworkInterface>;
export type ScheduledInstancesNetworkInterfaceSet =
  ScheduledInstancesNetworkInterface[];
export const ScheduledInstancesNetworkInterfaceSet = S.Array(
  ScheduledInstancesNetworkInterface.pipe(
    T.XmlName("NetworkInterface"),
  ).annotate({ identifier: "ScheduledInstancesNetworkInterface" }),
);
export interface ScheduledInstancesPlacement {
  AvailabilityZone?: string;
  GroupName?: string;
}
export const ScheduledInstancesPlacement = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String),
    GroupName: S.optional(S.String),
  }),
).annotate({
  identifier: "ScheduledInstancesPlacement",
}) as any as S.Schema<ScheduledInstancesPlacement>;
export interface ScheduledInstancesLaunchSpecification {
  BlockDeviceMappings?: ScheduledInstancesBlockDeviceMapping[];
  EbsOptimized?: boolean;
  IamInstanceProfile?: ScheduledInstancesIamInstanceProfile;
  ImageId?: string;
  InstanceType?: string;
  KernelId?: string;
  KeyName?: string;
  Monitoring?: ScheduledInstancesMonitoring;
  NetworkInterfaces?: ScheduledInstancesNetworkInterface[];
  Placement?: ScheduledInstancesPlacement;
  RamdiskId?: string;
  SecurityGroupIds?: string[];
  SubnetId?: string;
  UserData?: string;
}
export const ScheduledInstancesLaunchSpecification = S.suspend(() =>
  S.Struct({
    BlockDeviceMappings: S.optional(
      ScheduledInstancesBlockDeviceMappingSet,
    ).pipe(T.XmlName("BlockDeviceMapping")),
    EbsOptimized: S.optional(S.Boolean),
    IamInstanceProfile: S.optional(ScheduledInstancesIamInstanceProfile),
    ImageId: S.optional(S.String),
    InstanceType: S.optional(S.String),
    KernelId: S.optional(S.String),
    KeyName: S.optional(S.String),
    Monitoring: S.optional(ScheduledInstancesMonitoring),
    NetworkInterfaces: S.optional(ScheduledInstancesNetworkInterfaceSet).pipe(
      T.XmlName("NetworkInterface"),
    ),
    Placement: S.optional(ScheduledInstancesPlacement),
    RamdiskId: S.optional(S.String),
    SecurityGroupIds: S.optional(ScheduledInstancesSecurityGroupIdSet).pipe(
      T.XmlName("SecurityGroupId"),
    ),
    SubnetId: S.optional(S.String),
    UserData: S.optional(S.String),
  }),
).annotate({
  identifier: "ScheduledInstancesLaunchSpecification",
}) as any as S.Schema<ScheduledInstancesLaunchSpecification>;
export interface RunScheduledInstancesRequest {
  ClientToken?: string;
  DryRun?: boolean;
  InstanceCount?: number;
  LaunchSpecification?: ScheduledInstancesLaunchSpecification;
  ScheduledInstanceId?: string;
}
export const RunScheduledInstancesRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    DryRun: S.optional(S.Boolean),
    InstanceCount: S.optional(S.Number),
    LaunchSpecification: S.optional(ScheduledInstancesLaunchSpecification),
    ScheduledInstanceId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RunScheduledInstancesRequest",
}) as any as S.Schema<RunScheduledInstancesRequest>;
export type InstanceIdSet = string[];
export const InstanceIdSet = S.Array(S.String.pipe(T.XmlName("item")));
export interface RunScheduledInstancesResult {
  InstanceIdSet?: string[];
}
export const RunScheduledInstancesResult = S.suspend(() =>
  S.Struct({
    InstanceIdSet: S.optional(InstanceIdSet).pipe(
      T.XmlName("instanceIdSet"),
      T.Ec2QueryName("InstanceIdSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "RunScheduledInstancesResult",
}) as any as S.Schema<RunScheduledInstancesResult>;
export interface SearchLocalGatewayRoutesRequest {
  LocalGatewayRouteTableId?: string;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const SearchLocalGatewayRoutesRequest = S.suspend(() =>
  S.Struct({
    LocalGatewayRouteTableId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchLocalGatewayRoutesRequest",
}) as any as S.Schema<SearchLocalGatewayRoutesRequest>;
export type LocalGatewayRouteList = LocalGatewayRoute[];
export const LocalGatewayRouteList = S.Array(
  LocalGatewayRoute.pipe(T.XmlName("item")).annotate({
    identifier: "LocalGatewayRoute",
  }),
);
export interface SearchLocalGatewayRoutesResult {
  Routes?: LocalGatewayRoute[];
  NextToken?: string;
}
export const SearchLocalGatewayRoutesResult = S.suspend(() =>
  S.Struct({
    Routes: S.optional(LocalGatewayRouteList).pipe(
      T.XmlName("routeSet"),
      T.Ec2QueryName("RouteSet"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "SearchLocalGatewayRoutesResult",
}) as any as S.Schema<SearchLocalGatewayRoutesResult>;
export interface SearchTransitGatewayMulticastGroupsRequest {
  TransitGatewayMulticastDomainId?: string;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
  DryRun?: boolean;
}
export const SearchTransitGatewayMulticastGroupsRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayMulticastDomainId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchTransitGatewayMulticastGroupsRequest",
}) as any as S.Schema<SearchTransitGatewayMulticastGroupsRequest>;
export type MembershipType = "static" | "igmp" | (string & {});
export const MembershipType = S.String;
export interface TransitGatewayMulticastGroup {
  GroupIpAddress?: string;
  TransitGatewayAttachmentId?: string;
  SubnetId?: string;
  ResourceId?: string;
  ResourceType?: TransitGatewayAttachmentResourceType;
  ResourceOwnerId?: string;
  NetworkInterfaceId?: string;
  GroupMember?: boolean;
  GroupSource?: boolean;
  MemberType?: MembershipType;
  SourceType?: MembershipType;
}
export const TransitGatewayMulticastGroup = S.suspend(() =>
  S.Struct({
    GroupIpAddress: S.optional(S.String).pipe(
      T.XmlName("groupIpAddress"),
      T.Ec2QueryName("GroupIpAddress"),
    ),
    TransitGatewayAttachmentId: S.optional(S.String).pipe(
      T.XmlName("transitGatewayAttachmentId"),
      T.Ec2QueryName("TransitGatewayAttachmentId"),
    ),
    SubnetId: S.optional(S.String).pipe(
      T.XmlName("subnetId"),
      T.Ec2QueryName("SubnetId"),
    ),
    ResourceId: S.optional(S.String).pipe(
      T.XmlName("resourceId"),
      T.Ec2QueryName("ResourceId"),
    ),
    ResourceType: S.optional(TransitGatewayAttachmentResourceType).pipe(
      T.XmlName("resourceType"),
      T.Ec2QueryName("ResourceType"),
    ),
    ResourceOwnerId: S.optional(S.String).pipe(
      T.XmlName("resourceOwnerId"),
      T.Ec2QueryName("ResourceOwnerId"),
    ),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    GroupMember: S.optional(S.Boolean).pipe(
      T.XmlName("groupMember"),
      T.Ec2QueryName("GroupMember"),
    ),
    GroupSource: S.optional(S.Boolean).pipe(
      T.XmlName("groupSource"),
      T.Ec2QueryName("GroupSource"),
    ),
    MemberType: S.optional(MembershipType).pipe(
      T.XmlName("memberType"),
      T.Ec2QueryName("MemberType"),
    ),
    SourceType: S.optional(MembershipType).pipe(
      T.XmlName("sourceType"),
      T.Ec2QueryName("SourceType"),
    ),
  }),
).annotate({
  identifier: "TransitGatewayMulticastGroup",
}) as any as S.Schema<TransitGatewayMulticastGroup>;
export type TransitGatewayMulticastGroupList = TransitGatewayMulticastGroup[];
export const TransitGatewayMulticastGroupList = S.Array(
  TransitGatewayMulticastGroup.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayMulticastGroup",
  }),
);
export interface SearchTransitGatewayMulticastGroupsResult {
  MulticastGroups?: TransitGatewayMulticastGroup[];
  NextToken?: string;
}
export const SearchTransitGatewayMulticastGroupsResult = S.suspend(() =>
  S.Struct({
    MulticastGroups: S.optional(TransitGatewayMulticastGroupList).pipe(
      T.XmlName("multicastGroups"),
      T.Ec2QueryName("MulticastGroups"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "SearchTransitGatewayMulticastGroupsResult",
}) as any as S.Schema<SearchTransitGatewayMulticastGroupsResult>;
export interface SearchTransitGatewayRoutesRequest {
  TransitGatewayRouteTableId?: string;
  Filters?: Filter[];
  MaxResults?: number;
  DryRun?: boolean;
  NextToken?: string;
}
export const SearchTransitGatewayRoutesRequest = S.suspend(() =>
  S.Struct({
    TransitGatewayRouteTableId: S.optional(S.String),
    Filters: S.optional(FilterList).pipe(T.XmlName("Filter")),
    MaxResults: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchTransitGatewayRoutesRequest",
}) as any as S.Schema<SearchTransitGatewayRoutesRequest>;
export type TransitGatewayRouteList = TransitGatewayRoute[];
export const TransitGatewayRouteList = S.Array(
  TransitGatewayRoute.pipe(T.XmlName("item")).annotate({
    identifier: "TransitGatewayRoute",
  }),
);
export interface SearchTransitGatewayRoutesResult {
  Routes?: TransitGatewayRoute[];
  AdditionalRoutesAvailable?: boolean;
  NextToken?: string;
}
export const SearchTransitGatewayRoutesResult = S.suspend(() =>
  S.Struct({
    Routes: S.optional(TransitGatewayRouteList).pipe(
      T.XmlName("routeSet"),
      T.Ec2QueryName("RouteSet"),
    ),
    AdditionalRoutesAvailable: S.optional(S.Boolean).pipe(
      T.XmlName("additionalRoutesAvailable"),
      T.Ec2QueryName("AdditionalRoutesAvailable"),
    ),
    NextToken: S.optional(S.String).pipe(
      T.XmlName("nextToken"),
      T.Ec2QueryName("NextToken"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "SearchTransitGatewayRoutesResult",
}) as any as S.Schema<SearchTransitGatewayRoutesResult>;
export interface SendDiagnosticInterruptRequest {
  InstanceId?: string;
  DryRun?: boolean;
}
export const SendDiagnosticInterruptRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SendDiagnosticInterruptRequest",
}) as any as S.Schema<SendDiagnosticInterruptRequest>;
export interface SendDiagnosticInterruptResponse {}
export const SendDiagnosticInterruptResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "SendDiagnosticInterruptResponse",
}) as any as S.Schema<SendDiagnosticInterruptResponse>;
export interface StartDeclarativePoliciesReportRequest {
  DryRun?: boolean;
  S3Bucket?: string;
  S3Prefix?: string;
  TargetId?: string;
  TagSpecifications?: TagSpecification[];
}
export const StartDeclarativePoliciesReportRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    S3Bucket: S.optional(S.String),
    S3Prefix: S.optional(S.String),
    TargetId: S.optional(S.String),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartDeclarativePoliciesReportRequest",
}) as any as S.Schema<StartDeclarativePoliciesReportRequest>;
export interface StartDeclarativePoliciesReportResult {
  ReportId?: string;
}
export const StartDeclarativePoliciesReportResult = S.suspend(() =>
  S.Struct({
    ReportId: S.optional(S.String).pipe(
      T.XmlName("reportId"),
      T.Ec2QueryName("ReportId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "StartDeclarativePoliciesReportResult",
}) as any as S.Schema<StartDeclarativePoliciesReportResult>;
export interface StartInstancesRequest {
  InstanceIds?: string[];
  AdditionalInfo?: string;
  DryRun?: boolean;
}
export const StartInstancesRequest = S.suspend(() =>
  S.Struct({
    InstanceIds: S.optional(InstanceIdStringList).pipe(T.XmlName("InstanceId")),
    AdditionalInfo: S.optional(S.String).pipe(
      T.XmlName("additionalInfo"),
      T.Ec2QueryName("AdditionalInfo"),
    ),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartInstancesRequest",
}) as any as S.Schema<StartInstancesRequest>;
export interface InstanceStateChange {
  InstanceId?: string;
  CurrentState?: InstanceState;
  PreviousState?: InstanceState;
}
export const InstanceStateChange = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String).pipe(
      T.XmlName("instanceId"),
      T.Ec2QueryName("InstanceId"),
    ),
    CurrentState: S.optional(InstanceState)
      .pipe(T.XmlName("currentState"), T.Ec2QueryName("CurrentState"))
      .annotate({ identifier: "InstanceState" }),
    PreviousState: S.optional(InstanceState)
      .pipe(T.XmlName("previousState"), T.Ec2QueryName("PreviousState"))
      .annotate({ identifier: "InstanceState" }),
  }),
).annotate({
  identifier: "InstanceStateChange",
}) as any as S.Schema<InstanceStateChange>;
export type InstanceStateChangeList = InstanceStateChange[];
export const InstanceStateChangeList = S.Array(
  InstanceStateChange.pipe(T.XmlName("item")).annotate({
    identifier: "InstanceStateChange",
  }),
);
export interface StartInstancesResult {
  StartingInstances?: InstanceStateChange[];
}
export const StartInstancesResult = S.suspend(() =>
  S.Struct({
    StartingInstances: S.optional(InstanceStateChangeList).pipe(
      T.XmlName("instancesSet"),
      T.Ec2QueryName("InstancesSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "StartInstancesResult",
}) as any as S.Schema<StartInstancesResult>;
export interface StartNetworkInsightsAccessScopeAnalysisRequest {
  NetworkInsightsAccessScopeId?: string;
  DryRun?: boolean;
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
}
export const StartNetworkInsightsAccessScopeAnalysisRequest = S.suspend(() =>
  S.Struct({
    NetworkInsightsAccessScopeId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartNetworkInsightsAccessScopeAnalysisRequest",
}) as any as S.Schema<StartNetworkInsightsAccessScopeAnalysisRequest>;
export interface StartNetworkInsightsAccessScopeAnalysisResult {
  NetworkInsightsAccessScopeAnalysis?: NetworkInsightsAccessScopeAnalysis;
}
export const StartNetworkInsightsAccessScopeAnalysisResult = S.suspend(() =>
  S.Struct({
    NetworkInsightsAccessScopeAnalysis: S.optional(
      NetworkInsightsAccessScopeAnalysis,
    )
      .pipe(
        T.XmlName("networkInsightsAccessScopeAnalysis"),
        T.Ec2QueryName("NetworkInsightsAccessScopeAnalysis"),
      )
      .annotate({ identifier: "NetworkInsightsAccessScopeAnalysis" }),
  }).pipe(ns),
).annotate({
  identifier: "StartNetworkInsightsAccessScopeAnalysisResult",
}) as any as S.Schema<StartNetworkInsightsAccessScopeAnalysisResult>;
export interface StartNetworkInsightsAnalysisRequest {
  NetworkInsightsPathId?: string;
  AdditionalAccounts?: string[];
  FilterInArns?: string[];
  FilterOutArns?: string[];
  DryRun?: boolean;
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
}
export const StartNetworkInsightsAnalysisRequest = S.suspend(() =>
  S.Struct({
    NetworkInsightsPathId: S.optional(S.String),
    AdditionalAccounts: S.optional(ValueStringList).pipe(
      T.XmlName("AdditionalAccount"),
    ),
    FilterInArns: S.optional(ArnList).pipe(T.XmlName("FilterInArn")),
    FilterOutArns: S.optional(ArnList).pipe(T.XmlName("FilterOutArn")),
    DryRun: S.optional(S.Boolean),
    TagSpecifications: S.optional(TagSpecificationList).pipe(
      T.XmlName("TagSpecification"),
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartNetworkInsightsAnalysisRequest",
}) as any as S.Schema<StartNetworkInsightsAnalysisRequest>;
export interface StartNetworkInsightsAnalysisResult {
  NetworkInsightsAnalysis?: NetworkInsightsAnalysis;
}
export const StartNetworkInsightsAnalysisResult = S.suspend(() =>
  S.Struct({
    NetworkInsightsAnalysis: S.optional(NetworkInsightsAnalysis)
      .pipe(
        T.XmlName("networkInsightsAnalysis"),
        T.Ec2QueryName("NetworkInsightsAnalysis"),
      )
      .annotate({ identifier: "NetworkInsightsAnalysis" }),
  }).pipe(ns),
).annotate({
  identifier: "StartNetworkInsightsAnalysisResult",
}) as any as S.Schema<StartNetworkInsightsAnalysisResult>;
export interface StartVpcEndpointServicePrivateDnsVerificationRequest {
  DryRun?: boolean;
  ServiceId?: string;
}
export const StartVpcEndpointServicePrivateDnsVerificationRequest = S.suspend(
  () =>
    S.Struct({
      DryRun: S.optional(S.Boolean),
      ServiceId: S.optional(S.String),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotate({
  identifier: "StartVpcEndpointServicePrivateDnsVerificationRequest",
}) as any as S.Schema<StartVpcEndpointServicePrivateDnsVerificationRequest>;
export interface StartVpcEndpointServicePrivateDnsVerificationResult {
  ReturnValue?: boolean;
}
export const StartVpcEndpointServicePrivateDnsVerificationResult = S.suspend(
  () =>
    S.Struct({
      ReturnValue: S.optional(S.Boolean).pipe(
        T.XmlName("return"),
        T.Ec2QueryName("Return"),
      ),
    }).pipe(ns),
).annotate({
  identifier: "StartVpcEndpointServicePrivateDnsVerificationResult",
}) as any as S.Schema<StartVpcEndpointServicePrivateDnsVerificationResult>;
export interface StopInstancesRequest {
  InstanceIds?: string[];
  Hibernate?: boolean;
  SkipOsShutdown?: boolean;
  DryRun?: boolean;
  Force?: boolean;
}
export const StopInstancesRequest = S.suspend(() =>
  S.Struct({
    InstanceIds: S.optional(InstanceIdStringList).pipe(T.XmlName("InstanceId")),
    Hibernate: S.optional(S.Boolean),
    SkipOsShutdown: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
    Force: S.optional(S.Boolean).pipe(
      T.XmlName("force"),
      T.Ec2QueryName("Force"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopInstancesRequest",
}) as any as S.Schema<StopInstancesRequest>;
export interface StopInstancesResult {
  StoppingInstances?: InstanceStateChange[];
}
export const StopInstancesResult = S.suspend(() =>
  S.Struct({
    StoppingInstances: S.optional(InstanceStateChangeList).pipe(
      T.XmlName("instancesSet"),
      T.Ec2QueryName("InstancesSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "StopInstancesResult",
}) as any as S.Schema<StopInstancesResult>;
export interface TerminateClientVpnConnectionsRequest {
  ClientVpnEndpointId?: string;
  ConnectionId?: string;
  Username?: string;
  DryRun?: boolean;
}
export const TerminateClientVpnConnectionsRequest = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String),
    ConnectionId: S.optional(S.String),
    Username: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "TerminateClientVpnConnectionsRequest",
}) as any as S.Schema<TerminateClientVpnConnectionsRequest>;
export interface TerminateConnectionStatus {
  ConnectionId?: string;
  PreviousStatus?: ClientVpnConnectionStatus;
  CurrentStatus?: ClientVpnConnectionStatus;
}
export const TerminateConnectionStatus = S.suspend(() =>
  S.Struct({
    ConnectionId: S.optional(S.String).pipe(
      T.XmlName("connectionId"),
      T.Ec2QueryName("ConnectionId"),
    ),
    PreviousStatus: S.optional(ClientVpnConnectionStatus)
      .pipe(T.XmlName("previousStatus"), T.Ec2QueryName("PreviousStatus"))
      .annotate({ identifier: "ClientVpnConnectionStatus" }),
    CurrentStatus: S.optional(ClientVpnConnectionStatus)
      .pipe(T.XmlName("currentStatus"), T.Ec2QueryName("CurrentStatus"))
      .annotate({ identifier: "ClientVpnConnectionStatus" }),
  }),
).annotate({
  identifier: "TerminateConnectionStatus",
}) as any as S.Schema<TerminateConnectionStatus>;
export type TerminateConnectionStatusSet = TerminateConnectionStatus[];
export const TerminateConnectionStatusSet = S.Array(
  TerminateConnectionStatus.pipe(T.XmlName("item")).annotate({
    identifier: "TerminateConnectionStatus",
  }),
);
export interface TerminateClientVpnConnectionsResult {
  ClientVpnEndpointId?: string;
  Username?: string;
  ConnectionStatuses?: TerminateConnectionStatus[];
}
export const TerminateClientVpnConnectionsResult = S.suspend(() =>
  S.Struct({
    ClientVpnEndpointId: S.optional(S.String).pipe(
      T.XmlName("clientVpnEndpointId"),
      T.Ec2QueryName("ClientVpnEndpointId"),
    ),
    Username: S.optional(S.String).pipe(
      T.XmlName("username"),
      T.Ec2QueryName("Username"),
    ),
    ConnectionStatuses: S.optional(TerminateConnectionStatusSet).pipe(
      T.XmlName("connectionStatuses"),
      T.Ec2QueryName("ConnectionStatuses"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "TerminateClientVpnConnectionsResult",
}) as any as S.Schema<TerminateClientVpnConnectionsResult>;
export interface TerminateInstancesRequest {
  InstanceIds?: string[];
  Force?: boolean;
  SkipOsShutdown?: boolean;
  DryRun?: boolean;
}
export const TerminateInstancesRequest = S.suspend(() =>
  S.Struct({
    InstanceIds: S.optional(InstanceIdStringList).pipe(T.XmlName("InstanceId")),
    Force: S.optional(S.Boolean),
    SkipOsShutdown: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "TerminateInstancesRequest",
}) as any as S.Schema<TerminateInstancesRequest>;
export interface TerminateInstancesResult {
  TerminatingInstances?: InstanceStateChange[];
}
export const TerminateInstancesResult = S.suspend(() =>
  S.Struct({
    TerminatingInstances: S.optional(InstanceStateChangeList).pipe(
      T.XmlName("instancesSet"),
      T.Ec2QueryName("InstancesSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "TerminateInstancesResult",
}) as any as S.Schema<TerminateInstancesResult>;
export interface UnassignIpv6AddressesRequest {
  Ipv6Prefixes?: string[];
  NetworkInterfaceId?: string;
  Ipv6Addresses?: string[];
}
export const UnassignIpv6AddressesRequest = S.suspend(() =>
  S.Struct({
    Ipv6Prefixes: S.optional(IpPrefixList).pipe(T.XmlName("Ipv6Prefix")),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    Ipv6Addresses: S.optional(Ipv6AddressList).pipe(
      T.XmlName("ipv6Addresses"),
      T.Ec2QueryName("Ipv6Addresses"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UnassignIpv6AddressesRequest",
}) as any as S.Schema<UnassignIpv6AddressesRequest>;
export interface UnassignIpv6AddressesResult {
  NetworkInterfaceId?: string;
  UnassignedIpv6Addresses?: string[];
  UnassignedIpv6Prefixes?: string[];
}
export const UnassignIpv6AddressesResult = S.suspend(() =>
  S.Struct({
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    UnassignedIpv6Addresses: S.optional(Ipv6AddressList).pipe(
      T.XmlName("unassignedIpv6Addresses"),
      T.Ec2QueryName("UnassignedIpv6Addresses"),
    ),
    UnassignedIpv6Prefixes: S.optional(IpPrefixList).pipe(
      T.XmlName("unassignedIpv6PrefixSet"),
      T.Ec2QueryName("UnassignedIpv6PrefixSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "UnassignIpv6AddressesResult",
}) as any as S.Schema<UnassignIpv6AddressesResult>;
export interface UnassignPrivateIpAddressesRequest {
  Ipv4Prefixes?: string[];
  NetworkInterfaceId?: string;
  PrivateIpAddresses?: string[];
}
export const UnassignPrivateIpAddressesRequest = S.suspend(() =>
  S.Struct({
    Ipv4Prefixes: S.optional(IpPrefixList).pipe(T.XmlName("Ipv4Prefix")),
    NetworkInterfaceId: S.optional(S.String).pipe(
      T.XmlName("networkInterfaceId"),
      T.Ec2QueryName("NetworkInterfaceId"),
    ),
    PrivateIpAddresses: S.optional(PrivateIpAddressStringList).pipe(
      T.XmlName("privateIpAddress"),
      T.Ec2QueryName("PrivateIpAddress"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UnassignPrivateIpAddressesRequest",
}) as any as S.Schema<UnassignPrivateIpAddressesRequest>;
export interface UnassignPrivateIpAddressesResponse {}
export const UnassignPrivateIpAddressesResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "UnassignPrivateIpAddressesResponse",
}) as any as S.Schema<UnassignPrivateIpAddressesResponse>;
export interface UnassignPrivateNatGatewayAddressRequest {
  NatGatewayId?: string;
  PrivateIpAddresses?: string[];
  MaxDrainDurationSeconds?: number;
  DryRun?: boolean;
}
export const UnassignPrivateNatGatewayAddressRequest = S.suspend(() =>
  S.Struct({
    NatGatewayId: S.optional(S.String),
    PrivateIpAddresses: S.optional(IpList).pipe(T.XmlName("PrivateIpAddress")),
    MaxDrainDurationSeconds: S.optional(S.Number),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UnassignPrivateNatGatewayAddressRequest",
}) as any as S.Schema<UnassignPrivateNatGatewayAddressRequest>;
export interface UnassignPrivateNatGatewayAddressResult {
  NatGatewayId?: string;
  NatGatewayAddresses?: NatGatewayAddress[];
}
export const UnassignPrivateNatGatewayAddressResult = S.suspend(() =>
  S.Struct({
    NatGatewayId: S.optional(S.String).pipe(
      T.XmlName("natGatewayId"),
      T.Ec2QueryName("NatGatewayId"),
    ),
    NatGatewayAddresses: S.optional(NatGatewayAddressList).pipe(
      T.XmlName("natGatewayAddressSet"),
      T.Ec2QueryName("NatGatewayAddressSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "UnassignPrivateNatGatewayAddressResult",
}) as any as S.Schema<UnassignPrivateNatGatewayAddressResult>;
export interface UnlockSnapshotRequest {
  SnapshotId?: string;
  DryRun?: boolean;
}
export const UnlockSnapshotRequest = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String),
    DryRun: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UnlockSnapshotRequest",
}) as any as S.Schema<UnlockSnapshotRequest>;
export interface UnlockSnapshotResult {
  SnapshotId?: string;
}
export const UnlockSnapshotResult = S.suspend(() =>
  S.Struct({
    SnapshotId: S.optional(S.String).pipe(
      T.XmlName("snapshotId"),
      T.Ec2QueryName("SnapshotId"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "UnlockSnapshotResult",
}) as any as S.Schema<UnlockSnapshotResult>;
export interface UnmonitorInstancesRequest {
  InstanceIds?: string[];
  DryRun?: boolean;
}
export const UnmonitorInstancesRequest = S.suspend(() =>
  S.Struct({
    InstanceIds: S.optional(InstanceIdStringList).pipe(T.XmlName("InstanceId")),
    DryRun: S.optional(S.Boolean).pipe(
      T.XmlName("dryRun"),
      T.Ec2QueryName("DryRun"),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UnmonitorInstancesRequest",
}) as any as S.Schema<UnmonitorInstancesRequest>;
export interface UnmonitorInstancesResult {
  InstanceMonitorings?: InstanceMonitoring[];
}
export const UnmonitorInstancesResult = S.suspend(() =>
  S.Struct({
    InstanceMonitorings: S.optional(InstanceMonitoringList).pipe(
      T.XmlName("instancesSet"),
      T.Ec2QueryName("InstancesSet"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "UnmonitorInstancesResult",
}) as any as S.Schema<UnmonitorInstancesResult>;
export interface UpdateCapacityManagerOrganizationsAccessRequest {
  OrganizationsAccess?: boolean;
  DryRun?: boolean;
  ClientToken?: string;
}
export const UpdateCapacityManagerOrganizationsAccessRequest = S.suspend(() =>
  S.Struct({
    OrganizationsAccess: S.optional(S.Boolean),
    DryRun: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateCapacityManagerOrganizationsAccessRequest",
}) as any as S.Schema<UpdateCapacityManagerOrganizationsAccessRequest>;
export interface UpdateCapacityManagerOrganizationsAccessResult {
  CapacityManagerStatus?: CapacityManagerStatus;
  OrganizationsAccess?: boolean;
}
export const UpdateCapacityManagerOrganizationsAccessResult = S.suspend(() =>
  S.Struct({
    CapacityManagerStatus: S.optional(CapacityManagerStatus).pipe(
      T.XmlName("capacityManagerStatus"),
      T.Ec2QueryName("CapacityManagerStatus"),
    ),
    OrganizationsAccess: S.optional(S.Boolean).pipe(
      T.XmlName("organizationsAccess"),
      T.Ec2QueryName("OrganizationsAccess"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "UpdateCapacityManagerOrganizationsAccessResult",
}) as any as S.Schema<UpdateCapacityManagerOrganizationsAccessResult>;
export interface UpdateInterruptibleCapacityReservationAllocationRequest {
  CapacityReservationId?: string;
  TargetInstanceCount?: number;
  DryRun?: boolean;
}
export const UpdateInterruptibleCapacityReservationAllocationRequest =
  S.suspend(() =>
    S.Struct({
      CapacityReservationId: S.optional(S.String),
      TargetInstanceCount: S.optional(S.Number),
      DryRun: S.optional(S.Boolean),
    }).pipe(
      T.all(
        ns,
        T.Http({ method: "POST", uri: "/" }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
  ).annotate({
    identifier: "UpdateInterruptibleCapacityReservationAllocationRequest",
  }) as any as S.Schema<UpdateInterruptibleCapacityReservationAllocationRequest>;
export interface UpdateInterruptibleCapacityReservationAllocationResult {
  InterruptibleCapacityReservationId?: string;
  SourceCapacityReservationId?: string;
  InstanceCount?: number;
  TargetInstanceCount?: number;
  Status?: InterruptibleCapacityReservationAllocationStatus;
  InterruptionType?: InterruptionType;
}
export const UpdateInterruptibleCapacityReservationAllocationResult = S.suspend(
  () =>
    S.Struct({
      InterruptibleCapacityReservationId: S.optional(S.String).pipe(
        T.XmlName("interruptibleCapacityReservationId"),
        T.Ec2QueryName("InterruptibleCapacityReservationId"),
      ),
      SourceCapacityReservationId: S.optional(S.String).pipe(
        T.XmlName("sourceCapacityReservationId"),
        T.Ec2QueryName("SourceCapacityReservationId"),
      ),
      InstanceCount: S.optional(S.Number).pipe(
        T.XmlName("instanceCount"),
        T.Ec2QueryName("InstanceCount"),
      ),
      TargetInstanceCount: S.optional(S.Number).pipe(
        T.XmlName("targetInstanceCount"),
        T.Ec2QueryName("TargetInstanceCount"),
      ),
      Status: S.optional(InterruptibleCapacityReservationAllocationStatus).pipe(
        T.XmlName("status"),
        T.Ec2QueryName("Status"),
      ),
      InterruptionType: S.optional(InterruptionType).pipe(
        T.XmlName("interruptionType"),
        T.Ec2QueryName("InterruptionType"),
      ),
    }).pipe(ns),
).annotate({
  identifier: "UpdateInterruptibleCapacityReservationAllocationResult",
}) as any as S.Schema<UpdateInterruptibleCapacityReservationAllocationResult>;
export interface SecurityGroupRuleDescription {
  SecurityGroupRuleId?: string;
  Description?: string;
}
export const SecurityGroupRuleDescription = S.suspend(() =>
  S.Struct({
    SecurityGroupRuleId: S.optional(S.String),
    Description: S.optional(S.String),
  }),
).annotate({
  identifier: "SecurityGroupRuleDescription",
}) as any as S.Schema<SecurityGroupRuleDescription>;
export type SecurityGroupRuleDescriptionList = SecurityGroupRuleDescription[];
export const SecurityGroupRuleDescriptionList = S.Array(
  SecurityGroupRuleDescription.pipe(T.XmlName("item")).annotate({
    identifier: "SecurityGroupRuleDescription",
  }),
);
export interface UpdateSecurityGroupRuleDescriptionsEgressRequest {
  DryRun?: boolean;
  GroupId?: string;
  GroupName?: string;
  IpPermissions?: IpPermission[];
  SecurityGroupRuleDescriptions?: SecurityGroupRuleDescription[];
}
export const UpdateSecurityGroupRuleDescriptionsEgressRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    GroupId: S.optional(S.String),
    GroupName: S.optional(S.String),
    IpPermissions: S.optional(IpPermissionList),
    SecurityGroupRuleDescriptions: S.optional(
      SecurityGroupRuleDescriptionList,
    ).pipe(T.XmlName("SecurityGroupRuleDescription")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateSecurityGroupRuleDescriptionsEgressRequest",
}) as any as S.Schema<UpdateSecurityGroupRuleDescriptionsEgressRequest>;
export interface UpdateSecurityGroupRuleDescriptionsEgressResult {
  Return?: boolean;
}
export const UpdateSecurityGroupRuleDescriptionsEgressResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "UpdateSecurityGroupRuleDescriptionsEgressResult",
}) as any as S.Schema<UpdateSecurityGroupRuleDescriptionsEgressResult>;
export interface UpdateSecurityGroupRuleDescriptionsIngressRequest {
  DryRun?: boolean;
  GroupId?: string;
  GroupName?: string;
  IpPermissions?: IpPermission[];
  SecurityGroupRuleDescriptions?: SecurityGroupRuleDescription[];
}
export const UpdateSecurityGroupRuleDescriptionsIngressRequest = S.suspend(() =>
  S.Struct({
    DryRun: S.optional(S.Boolean),
    GroupId: S.optional(S.String),
    GroupName: S.optional(S.String),
    IpPermissions: S.optional(IpPermissionList),
    SecurityGroupRuleDescriptions: S.optional(
      SecurityGroupRuleDescriptionList,
    ).pipe(T.XmlName("SecurityGroupRuleDescription")),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateSecurityGroupRuleDescriptionsIngressRequest",
}) as any as S.Schema<UpdateSecurityGroupRuleDescriptionsIngressRequest>;
export interface UpdateSecurityGroupRuleDescriptionsIngressResult {
  Return?: boolean;
}
export const UpdateSecurityGroupRuleDescriptionsIngressResult = S.suspend(() =>
  S.Struct({
    Return: S.optional(S.Boolean).pipe(
      T.XmlName("return"),
      T.Ec2QueryName("Return"),
    ),
  }).pipe(ns),
).annotate({
  identifier: "UpdateSecurityGroupRuleDescriptionsIngressResult",
}) as any as S.Schema<UpdateSecurityGroupRuleDescriptionsIngressResult>;
export interface WithdrawByoipCidrRequest {
  Cidr?: string;
  DryRun?: boolean;
}
export const WithdrawByoipCidrRequest = S.suspend(() =>
  S.Struct({ Cidr: S.optional(S.String), DryRun: S.optional(S.Boolean) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "WithdrawByoipCidrRequest",
}) as any as S.Schema<WithdrawByoipCidrRequest>;
export interface WithdrawByoipCidrResult {
  ByoipCidr?: ByoipCidr;
}
export const WithdrawByoipCidrResult = S.suspend(() =>
  S.Struct({
    ByoipCidr: S.optional(ByoipCidr)
      .pipe(T.XmlName("byoipCidr"), T.Ec2QueryName("ByoipCidr"))
      .annotate({ identifier: "ByoipCidr" }),
  }).pipe(ns),
).annotate({
  identifier: "WithdrawByoipCidrResult",
}) as any as S.Schema<WithdrawByoipCidrResult>;

//# Errors
export class RequestLimitExceeded extends S.TaggedErrorClass<RequestLimitExceeded>()(
  "RequestLimitExceeded",
  {},
).pipe(C.withThrottlingError) {}
export class InvalidAddressMalformed extends S.TaggedErrorClass<InvalidAddressMalformed>()(
  "InvalidAddress.Malformed",
  {},
) {}
export class InvalidAddressNotFound extends S.TaggedErrorClass<InvalidAddressNotFound>()(
  "InvalidAddress.NotFound",
  {},
) {}
export class InvalidCapacityReservationIdMalformed extends S.TaggedErrorClass<InvalidCapacityReservationIdMalformed>()(
  "InvalidCapacityReservationId.Malformed",
  {},
) {}
export class InvalidReservedInstancesIDNotFound extends S.TaggedErrorClass<InvalidReservedInstancesIDNotFound>()(
  "InvalidReservedInstancesID.NotFound",
  {},
) {}
export class MissingParameter extends S.TaggedErrorClass<MissingParameter>()(
  "MissingParameter",
  {},
) {}
export class InvalidTransitGatewayAttachmentIDNotFound extends S.TaggedErrorClass<InvalidTransitGatewayAttachmentIDNotFound>()(
  "InvalidTransitGatewayAttachmentID.NotFound",
  {},
) {}
export class InvalidParameter extends S.TaggedErrorClass<InvalidParameter>()(
  "InvalidParameter",
  {},
) {}
export class InvalidVpcEndpointServiceIdNotFound extends S.TaggedErrorClass<InvalidVpcEndpointServiceIdNotFound>()(
  "InvalidVpcEndpointServiceId.NotFound",
  {},
) {}
export class InvalidVpcPeeringConnectionIDNotFound extends S.TaggedErrorClass<InvalidVpcPeeringConnectionIDNotFound>()(
  "InvalidVpcPeeringConnectionID.NotFound",
  {},
) {}
export class InvalidVpcPeeringConnectionIdNotFound extends S.TaggedErrorClass<InvalidVpcPeeringConnectionIdNotFound>()(
  "InvalidVpcPeeringConnectionId.NotFound",
  {},
) {}
export class AddressLimitExceeded extends S.TaggedErrorClass<AddressLimitExceeded>()(
  "AddressLimitExceeded",
  {},
).pipe(C.withThrottlingError) {}
export class InvalidHostConfiguration extends S.TaggedErrorClass<InvalidHostConfiguration>()(
  "InvalidHostConfiguration",
  {},
) {}
export class InvalidRequest extends S.TaggedErrorClass<InvalidRequest>()(
  "InvalidRequest",
  {},
) {}
export class InvalidIpamPoolIdNotFound extends S.TaggedErrorClass<InvalidIpamPoolIdNotFound>()(
  "InvalidIpamPoolId.NotFound",
  {},
) {}
export class InvalidVpcIdMalformed extends S.TaggedErrorClass<InvalidVpcIdMalformed>()(
  "InvalidVpcId.Malformed",
  {},
) {}
export class InvalidNetworkInterfaceIDNotFound extends S.TaggedErrorClass<InvalidNetworkInterfaceIDNotFound>()(
  "InvalidNetworkInterfaceID.NotFound",
  {},
) {}
export class InvalidParameterCombination extends S.TaggedErrorClass<InvalidParameterCombination>()(
  "InvalidParameterCombination",
  {},
) {}
export class InvalidNetworkInterfaceIdMalformed extends S.TaggedErrorClass<InvalidNetworkInterfaceIdMalformed>()(
  "InvalidNetworkInterfaceId.Malformed",
  {},
) {}
export class NatGatewayNotFound extends S.TaggedErrorClass<NatGatewayNotFound>()(
  "NatGatewayNotFound",
  {},
) {}
export class AuthFailure extends S.TaggedErrorClass<AuthFailure>()(
  "AuthFailure",
  {},
).pipe(C.withAuthError) {}
export class InvalidAllocationIDNotFound extends S.TaggedErrorClass<InvalidAllocationIDNotFound>()(
  "InvalidAllocationID.NotFound",
  {},
) {}
export class InvalidInstanceIDNotFound extends S.TaggedErrorClass<InvalidInstanceIDNotFound>()(
  "InvalidInstanceID.NotFound",
  {},
) {}
export class InvalidSubnetIDMalformed extends S.TaggedErrorClass<InvalidSubnetIDMalformed>()(
  "InvalidSubnetID.Malformed",
  {},
) {}
export class InvalidDhcpOptionsIdMalformed extends S.TaggedErrorClass<InvalidDhcpOptionsIdMalformed>()(
  "InvalidDhcpOptionsId.Malformed",
  {},
) {}
export class InvalidVpcIDNotFound extends S.TaggedErrorClass<InvalidVpcIDNotFound>()(
  "InvalidVpcID.NotFound",
  {},
) {}
export class InvalidCertificateArnMalformed extends S.TaggedErrorClass<InvalidCertificateArnMalformed>()(
  "InvalidCertificateArn.Malformed",
  {},
) {}
export class InvalidRoleArnMalformed extends S.TaggedErrorClass<InvalidRoleArnMalformed>()(
  "InvalidRoleArn.Malformed",
  {},
) {}
export class InvalidCidrNotFound extends S.TaggedErrorClass<InvalidCidrNotFound>()(
  "InvalidCidr.NotFound",
  {},
) {}
export class InvalidIpamResourceDiscoveryIdMalformed extends S.TaggedErrorClass<InvalidIpamResourceDiscoveryIdMalformed>()(
  "InvalidIpamResourceDiscoveryId.Malformed",
  {},
) {}
export class InvalidIpamResourceDiscoveryIdNotFound extends S.TaggedErrorClass<InvalidIpamResourceDiscoveryIdNotFound>()(
  "InvalidIpamResourceDiscoveryId.NotFound",
  {},
) {}
export class NatGatewayMalformed extends S.TaggedErrorClass<NatGatewayMalformed>()(
  "NatGatewayMalformed",
  {},
) {}
export class InvalidRouteServerIdNotFound extends S.TaggedErrorClass<InvalidRouteServerIdNotFound>()(
  "InvalidRouteServerId.NotFound",
  {},
) {}
export class DryRunOperation extends S.TaggedErrorClass<DryRunOperation>()(
  "DryRunOperation",
  {},
) {}
export class InvalidParameterValue extends S.TaggedErrorClass<InvalidParameterValue>()(
  "InvalidParameterValue",
  {},
) {}
export class InvalidPublicIpv4PoolIDMalformed extends S.TaggedErrorClass<InvalidPublicIpv4PoolIDMalformed>()(
  "InvalidPublicIpv4PoolID.Malformed",
  {},
) {}
export class InvalidPublicIpv4PoolIDNotFound extends S.TaggedErrorClass<InvalidPublicIpv4PoolIDNotFound>()(
  "InvalidPublicIpv4PoolID.NotFound",
  {},
) {}
export class InvalidRouteTableIDNotFound extends S.TaggedErrorClass<InvalidRouteTableIDNotFound>()(
  "InvalidRouteTableID.NotFound",
  {},
) {}
export class InvalidSubnetIDNotFound extends S.TaggedErrorClass<InvalidSubnetIDNotFound>()(
  "InvalidSubnetID.NotFound",
  {},
) {}
export class InvalidGroupIdMalformed extends S.TaggedErrorClass<InvalidGroupIdMalformed>()(
  "InvalidGroupId.Malformed",
  {},
) {}
export class InvalidTransitGatewayMulticastDomainIdNotFound extends S.TaggedErrorClass<InvalidTransitGatewayMulticastDomainIdNotFound>()(
  "InvalidTransitGatewayMulticastDomainId.NotFound",
  {},
) {}
export class InvalidTransitGatewayPolicyTableIdMalformed extends S.TaggedErrorClass<InvalidTransitGatewayPolicyTableIdMalformed>()(
  "InvalidTransitGatewayPolicyTableId.Malformed",
  {},
) {}
export class InvalidTransitGatewayPolicyTableIdNotFound extends S.TaggedErrorClass<InvalidTransitGatewayPolicyTableIdNotFound>()(
  "InvalidTransitGatewayPolicyTableId.NotFound",
  {},
) {}
export class OperationNotPermitted extends S.TaggedErrorClass<OperationNotPermitted>()(
  "OperationNotPermitted",
  {},
) {}
export class CidrConflict extends S.TaggedErrorClass<CidrConflict>()(
  "CidrConflict",
  {},
).pipe(C.withConflictError) {}
export class InvalidInstanceIDMalformed extends S.TaggedErrorClass<InvalidInstanceIDMalformed>()(
  "InvalidInstanceID.Malformed",
  {},
) {}
export class InvalidInternetGatewayIDNotFound extends S.TaggedErrorClass<InvalidInternetGatewayIDNotFound>()(
  "InvalidInternetGatewayID.NotFound",
  {},
) {}
export class InvalidInternetGatewayIdMalformed extends S.TaggedErrorClass<InvalidInternetGatewayIdMalformed>()(
  "InvalidInternetGatewayId.Malformed",
  {},
) {}
export class InvalidVerifiedAccessInstanceIdNotFound extends S.TaggedErrorClass<InvalidVerifiedAccessInstanceIdNotFound>()(
  "InvalidVerifiedAccessInstanceId.NotFound",
  {},
) {}
export class InvalidVolumeNotFound extends S.TaggedErrorClass<InvalidVolumeNotFound>()(
  "InvalidVolume.NotFound",
  {},
) {}
export class InvalidVpnGatewayIDNotFound extends S.TaggedErrorClass<InvalidVpnGatewayIDNotFound>()(
  "InvalidVpnGatewayID.NotFound",
  {},
) {}
export class InvalidGroupNotFound extends S.TaggedErrorClass<InvalidGroupNotFound>()(
  "InvalidGroup.NotFound",
  {},
) {}
export class InvalidBundleIDNotFound extends S.TaggedErrorClass<InvalidBundleIDNotFound>()(
  "InvalidBundleID.NotFound",
  {},
) {}
export class InvalidCapacityReservationFleetIdMalformed extends S.TaggedErrorClass<InvalidCapacityReservationFleetIdMalformed>()(
  "InvalidCapacityReservationFleetId.Malformed",
  {},
) {}
export class InvalidAction extends S.TaggedErrorClass<InvalidAction>()(
  "InvalidAction",
  {},
) {}
export class InvalidDeclarativePoliciesReportIdMalformed extends S.TaggedErrorClass<InvalidDeclarativePoliciesReportIdMalformed>()(
  "InvalidDeclarativePoliciesReportId.Malformed",
  {},
) {}
export class InvalidID extends S.TaggedErrorClass<InvalidID>()(
  "InvalidID",
  {},
) {}
export class InvalidAMIIDMalformed extends S.TaggedErrorClass<InvalidAMIIDMalformed>()(
  "InvalidAMIID.Malformed",
  {},
) {}
export class InvalidConversionTaskIdMalformed extends S.TaggedErrorClass<InvalidConversionTaskIdMalformed>()(
  "InvalidConversionTaskId.Malformed",
  {},
) {}
export class InvalidInput extends S.TaggedErrorClass<InvalidInput>()(
  "InvalidInput",
  {},
) {}
export class InvalidSpotInstanceRequestIDMalformed extends S.TaggedErrorClass<InvalidSpotInstanceRequestIDMalformed>()(
  "InvalidSpotInstanceRequestID.Malformed",
  {},
) {}
export class InvalidFpgaImageIDMalformed extends S.TaggedErrorClass<InvalidFpgaImageIDMalformed>()(
  "InvalidFpgaImageID.Malformed",
  {},
) {}
export class InvalidAMIIDNotFound extends S.TaggedErrorClass<InvalidAMIIDNotFound>()(
  "InvalidAMIID.NotFound",
  {},
) {}
export class InvalidRegion extends S.TaggedErrorClass<InvalidRegion>()(
  "InvalidRegion",
  {},
) {}
export class InvalidSnapshotNotFound extends S.TaggedErrorClass<InvalidSnapshotNotFound>()(
  "InvalidSnapshot.NotFound",
  {},
) {}
export class InvalidVolumeIDMalformed extends S.TaggedErrorClass<InvalidVolumeIDMalformed>()(
  "InvalidVolumeID.Malformed",
  {},
) {}
export class Unsupported extends S.TaggedErrorClass<Unsupported>()(
  "Unsupported",
  {},
) {}
export class InvalidCapacityReservationIdNotFound extends S.TaggedErrorClass<InvalidCapacityReservationIdNotFound>()(
  "InvalidCapacityReservationId.NotFound",
  {},
) {}
export class ParseError extends S.TaggedErrorClass<ParseError>()(
  "ParseError",
  {},
) {}
export class InvalidClientVpnEndpointIdNotFound extends S.TaggedErrorClass<InvalidClientVpnEndpointIdNotFound>()(
  "InvalidClientVpnEndpointId.NotFound",
  {},
) {}
export class InvalidPoolIDMalformed extends S.TaggedErrorClass<InvalidPoolIDMalformed>()(
  "InvalidPoolID.Malformed",
  {},
) {}
export class InvalidPoolIDNotFound extends S.TaggedErrorClass<InvalidPoolIDNotFound>()(
  "InvalidPoolID.NotFound",
  {},
) {}
export class InvalidLocalGatewayRouteTableIDMalformed extends S.TaggedErrorClass<InvalidLocalGatewayRouteTableIDMalformed>()(
  "InvalidLocalGatewayRouteTableID.Malformed",
  {},
) {}
export class InvalidLocalGatewayRouteTableIDNotFound extends S.TaggedErrorClass<InvalidLocalGatewayRouteTableIDNotFound>()(
  "InvalidLocalGatewayRouteTableID.NotFound",
  {},
) {}
export class DefaultSubnetAlreadyExistsInAvailabilityZone extends S.TaggedErrorClass<DefaultSubnetAlreadyExistsInAvailabilityZone>()(
  "DefaultSubnetAlreadyExistsInAvailabilityZone",
  {},
).pipe(C.withAlreadyExistsError) {}
export class DefaultVpcAlreadyExists extends S.TaggedErrorClass<DefaultVpcAlreadyExists>()(
  "DefaultVpcAlreadyExists",
  {},
).pipe(C.withAlreadyExistsError) {}
export class InternetGatewayLimitExceeded extends S.TaggedErrorClass<InternetGatewayLimitExceeded>()(
  "InternetGatewayLimitExceeded",
  {},
).pipe(C.withThrottlingError) {}
export class ResourceLimitExceeded extends S.TaggedErrorClass<ResourceLimitExceeded>()(
  "ResourceLimitExceeded",
  {},
).pipe(C.withThrottlingError) {}
export class InvalidIpamIdNotFound extends S.TaggedErrorClass<InvalidIpamIdNotFound>()(
  "InvalidIpamId.NotFound",
  {},
) {}
export class InvalidIpamScopeIdNotFound extends S.TaggedErrorClass<InvalidIpamScopeIdNotFound>()(
  "InvalidIpamScopeId.NotFound",
  {},
) {}
export class InvalidIpamPrefixListResolverIdMalformed extends S.TaggedErrorClass<InvalidIpamPrefixListResolverIdMalformed>()(
  "InvalidIpamPrefixListResolverId.Malformed",
  {},
) {}
export class InvalidIpamPrefixListResolverIdNotFound extends S.TaggedErrorClass<InvalidIpamPrefixListResolverIdNotFound>()(
  "InvalidIpamPrefixListResolverId.NotFound",
  {},
) {}
export class InvalidKeyPairDuplicate extends S.TaggedErrorClass<InvalidKeyPairDuplicate>()(
  "InvalidKeyPair.Duplicate",
  {},
).pipe(C.withAlreadyExistsError) {}
export class InvalidLocalGatewayIDMalformed extends S.TaggedErrorClass<InvalidLocalGatewayIDMalformed>()(
  "InvalidLocalGatewayID.Malformed",
  {},
) {}
export class InvalidLocalGatewayIDNotFound extends S.TaggedErrorClass<InvalidLocalGatewayIDNotFound>()(
  "InvalidLocalGatewayID.NotFound",
  {},
) {}
export class InvalidLocalGatewayVirtualInterfaceGroupIDMalformed extends S.TaggedErrorClass<InvalidLocalGatewayVirtualInterfaceGroupIDMalformed>()(
  "InvalidLocalGatewayVirtualInterfaceGroupID.Malformed",
  {},
) {}
export class InvalidLocalGatewayVirtualInterfaceGroupIDNotFound extends S.TaggedErrorClass<InvalidLocalGatewayVirtualInterfaceGroupIDNotFound>()(
  "InvalidLocalGatewayVirtualInterfaceGroupID.NotFound",
  {},
) {}
export class InvalidElasticIpIDNotFound extends S.TaggedErrorClass<InvalidElasticIpIDNotFound>()(
  "InvalidElasticIpID.NotFound",
  {},
) {}
export class InvalidSubnet extends S.TaggedErrorClass<InvalidSubnet>()(
  "InvalidSubnet",
  {},
) {}
export class InvalidNetworkAclIDNotFound extends S.TaggedErrorClass<InvalidNetworkAclIDNotFound>()(
  "InvalidNetworkAclID.NotFound",
  {},
) {}
export class InvalidGatewayIDNotFound extends S.TaggedErrorClass<InvalidGatewayIDNotFound>()(
  "InvalidGatewayID.NotFound",
  {},
) {}
export class InvalidPrefixListIDNotFound extends S.TaggedErrorClass<InvalidPrefixListIDNotFound>()(
  "InvalidPrefixListID.NotFound",
  {},
) {}
export class InvalidRouteTableIdMalformed extends S.TaggedErrorClass<InvalidRouteTableIdMalformed>()(
  "InvalidRouteTableId.Malformed",
  {},
) {}
export class InvalidVpcEndpointIdNotFound extends S.TaggedErrorClass<InvalidVpcEndpointIdNotFound>()(
  "InvalidVpcEndpointId.NotFound",
  {},
) {}
export class InvalidRouteServerIdNotAssociated extends S.TaggedErrorClass<InvalidRouteServerIdNotAssociated>()(
  "InvalidRouteServerId.NotAssociated",
  {},
) {}
export class InvalidGroupDuplicate extends S.TaggedErrorClass<InvalidGroupDuplicate>()(
  "InvalidGroup.Duplicate",
  {},
).pipe(C.withAlreadyExistsError) {}
export class VPCIdNotSpecified extends S.TaggedErrorClass<VPCIdNotSpecified>()(
  "VPCIdNotSpecified",
  {},
) {}
export class InaccessibleStorageLocation extends S.TaggedErrorClass<InaccessibleStorageLocation>()(
  "InaccessibleStorageLocation",
  {},
) {}
export class TransitGatewayLimitExceeded extends S.TaggedErrorClass<TransitGatewayLimitExceeded>()(
  "TransitGatewayLimitExceeded",
  {},
).pipe(C.withThrottlingError) {}
export class IncorrectState extends S.TaggedErrorClass<IncorrectState>()(
  "IncorrectState",
  {},
) {}
export class InvalidTransitGatewayIDNotFound extends S.TaggedErrorClass<InvalidTransitGatewayIDNotFound>()(
  "InvalidTransitGatewayID.NotFound",
  {},
) {}
export class InvalidTransitGatewayIDMalformed extends S.TaggedErrorClass<InvalidTransitGatewayIDMalformed>()(
  "InvalidTransitGatewayID.Malformed",
  {},
) {}
export class InvalidTransitGatewayAttachmentIDMalformed extends S.TaggedErrorClass<InvalidTransitGatewayAttachmentIDMalformed>()(
  "InvalidTransitGatewayAttachmentID.Malformed",
  {},
) {}
export class VerifiedAccessInstanceLimitExceeded extends S.TaggedErrorClass<VerifiedAccessInstanceLimitExceeded>()(
  "VerifiedAccessInstanceLimitExceeded",
  {},
).pipe(C.withThrottlingError) {}
export class InvalidZoneNotFound extends S.TaggedErrorClass<InvalidZoneNotFound>()(
  "InvalidZone.NotFound",
  {},
) {}
export class VpcLimitExceeded extends S.TaggedErrorClass<VpcLimitExceeded>()(
  "VpcLimitExceeded",
  {},
).pipe(C.withThrottlingError) {}
export class InvalidServiceName extends S.TaggedErrorClass<InvalidServiceName>()(
  "InvalidServiceName",
  {},
) {}
export class InvalidVpcIdNotFound extends S.TaggedErrorClass<InvalidVpcIdNotFound>()(
  "InvalidVpcId.NotFound",
  {},
) {}
export class InvalidCustomerGatewayIDNotFound extends S.TaggedErrorClass<InvalidCustomerGatewayIDNotFound>()(
  "InvalidCustomerGatewayID.NotFound",
  {},
) {}
export class InvalidCapacityManagerDataExportIdMalformed extends S.TaggedErrorClass<InvalidCapacityManagerDataExportIdMalformed>()(
  "InvalidCapacityManagerDataExportId.Malformed",
  {},
) {}
export class InvalidCapacityManagerDataExportIdNotFound extends S.TaggedErrorClass<InvalidCapacityManagerDataExportIdNotFound>()(
  "InvalidCapacityManagerDataExportId.NotFound",
  {},
) {}
export class InvalidCarrierGatewayIDMalformed extends S.TaggedErrorClass<InvalidCarrierGatewayIDMalformed>()(
  "InvalidCarrierGatewayID.Malformed",
  {},
) {}
export class InvalidCarrierGatewayIDNotFound extends S.TaggedErrorClass<InvalidCarrierGatewayIDNotFound>()(
  "InvalidCarrierGatewayID.NotFound",
  {},
) {}
export class InvalidCidrBlockMalformed extends S.TaggedErrorClass<InvalidCidrBlockMalformed>()(
  "InvalidCidrBlock.Malformed",
  {},
) {}
export class InvalidIpv4PoolCoipIdMalformed extends S.TaggedErrorClass<InvalidIpv4PoolCoipIdMalformed>()(
  "InvalidIpv4PoolCoipId.Malformed",
  {},
) {}
export class InvalidCustomerGatewayIdMalformed extends S.TaggedErrorClass<InvalidCustomerGatewayIdMalformed>()(
  "InvalidCustomerGatewayId.Malformed",
  {},
) {}
export class DependencyViolation extends S.TaggedErrorClass<DependencyViolation>()(
  "DependencyViolation",
  {},
).pipe(C.withDependencyViolationError) {}
export class InvalidDhcpOptionIDNotFound extends S.TaggedErrorClass<InvalidDhcpOptionIDNotFound>()(
  "InvalidDhcpOptionID.NotFound",
  {},
) {}
export class InvalidDhcpOptionsIDNotFound extends S.TaggedErrorClass<InvalidDhcpOptionsIDNotFound>()(
  "InvalidDhcpOptionsID.NotFound",
  {},
) {}
export class InvalidEgressOnlyInternetGatewayIdNotFound extends S.TaggedErrorClass<InvalidEgressOnlyInternetGatewayIdNotFound>()(
  "InvalidEgressOnlyInternetGatewayId.NotFound",
  {},
) {}
export class MalformedGatewayIDNotFound extends S.TaggedErrorClass<MalformedGatewayIDNotFound>()(
  "MalformedGatewayID.NotFound",
  {},
) {}
export class InvalidFleetIdMalformed extends S.TaggedErrorClass<InvalidFleetIdMalformed>()(
  "InvalidFleetId.Malformed",
  {},
) {}
export class InvalidFlowLogIdNotFound extends S.TaggedErrorClass<InvalidFlowLogIdNotFound>()(
  "InvalidFlowLogId.NotFound",
  {},
) {}
export class InvalidImageUsageReportIdMalformed extends S.TaggedErrorClass<InvalidImageUsageReportIdMalformed>()(
  "InvalidImageUsageReportId.Malformed",
  {},
) {}
export class InvalidInstanceConnectEndpointIdMalformed extends S.TaggedErrorClass<InvalidInstanceConnectEndpointIdMalformed>()(
  "InvalidInstanceConnectEndpointId.Malformed",
  {},
) {}
export class InvalidInstanceConnectEndpointIdNotFound extends S.TaggedErrorClass<InvalidInstanceConnectEndpointIdNotFound>()(
  "InvalidInstanceConnectEndpointId.NotFound",
  {},
) {}
export class InvalidState extends S.TaggedErrorClass<InvalidState>()(
  "InvalidState",
  {},
) {}
export class InvalidInstanceEventWindowIDNotFound extends S.TaggedErrorClass<InvalidInstanceEventWindowIDNotFound>()(
  "InvalidInstanceEventWindowIDNotFound",
  {},
) {}
export class InvalidIpamExternalResourceVerificationTokenIdMalformed extends S.TaggedErrorClass<InvalidIpamExternalResourceVerificationTokenIdMalformed>()(
  "InvalidIpamExternalResourceVerificationTokenId.Malformed",
  {},
) {}
export class InvalidIpamExternalResourceVerificationTokenIdNotFound extends S.TaggedErrorClass<InvalidIpamExternalResourceVerificationTokenIdNotFound>()(
  "InvalidIpamExternalResourceVerificationTokenId.NotFound",
  {},
) {}
export class InvalidIpamPolicyIdMalformed extends S.TaggedErrorClass<InvalidIpamPolicyIdMalformed>()(
  "InvalidIpamPolicyId.Malformed",
  {},
) {}
export class InvalidIpamPolicyIdNotFound extends S.TaggedErrorClass<InvalidIpamPolicyIdNotFound>()(
  "InvalidIpamPolicyId.NotFound",
  {},
) {}
export class InvalidIpamPrefixListResolverTargetIdMalformed extends S.TaggedErrorClass<InvalidIpamPrefixListResolverTargetIdMalformed>()(
  "InvalidIpamPrefixListResolverTargetId.Malformed",
  {},
) {}
export class InvalidLaunchTemplateNameNotFoundException extends S.TaggedErrorClass<InvalidLaunchTemplateNameNotFoundException>()(
  "InvalidLaunchTemplateName.NotFoundException",
  {},
) {}
export class InvalidLocalGatewayRouteTableVirtualInterfaceGroupAssociationIDMalformed extends S.TaggedErrorClass<InvalidLocalGatewayRouteTableVirtualInterfaceGroupAssociationIDMalformed>()(
  "InvalidLocalGatewayRouteTableVirtualInterfaceGroupAssociationID.Malformed",
  {},
) {}
export class InvalidLocalGatewayRouteTableVirtualInterfaceGroupAssociationIDNotFound extends S.TaggedErrorClass<InvalidLocalGatewayRouteTableVirtualInterfaceGroupAssociationIDNotFound>()(
  "InvalidLocalGatewayRouteTableVirtualInterfaceGroupAssociationID.NotFound",
  {},
) {}
export class InvalidLocalGatewayRouteTableVpcAssociationIDMalformed extends S.TaggedErrorClass<InvalidLocalGatewayRouteTableVpcAssociationIDMalformed>()(
  "InvalidLocalGatewayRouteTableVpcAssociationID.Malformed",
  {},
) {}
export class InvalidLocalGatewayRouteTableVpcAssociationIDNotFound extends S.TaggedErrorClass<InvalidLocalGatewayRouteTableVpcAssociationIDNotFound>()(
  "InvalidLocalGatewayRouteTableVpcAssociationID.NotFound",
  {},
) {}
export class InvalidLocalGatewayVirtualInterfaceIDMalformed extends S.TaggedErrorClass<InvalidLocalGatewayVirtualInterfaceIDMalformed>()(
  "InvalidLocalGatewayVirtualInterfaceID.Malformed",
  {},
) {}
export class InvalidLocalGatewayVirtualInterfaceIDNotFound extends S.TaggedErrorClass<InvalidLocalGatewayVirtualInterfaceIDNotFound>()(
  "InvalidLocalGatewayVirtualInterfaceID.NotFound",
  {},
) {}
export class InvalidPrefixListIdMalformed extends S.TaggedErrorClass<InvalidPrefixListIdMalformed>()(
  "InvalidPrefixListId.Malformed",
  {},
) {}
export class InvalidNetworkAclIdMalformed extends S.TaggedErrorClass<InvalidNetworkAclIdMalformed>()(
  "InvalidNetworkAclId.Malformed",
  {},
) {}
export class InvalidNetworkAclEntryNotFound extends S.TaggedErrorClass<InvalidNetworkAclEntryNotFound>()(
  "InvalidNetworkAclEntry.NotFound",
  {},
) {}
export class InvalidNetworkInsightsAccessScopeIdNotFound extends S.TaggedErrorClass<InvalidNetworkInsightsAccessScopeIdNotFound>()(
  "InvalidNetworkInsightsAccessScopeId.NotFound",
  {},
) {}
export class InvalidNetworkInterfaceInUse extends S.TaggedErrorClass<InvalidNetworkInterfaceInUse>()(
  "InvalidNetworkInterface.InUse",
  {},
).pipe(C.withDependencyViolationError) {}
export class InvalidPermissionIDMalformed extends S.TaggedErrorClass<InvalidPermissionIDMalformed>()(
  "InvalidPermissionID.Malformed",
  {},
) {}
export class InvalidPermissionIDNotFound extends S.TaggedErrorClass<InvalidPermissionIDNotFound>()(
  "InvalidPermissionID.NotFound",
  {},
) {}
export class InvalidPlacementGroupUnknown extends S.TaggedErrorClass<InvalidPlacementGroupUnknown>()(
  "InvalidPlacementGroup.Unknown",
  {},
) {}
export class InvalidPublicIpv4PoolNotFound extends S.TaggedErrorClass<InvalidPublicIpv4PoolNotFound>()(
  "InvalidPublicIpv4Pool.NotFound",
  {},
) {}
export class InvalidRouteNotFound extends S.TaggedErrorClass<InvalidRouteNotFound>()(
  "InvalidRoute.NotFound",
  {},
) {}
export class InvalidRouteServerEndpointIdNotFound extends S.TaggedErrorClass<InvalidRouteServerEndpointIdNotFound>()(
  "InvalidRouteServerEndpointId.NotFound",
  {},
) {}
export class InvalidRouteServerPeerIdMalformed extends S.TaggedErrorClass<InvalidRouteServerPeerIdMalformed>()(
  "InvalidRouteServerPeerId.Malformed",
  {},
) {}
export class InvalidRouteServerPeerIdNotFound extends S.TaggedErrorClass<InvalidRouteServerPeerIdNotFound>()(
  "InvalidRouteServerPeerId.NotFound",
  {},
) {}
export class CannotDelete extends S.TaggedErrorClass<CannotDelete>()(
  "CannotDelete",
  {},
) {}
export class InvalidSnapshotIDMalformed extends S.TaggedErrorClass<InvalidSnapshotIDMalformed>()(
  "InvalidSnapshotID.Malformed",
  {},
) {}
export class InvalidSubnetIdMalformed extends S.TaggedErrorClass<InvalidSubnetIdMalformed>()(
  "InvalidSubnetId.Malformed",
  {},
) {}
export class InvalidSubnetCidrReservationIDMalformed extends S.TaggedErrorClass<InvalidSubnetCidrReservationIDMalformed>()(
  "InvalidSubnetCidrReservationID.Malformed",
  {},
) {}
export class InvalidSubnetCidrReservationIDNotFound extends S.TaggedErrorClass<InvalidSubnetCidrReservationIDNotFound>()(
  "InvalidSubnetCidrReservationID.NotFound",
  {},
) {}
export class InvalidTrafficMirrorFilterIdNotFound extends S.TaggedErrorClass<InvalidTrafficMirrorFilterIdNotFound>()(
  "InvalidTrafficMirrorFilterId.NotFound",
  {},
) {}
export class InvalidTrafficMirrorFilterRuleIdNotFound extends S.TaggedErrorClass<InvalidTrafficMirrorFilterRuleIdNotFound>()(
  "InvalidTrafficMirrorFilterRuleId.NotFound",
  {},
) {}
export class InvalidTrafficMirrorSessionIdNotFound extends S.TaggedErrorClass<InvalidTrafficMirrorSessionIdNotFound>()(
  "InvalidTrafficMirrorSessionId.NotFound",
  {},
) {}
export class InvalidTrafficMirrorTargetIdNotFound extends S.TaggedErrorClass<InvalidTrafficMirrorTargetIdNotFound>()(
  "InvalidTrafficMirrorTargetId.NotFound",
  {},
) {}
export class InvalidTransitGatewayConnectPeerIDMalformed extends S.TaggedErrorClass<InvalidTransitGatewayConnectPeerIDMalformed>()(
  "InvalidTransitGatewayConnectPeerID.Malformed",
  {},
) {}
export class InvalidTransitGatewayConnectPeerIDNotFound extends S.TaggedErrorClass<InvalidTransitGatewayConnectPeerIDNotFound>()(
  "InvalidTransitGatewayConnectPeerID.NotFound",
  {},
) {}
export class InvalidTransitGatewayMeteringPolicyIdNotFound extends S.TaggedErrorClass<InvalidTransitGatewayMeteringPolicyIdNotFound>()(
  "InvalidTransitGatewayMeteringPolicyId.NotFound",
  {},
) {}
export class InvalidTransitGatewayMeteringPolicyIdMalformedException extends S.TaggedErrorClass<InvalidTransitGatewayMeteringPolicyIdMalformedException>()(
  "InvalidTransitGatewayMeteringPolicyIdMalformedException",
  {},
) {}
export class InvalidTransitGatewayMulticastDomainIdMalformed extends S.TaggedErrorClass<InvalidTransitGatewayMulticastDomainIdMalformed>()(
  "InvalidTransitGatewayMulticastDomainId.Malformed",
  {},
) {}
export class InvalidTransitGatewayRouteTableAnnouncementIdMalformed extends S.TaggedErrorClass<InvalidTransitGatewayRouteTableAnnouncementIdMalformed>()(
  "InvalidTransitGatewayRouteTableAnnouncementId.Malformed",
  {},
) {}
export class InvalidVerifiedAccessEndpointIdNotFound extends S.TaggedErrorClass<InvalidVerifiedAccessEndpointIdNotFound>()(
  "InvalidVerifiedAccessEndpointId.NotFound",
  {},
) {}
export class InvalidVerifiedAccessGroupIdNotFound extends S.TaggedErrorClass<InvalidVerifiedAccessGroupIdNotFound>()(
  "InvalidVerifiedAccessGroupId.NotFound",
  {},
) {}
export class InvalidVerifiedAccessTrustProviderIdNotFound extends S.TaggedErrorClass<InvalidVerifiedAccessTrustProviderIdNotFound>()(
  "InvalidVerifiedAccessTrustProviderId.NotFound",
  {},
) {}
export class RequestError extends S.TaggedErrorClass<RequestError>()(
  "RequestError",
  {},
) {}
export class VpcBlockPublicAccessExclusionIdMalformed extends S.TaggedErrorClass<VpcBlockPublicAccessExclusionIdMalformed>()(
  "VpcBlockPublicAccessExclusionId.Malformed",
  {},
) {}
export class InvalidVpcEncryptionControlIdMalformed extends S.TaggedErrorClass<InvalidVpcEncryptionControlIdMalformed>()(
  "InvalidVpcEncryptionControlId.Malformed",
  {},
) {}
export class InvalidVpcEncryptionControlIdNotFound extends S.TaggedErrorClass<InvalidVpcEncryptionControlIdNotFound>()(
  "InvalidVpcEncryptionControlId.NotFound",
  {},
) {}
export class InvalidVpnConcentratorIDMalformed extends S.TaggedErrorClass<InvalidVpnConcentratorIDMalformed>()(
  "InvalidVpnConcentratorID.Malformed",
  {},
) {}
export class InvalidVpnConnectionIDNotFound extends S.TaggedErrorClass<InvalidVpnConnectionIDNotFound>()(
  "InvalidVpnConnectionID.NotFound",
  {},
) {}
export class InvalidRouteMalformed extends S.TaggedErrorClass<InvalidRouteMalformed>()(
  "InvalidRoute.Malformed",
  {},
) {}
export class InvalidCapacityBlockIdMalformed extends S.TaggedErrorClass<InvalidCapacityBlockIdMalformed>()(
  "InvalidCapacityBlockId.Malformed",
  {},
) {}
export class InvalidEgressOnlyInternetGatewayIdMalformed extends S.TaggedErrorClass<InvalidEgressOnlyInternetGatewayIdMalformed>()(
  "InvalidEgressOnlyInternetGatewayId.Malformed",
  {},
) {}
export class UnsupportedOperation extends S.TaggedErrorClass<UnsupportedOperation>()(
  "UnsupportedOperation",
  {},
) {}
export class InvalidExportTaskIDMalformed extends S.TaggedErrorClass<InvalidExportTaskIDMalformed>()(
  "InvalidExportTaskID.Malformed",
  {},
) {}
export class InvalidFpgaImageIDNotFound extends S.TaggedErrorClass<InvalidFpgaImageIDNotFound>()(
  "InvalidFpgaImageID.NotFound",
  {},
) {}
export class InvalidHostReservationOfferingIdMalformed extends S.TaggedErrorClass<InvalidHostReservationOfferingIdMalformed>()(
  "InvalidHostReservationOfferingId.Malformed",
  {},
) {}
export class InvalidHostIDMalformed extends S.TaggedErrorClass<InvalidHostIDMalformed>()(
  "InvalidHostID.Malformed",
  {},
) {}
export class InvalidTargetArnUnknown extends S.TaggedErrorClass<InvalidTargetArnUnknown>()(
  "InvalidTargetArn.Unknown",
  {},
) {}
export class InvalidIpamResourceDiscoveryAssociationIdNotFound extends S.TaggedErrorClass<InvalidIpamResourceDiscoveryAssociationIdNotFound>()(
  "InvalidIpamResourceDiscoveryAssociationId.NotFound",
  {},
) {}
export class InvalidIpv6PoolIDNotFound extends S.TaggedErrorClass<InvalidIpv6PoolIDNotFound>()(
  "InvalidIpv6PoolID.NotFound",
  {},
) {}
export class InvalidKeyPairNotFound extends S.TaggedErrorClass<InvalidKeyPairNotFound>()(
  "InvalidKeyPair.NotFound",
  {},
) {}
export class InvalidLaunchTemplateIdMalformed extends S.TaggedErrorClass<InvalidLaunchTemplateIdMalformed>()(
  "InvalidLaunchTemplateId.Malformed",
  {},
) {}
export class FilterLimitExceeded extends S.TaggedErrorClass<FilterLimitExceeded>()(
  "FilterLimitExceeded",
  {},
).pipe(C.withThrottlingError) {}
export class InvalidOutpostLagIDMalformed extends S.TaggedErrorClass<InvalidOutpostLagIDMalformed>()(
  "InvalidOutpostLagID.Malformed",
  {},
) {}
export class InvalidPrefixListIdNotFound extends S.TaggedErrorClass<InvalidPrefixListIdNotFound>()(
  "InvalidPrefixListId.NotFound",
  {},
) {}
export class InvalidSecurityGroupRuleIdNotFound extends S.TaggedErrorClass<InvalidSecurityGroupRuleIdNotFound>()(
  "InvalidSecurityGroupRuleId.NotFound",
  {},
) {}
export class InvalidServiceLinkVirtualInterfaceIDMalformed extends S.TaggedErrorClass<InvalidServiceLinkVirtualInterfaceIDMalformed>()(
  "InvalidServiceLinkVirtualInterfaceID.Malformed",
  {},
) {}
export class InvalidUserIDMalformed extends S.TaggedErrorClass<InvalidUserIDMalformed>()(
  "InvalidUserID.Malformed",
  {},
) {}
export class InvalidSpotDatafeedNotFound extends S.TaggedErrorClass<InvalidSpotDatafeedNotFound>()(
  "InvalidSpotDatafeed.NotFound",
  {},
) {}
export class InvalidConnectionNotification extends S.TaggedErrorClass<InvalidConnectionNotification>()(
  "InvalidConnectionNotification",
  {},
) {}
export class InvalidVpcEndpointServiceIdMalformed extends S.TaggedErrorClass<InvalidVpcEndpointServiceIdMalformed>()(
  "InvalidVpcEndpointServiceId.Malformed",
  {},
) {}
export class InvalidVpnConcentratorIdMalformed extends S.TaggedErrorClass<InvalidVpnConcentratorIdMalformed>()(
  "InvalidVpnConcentratorId.Malformed",
  {},
) {}
export class GatewayNotAttached extends S.TaggedErrorClass<GatewayNotAttached>()(
  "Gateway.NotAttached",
  {},
) {}
export class InvalidAttachmentIDNotFound extends S.TaggedErrorClass<InvalidAttachmentIDNotFound>()(
  "InvalidAttachmentID.NotFound",
  {},
) {}
export class InvalidNetworkInterfaceAttachmentIdMalformed extends S.TaggedErrorClass<InvalidNetworkInterfaceAttachmentIdMalformed>()(
  "InvalidNetworkInterfaceAttachmentId.Malformed",
  {},
) {}
export class CapacityManagerDisabled extends S.TaggedErrorClass<CapacityManagerDisabled>()(
  "CapacityManager.Disabled",
  {},
) {}
export class InvalidAssociationIDNotFound extends S.TaggedErrorClass<InvalidAssociationIDNotFound>()(
  "InvalidAssociationID.NotFound",
  {},
) {}
export class InvalidIpamResourceDiscoveryAssociationIdMalformed extends S.TaggedErrorClass<InvalidIpamResourceDiscoveryAssociationIdMalformed>()(
  "InvalidIpamResourceDiscoveryAssociationId.Malformed",
  {},
) {}
export class InvalidSubnetCidrBlockAssociationIDNotFound extends S.TaggedErrorClass<InvalidSubnetCidrBlockAssociationIDNotFound>()(
  "InvalidSubnetCidrBlockAssociationID.NotFound",
  {},
) {}
export class InvalidSubnetCidrBlockAssociationIdMalformed extends S.TaggedErrorClass<InvalidSubnetCidrBlockAssociationIdMalformed>()(
  "InvalidSubnetCidrBlockAssociationId.Malformed",
  {},
) {}
export class InvalidVpcCidrBlockAssociationIDNotFound extends S.TaggedErrorClass<InvalidVpcCidrBlockAssociationIDNotFound>()(
  "InvalidVpcCidrBlockAssociationID.NotFound",
  {},
) {}
export class InvalidVpcCidrBlockAssociationIdMalformed extends S.TaggedErrorClass<InvalidVpcCidrBlockAssociationIdMalformed>()(
  "InvalidVpcCidrBlockAssociationId.Malformed",
  {},
) {}
export class InvalidVpcCidrBlockAssociationIdErrorNotFound extends S.TaggedErrorClass<InvalidVpcCidrBlockAssociationIdErrorNotFound>()(
  "InvalidVpcCidrBlockAssociationIdError.NotFound",
  {},
) {}
export class UnauthorizedOperation extends S.TaggedErrorClass<UnauthorizedOperation>()(
  "UnauthorizedOperation",
  {},
).pipe(C.withAuthError) {}
export class InvalidIpv6PoolIDMalformed extends S.TaggedErrorClass<InvalidIpv6PoolIDMalformed>()(
  "InvalidIpv6PoolID.Malformed",
  {},
) {}
export class InvalidVpnConnectionDeviceTypeIdNotFound extends S.TaggedErrorClass<InvalidVpnConnectionDeviceTypeIdNotFound>()(
  "InvalidVpnConnectionDeviceTypeId.NotFound",
  {},
) {}
export class InvalidVpnConnectionId extends S.TaggedErrorClass<InvalidVpnConnectionId>()(
  "InvalidVpnConnectionId",
  {},
) {}
export class MissingRequiredParameter extends S.TaggedErrorClass<MissingRequiredParameter>()(
  "MissingRequiredParameter",
  {},
) {}
export class InvalidInstanceEventWindowIdMalformed extends S.TaggedErrorClass<InvalidInstanceEventWindowIdMalformed>()(
  "InvalidInstanceEventWindowId.Malformed",
  {},
) {}
export class InvalidIpamScopeIdMalformed extends S.TaggedErrorClass<InvalidIpamScopeIdMalformed>()(
  "InvalidIpamScopeId.Malformed",
  {},
) {}
export class UnknownResource extends S.TaggedErrorClass<UnknownResource>()(
  "UnknownResource",
  {},
) {}
export class InvalidPurchaseTokenMalformed extends S.TaggedErrorClass<InvalidPurchaseTokenMalformed>()(
  "InvalidPurchaseToken.Malformed",
  {},
) {}
export class InvalidIPAddressInUse extends S.TaggedErrorClass<InvalidIPAddressInUse>()(
  "InvalidIPAddress.InUse",
  {},
).pipe(C.withDependencyViolationError) {}
export class InvalidRouteTableAssociationIdMalformed extends S.TaggedErrorClass<InvalidRouteTableAssociationIdMalformed>()(
  "InvalidRouteTableAssociationId.Malformed",
  {},
) {}
export class InvalidPermissionNotFound extends S.TaggedErrorClass<InvalidPermissionNotFound>()(
  "InvalidPermission.NotFound",
  {},
) {}
export class InvalidSecurityGroupRuleIdMalformed extends S.TaggedErrorClass<InvalidSecurityGroupRuleIdMalformed>()(
  "InvalidSecurityGroupRuleId.Malformed",
  {},
) {}
export class UnknownParameter extends S.TaggedErrorClass<UnknownParameter>()(
  "UnknownParameter",
  {},
) {}
export class InvalidScheduledInstance extends S.TaggedErrorClass<InvalidScheduledInstance>()(
  "InvalidScheduledInstance",
  {},
) {}
export class DeclarativePoliciesAccessDenied extends S.TaggedErrorClass<DeclarativePoliciesAccessDenied>()(
  "DeclarativePoliciesAccessDenied",
  {},
).pipe(C.withAuthError) {}
export class IdempotentParameterMismatch extends S.TaggedErrorClass<IdempotentParameterMismatch>()(
  "IdempotentParameterMismatch",
  {},
).pipe(C.withConflictError) {}

//# Operations
export type AcceptAddressTransferError =
  | RequestLimitExceeded
  | InvalidAddressMalformed
  | InvalidAddressNotFound
  | CommonErrors;
/**
 * Accepts an Elastic IP address transfer. For more information, see Accept a transferred Elastic IP address in the *Amazon VPC User Guide*.
 */
export const acceptAddressTransfer: API.OperationMethod<
  AcceptAddressTransferRequest,
  AcceptAddressTransferResult,
  AcceptAddressTransferError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AcceptAddressTransferRequest,
  output: AcceptAddressTransferResult,
  errors: [
    RequestLimitExceeded,
    InvalidAddressMalformed,
    InvalidAddressNotFound,
  ],
}));
export type AcceptCapacityReservationBillingOwnershipError =
  | RequestLimitExceeded
  | InvalidCapacityReservationIdMalformed
  | CommonErrors;
/**
 * Accepts a request to assign billing of the available capacity of a shared Capacity
 * Reservation to your account. For more information, see Billing assignment for shared
 * Amazon EC2 Capacity Reservations.
 */
export const acceptCapacityReservationBillingOwnership: API.OperationMethod<
  AcceptCapacityReservationBillingOwnershipRequest,
  AcceptCapacityReservationBillingOwnershipResult,
  AcceptCapacityReservationBillingOwnershipError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AcceptCapacityReservationBillingOwnershipRequest,
  output: AcceptCapacityReservationBillingOwnershipResult,
  errors: [RequestLimitExceeded, InvalidCapacityReservationIdMalformed],
}));
export type AcceptReservedInstancesExchangeQuoteError =
  | RequestLimitExceeded
  | InvalidReservedInstancesIDNotFound
  | CommonErrors;
/**
 * Accepts the Convertible Reserved Instance exchange quote described in the GetReservedInstancesExchangeQuote call.
 */
export const acceptReservedInstancesExchangeQuote: API.OperationMethod<
  AcceptReservedInstancesExchangeQuoteRequest,
  AcceptReservedInstancesExchangeQuoteResult,
  AcceptReservedInstancesExchangeQuoteError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AcceptReservedInstancesExchangeQuoteRequest,
  output: AcceptReservedInstancesExchangeQuoteResult,
  errors: [RequestLimitExceeded, InvalidReservedInstancesIDNotFound],
}));
export type AcceptTransitGatewayMulticastDomainAssociationsError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Accepts a request to associate subnets with a transit gateway multicast domain.
 */
export const acceptTransitGatewayMulticastDomainAssociations: API.OperationMethod<
  AcceptTransitGatewayMulticastDomainAssociationsRequest,
  AcceptTransitGatewayMulticastDomainAssociationsResult,
  AcceptTransitGatewayMulticastDomainAssociationsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AcceptTransitGatewayMulticastDomainAssociationsRequest,
  output: AcceptTransitGatewayMulticastDomainAssociationsResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type AcceptTransitGatewayPeeringAttachmentError =
  | RequestLimitExceeded
  | InvalidTransitGatewayAttachmentIDNotFound
  | CommonErrors;
/**
 * Accepts a transit gateway peering attachment request. The peering attachment must be
 * in the `pendingAcceptance` state.
 */
export const acceptTransitGatewayPeeringAttachment: API.OperationMethod<
  AcceptTransitGatewayPeeringAttachmentRequest,
  AcceptTransitGatewayPeeringAttachmentResult,
  AcceptTransitGatewayPeeringAttachmentError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AcceptTransitGatewayPeeringAttachmentRequest,
  output: AcceptTransitGatewayPeeringAttachmentResult,
  errors: [RequestLimitExceeded, InvalidTransitGatewayAttachmentIDNotFound],
}));
export type AcceptTransitGatewayVpcAttachmentError =
  | RequestLimitExceeded
  | InvalidTransitGatewayAttachmentIDNotFound
  | CommonErrors;
/**
 * Accepts a request to attach a VPC to a transit gateway.
 *
 * The VPC attachment must be in the `pendingAcceptance` state.
 * Use DescribeTransitGatewayVpcAttachments to view your pending VPC attachment requests.
 * Use RejectTransitGatewayVpcAttachment to reject a VPC attachment request.
 */
export const acceptTransitGatewayVpcAttachment: API.OperationMethod<
  AcceptTransitGatewayVpcAttachmentRequest,
  AcceptTransitGatewayVpcAttachmentResult,
  AcceptTransitGatewayVpcAttachmentError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AcceptTransitGatewayVpcAttachmentRequest,
  output: AcceptTransitGatewayVpcAttachmentResult,
  errors: [RequestLimitExceeded, InvalidTransitGatewayAttachmentIDNotFound],
}));
export type AcceptVpcEndpointConnectionsError =
  | RequestLimitExceeded
  | InvalidParameter
  | InvalidVpcEndpointServiceIdNotFound
  | CommonErrors;
/**
 * Accepts connection requests to your VPC endpoint service.
 */
export const acceptVpcEndpointConnections: API.OperationMethod<
  AcceptVpcEndpointConnectionsRequest,
  AcceptVpcEndpointConnectionsResult,
  AcceptVpcEndpointConnectionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AcceptVpcEndpointConnectionsRequest,
  output: AcceptVpcEndpointConnectionsResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameter,
    InvalidVpcEndpointServiceIdNotFound,
  ],
}));
export type AcceptVpcPeeringConnectionError =
  | RequestLimitExceeded
  | InvalidVpcPeeringConnectionIDNotFound
  | InvalidVpcPeeringConnectionIdNotFound
  | CommonErrors;
/**
 * Accept a VPC peering connection request. To accept a request, the VPC peering connection must
 * be in the `pending-acceptance` state, and you must be the owner of the peer VPC.
 * Use DescribeVpcPeeringConnections to view your outstanding VPC
 * peering connection requests.
 *
 * For an inter-Region VPC peering connection request, you must accept the VPC peering
 * connection in the Region of the accepter VPC.
 */
export const acceptVpcPeeringConnection: API.OperationMethod<
  AcceptVpcPeeringConnectionRequest,
  AcceptVpcPeeringConnectionResult,
  AcceptVpcPeeringConnectionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AcceptVpcPeeringConnectionRequest,
  output: AcceptVpcPeeringConnectionResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcPeeringConnectionIDNotFound,
    InvalidVpcPeeringConnectionIdNotFound,
  ],
}));
export type AdvertiseByoipCidrError = RequestLimitExceeded | CommonErrors;
/**
 * Advertises an IPv4 or IPv6 address range that is provisioned for use with your Amazon Web Services resources through
 * bring your own IP addresses (BYOIP).
 *
 * You can perform this operation at most once every 10 seconds, even if you specify different
 * address ranges each time.
 *
 * We recommend that you stop advertising the BYOIP CIDR from other locations when you advertise
 * it from Amazon Web Services. To minimize down time, you can configure your Amazon Web Services resources to use an address from a
 * BYOIP CIDR before it is advertised, and then simultaneously stop advertising it from the current
 * location and start advertising it through Amazon Web Services.
 *
 * It can take a few minutes before traffic to the specified addresses starts routing to Amazon Web Services
 * because of BGP propagation delays.
 */
export const advertiseByoipCidr: API.OperationMethod<
  AdvertiseByoipCidrRequest,
  AdvertiseByoipCidrResult,
  AdvertiseByoipCidrError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AdvertiseByoipCidrRequest,
  output: AdvertiseByoipCidrResult,
  errors: [RequestLimitExceeded],
}));
export type AllocateAddressError =
  | RequestLimitExceeded
  | AddressLimitExceeded
  | CommonErrors;
/**
 * Allocates an Elastic IP address to your Amazon Web Services account. After you allocate the Elastic IP address you can associate
 * it with an instance or network interface. After you release an Elastic IP address, it is released to the IP address
 * pool and can be allocated to a different Amazon Web Services account.
 *
 * You can allocate an Elastic IP address from one of the following address pools:
 *
 * - Amazon's pool of IPv4 addresses
 *
 * - Public IPv4 address range that you own and bring to your Amazon Web Services account using
 * Bring Your Own IP Addresses (BYOIP)
 *
 * - An IPv4 IPAM pool with an Amazon-provided or BYOIP public IPv4 address range
 *
 * - IPv4 addresses from your on-premises network made available for use with an Outpost
 * using a customer-owned IP address
 * pool (CoIP pool)
 *
 * For more information, see Elastic IP Addresses in the *Amazon EC2 User Guide*.
 *
 * If you release an Elastic IP address, you might be able to recover it. You cannot recover
 * an Elastic IP address that you released after it is allocated to another Amazon Web Services account. To attempt to recover an Elastic IP address that you released, specify
 * it in this operation.
 *
 * You can allocate a carrier IP address which is a public IP address from a telecommunication carrier,
 * to a network interface which resides in a subnet in a Wavelength Zone (for example an EC2 instance).
 */
export const allocateAddress: API.OperationMethod<
  AllocateAddressRequest,
  AllocateAddressResult,
  AllocateAddressError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AllocateAddressRequest,
  output: AllocateAddressResult,
  errors: [RequestLimitExceeded, AddressLimitExceeded],
}));
export type AllocateHostsError =
  | RequestLimitExceeded
  | InvalidHostConfiguration
  | InvalidRequest
  | CommonErrors;
/**
 * Allocates a Dedicated Host to your account. At a minimum, specify the supported
 * instance type or instance family, the Availability Zone in which to allocate the host,
 * and the number of hosts to allocate.
 */
export const allocateHosts: API.OperationMethod<
  AllocateHostsRequest,
  AllocateHostsResult,
  AllocateHostsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AllocateHostsRequest,
  output: AllocateHostsResult,
  errors: [RequestLimitExceeded, InvalidHostConfiguration, InvalidRequest],
}));
export type AllocateIpamPoolCidrError =
  | RequestLimitExceeded
  | InvalidIpamPoolIdNotFound
  | CommonErrors;
/**
 * Allocate a CIDR from an IPAM pool. The Region you use should be the IPAM pool locale. The locale is the Amazon Web Services Region where this IPAM pool is available for allocations.
 *
 * In IPAM, an allocation is a CIDR assignment from an IPAM pool to another IPAM pool or to a resource. For more information, see Allocate CIDRs in the *Amazon VPC IPAM User Guide*.
 *
 * This action creates an allocation with strong consistency. The returned CIDR will not overlap with any other allocations from the same pool.
 */
export const allocateIpamPoolCidr: API.OperationMethod<
  AllocateIpamPoolCidrRequest,
  AllocateIpamPoolCidrResult,
  AllocateIpamPoolCidrError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AllocateIpamPoolCidrRequest,
  output: AllocateIpamPoolCidrResult,
  errors: [RequestLimitExceeded, InvalidIpamPoolIdNotFound],
}));
export type ApplySecurityGroupsToClientVpnTargetNetworkError =
  | RequestLimitExceeded
  | InvalidVpcIdMalformed
  | CommonErrors;
/**
 * Applies a security group to the association between the target network and the Client VPN endpoint. This action replaces the existing
 * security groups with the specified security groups.
 */
export const applySecurityGroupsToClientVpnTargetNetwork: API.OperationMethod<
  ApplySecurityGroupsToClientVpnTargetNetworkRequest,
  ApplySecurityGroupsToClientVpnTargetNetworkResult,
  ApplySecurityGroupsToClientVpnTargetNetworkError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ApplySecurityGroupsToClientVpnTargetNetworkRequest,
  output: ApplySecurityGroupsToClientVpnTargetNetworkResult,
  errors: [RequestLimitExceeded, InvalidVpcIdMalformed],
}));
export type AssignIpv6AddressesError =
  | RequestLimitExceeded
  | InvalidNetworkInterfaceIDNotFound
  | InvalidParameterCombination
  | CommonErrors;
/**
 * Assigns the specified IPv6 addresses to the specified network interface. You can
 * specify specific IPv6 addresses, or you can specify the number of IPv6 addresses to be
 * automatically assigned from the subnet's IPv6 CIDR block range. You can assign as many
 * IPv6 addresses to a network interface as you can assign private IPv4 addresses, and the
 * limit varies by instance type.
 *
 * You must specify either the IPv6 addresses or the IPv6 address count in the request.
 *
 * You can optionally use Prefix Delegation on the network interface. You must specify
 * either the IPV6 Prefix Delegation prefixes, or the IPv6 Prefix Delegation count. For
 * information, see Assigning prefixes to network
 * interfaces in the *Amazon EC2 User Guide*.
 */
export const assignIpv6Addresses: API.OperationMethod<
  AssignIpv6AddressesRequest,
  AssignIpv6AddressesResult,
  AssignIpv6AddressesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssignIpv6AddressesRequest,
  output: AssignIpv6AddressesResult,
  errors: [
    RequestLimitExceeded,
    InvalidNetworkInterfaceIDNotFound,
    InvalidParameterCombination,
  ],
}));
export type AssignPrivateIpAddressesError =
  | RequestLimitExceeded
  | InvalidNetworkInterfaceIDNotFound
  | InvalidNetworkInterfaceIdMalformed
  | InvalidParameter
  | CommonErrors;
/**
 * Assigns the specified secondary private IP addresses to the specified network
 * interface.
 *
 * You can specify specific secondary IP addresses, or you can specify the number of
 * secondary IP addresses to be automatically assigned from the subnet's CIDR block range.
 * The number of secondary IP addresses that you can assign to an instance varies by
 * instance type. For more information about Elastic IP addresses, see Elastic IP
 * Addresses in the *Amazon EC2 User Guide*.
 *
 * When you move a secondary private IP address to another network interface, any Elastic
 * IP address that is associated with the IP address is also moved.
 *
 * Remapping an IP address is an asynchronous operation. When you move an IP address from
 * one network interface to another, check
 * `network/interfaces/macs/mac/local-ipv4s` in the instance metadata to
 * confirm that the remapping is complete.
 *
 * You must specify either the IP addresses or the IP address count in the
 * request.
 *
 * You can optionally use Prefix Delegation on the network interface. You must specify
 * either the IPv4 Prefix Delegation prefixes, or the IPv4 Prefix Delegation count. For
 * information, see Assigning prefixes to network
 * interfaces in the *Amazon EC2 User Guide*.
 */
export const assignPrivateIpAddresses: API.OperationMethod<
  AssignPrivateIpAddressesRequest,
  AssignPrivateIpAddressesResult,
  AssignPrivateIpAddressesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssignPrivateIpAddressesRequest,
  output: AssignPrivateIpAddressesResult,
  errors: [
    RequestLimitExceeded,
    InvalidNetworkInterfaceIDNotFound,
    InvalidNetworkInterfaceIdMalformed,
    InvalidParameter,
  ],
}));
export type AssignPrivateNatGatewayAddressError =
  | RequestLimitExceeded
  | NatGatewayNotFound
  | CommonErrors;
/**
 * Assigns private IPv4 addresses to a private NAT gateway. For more information, see
 * Work with NAT gateways in the *Amazon VPC User Guide*.
 */
export const assignPrivateNatGatewayAddress: API.OperationMethod<
  AssignPrivateNatGatewayAddressRequest,
  AssignPrivateNatGatewayAddressResult,
  AssignPrivateNatGatewayAddressError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssignPrivateNatGatewayAddressRequest,
  output: AssignPrivateNatGatewayAddressResult,
  errors: [RequestLimitExceeded, NatGatewayNotFound],
}));
export type AssociateAddressError =
  | RequestLimitExceeded
  | AuthFailure
  | InvalidAllocationIDNotFound
  | InvalidInstanceIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Associates an Elastic IP address, or carrier IP address (for instances that are in
 * subnets in Wavelength Zones) with an instance or a network interface. Before you can use an
 * Elastic IP address, you must allocate it to your account.
 *
 * If the Elastic IP address is already
 * associated with a different instance, it is disassociated from that instance and associated
 * with the specified instance. If you associate an Elastic IP address with an instance that has
 * an existing Elastic IP address, the existing address is disassociated from the instance, but
 * remains allocated to your account.
 *
 * [Subnets in Wavelength Zones] You can associate an IP address from the telecommunication
 * carrier to the instance or network interface.
 *
 * You cannot associate an Elastic IP address with an interface in a different network border group.
 *
 * This is an idempotent operation. If you perform the operation more than once, Amazon EC2
 * doesn't return an error, and you may be charged for each time the Elastic IP address is
 * remapped to the same instance. For more information, see the Elastic IP
 * Addresses section of Amazon EC2
 * Pricing.
 */
export const associateAddress: API.OperationMethod<
  AssociateAddressRequest,
  AssociateAddressResult,
  AssociateAddressError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateAddressRequest,
  output: AssociateAddressResult,
  errors: [
    RequestLimitExceeded,
    AuthFailure,
    InvalidAllocationIDNotFound,
    InvalidInstanceIDNotFound,
    MissingParameter,
  ],
}));
export type AssociateCapacityReservationBillingOwnerError =
  | RequestLimitExceeded
  | InvalidCapacityReservationIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Initiates a request to assign billing of the unused capacity of a shared Capacity
 * Reservation to a consumer account that is consolidated under the same Amazon Web Services
 * organizations payer account. For more information, see Billing assignment for shared
 * Amazon EC2 Capacity Reservations.
 */
export const associateCapacityReservationBillingOwner: API.OperationMethod<
  AssociateCapacityReservationBillingOwnerRequest,
  AssociateCapacityReservationBillingOwnerResult,
  AssociateCapacityReservationBillingOwnerError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateCapacityReservationBillingOwnerRequest,
  output: AssociateCapacityReservationBillingOwnerResult,
  errors: [
    RequestLimitExceeded,
    InvalidCapacityReservationIdMalformed,
    MissingParameter,
  ],
}));
export type AssociateClientVpnTargetNetworkError =
  | RequestLimitExceeded
  | InvalidSubnetIDMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Associates a target network with a Client VPN endpoint. A target network is a subnet in a VPC. You can associate multiple subnets from the same VPC with a Client VPN endpoint. You can associate only one subnet in each Availability Zone. We recommend that you associate at least two subnets to provide Availability Zone redundancy.
 *
 * If you specified a VPC when you created the Client VPN endpoint or if you have previous subnet associations, the specified subnet must be in the same VPC. To specify a subnet that's in a different VPC, you must first modify the Client VPN endpoint (ModifyClientVpnEndpoint) and change the VPC that's associated with it.
 */
export const associateClientVpnTargetNetwork: API.OperationMethod<
  AssociateClientVpnTargetNetworkRequest,
  AssociateClientVpnTargetNetworkResult,
  AssociateClientVpnTargetNetworkError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateClientVpnTargetNetworkRequest,
  output: AssociateClientVpnTargetNetworkResult,
  errors: [RequestLimitExceeded, InvalidSubnetIDMalformed, MissingParameter],
}));
export type AssociateDhcpOptionsError =
  | RequestLimitExceeded
  | InvalidDhcpOptionsIdMalformed
  | InvalidVpcIDNotFound
  | InvalidVpcIdMalformed
  | CommonErrors;
/**
 * Associates a set of DHCP options (that you've previously created) with the specified VPC, or associates no DHCP options with the VPC.
 *
 * After you associate the options with the VPC, any existing instances and all new instances that you launch in that VPC use the options. You don't need to restart or relaunch the instances. They automatically pick up the changes within a few hours, depending on how frequently the instance renews its DHCP lease. You can explicitly renew the lease using the operating system on the instance.
 *
 * For more information, see DHCP option sets
 * in the *Amazon VPC User Guide*.
 */
export const associateDhcpOptions: API.OperationMethod<
  AssociateDhcpOptionsRequest,
  AssociateDhcpOptionsResponse,
  AssociateDhcpOptionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateDhcpOptionsRequest,
  output: AssociateDhcpOptionsResponse,
  errors: [
    RequestLimitExceeded,
    InvalidDhcpOptionsIdMalformed,
    InvalidVpcIDNotFound,
    InvalidVpcIdMalformed,
  ],
}));
export type AssociateEnclaveCertificateIamRoleError =
  | RequestLimitExceeded
  | InvalidCertificateArnMalformed
  | InvalidRoleArnMalformed
  | CommonErrors;
/**
 * Associates an Identity and Access Management (IAM) role with an Certificate Manager (ACM) certificate.
 * This enables the certificate to be used by the ACM for Nitro Enclaves application inside an enclave. For more
 * information, see Certificate Manager for Nitro Enclaves in the Amazon Web Services Nitro Enclaves
 * User Guide.
 *
 * When the IAM role is associated with the ACM certificate, the certificate, certificate chain, and encrypted
 * private key are placed in an Amazon S3 location that only the associated IAM role can access. The private key of the certificate
 * is encrypted with an Amazon Web Services managed key that has an attached attestation-based key policy.
 *
 * To enable the IAM role to access the Amazon S3 object, you must grant it permission to call `s3:GetObject`
 * on the Amazon S3 bucket returned by the command. To enable the IAM role to access the KMS key,
 * you must grant it permission to call `kms:Decrypt` on the KMS key returned by the command.
 * For more information, see
 * Grant the role permission to access the certificate and encryption key in the
 * *Amazon Web Services Nitro Enclaves User Guide*.
 */
export const associateEnclaveCertificateIamRole: API.OperationMethod<
  AssociateEnclaveCertificateIamRoleRequest,
  AssociateEnclaveCertificateIamRoleResult,
  AssociateEnclaveCertificateIamRoleError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateEnclaveCertificateIamRoleRequest,
  output: AssociateEnclaveCertificateIamRoleResult,
  errors: [
    RequestLimitExceeded,
    InvalidCertificateArnMalformed,
    InvalidRoleArnMalformed,
  ],
}));
export type AssociateIamInstanceProfileError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Associates an IAM instance profile with a running or stopped instance. You cannot
 * associate more than one IAM instance profile with an instance.
 */
export const associateIamInstanceProfile: API.OperationMethod<
  AssociateIamInstanceProfileRequest,
  AssociateIamInstanceProfileResult,
  AssociateIamInstanceProfileError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateIamInstanceProfileRequest,
  output: AssociateIamInstanceProfileResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type AssociateInstanceEventWindowError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Associates one or more targets with an event window. Only one type of target (instance
 * IDs, Dedicated Host IDs, or tags) can be specified with an event window.
 *
 * For more information, see Define event windows for scheduled
 * events in the *Amazon EC2 User Guide*.
 */
export const associateInstanceEventWindow: API.OperationMethod<
  AssociateInstanceEventWindowRequest,
  AssociateInstanceEventWindowResult,
  AssociateInstanceEventWindowError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateInstanceEventWindowRequest,
  output: AssociateInstanceEventWindowResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type AssociateIpamByoasnError =
  | RequestLimitExceeded
  | InvalidCidrNotFound
  | CommonErrors;
/**
 * Associates your Autonomous System Number (ASN) with a BYOIP CIDR that you own in the same Amazon Web Services Region.
 * For more information, see Tutorial: Bring your ASN to IPAM in the *Amazon VPC IPAM guide*.
 *
 * After the association succeeds, the ASN is eligible for
 * advertisement. You can view the association with DescribeByoipCidrs. You can advertise the CIDR with AdvertiseByoipCidr.
 */
export const associateIpamByoasn: API.OperationMethod<
  AssociateIpamByoasnRequest,
  AssociateIpamByoasnResult,
  AssociateIpamByoasnError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateIpamByoasnRequest,
  output: AssociateIpamByoasnResult,
  errors: [RequestLimitExceeded, InvalidCidrNotFound],
}));
export type AssociateIpamResourceDiscoveryError =
  | RequestLimitExceeded
  | InvalidIpamResourceDiscoveryIdMalformed
  | InvalidIpamResourceDiscoveryIdNotFound
  | CommonErrors;
/**
 * Associates an IPAM resource discovery with an Amazon VPC IPAM. A resource discovery is an IPAM component that enables IPAM to manage and monitor resources that belong to the owning account.
 */
export const associateIpamResourceDiscovery: API.OperationMethod<
  AssociateIpamResourceDiscoveryRequest,
  AssociateIpamResourceDiscoveryResult,
  AssociateIpamResourceDiscoveryError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateIpamResourceDiscoveryRequest,
  output: AssociateIpamResourceDiscoveryResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamResourceDiscoveryIdMalformed,
    InvalidIpamResourceDiscoveryIdNotFound,
  ],
}));
export type AssociateNatGatewayAddressError =
  | RequestLimitExceeded
  | MissingParameter
  | NatGatewayMalformed
  | NatGatewayNotFound
  | CommonErrors;
/**
 * Associates Elastic IP addresses (EIPs) and private IPv4 addresses with a public NAT gateway. For more information,
 * see Work with NAT gateways in the *Amazon VPC User Guide*.
 *
 * By default, you can associate up to 2 Elastic IP addresses per public NAT gateway. You can increase the limit by requesting a quota adjustment.
 * For more information, see Elastic IP address quotas in the *Amazon VPC User Guide*.
 *
 * When you associate an EIP or secondary EIPs with a public NAT gateway, the network border group of the EIPs
 * must match the network border group of the Availability Zone (AZ) that the public NAT gateway is in. If it's not the same,
 * the EIP will fail to associate. You can see the network border group for the subnet's AZ by viewing the details of the subnet.
 * Similarly, you can view the network border group of an EIP by viewing the details of the EIP address. For more information
 * about network border groups and EIPs, see Allocate an Elastic IP address in the *Amazon VPC User Guide*.
 */
export const associateNatGatewayAddress: API.OperationMethod<
  AssociateNatGatewayAddressRequest,
  AssociateNatGatewayAddressResult,
  AssociateNatGatewayAddressError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateNatGatewayAddressRequest,
  output: AssociateNatGatewayAddressResult,
  errors: [
    RequestLimitExceeded,
    MissingParameter,
    NatGatewayMalformed,
    NatGatewayNotFound,
  ],
}));
export type AssociateRouteServerError =
  | RequestLimitExceeded
  | InvalidRouteServerIdNotFound
  | CommonErrors;
/**
 * Associates a route server with a VPC to enable dynamic route updates.
 *
 * A route server association is the connection established between a route server and a VPC.
 *
 * For more information see Dynamic routing in your VPC with VPC Route Server in the *Amazon VPC User Guide*.
 */
export const associateRouteServer: API.OperationMethod<
  AssociateRouteServerRequest,
  AssociateRouteServerResult,
  AssociateRouteServerError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateRouteServerRequest,
  output: AssociateRouteServerResult,
  errors: [RequestLimitExceeded, InvalidRouteServerIdNotFound],
}));
export type AssociateRouteTableError =
  | RequestLimitExceeded
  | DryRunOperation
  | InvalidParameterCombination
  | InvalidParameterValue
  | InvalidPublicIpv4PoolIDMalformed
  | InvalidPublicIpv4PoolIDNotFound
  | InvalidRouteTableIDNotFound
  | InvalidSubnetIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Associates a subnet in your VPC or an internet gateway or virtual private gateway
 * attached to your VPC with a route table in your VPC. This association causes traffic
 * from the subnet or gateway to be routed according to the routes in the route table. The
 * action returns an association ID, which you need in order to disassociate the route
 * table later. A route table can be associated with multiple subnets.
 *
 * For more information, see Route tables in the
 * *Amazon VPC User Guide*.
 */
export const associateRouteTable: API.OperationMethod<
  AssociateRouteTableRequest,
  AssociateRouteTableResult,
  AssociateRouteTableError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateRouteTableRequest,
  output: AssociateRouteTableResult,
  errors: [
    RequestLimitExceeded,
    DryRunOperation,
    InvalidParameterCombination,
    InvalidParameterValue,
    InvalidPublicIpv4PoolIDMalformed,
    InvalidPublicIpv4PoolIDNotFound,
    InvalidRouteTableIDNotFound,
    InvalidSubnetIDNotFound,
    MissingParameter,
  ],
}));
export type AssociateSecurityGroupVpcError =
  | RequestLimitExceeded
  | InvalidGroupIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Associates a security group with another VPC in the same Region. This enables you to use the same security group with network interfaces and instances in the specified VPC.
 *
 * - The VPC you want to associate the security group with must be in the same Region.
 *
 * - You can associate the security group with another VPC if your account owns the VPC or if the VPC was shared with you.
 *
 * - You must own the security group.
 *
 * - You cannot use this feature with default security groups.
 *
 * - You cannot use this feature with the default VPC.
 */
export const associateSecurityGroupVpc: API.OperationMethod<
  AssociateSecurityGroupVpcRequest,
  AssociateSecurityGroupVpcResult,
  AssociateSecurityGroupVpcError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateSecurityGroupVpcRequest,
  output: AssociateSecurityGroupVpcResult,
  errors: [RequestLimitExceeded, InvalidGroupIdMalformed, MissingParameter],
}));
export type AssociateSubnetCidrBlockError =
  | RequestLimitExceeded
  | InvalidSubnetIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Associates a CIDR block with your subnet. You can only associate a single IPv6 CIDR
 * block with your subnet.
 */
export const associateSubnetCidrBlock: API.OperationMethod<
  AssociateSubnetCidrBlockRequest,
  AssociateSubnetCidrBlockResult,
  AssociateSubnetCidrBlockError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateSubnetCidrBlockRequest,
  output: AssociateSubnetCidrBlockResult,
  errors: [RequestLimitExceeded, InvalidSubnetIDNotFound, MissingParameter],
}));
export type AssociateTransitGatewayMulticastDomainError =
  | RequestLimitExceeded
  | InvalidTransitGatewayMulticastDomainIdNotFound
  | CommonErrors;
/**
 * Associates the specified subnets and transit gateway attachments with the specified transit gateway multicast domain.
 *
 * The transit gateway attachment must be in the available state before you can add a resource. Use DescribeTransitGatewayAttachments
 * to see the state of the attachment.
 */
export const associateTransitGatewayMulticastDomain: API.OperationMethod<
  AssociateTransitGatewayMulticastDomainRequest,
  AssociateTransitGatewayMulticastDomainResult,
  AssociateTransitGatewayMulticastDomainError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateTransitGatewayMulticastDomainRequest,
  output: AssociateTransitGatewayMulticastDomainResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayMulticastDomainIdNotFound,
  ],
}));
export type AssociateTransitGatewayPolicyTableError =
  | RequestLimitExceeded
  | InvalidTransitGatewayPolicyTableIdMalformed
  | InvalidTransitGatewayPolicyTableIdNotFound
  | CommonErrors;
/**
 * Associates the specified transit gateway attachment with a transit gateway policy table.
 */
export const associateTransitGatewayPolicyTable: API.OperationMethod<
  AssociateTransitGatewayPolicyTableRequest,
  AssociateTransitGatewayPolicyTableResult,
  AssociateTransitGatewayPolicyTableError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateTransitGatewayPolicyTableRequest,
  output: AssociateTransitGatewayPolicyTableResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayPolicyTableIdMalformed,
    InvalidTransitGatewayPolicyTableIdNotFound,
  ],
}));
export type AssociateTransitGatewayRouteTableError =
  | RequestLimitExceeded
  | InvalidRouteTableIDNotFound
  | CommonErrors;
/**
 * Associates the specified attachment with the specified transit gateway route table. You can
 * associate only one route table with an attachment.
 */
export const associateTransitGatewayRouteTable: API.OperationMethod<
  AssociateTransitGatewayRouteTableRequest,
  AssociateTransitGatewayRouteTableResult,
  AssociateTransitGatewayRouteTableError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateTransitGatewayRouteTableRequest,
  output: AssociateTransitGatewayRouteTableResult,
  errors: [RequestLimitExceeded, InvalidRouteTableIDNotFound],
}));
export type AssociateTrunkInterfaceError =
  | RequestLimitExceeded
  | OperationNotPermitted
  | CommonErrors;
/**
 * Associates a branch network interface with a trunk network interface.
 *
 * Before you create the association, use CreateNetworkInterface command and set the interface type
 * to `trunk`. You must also create a network interface for
 * each branch network interface that you want to associate with the trunk
 * network interface.
 */
export const associateTrunkInterface: API.OperationMethod<
  AssociateTrunkInterfaceRequest,
  AssociateTrunkInterfaceResult,
  AssociateTrunkInterfaceError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateTrunkInterfaceRequest,
  output: AssociateTrunkInterfaceResult,
  errors: [RequestLimitExceeded, OperationNotPermitted],
}));
export type AssociateVpcCidrBlockError =
  | RequestLimitExceeded
  | CidrConflict
  | InvalidParameterCombination
  | InvalidVpcIDNotFound
  | InvalidVpcIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Associates a CIDR block with your VPC. You can associate a secondary IPv4 CIDR block,
 * an Amazon-provided IPv6 CIDR block, or an IPv6 CIDR block from an IPv6 address pool that
 * you provisioned through bring your own IP addresses (BYOIP).
 *
 * You must specify one of the following in the request: an IPv4 CIDR block, an IPv6
 * pool, or an Amazon-provided IPv6 CIDR block.
 *
 * For more information about associating CIDR blocks with your VPC and applicable
 * restrictions, see IP addressing for your VPCs and subnets
 * in the *Amazon VPC User Guide*.
 */
export const associateVpcCidrBlock: API.OperationMethod<
  AssociateVpcCidrBlockRequest,
  AssociateVpcCidrBlockResult,
  AssociateVpcCidrBlockError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateVpcCidrBlockRequest,
  output: AssociateVpcCidrBlockResult,
  errors: [
    RequestLimitExceeded,
    CidrConflict,
    InvalidParameterCombination,
    InvalidVpcIDNotFound,
    InvalidVpcIdMalformed,
    MissingParameter,
  ],
}));
export type AttachClassicLinkVpcError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | MissingParameter
  | CommonErrors;
/**
 * This action is deprecated.
 *
 * Links an EC2-Classic instance to a ClassicLink-enabled VPC through one or more of the VPC
 * security groups. You cannot link an EC2-Classic instance to more than one VPC at a time. You
 * can only link an instance that's in the `running` state. An instance is
 * automatically unlinked from a VPC when it's stopped - you can link it to the VPC again when
 * you restart it.
 *
 * After you've linked an instance, you cannot change the VPC security groups that are associated with it. To change the security groups, you must first unlink the instance, and then link it again.
 *
 * Linking your instance to a VPC is sometimes referred to as *attaching* your instance.
 */
export const attachClassicLinkVpc: API.OperationMethod<
  AttachClassicLinkVpcRequest,
  AttachClassicLinkVpcResult,
  AttachClassicLinkVpcError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AttachClassicLinkVpcRequest,
  output: AttachClassicLinkVpcResult,
  errors: [RequestLimitExceeded, InvalidInstanceIDMalformed, MissingParameter],
}));
export type AttachInternetGatewayError =
  | RequestLimitExceeded
  | InvalidVpcIDNotFound
  | InvalidInternetGatewayIDNotFound
  | InvalidInternetGatewayIdMalformed
  | InvalidVpcIdMalformed
  | CommonErrors;
/**
 * Attaches an internet gateway or a virtual private gateway to a VPC, enabling connectivity
 * between the internet and the VPC. For more information, see Internet gateways in the
 * *Amazon VPC User Guide*.
 */
export const attachInternetGateway: API.OperationMethod<
  AttachInternetGatewayRequest,
  AttachInternetGatewayResponse,
  AttachInternetGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AttachInternetGatewayRequest,
  output: AttachInternetGatewayResponse,
  errors: [
    RequestLimitExceeded,
    InvalidVpcIDNotFound,
    InvalidInternetGatewayIDNotFound,
    InvalidInternetGatewayIdMalformed,
    InvalidVpcIdMalformed,
  ],
}));
export type AttachNetworkInterfaceError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | InvalidInstanceIDNotFound
  | InvalidNetworkInterfaceIDNotFound
  | CommonErrors;
/**
 * Attaches a network interface to an instance.
 */
export const attachNetworkInterface: API.OperationMethod<
  AttachNetworkInterfaceRequest,
  AttachNetworkInterfaceResult,
  AttachNetworkInterfaceError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AttachNetworkInterfaceRequest,
  output: AttachNetworkInterfaceResult,
  errors: [
    RequestLimitExceeded,
    InvalidInstanceIDMalformed,
    InvalidInstanceIDNotFound,
    InvalidNetworkInterfaceIDNotFound,
  ],
}));
export type AttachVerifiedAccessTrustProviderError =
  | RequestLimitExceeded
  | InvalidVerifiedAccessInstanceIdNotFound
  | CommonErrors;
/**
 * Attaches the specified Amazon Web Services Verified Access trust provider to the specified Amazon Web Services Verified Access instance.
 */
export const attachVerifiedAccessTrustProvider: API.OperationMethod<
  AttachVerifiedAccessTrustProviderRequest,
  AttachVerifiedAccessTrustProviderResult,
  AttachVerifiedAccessTrustProviderError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AttachVerifiedAccessTrustProviderRequest,
  output: AttachVerifiedAccessTrustProviderResult,
  errors: [RequestLimitExceeded, InvalidVerifiedAccessInstanceIdNotFound],
}));
export type AttachVolumeError =
  | RequestLimitExceeded
  | InvalidInstanceIDNotFound
  | InvalidParameterValue
  | InvalidVolumeNotFound
  | CommonErrors;
/**
 * Attaches an Amazon EBS volume to a `running` or `stopped`
 * instance, and exposes it to the instance with the specified device name.
 *
 * The maximum number of Amazon EBS volumes that you can attach to an instance depends on the
 * instance type. If you exceed the volume attachment limit for an instance type, the attachment
 * request fails with the `AttachmentLimitExceeded` error. For more information,
 * see Instance
 * volume limits.
 *
 * After you attach an EBS volume, you must make it available for use. For more information,
 * see Make an
 * EBS volume available for use.
 *
 * If a volume has an Amazon Web Services Marketplace product code:
 *
 * - The volume can be attached only to a stopped instance.
 *
 * - Amazon Web Services Marketplace product codes are copied from the volume to the instance.
 *
 * - You must be subscribed to the product.
 *
 * - The instance type and operating system of the instance must support the product. For
 * example, you can't detach a volume from a Windows instance and attach it to a Linux
 * instance.
 *
 * For more information, see Attach an Amazon EBS volume to an instance in the
 * *Amazon EBS User Guide*.
 */
export const attachVolume: API.OperationMethod<
  AttachVolumeRequest,
  VolumeAttachment,
  AttachVolumeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AttachVolumeRequest,
  output: VolumeAttachment,
  errors: [
    RequestLimitExceeded,
    InvalidInstanceIDNotFound,
    InvalidParameterValue,
    InvalidVolumeNotFound,
  ],
}));
export type AttachVpnGatewayError =
  | RequestLimitExceeded
  | InvalidVpcIDNotFound
  | InvalidVpnGatewayIDNotFound
  | CommonErrors;
/**
 * Attaches an available virtual private gateway to a VPC. You can attach one virtual private
 * gateway to one VPC at a time.
 *
 * For more information, see Amazon Web Services Site-to-Site VPN in the Amazon Web Services Site-to-Site VPN
 * User Guide.
 */
export const attachVpnGateway: API.OperationMethod<
  AttachVpnGatewayRequest,
  AttachVpnGatewayResult,
  AttachVpnGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AttachVpnGatewayRequest,
  output: AttachVpnGatewayResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcIDNotFound,
    InvalidVpnGatewayIDNotFound,
  ],
}));
export type AuthorizeClientVpnIngressError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Adds an ingress authorization rule to a Client VPN endpoint. Ingress authorization rules act as
 * firewall rules that grant access to networks. You must configure ingress authorization rules to
 * enable clients to access resources in Amazon Web Services or on-premises networks.
 */
export const authorizeClientVpnIngress: API.OperationMethod<
  AuthorizeClientVpnIngressRequest,
  AuthorizeClientVpnIngressResult,
  AuthorizeClientVpnIngressError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AuthorizeClientVpnIngressRequest,
  output: AuthorizeClientVpnIngressResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type AuthorizeSecurityGroupEgressError =
  | RequestLimitExceeded
  | InvalidGroupNotFound
  | InvalidGroupIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Adds the specified outbound (egress) rules to a security group.
 *
 * An outbound rule permits instances to send traffic to the specified IPv4 or IPv6
 * address ranges, the IP address ranges specified by a prefix list, or the instances
 * that are associated with a source security group. For more information, see Security group rules.
 *
 * You must specify exactly one of the following destinations: an IPv4 or IPv6 address range,
 * a prefix list, or a security group. You must specify a protocol for each rule (for example, TCP).
 * If the protocol is TCP or UDP, you must also specify a port or port range. If the protocol is
 * ICMP or ICMPv6, you must also specify the ICMP type and code.
 *
 * Rule changes are propagated to instances associated with the security group as quickly
 * as possible. However, a small delay might occur.
 *
 * For examples of rules that you can add to security groups for specific access scenarios,
 * see Security group rules for different use cases in the *Amazon EC2 User Guide*.
 *
 * For information about security group quotas, see Amazon VPC quotas in the *Amazon VPC User Guide*.
 */
export const authorizeSecurityGroupEgress: API.OperationMethod<
  AuthorizeSecurityGroupEgressRequest,
  AuthorizeSecurityGroupEgressResult,
  AuthorizeSecurityGroupEgressError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AuthorizeSecurityGroupEgressRequest,
  output: AuthorizeSecurityGroupEgressResult,
  errors: [
    RequestLimitExceeded,
    InvalidGroupNotFound,
    InvalidGroupIdMalformed,
    MissingParameter,
  ],
}));
export type AuthorizeSecurityGroupIngressError =
  | RequestLimitExceeded
  | InvalidGroupNotFound
  | InvalidGroupIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Adds the specified inbound (ingress) rules to a security group.
 *
 * An inbound rule permits instances to receive traffic from the specified IPv4 or IPv6
 * address range, the IP address ranges that are specified by a prefix list, or the instances
 * that are associated with a destination security group. For more information, see Security group rules.
 *
 * You must specify exactly one of the following sources: an IPv4 or IPv6 address range,
 * a prefix list, or a security group. You must specify a protocol for each rule (for example, TCP).
 * If the protocol is TCP or UDP, you must also specify a port or port range. If the protocol is
 * ICMP or ICMPv6, you must also specify the ICMP/ICMPv6 type and code.
 *
 * Rule changes are propagated to instances associated with the security group as quickly
 * as possible. However, a small delay might occur.
 *
 * For examples of rules that you can add to security groups for specific access scenarios,
 * see Security group rules for different use cases in the *Amazon EC2 User Guide*.
 *
 * For more information about security group quotas, see Amazon VPC quotas in the *Amazon VPC User Guide*.
 */
export const authorizeSecurityGroupIngress: API.OperationMethod<
  AuthorizeSecurityGroupIngressRequest,
  AuthorizeSecurityGroupIngressResult,
  AuthorizeSecurityGroupIngressError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AuthorizeSecurityGroupIngressRequest,
  output: AuthorizeSecurityGroupIngressResult,
  errors: [
    RequestLimitExceeded,
    InvalidGroupNotFound,
    InvalidGroupIdMalformed,
    MissingParameter,
  ],
}));
export type BundleInstanceError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Bundles an Amazon instance store-backed Windows instance.
 *
 * During bundling, only the root device volume (C:\) is bundled. Data on other instance
 * store volumes is not preserved.
 *
 * This action is not applicable for Linux/Unix instances or Windows instances that are
 * backed by Amazon EBS.
 */
export const bundleInstance: API.OperationMethod<
  BundleInstanceRequest,
  BundleInstanceResult,
  BundleInstanceError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BundleInstanceRequest,
  output: BundleInstanceResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CancelBundleTaskError =
  | RequestLimitExceeded
  | InvalidBundleIDNotFound
  | InvalidInstanceIDMalformed
  | CommonErrors;
/**
 * Cancels a bundling operation for an instance store-backed Windows instance.
 */
export const cancelBundleTask: API.OperationMethod<
  CancelBundleTaskRequest,
  CancelBundleTaskResult,
  CancelBundleTaskError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CancelBundleTaskRequest,
  output: CancelBundleTaskResult,
  errors: [
    RequestLimitExceeded,
    InvalidBundleIDNotFound,
    InvalidInstanceIDMalformed,
  ],
}));
export type CancelCapacityReservationError =
  | RequestLimitExceeded
  | InvalidCapacityReservationIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Cancels the specified Capacity Reservation, releases the reserved capacity, and
 * changes the Capacity Reservation's state to `cancelled`.
 *
 * You can cancel a Capacity Reservation that is in the following states:
 *
 * - `assessing`
 *
 * - `active` and there is no commitment duration or the commitment
 * duration has elapsed. You can't cancel a future-dated Capacity Reservation
 * during the commitment duration.
 *
 * You can't modify or cancel a Capacity Block. For more information, see Capacity Blocks for ML.
 *
 * If a future-dated Capacity Reservation enters the `delayed` state, the
 * commitment duration is waived, and you can cancel it as soon as it enters the
 * `active` state.
 *
 * Instances running in the reserved capacity continue running until you stop them.
 * Stopped instances that target the Capacity Reservation can no longer launch. Modify
 * these instances to either target a different Capacity Reservation, launch On-Demand
 * Instance capacity, or run in any open Capacity Reservation that has matching attributes
 * and sufficient capacity.
 */
export const cancelCapacityReservation: API.OperationMethod<
  CancelCapacityReservationRequest,
  CancelCapacityReservationResult,
  CancelCapacityReservationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CancelCapacityReservationRequest,
  output: CancelCapacityReservationResult,
  errors: [
    RequestLimitExceeded,
    InvalidCapacityReservationIdMalformed,
    MissingParameter,
  ],
}));
export type CancelCapacityReservationFleetsError =
  | RequestLimitExceeded
  | InvalidCapacityReservationFleetIdMalformed
  | CommonErrors;
/**
 * Cancels one or more Capacity Reservation Fleets. When you cancel a Capacity
 * Reservation Fleet, the following happens:
 *
 * - The Capacity Reservation Fleet's status changes to
 * `cancelled`.
 *
 * - The individual Capacity Reservations in the Fleet are cancelled. Instances
 * running in the Capacity Reservations at the time of cancelling the Fleet
 * continue to run in shared capacity.
 *
 * - The Fleet stops creating new Capacity Reservations.
 */
export const cancelCapacityReservationFleets: API.OperationMethod<
  CancelCapacityReservationFleetsRequest,
  CancelCapacityReservationFleetsResult,
  CancelCapacityReservationFleetsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CancelCapacityReservationFleetsRequest,
  output: CancelCapacityReservationFleetsResult,
  errors: [RequestLimitExceeded, InvalidCapacityReservationFleetIdMalformed],
}));
export type CancelConversionTaskError =
  | RequestLimitExceeded
  | InvalidAction
  | CommonErrors;
/**
 * Cancels an active conversion task. The task can be the import of an instance or volume. The action removes all
 * artifacts of the conversion, including a partially uploaded volume or instance. If the conversion is complete or is
 * in the process of transferring the final disk image, the command fails and returns an exception.
 */
export const cancelConversionTask: API.OperationMethod<
  CancelConversionRequest,
  CancelConversionTaskResponse,
  CancelConversionTaskError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CancelConversionRequest,
  output: CancelConversionTaskResponse,
  errors: [RequestLimitExceeded, InvalidAction],
}));
export type CancelDeclarativePoliciesReportError =
  | RequestLimitExceeded
  | InvalidDeclarativePoliciesReportIdMalformed
  | CommonErrors;
/**
 * Cancels the generation of an account status report.
 *
 * You can only cancel a report while it has the `running` status. Reports
 * with other statuses (`complete`, `cancelled`, or
 * `error`) can't be canceled.
 *
 * For more information, see Generating the account status report for declarative policies in the
 * *Amazon Web Services Organizations User Guide*.
 */
export const cancelDeclarativePoliciesReport: API.OperationMethod<
  CancelDeclarativePoliciesReportRequest,
  CancelDeclarativePoliciesReportResult,
  CancelDeclarativePoliciesReportError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CancelDeclarativePoliciesReportRequest,
  output: CancelDeclarativePoliciesReportResult,
  errors: [RequestLimitExceeded, InvalidDeclarativePoliciesReportIdMalformed],
}));
export type CancelExportTaskError =
  | RequestLimitExceeded
  | InvalidID
  | CommonErrors;
/**
 * Cancels an active export task. The request removes all artifacts of the export, including any partially-created
 * Amazon S3 objects. If the export task is complete or is in the process of transferring the final disk image, the
 * command fails and returns an error.
 */
export const cancelExportTask: API.OperationMethod<
  CancelExportTaskRequest,
  CancelExportTaskResponse,
  CancelExportTaskError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CancelExportTaskRequest,
  output: CancelExportTaskResponse,
  errors: [RequestLimitExceeded, InvalidID],
}));
export type CancelImageLaunchPermissionError =
  | RequestLimitExceeded
  | InvalidAMIIDMalformed
  | CommonErrors;
/**
 * Removes your Amazon Web Services account from the launch permissions for the specified AMI.
 * For more information, see Cancel having an AMI shared with
 * your Amazon Web Services account in the *Amazon EC2 User Guide*.
 */
export const cancelImageLaunchPermission: API.OperationMethod<
  CancelImageLaunchPermissionRequest,
  CancelImageLaunchPermissionResult,
  CancelImageLaunchPermissionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CancelImageLaunchPermissionRequest,
  output: CancelImageLaunchPermissionResult,
  errors: [RequestLimitExceeded, InvalidAMIIDMalformed],
}));
export type CancelImportTaskError =
  | RequestLimitExceeded
  | InvalidConversionTaskIdMalformed
  | CommonErrors;
/**
 * Cancels an in-process import virtual machine or import snapshot task.
 */
export const cancelImportTask: API.OperationMethod<
  CancelImportTaskRequest,
  CancelImportTaskResult,
  CancelImportTaskError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CancelImportTaskRequest,
  output: CancelImportTaskResult,
  errors: [RequestLimitExceeded, InvalidConversionTaskIdMalformed],
}));
export type CancelReservedInstancesListingError =
  | RequestLimitExceeded
  | InvalidInput
  | CommonErrors;
/**
 * Cancels the specified Reserved Instance listing in the Reserved Instance
 * Marketplace.
 *
 * For more information, see Sell in the Reserved Instance
 * Marketplace in the *Amazon EC2 User Guide*.
 */
export const cancelReservedInstancesListing: API.OperationMethod<
  CancelReservedInstancesListingRequest,
  CancelReservedInstancesListingResult,
  CancelReservedInstancesListingError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CancelReservedInstancesListingRequest,
  output: CancelReservedInstancesListingResult,
  errors: [RequestLimitExceeded, InvalidInput],
}));
export type CancelSpotFleetRequestsError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | MissingParameter
  | CommonErrors;
/**
 * Cancels the specified Spot Fleet requests.
 *
 * After you cancel a Spot Fleet request, the Spot Fleet launches no new instances.
 *
 * You must also specify whether a canceled Spot Fleet request should terminate its instances. If you
 * choose to terminate the instances, the Spot Fleet request enters the
 * `cancelled_terminating` state. Otherwise, the Spot Fleet request enters
 * the `cancelled_running` state and the instances continue to run until they
 * are interrupted or you terminate them manually.
 *
 * **Terminating an instance is permanent and irreversible.**
 *
 * After you terminate an instance, you can no longer connect to it, and it can't be recovered.
 * All attached Amazon EBS volumes that are configured to be deleted on termination are also permanently
 * deleted and can't be recovered. All data stored on instance store volumes is permanently lost.
 * For more information, see
 * How instance termination works.
 *
 * Before you terminate an instance, ensure that you have backed up all data that you need to
 * retain after the termination to persistent storage.
 *
 * **Restrictions**
 *
 * - You can delete up to 100 fleets in a single request. If you exceed the specified
 * number, no fleets are deleted.
 */
export const cancelSpotFleetRequests: API.OperationMethod<
  CancelSpotFleetRequestsRequest,
  CancelSpotFleetRequestsResponse,
  CancelSpotFleetRequestsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CancelSpotFleetRequestsRequest,
  output: CancelSpotFleetRequestsResponse,
  errors: [RequestLimitExceeded, InvalidParameterValue, MissingParameter],
}));
export type CancelSpotInstanceRequestsError =
  | RequestLimitExceeded
  | InvalidParameterCombination
  | InvalidSpotInstanceRequestIDMalformed
  | CommonErrors;
/**
 * Cancels one or more Spot Instance requests.
 *
 * Canceling a Spot Instance request does not terminate running Spot Instances
 * associated with the request.
 */
export const cancelSpotInstanceRequests: API.OperationMethod<
  CancelSpotInstanceRequestsRequest,
  CancelSpotInstanceRequestsResult,
  CancelSpotInstanceRequestsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CancelSpotInstanceRequestsRequest,
  output: CancelSpotInstanceRequestsResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterCombination,
    InvalidSpotInstanceRequestIDMalformed,
  ],
}));
export type ConfirmProductInstanceError =
  | RequestLimitExceeded
  | AuthFailure
  | CommonErrors;
/**
 * Determines whether a product code is associated with an instance. This action can only
 * be used by the owner of the product code. It is useful when a product code owner must
 * verify whether another user's instance is eligible for support.
 */
export const confirmProductInstance: API.OperationMethod<
  ConfirmProductInstanceRequest,
  ConfirmProductInstanceResult,
  ConfirmProductInstanceError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ConfirmProductInstanceRequest,
  output: ConfirmProductInstanceResult,
  errors: [RequestLimitExceeded, AuthFailure],
}));
export type CopyFpgaImageError =
  | RequestLimitExceeded
  | InvalidFpgaImageIDMalformed
  | CommonErrors;
/**
 * Copies the specified Amazon FPGA Image (AFI) to the current Region.
 */
export const copyFpgaImage: API.OperationMethod<
  CopyFpgaImageRequest,
  CopyFpgaImageResult,
  CopyFpgaImageError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CopyFpgaImageRequest,
  output: CopyFpgaImageResult,
  errors: [RequestLimitExceeded, InvalidFpgaImageIDMalformed],
}));
export type CopyImageError =
  | RequestLimitExceeded
  | InvalidAMIIDMalformed
  | InvalidAMIIDNotFound
  | InvalidRegion
  | InvalidRequest
  | CommonErrors;
/**
 * Initiates an AMI copy operation. You must specify the source AMI ID and both the source
 * and destination locations. The copy operation must be initiated in the destination
 * Region.
 *
 * **CopyImage supports the following source to destination copies:**
 *
 * - Region to Region
 *
 * - Region to Outpost
 *
 * - Parent Region to Local Zone
 *
 * - Local Zone to parent Region
 *
 * - Between Local Zones with the same parent Region (only supported for certain Local
 * Zones)
 *
 * **CopyImage does not support the following source to destination copies:**
 *
 * - Local Zone to non-parent Regions
 *
 * - Between Local Zones with different parent Regions
 *
 * - Local Zone to Outpost
 *
 * - Outpost to Local Zone
 *
 * - Outpost to Region
 *
 * - Between Outposts
 *
 * - Within same Outpost
 *
 * - Cross-partition copies (use CreateStoreImageTask instead)
 *
 * **Destination specification**
 *
 * - Region to Region: The destination Region is the Region in which you initiate the copy
 * operation.
 *
 * - Region to Outpost: Specify the destination using the
 * `DestinationOutpostArn` parameter (the ARN of the Outpost)
 *
 * - Region to Local Zone, and Local Zone to Local Zone copies: Specify the destination
 * using the `DestinationAvailabilityZone` parameter (the name of the destination
 * Local Zone) or `DestinationAvailabilityZoneId` parameter (the ID of the
 * destination Local Zone).
 *
 * **Snapshot encryption**
 *
 * - Region to Outpost: Backing snapshots copied to an Outpost are encrypted by default
 * using the default encryption key for the Region or the key that you specify. Outposts do
 * not support unencrypted snapshots.
 *
 * - Region to Local Zone, and Local Zone to Local Zone: Not all Local Zones require
 * encrypted snapshots. In Local Zones that require encrypted snapshots, backing snapshots
 * are automatically encrypted during copy. In Local Zones where encryption is not required,
 * snapshots retain their original encryption state (encrypted or unencrypted) by
 * default.
 *
 * For more information, including the required permissions for copying an AMI, see Copy an Amazon EC2 AMI in the
 * *Amazon EC2 User Guide*.
 */
export const copyImage: API.OperationMethod<
  CopyImageRequest,
  CopyImageResult,
  CopyImageError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CopyImageRequest,
  output: CopyImageResult,
  errors: [
    RequestLimitExceeded,
    InvalidAMIIDMalformed,
    InvalidAMIIDNotFound,
    InvalidRegion,
    InvalidRequest,
  ],
}));
export type CopySnapshotError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidRegion
  | InvalidSnapshotNotFound
  | CommonErrors;
/**
 * Creates an exact copy of an Amazon EBS snapshot.
 *
 * The location of the source snapshot determines whether you can copy it or not,
 * and the allowed destinations for the snapshot copy.
 *
 * - If the source snapshot is in a Region, you can copy it within that Region,
 * to another Region, to an Outpost associated with that Region, or to a Local
 * Zone in that Region.
 *
 * - If the source snapshot is in a Local Zone, you can copy it within that Local Zone,
 * to another Local Zone in the same zone group, or to the parent Region of the Local
 * Zone.
 *
 * - If the source snapshot is on an Outpost, you can't copy it.
 *
 * When copying snapshots to a Region, the encryption outcome for the snapshot copy depends on the
 * Amazon EBS encryption by default setting for the destination Region, the encryption status of the source
 * snapshot, and the encryption parameters you specify in the request. For more information, see
 * Encryption and snapshot copying.
 *
 * Snapshots copied to an Outpost must be encrypted. Unencrypted snapshots are not supported
 * on Outposts. For more information,
 * Amazon EBS local snapshots on Outposts.
 *
 * Snapshots copies have an arbitrary source volume ID. Do not use this volume ID for
 * any purpose.
 *
 * For more information, see Copy an Amazon EBS snapshot in the
 * *Amazon EBS User Guide*.
 */
export const copySnapshot: API.OperationMethod<
  CopySnapshotRequest,
  CopySnapshotResult,
  CopySnapshotError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CopySnapshotRequest,
  output: CopySnapshotResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidRegion,
    InvalidSnapshotNotFound,
  ],
}));
export type CopyVolumesError =
  | RequestLimitExceeded
  | InvalidVolumeIDMalformed
  | CommonErrors;
/**
 * Creates a crash-consistent, point-in-time copy of an existing Amazon EBS volume within the same
 * Availability Zone. The volume copy can be attached to an Amazon EC2 instance once it reaches the
 * `available` state. For more information, see Copy an Amazon EBS volume.
 */
export const copyVolumes: API.OperationMethod<
  CopyVolumesRequest,
  CopyVolumesResult,
  CopyVolumesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CopyVolumesRequest,
  output: CopyVolumesResult,
  errors: [RequestLimitExceeded, InvalidVolumeIDMalformed],
}));
export type CreateCapacityManagerDataExportError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates a new data export configuration for EC2 Capacity Manager. This allows you to automatically export capacity usage data to an S3 bucket on a scheduled basis.
 * The exported data includes metrics for On-Demand, Spot, and Capacity Reservations usage across your organization.
 */
export const createCapacityManagerDataExport: API.OperationMethod<
  CreateCapacityManagerDataExportRequest,
  CreateCapacityManagerDataExportResult,
  CreateCapacityManagerDataExportError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateCapacityManagerDataExportRequest,
  output: CreateCapacityManagerDataExportResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateCapacityReservationError =
  | RequestLimitExceeded
  | Unsupported
  | CommonErrors;
/**
 * Creates a new Capacity Reservation with the specified attributes. Capacity
 * Reservations enable you to reserve capacity for your Amazon EC2 instances in a specific
 * Availability Zone for any duration.
 *
 * You can create a Capacity Reservation at any time, and you can choose when it starts.
 * You can create a Capacity Reservation for immediate use or you can request a Capacity
 * Reservation for a future date.
 *
 * For more information, see Reserve compute
 * capacity with On-Demand Capacity Reservations in the
 * *Amazon EC2 User Guide*.
 *
 * Your request to create a Capacity Reservation could fail if:
 *
 * - Amazon EC2 does not have sufficient capacity. In this case, try again
 * at a later time, try in a different Availability Zone, or request a smaller
 * Capacity Reservation. If your workload is flexible across instance types and
 * sizes, try with different instance attributes.
 *
 * - The requested quantity exceeds your On-Demand Instance quota. In this case,
 * increase your On-Demand Instance quota for the requested instance type and try
 * again. For more information, see
 * Amazon EC2 Service Quotas in the
 * *Amazon EC2 User Guide*.
 */
export const createCapacityReservation: API.OperationMethod<
  CreateCapacityReservationRequest,
  CreateCapacityReservationResult,
  CreateCapacityReservationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateCapacityReservationRequest,
  output: CreateCapacityReservationResult,
  errors: [RequestLimitExceeded, Unsupported],
}));
export type CreateCapacityReservationBySplittingError =
  | RequestLimitExceeded
  | InvalidCapacityReservationIdMalformed
  | InvalidCapacityReservationIdNotFound
  | CommonErrors;
/**
 * Create a new Capacity Reservation by splitting the capacity of the source Capacity
 * Reservation. The new Capacity Reservation will have the same attributes as the source
 * Capacity Reservation except for tags. The source Capacity Reservation must be
 * `active` and owned by your Amazon Web Services account.
 */
export const createCapacityReservationBySplitting: API.OperationMethod<
  CreateCapacityReservationBySplittingRequest,
  CreateCapacityReservationBySplittingResult,
  CreateCapacityReservationBySplittingError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateCapacityReservationBySplittingRequest,
  output: CreateCapacityReservationBySplittingResult,
  errors: [
    RequestLimitExceeded,
    InvalidCapacityReservationIdMalformed,
    InvalidCapacityReservationIdNotFound,
  ],
}));
export type CreateCapacityReservationFleetError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates a Capacity Reservation Fleet. For more information, see Create a
 * Capacity Reservation Fleet in the
 * *Amazon EC2 User Guide*.
 */
export const createCapacityReservationFleet: API.OperationMethod<
  CreateCapacityReservationFleetRequest,
  CreateCapacityReservationFleetResult,
  CreateCapacityReservationFleetError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateCapacityReservationFleetRequest,
  output: CreateCapacityReservationFleetResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateCarrierGatewayError =
  | RequestLimitExceeded
  | InvalidVpcIDNotFound
  | InvalidVpcIdMalformed
  | MissingParameter
  | ParseError
  | CommonErrors;
/**
 * Creates a carrier gateway. For more information about carrier gateways, see Carrier gateways in the *Amazon Web Services Wavelength Developer Guide*.
 */
export const createCarrierGateway: API.OperationMethod<
  CreateCarrierGatewayRequest,
  CreateCarrierGatewayResult,
  CreateCarrierGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateCarrierGatewayRequest,
  output: CreateCarrierGatewayResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcIDNotFound,
    InvalidVpcIdMalformed,
    MissingParameter,
    ParseError,
  ],
}));
export type CreateClientVpnEndpointError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates a Client VPN endpoint. A Client VPN endpoint is the resource you create and configure to
 * enable and manage client VPN sessions. It is the destination endpoint at which all client VPN sessions
 * are terminated.
 */
export const createClientVpnEndpoint: API.OperationMethod<
  CreateClientVpnEndpointRequest,
  CreateClientVpnEndpointResult,
  CreateClientVpnEndpointError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateClientVpnEndpointRequest,
  output: CreateClientVpnEndpointResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateClientVpnRouteError =
  | RequestLimitExceeded
  | InvalidClientVpnEndpointIdNotFound
  | CommonErrors;
/**
 * Adds a route to a network to a Client VPN endpoint. Each Client VPN endpoint has a route table that describes the
 * available destination network routes. Each route in the route table specifies the path for trac to specic resources or networks.
 */
export const createClientVpnRoute: API.OperationMethod<
  CreateClientVpnRouteRequest,
  CreateClientVpnRouteResult,
  CreateClientVpnRouteError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateClientVpnRouteRequest,
  output: CreateClientVpnRouteResult,
  errors: [RequestLimitExceeded, InvalidClientVpnEndpointIdNotFound],
}));
export type CreateCoipCidrError =
  | RequestLimitExceeded
  | InvalidPoolIDMalformed
  | InvalidPoolIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Creates a range of customer-owned IP addresses.
 */
export const createCoipCidr: API.OperationMethod<
  CreateCoipCidrRequest,
  CreateCoipCidrResult,
  CreateCoipCidrError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateCoipCidrRequest,
  output: CreateCoipCidrResult,
  errors: [
    RequestLimitExceeded,
    InvalidPoolIDMalformed,
    InvalidPoolIDNotFound,
    MissingParameter,
  ],
}));
export type CreateCoipPoolError =
  | RequestLimitExceeded
  | InvalidLocalGatewayRouteTableIDMalformed
  | InvalidLocalGatewayRouteTableIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Creates a pool of customer-owned IP (CoIP) addresses.
 */
export const createCoipPool: API.OperationMethod<
  CreateCoipPoolRequest,
  CreateCoipPoolResult,
  CreateCoipPoolError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateCoipPoolRequest,
  output: CreateCoipPoolResult,
  errors: [
    RequestLimitExceeded,
    InvalidLocalGatewayRouteTableIDMalformed,
    InvalidLocalGatewayRouteTableIDNotFound,
    MissingParameter,
  ],
}));
export type CreateCustomerGatewayError =
  | RequestLimitExceeded
  | MissingParameter
  | ParseError
  | CommonErrors;
/**
 * Provides information to Amazon Web Services about your customer gateway device. The
 * customer gateway device is the appliance at your end of the VPN connection. You
 * must provide the IP address of the customer gateway devices external
 * interface. The IP address must be static and can be behind a device performing network
 * address translation (NAT).
 *
 * For devices that use Border Gateway Protocol (BGP), you can also provide the device's
 * BGP Autonomous System Number (ASN). You can use an existing ASN assigned to your network.
 * If you don't have an ASN already, you can use a private ASN. For more information, see
 * Customer gateway
 * options for your Site-to-Site VPN connection in the *Amazon Web Services Site-to-Site VPN User Guide*.
 *
 * To create more than one customer gateway with the same VPN type, IP address, and
 * BGP ASN, specify a unique device name for each customer gateway. An identical request
 * returns information about the existing customer gateway; it doesn't create a new customer
 * gateway.
 */
export const createCustomerGateway: API.OperationMethod<
  CreateCustomerGatewayRequest,
  CreateCustomerGatewayResult,
  CreateCustomerGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateCustomerGatewayRequest,
  output: CreateCustomerGatewayResult,
  errors: [RequestLimitExceeded, MissingParameter, ParseError],
}));
export type CreateDefaultSubnetError =
  | RequestLimitExceeded
  | DefaultSubnetAlreadyExistsInAvailabilityZone
  | MissingParameter
  | CommonErrors;
/**
 * Creates a default subnet with a size `/20` IPv4 CIDR block in the
 * specified Availability Zone in your default VPC. You can have only one default subnet
 * per Availability Zone. For more information, see Create a default
 * subnet in the *Amazon VPC User Guide*.
 */
export const createDefaultSubnet: API.OperationMethod<
  CreateDefaultSubnetRequest,
  CreateDefaultSubnetResult,
  CreateDefaultSubnetError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateDefaultSubnetRequest,
  output: CreateDefaultSubnetResult,
  errors: [
    RequestLimitExceeded,
    DefaultSubnetAlreadyExistsInAvailabilityZone,
    MissingParameter,
  ],
}));
export type CreateDefaultVpcError =
  | RequestLimitExceeded
  | DefaultVpcAlreadyExists
  | CommonErrors;
/**
 * Creates a default VPC with a size `/16` IPv4 CIDR block and a default subnet
 * in each Availability Zone. For more information about the components of a default VPC,
 * see Default VPCs
 * in the *Amazon VPC User Guide*. You cannot specify the components of the
 * default VPC yourself.
 *
 * If you deleted your previous default VPC, you can create a default VPC. You cannot have
 * more than one default VPC per Region.
 */
export const createDefaultVpc: API.OperationMethod<
  CreateDefaultVpcRequest,
  CreateDefaultVpcResult,
  CreateDefaultVpcError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateDefaultVpcRequest,
  output: CreateDefaultVpcResult,
  errors: [RequestLimitExceeded, DefaultVpcAlreadyExists],
}));
export type CreateDelegateMacVolumeOwnershipTaskError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Delegates ownership of the Amazon EBS root volume for an Apple silicon
 * Mac instance to an administrative user.
 */
export const createDelegateMacVolumeOwnershipTask: API.OperationMethod<
  CreateDelegateMacVolumeOwnershipTaskRequest,
  CreateDelegateMacVolumeOwnershipTaskResult,
  CreateDelegateMacVolumeOwnershipTaskError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateDelegateMacVolumeOwnershipTaskRequest,
  output: CreateDelegateMacVolumeOwnershipTaskResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateDhcpOptionsError =
  | RequestLimitExceeded
  | MissingParameter
  | ParseError
  | CommonErrors;
/**
 * Creates a custom set of DHCP options. After you create a DHCP option set, you associate
 * it with a VPC. After you associate a DHCP option set with a VPC, all existing and newly
 * launched instances in the VPC use this set of DHCP options.
 *
 * The following are the individual DHCP options you can specify. For more information, see
 * DHCP option sets
 * in the *Amazon VPC User Guide*.
 *
 * - `domain-name` - If you're using AmazonProvidedDNS in `us-east-1`,
 * specify `ec2.internal`. If you're using AmazonProvidedDNS in any other Region,
 * specify `region.compute.internal`. Otherwise, specify a custom domain name.
 * This value is used to complete unqualified DNS hostnames.
 *
 * Some Linux operating systems accept multiple domain names separated by spaces.
 * However, Windows and other Linux operating systems treat the value as a single
 * domain, which results in unexpected behavior. If your DHCP option set is
 * associated with a VPC that has instances running operating systems that treat
 * the value as a single domain, specify only one domain name.
 *
 * - `domain-name-servers` - The IP addresses of up to four DNS servers,
 * or AmazonProvidedDNS. To specify multiple domain name servers in a single parameter,
 * separate the IP addresses using commas. To have your instances receive custom DNS
 * hostnames as specified in `domain-name`, you must specify a custom DNS
 * server.
 *
 * - `ntp-servers` - The IP addresses of up to eight Network Time Protocol (NTP)
 * servers (four IPv4 addresses and four IPv6 addresses).
 *
 * - `netbios-name-servers` - The IP addresses of up to four NetBIOS name
 * servers.
 *
 * - `netbios-node-type` - The NetBIOS node type (1, 2, 4, or 8). We recommend that
 * you specify 2. Broadcast and multicast are not supported. For more information about
 * NetBIOS node types, see RFC 2132.
 *
 * - `ipv6-address-preferred-lease-time` - A value (in seconds, minutes, hours, or years) for how frequently a running instance with an IPv6 assigned to it goes through DHCPv6 lease renewal.
 * Acceptable values are between 140 and 2147483647 seconds (approximately 68 years). If no value is entered, the default lease time is 140 seconds. If you use long-term addressing for EC2 instances, you can increase the lease time and avoid frequent
 * lease renewal requests. Lease renewal typically occurs when half of the lease time has elapsed.
 */
export const createDhcpOptions: API.OperationMethod<
  CreateDhcpOptionsRequest,
  CreateDhcpOptionsResult,
  CreateDhcpOptionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateDhcpOptionsRequest,
  output: CreateDhcpOptionsResult,
  errors: [RequestLimitExceeded, MissingParameter, ParseError],
}));
export type CreateEgressOnlyInternetGatewayError =
  | RequestLimitExceeded
  | InvalidVpcIDNotFound
  | InvalidVpcIdMalformed
  | MissingParameter
  | ParseError
  | CommonErrors;
/**
 * [IPv6 only] Creates an egress-only internet gateway for your VPC. An egress-only
 * internet gateway is used to enable outbound communication over IPv6 from instances in
 * your VPC to the internet, and prevents hosts outside of your VPC from initiating an IPv6
 * connection with your instance.
 */
export const createEgressOnlyInternetGateway: API.OperationMethod<
  CreateEgressOnlyInternetGatewayRequest,
  CreateEgressOnlyInternetGatewayResult,
  CreateEgressOnlyInternetGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateEgressOnlyInternetGatewayRequest,
  output: CreateEgressOnlyInternetGatewayResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcIDNotFound,
    InvalidVpcIdMalformed,
    MissingParameter,
    ParseError,
  ],
}));
export type CreateFleetError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates an EC2 Fleet that contains the configuration information for On-Demand Instances and Spot Instances.
 * Instances are launched immediately if there is available capacity.
 *
 * A single EC2 Fleet can include multiple launch specifications that vary by instance type,
 * AMI, Availability Zone, or subnet.
 *
 * For more information, see EC2 Fleet in the *Amazon EC2 User Guide*.
 */
export const createFleet: API.OperationMethod<
  CreateFleetRequest,
  CreateFleetResult,
  CreateFleetError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateFleetRequest,
  output: CreateFleetResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateFlowLogsError =
  | RequestLimitExceeded
  | InvalidID
  | InvalidParameterValue
  | MissingParameter
  | CommonErrors;
/**
 * Creates one or more flow logs to capture information about IP traffic for a specific network interface,
 * subnet, or VPC.
 *
 * Flow log data for a monitored network interface is recorded as flow log records, which are log events
 * consisting of fields that describe the traffic flow. For more information, see
 * Flow log records
 * in the *Amazon VPC User Guide*.
 *
 * When publishing to CloudWatch Logs, flow log records are published to a log group, and each network
 * interface has a unique log stream in the log group. When publishing to Amazon S3, flow log records for all
 * of the monitored network interfaces are published to a single log file object that is stored in the specified
 * bucket.
 *
 * For more information, see VPC Flow Logs
 * in the *Amazon VPC User Guide*.
 */
export const createFlowLogs: API.OperationMethod<
  CreateFlowLogsRequest,
  CreateFlowLogsResult,
  CreateFlowLogsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateFlowLogsRequest,
  output: CreateFlowLogsResult,
  errors: [
    RequestLimitExceeded,
    InvalidID,
    InvalidParameterValue,
    MissingParameter,
  ],
}));
export type CreateFpgaImageError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Creates an Amazon FPGA Image (AFI) from the specified design checkpoint (DCP).
 *
 * The create operation is asynchronous. To verify that the AFI was successfully
 * created and is ready for use, check the output logs.
 *
 * An AFI contains the FPGA bitstream that is ready to download to an FPGA.
 * You can securely deploy an AFI on multiple FPGA-accelerated instances.
 * For more information, see the Amazon Web Services FPGA Hardware Development Kit.
 */
export const createFpgaImage: API.OperationMethod<
  CreateFpgaImageRequest,
  CreateFpgaImageResult,
  CreateFpgaImageError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateFpgaImageRequest,
  output: CreateFpgaImageResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type CreateImageError =
  | RequestLimitExceeded
  | InvalidInstanceIDNotFound
  | InvalidParameterValue
  | CommonErrors;
/**
 * Creates an Amazon EBS-backed AMI from an Amazon EBS-backed instance that is either running or
 * stopped.
 *
 * If you customized your instance with instance store volumes or Amazon EBS volumes in addition
 * to the root device volume, the new AMI contains block device mapping information for those
 * volumes. When you launch an instance from this new AMI, the instance automatically launches
 * with those additional volumes.
 *
 * The location of the source instance determines where you can create the snapshots of the
 * AMI:
 *
 * - If the source instance is in a Region, you must create the snapshots in the same
 * Region as the instance.
 *
 * - If the source instance is in a Local Zone, you can create the snapshots in the same
 * Local Zone or in its parent Region.
 *
 * For more information, see Create an Amazon EBS-backed AMI in
 * the *Amazon Elastic Compute Cloud User Guide*.
 */
export const createImage: API.OperationMethod<
  CreateImageRequest,
  CreateImageResult,
  CreateImageError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateImageRequest,
  output: CreateImageResult,
  errors: [
    RequestLimitExceeded,
    InvalidInstanceIDNotFound,
    InvalidParameterValue,
  ],
}));
export type CreateImageUsageReportError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates a report that shows how your image is used across other Amazon Web Services accounts. The report
 * provides visibility into which accounts are using the specified image, and how many resources
 * (EC2 instances or launch templates) are referencing it.
 *
 * For more information, see View your AMI usage in the
 * *Amazon EC2 User Guide*.
 */
export const createImageUsageReport: API.OperationMethod<
  CreateImageUsageReportRequest,
  CreateImageUsageReportResult,
  CreateImageUsageReportError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateImageUsageReportRequest,
  output: CreateImageUsageReportResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateInstanceConnectEndpointError =
  | RequestLimitExceeded
  | InvalidGroupNotFound
  | InvalidSubnetIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Creates an EC2 Instance Connect Endpoint.
 *
 * An EC2 Instance Connect Endpoint allows you to connect to an instance, without
 * requiring the instance to have a public IPv4 or public IPv6 address. For more
 * information, see Connect to your instances using EC2 Instance Connect Endpoint in the
 * *Amazon EC2 User Guide*.
 */
export const createInstanceConnectEndpoint: API.OperationMethod<
  CreateInstanceConnectEndpointRequest,
  CreateInstanceConnectEndpointResult,
  CreateInstanceConnectEndpointError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateInstanceConnectEndpointRequest,
  output: CreateInstanceConnectEndpointResult,
  errors: [
    RequestLimitExceeded,
    InvalidGroupNotFound,
    InvalidSubnetIDNotFound,
    MissingParameter,
  ],
}));
export type CreateInstanceEventWindowError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Creates an event window in which scheduled events for the associated Amazon EC2 instances can
 * run.
 *
 * You can define either a set of time ranges or a cron expression when creating the event
 * window, but not both. All event window times are in UTC.
 *
 * You can create up to 200 event windows per Amazon Web Services Region.
 *
 * When you create the event window, targets (instance IDs, Dedicated Host IDs, or tags)
 * are not yet associated with it. To ensure that the event window can be used, you must
 * associate one or more targets with it by using the AssociateInstanceEventWindow API.
 *
 * Event windows are applicable only for scheduled events that stop, reboot, or
 * terminate instances.
 *
 * Event windows are *not* applicable for:
 *
 * - Expedited scheduled events and network maintenance events.
 *
 * - Unscheduled maintenance such as AutoRecovery and unplanned reboots.
 *
 * For more information, see Define event windows for scheduled
 * events in the *Amazon EC2 User Guide*.
 */
export const createInstanceEventWindow: API.OperationMethod<
  CreateInstanceEventWindowRequest,
  CreateInstanceEventWindowResult,
  CreateInstanceEventWindowError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateInstanceEventWindowRequest,
  output: CreateInstanceEventWindowResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type CreateInstanceExportTaskError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Exports a running or stopped instance to an Amazon S3 bucket.
 *
 * For information about the prerequisites for your Amazon S3 bucket, supported operating systems,
 * image formats, and known limitations for the types of instances you can export, see Exporting an instance as a VM Using VM
 * Import/Export in the *VM Import/Export User Guide*.
 */
export const createInstanceExportTask: API.OperationMethod<
  CreateInstanceExportTaskRequest,
  CreateInstanceExportTaskResult,
  CreateInstanceExportTaskError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateInstanceExportTaskRequest,
  output: CreateInstanceExportTaskResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateInternetGatewayError =
  | RequestLimitExceeded
  | InternetGatewayLimitExceeded
  | ParseError
  | CommonErrors;
/**
 * Creates an internet gateway for use with a VPC. After creating the internet gateway,
 * you attach it to a VPC using AttachInternetGateway.
 *
 * For more information, see Internet gateways in the
 * *Amazon VPC User Guide*.
 */
export const createInternetGateway: API.OperationMethod<
  CreateInternetGatewayRequest,
  CreateInternetGatewayResult,
  CreateInternetGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateInternetGatewayRequest,
  output: CreateInternetGatewayResult,
  errors: [RequestLimitExceeded, InternetGatewayLimitExceeded, ParseError],
}));
export type CreateInterruptibleCapacityReservationAllocationError =
  | RequestLimitExceeded
  | InvalidCapacityReservationIdNotFound
  | CommonErrors;
/**
 * Creates an interruptible Capacity Reservation by specifying the number of unused instances you want to allocate from your source reservation. This helps you make unused capacity available for other workloads within your account while maintaining control to reclaim it.
 */
export const createInterruptibleCapacityReservationAllocation: API.OperationMethod<
  CreateInterruptibleCapacityReservationAllocationRequest,
  CreateInterruptibleCapacityReservationAllocationResult,
  CreateInterruptibleCapacityReservationAllocationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateInterruptibleCapacityReservationAllocationRequest,
  output: CreateInterruptibleCapacityReservationAllocationResult,
  errors: [RequestLimitExceeded, InvalidCapacityReservationIdNotFound],
}));
export type CreateIpamError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | ParseError
  | ResourceLimitExceeded
  | CommonErrors;
/**
 * Create an IPAM. Amazon VPC IP Address Manager (IPAM) is a VPC feature that you can use
 * to automate your IP address management workflows including assigning, tracking,
 * troubleshooting, and auditing IP addresses across Amazon Web Services Regions and accounts
 * throughout your Amazon Web Services Organization.
 *
 * For more information, see Create an IPAM in the *Amazon VPC IPAM User Guide*.
 */
export const createIpam: API.OperationMethod<
  CreateIpamRequest,
  CreateIpamResult,
  CreateIpamError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateIpamRequest,
  output: CreateIpamResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    ParseError,
    ResourceLimitExceeded,
  ],
}));
export type CreateIpamExternalResourceVerificationTokenError =
  | RequestLimitExceeded
  | InvalidIpamIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Create a verification token.
 *
 * A verification token is an Amazon Web Services-generated random value that you can use to prove ownership of an external resource. For example, you can use a verification token to validate that you control a public IP address range when you bring an IP address range to Amazon Web Services (BYOIP).
 */
export const createIpamExternalResourceVerificationToken: API.OperationMethod<
  CreateIpamExternalResourceVerificationTokenRequest,
  CreateIpamExternalResourceVerificationTokenResult,
  CreateIpamExternalResourceVerificationTokenError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateIpamExternalResourceVerificationTokenRequest,
  output: CreateIpamExternalResourceVerificationTokenResult,
  errors: [RequestLimitExceeded, InvalidIpamIdNotFound, MissingParameter],
}));
export type CreateIpamPolicyError =
  | RequestLimitExceeded
  | InvalidIpamIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Creates an IPAM policy.
 *
 * An IPAM policy is a set of rules that define how public IPv4 addresses from IPAM pools are allocated to Amazon Web Services resources. Each rule maps an Amazon Web Services service to IPAM pools that the service will use to get IP addresses. A single policy can have multiple rules and be applied to multiple Amazon Web Services Regions. If the IPAM pool run out of addresses then the services fallback to Amazon-provided IP addresses. A policy can be applied to an individual Amazon Web Services account or an entity within Amazon Web Services Organizations.
 *
 * For more information, see Define public IPv4 allocation strategy with IPAM policies in the *Amazon VPC IPAM User Guide*.
 */
export const createIpamPolicy: API.OperationMethod<
  CreateIpamPolicyRequest,
  CreateIpamPolicyResult,
  CreateIpamPolicyError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateIpamPolicyRequest,
  output: CreateIpamPolicyResult,
  errors: [RequestLimitExceeded, InvalidIpamIdNotFound, MissingParameter],
}));
export type CreateIpamPoolError =
  | RequestLimitExceeded
  | InvalidIpamScopeIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Create an IP address pool for Amazon VPC IP Address Manager (IPAM). In IPAM, a pool is a collection of contiguous IP addresses CIDRs. Pools enable you to organize your IP addresses according to your routing and security needs. For example, if you have separate routing and security needs for development and production applications, you can create a pool for each.
 *
 * For more information, see Create a top-level pool in the *Amazon VPC IPAM User Guide*.
 */
export const createIpamPool: API.OperationMethod<
  CreateIpamPoolRequest,
  CreateIpamPoolResult,
  CreateIpamPoolError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateIpamPoolRequest,
  output: CreateIpamPoolResult,
  errors: [RequestLimitExceeded, InvalidIpamScopeIdNotFound, MissingParameter],
}));
export type CreateIpamPrefixListResolverError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates an IPAM prefix list resolver.
 *
 * An IPAM prefix list resolver is a component that manages the synchronization between IPAM's CIDR selection rules and customer-managed prefix lists. It automates connectivity configurations by selecting CIDRs from IPAM's database based on your business logic and synchronizing them with prefix lists used in resources such as VPC route tables and security groups.
 *
 * For more information about IPAM prefix list resolver, see Automate prefix list updates with IPAM in the *Amazon VPC IPAM User Guide*.
 */
export const createIpamPrefixListResolver: API.OperationMethod<
  CreateIpamPrefixListResolverRequest,
  CreateIpamPrefixListResolverResult,
  CreateIpamPrefixListResolverError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateIpamPrefixListResolverRequest,
  output: CreateIpamPrefixListResolverResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateIpamPrefixListResolverTargetError =
  | RequestLimitExceeded
  | InvalidIpamPrefixListResolverIdMalformed
  | InvalidIpamPrefixListResolverIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Creates an IPAM prefix list resolver target.
 *
 * An IPAM prefix list resolver target is an association between a specific customer-managed prefix list and an IPAM prefix list resolver. The target enables the resolver to synchronize CIDRs selected by its rules into the specified prefix list, which can then be referenced in Amazon Web Services resources.
 *
 * For more information about IPAM prefix list resolver, see Automate prefix list updates with IPAM in the *Amazon VPC IPAM User Guide*.
 */
export const createIpamPrefixListResolverTarget: API.OperationMethod<
  CreateIpamPrefixListResolverTargetRequest,
  CreateIpamPrefixListResolverTargetResult,
  CreateIpamPrefixListResolverTargetError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateIpamPrefixListResolverTargetRequest,
  output: CreateIpamPrefixListResolverTargetResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamPrefixListResolverIdMalformed,
    InvalidIpamPrefixListResolverIdNotFound,
    MissingParameter,
  ],
}));
export type CreateIpamResourceDiscoveryError =
  | RequestLimitExceeded
  | ResourceLimitExceeded
  | CommonErrors;
/**
 * Creates an IPAM resource discovery. A resource discovery is an IPAM component that enables IPAM to manage and monitor resources that belong to the owning account.
 */
export const createIpamResourceDiscovery: API.OperationMethod<
  CreateIpamResourceDiscoveryRequest,
  CreateIpamResourceDiscoveryResult,
  CreateIpamResourceDiscoveryError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateIpamResourceDiscoveryRequest,
  output: CreateIpamResourceDiscoveryResult,
  errors: [RequestLimitExceeded, ResourceLimitExceeded],
}));
export type CreateIpamScopeError =
  | RequestLimitExceeded
  | InvalidIpamIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Create an IPAM scope. In IPAM, a scope is the highest-level container within IPAM. An IPAM contains two default scopes. Each scope represents the IP space for a single network. The private scope is intended for all private IP address space. The public scope is intended for all public IP address space. Scopes enable you to reuse IP addresses across multiple unconnected networks without causing IP address overlap or conflict.
 *
 * For more information, see Add a scope in the *Amazon VPC IPAM User Guide*.
 */
export const createIpamScope: API.OperationMethod<
  CreateIpamScopeRequest,
  CreateIpamScopeResult,
  CreateIpamScopeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateIpamScopeRequest,
  output: CreateIpamScopeResult,
  errors: [RequestLimitExceeded, InvalidIpamIdNotFound, MissingParameter],
}));
export type CreateKeyPairError =
  | RequestLimitExceeded
  | InvalidKeyPairDuplicate
  | CommonErrors;
/**
 * Creates an ED25519 or 2048-bit RSA key pair with the specified name and in the
 * specified format. Amazon EC2 stores the public key and displays the private
 * key for you to save to a file. The private key is returned as an unencrypted PEM encoded
 * PKCS#1 private key or an unencrypted PPK formatted private key for use with PuTTY. If a
 * key with the specified name already exists, Amazon EC2 returns an error.
 *
 * The key pair returned to you is available only in the Amazon Web Services Region in which you create it.
 * If you prefer, you can create your own key pair using a third-party tool and upload it
 * to any Region using ImportKeyPair.
 *
 * You can have up to 5,000 key pairs per Amazon Web Services Region.
 *
 * For more information, see Amazon EC2 key pairs in the
 * *Amazon EC2 User Guide*.
 */
export const createKeyPair: API.OperationMethod<
  CreateKeyPairRequest,
  KeyPair,
  CreateKeyPairError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateKeyPairRequest,
  output: KeyPair,
  errors: [RequestLimitExceeded, InvalidKeyPairDuplicate],
}));
export type CreateLaunchTemplateError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates a launch template.
 *
 * A launch template contains the parameters to launch an instance. When you launch an
 * instance using RunInstances, you can specify a launch template instead
 * of providing the launch parameters in the request. For more information, see Store
 * instance launch parameters in Amazon EC2 launch templates in the
 * *Amazon EC2 User Guide*.
 *
 * To clone an existing launch template as the basis for a new launch template, use the
 * Amazon EC2 console. The API, SDKs, and CLI do not support cloning a template. For more
 * information, see Create a launch template from an existing launch template in the
 * *Amazon EC2 User Guide*.
 */
export const createLaunchTemplate: API.OperationMethod<
  CreateLaunchTemplateRequest,
  CreateLaunchTemplateResult,
  CreateLaunchTemplateError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateLaunchTemplateRequest,
  output: CreateLaunchTemplateResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateLaunchTemplateVersionError = CommonErrors;
/**
 * Creates a new version of a launch template. You must specify an existing launch
 * template, either by name or ID. You can determine whether the new version inherits
 * parameters from a source version, and add or overwrite parameters as needed.
 *
 * Launch template versions are numbered in the order in which they are created. You
 * can't specify, change, or replace the numbering of launch template versions.
 *
 * Launch templates are immutable; after you create a launch template, you can't modify
 * it. Instead, you can create a new version of the launch template that includes the
 * changes that you require.
 *
 * For more information, see Modify a launch
 * template (manage launch template versions) in the
 * *Amazon EC2 User Guide*.
 */
export const createLaunchTemplateVersion: API.OperationMethod<
  CreateLaunchTemplateVersionRequest,
  CreateLaunchTemplateVersionResult,
  CreateLaunchTemplateVersionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateLaunchTemplateVersionRequest,
  output: CreateLaunchTemplateVersionResult,
  errors: [],
}));
export type CreateLocalGatewayRouteError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | MissingParameter
  | CommonErrors;
/**
 * Creates a static route for the specified local gateway route table. You must specify one of the
 * following targets:
 *
 * - `LocalGatewayVirtualInterfaceGroupId`
 *
 * - `NetworkInterfaceId`
 */
export const createLocalGatewayRoute: API.OperationMethod<
  CreateLocalGatewayRouteRequest,
  CreateLocalGatewayRouteResult,
  CreateLocalGatewayRouteError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateLocalGatewayRouteRequest,
  output: CreateLocalGatewayRouteResult,
  errors: [RequestLimitExceeded, InvalidParameterValue, MissingParameter],
}));
export type CreateLocalGatewayRouteTableError =
  | RequestLimitExceeded
  | InvalidLocalGatewayIDMalformed
  | InvalidLocalGatewayIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Creates a local gateway route table.
 */
export const createLocalGatewayRouteTable: API.OperationMethod<
  CreateLocalGatewayRouteTableRequest,
  CreateLocalGatewayRouteTableResult,
  CreateLocalGatewayRouteTableError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateLocalGatewayRouteTableRequest,
  output: CreateLocalGatewayRouteTableResult,
  errors: [
    RequestLimitExceeded,
    InvalidLocalGatewayIDMalformed,
    InvalidLocalGatewayIDNotFound,
    MissingParameter,
  ],
}));
export type CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationError =
  | RequestLimitExceeded
  | InvalidLocalGatewayRouteTableIDNotFound
  | InvalidLocalGatewayVirtualInterfaceGroupIDMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Creates a local gateway route table virtual interface group association.
 */
export const createLocalGatewayRouteTableVirtualInterfaceGroupAssociation: API.OperationMethod<
  CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest,
  CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult,
  CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest,
  output: CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult,
  errors: [
    RequestLimitExceeded,
    InvalidLocalGatewayRouteTableIDNotFound,
    InvalidLocalGatewayVirtualInterfaceGroupIDMalformed,
    MissingParameter,
  ],
}));
export type CreateLocalGatewayRouteTableVpcAssociationError =
  | RequestLimitExceeded
  | InvalidLocalGatewayRouteTableIDMalformed
  | InvalidLocalGatewayRouteTableIDNotFound
  | InvalidVpcIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Associates the specified VPC with the specified local gateway route table.
 */
export const createLocalGatewayRouteTableVpcAssociation: API.OperationMethod<
  CreateLocalGatewayRouteTableVpcAssociationRequest,
  CreateLocalGatewayRouteTableVpcAssociationResult,
  CreateLocalGatewayRouteTableVpcAssociationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateLocalGatewayRouteTableVpcAssociationRequest,
  output: CreateLocalGatewayRouteTableVpcAssociationResult,
  errors: [
    RequestLimitExceeded,
    InvalidLocalGatewayRouteTableIDMalformed,
    InvalidLocalGatewayRouteTableIDNotFound,
    InvalidVpcIDNotFound,
    MissingParameter,
  ],
}));
export type CreateLocalGatewayVirtualInterfaceError =
  | RequestLimitExceeded
  | InvalidLocalGatewayVirtualInterfaceGroupIDMalformed
  | InvalidLocalGatewayVirtualInterfaceGroupIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Create a virtual interface for a local gateway.
 */
export const createLocalGatewayVirtualInterface: API.OperationMethod<
  CreateLocalGatewayVirtualInterfaceRequest,
  CreateLocalGatewayVirtualInterfaceResult,
  CreateLocalGatewayVirtualInterfaceError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateLocalGatewayVirtualInterfaceRequest,
  output: CreateLocalGatewayVirtualInterfaceResult,
  errors: [
    RequestLimitExceeded,
    InvalidLocalGatewayVirtualInterfaceGroupIDMalformed,
    InvalidLocalGatewayVirtualInterfaceGroupIDNotFound,
    MissingParameter,
  ],
}));
export type CreateLocalGatewayVirtualInterfaceGroupError =
  | RequestLimitExceeded
  | InvalidLocalGatewayIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Create a local gateway virtual interface group.
 */
export const createLocalGatewayVirtualInterfaceGroup: API.OperationMethod<
  CreateLocalGatewayVirtualInterfaceGroupRequest,
  CreateLocalGatewayVirtualInterfaceGroupResult,
  CreateLocalGatewayVirtualInterfaceGroupError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateLocalGatewayVirtualInterfaceGroupRequest,
  output: CreateLocalGatewayVirtualInterfaceGroupResult,
  errors: [
    RequestLimitExceeded,
    InvalidLocalGatewayIDNotFound,
    MissingParameter,
  ],
}));
export type CreateMacSystemIntegrityProtectionModificationTaskError =
  CommonErrors;
/**
 * Creates a System Integrity Protection (SIP) modification task to configure the SIP settings
 * for an x86 Mac instance or Apple silicon Mac instance. For more information, see
 *
 * Configure SIP for Amazon EC2 instances in the *Amazon EC2 User Guide*.
 *
 * When you configure the SIP settings for your instance, you can either enable
 * or disable all SIP settings, or you can specify a custom SIP configuration that
 * selectively enables or disables specific SIP settings.
 *
 * If you implement a custom configuration,
 * connect to the instance and verify the settings to ensure that your
 * requirements are properly implemented and functioning as intended.
 *
 * SIP configurations might change with macOS updates. We recommend that you
 * review custom SIP settings after any macOS version upgrade to ensure
 * continued compatibility and proper functionality of your security configurations.
 *
 * To enable or disable all SIP settings, use the **MacSystemIntegrityProtectionStatus**
 * parameter only. For example, to enable all SIP settings, specify the following:
 *
 * - `MacSystemIntegrityProtectionStatus=enabled`
 *
 * To specify a custom configuration that selectively enables or disables specific SIP
 * settings, use the **MacSystemIntegrityProtectionStatus**
 * parameter to enable or disable all SIP settings, and then use the
 * **MacSystemIntegrityProtectionConfiguration** parameter
 * to specify exceptions. In this case, the exceptions you specify for **MacSystemIntegrityProtectionConfiguration** override the value
 * you specify for **MacSystemIntegrityProtectionStatus**.
 * For example, to enable all SIP settings, except `NvramProtections`,
 * specify the following:
 *
 * - `MacSystemIntegrityProtectionStatus=enabled`
 *
 * - `MacSystemIntegrityProtectionConfigurationRequest "NvramProtections=disabled"`
 */
export const createMacSystemIntegrityProtectionModificationTask: API.OperationMethod<
  CreateMacSystemIntegrityProtectionModificationTaskRequest,
  CreateMacSystemIntegrityProtectionModificationTaskResult,
  CreateMacSystemIntegrityProtectionModificationTaskError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateMacSystemIntegrityProtectionModificationTaskRequest,
  output: CreateMacSystemIntegrityProtectionModificationTaskResult,
  errors: [],
}));
export type CreateManagedPrefixListError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | ParseError
  | CommonErrors;
/**
 * Creates a managed prefix list. You can specify entries for the prefix list.
 * Each entry consists of a CIDR block and an optional description.
 */
export const createManagedPrefixList: API.OperationMethod<
  CreateManagedPrefixListRequest,
  CreateManagedPrefixListResult,
  CreateManagedPrefixListError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateManagedPrefixListRequest,
  output: CreateManagedPrefixListResult,
  errors: [RequestLimitExceeded, InvalidParameterValue, ParseError],
}));
export type CreateNatGatewayError =
  | RequestLimitExceeded
  | InvalidElasticIpIDNotFound
  | InvalidSubnet
  | InvalidSubnetIDNotFound
  | MissingParameter
  | ParseError
  | CommonErrors;
/**
 * Creates a NAT gateway in the specified subnet. This action creates a network interface
 * in the specified subnet with a private IP address from the IP address range of the
 * subnet. You can create either a public NAT gateway or a private NAT gateway.
 *
 * With a public NAT gateway, internet-bound traffic from a private subnet can be routed
 * to the NAT gateway, so that instances in a private subnet can connect to the internet.
 *
 * With a private NAT gateway, private communication is routed across VPCs and on-premises
 * networks through a transit gateway or virtual private gateway. Common use cases include
 * running large workloads behind a small pool of allowlisted IPv4 addresses, preserving
 * private IPv4 addresses, and communicating between overlapping networks.
 *
 * For more information, see NAT gateways in the *Amazon VPC User Guide*.
 *
 * When you create a public NAT gateway and assign it an EIP or secondary EIPs,
 * the network border group of the EIPs must match the network border group of the Availability Zone (AZ)
 * that the public NAT gateway is in. If it's not the same, the NAT gateway will fail to launch.
 * You can see the network border group for the subnet's AZ by viewing the details of the subnet.
 * Similarly, you can view the network border group of an EIP by viewing the details of the EIP address.
 * For more information about network border groups and EIPs, see Allocate an Elastic IP address
 * in the *Amazon VPC User Guide*.
 */
export const createNatGateway: API.OperationMethod<
  CreateNatGatewayRequest,
  CreateNatGatewayResult,
  CreateNatGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateNatGatewayRequest,
  output: CreateNatGatewayResult,
  errors: [
    RequestLimitExceeded,
    InvalidElasticIpIDNotFound,
    InvalidSubnet,
    InvalidSubnetIDNotFound,
    MissingParameter,
    ParseError,
  ],
}));
export type CreateNetworkAclError =
  | RequestLimitExceeded
  | InvalidVpcIDNotFound
  | MissingParameter
  | ParseError
  | CommonErrors;
/**
 * Creates a network ACL in a VPC. Network ACLs provide an optional layer of security (in addition to security groups) for the instances in your VPC.
 *
 * For more information, see Network ACLs in the
 * *Amazon VPC User Guide*.
 */
export const createNetworkAcl: API.OperationMethod<
  CreateNetworkAclRequest,
  CreateNetworkAclResult,
  CreateNetworkAclError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateNetworkAclRequest,
  output: CreateNetworkAclResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcIDNotFound,
    MissingParameter,
    ParseError,
  ],
}));
export type CreateNetworkAclEntryError =
  | RequestLimitExceeded
  | InvalidNetworkAclIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Creates an entry (a rule) in a network ACL with the specified rule number. Each network ACL has a set of numbered ingress rules
 * and a separate set of numbered egress rules. When determining whether a packet should be allowed in or out of a subnet associated
 * with the ACL, we process the entries in the ACL according to the rule numbers, in ascending order. Each network ACL has a set of
 * ingress rules and a separate set of egress rules.
 *
 * We recommend that you leave room between the rule numbers (for example, 100, 110, 120, ...), and not number them one right after the
 * other (for example, 101, 102, 103, ...). This makes it easier to add a rule between existing ones without having to renumber the rules.
 *
 * After you add an entry, you can't modify it; you must either replace it, or create an entry and delete the old one.
 *
 * For more information about network ACLs, see Network ACLs
 * in the *Amazon VPC User Guide*.
 */
export const createNetworkAclEntry: API.OperationMethod<
  CreateNetworkAclEntryRequest,
  CreateNetworkAclEntryResponse,
  CreateNetworkAclEntryError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateNetworkAclEntryRequest,
  output: CreateNetworkAclEntryResponse,
  errors: [RequestLimitExceeded, InvalidNetworkAclIDNotFound, MissingParameter],
}));
export type CreateNetworkInsightsAccessScopeError = CommonErrors;
/**
 * Creates a Network Access Scope.
 *
 * Amazon Web Services Network Access Analyzer enables cloud networking and cloud operations teams
 * to verify that their networks on Amazon Web Services conform to their network security and governance
 * objectives. For more information, see the Amazon Web Services Network Access Analyzer Guide.
 */
export const createNetworkInsightsAccessScope: API.OperationMethod<
  CreateNetworkInsightsAccessScopeRequest,
  CreateNetworkInsightsAccessScopeResult,
  CreateNetworkInsightsAccessScopeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateNetworkInsightsAccessScopeRequest,
  output: CreateNetworkInsightsAccessScopeResult,
  errors: [],
}));
export type CreateNetworkInsightsPathError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | MissingParameter
  | CommonErrors;
/**
 * Creates a path to analyze for reachability.
 *
 * Reachability Analyzer enables you to analyze and debug network reachability between
 * two resources in your virtual private cloud (VPC). For more information, see the
 * Reachability Analyzer Guide.
 */
export const createNetworkInsightsPath: API.OperationMethod<
  CreateNetworkInsightsPathRequest,
  CreateNetworkInsightsPathResult,
  CreateNetworkInsightsPathError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateNetworkInsightsPathRequest,
  output: CreateNetworkInsightsPathResult,
  errors: [RequestLimitExceeded, InvalidParameterValue, MissingParameter],
}));
export type CreateNetworkInterfaceError =
  | RequestLimitExceeded
  | InvalidSubnetIDNotFound
  | MissingParameter
  | ParseError
  | CommonErrors;
/**
 * Creates a network interface in the specified subnet.
 *
 * The number of IP addresses you can assign to a network interface varies by instance
 * type.
 *
 * For more information about network interfaces, see Elastic network interfaces in the
 * *Amazon EC2 User Guide*.
 */
export const createNetworkInterface: API.OperationMethod<
  CreateNetworkInterfaceRequest,
  CreateNetworkInterfaceResult,
  CreateNetworkInterfaceError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateNetworkInterfaceRequest,
  output: CreateNetworkInterfaceResult,
  errors: [
    RequestLimitExceeded,
    InvalidSubnetIDNotFound,
    MissingParameter,
    ParseError,
  ],
}));
export type CreateNetworkInterfacePermissionError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Grants an Amazon Web Services-authorized account permission to attach the specified
 * network interface to an instance in their account.
 *
 * You can grant permission to a single Amazon Web Services account only, and only one
 * account at a time.
 */
export const createNetworkInterfacePermission: API.OperationMethod<
  CreateNetworkInterfacePermissionRequest,
  CreateNetworkInterfacePermissionResult,
  CreateNetworkInterfacePermissionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateNetworkInterfacePermissionRequest,
  output: CreateNetworkInterfacePermissionResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreatePlacementGroupError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | MissingParameter
  | CommonErrors;
/**
 * Creates a placement group in which to launch instances. The strategy of the placement
 * group determines how the instances are organized within the group.
 *
 * A `cluster` placement group is a logical grouping of instances within a
 * single Availability Zone that benefit from low network latency, high network throughput.
 * A `spread` placement group places instances on distinct hardware. A
 * `partition` placement group places groups of instances in different
 * partitions, where instances in one partition do not share the same hardware with
 * instances in another partition.
 *
 * For more information, see Placement groups in the
 * *Amazon EC2 User Guide*.
 */
export const createPlacementGroup: API.OperationMethod<
  CreatePlacementGroupRequest,
  CreatePlacementGroupResult,
  CreatePlacementGroupError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreatePlacementGroupRequest,
  output: CreatePlacementGroupResult,
  errors: [RequestLimitExceeded, InvalidParameterValue, MissingParameter],
}));
export type CreatePublicIpv4PoolError = CommonErrors;
/**
 * Creates a public IPv4 address pool. A public IPv4 pool is an EC2 IP address pool required for the public IPv4 CIDRs that you own and bring to Amazon Web Services to manage with IPAM. IPv6 addresses you bring to Amazon Web Services, however, use IPAM pools only. To monitor the status of pool creation, use DescribePublicIpv4Pools.
 */
export const createPublicIpv4Pool: API.OperationMethod<
  CreatePublicIpv4PoolRequest,
  CreatePublicIpv4PoolResult,
  CreatePublicIpv4PoolError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreatePublicIpv4PoolRequest,
  output: CreatePublicIpv4PoolResult,
  errors: [],
}));
export type CreateReplaceRootVolumeTaskError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | CommonErrors;
/**
 * Replaces the EBS-backed root volume for a `running` instance with a new
 * volume that is restored to the original root volume's launch state, that is restored to a
 * specific snapshot taken from the original root volume, or that is restored from an AMI
 * that has the same key characteristics as that of the instance.
 *
 * For more information, see Replace a root volume in the *Amazon EC2 User Guide*.
 */
export const createReplaceRootVolumeTask: API.OperationMethod<
  CreateReplaceRootVolumeTaskRequest,
  CreateReplaceRootVolumeTaskResult,
  CreateReplaceRootVolumeTaskError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateReplaceRootVolumeTaskRequest,
  output: CreateReplaceRootVolumeTaskResult,
  errors: [RequestLimitExceeded, InvalidInstanceIDMalformed],
}));
export type CreateReservedInstancesListingError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates a listing for Amazon EC2 Standard Reserved Instances to be sold in the Reserved
 * Instance Marketplace. You can submit one Standard Reserved Instance listing at a time. To get
 * a list of your Standard Reserved Instances, you can use the DescribeReservedInstances operation.
 *
 * Only Standard Reserved Instances can be sold in the Reserved Instance Marketplace.
 * Convertible Reserved Instances cannot be sold.
 *
 * The Reserved Instance Marketplace matches sellers who want to resell Standard Reserved
 * Instance capacity that they no longer need with buyers who want to purchase additional
 * capacity. Reserved Instances bought and sold through the Reserved Instance Marketplace work
 * like any other Reserved Instances.
 *
 * To sell your Standard Reserved Instances, you must first register as a seller in the
 * Reserved Instance Marketplace. After completing the registration process, you can create a
 * Reserved Instance Marketplace listing of some or all of your Standard Reserved Instances, and
 * specify the upfront price to receive for them. Your Standard Reserved Instance listings then
 * become available for purchase. To view the details of your Standard Reserved Instance listing,
 * you can use the DescribeReservedInstancesListings operation.
 *
 * For more information, see Sell in the Reserved Instance
 * Marketplace in the *Amazon EC2 User Guide*.
 */
export const createReservedInstancesListing: API.OperationMethod<
  CreateReservedInstancesListingRequest,
  CreateReservedInstancesListingResult,
  CreateReservedInstancesListingError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateReservedInstancesListingRequest,
  output: CreateReservedInstancesListingResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateRestoreImageTaskError =
  | RequestLimitExceeded
  | InvalidRequest
  | CommonErrors;
/**
 * Starts a task that restores an AMI from an Amazon S3 object that was previously created by
 * using CreateStoreImageTask.
 *
 * To use this API, you must have the required permissions. For more information, see Permissions for storing and restoring AMIs using S3 in the
 * *Amazon EC2 User Guide*.
 *
 * For more information, see Store and restore an AMI using
 * S3 in the *Amazon EC2 User Guide*.
 */
export const createRestoreImageTask: API.OperationMethod<
  CreateRestoreImageTaskRequest,
  CreateRestoreImageTaskResult,
  CreateRestoreImageTaskError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateRestoreImageTaskRequest,
  output: CreateRestoreImageTaskResult,
  errors: [RequestLimitExceeded, InvalidRequest],
}));
export type CreateRouteError =
  | RequestLimitExceeded
  | InvalidGatewayIDNotFound
  | InvalidInstanceIDMalformed
  | InvalidNetworkInterfaceIDNotFound
  | InvalidPrefixListIDNotFound
  | InvalidRouteTableIDNotFound
  | InvalidRouteTableIdMalformed
  | InvalidVpcEndpointIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Creates a route in a route table within a VPC.
 *
 * You must specify either a destination CIDR block or a prefix list ID. You must also specify
 * exactly one of the resources from the parameter list.
 *
 * When determining how to route traffic, we use the route with the most specific match.
 * For example, traffic is destined for the IPv4 address `192.0.2.3`, and the
 * route table includes the following two IPv4 routes:
 *
 * - `192.0.2.0/24` (goes to some target A)
 *
 * - `192.0.2.0/28` (goes to some target B)
 *
 * Both routes apply to the traffic destined for `192.0.2.3`. However, the second route
 * in the list covers a smaller number of IP addresses and is therefore more specific,
 * so we use that route to determine where to target the traffic.
 *
 * For more information about route tables, see Route tables in the
 * *Amazon VPC User Guide*.
 */
export const createRoute: API.OperationMethod<
  CreateRouteRequest,
  CreateRouteResult,
  CreateRouteError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateRouteRequest,
  output: CreateRouteResult,
  errors: [
    RequestLimitExceeded,
    InvalidGatewayIDNotFound,
    InvalidInstanceIDMalformed,
    InvalidNetworkInterfaceIDNotFound,
    InvalidPrefixListIDNotFound,
    InvalidRouteTableIDNotFound,
    InvalidRouteTableIdMalformed,
    InvalidVpcEndpointIdNotFound,
    MissingParameter,
  ],
}));
export type CreateRouteServerError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates a new route server to manage dynamic routing in a VPC.
 *
 * Amazon VPC Route Server simplifies routing for traffic between workloads that are deployed within a VPC and its internet gateways. With this feature,
 * VPC Route Server dynamically updates VPC and internet gateway route tables with your preferred IPv4 or IPv6 routes to achieve routing fault tolerance for those workloads. This enables you to automatically reroute traffic within a VPC, which increases the manageability of VPC routing and interoperability with third-party workloads.
 *
 * Route server supports the follow route table types:
 *
 * - VPC route tables not associated with subnets
 *
 * - Subnet route tables
 *
 * - Internet gateway route tables
 *
 * Route server does not support route tables associated with virtual private gateways. To propagate routes into a transit gateway route table, use Transit Gateway Connect.
 *
 * For more information see Dynamic routing in your VPC with VPC Route Server in the *Amazon VPC User Guide*.
 */
export const createRouteServer: API.OperationMethod<
  CreateRouteServerRequest,
  CreateRouteServerResult,
  CreateRouteServerError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateRouteServerRequest,
  output: CreateRouteServerResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateRouteServerEndpointError =
  | RequestLimitExceeded
  | InvalidRouteServerIdNotAssociated
  | InvalidRouteServerIdNotFound
  | InvalidSubnetIDMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Creates a new endpoint for a route server in a specified subnet.
 *
 * A route server endpoint is an Amazon Web Services-managed component inside a subnet that facilitates BGP (Border Gateway Protocol) connections between your route server and your BGP peers.
 *
 * For more information see Dynamic routing in your VPC with VPC Route Server in the *Amazon VPC User Guide*.
 */
export const createRouteServerEndpoint: API.OperationMethod<
  CreateRouteServerEndpointRequest,
  CreateRouteServerEndpointResult,
  CreateRouteServerEndpointError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateRouteServerEndpointRequest,
  output: CreateRouteServerEndpointResult,
  errors: [
    RequestLimitExceeded,
    InvalidRouteServerIdNotAssociated,
    InvalidRouteServerIdNotFound,
    InvalidSubnetIDMalformed,
    MissingParameter,
  ],
}));
export type CreateRouteServerPeerError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates a new BGP peer for a specified route server endpoint.
 *
 * A route server peer is a session between a route server endpoint and the device deployed in Amazon Web Services (such as a firewall appliance or other network security function running on an EC2 instance). The device must meet these requirements:
 *
 * - Have an elastic network interface in the VPC
 *
 * - Support BGP (Border Gateway Protocol)
 *
 * - Can initiate BGP sessions
 *
 * For more information see Dynamic routing in your VPC with VPC Route Server in the *Amazon VPC User Guide*.
 */
export const createRouteServerPeer: API.OperationMethod<
  CreateRouteServerPeerRequest,
  CreateRouteServerPeerResult,
  CreateRouteServerPeerError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateRouteServerPeerRequest,
  output: CreateRouteServerPeerResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateRouteTableError =
  | RequestLimitExceeded
  | InvalidVpcIDNotFound
  | MissingParameter
  | ParseError
  | CommonErrors;
/**
 * Creates a route table for the specified VPC. After you create a route table, you can add routes and associate the table with a subnet.
 *
 * For more information, see Route tables in the
 * *Amazon VPC User Guide*.
 */
export const createRouteTable: API.OperationMethod<
  CreateRouteTableRequest,
  CreateRouteTableResult,
  CreateRouteTableError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateRouteTableRequest,
  output: CreateRouteTableResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcIDNotFound,
    MissingParameter,
    ParseError,
  ],
}));
export type CreateSecondaryNetworkError = CommonErrors;
/**
 * Creates a secondary network.
 *
 * The allowed size for a secondary network CIDR block is between /28 netmask (16 IP addresses) and /12 netmask (1,048,576 IP addresses).
 */
export const createSecondaryNetwork: API.OperationMethod<
  CreateSecondaryNetworkRequest,
  CreateSecondaryNetworkResult,
  CreateSecondaryNetworkError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateSecondaryNetworkRequest,
  output: CreateSecondaryNetworkResult,
  errors: [],
}));
export type CreateSecondarySubnetError = CommonErrors;
/**
 * Creates a secondary subnet in a secondary network.
 *
 * A secondary subnet CIDR block must not overlap with the CIDR block of an existing secondary subnet in the secondary network. After you create a secondary subnet, you can't change its CIDR block.
 *
 * The allowed size for a secondary subnet CIDR block is between /28 netmask (16 IP addresses) and /12 netmask (1,048,576 IP addresses). Amazon reserves the first four IP addresses and the last IP address in each secondary subnet for internal use.
 */
export const createSecondarySubnet: API.OperationMethod<
  CreateSecondarySubnetRequest,
  CreateSecondarySubnetResult,
  CreateSecondarySubnetError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateSecondarySubnetRequest,
  output: CreateSecondarySubnetResult,
  errors: [],
}));
export type CreateSecurityGroupError =
  | RequestLimitExceeded
  | InvalidGroupDuplicate
  | InvalidParameterValue
  | InvalidVpcIDNotFound
  | InvalidVpcIdMalformed
  | MissingParameter
  | VPCIdNotSpecified
  | CommonErrors;
/**
 * Creates a security group.
 *
 * A security group acts as a virtual firewall for your instance to control inbound and outbound traffic.
 * For more information, see
 * Amazon EC2 security groups in
 * the *Amazon EC2 User Guide* and
 * Security groups for your VPC in the
 * *Amazon VPC User Guide*.
 *
 * When you create a security group, you specify a friendly name of your choice.
 * You can't have two security groups for the same VPC with the same name.
 *
 * You have a default security group for use in your VPC. If you don't specify a security group
 * when you launch an instance, the instance is launched into the appropriate default security group.
 * A default security group includes a default rule that grants instances unrestricted network access
 * to each other.
 *
 * You can add or remove rules from your security groups using
 * AuthorizeSecurityGroupIngress,
 * AuthorizeSecurityGroupEgress,
 * RevokeSecurityGroupIngress, and
 * RevokeSecurityGroupEgress.
 *
 * For more information about VPC security group limits, see Amazon VPC Limits.
 */
export const createSecurityGroup: API.OperationMethod<
  CreateSecurityGroupRequest,
  CreateSecurityGroupResult,
  CreateSecurityGroupError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateSecurityGroupRequest,
  output: CreateSecurityGroupResult,
  errors: [
    RequestLimitExceeded,
    InvalidGroupDuplicate,
    InvalidParameterValue,
    InvalidVpcIDNotFound,
    InvalidVpcIdMalformed,
    MissingParameter,
    VPCIdNotSpecified,
  ],
}));
export type CreateSnapshotError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidVolumeNotFound
  | InvalidVolumeIDMalformed
  | CommonErrors;
/**
 * Creates a snapshot of an EBS volume and stores it in Amazon S3. You can use snapshots for
 * backups, to make copies of EBS volumes, and to save data before shutting down an
 * instance.
 *
 * The location of the source EBS volume determines where you can create the snapshot.
 *
 * - If the source volume is in a Region, you must create the snapshot in the same
 * Region as the volume.
 *
 * - If the source volume is in a Local Zone, you can create the snapshot in the same Local
 * Zone or in its parent Amazon Web Services Region.
 *
 * - If the source volume is on an Outpost, you can create the snapshot on the same
 * Outpost or in its parent Amazon Web Services Region.
 *
 * When a snapshot is created, any Amazon Web Services Marketplace product codes that are associated with the
 * source volume are propagated to the snapshot.
 *
 * You can take a snapshot of an attached volume that is in use. However, snapshots only
 * capture data that has been written to your Amazon EBS volume at the time the snapshot command is
 * issued; this might exclude any data that has been cached by any applications or the operating
 * system. If you can pause any file systems on the volume long enough to take a snapshot, your
 * snapshot should be complete. However, if you cannot pause all file writes to the volume, you
 * should unmount the volume from within the instance, issue the snapshot command, and then
 * remount the volume to ensure a consistent and complete snapshot. You may remount and use your
 * volume while the snapshot status is `pending`.
 *
 * When you create a snapshot for an EBS volume that serves as a root device, we recommend
 * that you stop the instance before taking the snapshot.
 *
 * Snapshots that are taken from encrypted volumes are automatically encrypted. Volumes that
 * are created from encrypted snapshots are also automatically encrypted. Your encrypted volumes
 * and any associated snapshots always remain protected. For more information, see Amazon EBS encryption
 * in the *Amazon EBS User Guide*.
 */
export const createSnapshot: API.OperationMethod<
  CreateSnapshotRequest,
  Snapshot,
  CreateSnapshotError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateSnapshotRequest,
  output: Snapshot,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidVolumeNotFound,
    InvalidVolumeIDMalformed,
  ],
}));
export type CreateSnapshotsError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates crash-consistent snapshots of multiple EBS volumes attached to an Amazon EC2 instance.
 * Volumes are chosen by specifying an instance. Each volume attached to the specified instance
 * will produce one snapshot that is crash-consistent across the instance. You can include all of
 * the volumes currently attached to the instance, or you can exclude the root volume or specific
 * data (non-root) volumes from the multi-volume snapshot set.
 *
 * The location of the source instance determines where you can create the snapshots.
 *
 * - If the source instance is in a Region, you must create the snapshots in the same
 * Region as the instance.
 *
 * - If the source instance is in a Local Zone, you can create the snapshots in the same
 * Local Zone or in its parent Amazon Web Services Region.
 *
 * - If the source instance is on an Outpost, you can create the snapshots on the same
 * Outpost or in its parent Amazon Web Services Region.
 */
export const createSnapshots: API.OperationMethod<
  CreateSnapshotsRequest,
  CreateSnapshotsResult,
  CreateSnapshotsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateSnapshotsRequest,
  output: CreateSnapshotsResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateSpotDatafeedSubscriptionError =
  | RequestLimitExceeded
  | InaccessibleStorageLocation
  | CommonErrors;
/**
 * Creates a data feed for Spot Instances, enabling you to view Spot Instance usage logs.
 * You can create one data feed per Amazon Web Services account. For more information, see
 * Spot Instance data feed
 * in the *Amazon EC2 User Guide*.
 */
export const createSpotDatafeedSubscription: API.OperationMethod<
  CreateSpotDatafeedSubscriptionRequest,
  CreateSpotDatafeedSubscriptionResult,
  CreateSpotDatafeedSubscriptionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateSpotDatafeedSubscriptionRequest,
  output: CreateSpotDatafeedSubscriptionResult,
  errors: [RequestLimitExceeded, InaccessibleStorageLocation],
}));
export type CreateStoreImageTaskError =
  | RequestLimitExceeded
  | InvalidAMIIDMalformed
  | CommonErrors;
/**
 * Stores an AMI as a single object in an Amazon S3 bucket.
 *
 * To use this API, you must have the required permissions. For more information, see Permissions for storing and restoring AMIs using S3 in the
 * *Amazon EC2 User Guide*.
 *
 * For more information, see Store and restore an AMI using
 * S3 in the *Amazon EC2 User Guide*.
 */
export const createStoreImageTask: API.OperationMethod<
  CreateStoreImageTaskRequest,
  CreateStoreImageTaskResult,
  CreateStoreImageTaskError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateStoreImageTaskRequest,
  output: CreateStoreImageTaskResult,
  errors: [RequestLimitExceeded, InvalidAMIIDMalformed],
}));
export type CreateSubnetError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidVpcIDNotFound
  | MissingParameter
  | ParseError
  | CommonErrors;
/**
 * Creates a subnet in the specified VPC. For an IPv4 only subnet, specify an IPv4 CIDR block.
 * If the VPC has an IPv6 CIDR block, you can create an IPv6 only subnet or a dual stack subnet instead.
 * For an IPv6 only subnet, specify an IPv6 CIDR block. For a dual stack subnet, specify both
 * an IPv4 CIDR block and an IPv6 CIDR block.
 *
 * A subnet CIDR block must not overlap the CIDR block of an existing subnet in the VPC.
 * After you create a subnet, you can't change its CIDR block.
 *
 * The allowed size for an IPv4 subnet is between a /28 netmask (16 IP addresses) and
 * a /16 netmask (65,536 IP addresses). Amazon Web Services reserves both the first four and
 * the last IPv4 address in each subnet's CIDR block. They're not available for your use.
 *
 * If you've associated an IPv6 CIDR block with your VPC, you can associate an IPv6 CIDR
 * block with a subnet when you create it.
 *
 * If you add more than one subnet to a VPC, they're set up in a star topology with a
 * logical router in the middle.
 *
 * When you stop an instance in a subnet, it retains its private IPv4 address. It's
 * therefore possible to have a subnet with no running instances (they're all stopped), but
 * no remaining IP addresses available.
 *
 * For more information, see Subnets in the *Amazon VPC User Guide*.
 */
export const createSubnet: API.OperationMethod<
  CreateSubnetRequest,
  CreateSubnetResult,
  CreateSubnetError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateSubnetRequest,
  output: CreateSubnetResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidVpcIDNotFound,
    MissingParameter,
    ParseError,
  ],
}));
export type CreateSubnetCidrReservationError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidSubnetIDMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Creates a subnet CIDR reservation. For more information, see Subnet CIDR reservations
 * in the *Amazon VPC User Guide* and Manage prefixes
 * for your network interfaces in the *Amazon EC2 User Guide*.
 */
export const createSubnetCidrReservation: API.OperationMethod<
  CreateSubnetCidrReservationRequest,
  CreateSubnetCidrReservationResult,
  CreateSubnetCidrReservationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateSubnetCidrReservationRequest,
  output: CreateSubnetCidrReservationResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidSubnetIDMalformed,
    MissingParameter,
  ],
}));
export type CreateTagsError =
  | RequestLimitExceeded
  | InvalidID
  | MissingParameter
  | CommonErrors;
/**
 * Adds or overwrites only the specified tags for the specified Amazon EC2 resource or
 * resources. When you specify an existing tag key, the value is overwritten with
 * the new value. Each resource can have a maximum of 50 tags. Each tag consists of a key and
 * optional value. Tag keys must be unique per resource.
 *
 * For more information about tags, see Tag your Amazon EC2 resources in the
 * *Amazon Elastic Compute Cloud User Guide*. For more information about
 * creating IAM policies that control users' access to resources based on tags, see Supported
 * resource-level permissions for Amazon EC2 API actions in the Amazon
 * Elastic Compute Cloud User Guide.
 */
export const createTags: API.OperationMethod<
  CreateTagsRequest,
  CreateTagsResponse,
  CreateTagsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTagsRequest,
  output: CreateTagsResponse,
  errors: [RequestLimitExceeded, InvalidID, MissingParameter],
}));
export type CreateTrafficMirrorFilterError =
  | RequestLimitExceeded
  | ParseError
  | CommonErrors;
/**
 * Creates a Traffic Mirror filter.
 *
 * A Traffic Mirror filter is a set of rules that defines the traffic to mirror.
 *
 * By default, no traffic is mirrored. To mirror traffic, use CreateTrafficMirrorFilterRule
 * to add Traffic Mirror rules to the filter. The rules you add define what traffic gets mirrored.
 * You can also use ModifyTrafficMirrorFilterNetworkServices to mirror supported network services.
 */
export const createTrafficMirrorFilter: API.OperationMethod<
  CreateTrafficMirrorFilterRequest,
  CreateTrafficMirrorFilterResult,
  CreateTrafficMirrorFilterError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTrafficMirrorFilterRequest,
  output: CreateTrafficMirrorFilterResult,
  errors: [RequestLimitExceeded, ParseError],
}));
export type CreateTrafficMirrorFilterRuleError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates a Traffic Mirror filter rule.
 *
 * A Traffic Mirror rule defines the Traffic Mirror source traffic to mirror.
 *
 * You need the Traffic Mirror filter ID when you create the rule.
 */
export const createTrafficMirrorFilterRule: API.OperationMethod<
  CreateTrafficMirrorFilterRuleRequest,
  CreateTrafficMirrorFilterRuleResult,
  CreateTrafficMirrorFilterRuleError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTrafficMirrorFilterRuleRequest,
  output: CreateTrafficMirrorFilterRuleResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateTrafficMirrorSessionError =
  | RequestLimitExceeded
  | InvalidNetworkInterfaceIDNotFound
  | InvalidParameterValue
  | MissingParameter
  | CommonErrors;
/**
 * Creates a Traffic Mirror session.
 *
 * A Traffic Mirror session actively copies packets from a Traffic Mirror source to a Traffic Mirror target. Create a filter, and then assign it
 * to the session to define a subset of the traffic to mirror, for example all TCP
 * traffic.
 *
 * The Traffic Mirror source and the Traffic Mirror target (monitoring appliances) can be in the same VPC, or in a different VPC connected via VPC peering or a transit gateway.
 *
 * By default, no traffic is mirrored. Use CreateTrafficMirrorFilter to
 * create filter rules that specify the traffic to mirror.
 */
export const createTrafficMirrorSession: API.OperationMethod<
  CreateTrafficMirrorSessionRequest,
  CreateTrafficMirrorSessionResult,
  CreateTrafficMirrorSessionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTrafficMirrorSessionRequest,
  output: CreateTrafficMirrorSessionResult,
  errors: [
    RequestLimitExceeded,
    InvalidNetworkInterfaceIDNotFound,
    InvalidParameterValue,
    MissingParameter,
  ],
}));
export type CreateTrafficMirrorTargetError =
  | RequestLimitExceeded
  | InvalidParameterCombination
  | CommonErrors;
/**
 * Creates a target for your Traffic Mirror session.
 *
 * A Traffic Mirror target is the destination for mirrored traffic. The Traffic Mirror source and
 * the Traffic Mirror target (monitoring appliances) can be in the same VPC, or in
 * different VPCs connected via VPC peering or a transit gateway.
 *
 * A Traffic Mirror target can be a network interface, a Network Load Balancer, or a Gateway Load Balancer endpoint.
 *
 * To use the target in a Traffic Mirror session, use CreateTrafficMirrorSession.
 */
export const createTrafficMirrorTarget: API.OperationMethod<
  CreateTrafficMirrorTargetRequest,
  CreateTrafficMirrorTargetResult,
  CreateTrafficMirrorTargetError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTrafficMirrorTargetRequest,
  output: CreateTrafficMirrorTargetResult,
  errors: [RequestLimitExceeded, InvalidParameterCombination],
}));
export type CreateTransitGatewayError =
  | RequestLimitExceeded
  | ParseError
  | TransitGatewayLimitExceeded
  | CommonErrors;
/**
 * Creates a transit gateway.
 *
 * You can use a transit gateway to interconnect your virtual private clouds (VPC) and on-premises networks.
 * After the transit gateway enters the `available` state, you can attach your VPCs and VPN
 * connections to the transit gateway.
 *
 * To attach your VPCs, use CreateTransitGatewayVpcAttachment.
 *
 * To attach a VPN connection, use CreateCustomerGateway to create a customer
 * gateway and specify the ID of the customer gateway and the ID of the transit gateway in a call to
 * CreateVpnConnection.
 *
 * When you create a transit gateway, we create a default transit gateway route table and use it as the default association route table
 * and the default propagation route table. You can use CreateTransitGatewayRouteTable to create
 * additional transit gateway route tables. If you disable automatic route propagation, we do not create a default transit gateway route table.
 * You can use EnableTransitGatewayRouteTablePropagation to propagate routes from a resource
 * attachment to a transit gateway route table. If you disable automatic associations, you can use AssociateTransitGatewayRouteTable to associate a resource attachment with a transit gateway route table.
 */
export const createTransitGateway: API.OperationMethod<
  CreateTransitGatewayRequest,
  CreateTransitGatewayResult,
  CreateTransitGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTransitGatewayRequest,
  output: CreateTransitGatewayResult,
  errors: [RequestLimitExceeded, ParseError, TransitGatewayLimitExceeded],
}));
export type CreateTransitGatewayConnectError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates a Connect attachment from a specified transit gateway attachment. A Connect attachment is a GRE-based tunnel attachment that you can use to establish a connection between a transit gateway and an appliance.
 *
 * A Connect attachment uses an existing VPC or Amazon Web Services Direct Connect attachment as the underlying transport mechanism.
 */
export const createTransitGatewayConnect: API.OperationMethod<
  CreateTransitGatewayConnectRequest,
  CreateTransitGatewayConnectResult,
  CreateTransitGatewayConnectError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTransitGatewayConnectRequest,
  output: CreateTransitGatewayConnectResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateTransitGatewayConnectPeerError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates a Connect peer for a specified transit gateway Connect attachment between a
 * transit gateway and an appliance.
 *
 * The peer address and transit gateway address must be the same IP address family (IPv4 or IPv6).
 *
 * For more information, see Connect peers
 * in the *Amazon Web Services Transit Gateways Guide*.
 */
export const createTransitGatewayConnectPeer: API.OperationMethod<
  CreateTransitGatewayConnectPeerRequest,
  CreateTransitGatewayConnectPeerResult,
  CreateTransitGatewayConnectPeerError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTransitGatewayConnectPeerRequest,
  output: CreateTransitGatewayConnectPeerResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateTransitGatewayMeteringPolicyError =
  | RequestLimitExceeded
  | IncorrectState
  | InvalidTransitGatewayIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Creates a metering policy for a transit gateway to track and measure network traffic.
 */
export const createTransitGatewayMeteringPolicy: API.OperationMethod<
  CreateTransitGatewayMeteringPolicyRequest,
  CreateTransitGatewayMeteringPolicyResult,
  CreateTransitGatewayMeteringPolicyError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTransitGatewayMeteringPolicyRequest,
  output: CreateTransitGatewayMeteringPolicyResult,
  errors: [
    RequestLimitExceeded,
    IncorrectState,
    InvalidTransitGatewayIDNotFound,
    MissingParameter,
  ],
}));
export type CreateTransitGatewayMeteringPolicyEntryError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates an entry in a transit gateway metering policy to define traffic measurement rules.
 */
export const createTransitGatewayMeteringPolicyEntry: API.OperationMethod<
  CreateTransitGatewayMeteringPolicyEntryRequest,
  CreateTransitGatewayMeteringPolicyEntryResult,
  CreateTransitGatewayMeteringPolicyEntryError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTransitGatewayMeteringPolicyEntryRequest,
  output: CreateTransitGatewayMeteringPolicyEntryResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateTransitGatewayMulticastDomainError =
  | RequestLimitExceeded
  | IncorrectState
  | InvalidTransitGatewayIDMalformed
  | InvalidTransitGatewayIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Creates a multicast domain using the specified transit gateway.
 *
 * The transit gateway must be in the available state before you create a domain. Use DescribeTransitGateways to see the state of transit gateway.
 */
export const createTransitGatewayMulticastDomain: API.OperationMethod<
  CreateTransitGatewayMulticastDomainRequest,
  CreateTransitGatewayMulticastDomainResult,
  CreateTransitGatewayMulticastDomainError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTransitGatewayMulticastDomainRequest,
  output: CreateTransitGatewayMulticastDomainResult,
  errors: [
    RequestLimitExceeded,
    IncorrectState,
    InvalidTransitGatewayIDMalformed,
    InvalidTransitGatewayIDNotFound,
    MissingParameter,
  ],
}));
export type CreateTransitGatewayPeeringAttachmentError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidTransitGatewayIDMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Requests a transit gateway peering attachment between the specified transit gateway
 * (requester) and a peer transit gateway (accepter). The peer transit gateway can be in
 * your account or a different Amazon Web Services account.
 *
 * After you create the peering attachment, the owner of the accepter transit gateway
 * must accept the attachment request.
 */
export const createTransitGatewayPeeringAttachment: API.OperationMethod<
  CreateTransitGatewayPeeringAttachmentRequest,
  CreateTransitGatewayPeeringAttachmentResult,
  CreateTransitGatewayPeeringAttachmentError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTransitGatewayPeeringAttachmentRequest,
  output: CreateTransitGatewayPeeringAttachmentResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidTransitGatewayIDMalformed,
    MissingParameter,
  ],
}));
export type CreateTransitGatewayPolicyTableError =
  | RequestLimitExceeded
  | IncorrectState
  | InvalidTransitGatewayIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Creates a transit gateway policy table.
 */
export const createTransitGatewayPolicyTable: API.OperationMethod<
  CreateTransitGatewayPolicyTableRequest,
  CreateTransitGatewayPolicyTableResult,
  CreateTransitGatewayPolicyTableError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTransitGatewayPolicyTableRequest,
  output: CreateTransitGatewayPolicyTableResult,
  errors: [
    RequestLimitExceeded,
    IncorrectState,
    InvalidTransitGatewayIDNotFound,
    MissingParameter,
  ],
}));
export type CreateTransitGatewayPrefixListReferenceError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates a reference (route) to a prefix list in a specified transit gateway route table.
 */
export const createTransitGatewayPrefixListReference: API.OperationMethod<
  CreateTransitGatewayPrefixListReferenceRequest,
  CreateTransitGatewayPrefixListReferenceResult,
  CreateTransitGatewayPrefixListReferenceError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTransitGatewayPrefixListReferenceRequest,
  output: CreateTransitGatewayPrefixListReferenceResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateTransitGatewayRouteError =
  | RequestLimitExceeded
  | InvalidRouteTableIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Creates a static route for the specified transit gateway route table.
 */
export const createTransitGatewayRoute: API.OperationMethod<
  CreateTransitGatewayRouteRequest,
  CreateTransitGatewayRouteResult,
  CreateTransitGatewayRouteError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTransitGatewayRouteRequest,
  output: CreateTransitGatewayRouteResult,
  errors: [RequestLimitExceeded, InvalidRouteTableIDNotFound, MissingParameter],
}));
export type CreateTransitGatewayRouteTableError =
  | RequestLimitExceeded
  | IncorrectState
  | InvalidTransitGatewayIDNotFound
  | MissingParameter
  | ParseError
  | CommonErrors;
/**
 * Creates a route table for the specified transit gateway.
 */
export const createTransitGatewayRouteTable: API.OperationMethod<
  CreateTransitGatewayRouteTableRequest,
  CreateTransitGatewayRouteTableResult,
  CreateTransitGatewayRouteTableError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTransitGatewayRouteTableRequest,
  output: CreateTransitGatewayRouteTableResult,
  errors: [
    RequestLimitExceeded,
    IncorrectState,
    InvalidTransitGatewayIDNotFound,
    MissingParameter,
    ParseError,
  ],
}));
export type CreateTransitGatewayRouteTableAnnouncementError =
  | RequestLimitExceeded
  | InvalidRouteTableIDNotFound
  | InvalidTransitGatewayAttachmentIDMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Advertises a new transit gateway route table.
 */
export const createTransitGatewayRouteTableAnnouncement: API.OperationMethod<
  CreateTransitGatewayRouteTableAnnouncementRequest,
  CreateTransitGatewayRouteTableAnnouncementResult,
  CreateTransitGatewayRouteTableAnnouncementError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTransitGatewayRouteTableAnnouncementRequest,
  output: CreateTransitGatewayRouteTableAnnouncementResult,
  errors: [
    RequestLimitExceeded,
    InvalidRouteTableIDNotFound,
    InvalidTransitGatewayAttachmentIDMalformed,
    MissingParameter,
  ],
}));
export type CreateTransitGatewayVpcAttachmentError =
  | RequestLimitExceeded
  | InvalidSubnetIDNotFound
  | InvalidTransitGatewayIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Attaches the specified VPC to the specified transit gateway.
 *
 * If you attach a VPC with a CIDR range that overlaps the CIDR range of a VPC that is already attached,
 * the new VPC CIDR range is not propagated to the default propagation route table.
 *
 * To send VPC traffic to an attached transit gateway, add a route to the VPC route table using CreateRoute.
 */
export const createTransitGatewayVpcAttachment: API.OperationMethod<
  CreateTransitGatewayVpcAttachmentRequest,
  CreateTransitGatewayVpcAttachmentResult,
  CreateTransitGatewayVpcAttachmentError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTransitGatewayVpcAttachmentRequest,
  output: CreateTransitGatewayVpcAttachmentResult,
  errors: [
    RequestLimitExceeded,
    InvalidSubnetIDNotFound,
    InvalidTransitGatewayIDNotFound,
    MissingParameter,
  ],
}));
export type CreateVerifiedAccessEndpointError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * An Amazon Web Services Verified Access endpoint is where you define your application along with an optional endpoint-level access policy.
 */
export const createVerifiedAccessEndpoint: API.OperationMethod<
  CreateVerifiedAccessEndpointRequest,
  CreateVerifiedAccessEndpointResult,
  CreateVerifiedAccessEndpointError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVerifiedAccessEndpointRequest,
  output: CreateVerifiedAccessEndpointResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateVerifiedAccessGroupError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidVerifiedAccessInstanceIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * An Amazon Web Services Verified Access group is a collection of Amazon Web Services Verified Access endpoints who's associated applications have
 * similar security requirements. Each instance within a Verified Access group shares an Verified Access policy. For
 * example, you can group all Verified Access instances associated with "sales" applications together and
 * use one common Verified Access policy.
 */
export const createVerifiedAccessGroup: API.OperationMethod<
  CreateVerifiedAccessGroupRequest,
  CreateVerifiedAccessGroupResult,
  CreateVerifiedAccessGroupError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVerifiedAccessGroupRequest,
  output: CreateVerifiedAccessGroupResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidVerifiedAccessInstanceIdNotFound,
    MissingParameter,
  ],
}));
export type CreateVerifiedAccessInstanceError =
  | RequestLimitExceeded
  | ParseError
  | VerifiedAccessInstanceLimitExceeded
  | CommonErrors;
/**
 * An Amazon Web Services Verified Access instance is a regional entity that evaluates application requests and grants
 * access only when your security requirements are met.
 */
export const createVerifiedAccessInstance: API.OperationMethod<
  CreateVerifiedAccessInstanceRequest,
  CreateVerifiedAccessInstanceResult,
  CreateVerifiedAccessInstanceError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVerifiedAccessInstanceRequest,
  output: CreateVerifiedAccessInstanceResult,
  errors: [
    RequestLimitExceeded,
    ParseError,
    VerifiedAccessInstanceLimitExceeded,
  ],
}));
export type CreateVerifiedAccessTrustProviderError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * A trust provider is a third-party entity that creates, maintains, and manages identity
 * information for users and devices. When an application request is made, the identity
 * information sent by the trust provider is evaluated by Verified Access before allowing or
 * denying the application request.
 */
export const createVerifiedAccessTrustProvider: API.OperationMethod<
  CreateVerifiedAccessTrustProviderRequest,
  CreateVerifiedAccessTrustProviderResult,
  CreateVerifiedAccessTrustProviderError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVerifiedAccessTrustProviderRequest,
  output: CreateVerifiedAccessTrustProviderResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateVolumeError =
  | RequestLimitExceeded
  | InvalidZoneNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Creates an EBS volume that can be attached to an instance in the same Availability Zone.
 *
 * You can create a new empty volume or restore a volume from an EBS snapshot.
 * Any Amazon Web Services Marketplace product codes from the snapshot are propagated to the volume.
 *
 * You can create encrypted volumes. Encrypted volumes must be attached to instances that
 * support Amazon EBS encryption. Volumes that are created from encrypted snapshots are also automatically
 * encrypted. For more information, see Amazon EBS encryption
 * in the *Amazon EBS User Guide*.
 *
 * You can tag your volumes during creation. For more information, see Tag your Amazon EC2
 * resources in the *Amazon EC2 User Guide*.
 *
 * For more information, see Create an Amazon EBS volume in the
 * *Amazon EBS User Guide*.
 */
export const createVolume: API.OperationMethod<
  CreateVolumeRequest,
  Volume,
  CreateVolumeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVolumeRequest,
  output: Volume,
  errors: [RequestLimitExceeded, InvalidZoneNotFound, MissingParameter],
}));
export type CreateVpcError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | MissingParameter
  | ParseError
  | VpcLimitExceeded
  | CommonErrors;
/**
 * Creates a VPC with the specified CIDR blocks.
 *
 * A VPC must have an associated IPv4 CIDR block. You can choose an IPv4 CIDR block or an
 * IPAM-allocated IPv4 CIDR block. You can optionally associate an IPv6 CIDR block with a
 * VPC. You can choose an IPv6 CIDR block, an Amazon-provided IPv6 CIDR block, an
 * IPAM-allocated IPv6 CIDR block, or an IPv6 CIDR block that you brought to Amazon Web Services. For
 * more information, see IP addressing for your VPCs and
 * subnets in the *Amazon VPC User Guide*.
 *
 * By default, each instance that you launch in the VPC has the default DHCP options, which
 * include only a default DNS server that we provide (AmazonProvidedDNS). For more
 * information, see DHCP option sets in the *Amazon VPC User Guide*.
 *
 * You can specify DNS options and tenancy for a VPC when you create it. You can't change
 * the tenancy of a VPC after you create it. For more information, see VPC configuration options in the
 * *Amazon VPC User Guide*.
 */
export const createVpc: API.OperationMethod<
  CreateVpcRequest,
  CreateVpcResult,
  CreateVpcError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVpcRequest,
  output: CreateVpcResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    MissingParameter,
    ParseError,
    VpcLimitExceeded,
  ],
}));
export type CreateVpcBlockPublicAccessExclusionError =
  | RequestLimitExceeded
  | InvalidVpcIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Create a VPC Block Public Access (BPA) exclusion. A VPC BPA exclusion is a mode that can be applied to a single VPC or subnet that exempts it from the accounts BPA mode and will allow bidirectional or egress-only access. You can create BPA exclusions for VPCs and subnets even when BPA is not enabled on the account to ensure that there is no traffic disruption to the exclusions when VPC BPA is turned on. To learn more about VPC BPA, see Block public access to VPCs and subnets in the *Amazon VPC User Guide*.
 */
export const createVpcBlockPublicAccessExclusion: API.OperationMethod<
  CreateVpcBlockPublicAccessExclusionRequest,
  CreateVpcBlockPublicAccessExclusionResult,
  CreateVpcBlockPublicAccessExclusionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVpcBlockPublicAccessExclusionRequest,
  output: CreateVpcBlockPublicAccessExclusionResult,
  errors: [RequestLimitExceeded, InvalidVpcIdMalformed, MissingParameter],
}));
export type CreateVpcEncryptionControlError =
  | RequestLimitExceeded
  | InvalidVpcIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Creates a VPC Encryption Control configuration for a specified VPC. VPC Encryption Control enables you to enforce encryption for all data in transit within and between VPCs to meet compliance requirements for standards like HIPAA, FedRAMP, and PCI DSS.
 *
 * For more information, see Enforce VPC encryption in transit in the *Amazon VPC User Guide*.
 */
export const createVpcEncryptionControl: API.OperationMethod<
  CreateVpcEncryptionControlRequest,
  CreateVpcEncryptionControlResult,
  CreateVpcEncryptionControlError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVpcEncryptionControlRequest,
  output: CreateVpcEncryptionControlResult,
  errors: [RequestLimitExceeded, InvalidVpcIdMalformed, MissingParameter],
}));
export type CreateVpcEndpointError =
  | RequestLimitExceeded
  | InvalidParameter
  | InvalidServiceName
  | InvalidVpcIDNotFound
  | InvalidVpcIdNotFound
  | ParseError
  | CommonErrors;
/**
 * Creates a VPC endpoint. A VPC endpoint provides a private connection between the
 * specified VPC and the specified endpoint service. You can use an endpoint service
 * provided by Amazon Web Services, an Amazon Web Services Marketplace Partner, or another
 * Amazon Web Services account. For more information, see the Amazon Web Services PrivateLink User Guide.
 */
export const createVpcEndpoint: API.OperationMethod<
  CreateVpcEndpointRequest,
  CreateVpcEndpointResult,
  CreateVpcEndpointError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVpcEndpointRequest,
  output: CreateVpcEndpointResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameter,
    InvalidServiceName,
    InvalidVpcIDNotFound,
    InvalidVpcIdNotFound,
    ParseError,
  ],
}));
export type CreateVpcEndpointConnectionNotificationError =
  | RequestLimitExceeded
  | InvalidParameter
  | CommonErrors;
/**
 * Creates a connection notification for a specified VPC endpoint or VPC endpoint
 * service. A connection notification notifies you of specific endpoint events. You must
 * create an SNS topic to receive notifications. For more information, see Creating an Amazon SNS topic in
 * the *Amazon SNS Developer Guide*.
 *
 * You can create a connection notification for interface endpoints only.
 */
export const createVpcEndpointConnectionNotification: API.OperationMethod<
  CreateVpcEndpointConnectionNotificationRequest,
  CreateVpcEndpointConnectionNotificationResult,
  CreateVpcEndpointConnectionNotificationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVpcEndpointConnectionNotificationRequest,
  output: CreateVpcEndpointConnectionNotificationResult,
  errors: [RequestLimitExceeded, InvalidParameter],
}));
export type CreateVpcEndpointServiceConfigurationError =
  | RequestLimitExceeded
  | InvalidParameter
  | CommonErrors;
/**
 * Creates a VPC endpoint service to which service consumers (Amazon Web Services accounts,
 * users, and IAM roles) can connect.
 *
 * Before you create an endpoint service, you must create one of the following for your service:
 *
 * - A Network Load Balancer.
 * Service consumers connect to your service using an interface endpoint.
 *
 * - A Gateway Load Balancer.
 * Service consumers connect to your service using a Gateway Load Balancer endpoint.
 *
 * If you set the private DNS name, you must prove that you own the private DNS domain
 * name.
 *
 * For more information, see the Amazon Web Services PrivateLink
 * Guide.
 */
export const createVpcEndpointServiceConfiguration: API.OperationMethod<
  CreateVpcEndpointServiceConfigurationRequest,
  CreateVpcEndpointServiceConfigurationResult,
  CreateVpcEndpointServiceConfigurationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVpcEndpointServiceConfigurationRequest,
  output: CreateVpcEndpointServiceConfigurationResult,
  errors: [RequestLimitExceeded, InvalidParameter],
}));
export type CreateVpcPeeringConnectionError =
  | RequestLimitExceeded
  | InvalidVpcIDNotFound
  | InvalidVpcIdMalformed
  | MissingParameter
  | ParseError
  | CommonErrors;
/**
 * Requests a VPC peering connection between two VPCs: a requester VPC that you own and
 * an accepter VPC with which to create the connection. The accepter VPC can belong to
 * another Amazon Web Services account and can be in a different Region to the requester VPC.
 * The requester VPC and accepter VPC cannot have overlapping CIDR blocks.
 *
 * Limitations and rules apply to a VPC peering connection. For more information, see
 * the VPC peering limitations in the *VPC Peering Guide*.
 *
 * The owner of the accepter VPC must accept the peering request to activate the peering
 * connection. The VPC peering connection request expires after 7 days, after which it
 * cannot be accepted or rejected.
 *
 * If you create a VPC peering connection request between VPCs with overlapping CIDR
 * blocks, the VPC peering connection has a status of `failed`.
 */
export const createVpcPeeringConnection: API.OperationMethod<
  CreateVpcPeeringConnectionRequest,
  CreateVpcPeeringConnectionResult,
  CreateVpcPeeringConnectionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVpcPeeringConnectionRequest,
  output: CreateVpcPeeringConnectionResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcIDNotFound,
    InvalidVpcIdMalformed,
    MissingParameter,
    ParseError,
  ],
}));
export type CreateVpnConcentratorError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates a VPN concentrator that aggregates multiple VPN connections to a transit gateway.
 */
export const createVpnConcentrator: API.OperationMethod<
  CreateVpnConcentratorRequest,
  CreateVpnConcentratorResult,
  CreateVpnConcentratorError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVpnConcentratorRequest,
  output: CreateVpnConcentratorResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type CreateVpnConnectionError =
  | RequestLimitExceeded
  | InvalidCustomerGatewayIDNotFound
  | InvalidParameterValue
  | MissingParameter
  | ParseError
  | CommonErrors;
/**
 * Creates a VPN connection between an existing virtual private gateway or transit
 * gateway and a customer gateway. The supported connection type is
 * `ipsec.1`.
 *
 * The response includes information that you need to give to your network administrator
 * to configure your customer gateway.
 *
 * We strongly recommend that you use HTTPS when calling this operation because the
 * response contains sensitive cryptographic information for configuring your customer
 * gateway device.
 *
 * If you decide to shut down your VPN connection for any reason and later create a new
 * VPN connection, you must reconfigure your customer gateway with the new information
 * returned from this call.
 *
 * This is an idempotent operation. If you perform the operation more than once, Amazon
 * EC2 doesn't return an error.
 *
 * For more information, see Amazon Web Services Site-to-Site VPN in the Amazon Web Services Site-to-Site VPN
 * User Guide.
 */
export const createVpnConnection: API.OperationMethod<
  CreateVpnConnectionRequest,
  CreateVpnConnectionResult,
  CreateVpnConnectionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVpnConnectionRequest,
  output: CreateVpnConnectionResult,
  errors: [
    RequestLimitExceeded,
    InvalidCustomerGatewayIDNotFound,
    InvalidParameterValue,
    MissingParameter,
    ParseError,
  ],
}));
export type CreateVpnConnectionRouteError =
  | RequestLimitExceeded
  | InvalidParameter
  | MissingParameter
  | CommonErrors;
/**
 * Creates a static route associated with a VPN connection between an existing virtual
 * private gateway and a VPN customer gateway. The static route allows traffic to be routed
 * from the virtual private gateway to the VPN customer gateway.
 *
 * For more information, see Amazon Web Services Site-to-Site VPN in the Amazon Web Services Site-to-Site VPN
 * User Guide.
 */
export const createVpnConnectionRoute: API.OperationMethod<
  CreateVpnConnectionRouteRequest,
  CreateVpnConnectionRouteResponse,
  CreateVpnConnectionRouteError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVpnConnectionRouteRequest,
  output: CreateVpnConnectionRouteResponse,
  errors: [RequestLimitExceeded, InvalidParameter, MissingParameter],
}));
export type CreateVpnGatewayError =
  | RequestLimitExceeded
  | MissingParameter
  | ParseError
  | CommonErrors;
/**
 * Creates a virtual private gateway. A virtual private gateway is the endpoint on the
 * VPC side of your VPN connection. You can create a virtual private gateway before
 * creating the VPC itself.
 *
 * For more information, see Amazon Web Services Site-to-Site VPN in the Amazon Web Services Site-to-Site VPN
 * User Guide.
 */
export const createVpnGateway: API.OperationMethod<
  CreateVpnGatewayRequest,
  CreateVpnGatewayResult,
  CreateVpnGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVpnGatewayRequest,
  output: CreateVpnGatewayResult,
  errors: [RequestLimitExceeded, MissingParameter, ParseError],
}));
export type DeleteCapacityManagerDataExportError =
  | RequestLimitExceeded
  | InvalidCapacityManagerDataExportIdMalformed
  | InvalidCapacityManagerDataExportIdNotFound
  | CommonErrors;
/**
 * Deletes an existing Capacity Manager data export configuration. This stops future scheduled exports but does not delete previously exported files from S3.
 */
export const deleteCapacityManagerDataExport: API.OperationMethod<
  DeleteCapacityManagerDataExportRequest,
  DeleteCapacityManagerDataExportResult,
  DeleteCapacityManagerDataExportError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteCapacityManagerDataExportRequest,
  output: DeleteCapacityManagerDataExportResult,
  errors: [
    RequestLimitExceeded,
    InvalidCapacityManagerDataExportIdMalformed,
    InvalidCapacityManagerDataExportIdNotFound,
  ],
}));
export type DeleteCarrierGatewayError =
  | RequestLimitExceeded
  | InvalidCarrierGatewayIDMalformed
  | InvalidCarrierGatewayIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes a carrier gateway.
 *
 * If you do not delete the route that contains the carrier gateway as the
 * Target, the route is a blackhole route. For information about how to delete a route, see
 * DeleteRoute.
 */
export const deleteCarrierGateway: API.OperationMethod<
  DeleteCarrierGatewayRequest,
  DeleteCarrierGatewayResult,
  DeleteCarrierGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteCarrierGatewayRequest,
  output: DeleteCarrierGatewayResult,
  errors: [
    RequestLimitExceeded,
    InvalidCarrierGatewayIDMalformed,
    InvalidCarrierGatewayIDNotFound,
    MissingParameter,
  ],
}));
export type DeleteClientVpnEndpointError =
  | RequestLimitExceeded
  | InvalidClientVpnEndpointIdNotFound
  | CommonErrors;
/**
 * Deletes the specified Client VPN endpoint. You must disassociate all target networks before you
 * can delete a Client VPN endpoint.
 */
export const deleteClientVpnEndpoint: API.OperationMethod<
  DeleteClientVpnEndpointRequest,
  DeleteClientVpnEndpointResult,
  DeleteClientVpnEndpointError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteClientVpnEndpointRequest,
  output: DeleteClientVpnEndpointResult,
  errors: [RequestLimitExceeded, InvalidClientVpnEndpointIdNotFound],
}));
export type DeleteClientVpnRouteError =
  | RequestLimitExceeded
  | InvalidClientVpnEndpointIdNotFound
  | CommonErrors;
/**
 * Deletes a route from a Client VPN endpoint. You can only delete routes that you manually added using
 * the **CreateClientVpnRoute** action. You cannot delete routes that were
 * automatically added when associating a subnet. To remove routes that have been automatically added,
 * disassociate the target subnet from the Client VPN endpoint.
 */
export const deleteClientVpnRoute: API.OperationMethod<
  DeleteClientVpnRouteRequest,
  DeleteClientVpnRouteResult,
  DeleteClientVpnRouteError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteClientVpnRouteRequest,
  output: DeleteClientVpnRouteResult,
  errors: [RequestLimitExceeded, InvalidClientVpnEndpointIdNotFound],
}));
export type DeleteCoipCidrError =
  | RequestLimitExceeded
  | InvalidCidrBlockMalformed
  | InvalidIpv4PoolCoipIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Deletes a range of customer-owned IP addresses.
 */
export const deleteCoipCidr: API.OperationMethod<
  DeleteCoipCidrRequest,
  DeleteCoipCidrResult,
  DeleteCoipCidrError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteCoipCidrRequest,
  output: DeleteCoipCidrResult,
  errors: [
    RequestLimitExceeded,
    InvalidCidrBlockMalformed,
    InvalidIpv4PoolCoipIdMalformed,
    MissingParameter,
  ],
}));
export type DeleteCoipPoolError =
  | RequestLimitExceeded
  | InvalidIpv4PoolCoipIdMalformed
  | InvalidParameterValue
  | MissingParameter
  | CommonErrors;
/**
 * Deletes a pool of customer-owned IP (CoIP) addresses.
 */
export const deleteCoipPool: API.OperationMethod<
  DeleteCoipPoolRequest,
  DeleteCoipPoolResult,
  DeleteCoipPoolError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteCoipPoolRequest,
  output: DeleteCoipPoolResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpv4PoolCoipIdMalformed,
    InvalidParameterValue,
    MissingParameter,
  ],
}));
export type DeleteCustomerGatewayError =
  | RequestLimitExceeded
  | InvalidCustomerGatewayIDNotFound
  | InvalidCustomerGatewayIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified customer gateway. You must delete the VPN connection before you
 * can delete the customer gateway.
 */
export const deleteCustomerGateway: API.OperationMethod<
  DeleteCustomerGatewayRequest,
  DeleteCustomerGatewayResponse,
  DeleteCustomerGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteCustomerGatewayRequest,
  output: DeleteCustomerGatewayResponse,
  errors: [
    RequestLimitExceeded,
    InvalidCustomerGatewayIDNotFound,
    InvalidCustomerGatewayIdMalformed,
    MissingParameter,
  ],
}));
export type DeleteDhcpOptionsError =
  | RequestLimitExceeded
  | DependencyViolation
  | InvalidDhcpOptionIDNotFound
  | InvalidDhcpOptionsIDNotFound
  | InvalidDhcpOptionsIdMalformed
  | CommonErrors;
/**
 * Deletes the specified set of DHCP options. You must disassociate the set of DHCP options before you can delete it. You can disassociate the set of DHCP options by associating either a new set of options or the default set of options with the VPC.
 */
export const deleteDhcpOptions: API.OperationMethod<
  DeleteDhcpOptionsRequest,
  DeleteDhcpOptionsResponse,
  DeleteDhcpOptionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteDhcpOptionsRequest,
  output: DeleteDhcpOptionsResponse,
  errors: [
    RequestLimitExceeded,
    DependencyViolation,
    InvalidDhcpOptionIDNotFound,
    InvalidDhcpOptionsIDNotFound,
    InvalidDhcpOptionsIdMalformed,
  ],
}));
export type DeleteEgressOnlyInternetGatewayError =
  | DependencyViolation
  | DryRunOperation
  | InvalidEgressOnlyInternetGatewayIdNotFound
  | InvalidGatewayIDNotFound
  | MalformedGatewayIDNotFound
  | MissingParameter
  | RequestLimitExceeded
  | CommonErrors;
/**
 * Deletes an egress-only internet gateway.
 */
export const deleteEgressOnlyInternetGateway: API.OperationMethod<
  DeleteEgressOnlyInternetGatewayRequest,
  DeleteEgressOnlyInternetGatewayResult,
  DeleteEgressOnlyInternetGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteEgressOnlyInternetGatewayRequest,
  output: DeleteEgressOnlyInternetGatewayResult,
  errors: [
    DependencyViolation,
    DryRunOperation,
    InvalidEgressOnlyInternetGatewayIdNotFound,
    InvalidGatewayIDNotFound,
    MalformedGatewayIDNotFound,
    MissingParameter,
    RequestLimitExceeded,
  ],
}));
export type DeleteFleetsError =
  | RequestLimitExceeded
  | InvalidFleetIdMalformed
  | CommonErrors;
/**
 * Deletes the specified EC2 Fleet request.
 *
 * After you delete an EC2 Fleet request, it launches no new instances.
 *
 * You must also specify whether a deleted EC2 Fleet request should terminate its instances. If
 * you choose to terminate the instances, the EC2 Fleet request enters the
 * `deleted_terminating` state. Otherwise, it enters the
 * `deleted_running` state, and the instances continue to run until they are
 * interrupted or you terminate them manually.
 *
 * A deleted `instant` fleet with running instances is not supported. When you
 * delete an `instant` fleet, Amazon EC2 automatically terminates all its instances. For
 * fleets with more than 1000 instances, the deletion request might fail. If your fleet has
 * more than 1000 instances, first terminate most of the instances manually, leaving 1000 or
 * fewer. Then delete the fleet, and the remaining instances will be terminated automatically.
 *
 * **Terminating an instance is permanent and irreversible.**
 *
 * After you terminate an instance, you can no longer connect to it, and it can't be recovered.
 * All attached Amazon EBS volumes that are configured to be deleted on termination are also permanently
 * deleted and can't be recovered. All data stored on instance store volumes is permanently lost.
 * For more information, see
 * How instance termination works.
 *
 * Before you terminate an instance, ensure that you have backed up all data that you need to
 * retain after the termination to persistent storage.
 *
 * **Restrictions**
 *
 * - You can delete up to 25 fleets of type `instant` in a single
 * request.
 *
 * - You can delete up to 100 fleets of type `maintain` or
 * `request` in a single request.
 *
 * - You can delete up to 125 fleets in a single request, provided you do not exceed
 * the quota for each fleet type, as specified above.
 *
 * - If you exceed the specified number of fleets to delete, no fleets are
 * deleted.
 *
 * For more information, see Delete an EC2 Fleet request and the instances
 * in the fleet in the *Amazon EC2 User Guide*.
 */
export const deleteFleets: API.OperationMethod<
  DeleteFleetsRequest,
  DeleteFleetsResult,
  DeleteFleetsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteFleetsRequest,
  output: DeleteFleetsResult,
  errors: [RequestLimitExceeded, InvalidFleetIdMalformed],
}));
export type DeleteFlowLogsError =
  | RequestLimitExceeded
  | InvalidFlowLogIdNotFound
  | CommonErrors;
/**
 * Deletes one or more flow logs.
 */
export const deleteFlowLogs: API.OperationMethod<
  DeleteFlowLogsRequest,
  DeleteFlowLogsResult,
  DeleteFlowLogsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteFlowLogsRequest,
  output: DeleteFlowLogsResult,
  errors: [RequestLimitExceeded, InvalidFlowLogIdNotFound],
}));
export type DeleteFpgaImageError =
  | RequestLimitExceeded
  | InvalidFpgaImageIDMalformed
  | CommonErrors;
/**
 * Deletes the specified Amazon FPGA Image (AFI).
 */
export const deleteFpgaImage: API.OperationMethod<
  DeleteFpgaImageRequest,
  DeleteFpgaImageResult,
  DeleteFpgaImageError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteFpgaImageRequest,
  output: DeleteFpgaImageResult,
  errors: [RequestLimitExceeded, InvalidFpgaImageIDMalformed],
}));
export type DeleteImageUsageReportError =
  | RequestLimitExceeded
  | InvalidImageUsageReportIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified image usage report.
 *
 * For more information, see View your AMI usage in the
 * *Amazon EC2 User Guide*.
 */
export const deleteImageUsageReport: API.OperationMethod<
  DeleteImageUsageReportRequest,
  DeleteImageUsageReportResult,
  DeleteImageUsageReportError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteImageUsageReportRequest,
  output: DeleteImageUsageReportResult,
  errors: [
    RequestLimitExceeded,
    InvalidImageUsageReportIdMalformed,
    MissingParameter,
  ],
}));
export type DeleteInstanceConnectEndpointError =
  | RequestLimitExceeded
  | InvalidInstanceConnectEndpointIdMalformed
  | InvalidInstanceConnectEndpointIdNotFound
  | InvalidState
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified EC2 Instance Connect Endpoint.
 */
export const deleteInstanceConnectEndpoint: API.OperationMethod<
  DeleteInstanceConnectEndpointRequest,
  DeleteInstanceConnectEndpointResult,
  DeleteInstanceConnectEndpointError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteInstanceConnectEndpointRequest,
  output: DeleteInstanceConnectEndpointResult,
  errors: [
    RequestLimitExceeded,
    InvalidInstanceConnectEndpointIdMalformed,
    InvalidInstanceConnectEndpointIdNotFound,
    InvalidState,
    MissingParameter,
  ],
}));
export type DeleteInstanceEventWindowError =
  | RequestLimitExceeded
  | InvalidInstanceEventWindowIDNotFound
  | InvalidParameterValue
  | CommonErrors;
/**
 * Deletes the specified event window.
 *
 * For more information, see Define event windows for scheduled
 * events in the *Amazon EC2 User Guide*.
 */
export const deleteInstanceEventWindow: API.OperationMethod<
  DeleteInstanceEventWindowRequest,
  DeleteInstanceEventWindowResult,
  DeleteInstanceEventWindowError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteInstanceEventWindowRequest,
  output: DeleteInstanceEventWindowResult,
  errors: [
    RequestLimitExceeded,
    InvalidInstanceEventWindowIDNotFound,
    InvalidParameterValue,
  ],
}));
export type DeleteInternetGatewayError =
  | RequestLimitExceeded
  | DependencyViolation
  | InvalidInternetGatewayIDNotFound
  | InvalidInternetGatewayIdMalformed
  | CommonErrors;
/**
 * Deletes the specified internet gateway. You must detach the internet gateway from the
 * VPC before you can delete it.
 */
export const deleteInternetGateway: API.OperationMethod<
  DeleteInternetGatewayRequest,
  DeleteInternetGatewayResponse,
  DeleteInternetGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteInternetGatewayRequest,
  output: DeleteInternetGatewayResponse,
  errors: [
    RequestLimitExceeded,
    DependencyViolation,
    InvalidInternetGatewayIDNotFound,
    InvalidInternetGatewayIdMalformed,
  ],
}));
export type DeleteIpamError =
  | RequestLimitExceeded
  | DependencyViolation
  | InvalidIpamIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Delete an IPAM. Deleting an IPAM removes all monitored data associated with the IPAM including the historical data for CIDRs.
 *
 * For more information, see Delete an IPAM in the *Amazon VPC IPAM User Guide*.
 */
export const deleteIpam: API.OperationMethod<
  DeleteIpamRequest,
  DeleteIpamResult,
  DeleteIpamError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteIpamRequest,
  output: DeleteIpamResult,
  errors: [
    RequestLimitExceeded,
    DependencyViolation,
    InvalidIpamIdNotFound,
    MissingParameter,
  ],
}));
export type DeleteIpamExternalResourceVerificationTokenError =
  | RequestLimitExceeded
  | InvalidIpamExternalResourceVerificationTokenIdMalformed
  | InvalidIpamExternalResourceVerificationTokenIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Delete a verification token.
 *
 * A verification token is an Amazon Web Services-generated random value that you can use to prove ownership of an external resource. For example, you can use a verification token to validate that you control a public IP address range when you bring an IP address range to Amazon Web Services (BYOIP).
 */
export const deleteIpamExternalResourceVerificationToken: API.OperationMethod<
  DeleteIpamExternalResourceVerificationTokenRequest,
  DeleteIpamExternalResourceVerificationTokenResult,
  DeleteIpamExternalResourceVerificationTokenError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteIpamExternalResourceVerificationTokenRequest,
  output: DeleteIpamExternalResourceVerificationTokenResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamExternalResourceVerificationTokenIdMalformed,
    InvalidIpamExternalResourceVerificationTokenIdNotFound,
    MissingParameter,
  ],
}));
export type DeleteIpamPolicyError =
  | RequestLimitExceeded
  | InvalidIpamPolicyIdMalformed
  | InvalidIpamPolicyIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes an IPAM policy.
 *
 * An IPAM policy is a set of rules that define how public IPv4 addresses from IPAM pools are allocated to Amazon Web Services resources. Each rule maps an Amazon Web Services service to IPAM pools that the service will use to get IP addresses. A single policy can have multiple rules and be applied to multiple Amazon Web Services Regions. If the IPAM pool run out of addresses then the services fallback to Amazon-provided IP addresses. A policy can be applied to an individual Amazon Web Services account or an entity within Amazon Web Services Organizations.
 */
export const deleteIpamPolicy: API.OperationMethod<
  DeleteIpamPolicyRequest,
  DeleteIpamPolicyResult,
  DeleteIpamPolicyError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteIpamPolicyRequest,
  output: DeleteIpamPolicyResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamPolicyIdMalformed,
    InvalidIpamPolicyIdNotFound,
    MissingParameter,
  ],
}));
export type DeleteIpamPoolError =
  | RequestLimitExceeded
  | IncorrectState
  | InvalidIpamPoolIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Delete an IPAM pool.
 *
 * You cannot delete an IPAM pool if there are allocations in it or CIDRs provisioned to it. To release
 * allocations, see ReleaseIpamPoolAllocation. To deprovision pool
 * CIDRs, see DeprovisionIpamPoolCidr.
 *
 * For more information, see Delete a pool in the *Amazon VPC IPAM User Guide*.
 */
export const deleteIpamPool: API.OperationMethod<
  DeleteIpamPoolRequest,
  DeleteIpamPoolResult,
  DeleteIpamPoolError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteIpamPoolRequest,
  output: DeleteIpamPoolResult,
  errors: [
    RequestLimitExceeded,
    IncorrectState,
    InvalidIpamPoolIdNotFound,
    MissingParameter,
  ],
}));
export type DeleteIpamPrefixListResolverError =
  | RequestLimitExceeded
  | InvalidIpamPrefixListResolverIdMalformed
  | InvalidIpamPrefixListResolverIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes an IPAM prefix list resolver. Before deleting a resolver, you must first delete all resolver targets associated with it.
 */
export const deleteIpamPrefixListResolver: API.OperationMethod<
  DeleteIpamPrefixListResolverRequest,
  DeleteIpamPrefixListResolverResult,
  DeleteIpamPrefixListResolverError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteIpamPrefixListResolverRequest,
  output: DeleteIpamPrefixListResolverResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamPrefixListResolverIdMalformed,
    InvalidIpamPrefixListResolverIdNotFound,
    MissingParameter,
  ],
}));
export type DeleteIpamPrefixListResolverTargetError =
  | RequestLimitExceeded
  | InvalidIpamPrefixListResolverTargetIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Deletes an IPAM prefix list resolver target. This removes the association between the resolver and the managed prefix list, stopping automatic CIDR synchronization.
 *
 * For more information about IPAM prefix list resolver, see Automate prefix list updates with IPAM in the *Amazon VPC IPAM User Guide*.
 */
export const deleteIpamPrefixListResolverTarget: API.OperationMethod<
  DeleteIpamPrefixListResolverTargetRequest,
  DeleteIpamPrefixListResolverTargetResult,
  DeleteIpamPrefixListResolverTargetError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteIpamPrefixListResolverTargetRequest,
  output: DeleteIpamPrefixListResolverTargetResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamPrefixListResolverTargetIdMalformed,
    MissingParameter,
  ],
}));
export type DeleteIpamResourceDiscoveryError =
  | RequestLimitExceeded
  | InvalidIpamResourceDiscoveryIdMalformed
  | InvalidIpamResourceDiscoveryIdNotFound
  | CommonErrors;
/**
 * Deletes an IPAM resource discovery. A resource discovery is an IPAM component that enables IPAM to manage and monitor resources that belong to the owning account.
 */
export const deleteIpamResourceDiscovery: API.OperationMethod<
  DeleteIpamResourceDiscoveryRequest,
  DeleteIpamResourceDiscoveryResult,
  DeleteIpamResourceDiscoveryError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteIpamResourceDiscoveryRequest,
  output: DeleteIpamResourceDiscoveryResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamResourceDiscoveryIdMalformed,
    InvalidIpamResourceDiscoveryIdNotFound,
  ],
}));
export type DeleteIpamScopeError =
  | RequestLimitExceeded
  | DependencyViolation
  | IncorrectState
  | InvalidIpamScopeIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Delete the scope for an IPAM. You cannot delete the default scopes.
 *
 * For more information, see Delete a scope in the *Amazon VPC IPAM User Guide*.
 */
export const deleteIpamScope: API.OperationMethod<
  DeleteIpamScopeRequest,
  DeleteIpamScopeResult,
  DeleteIpamScopeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteIpamScopeRequest,
  output: DeleteIpamScopeResult,
  errors: [
    RequestLimitExceeded,
    DependencyViolation,
    IncorrectState,
    InvalidIpamScopeIdNotFound,
    MissingParameter,
  ],
}));
export type DeleteKeyPairError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified key pair, by removing the public key from Amazon EC2.
 */
export const deleteKeyPair: API.OperationMethod<
  DeleteKeyPairRequest,
  DeleteKeyPairResult,
  DeleteKeyPairError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteKeyPairRequest,
  output: DeleteKeyPairResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type DeleteLaunchTemplateError =
  | RequestLimitExceeded
  | InvalidLaunchTemplateNameNotFoundException
  | MissingParameter
  | CommonErrors;
/**
 * Deletes a launch template. Deleting a launch template deletes all of its
 * versions.
 */
export const deleteLaunchTemplate: API.OperationMethod<
  DeleteLaunchTemplateRequest,
  DeleteLaunchTemplateResult,
  DeleteLaunchTemplateError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteLaunchTemplateRequest,
  output: DeleteLaunchTemplateResult,
  errors: [
    RequestLimitExceeded,
    InvalidLaunchTemplateNameNotFoundException,
    MissingParameter,
  ],
}));
export type DeleteLaunchTemplateVersionsError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Deletes one or more versions of a launch template.
 *
 * You can't delete the default version of a launch template; you must first assign a
 * different version as the default. If the default version is the only version for the
 * launch template, you must delete the entire launch template using DeleteLaunchTemplate.
 *
 * You can delete up to 200 launch template versions in a single request. To delete more
 * than 200 versions in a single request, use DeleteLaunchTemplate, which
 * deletes the launch template and all of its versions.
 *
 * For more information, see Delete a launch template version in the
 * *Amazon EC2 User Guide*.
 */
export const deleteLaunchTemplateVersions: API.OperationMethod<
  DeleteLaunchTemplateVersionsRequest,
  DeleteLaunchTemplateVersionsResult,
  DeleteLaunchTemplateVersionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteLaunchTemplateVersionsRequest,
  output: DeleteLaunchTemplateVersionsResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type DeleteLocalGatewayRouteError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified route from the specified local gateway route table.
 */
export const deleteLocalGatewayRoute: API.OperationMethod<
  DeleteLocalGatewayRouteRequest,
  DeleteLocalGatewayRouteResult,
  DeleteLocalGatewayRouteError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteLocalGatewayRouteRequest,
  output: DeleteLocalGatewayRouteResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type DeleteLocalGatewayRouteTableError =
  | RequestLimitExceeded
  | InvalidLocalGatewayRouteTableIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes a local gateway route table.
 */
export const deleteLocalGatewayRouteTable: API.OperationMethod<
  DeleteLocalGatewayRouteTableRequest,
  DeleteLocalGatewayRouteTableResult,
  DeleteLocalGatewayRouteTableError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteLocalGatewayRouteTableRequest,
  output: DeleteLocalGatewayRouteTableResult,
  errors: [
    RequestLimitExceeded,
    InvalidLocalGatewayRouteTableIDNotFound,
    MissingParameter,
  ],
}));
export type DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationError =
  | RequestLimitExceeded
  | InvalidLocalGatewayRouteTableVirtualInterfaceGroupAssociationIDMalformed
  | InvalidLocalGatewayRouteTableVirtualInterfaceGroupAssociationIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes a local gateway route table virtual interface group association.
 */
export const deleteLocalGatewayRouteTableVirtualInterfaceGroupAssociation: API.OperationMethod<
  DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest,
  DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult,
  DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest,
  output: DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult,
  errors: [
    RequestLimitExceeded,
    InvalidLocalGatewayRouteTableVirtualInterfaceGroupAssociationIDMalformed,
    InvalidLocalGatewayRouteTableVirtualInterfaceGroupAssociationIDNotFound,
    MissingParameter,
  ],
}));
export type DeleteLocalGatewayRouteTableVpcAssociationError =
  | RequestLimitExceeded
  | InvalidLocalGatewayRouteTableVpcAssociationIDMalformed
  | InvalidLocalGatewayRouteTableVpcAssociationIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified association between a VPC and local gateway route table.
 */
export const deleteLocalGatewayRouteTableVpcAssociation: API.OperationMethod<
  DeleteLocalGatewayRouteTableVpcAssociationRequest,
  DeleteLocalGatewayRouteTableVpcAssociationResult,
  DeleteLocalGatewayRouteTableVpcAssociationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteLocalGatewayRouteTableVpcAssociationRequest,
  output: DeleteLocalGatewayRouteTableVpcAssociationResult,
  errors: [
    RequestLimitExceeded,
    InvalidLocalGatewayRouteTableVpcAssociationIDMalformed,
    InvalidLocalGatewayRouteTableVpcAssociationIDNotFound,
    MissingParameter,
  ],
}));
export type DeleteLocalGatewayVirtualInterfaceError =
  | RequestLimitExceeded
  | InvalidLocalGatewayVirtualInterfaceIDMalformed
  | InvalidLocalGatewayVirtualInterfaceIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified local gateway virtual interface.
 */
export const deleteLocalGatewayVirtualInterface: API.OperationMethod<
  DeleteLocalGatewayVirtualInterfaceRequest,
  DeleteLocalGatewayVirtualInterfaceResult,
  DeleteLocalGatewayVirtualInterfaceError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteLocalGatewayVirtualInterfaceRequest,
  output: DeleteLocalGatewayVirtualInterfaceResult,
  errors: [
    RequestLimitExceeded,
    InvalidLocalGatewayVirtualInterfaceIDMalformed,
    InvalidLocalGatewayVirtualInterfaceIDNotFound,
    MissingParameter,
  ],
}));
export type DeleteLocalGatewayVirtualInterfaceGroupError =
  | RequestLimitExceeded
  | InvalidLocalGatewayVirtualInterfaceGroupIDMalformed
  | InvalidLocalGatewayVirtualInterfaceGroupIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Delete the specified local gateway interface group.
 */
export const deleteLocalGatewayVirtualInterfaceGroup: API.OperationMethod<
  DeleteLocalGatewayVirtualInterfaceGroupRequest,
  DeleteLocalGatewayVirtualInterfaceGroupResult,
  DeleteLocalGatewayVirtualInterfaceGroupError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteLocalGatewayVirtualInterfaceGroupRequest,
  output: DeleteLocalGatewayVirtualInterfaceGroupResult,
  errors: [
    RequestLimitExceeded,
    InvalidLocalGatewayVirtualInterfaceGroupIDMalformed,
    InvalidLocalGatewayVirtualInterfaceGroupIDNotFound,
    MissingParameter,
  ],
}));
export type DeleteManagedPrefixListError =
  | RequestLimitExceeded
  | InvalidPrefixListIDNotFound
  | InvalidPrefixListIdMalformed
  | ParseError
  | CommonErrors;
/**
 * Deletes the specified managed prefix list. You must first remove all references to the prefix list in your resources.
 */
export const deleteManagedPrefixList: API.OperationMethod<
  DeleteManagedPrefixListRequest,
  DeleteManagedPrefixListResult,
  DeleteManagedPrefixListError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteManagedPrefixListRequest,
  output: DeleteManagedPrefixListResult,
  errors: [
    RequestLimitExceeded,
    InvalidPrefixListIDNotFound,
    InvalidPrefixListIdMalformed,
    ParseError,
  ],
}));
export type DeleteNatGatewayError =
  | RequestLimitExceeded
  | DryRunOperation
  | InvalidParameter
  | MissingParameter
  | NatGatewayMalformed
  | NatGatewayNotFound
  | CommonErrors;
/**
 * Deletes the specified NAT gateway. Deleting a public NAT gateway disassociates its Elastic IP address,
 * but does not release the address from your account. Deleting a NAT gateway does not delete any NAT gateway
 * routes in your route tables.
 */
export const deleteNatGateway: API.OperationMethod<
  DeleteNatGatewayRequest,
  DeleteNatGatewayResult,
  DeleteNatGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteNatGatewayRequest,
  output: DeleteNatGatewayResult,
  errors: [
    RequestLimitExceeded,
    DryRunOperation,
    InvalidParameter,
    MissingParameter,
    NatGatewayMalformed,
    NatGatewayNotFound,
  ],
}));
export type DeleteNetworkAclError =
  | RequestLimitExceeded
  | DependencyViolation
  | DryRunOperation
  | InvalidNetworkAclIDNotFound
  | InvalidNetworkAclIdMalformed
  | InvalidParameterValue
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified network ACL. You can't delete the ACL if it's associated with any subnets. You can't delete the default network ACL.
 */
export const deleteNetworkAcl: API.OperationMethod<
  DeleteNetworkAclRequest,
  DeleteNetworkAclResponse,
  DeleteNetworkAclError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteNetworkAclRequest,
  output: DeleteNetworkAclResponse,
  errors: [
    RequestLimitExceeded,
    DependencyViolation,
    DryRunOperation,
    InvalidNetworkAclIDNotFound,
    InvalidNetworkAclIdMalformed,
    InvalidParameterValue,
    MissingParameter,
  ],
}));
export type DeleteNetworkAclEntryError =
  | RequestLimitExceeded
  | InvalidNetworkAclEntryNotFound
  | InvalidNetworkAclIDNotFound
  | InvalidNetworkAclIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified ingress or egress entry (rule) from the specified network ACL.
 */
export const deleteNetworkAclEntry: API.OperationMethod<
  DeleteNetworkAclEntryRequest,
  DeleteNetworkAclEntryResponse,
  DeleteNetworkAclEntryError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteNetworkAclEntryRequest,
  output: DeleteNetworkAclEntryResponse,
  errors: [
    RequestLimitExceeded,
    InvalidNetworkAclEntryNotFound,
    InvalidNetworkAclIDNotFound,
    InvalidNetworkAclIdMalformed,
    MissingParameter,
  ],
}));
export type DeleteNetworkInsightsAccessScopeError =
  | RequestLimitExceeded
  | InvalidNetworkInsightsAccessScopeIdNotFound
  | InvalidParameterValue
  | CommonErrors;
/**
 * Deletes the specified Network Access Scope.
 */
export const deleteNetworkInsightsAccessScope: API.OperationMethod<
  DeleteNetworkInsightsAccessScopeRequest,
  DeleteNetworkInsightsAccessScopeResult,
  DeleteNetworkInsightsAccessScopeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteNetworkInsightsAccessScopeRequest,
  output: DeleteNetworkInsightsAccessScopeResult,
  errors: [
    RequestLimitExceeded,
    InvalidNetworkInsightsAccessScopeIdNotFound,
    InvalidParameterValue,
  ],
}));
export type DeleteNetworkInsightsAccessScopeAnalysisError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified Network Access Scope analysis.
 */
export const deleteNetworkInsightsAccessScopeAnalysis: API.OperationMethod<
  DeleteNetworkInsightsAccessScopeAnalysisRequest,
  DeleteNetworkInsightsAccessScopeAnalysisResult,
  DeleteNetworkInsightsAccessScopeAnalysisError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteNetworkInsightsAccessScopeAnalysisRequest,
  output: DeleteNetworkInsightsAccessScopeAnalysisResult,
  errors: [RequestLimitExceeded, InvalidParameterValue, MissingParameter],
}));
export type DeleteNetworkInsightsAnalysisError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified network insights analysis.
 */
export const deleteNetworkInsightsAnalysis: API.OperationMethod<
  DeleteNetworkInsightsAnalysisRequest,
  DeleteNetworkInsightsAnalysisResult,
  DeleteNetworkInsightsAnalysisError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteNetworkInsightsAnalysisRequest,
  output: DeleteNetworkInsightsAnalysisResult,
  errors: [RequestLimitExceeded, InvalidParameterValue, MissingParameter],
}));
export type DeleteNetworkInsightsPathError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified path.
 */
export const deleteNetworkInsightsPath: API.OperationMethod<
  DeleteNetworkInsightsPathRequest,
  DeleteNetworkInsightsPathResult,
  DeleteNetworkInsightsPathError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteNetworkInsightsPathRequest,
  output: DeleteNetworkInsightsPathResult,
  errors: [RequestLimitExceeded, InvalidParameterValue, MissingParameter],
}));
export type DeleteNetworkInterfaceError =
  | RequestLimitExceeded
  | InvalidNetworkInterfaceInUse
  | InvalidNetworkInterfaceIDNotFound
  | InvalidNetworkInterfaceIdMalformed
  | InvalidParameterValue
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified network interface. You must detach the network interface before
 * you can delete it.
 */
export const deleteNetworkInterface: API.OperationMethod<
  DeleteNetworkInterfaceRequest,
  DeleteNetworkInterfaceResponse,
  DeleteNetworkInterfaceError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteNetworkInterfaceRequest,
  output: DeleteNetworkInterfaceResponse,
  errors: [
    RequestLimitExceeded,
    InvalidNetworkInterfaceInUse,
    InvalidNetworkInterfaceIDNotFound,
    InvalidNetworkInterfaceIdMalformed,
    InvalidParameterValue,
    MissingParameter,
  ],
}));
export type DeleteNetworkInterfacePermissionError =
  | RequestLimitExceeded
  | InvalidPermissionIDMalformed
  | InvalidPermissionIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes a permission for a network interface. By default, you cannot delete the
 * permission if the account for which you're removing the permission has attached the
 * network interface to an instance. However, you can force delete the permission,
 * regardless of any attachment.
 */
export const deleteNetworkInterfacePermission: API.OperationMethod<
  DeleteNetworkInterfacePermissionRequest,
  DeleteNetworkInterfacePermissionResult,
  DeleteNetworkInterfacePermissionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteNetworkInterfacePermissionRequest,
  output: DeleteNetworkInterfacePermissionResult,
  errors: [
    RequestLimitExceeded,
    InvalidPermissionIDMalformed,
    InvalidPermissionIDNotFound,
    MissingParameter,
  ],
}));
export type DeletePlacementGroupError =
  | RequestLimitExceeded
  | InvalidPlacementGroupUnknown
  | CommonErrors;
/**
 * Deletes the specified placement group. You must terminate all instances in the
 * placement group before you can delete the placement group. For more information, see
 * Placement groups in the *Amazon EC2 User Guide*.
 */
export const deletePlacementGroup: API.OperationMethod<
  DeletePlacementGroupRequest,
  DeletePlacementGroupResponse,
  DeletePlacementGroupError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeletePlacementGroupRequest,
  output: DeletePlacementGroupResponse,
  errors: [RequestLimitExceeded, InvalidPlacementGroupUnknown],
}));
export type DeletePublicIpv4PoolError =
  | RequestLimitExceeded
  | InvalidPublicIpv4PoolNotFound
  | InvalidPublicIpv4PoolIDMalformed
  | CommonErrors;
/**
 * Delete a public IPv4 pool. A public IPv4 pool is an EC2 IP address pool required for the public IPv4 CIDRs that you own and bring to Amazon Web Services to manage with IPAM. IPv6 addresses you bring to Amazon Web Services, however, use IPAM pools only.
 */
export const deletePublicIpv4Pool: API.OperationMethod<
  DeletePublicIpv4PoolRequest,
  DeletePublicIpv4PoolResult,
  DeletePublicIpv4PoolError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeletePublicIpv4PoolRequest,
  output: DeletePublicIpv4PoolResult,
  errors: [
    RequestLimitExceeded,
    InvalidPublicIpv4PoolNotFound,
    InvalidPublicIpv4PoolIDMalformed,
  ],
}));
export type DeleteQueuedReservedInstancesError =
  | RequestLimitExceeded
  | InvalidReservedInstancesIDNotFound
  | CommonErrors;
/**
 * Deletes the queued purchases for the specified Reserved Instances.
 */
export const deleteQueuedReservedInstances: API.OperationMethod<
  DeleteQueuedReservedInstancesRequest,
  DeleteQueuedReservedInstancesResult,
  DeleteQueuedReservedInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteQueuedReservedInstancesRequest,
  output: DeleteQueuedReservedInstancesResult,
  errors: [RequestLimitExceeded, InvalidReservedInstancesIDNotFound],
}));
export type DeleteRouteError =
  | RequestLimitExceeded
  | InvalidParameterCombination
  | InvalidParameterValue
  | InvalidRouteNotFound
  | InvalidRouteTableIDNotFound
  | InvalidRouteTableIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified route from the specified route table.
 */
export const deleteRoute: API.OperationMethod<
  DeleteRouteRequest,
  DeleteRouteResponse,
  DeleteRouteError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteRouteRequest,
  output: DeleteRouteResponse,
  errors: [
    RequestLimitExceeded,
    InvalidParameterCombination,
    InvalidParameterValue,
    InvalidRouteNotFound,
    InvalidRouteTableIDNotFound,
    InvalidRouteTableIdMalformed,
    MissingParameter,
  ],
}));
export type DeleteRouteServerError =
  | RequestLimitExceeded
  | IncorrectState
  | InvalidRouteServerIdNotFound
  | CommonErrors;
/**
 * Deletes the specified route server.
 *
 * Amazon VPC Route Server simplifies routing for traffic between workloads that are deployed within a VPC and its internet gateways. With this feature,
 * VPC Route Server dynamically updates VPC and internet gateway route tables with your preferred IPv4 or IPv6 routes to achieve routing fault tolerance for those workloads. This enables you to automatically reroute traffic within a VPC, which increases the manageability of VPC routing and interoperability with third-party workloads.
 *
 * Route server supports the follow route table types:
 *
 * - VPC route tables not associated with subnets
 *
 * - Subnet route tables
 *
 * - Internet gateway route tables
 *
 * Route server does not support route tables associated with virtual private gateways. To propagate routes into a transit gateway route table, use Transit Gateway Connect.
 *
 * For more information see Dynamic routing in your VPC with VPC Route Server in the *Amazon VPC User Guide*.
 */
export const deleteRouteServer: API.OperationMethod<
  DeleteRouteServerRequest,
  DeleteRouteServerResult,
  DeleteRouteServerError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteRouteServerRequest,
  output: DeleteRouteServerResult,
  errors: [RequestLimitExceeded, IncorrectState, InvalidRouteServerIdNotFound],
}));
export type DeleteRouteServerEndpointError =
  | RequestLimitExceeded
  | InvalidRouteServerEndpointIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified route server endpoint.
 *
 * A route server endpoint is an Amazon Web Services-managed component inside a subnet that facilitates BGP (Border Gateway Protocol) connections between your route server and your BGP peers.
 */
export const deleteRouteServerEndpoint: API.OperationMethod<
  DeleteRouteServerEndpointRequest,
  DeleteRouteServerEndpointResult,
  DeleteRouteServerEndpointError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteRouteServerEndpointRequest,
  output: DeleteRouteServerEndpointResult,
  errors: [
    RequestLimitExceeded,
    InvalidRouteServerEndpointIdNotFound,
    MissingParameter,
  ],
}));
export type DeleteRouteServerPeerError =
  | RequestLimitExceeded
  | InvalidRouteServerPeerIdMalformed
  | InvalidRouteServerPeerIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified BGP peer from a route server.
 *
 * A route server peer is a session between a route server endpoint and the device deployed in Amazon Web Services (such as a firewall appliance or other network security function running on an EC2 instance). The device must meet these requirements:
 *
 * - Have an elastic network interface in the VPC
 *
 * - Support BGP (Border Gateway Protocol)
 *
 * - Can initiate BGP sessions
 */
export const deleteRouteServerPeer: API.OperationMethod<
  DeleteRouteServerPeerRequest,
  DeleteRouteServerPeerResult,
  DeleteRouteServerPeerError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteRouteServerPeerRequest,
  output: DeleteRouteServerPeerResult,
  errors: [
    RequestLimitExceeded,
    InvalidRouteServerPeerIdMalformed,
    InvalidRouteServerPeerIdNotFound,
    MissingParameter,
  ],
}));
export type DeleteRouteTableError =
  | RequestLimitExceeded
  | DependencyViolation
  | InvalidRouteTableIDNotFound
  | InvalidRouteTableIdMalformed
  | CommonErrors;
/**
 * Deletes the specified route table. You must disassociate the route table from any subnets before you can delete it. You can't delete the main route table.
 */
export const deleteRouteTable: API.OperationMethod<
  DeleteRouteTableRequest,
  DeleteRouteTableResponse,
  DeleteRouteTableError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteRouteTableRequest,
  output: DeleteRouteTableResponse,
  errors: [
    RequestLimitExceeded,
    DependencyViolation,
    InvalidRouteTableIDNotFound,
    InvalidRouteTableIdMalformed,
  ],
}));
export type DeleteSecondaryNetworkError = CommonErrors;
/**
 * Deletes a secondary network. You must delete all secondary subnets in the secondary network before you can delete the secondary network.
 */
export const deleteSecondaryNetwork: API.OperationMethod<
  DeleteSecondaryNetworkRequest,
  DeleteSecondaryNetworkResult,
  DeleteSecondaryNetworkError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteSecondaryNetworkRequest,
  output: DeleteSecondaryNetworkResult,
  errors: [],
}));
export type DeleteSecondarySubnetError = CommonErrors;
/**
 * Deletes a secondary subnet. A secondary subnet must not contain any secondary interfaces prior to deletion.
 */
export const deleteSecondarySubnet: API.OperationMethod<
  DeleteSecondarySubnetRequest,
  DeleteSecondarySubnetResult,
  DeleteSecondarySubnetError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteSecondarySubnetRequest,
  output: DeleteSecondarySubnetResult,
  errors: [],
}));
export type DeleteSecurityGroupError =
  | RequestLimitExceeded
  | CannotDelete
  | DependencyViolation
  | InvalidGroupNotFound
  | InvalidGroupIdMalformed
  | MissingParameter
  | VPCIdNotSpecified
  | CommonErrors;
/**
 * Deletes a security group.
 *
 * If you attempt to delete a security group that is associated with an instance or network interface, is
 * referenced by another security group in the same VPC, or has a VPC association, the operation fails with
 * `DependencyViolation`.
 */
export const deleteSecurityGroup: API.OperationMethod<
  DeleteSecurityGroupRequest,
  DeleteSecurityGroupResult,
  DeleteSecurityGroupError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteSecurityGroupRequest,
  output: DeleteSecurityGroupResult,
  errors: [
    RequestLimitExceeded,
    CannotDelete,
    DependencyViolation,
    InvalidGroupNotFound,
    InvalidGroupIdMalformed,
    MissingParameter,
    VPCIdNotSpecified,
  ],
}));
export type DeleteSnapshotError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidSnapshotNotFound
  | InvalidSnapshotIDMalformed
  | CommonErrors;
/**
 * Deletes the specified snapshot.
 *
 * When you make periodic snapshots of a volume, the snapshots are incremental, and only the
 * blocks on the device that have changed since your last snapshot are saved in the new snapshot.
 * When you delete a snapshot, only the data not needed for any other snapshot is removed. So
 * regardless of which prior snapshots have been deleted, all active snapshots will have access
 * to all the information needed to restore the volume.
 *
 * You cannot delete a snapshot of the root device of an EBS volume used by a registered AMI.
 * You must first deregister the AMI before you can delete the snapshot.
 *
 * For more information, see Delete an Amazon EBS snapshot in the
 * *Amazon EBS User Guide*.
 */
export const deleteSnapshot: API.OperationMethod<
  DeleteSnapshotRequest,
  DeleteSnapshotResponse,
  DeleteSnapshotError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteSnapshotRequest,
  output: DeleteSnapshotResponse,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidSnapshotNotFound,
    InvalidSnapshotIDMalformed,
  ],
}));
export type DeleteSpotDatafeedSubscriptionError = CommonErrors;
/**
 * Deletes the data feed for Spot Instances.
 */
export const deleteSpotDatafeedSubscription: API.OperationMethod<
  DeleteSpotDatafeedSubscriptionRequest,
  DeleteSpotDatafeedSubscriptionResponse,
  DeleteSpotDatafeedSubscriptionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteSpotDatafeedSubscriptionRequest,
  output: DeleteSpotDatafeedSubscriptionResponse,
  errors: [],
}));
export type DeleteSubnetError =
  | RequestLimitExceeded
  | DependencyViolation
  | InvalidSubnetIDNotFound
  | InvalidSubnetIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified subnet. You must terminate all running instances in the subnet before you can delete the subnet.
 */
export const deleteSubnet: API.OperationMethod<
  DeleteSubnetRequest,
  DeleteSubnetResponse,
  DeleteSubnetError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteSubnetRequest,
  output: DeleteSubnetResponse,
  errors: [
    RequestLimitExceeded,
    DependencyViolation,
    InvalidSubnetIDNotFound,
    InvalidSubnetIdMalformed,
    MissingParameter,
  ],
}));
export type DeleteSubnetCidrReservationError =
  | RequestLimitExceeded
  | InvalidSubnetCidrReservationIDMalformed
  | InvalidSubnetCidrReservationIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes a subnet CIDR reservation.
 */
export const deleteSubnetCidrReservation: API.OperationMethod<
  DeleteSubnetCidrReservationRequest,
  DeleteSubnetCidrReservationResult,
  DeleteSubnetCidrReservationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteSubnetCidrReservationRequest,
  output: DeleteSubnetCidrReservationResult,
  errors: [
    RequestLimitExceeded,
    InvalidSubnetCidrReservationIDMalformed,
    InvalidSubnetCidrReservationIDNotFound,
    MissingParameter,
  ],
}));
export type DeleteTagsError =
  | RequestLimitExceeded
  | InvalidID
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified set of tags from the specified set of resources.
 *
 * To list the current tags, use DescribeTags. For more information about
 * tags, see Tag
 * your Amazon EC2 resources in the Amazon Elastic Compute Cloud User
 * Guide.
 */
export const deleteTags: API.OperationMethod<
  DeleteTagsRequest,
  DeleteTagsResponse,
  DeleteTagsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTagsRequest,
  output: DeleteTagsResponse,
  errors: [RequestLimitExceeded, InvalidID, MissingParameter],
}));
export type DeleteTrafficMirrorFilterError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidTrafficMirrorFilterIdNotFound
  | CommonErrors;
/**
 * Deletes the specified Traffic Mirror filter.
 *
 * You cannot delete a Traffic Mirror filter that is in use by a Traffic Mirror session.
 */
export const deleteTrafficMirrorFilter: API.OperationMethod<
  DeleteTrafficMirrorFilterRequest,
  DeleteTrafficMirrorFilterResult,
  DeleteTrafficMirrorFilterError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTrafficMirrorFilterRequest,
  output: DeleteTrafficMirrorFilterResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidTrafficMirrorFilterIdNotFound,
  ],
}));
export type DeleteTrafficMirrorFilterRuleError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidTrafficMirrorFilterRuleIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified Traffic Mirror rule.
 */
export const deleteTrafficMirrorFilterRule: API.OperationMethod<
  DeleteTrafficMirrorFilterRuleRequest,
  DeleteTrafficMirrorFilterRuleResult,
  DeleteTrafficMirrorFilterRuleError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTrafficMirrorFilterRuleRequest,
  output: DeleteTrafficMirrorFilterRuleResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidTrafficMirrorFilterRuleIdNotFound,
    MissingParameter,
  ],
}));
export type DeleteTrafficMirrorSessionError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidTrafficMirrorSessionIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified Traffic Mirror session.
 */
export const deleteTrafficMirrorSession: API.OperationMethod<
  DeleteTrafficMirrorSessionRequest,
  DeleteTrafficMirrorSessionResult,
  DeleteTrafficMirrorSessionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTrafficMirrorSessionRequest,
  output: DeleteTrafficMirrorSessionResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidTrafficMirrorSessionIdNotFound,
    MissingParameter,
  ],
}));
export type DeleteTrafficMirrorTargetError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidTrafficMirrorTargetIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified Traffic Mirror target.
 *
 * You cannot delete a Traffic Mirror target that is in use by a Traffic Mirror session.
 */
export const deleteTrafficMirrorTarget: API.OperationMethod<
  DeleteTrafficMirrorTargetRequest,
  DeleteTrafficMirrorTargetResult,
  DeleteTrafficMirrorTargetError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTrafficMirrorTargetRequest,
  output: DeleteTrafficMirrorTargetResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidTrafficMirrorTargetIdNotFound,
    MissingParameter,
  ],
}));
export type DeleteTransitGatewayError =
  | RequestLimitExceeded
  | IncorrectState
  | InvalidTransitGatewayIDMalformed
  | InvalidTransitGatewayIDNotFound
  | MissingParameter
  | ParseError
  | CommonErrors;
/**
 * Deletes the specified transit gateway.
 */
export const deleteTransitGateway: API.OperationMethod<
  DeleteTransitGatewayRequest,
  DeleteTransitGatewayResult,
  DeleteTransitGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTransitGatewayRequest,
  output: DeleteTransitGatewayResult,
  errors: [
    RequestLimitExceeded,
    IncorrectState,
    InvalidTransitGatewayIDMalformed,
    InvalidTransitGatewayIDNotFound,
    MissingParameter,
    ParseError,
  ],
}));
export type DeleteTransitGatewayConnectError =
  | RequestLimitExceeded
  | InvalidTransitGatewayAttachmentIDNotFound
  | CommonErrors;
/**
 * Deletes the specified Connect attachment. You must first delete any Connect peers for
 * the attachment.
 */
export const deleteTransitGatewayConnect: API.OperationMethod<
  DeleteTransitGatewayConnectRequest,
  DeleteTransitGatewayConnectResult,
  DeleteTransitGatewayConnectError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTransitGatewayConnectRequest,
  output: DeleteTransitGatewayConnectResult,
  errors: [RequestLimitExceeded, InvalidTransitGatewayAttachmentIDNotFound],
}));
export type DeleteTransitGatewayConnectPeerError =
  | RequestLimitExceeded
  | InvalidTransitGatewayConnectPeerIDMalformed
  | InvalidTransitGatewayConnectPeerIDNotFound
  | CommonErrors;
/**
 * Deletes the specified Connect peer.
 */
export const deleteTransitGatewayConnectPeer: API.OperationMethod<
  DeleteTransitGatewayConnectPeerRequest,
  DeleteTransitGatewayConnectPeerResult,
  DeleteTransitGatewayConnectPeerError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTransitGatewayConnectPeerRequest,
  output: DeleteTransitGatewayConnectPeerResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayConnectPeerIDMalformed,
    InvalidTransitGatewayConnectPeerIDNotFound,
  ],
}));
export type DeleteTransitGatewayMeteringPolicyError =
  | RequestLimitExceeded
  | InvalidTransitGatewayMeteringPolicyIdNotFound
  | InvalidTransitGatewayMeteringPolicyIdMalformedException
  | MissingParameter
  | CommonErrors;
/**
 * Deletes a transit gateway metering policy.
 */
export const deleteTransitGatewayMeteringPolicy: API.OperationMethod<
  DeleteTransitGatewayMeteringPolicyRequest,
  DeleteTransitGatewayMeteringPolicyResult,
  DeleteTransitGatewayMeteringPolicyError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTransitGatewayMeteringPolicyRequest,
  output: DeleteTransitGatewayMeteringPolicyResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayMeteringPolicyIdNotFound,
    InvalidTransitGatewayMeteringPolicyIdMalformedException,
    MissingParameter,
  ],
}));
export type DeleteTransitGatewayMeteringPolicyEntryError =
  | RequestLimitExceeded
  | InvalidTransitGatewayMeteringPolicyIdNotFound
  | InvalidTransitGatewayMeteringPolicyIdMalformedException
  | MissingParameter
  | CommonErrors;
/**
 * Deletes an entry from a transit gateway metering policy.
 */
export const deleteTransitGatewayMeteringPolicyEntry: API.OperationMethod<
  DeleteTransitGatewayMeteringPolicyEntryRequest,
  DeleteTransitGatewayMeteringPolicyEntryResult,
  DeleteTransitGatewayMeteringPolicyEntryError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTransitGatewayMeteringPolicyEntryRequest,
  output: DeleteTransitGatewayMeteringPolicyEntryResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayMeteringPolicyIdNotFound,
    InvalidTransitGatewayMeteringPolicyIdMalformedException,
    MissingParameter,
  ],
}));
export type DeleteTransitGatewayMulticastDomainError =
  | RequestLimitExceeded
  | InvalidTransitGatewayMulticastDomainIdMalformed
  | InvalidTransitGatewayMulticastDomainIdNotFound
  | CommonErrors;
/**
 * Deletes the specified transit gateway multicast domain.
 */
export const deleteTransitGatewayMulticastDomain: API.OperationMethod<
  DeleteTransitGatewayMulticastDomainRequest,
  DeleteTransitGatewayMulticastDomainResult,
  DeleteTransitGatewayMulticastDomainError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTransitGatewayMulticastDomainRequest,
  output: DeleteTransitGatewayMulticastDomainResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayMulticastDomainIdMalformed,
    InvalidTransitGatewayMulticastDomainIdNotFound,
  ],
}));
export type DeleteTransitGatewayPeeringAttachmentError =
  | RequestLimitExceeded
  | InvalidTransitGatewayAttachmentIDNotFound
  | CommonErrors;
/**
 * Deletes a transit gateway peering attachment.
 */
export const deleteTransitGatewayPeeringAttachment: API.OperationMethod<
  DeleteTransitGatewayPeeringAttachmentRequest,
  DeleteTransitGatewayPeeringAttachmentResult,
  DeleteTransitGatewayPeeringAttachmentError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTransitGatewayPeeringAttachmentRequest,
  output: DeleteTransitGatewayPeeringAttachmentResult,
  errors: [RequestLimitExceeded, InvalidTransitGatewayAttachmentIDNotFound],
}));
export type DeleteTransitGatewayPolicyTableError =
  | RequestLimitExceeded
  | InvalidTransitGatewayPolicyTableIdMalformed
  | InvalidTransitGatewayPolicyTableIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified transit gateway policy table.
 */
export const deleteTransitGatewayPolicyTable: API.OperationMethod<
  DeleteTransitGatewayPolicyTableRequest,
  DeleteTransitGatewayPolicyTableResult,
  DeleteTransitGatewayPolicyTableError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTransitGatewayPolicyTableRequest,
  output: DeleteTransitGatewayPolicyTableResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayPolicyTableIdMalformed,
    InvalidTransitGatewayPolicyTableIdNotFound,
    MissingParameter,
  ],
}));
export type DeleteTransitGatewayPrefixListReferenceError =
  | RequestLimitExceeded
  | InvalidRouteTableIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes a reference (route) to a prefix list in a specified transit gateway route table.
 */
export const deleteTransitGatewayPrefixListReference: API.OperationMethod<
  DeleteTransitGatewayPrefixListReferenceRequest,
  DeleteTransitGatewayPrefixListReferenceResult,
  DeleteTransitGatewayPrefixListReferenceError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTransitGatewayPrefixListReferenceRequest,
  output: DeleteTransitGatewayPrefixListReferenceResult,
  errors: [RequestLimitExceeded, InvalidRouteTableIDNotFound, MissingParameter],
}));
export type DeleteTransitGatewayRouteError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified route from the specified transit gateway route table.
 */
export const deleteTransitGatewayRoute: API.OperationMethod<
  DeleteTransitGatewayRouteRequest,
  DeleteTransitGatewayRouteResult,
  DeleteTransitGatewayRouteError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTransitGatewayRouteRequest,
  output: DeleteTransitGatewayRouteResult,
  errors: [RequestLimitExceeded, InvalidParameterValue, MissingParameter],
}));
export type DeleteTransitGatewayRouteTableError =
  | RequestLimitExceeded
  | IncorrectState
  | InvalidRouteTableIDNotFound
  | InvalidRouteTableIdMalformed
  | MissingParameter
  | ParseError
  | CommonErrors;
/**
 * Deletes the specified transit gateway route table. If there are any route tables associated with
 * the transit gateway route table, you must first run DisassociateRouteTable before you can delete the transit gateway route table. This removes any route tables associated with the transit gateway route table.
 */
export const deleteTransitGatewayRouteTable: API.OperationMethod<
  DeleteTransitGatewayRouteTableRequest,
  DeleteTransitGatewayRouteTableResult,
  DeleteTransitGatewayRouteTableError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTransitGatewayRouteTableRequest,
  output: DeleteTransitGatewayRouteTableResult,
  errors: [
    RequestLimitExceeded,
    IncorrectState,
    InvalidRouteTableIDNotFound,
    InvalidRouteTableIdMalformed,
    MissingParameter,
    ParseError,
  ],
}));
export type DeleteTransitGatewayRouteTableAnnouncementError =
  | RequestLimitExceeded
  | InvalidTransitGatewayRouteTableAnnouncementIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Advertises to the transit gateway that a transit gateway route table is deleted.
 */
export const deleteTransitGatewayRouteTableAnnouncement: API.OperationMethod<
  DeleteTransitGatewayRouteTableAnnouncementRequest,
  DeleteTransitGatewayRouteTableAnnouncementResult,
  DeleteTransitGatewayRouteTableAnnouncementError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTransitGatewayRouteTableAnnouncementRequest,
  output: DeleteTransitGatewayRouteTableAnnouncementResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayRouteTableAnnouncementIdMalformed,
    MissingParameter,
  ],
}));
export type DeleteTransitGatewayVpcAttachmentError =
  | RequestLimitExceeded
  | InvalidTransitGatewayAttachmentIDMalformed
  | InvalidTransitGatewayAttachmentIDNotFound
  | CommonErrors;
/**
 * Deletes the specified VPC attachment.
 */
export const deleteTransitGatewayVpcAttachment: API.OperationMethod<
  DeleteTransitGatewayVpcAttachmentRequest,
  DeleteTransitGatewayVpcAttachmentResult,
  DeleteTransitGatewayVpcAttachmentError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTransitGatewayVpcAttachmentRequest,
  output: DeleteTransitGatewayVpcAttachmentResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayAttachmentIDMalformed,
    InvalidTransitGatewayAttachmentIDNotFound,
  ],
}));
export type DeleteVerifiedAccessEndpointError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidVerifiedAccessEndpointIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Delete an Amazon Web Services Verified Access endpoint.
 */
export const deleteVerifiedAccessEndpoint: API.OperationMethod<
  DeleteVerifiedAccessEndpointRequest,
  DeleteVerifiedAccessEndpointResult,
  DeleteVerifiedAccessEndpointError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVerifiedAccessEndpointRequest,
  output: DeleteVerifiedAccessEndpointResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidVerifiedAccessEndpointIdNotFound,
    MissingParameter,
  ],
}));
export type DeleteVerifiedAccessGroupError =
  | RequestLimitExceeded
  | InvalidVerifiedAccessGroupIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Delete an Amazon Web Services Verified Access group.
 */
export const deleteVerifiedAccessGroup: API.OperationMethod<
  DeleteVerifiedAccessGroupRequest,
  DeleteVerifiedAccessGroupResult,
  DeleteVerifiedAccessGroupError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVerifiedAccessGroupRequest,
  output: DeleteVerifiedAccessGroupResult,
  errors: [
    RequestLimitExceeded,
    InvalidVerifiedAccessGroupIdNotFound,
    MissingParameter,
  ],
}));
export type DeleteVerifiedAccessInstanceError =
  | RequestLimitExceeded
  | InvalidVerifiedAccessInstanceIdNotFound
  | CommonErrors;
/**
 * Delete an Amazon Web Services Verified Access instance.
 */
export const deleteVerifiedAccessInstance: API.OperationMethod<
  DeleteVerifiedAccessInstanceRequest,
  DeleteVerifiedAccessInstanceResult,
  DeleteVerifiedAccessInstanceError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVerifiedAccessInstanceRequest,
  output: DeleteVerifiedAccessInstanceResult,
  errors: [RequestLimitExceeded, InvalidVerifiedAccessInstanceIdNotFound],
}));
export type DeleteVerifiedAccessTrustProviderError =
  | RequestLimitExceeded
  | InvalidVerifiedAccessTrustProviderIdNotFound
  | CommonErrors;
/**
 * Delete an Amazon Web Services Verified Access trust provider.
 */
export const deleteVerifiedAccessTrustProvider: API.OperationMethod<
  DeleteVerifiedAccessTrustProviderRequest,
  DeleteVerifiedAccessTrustProviderResult,
  DeleteVerifiedAccessTrustProviderError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVerifiedAccessTrustProviderRequest,
  output: DeleteVerifiedAccessTrustProviderResult,
  errors: [RequestLimitExceeded, InvalidVerifiedAccessTrustProviderIdNotFound],
}));
export type DeleteVolumeError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidVolumeNotFound
  | CommonErrors;
/**
 * Deletes the specified EBS volume. The volume must be in the `available` state
 * (not attached to an instance).
 *
 * The volume can remain in the `deleting` state for several minutes.
 *
 * For more information, see Delete an Amazon EBS volume in the
 * *Amazon EBS User Guide*.
 */
export const deleteVolume: API.OperationMethod<
  DeleteVolumeRequest,
  DeleteVolumeResponse,
  DeleteVolumeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVolumeRequest,
  output: DeleteVolumeResponse,
  errors: [RequestLimitExceeded, InvalidParameterValue, InvalidVolumeNotFound],
}));
export type DeleteVpcError =
  | RequestLimitExceeded
  | DependencyViolation
  | InvalidVpcIDNotFound
  | InvalidVpcIdMalformed
  | MissingParameter
  | RequestError
  | CommonErrors;
/**
 * Deletes the specified VPC. You must detach or delete all gateways and resources that are associated
 * with the VPC before you can delete it. For example, you must terminate all instances running in the VPC,
 * delete all security groups associated with the VPC (except the default one), delete all route tables
 * associated with the VPC (except the default one), and so on. When you delete the VPC, it deletes the
 * default security group, network ACL, and route table for the VPC.
 *
 * If you created a flow log for the VPC that you are deleting, note that flow logs for deleted
 * VPCs are eventually automatically removed.
 */
export const deleteVpc: API.OperationMethod<
  DeleteVpcRequest,
  DeleteVpcResponse,
  DeleteVpcError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVpcRequest,
  output: DeleteVpcResponse,
  errors: [
    RequestLimitExceeded,
    DependencyViolation,
    InvalidVpcIDNotFound,
    InvalidVpcIdMalformed,
    MissingParameter,
    RequestError,
  ],
}));
export type DeleteVpcBlockPublicAccessExclusionError =
  | RequestLimitExceeded
  | MissingParameter
  | VpcBlockPublicAccessExclusionIdMalformed
  | CommonErrors;
/**
 * Delete a VPC Block Public Access (BPA) exclusion. A VPC BPA exclusion is a mode that can be applied to a single VPC or subnet that exempts it from the accounts BPA mode and will allow bidirectional or egress-only access. You can create BPA exclusions for VPCs and subnets even when BPA is not enabled on the account to ensure that there is no traffic disruption to the exclusions when VPC BPA is turned on. To learn more about VPC BPA, see Block public access to VPCs and subnets in the *Amazon VPC User Guide*.
 */
export const deleteVpcBlockPublicAccessExclusion: API.OperationMethod<
  DeleteVpcBlockPublicAccessExclusionRequest,
  DeleteVpcBlockPublicAccessExclusionResult,
  DeleteVpcBlockPublicAccessExclusionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVpcBlockPublicAccessExclusionRequest,
  output: DeleteVpcBlockPublicAccessExclusionResult,
  errors: [
    RequestLimitExceeded,
    MissingParameter,
    VpcBlockPublicAccessExclusionIdMalformed,
  ],
}));
export type DeleteVpcEncryptionControlError =
  | RequestLimitExceeded
  | InvalidVpcEncryptionControlIdMalformed
  | InvalidVpcEncryptionControlIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes a VPC Encryption Control configuration. This removes the encryption policy enforcement from the specified VPC.
 *
 * For more information, see Enforce VPC encryption in transit in the *Amazon VPC User Guide*.
 */
export const deleteVpcEncryptionControl: API.OperationMethod<
  DeleteVpcEncryptionControlRequest,
  DeleteVpcEncryptionControlResult,
  DeleteVpcEncryptionControlError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVpcEncryptionControlRequest,
  output: DeleteVpcEncryptionControlResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcEncryptionControlIdMalformed,
    InvalidVpcEncryptionControlIdNotFound,
    MissingParameter,
  ],
}));
export type DeleteVpcEndpointConnectionNotificationsError = CommonErrors;
/**
 * Deletes the specified VPC endpoint connection notifications.
 */
export const deleteVpcEndpointConnectionNotifications: API.OperationMethod<
  DeleteVpcEndpointConnectionNotificationsRequest,
  DeleteVpcEndpointConnectionNotificationsResult,
  DeleteVpcEndpointConnectionNotificationsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVpcEndpointConnectionNotificationsRequest,
  output: DeleteVpcEndpointConnectionNotificationsResult,
  errors: [],
}));
export type DeleteVpcEndpointsError =
  | RequestLimitExceeded
  | InvalidVpcEndpointIdNotFound
  | ParseError
  | CommonErrors;
/**
 * Deletes the specified VPC endpoints.
 *
 * When you delete a gateway endpoint, we delete the endpoint routes in the route tables for the endpoint.
 *
 * When you delete a Gateway Load Balancer endpoint, we delete its endpoint network interfaces.
 * You can only delete Gateway Load Balancer endpoints when the routes that are associated with the endpoint are deleted.
 *
 * When you delete an interface endpoint, we delete its endpoint network interfaces.
 */
export const deleteVpcEndpoints: API.OperationMethod<
  DeleteVpcEndpointsRequest,
  DeleteVpcEndpointsResult,
  DeleteVpcEndpointsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVpcEndpointsRequest,
  output: DeleteVpcEndpointsResult,
  errors: [RequestLimitExceeded, InvalidVpcEndpointIdNotFound, ParseError],
}));
export type DeleteVpcEndpointServiceConfigurationsError = CommonErrors;
/**
 * Deletes the specified VPC endpoint service configurations. Before you can delete
 * an endpoint service configuration, you must reject any `Available` or
 * `PendingAcceptance` interface endpoint connections that are attached to
 * the service.
 */
export const deleteVpcEndpointServiceConfigurations: API.OperationMethod<
  DeleteVpcEndpointServiceConfigurationsRequest,
  DeleteVpcEndpointServiceConfigurationsResult,
  DeleteVpcEndpointServiceConfigurationsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVpcEndpointServiceConfigurationsRequest,
  output: DeleteVpcEndpointServiceConfigurationsResult,
  errors: [],
}));
export type DeleteVpcPeeringConnectionError =
  | RequestLimitExceeded
  | InvalidVpcPeeringConnectionIDNotFound
  | InvalidVpcPeeringConnectionIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes a VPC peering connection. Either the owner of the requester VPC or the owner
 * of the accepter VPC can delete the VPC peering connection if it's in the
 * `active` state. The owner of the requester VPC can delete a VPC peering
 * connection in the `pending-acceptance` state. You cannot delete a VPC peering
 * connection that's in the `failed` or `rejected` state.
 */
export const deleteVpcPeeringConnection: API.OperationMethod<
  DeleteVpcPeeringConnectionRequest,
  DeleteVpcPeeringConnectionResult,
  DeleteVpcPeeringConnectionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVpcPeeringConnectionRequest,
  output: DeleteVpcPeeringConnectionResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcPeeringConnectionIDNotFound,
    InvalidVpcPeeringConnectionIdNotFound,
    MissingParameter,
  ],
}));
export type DeleteVpnConcentratorError =
  | RequestLimitExceeded
  | InvalidVpnConcentratorIDMalformed
  | CommonErrors;
/**
 * Deletes the specified VPN concentrator.
 */
export const deleteVpnConcentrator: API.OperationMethod<
  DeleteVpnConcentratorRequest,
  DeleteVpnConcentratorResult,
  DeleteVpnConcentratorError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVpnConcentratorRequest,
  output: DeleteVpnConcentratorResult,
  errors: [RequestLimitExceeded, InvalidVpnConcentratorIDMalformed],
}));
export type DeleteVpnConnectionError =
  | RequestLimitExceeded
  | InvalidVpnConnectionIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified VPN connection.
 *
 * If you're deleting the VPC and its associated components, we recommend that you detach
 * the virtual private gateway from the VPC and delete the VPC before deleting the VPN
 * connection. If you believe that the tunnel credentials for your VPN connection have been
 * compromised, you can delete the VPN connection and create a new one that has new keys,
 * without needing to delete the VPC or virtual private gateway. If you create a new VPN
 * connection, you must reconfigure the customer gateway device using the new configuration
 * information returned with the new VPN connection ID.
 *
 * For certificate-based authentication, delete all Certificate Manager (ACM) private
 * certificates used for the Amazon Web Services-side tunnel endpoints for the VPN
 * connection before deleting the VPN connection.
 */
export const deleteVpnConnection: API.OperationMethod<
  DeleteVpnConnectionRequest,
  DeleteVpnConnectionResponse,
  DeleteVpnConnectionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVpnConnectionRequest,
  output: DeleteVpnConnectionResponse,
  errors: [
    RequestLimitExceeded,
    InvalidVpnConnectionIDNotFound,
    MissingParameter,
  ],
}));
export type DeleteVpnConnectionRouteError =
  | RequestLimitExceeded
  | InvalidRouteMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Deletes the specified static route associated with a VPN connection between an
 * existing virtual private gateway and a VPN customer gateway. The static route allows
 * traffic to be routed from the virtual private gateway to the VPN customer
 * gateway.
 */
export const deleteVpnConnectionRoute: API.OperationMethod<
  DeleteVpnConnectionRouteRequest,
  DeleteVpnConnectionRouteResponse,
  DeleteVpnConnectionRouteError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVpnConnectionRouteRequest,
  output: DeleteVpnConnectionRouteResponse,
  errors: [RequestLimitExceeded, InvalidRouteMalformed, MissingParameter],
}));
export type DeleteVpnGatewayError =
  | RequestLimitExceeded
  | IncorrectState
  | InvalidVpnGatewayIDNotFound
  | CommonErrors;
/**
 * Deletes the specified virtual private gateway. You must first detach the virtual
 * private gateway from the VPC. Note that you don't need to delete the virtual private
 * gateway if you plan to delete and recreate the VPN connection between your VPC and your
 * network.
 */
export const deleteVpnGateway: API.OperationMethod<
  DeleteVpnGatewayRequest,
  DeleteVpnGatewayResponse,
  DeleteVpnGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVpnGatewayRequest,
  output: DeleteVpnGatewayResponse,
  errors: [RequestLimitExceeded, IncorrectState, InvalidVpnGatewayIDNotFound],
}));
export type DeprovisionByoipCidrError = RequestLimitExceeded | CommonErrors;
/**
 * Releases the specified address range that you provisioned for use with your Amazon Web Services resources
 * through bring your own IP addresses (BYOIP) and deletes the corresponding address pool.
 *
 * Before you can release an address range, you must stop advertising it and you must not
 * have any IP addresses allocated from its address range.
 */
export const deprovisionByoipCidr: API.OperationMethod<
  DeprovisionByoipCidrRequest,
  DeprovisionByoipCidrResult,
  DeprovisionByoipCidrError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeprovisionByoipCidrRequest,
  output: DeprovisionByoipCidrResult,
  errors: [RequestLimitExceeded],
}));
export type DeprovisionIpamByoasnError =
  | RequestLimitExceeded
  | InvalidIpamIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deprovisions your Autonomous System Number (ASN) from your Amazon Web Services account. This action can only be called after any BYOIP CIDR associations are removed from your Amazon Web Services account with DisassociateIpamByoasn.
 * For more information, see Tutorial: Bring your ASN to IPAM in the *Amazon VPC IPAM guide*.
 */
export const deprovisionIpamByoasn: API.OperationMethod<
  DeprovisionIpamByoasnRequest,
  DeprovisionIpamByoasnResult,
  DeprovisionIpamByoasnError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeprovisionIpamByoasnRequest,
  output: DeprovisionIpamByoasnResult,
  errors: [RequestLimitExceeded, InvalidIpamIdNotFound, MissingParameter],
}));
export type DeprovisionIpamPoolCidrError =
  | RequestLimitExceeded
  | InvalidIpamPoolIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deprovision a CIDR provisioned from an IPAM pool. If you deprovision a CIDR from a pool that has a source pool, the CIDR is recycled back into the source pool. For more information, see Deprovision pool CIDRs in the *Amazon VPC IPAM User Guide*.
 */
export const deprovisionIpamPoolCidr: API.OperationMethod<
  DeprovisionIpamPoolCidrRequest,
  DeprovisionIpamPoolCidrResult,
  DeprovisionIpamPoolCidrError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeprovisionIpamPoolCidrRequest,
  output: DeprovisionIpamPoolCidrResult,
  errors: [RequestLimitExceeded, InvalidIpamPoolIdNotFound, MissingParameter],
}));
export type DeprovisionPublicIpv4PoolCidrError =
  | RequestLimitExceeded
  | InvalidPublicIpv4PoolNotFound
  | InvalidPublicIpv4PoolIDMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Deprovision a CIDR from a public IPv4 pool.
 */
export const deprovisionPublicIpv4PoolCidr: API.OperationMethod<
  DeprovisionPublicIpv4PoolCidrRequest,
  DeprovisionPublicIpv4PoolCidrResult,
  DeprovisionPublicIpv4PoolCidrError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeprovisionPublicIpv4PoolCidrRequest,
  output: DeprovisionPublicIpv4PoolCidrResult,
  errors: [
    RequestLimitExceeded,
    InvalidPublicIpv4PoolNotFound,
    InvalidPublicIpv4PoolIDMalformed,
    MissingParameter,
  ],
}));
export type DeregisterImageError =
  | RequestLimitExceeded
  | InvalidAMIIDMalformed
  | InvalidAMIIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Deregisters the specified AMI. A deregistered AMI can't be used to launch new
 * instances.
 *
 * If a deregistered EBS-backed AMI matches a Recycle Bin retention rule, it moves to the
 * Recycle Bin for the specified retention period. It can be restored before its retention period
 * expires, after which it is permanently deleted. If the deregistered AMI doesn't match a
 * retention rule, it is permanently deleted immediately. For more information, see Recover deleted Amazon EBS
 * snapshots and EBS-backed AMIs with Recycle Bin in the Amazon EBS User
 * Guide.
 *
 * When deregistering an EBS-backed AMI, you can optionally delete its associated snapshots
 * at the same time. However, if a snapshot is associated with multiple AMIs, it won't be deleted
 * even if specified for deletion, although the AMI will still be deregistered.
 *
 * Deregistering an AMI does not delete the following:
 *
 * - Instances already launched from the AMI. You'll continue to incur usage costs for the
 * instances until you terminate them.
 *
 * - For EBS-backed AMIs: Snapshots that are associated with multiple AMIs. You'll continue
 * to incur snapshot storage costs.
 *
 * - For instance store-backed AMIs: The files uploaded to Amazon S3 during AMI creation. You'll
 * continue to incur S3 storage costs.
 *
 * For more information, see Deregister an Amazon EC2 AMI in the
 * *Amazon EC2 User Guide*.
 */
export const deregisterImage: API.OperationMethod<
  DeregisterImageRequest,
  DeregisterImageResult,
  DeregisterImageError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeregisterImageRequest,
  output: DeregisterImageResult,
  errors: [
    RequestLimitExceeded,
    InvalidAMIIDMalformed,
    InvalidAMIIDNotFound,
    MissingParameter,
  ],
}));
export type DeregisterInstanceEventNotificationAttributesError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Deregisters tag keys to prevent tags that have the specified tag keys from being
 * included in scheduled event notifications for resources in the Region.
 */
export const deregisterInstanceEventNotificationAttributes: API.OperationMethod<
  DeregisterInstanceEventNotificationAttributesRequest,
  DeregisterInstanceEventNotificationAttributesResult,
  DeregisterInstanceEventNotificationAttributesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeregisterInstanceEventNotificationAttributesRequest,
  output: DeregisterInstanceEventNotificationAttributesResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type DeregisterTransitGatewayMulticastGroupMembersError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Deregisters the specified members (network interfaces) from the transit gateway multicast group.
 */
export const deregisterTransitGatewayMulticastGroupMembers: API.OperationMethod<
  DeregisterTransitGatewayMulticastGroupMembersRequest,
  DeregisterTransitGatewayMulticastGroupMembersResult,
  DeregisterTransitGatewayMulticastGroupMembersError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeregisterTransitGatewayMulticastGroupMembersRequest,
  output: DeregisterTransitGatewayMulticastGroupMembersResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type DeregisterTransitGatewayMulticastGroupSourcesError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Deregisters the specified sources (network interfaces) from the transit gateway multicast group.
 */
export const deregisterTransitGatewayMulticastGroupSources: API.OperationMethod<
  DeregisterTransitGatewayMulticastGroupSourcesRequest,
  DeregisterTransitGatewayMulticastGroupSourcesResult,
  DeregisterTransitGatewayMulticastGroupSourcesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeregisterTransitGatewayMulticastGroupSourcesRequest,
  output: DeregisterTransitGatewayMulticastGroupSourcesResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type DescribeAccountAttributesError = CommonErrors;
/**
 * Describes attributes of your Amazon Web Services account. The following are the supported account attributes:
 *
 * - `default-vpc`: The ID of the default VPC for your account, or `none`.
 *
 * - `max-instances`: This attribute is no longer supported. The returned
 * value does not reflect your actual vCPU limit for running On-Demand Instances.
 * For more information, see On-Demand Instance Limits in the
 * *Amazon Elastic Compute Cloud User Guide*.
 *
 * - `max-elastic-ips`: The maximum number of Elastic IP addresses that you can allocate.
 *
 * - `supported-platforms`: This attribute is deprecated.
 *
 * - `vpc-max-elastic-ips`: The maximum number of Elastic IP addresses that you can allocate.
 *
 * - `vpc-max-security-groups-per-interface`: The maximum number of security groups
 * that you can assign to a network interface.
 *
 * The order of the elements in the response, including those within nested
 * structures, might vary. Applications should not assume the elements appear in a
 * particular order.
 */
export const describeAccountAttributes: API.OperationMethod<
  DescribeAccountAttributesRequest,
  DescribeAccountAttributesResult,
  DescribeAccountAttributesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAccountAttributesRequest,
  output: DescribeAccountAttributesResult,
  errors: [],
}));
export type DescribeAddressesError =
  | RequestLimitExceeded
  | InvalidAllocationIDNotFound
  | CommonErrors;
/**
 * Describes the specified Elastic IP addresses or all of your Elastic IP addresses.
 */
export const describeAddresses: API.OperationMethod<
  DescribeAddressesRequest,
  DescribeAddressesResult,
  DescribeAddressesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAddressesRequest,
  output: DescribeAddressesResult,
  errors: [RequestLimitExceeded, InvalidAllocationIDNotFound],
}));
export type DescribeAddressesAttributeError =
  | RequestLimitExceeded
  | InvalidAllocationIDNotFound
  | CommonErrors;
/**
 * Describes the attributes of the specified Elastic IP addresses. For requirements, see Using reverse DNS for email applications.
 */
export const describeAddressesAttribute: API.OperationMethod<
  DescribeAddressesAttributeRequest,
  DescribeAddressesAttributeResult,
  DescribeAddressesAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeAddressesAttributeRequest,
  ) => stream.Stream<
    DescribeAddressesAttributeResult,
    DescribeAddressesAttributeError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeAddressesAttributeRequest,
  ) => stream.Stream<
    AddressAttribute,
    DescribeAddressesAttributeError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeAddressesAttributeRequest,
  output: DescribeAddressesAttributeResult,
  errors: [RequestLimitExceeded, InvalidAllocationIDNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Addresses",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeAddressTransfersError = CommonErrors;
/**
 * Describes an Elastic IP address transfer. For more information, see Transfer Elastic IP addresses in the *Amazon VPC User Guide*.
 *
 * When you transfer an Elastic IP address, there is a two-step handshake
 * between the source and transfer Amazon Web Services accounts. When the source account starts the transfer,
 * the transfer account has seven days to accept the Elastic IP address
 * transfer. During those seven days, the source account can view the
 * pending transfer by using this action. After seven days, the
 * transfer expires and ownership of the Elastic IP
 * address returns to the source
 * account. Accepted transfers are visible to the source account for 14 days
 * after the transfers have been accepted.
 */
export const describeAddressTransfers: API.OperationMethod<
  DescribeAddressTransfersRequest,
  DescribeAddressTransfersResult,
  DescribeAddressTransfersError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeAddressTransfersRequest,
  ) => stream.Stream<
    DescribeAddressTransfersResult,
    DescribeAddressTransfersError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeAddressTransfersRequest,
  ) => stream.Stream<
    AddressTransfer,
    DescribeAddressTransfersError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeAddressTransfersRequest,
  output: DescribeAddressTransfersResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AddressTransfers",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeAggregateIdFormatError = CommonErrors;
/**
 * Describes the longer ID format settings for all resource types in a specific
 * Region. This request is useful for performing a quick audit to determine whether a
 * specific Region is fully opted in for longer IDs (17-character IDs).
 *
 * This request only returns information about resource types that support longer IDs.
 *
 * The following resource types support longer IDs: `bundle` |
 * `conversion-task` | `customer-gateway` | `dhcp-options` |
 * `elastic-ip-allocation` | `elastic-ip-association` |
 * `export-task` | `flow-log` | `image` |
 * `import-task` | `instance` | `internet-gateway` |
 * `network-acl` | `network-acl-association` |
 * `network-interface` | `network-interface-attachment` |
 * `prefix-list` | `reservation` | `route-table` |
 * `route-table-association` | `security-group` |
 * `snapshot` | `subnet` |
 * `subnet-cidr-block-association` | `volume` | `vpc` |
 * `vpc-cidr-block-association` | `vpc-endpoint` |
 * `vpc-peering-connection` | `vpn-connection` | `vpn-gateway`.
 */
export const describeAggregateIdFormat: API.OperationMethod<
  DescribeAggregateIdFormatRequest,
  DescribeAggregateIdFormatResult,
  DescribeAggregateIdFormatError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAggregateIdFormatRequest,
  output: DescribeAggregateIdFormatResult,
  errors: [],
}));
export type DescribeAvailabilityZonesError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | ParseError
  | CommonErrors;
/**
 * Describes the Availability Zones, Local Zones, and Wavelength Zones that are available to
 * you.
 *
 * For more information about Availability Zones, Local Zones, and Wavelength Zones, see
 * Regions and zones
 * in the *Amazon EC2 User Guide*.
 *
 * The order of the elements in the response, including those within nested
 * structures, might vary. Applications should not assume the elements appear in a
 * particular order.
 */
export const describeAvailabilityZones: API.OperationMethod<
  DescribeAvailabilityZonesRequest,
  DescribeAvailabilityZonesResult,
  DescribeAvailabilityZonesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAvailabilityZonesRequest,
  output: DescribeAvailabilityZonesResult,
  errors: [RequestLimitExceeded, InvalidParameterValue, ParseError],
}));
export type DescribeAwsNetworkPerformanceMetricSubscriptionsError =
  CommonErrors;
/**
 * Describes the current Infrastructure Performance metric subscriptions.
 */
export const describeAwsNetworkPerformanceMetricSubscriptions: API.OperationMethod<
  DescribeAwsNetworkPerformanceMetricSubscriptionsRequest,
  DescribeAwsNetworkPerformanceMetricSubscriptionsResult,
  DescribeAwsNetworkPerformanceMetricSubscriptionsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeAwsNetworkPerformanceMetricSubscriptionsRequest,
  ) => stream.Stream<
    DescribeAwsNetworkPerformanceMetricSubscriptionsResult,
    DescribeAwsNetworkPerformanceMetricSubscriptionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeAwsNetworkPerformanceMetricSubscriptionsRequest,
  ) => stream.Stream<
    Subscription,
    DescribeAwsNetworkPerformanceMetricSubscriptionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeAwsNetworkPerformanceMetricSubscriptionsRequest,
  output: DescribeAwsNetworkPerformanceMetricSubscriptionsResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Subscriptions",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeBundleTasksError =
  | RequestLimitExceeded
  | InvalidBundleIDNotFound
  | InvalidInstanceIDMalformed
  | CommonErrors;
/**
 * Describes the specified bundle tasks or all of your bundle tasks.
 *
 * Completed bundle tasks are listed for only a limited time. If your bundle task is no
 * longer in the list, you can still register an AMI from it. Just use
 * `RegisterImage` with the Amazon S3 bucket name and image manifest name you provided
 * to the bundle task.
 *
 * The order of the elements in the response, including those within nested structures,
 * might vary. Applications should not assume the elements appear in a particular order.
 */
export const describeBundleTasks: API.OperationMethod<
  DescribeBundleTasksRequest,
  DescribeBundleTasksResult,
  DescribeBundleTasksError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeBundleTasksRequest,
  output: DescribeBundleTasksResult,
  errors: [
    RequestLimitExceeded,
    InvalidBundleIDNotFound,
    InvalidInstanceIDMalformed,
  ],
}));
export type DescribeByoipCidrsError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Describes the IP address ranges that were provisioned for use with Amazon Web Services resources
 * through through bring your own IP addresses (BYOIP).
 */
export const describeByoipCidrs: API.OperationMethod<
  DescribeByoipCidrsRequest,
  DescribeByoipCidrsResult,
  DescribeByoipCidrsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeByoipCidrsRequest,
  ) => stream.Stream<
    DescribeByoipCidrsResult,
    DescribeByoipCidrsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeByoipCidrsRequest,
  ) => stream.Stream<
    ByoipCidr,
    DescribeByoipCidrsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeByoipCidrsRequest,
  output: DescribeByoipCidrsResult,
  errors: [RequestLimitExceeded, MissingParameter],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ByoipCidrs",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeCapacityBlockExtensionHistoryError =
  | RequestLimitExceeded
  | InvalidCapacityReservationIdMalformed
  | CommonErrors;
/**
 * Describes the events for the specified Capacity Block extension during the specified
 * time.
 */
export const describeCapacityBlockExtensionHistory: API.OperationMethod<
  DescribeCapacityBlockExtensionHistoryRequest,
  DescribeCapacityBlockExtensionHistoryResult,
  DescribeCapacityBlockExtensionHistoryError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeCapacityBlockExtensionHistoryRequest,
  ) => stream.Stream<
    DescribeCapacityBlockExtensionHistoryResult,
    DescribeCapacityBlockExtensionHistoryError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeCapacityBlockExtensionHistoryRequest,
  ) => stream.Stream<
    CapacityBlockExtension,
    DescribeCapacityBlockExtensionHistoryError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeCapacityBlockExtensionHistoryRequest,
  output: DescribeCapacityBlockExtensionHistoryResult,
  errors: [RequestLimitExceeded, InvalidCapacityReservationIdMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "CapacityBlockExtensions",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeCapacityBlockExtensionOfferingsError =
  | RequestLimitExceeded
  | InvalidCapacityReservationIdNotFound
  | CommonErrors;
/**
 * Describes Capacity Block extension offerings available for purchase in the Amazon Web Services
 * Region that you're currently using.
 */
export const describeCapacityBlockExtensionOfferings: API.OperationMethod<
  DescribeCapacityBlockExtensionOfferingsRequest,
  DescribeCapacityBlockExtensionOfferingsResult,
  DescribeCapacityBlockExtensionOfferingsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeCapacityBlockExtensionOfferingsRequest,
  ) => stream.Stream<
    DescribeCapacityBlockExtensionOfferingsResult,
    DescribeCapacityBlockExtensionOfferingsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeCapacityBlockExtensionOfferingsRequest,
  ) => stream.Stream<
    CapacityBlockExtensionOffering,
    DescribeCapacityBlockExtensionOfferingsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeCapacityBlockExtensionOfferingsRequest,
  output: DescribeCapacityBlockExtensionOfferingsResult,
  errors: [RequestLimitExceeded, InvalidCapacityReservationIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "CapacityBlockExtensionOfferings",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeCapacityBlockOfferingsError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Describes Capacity Block offerings available for purchase in the Amazon Web Services Region that you're currently using. With Capacity Blocks, you can
 * purchase a specific GPU instance type or EC2 UltraServer for a period of time.
 *
 * To search for an available Capacity Block offering, you specify a reservation duration
 * and instance count.
 */
export const describeCapacityBlockOfferings: API.OperationMethod<
  DescribeCapacityBlockOfferingsRequest,
  DescribeCapacityBlockOfferingsResult,
  DescribeCapacityBlockOfferingsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeCapacityBlockOfferingsRequest,
  ) => stream.Stream<
    DescribeCapacityBlockOfferingsResult,
    DescribeCapacityBlockOfferingsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeCapacityBlockOfferingsRequest,
  ) => stream.Stream<
    CapacityBlockOffering,
    DescribeCapacityBlockOfferingsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeCapacityBlockOfferingsRequest,
  output: DescribeCapacityBlockOfferingsResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "CapacityBlockOfferings",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeCapacityBlocksError =
  | RequestLimitExceeded
  | InvalidCapacityBlockIdMalformed
  | CommonErrors;
/**
 * Describes details about Capacity Blocks in the Amazon Web Services Region that you're currently using.
 */
export const describeCapacityBlocks: API.OperationMethod<
  DescribeCapacityBlocksRequest,
  DescribeCapacityBlocksResult,
  DescribeCapacityBlocksError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeCapacityBlocksRequest,
  ) => stream.Stream<
    DescribeCapacityBlocksResult,
    DescribeCapacityBlocksError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeCapacityBlocksRequest,
  ) => stream.Stream<
    CapacityBlock,
    DescribeCapacityBlocksError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeCapacityBlocksRequest,
  output: DescribeCapacityBlocksResult,
  errors: [RequestLimitExceeded, InvalidCapacityBlockIdMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "CapacityBlocks",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeCapacityBlockStatusError =
  | RequestLimitExceeded
  | InvalidCapacityBlockIdMalformed
  | CommonErrors;
/**
 * Describes the availability of capacity for the specified Capacity blocks, or all of your Capacity Blocks.
 */
export const describeCapacityBlockStatus: API.OperationMethod<
  DescribeCapacityBlockStatusRequest,
  DescribeCapacityBlockStatusResult,
  DescribeCapacityBlockStatusError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeCapacityBlockStatusRequest,
  ) => stream.Stream<
    DescribeCapacityBlockStatusResult,
    DescribeCapacityBlockStatusError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeCapacityBlockStatusRequest,
  ) => stream.Stream<
    CapacityBlockStatus,
    DescribeCapacityBlockStatusError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeCapacityBlockStatusRequest,
  output: DescribeCapacityBlockStatusResult,
  errors: [RequestLimitExceeded, InvalidCapacityBlockIdMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "CapacityBlockStatuses",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeCapacityManagerDataExportsError =
  | RequestLimitExceeded
  | InvalidCapacityManagerDataExportIdNotFound
  | CommonErrors;
/**
 * Describes one or more Capacity Manager data export configurations. Returns information about export settings, delivery status, and recent export activity.
 */
export const describeCapacityManagerDataExports: API.OperationMethod<
  DescribeCapacityManagerDataExportsRequest,
  DescribeCapacityManagerDataExportsResult,
  DescribeCapacityManagerDataExportsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeCapacityManagerDataExportsRequest,
  ) => stream.Stream<
    DescribeCapacityManagerDataExportsResult,
    DescribeCapacityManagerDataExportsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeCapacityManagerDataExportsRequest,
  ) => stream.Stream<
    CapacityManagerDataExportResponse,
    DescribeCapacityManagerDataExportsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeCapacityManagerDataExportsRequest,
  output: DescribeCapacityManagerDataExportsResult,
  errors: [RequestLimitExceeded, InvalidCapacityManagerDataExportIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "CapacityManagerDataExports",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeCapacityReservationBillingRequestsError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Describes a request to assign the billing of the unused capacity of a Capacity
 * Reservation. For more information, see Billing assignment for shared
 * Amazon EC2 Capacity Reservations.
 */
export const describeCapacityReservationBillingRequests: API.OperationMethod<
  DescribeCapacityReservationBillingRequestsRequest,
  DescribeCapacityReservationBillingRequestsResult,
  DescribeCapacityReservationBillingRequestsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeCapacityReservationBillingRequestsRequest,
  ) => stream.Stream<
    DescribeCapacityReservationBillingRequestsResult,
    DescribeCapacityReservationBillingRequestsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeCapacityReservationBillingRequestsRequest,
  ) => stream.Stream<
    CapacityReservationBillingRequest,
    DescribeCapacityReservationBillingRequestsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeCapacityReservationBillingRequestsRequest,
  output: DescribeCapacityReservationBillingRequestsResult,
  errors: [RequestLimitExceeded, MissingParameter],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "CapacityReservationBillingRequests",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeCapacityReservationFleetsError =
  | RequestLimitExceeded
  | InvalidCapacityReservationFleetIdMalformed
  | CommonErrors;
/**
 * Describes one or more Capacity Reservation Fleets.
 */
export const describeCapacityReservationFleets: API.OperationMethod<
  DescribeCapacityReservationFleetsRequest,
  DescribeCapacityReservationFleetsResult,
  DescribeCapacityReservationFleetsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeCapacityReservationFleetsRequest,
  ) => stream.Stream<
    DescribeCapacityReservationFleetsResult,
    DescribeCapacityReservationFleetsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeCapacityReservationFleetsRequest,
  ) => stream.Stream<
    CapacityReservationFleet,
    DescribeCapacityReservationFleetsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeCapacityReservationFleetsRequest,
  output: DescribeCapacityReservationFleetsResult,
  errors: [RequestLimitExceeded, InvalidCapacityReservationFleetIdMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "CapacityReservationFleets",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeCapacityReservationsError =
  | RequestLimitExceeded
  | InvalidCapacityReservationIdMalformed
  | CommonErrors;
/**
 * Describes one or more of your Capacity Reservations. The results describe only the
 * Capacity Reservations in the Amazon Web Services Region that you're currently
 * using.
 */
export const describeCapacityReservations: API.OperationMethod<
  DescribeCapacityReservationsRequest,
  DescribeCapacityReservationsResult,
  DescribeCapacityReservationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeCapacityReservationsRequest,
  ) => stream.Stream<
    DescribeCapacityReservationsResult,
    DescribeCapacityReservationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeCapacityReservationsRequest,
  ) => stream.Stream<
    CapacityReservation,
    DescribeCapacityReservationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeCapacityReservationsRequest,
  output: DescribeCapacityReservationsResult,
  errors: [RequestLimitExceeded, InvalidCapacityReservationIdMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "CapacityReservations",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeCapacityReservationTopologyError = CommonErrors;
/**
 * Describes a tree-based hierarchy that represents the physical host placement of your
 * pending or active Capacity Reservations within an Availability Zone or Local Zone. You
 * can use this information to determine the relative proximity of your capacity within the
 * Amazon Web Services network before it is launched and use this information to allocate capacity
 * together to support your tightly coupled workloads.
 *
 * Capacity Reservation topology is supported for specific instance types only. For more
 * information, see Prerequisites
 * for Amazon EC2 instance topology in the
 * *Amazon EC2 User Guide*.
 *
 * The Amazon EC2 API follows an eventual consistency model due to the
 * distributed nature of the system supporting it. As a result, when you call the
 * DescribeCapacityReservationTopology API command immediately after launching
 * instances, the response might return a `null` value for
 * `capacityBlockId` because the data might not have fully propagated
 * across all subsystems. For more information, see Eventual consistency in the
 * Amazon EC2 API in the Amazon EC2 Developer
 * Guide.
 *
 * For more information, see Amazon EC2 topology in
 * the *Amazon EC2 User Guide*.
 */
export const describeCapacityReservationTopology: API.OperationMethod<
  DescribeCapacityReservationTopologyRequest,
  DescribeCapacityReservationTopologyResult,
  DescribeCapacityReservationTopologyError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeCapacityReservationTopologyRequest,
  output: DescribeCapacityReservationTopologyResult,
  errors: [],
}));
export type DescribeCarrierGatewaysError =
  | RequestLimitExceeded
  | InvalidCarrierGatewayIDMalformed
  | InvalidCarrierGatewayIDNotFound
  | ParseError
  | CommonErrors;
/**
 * Describes one or more of your carrier gateways.
 */
export const describeCarrierGateways: API.OperationMethod<
  DescribeCarrierGatewaysRequest,
  DescribeCarrierGatewaysResult,
  DescribeCarrierGatewaysError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeCarrierGatewaysRequest,
  ) => stream.Stream<
    DescribeCarrierGatewaysResult,
    DescribeCarrierGatewaysError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeCarrierGatewaysRequest,
  ) => stream.Stream<
    CarrierGateway,
    DescribeCarrierGatewaysError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeCarrierGatewaysRequest,
  output: DescribeCarrierGatewaysResult,
  errors: [
    RequestLimitExceeded,
    InvalidCarrierGatewayIDMalformed,
    InvalidCarrierGatewayIDNotFound,
    ParseError,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "CarrierGateways",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeClassicLinkInstancesError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | CommonErrors;
/**
 * This action is deprecated.
 *
 * Describes your linked EC2-Classic instances. This request only returns
 * information about EC2-Classic instances linked to a VPC through ClassicLink. You cannot
 * use this request to return information about other instances.
 */
export const describeClassicLinkInstances: API.OperationMethod<
  DescribeClassicLinkInstancesRequest,
  DescribeClassicLinkInstancesResult,
  DescribeClassicLinkInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeClassicLinkInstancesRequest,
  ) => stream.Stream<
    DescribeClassicLinkInstancesResult,
    DescribeClassicLinkInstancesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeClassicLinkInstancesRequest,
  ) => stream.Stream<
    ClassicLinkInstance,
    DescribeClassicLinkInstancesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeClassicLinkInstancesRequest,
  output: DescribeClassicLinkInstancesResult,
  errors: [RequestLimitExceeded, InvalidInstanceIDMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Instances",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeClientVpnAuthorizationRulesError =
  | RequestLimitExceeded
  | InvalidClientVpnEndpointIdNotFound
  | CommonErrors;
/**
 * Describes the authorization rules for a specified Client VPN endpoint.
 */
export const describeClientVpnAuthorizationRules: API.OperationMethod<
  DescribeClientVpnAuthorizationRulesRequest,
  DescribeClientVpnAuthorizationRulesResult,
  DescribeClientVpnAuthorizationRulesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeClientVpnAuthorizationRulesRequest,
  ) => stream.Stream<
    DescribeClientVpnAuthorizationRulesResult,
    DescribeClientVpnAuthorizationRulesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeClientVpnAuthorizationRulesRequest,
  ) => stream.Stream<
    AuthorizationRule,
    DescribeClientVpnAuthorizationRulesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeClientVpnAuthorizationRulesRequest,
  output: DescribeClientVpnAuthorizationRulesResult,
  errors: [RequestLimitExceeded, InvalidClientVpnEndpointIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AuthorizationRules",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeClientVpnConnectionsError =
  | RequestLimitExceeded
  | InvalidClientVpnEndpointIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Describes active client connections and connections that have been terminated within the last 60
 * minutes for the specified Client VPN endpoint.
 */
export const describeClientVpnConnections: API.OperationMethod<
  DescribeClientVpnConnectionsRequest,
  DescribeClientVpnConnectionsResult,
  DescribeClientVpnConnectionsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeClientVpnConnectionsRequest,
  ) => stream.Stream<
    DescribeClientVpnConnectionsResult,
    DescribeClientVpnConnectionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeClientVpnConnectionsRequest,
  ) => stream.Stream<
    ClientVpnConnection,
    DescribeClientVpnConnectionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeClientVpnConnectionsRequest,
  output: DescribeClientVpnConnectionsResult,
  errors: [
    RequestLimitExceeded,
    InvalidClientVpnEndpointIdNotFound,
    MissingParameter,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Connections",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeClientVpnEndpointsError =
  | RequestLimitExceeded
  | InvalidClientVpnEndpointIdNotFound
  | CommonErrors;
/**
 * Describes one or more Client VPN endpoints in the account.
 */
export const describeClientVpnEndpoints: API.OperationMethod<
  DescribeClientVpnEndpointsRequest,
  DescribeClientVpnEndpointsResult,
  DescribeClientVpnEndpointsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeClientVpnEndpointsRequest,
  ) => stream.Stream<
    DescribeClientVpnEndpointsResult,
    DescribeClientVpnEndpointsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeClientVpnEndpointsRequest,
  ) => stream.Stream<
    ClientVpnEndpoint,
    DescribeClientVpnEndpointsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeClientVpnEndpointsRequest,
  output: DescribeClientVpnEndpointsResult,
  errors: [RequestLimitExceeded, InvalidClientVpnEndpointIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ClientVpnEndpoints",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeClientVpnRoutesError =
  | RequestLimitExceeded
  | InvalidClientVpnEndpointIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Describes the routes for the specified Client VPN endpoint.
 */
export const describeClientVpnRoutes: API.OperationMethod<
  DescribeClientVpnRoutesRequest,
  DescribeClientVpnRoutesResult,
  DescribeClientVpnRoutesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeClientVpnRoutesRequest,
  ) => stream.Stream<
    DescribeClientVpnRoutesResult,
    DescribeClientVpnRoutesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeClientVpnRoutesRequest,
  ) => stream.Stream<
    ClientVpnRoute,
    DescribeClientVpnRoutesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeClientVpnRoutesRequest,
  output: DescribeClientVpnRoutesResult,
  errors: [
    RequestLimitExceeded,
    InvalidClientVpnEndpointIdNotFound,
    MissingParameter,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Routes",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeClientVpnTargetNetworksError =
  | RequestLimitExceeded
  | InvalidClientVpnEndpointIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Describes the target networks associated with the specified Client VPN endpoint.
 */
export const describeClientVpnTargetNetworks: API.OperationMethod<
  DescribeClientVpnTargetNetworksRequest,
  DescribeClientVpnTargetNetworksResult,
  DescribeClientVpnTargetNetworksError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeClientVpnTargetNetworksRequest,
  ) => stream.Stream<
    DescribeClientVpnTargetNetworksResult,
    DescribeClientVpnTargetNetworksError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeClientVpnTargetNetworksRequest,
  ) => stream.Stream<
    TargetNetwork,
    DescribeClientVpnTargetNetworksError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeClientVpnTargetNetworksRequest,
  output: DescribeClientVpnTargetNetworksResult,
  errors: [
    RequestLimitExceeded,
    InvalidClientVpnEndpointIdNotFound,
    MissingParameter,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ClientVpnTargetNetworks",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeCoipPoolsError =
  | RequestLimitExceeded
  | InvalidPoolIDMalformed
  | CommonErrors;
/**
 * Describes the specified customer-owned address pools or all of your customer-owned address pools.
 */
export const describeCoipPools: API.OperationMethod<
  DescribeCoipPoolsRequest,
  DescribeCoipPoolsResult,
  DescribeCoipPoolsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeCoipPoolsRequest,
  ) => stream.Stream<
    DescribeCoipPoolsResult,
    DescribeCoipPoolsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeCoipPoolsRequest,
  ) => stream.Stream<
    CoipPool,
    DescribeCoipPoolsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeCoipPoolsRequest,
  output: DescribeCoipPoolsResult,
  errors: [RequestLimitExceeded, InvalidPoolIDMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "CoipPools",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeConversionTasksError = CommonErrors;
/**
 * Describes the specified conversion tasks or all your conversion tasks. For more information, see the
 * VM Import/Export User Guide.
 *
 * For information about the import manifest referenced by this API action, see VM Import Manifest.
 */
export const describeConversionTasks: API.OperationMethod<
  DescribeConversionTasksRequest,
  DescribeConversionTasksResult,
  DescribeConversionTasksError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeConversionTasksRequest,
  output: DescribeConversionTasksResult,
  errors: [],
}));
export type DescribeCustomerGatewaysError =
  | RequestLimitExceeded
  | InvalidCustomerGatewayIDNotFound
  | ParseError
  | CommonErrors;
/**
 * Describes one or more of your VPN customer gateways.
 *
 * For more information, see Amazon Web Services Site-to-Site VPN in the Amazon Web Services Site-to-Site VPN
 * User Guide.
 */
export const describeCustomerGateways: API.OperationMethod<
  DescribeCustomerGatewaysRequest,
  DescribeCustomerGatewaysResult,
  DescribeCustomerGatewaysError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeCustomerGatewaysRequest,
  output: DescribeCustomerGatewaysResult,
  errors: [RequestLimitExceeded, InvalidCustomerGatewayIDNotFound, ParseError],
}));
export type DescribeDeclarativePoliciesReportsError =
  | RequestLimitExceeded
  | InvalidParameter
  | CommonErrors;
/**
 * Describes the metadata of an account status report, including the status of the
 * report.
 *
 * To view the full report, download it from the Amazon S3 bucket where it was saved.
 * Reports are accessible only when they have the `complete` status. Reports
 * with other statuses (`running`, `cancelled`, or
 * `error`) are not available in the S3 bucket. For more information about
 * downloading objects from an S3 bucket, see Downloading objects in
 * the *Amazon Simple Storage Service User Guide*.
 *
 * For more information, see Generating the account status report for declarative policies in the
 * *Amazon Web Services Organizations User Guide*.
 */
export const describeDeclarativePoliciesReports: API.OperationMethod<
  DescribeDeclarativePoliciesReportsRequest,
  DescribeDeclarativePoliciesReportsResult,
  DescribeDeclarativePoliciesReportsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDeclarativePoliciesReportsRequest,
  output: DescribeDeclarativePoliciesReportsResult,
  errors: [RequestLimitExceeded, InvalidParameter],
}));
export type DescribeDhcpOptionsError =
  | RequestLimitExceeded
  | InvalidDhcpOptionIDNotFound
  | InvalidParameterValue
  | ParseError
  | CommonErrors;
/**
 * Describes your DHCP option sets. The default is to describe all your DHCP option sets.
 * Alternatively, you can specify specific DHCP option set IDs or filter the results to
 * include only the DHCP option sets that match specific criteria.
 *
 * For more information, see DHCP option sets in the
 * *Amazon VPC User Guide*.
 */
export const describeDhcpOptions: API.OperationMethod<
  DescribeDhcpOptionsRequest,
  DescribeDhcpOptionsResult,
  DescribeDhcpOptionsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeDhcpOptionsRequest,
  ) => stream.Stream<
    DescribeDhcpOptionsResult,
    DescribeDhcpOptionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeDhcpOptionsRequest,
  ) => stream.Stream<
    DhcpOptions,
    DescribeDhcpOptionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeDhcpOptionsRequest,
  output: DescribeDhcpOptionsResult,
  errors: [
    RequestLimitExceeded,
    InvalidDhcpOptionIDNotFound,
    InvalidParameterValue,
    ParseError,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "DhcpOptions",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeEgressOnlyInternetGatewaysError =
  | RequestLimitExceeded
  | InvalidEgressOnlyInternetGatewayIdMalformed
  | InvalidEgressOnlyInternetGatewayIdNotFound
  | ParseError
  | CommonErrors;
/**
 * Describes your egress-only internet gateways. The default is to describe all your egress-only internet gateways.
 * Alternatively, you can specify specific egress-only internet gateway IDs or filter the results to
 * include only the egress-only internet gateways that match specific criteria.
 */
export const describeEgressOnlyInternetGateways: API.OperationMethod<
  DescribeEgressOnlyInternetGatewaysRequest,
  DescribeEgressOnlyInternetGatewaysResult,
  DescribeEgressOnlyInternetGatewaysError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeEgressOnlyInternetGatewaysRequest,
  ) => stream.Stream<
    DescribeEgressOnlyInternetGatewaysResult,
    DescribeEgressOnlyInternetGatewaysError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeEgressOnlyInternetGatewaysRequest,
  ) => stream.Stream<
    EgressOnlyInternetGateway,
    DescribeEgressOnlyInternetGatewaysError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeEgressOnlyInternetGatewaysRequest,
  output: DescribeEgressOnlyInternetGatewaysResult,
  errors: [
    RequestLimitExceeded,
    InvalidEgressOnlyInternetGatewayIdMalformed,
    InvalidEgressOnlyInternetGatewayIdNotFound,
    ParseError,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "EgressOnlyInternetGateways",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeElasticGpusError =
  | RequestLimitExceeded
  | UnsupportedOperation
  | CommonErrors;
/**
 * Amazon Elastic Graphics reached end of life on January 8, 2024.
 *
 * Describes the Elastic Graphics accelerator associated with your instances.
 */
export const describeElasticGpus: API.OperationMethod<
  DescribeElasticGpusRequest,
  DescribeElasticGpusResult,
  DescribeElasticGpusError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeElasticGpusRequest,
  output: DescribeElasticGpusResult,
  errors: [RequestLimitExceeded, UnsupportedOperation],
}));
export type DescribeExportImageTasksError =
  | RequestLimitExceeded
  | InvalidExportTaskIDMalformed
  | CommonErrors;
/**
 * Describes the specified export image tasks or all of your export image tasks.
 */
export const describeExportImageTasks: API.OperationMethod<
  DescribeExportImageTasksRequest,
  DescribeExportImageTasksResult,
  DescribeExportImageTasksError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeExportImageTasksRequest,
  ) => stream.Stream<
    DescribeExportImageTasksResult,
    DescribeExportImageTasksError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeExportImageTasksRequest,
  ) => stream.Stream<
    ExportImageTask,
    DescribeExportImageTasksError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeExportImageTasksRequest,
  output: DescribeExportImageTasksResult,
  errors: [RequestLimitExceeded, InvalidExportTaskIDMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ExportImageTasks",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeExportTasksError =
  | RequestLimitExceeded
  | InvalidExportTaskIDMalformed
  | CommonErrors;
/**
 * Describes the specified export instance tasks or all of your export instance tasks.
 */
export const describeExportTasks: API.OperationMethod<
  DescribeExportTasksRequest,
  DescribeExportTasksResult,
  DescribeExportTasksError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeExportTasksRequest,
  output: DescribeExportTasksResult,
  errors: [RequestLimitExceeded, InvalidExportTaskIDMalformed],
}));
export type DescribeFastLaunchImagesError =
  | RequestLimitExceeded
  | InvalidRequest
  | CommonErrors;
/**
 * Describe details for Windows AMIs that are configured for Windows fast launch.
 */
export const describeFastLaunchImages: API.OperationMethod<
  DescribeFastLaunchImagesRequest,
  DescribeFastLaunchImagesResult,
  DescribeFastLaunchImagesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeFastLaunchImagesRequest,
  ) => stream.Stream<
    DescribeFastLaunchImagesResult,
    DescribeFastLaunchImagesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeFastLaunchImagesRequest,
  ) => stream.Stream<
    DescribeFastLaunchImagesSuccessItem,
    DescribeFastLaunchImagesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeFastLaunchImagesRequest,
  output: DescribeFastLaunchImagesResult,
  errors: [RequestLimitExceeded, InvalidRequest],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "FastLaunchImages",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeFastSnapshotRestoresError = CommonErrors;
/**
 * Describes the state of fast snapshot restores for your snapshots.
 */
export const describeFastSnapshotRestores: API.OperationMethod<
  DescribeFastSnapshotRestoresRequest,
  DescribeFastSnapshotRestoresResult,
  DescribeFastSnapshotRestoresError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeFastSnapshotRestoresRequest,
  ) => stream.Stream<
    DescribeFastSnapshotRestoresResult,
    DescribeFastSnapshotRestoresError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeFastSnapshotRestoresRequest,
  ) => stream.Stream<
    DescribeFastSnapshotRestoreSuccessItem,
    DescribeFastSnapshotRestoresError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeFastSnapshotRestoresRequest,
  output: DescribeFastSnapshotRestoresResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "FastSnapshotRestores",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeFleetHistoryError =
  | RequestLimitExceeded
  | InvalidFleetIdMalformed
  | CommonErrors;
/**
 * Describes the events for the specified EC2 Fleet during the specified time.
 *
 * EC2 Fleet events are delayed by up to 30 seconds before they can be described. This ensures
 * that you can query by the last evaluated time and not miss a recorded event. EC2 Fleet events
 * are available for 48 hours.
 *
 * For more information, see Monitor fleet events using Amazon EventBridge in the
 * *Amazon EC2 User Guide*.
 */
export const describeFleetHistory: API.OperationMethod<
  DescribeFleetHistoryRequest,
  DescribeFleetHistoryResult,
  DescribeFleetHistoryError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeFleetHistoryRequest,
  output: DescribeFleetHistoryResult,
  errors: [RequestLimitExceeded, InvalidFleetIdMalformed],
}));
export type DescribeFleetInstancesError =
  | RequestLimitExceeded
  | InvalidFleetIdMalformed
  | CommonErrors;
/**
 * Describes the running instances for the specified EC2 Fleet.
 *
 * Currently, `DescribeFleetInstances` does not support fleets of type
 * `instant`. Instead, use `DescribeFleets`, specifying the
 * `instant` fleet ID in the request.
 *
 * For more information, see Describe your
 * EC2 Fleet in the *Amazon EC2 User Guide*.
 */
export const describeFleetInstances: API.OperationMethod<
  DescribeFleetInstancesRequest,
  DescribeFleetInstancesResult,
  DescribeFleetInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeFleetInstancesRequest,
  output: DescribeFleetInstancesResult,
  errors: [RequestLimitExceeded, InvalidFleetIdMalformed],
}));
export type DescribeFleetsError =
  | RequestLimitExceeded
  | InvalidFleetIdMalformed
  | CommonErrors;
/**
 * Describes the specified EC2 Fleet or all of your EC2 Fleets.
 *
 * If a fleet is of type `instant`, you must specify the fleet ID in the
 * request, otherwise the fleet does not appear in the response.
 *
 * For more information, see Describe your
 * EC2 Fleet in the *Amazon EC2 User Guide*.
 */
export const describeFleets: API.OperationMethod<
  DescribeFleetsRequest,
  DescribeFleetsResult,
  DescribeFleetsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeFleetsRequest,
  ) => stream.Stream<
    DescribeFleetsResult,
    DescribeFleetsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeFleetsRequest,
  ) => stream.Stream<
    FleetData,
    DescribeFleetsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeFleetsRequest,
  output: DescribeFleetsResult,
  errors: [RequestLimitExceeded, InvalidFleetIdMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Fleets",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeFlowLogsError =
  | RequestLimitExceeded
  | ParseError
  | CommonErrors;
/**
 * Describes one or more flow logs.
 *
 * To view the published flow log records, you must view the log destination. For example,
 * the CloudWatch Logs log group, the Amazon S3 bucket, or the Kinesis Data Firehose delivery stream.
 */
export const describeFlowLogs: API.OperationMethod<
  DescribeFlowLogsRequest,
  DescribeFlowLogsResult,
  DescribeFlowLogsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeFlowLogsRequest,
  ) => stream.Stream<
    DescribeFlowLogsResult,
    DescribeFlowLogsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeFlowLogsRequest,
  ) => stream.Stream<
    FlowLog,
    DescribeFlowLogsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeFlowLogsRequest,
  output: DescribeFlowLogsResult,
  errors: [RequestLimitExceeded, ParseError],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "FlowLogs",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeFpgaImageAttributeError =
  | RequestLimitExceeded
  | InvalidFpgaImageIDMalformed
  | InvalidFpgaImageIDNotFound
  | CommonErrors;
/**
 * Describes the specified attribute of the specified Amazon FPGA Image (AFI).
 */
export const describeFpgaImageAttribute: API.OperationMethod<
  DescribeFpgaImageAttributeRequest,
  DescribeFpgaImageAttributeResult,
  DescribeFpgaImageAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeFpgaImageAttributeRequest,
  output: DescribeFpgaImageAttributeResult,
  errors: [
    RequestLimitExceeded,
    InvalidFpgaImageIDMalformed,
    InvalidFpgaImageIDNotFound,
  ],
}));
export type DescribeFpgaImagesError =
  | RequestLimitExceeded
  | InvalidFpgaImageIDMalformed
  | CommonErrors;
/**
 * Describes the Amazon FPGA Images (AFIs) available to you. These include public AFIs,
 * private AFIs that you own, and AFIs owned by other Amazon Web Services accounts for which you have load
 * permissions.
 */
export const describeFpgaImages: API.OperationMethod<
  DescribeFpgaImagesRequest,
  DescribeFpgaImagesResult,
  DescribeFpgaImagesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeFpgaImagesRequest,
  ) => stream.Stream<
    DescribeFpgaImagesResult,
    DescribeFpgaImagesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeFpgaImagesRequest,
  ) => stream.Stream<
    FpgaImage,
    DescribeFpgaImagesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeFpgaImagesRequest,
  output: DescribeFpgaImagesResult,
  errors: [RequestLimitExceeded, InvalidFpgaImageIDMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "FpgaImages",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeHostReservationOfferingsError =
  | RequestLimitExceeded
  | InvalidHostReservationOfferingIdMalformed
  | CommonErrors;
/**
 * Describes the Dedicated Host reservations that are available to purchase.
 *
 * The results describe all of the Dedicated Host reservation offerings, including
 * offerings that might not match the instance family and Region of your Dedicated Hosts.
 * When purchasing an offering, ensure that the instance family and Region of the offering
 * matches that of the Dedicated Hosts with which it is to be associated. For more
 * information about supported instance types, see Dedicated Hosts
 * in the *Amazon EC2 User Guide*.
 */
export const describeHostReservationOfferings: API.OperationMethod<
  DescribeHostReservationOfferingsRequest,
  DescribeHostReservationOfferingsResult,
  DescribeHostReservationOfferingsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeHostReservationOfferingsRequest,
  ) => stream.Stream<
    DescribeHostReservationOfferingsResult,
    DescribeHostReservationOfferingsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeHostReservationOfferingsRequest,
  ) => stream.Stream<
    HostOffering,
    DescribeHostReservationOfferingsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeHostReservationOfferingsRequest,
  output: DescribeHostReservationOfferingsResult,
  errors: [RequestLimitExceeded, InvalidHostReservationOfferingIdMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "OfferingSet",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeHostReservationsError = CommonErrors;
/**
 * Describes reservations that are associated with Dedicated Hosts in your
 * account.
 */
export const describeHostReservations: API.OperationMethod<
  DescribeHostReservationsRequest,
  DescribeHostReservationsResult,
  DescribeHostReservationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeHostReservationsRequest,
  ) => stream.Stream<
    DescribeHostReservationsResult,
    DescribeHostReservationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeHostReservationsRequest,
  ) => stream.Stream<
    HostReservation,
    DescribeHostReservationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeHostReservationsRequest,
  output: DescribeHostReservationsResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "HostReservationSet",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeHostsError =
  | RequestLimitExceeded
  | InvalidHostIDMalformed
  | CommonErrors;
/**
 * Describes the specified Dedicated Hosts or all your Dedicated Hosts.
 *
 * The results describe only the Dedicated Hosts in the Region you're currently using.
 * All listed instances consume capacity on your Dedicated Host. Dedicated Hosts that have
 * recently been released are listed with the state `released`.
 */
export const describeHosts: API.OperationMethod<
  DescribeHostsRequest,
  DescribeHostsResult,
  DescribeHostsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeHostsRequest,
  ) => stream.Stream<
    DescribeHostsResult,
    DescribeHostsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeHostsRequest,
  ) => stream.Stream<
    Host,
    DescribeHostsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeHostsRequest,
  output: DescribeHostsResult,
  errors: [RequestLimitExceeded, InvalidHostIDMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Hosts",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeIamInstanceProfileAssociationsError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Describes your IAM instance profile associations.
 */
export const describeIamInstanceProfileAssociations: API.OperationMethod<
  DescribeIamInstanceProfileAssociationsRequest,
  DescribeIamInstanceProfileAssociationsResult,
  DescribeIamInstanceProfileAssociationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeIamInstanceProfileAssociationsRequest,
  ) => stream.Stream<
    DescribeIamInstanceProfileAssociationsResult,
    DescribeIamInstanceProfileAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeIamInstanceProfileAssociationsRequest,
  ) => stream.Stream<
    IamInstanceProfileAssociation,
    DescribeIamInstanceProfileAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeIamInstanceProfileAssociationsRequest,
  output: DescribeIamInstanceProfileAssociationsResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "IamInstanceProfileAssociations",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeIdentityIdFormatError =
  | RequestLimitExceeded
  | InvalidTargetArnUnknown
  | CommonErrors;
/**
 * Describes the ID format settings for resources for the specified IAM user, IAM role, or root
 * user. For example, you can view the resource types that are enabled for longer IDs. This request only
 * returns information about resource types whose ID formats can be modified; it does not return
 * information about other resource types. For more information, see Resource IDs in the *Amazon Elastic Compute Cloud User Guide*.
 *
 * The following resource types support longer IDs: `bundle` |
 * `conversion-task` | `customer-gateway` | `dhcp-options` |
 * `elastic-ip-allocation` | `elastic-ip-association` |
 * `export-task` | `flow-log` | `image` |
 * `import-task` | `instance` | `internet-gateway` |
 * `network-acl` | `network-acl-association` |
 * `network-interface` | `network-interface-attachment` |
 * `prefix-list` | `reservation` | `route-table` |
 * `route-table-association` | `security-group` |
 * `snapshot` | `subnet` |
 * `subnet-cidr-block-association` | `volume` | `vpc`
 * | `vpc-cidr-block-association` | `vpc-endpoint` |
 * `vpc-peering-connection` | `vpn-connection` | `vpn-gateway`.
 *
 * These settings apply to the principal specified in the request. They do not apply to the
 * principal that makes the request.
 */
export const describeIdentityIdFormat: API.OperationMethod<
  DescribeIdentityIdFormatRequest,
  DescribeIdentityIdFormatResult,
  DescribeIdentityIdFormatError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeIdentityIdFormatRequest,
  output: DescribeIdentityIdFormatResult,
  errors: [RequestLimitExceeded, InvalidTargetArnUnknown],
}));
export type DescribeIdFormatError = CommonErrors;
/**
 * Describes the ID format settings for your resources on a per-Region basis, for example, to view which resource types are enabled for longer IDs. This request only returns information about resource types whose ID formats can be modified; it does not return information about other resource types.
 *
 * The following resource types support longer IDs: `bundle` |
 * `conversion-task` | `customer-gateway` | `dhcp-options` |
 * `elastic-ip-allocation` | `elastic-ip-association` |
 * `export-task` | `flow-log` | `image` |
 * `import-task` | `instance` | `internet-gateway` |
 * `network-acl` | `network-acl-association` |
 * `network-interface` | `network-interface-attachment` |
 * `prefix-list` | `reservation` | `route-table` |
 * `route-table-association` | `security-group` |
 * `snapshot` | `subnet` |
 * `subnet-cidr-block-association` | `volume` | `vpc`
 * | `vpc-cidr-block-association` | `vpc-endpoint` |
 * `vpc-peering-connection` | `vpn-connection` | `vpn-gateway`.
 *
 * These settings apply to the IAM user who makes the request; they do not apply to the entire
 * Amazon Web Services account. By default, an IAM user defaults to the same settings as the root user, unless
 * they explicitly override the settings by running the ModifyIdFormat command. Resources
 * created with longer IDs are visible to all IAM users, regardless of these settings and
 * provided that they have permission to use the relevant `Describe` command for the
 * resource type.
 */
export const describeIdFormat: API.OperationMethod<
  DescribeIdFormatRequest,
  DescribeIdFormatResult,
  DescribeIdFormatError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeIdFormatRequest,
  output: DescribeIdFormatResult,
  errors: [],
}));
export type DescribeImageAttributeError =
  | RequestLimitExceeded
  | InvalidAMIIDMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Describes the specified attribute of the specified AMI. You can specify only one attribute
 * at a time.
 *
 * The order of the elements in the response, including those within nested structures,
 * might vary. Applications should not assume the elements appear in a particular order.
 */
export const describeImageAttribute: API.OperationMethod<
  DescribeImageAttributeRequest,
  ImageAttribute,
  DescribeImageAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeImageAttributeRequest,
  output: ImageAttribute,
  errors: [RequestLimitExceeded, InvalidAMIIDMalformed, MissingParameter],
}));
export type DescribeImageReferencesError =
  | RequestLimitExceeded
  | InvalidAMIIDMalformed
  | CommonErrors;
/**
 * Describes your Amazon Web Services resources that are referencing the specified images.
 *
 * For more information, see Identify your resources referencing
 * specified AMIs in the *Amazon EC2 User Guide*.
 */
export const describeImageReferences: API.OperationMethod<
  DescribeImageReferencesRequest,
  DescribeImageReferencesResult,
  DescribeImageReferencesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeImageReferencesRequest,
  ) => stream.Stream<
    DescribeImageReferencesResult,
    DescribeImageReferencesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeImageReferencesRequest,
  ) => stream.Stream<
    ImageReference,
    DescribeImageReferencesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeImageReferencesRequest,
  output: DescribeImageReferencesResult,
  errors: [RequestLimitExceeded, InvalidAMIIDMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ImageReferences",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeImagesError =
  | RequestLimitExceeded
  | InvalidAMIIDMalformed
  | InvalidAMIIDNotFound
  | CommonErrors;
/**
 * Describes the specified images (AMIs, AKIs, and ARIs) available to you or all of the
 * images available to you.
 *
 * The images available to you include public images, private images that you own, and
 * private images owned by other Amazon Web Services accounts for which you have explicit launch
 * permissions.
 *
 * Recently deregistered images appear in the returned results for a short interval and then
 * return empty results. After all instances that reference a deregistered AMI are terminated,
 * specifying the ID of the image will eventually return an error indicating that the AMI ID
 * cannot be found.
 *
 * When Allowed AMIs is set to `enabled`, only allowed images are returned in the
 * results, with the `imageAllowed` field set to `true` for each image. In
 * `audit-mode`, the `imageAllowed` field is set to `true` for
 * images that meet the account's Allowed AMIs criteria, and `false` for images that
 * don't meet the criteria. For more information, see Allowed AMIs.
 *
 * The Amazon EC2 API follows an eventual consistency model. This means that the result of an API
 * command you run that creates or modifies resources might not be immediately available to all
 * subsequent commands you run. For guidance on how to manage eventual consistency, see Eventual
 * consistency in the Amazon EC2 API in the Amazon EC2 Developer
 * Guide.
 *
 * We strongly recommend using only paginated requests. Unpaginated requests are
 * susceptible to throttling and timeouts.
 *
 * The order of the elements in the response, including those within nested structures,
 * might vary. Applications should not assume the elements appear in a particular order.
 */
export const describeImages: API.OperationMethod<
  DescribeImagesRequest,
  DescribeImagesResult,
  DescribeImagesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeImagesRequest,
  ) => stream.Stream<
    DescribeImagesResult,
    DescribeImagesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeImagesRequest,
  ) => stream.Stream<
    Image,
    DescribeImagesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeImagesRequest,
  output: DescribeImagesResult,
  errors: [RequestLimitExceeded, InvalidAMIIDMalformed, InvalidAMIIDNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Images",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeImageUsageReportEntriesError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Describes the entries in image usage reports, showing how your images are used across
 * other Amazon Web Services accounts.
 *
 * For more information, see View your AMI usage in the
 * *Amazon EC2 User Guide*.
 */
export const describeImageUsageReportEntries: API.OperationMethod<
  DescribeImageUsageReportEntriesRequest,
  DescribeImageUsageReportEntriesResult,
  DescribeImageUsageReportEntriesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeImageUsageReportEntriesRequest,
  ) => stream.Stream<
    DescribeImageUsageReportEntriesResult,
    DescribeImageUsageReportEntriesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeImageUsageReportEntriesRequest,
  ) => stream.Stream<
    ImageUsageReportEntry,
    DescribeImageUsageReportEntriesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeImageUsageReportEntriesRequest,
  output: DescribeImageUsageReportEntriesResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ImageUsageReportEntries",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeImageUsageReportsError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Describes the configuration and status of image usage reports, filtered by report IDs or
 * image IDs.
 *
 * For more information, see View your AMI usage in the
 * *Amazon EC2 User Guide*.
 */
export const describeImageUsageReports: API.OperationMethod<
  DescribeImageUsageReportsRequest,
  DescribeImageUsageReportsResult,
  DescribeImageUsageReportsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeImageUsageReportsRequest,
  ) => stream.Stream<
    DescribeImageUsageReportsResult,
    DescribeImageUsageReportsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeImageUsageReportsRequest,
  ) => stream.Stream<
    ImageUsageReport,
    DescribeImageUsageReportsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeImageUsageReportsRequest,
  output: DescribeImageUsageReportsResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ImageUsageReports",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeImportImageTasksError =
  | RequestLimitExceeded
  | InvalidParameter
  | CommonErrors;
/**
 * Displays details about an import virtual machine or import snapshot tasks that are already created.
 */
export const describeImportImageTasks: API.OperationMethod<
  DescribeImportImageTasksRequest,
  DescribeImportImageTasksResult,
  DescribeImportImageTasksError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeImportImageTasksRequest,
  ) => stream.Stream<
    DescribeImportImageTasksResult,
    DescribeImportImageTasksError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeImportImageTasksRequest,
  ) => stream.Stream<
    ImportImageTask,
    DescribeImportImageTasksError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeImportImageTasksRequest,
  output: DescribeImportImageTasksResult,
  errors: [RequestLimitExceeded, InvalidParameter],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ImportImageTasks",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeImportSnapshotTasksError =
  | RequestLimitExceeded
  | InvalidParameter
  | CommonErrors;
/**
 * Describes your import snapshot tasks.
 */
export const describeImportSnapshotTasks: API.OperationMethod<
  DescribeImportSnapshotTasksRequest,
  DescribeImportSnapshotTasksResult,
  DescribeImportSnapshotTasksError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeImportSnapshotTasksRequest,
  ) => stream.Stream<
    DescribeImportSnapshotTasksResult,
    DescribeImportSnapshotTasksError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeImportSnapshotTasksRequest,
  ) => stream.Stream<
    ImportSnapshotTask,
    DescribeImportSnapshotTasksError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeImportSnapshotTasksRequest,
  output: DescribeImportSnapshotTasksResult,
  errors: [RequestLimitExceeded, InvalidParameter],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ImportSnapshotTasks",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeInstanceAttributeError =
  | RequestLimitExceeded
  | InvalidInstanceIDNotFound
  | InvalidParameterValue
  | CommonErrors;
/**
 * Describes the specified attribute of the specified instance. You can specify only one
 * attribute at a time. Available attributes include SQL license exemption configuration
 * for instances registered with the SQL LE service.
 */
export const describeInstanceAttribute: API.OperationMethod<
  DescribeInstanceAttributeRequest,
  InstanceAttribute,
  DescribeInstanceAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeInstanceAttributeRequest,
  output: InstanceAttribute,
  errors: [
    RequestLimitExceeded,
    InvalidInstanceIDNotFound,
    InvalidParameterValue,
  ],
}));
export type DescribeInstanceConnectEndpointsError =
  | RequestLimitExceeded
  | InvalidInstanceConnectEndpointIdNotFound
  | CommonErrors;
/**
 * Describes the specified EC2 Instance Connect Endpoints or all EC2 Instance Connect Endpoints.
 */
export const describeInstanceConnectEndpoints: API.OperationMethod<
  DescribeInstanceConnectEndpointsRequest,
  DescribeInstanceConnectEndpointsResult,
  DescribeInstanceConnectEndpointsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeInstanceConnectEndpointsRequest,
  ) => stream.Stream<
    DescribeInstanceConnectEndpointsResult,
    DescribeInstanceConnectEndpointsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeInstanceConnectEndpointsRequest,
  ) => stream.Stream<
    Ec2InstanceConnectEndpoint,
    DescribeInstanceConnectEndpointsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeInstanceConnectEndpointsRequest,
  output: DescribeInstanceConnectEndpointsResult,
  errors: [RequestLimitExceeded, InvalidInstanceConnectEndpointIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "InstanceConnectEndpoints",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeInstanceCreditSpecificationsError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | CommonErrors;
/**
 * Describes the credit option for CPU usage of the specified burstable performance
 * instances. The credit options are `standard` and
 * `unlimited`.
 *
 * If you do not specify an instance ID, Amazon EC2 returns burstable performance
 * instances with the `unlimited` credit option, as well as instances that were
 * previously configured as T2, T3, and T3a with the `unlimited` credit option.
 * For example, if you resize a T2 instance, while it is configured as
 * `unlimited`, to an M4 instance, Amazon EC2 returns the M4
 * instance.
 *
 * If you specify one or more instance IDs, Amazon EC2 returns the credit option
 * (`standard` or `unlimited`) of those instances. If you specify
 * an instance ID that is not valid, such as an instance that is not a burstable
 * performance instance, an error is returned.
 *
 * Recently terminated instances might appear in the returned results. This interval is
 * usually less than one hour.
 *
 * If an Availability Zone is experiencing a service disruption and you specify instance
 * IDs in the affected zone, or do not specify any instance IDs at all, the call fails. If
 * you specify only instance IDs in an unaffected zone, the call works normally.
 *
 * For more information, see Burstable
 * performance instances in the *Amazon EC2 User Guide*.
 */
export const describeInstanceCreditSpecifications: API.OperationMethod<
  DescribeInstanceCreditSpecificationsRequest,
  DescribeInstanceCreditSpecificationsResult,
  DescribeInstanceCreditSpecificationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeInstanceCreditSpecificationsRequest,
  ) => stream.Stream<
    DescribeInstanceCreditSpecificationsResult,
    DescribeInstanceCreditSpecificationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeInstanceCreditSpecificationsRequest,
  ) => stream.Stream<
    InstanceCreditSpecification,
    DescribeInstanceCreditSpecificationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeInstanceCreditSpecificationsRequest,
  output: DescribeInstanceCreditSpecificationsResult,
  errors: [RequestLimitExceeded, InvalidInstanceIDMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "InstanceCreditSpecifications",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeInstanceEventNotificationAttributesError = CommonErrors;
/**
 * Describes the tag keys that are registered to appear in scheduled event notifications
 * for resources in the current Region.
 */
export const describeInstanceEventNotificationAttributes: API.OperationMethod<
  DescribeInstanceEventNotificationAttributesRequest,
  DescribeInstanceEventNotificationAttributesResult,
  DescribeInstanceEventNotificationAttributesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeInstanceEventNotificationAttributesRequest,
  output: DescribeInstanceEventNotificationAttributesResult,
  errors: [],
}));
export type DescribeInstanceEventWindowsError =
  | RequestLimitExceeded
  | InvalidInstanceEventWindowIDNotFound
  | CommonErrors;
/**
 * Describes the specified event windows or all event windows.
 *
 * If you specify event window IDs, the output includes information for only the specified
 * event windows. If you specify filters, the output includes information for only those event
 * windows that meet the filter criteria. If you do not specify event windows IDs or filters,
 * the output includes information for all event windows, which can affect performance. We
 * recommend that you use pagination to ensure that the operation returns quickly and
 * successfully.
 *
 * For more information, see Define event windows for scheduled
 * events in the *Amazon EC2 User Guide*.
 */
export const describeInstanceEventWindows: API.OperationMethod<
  DescribeInstanceEventWindowsRequest,
  DescribeInstanceEventWindowsResult,
  DescribeInstanceEventWindowsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeInstanceEventWindowsRequest,
  ) => stream.Stream<
    DescribeInstanceEventWindowsResult,
    DescribeInstanceEventWindowsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeInstanceEventWindowsRequest,
  ) => stream.Stream<
    InstanceEventWindow,
    DescribeInstanceEventWindowsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeInstanceEventWindowsRequest,
  output: DescribeInstanceEventWindowsResult,
  errors: [RequestLimitExceeded, InvalidInstanceEventWindowIDNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "InstanceEventWindows",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeInstanceImageMetadataError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | CommonErrors;
/**
 * Describes the AMI that was used to launch an instance, even if the AMI is deprecated,
 * deregistered, made private (no longer public or shared with your account), or not
 * allowed.
 *
 * If you specify instance IDs, the output includes information for only the specified
 * instances. If you specify filters, the output includes information for only those instances
 * that meet the filter criteria. If you do not specify instance IDs or filters, the output
 * includes information for all instances, which can affect performance.
 *
 * If you specify an instance ID that is not valid, an instance that doesn't exist, or an
 * instance that you do not own, an error (`InvalidInstanceID.NotFound`) is
 * returned.
 *
 * Recently terminated instances might appear in the returned results. This interval is
 * usually less than one hour.
 *
 * In the rare case where an Availability Zone is experiencing a service disruption and you
 * specify instance IDs that are in the affected Availability Zone, or do not specify any
 * instance IDs at all, the call fails. If you specify only instance IDs that are in an
 * unaffected Availability Zone, the call works normally.
 *
 * The order of the elements in the response, including those within nested structures,
 * might vary. Applications should not assume the elements appear in a particular order.
 */
export const describeInstanceImageMetadata: API.OperationMethod<
  DescribeInstanceImageMetadataRequest,
  DescribeInstanceImageMetadataResult,
  DescribeInstanceImageMetadataError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeInstanceImageMetadataRequest,
  ) => stream.Stream<
    DescribeInstanceImageMetadataResult,
    DescribeInstanceImageMetadataError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeInstanceImageMetadataRequest,
  ) => stream.Stream<
    InstanceImageMetadata,
    DescribeInstanceImageMetadataError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeInstanceImageMetadataRequest,
  output: DescribeInstanceImageMetadataResult,
  errors: [RequestLimitExceeded, InvalidInstanceIDMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "InstanceImageMetadata",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeInstancesError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | InvalidInstanceIDNotFound
  | ParseError
  | CommonErrors;
/**
 * Describes the specified instances or all instances.
 *
 * If you specify instance IDs, the output includes information for only the specified
 * instances. If you specify filters, the output includes information for only those
 * instances that meet the filter criteria. If you do not specify instance IDs or filters,
 * the output includes information for all instances, which can affect performance. We
 * recommend that you use pagination to ensure that the operation returns quickly and
 * successfully.
 *
 * The response includes SQL license exemption status information for instances registered
 * with the SQL LE service, providing visibility into license exemption configuration and status.
 *
 * If you specify an instance ID that is not valid, an error is returned. If you specify
 * an instance that you do not own, it is not included in the output.
 *
 * Recently terminated instances might appear in the returned results. This interval is
 * usually less than one hour.
 *
 * If you describe instances in the rare case where an Availability Zone is experiencing
 * a service disruption and you specify instance IDs that are in the affected zone, or do
 * not specify any instance IDs at all, the call fails. If you describe instances and
 * specify only instance IDs that are in an unaffected zone, the call works
 * normally.
 *
 * The Amazon EC2 API follows an eventual consistency model. This means that the result of an
 * API command you run that creates or modifies resources might not be immediately
 * available to all subsequent commands you run. For guidance on how to manage eventual
 * consistency, see Eventual consistency in the
 * Amazon EC2 API in the Amazon EC2 Developer
 * Guide.
 *
 * We strongly recommend using only paginated requests. Unpaginated requests are
 * susceptible to throttling and timeouts.
 *
 * The order of the elements in the response, including those within nested
 * structures, might vary. Applications should not assume the elements appear in a
 * particular order.
 */
export const describeInstances: API.OperationMethod<
  DescribeInstancesRequest,
  DescribeInstancesResult,
  DescribeInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeInstancesRequest,
  ) => stream.Stream<
    DescribeInstancesResult,
    DescribeInstancesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeInstancesRequest,
  ) => stream.Stream<
    Reservation,
    DescribeInstancesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeInstancesRequest,
  output: DescribeInstancesResult,
  errors: [
    RequestLimitExceeded,
    InvalidInstanceIDMalformed,
    InvalidInstanceIDNotFound,
    ParseError,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Reservations",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeInstanceSqlHaHistoryStatesError =
  | RequestLimitExceeded
  | InvalidInstanceIDNotFound
  | CommonErrors;
/**
 * Describes the historical SQL Server High Availability states for Amazon EC2
 * instances that are enabled for Amazon EC2 High Availability for SQL Server monitoring.
 */
export const describeInstanceSqlHaHistoryStates: API.OperationMethod<
  DescribeInstanceSqlHaHistoryStatesRequest,
  DescribeInstanceSqlHaHistoryStatesResult,
  DescribeInstanceSqlHaHistoryStatesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeInstanceSqlHaHistoryStatesRequest,
  output: DescribeInstanceSqlHaHistoryStatesResult,
  errors: [RequestLimitExceeded, InvalidInstanceIDNotFound],
}));
export type DescribeInstanceSqlHaStatesError =
  | RequestLimitExceeded
  | InvalidInstanceIDNotFound
  | CommonErrors;
/**
 * Describes the SQL Server High Availability states for Amazon EC2 instances that are
 * enabled for Amazon EC2 High Availability for SQL Server monitoring.
 */
export const describeInstanceSqlHaStates: API.OperationMethod<
  DescribeInstanceSqlHaStatesRequest,
  DescribeInstanceSqlHaStatesResult,
  DescribeInstanceSqlHaStatesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeInstanceSqlHaStatesRequest,
  output: DescribeInstanceSqlHaStatesResult,
  errors: [RequestLimitExceeded, InvalidInstanceIDNotFound],
}));
export type DescribeInstanceStatusError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | InvalidInstanceIDNotFound
  | CommonErrors;
/**
 * Describes the status of the specified instances or all of your instances. By default,
 * only running instances are described, unless you specifically indicate to return the
 * status of all instances.
 *
 * Instance status includes the following components:
 *
 * - **Status checks** - Amazon EC2 performs status
 * checks on running EC2 instances to identify hardware and software issues. For
 * more information, see Status checks for your instances and Troubleshoot
 * instances with failed status checks in the Amazon EC2 User
 * Guide.
 *
 * - **Scheduled events** - Amazon EC2 can schedule
 * events (such as reboot, stop, or terminate) for your instances related to
 * hardware issues, software updates, or system maintenance. For more information,
 * see Scheduled events for your instances in the Amazon EC2 User
 * Guide.
 *
 * - **Instance state** - You can manage your instances
 * from the moment you launch them through their termination. For more information,
 * see Instance
 * lifecycle in the *Amazon EC2 User Guide*.
 *
 * The Amazon EC2 API follows an eventual consistency model. This means that the result of an
 * API command you run that creates or modifies resources might not be immediately
 * available to all subsequent commands you run. For guidance on how to manage eventual
 * consistency, see Eventual consistency in the
 * Amazon EC2 API in the Amazon EC2 Developer
 * Guide.
 *
 * The order of the elements in the response, including those within nested
 * structures, might vary. Applications should not assume the elements appear in a
 * particular order.
 */
export const describeInstanceStatus: API.OperationMethod<
  DescribeInstanceStatusRequest,
  DescribeInstanceStatusResult,
  DescribeInstanceStatusError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeInstanceStatusRequest,
  ) => stream.Stream<
    DescribeInstanceStatusResult,
    DescribeInstanceStatusError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeInstanceStatusRequest,
  ) => stream.Stream<
    InstanceStatus,
    DescribeInstanceStatusError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeInstanceStatusRequest,
  output: DescribeInstanceStatusResult,
  errors: [
    RequestLimitExceeded,
    InvalidInstanceIDMalformed,
    InvalidInstanceIDNotFound,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "InstanceStatuses",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeInstanceTopologyError = CommonErrors;
/**
 * Describes a tree-based hierarchy that represents the physical host placement of your
 * EC2 instances within an Availability Zone or Local Zone. You can use this information to
 * determine the relative proximity of your EC2 instances within the Amazon Web Services network to
 * support your tightly coupled workloads.
 *
 * Instance topology is supported for specific instance types only. For more information,
 * see Prerequisites
 * for Amazon EC2 instance topology in the
 * *Amazon EC2 User Guide*.
 *
 * The Amazon EC2 API follows an eventual consistency model due to the
 * distributed nature of the system supporting it. As a result, when you call the
 * DescribeInstanceTopology API command immediately after launching instances, the
 * response might return a `null` value for `capacityBlockId`
 * because the data might not have fully propagated across all subsystems. For more
 * information, see Eventual consistency in the
 * Amazon EC2 API in the Amazon EC2 Developer
 * Guide.
 *
 * For more information, see Amazon EC2 topology in
 * the *Amazon EC2 User Guide*.
 */
export const describeInstanceTopology: API.OperationMethod<
  DescribeInstanceTopologyRequest,
  DescribeInstanceTopologyResult,
  DescribeInstanceTopologyError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeInstanceTopologyRequest,
  ) => stream.Stream<
    DescribeInstanceTopologyResult,
    DescribeInstanceTopologyError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeInstanceTopologyRequest,
  ) => stream.Stream<
    InstanceTopology,
    DescribeInstanceTopologyError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeInstanceTopologyRequest,
  output: DescribeInstanceTopologyResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Instances",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeInstanceTypeOfferingsError = CommonErrors;
/**
 * Lists the instance types that are offered for the specified location. If no location is
 * specified, the default is to list the instance types that are offered in the current
 * Region.
 */
export const describeInstanceTypeOfferings: API.OperationMethod<
  DescribeInstanceTypeOfferingsRequest,
  DescribeInstanceTypeOfferingsResult,
  DescribeInstanceTypeOfferingsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeInstanceTypeOfferingsRequest,
  ) => stream.Stream<
    DescribeInstanceTypeOfferingsResult,
    DescribeInstanceTypeOfferingsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeInstanceTypeOfferingsRequest,
  ) => stream.Stream<
    InstanceTypeOffering,
    DescribeInstanceTypeOfferingsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeInstanceTypeOfferingsRequest,
  output: DescribeInstanceTypeOfferingsResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "InstanceTypeOfferings",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeInstanceTypesError = CommonErrors;
/**
 * Describes the specified instance types. By default, all instance types for the current
 * Region are described. Alternatively, you can filter the results.
 */
export const describeInstanceTypes: API.OperationMethod<
  DescribeInstanceTypesRequest,
  DescribeInstanceTypesResult,
  DescribeInstanceTypesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeInstanceTypesRequest,
  ) => stream.Stream<
    DescribeInstanceTypesResult,
    DescribeInstanceTypesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeInstanceTypesRequest,
  ) => stream.Stream<
    InstanceTypeInfo,
    DescribeInstanceTypesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeInstanceTypesRequest,
  output: DescribeInstanceTypesResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "InstanceTypes",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeInternetGatewaysError =
  | RequestLimitExceeded
  | InvalidInternetGatewayIDNotFound
  | ParseError
  | CommonErrors;
/**
 * Describes your internet gateways. The default is to describe all your internet gateways.
 * Alternatively, you can specify specific internet gateway IDs or filter the results to
 * include only the internet gateways that match specific criteria.
 */
export const describeInternetGateways: API.OperationMethod<
  DescribeInternetGatewaysRequest,
  DescribeInternetGatewaysResult,
  DescribeInternetGatewaysError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeInternetGatewaysRequest,
  ) => stream.Stream<
    DescribeInternetGatewaysResult,
    DescribeInternetGatewaysError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeInternetGatewaysRequest,
  ) => stream.Stream<
    InternetGateway,
    DescribeInternetGatewaysError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeInternetGatewaysRequest,
  output: DescribeInternetGatewaysResult,
  errors: [RequestLimitExceeded, InvalidInternetGatewayIDNotFound, ParseError],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "InternetGateways",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeIpamByoasnError = CommonErrors;
/**
 * Describes your Autonomous System Numbers (ASNs), their provisioning statuses, and the BYOIP CIDRs with which they are associated. For more information, see Tutorial: Bring your ASN to IPAM in the *Amazon VPC IPAM guide*.
 */
export const describeIpamByoasn: API.OperationMethod<
  DescribeIpamByoasnRequest,
  DescribeIpamByoasnResult,
  DescribeIpamByoasnError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeIpamByoasnRequest,
  output: DescribeIpamByoasnResult,
  errors: [],
}));
export type DescribeIpamExternalResourceVerificationTokensError =
  | RequestLimitExceeded
  | InvalidIpamExternalResourceVerificationTokenIdNotFound
  | CommonErrors;
/**
 * Describe verification tokens.
 *
 * A verification token is an Amazon Web Services-generated random value that you can use to prove ownership of an external resource. For example, you can use a verification token to validate that you control a public IP address range when you bring an IP address range to Amazon Web Services (BYOIP).
 */
export const describeIpamExternalResourceVerificationTokens: API.OperationMethod<
  DescribeIpamExternalResourceVerificationTokensRequest,
  DescribeIpamExternalResourceVerificationTokensResult,
  DescribeIpamExternalResourceVerificationTokensError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeIpamExternalResourceVerificationTokensRequest,
  output: DescribeIpamExternalResourceVerificationTokensResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamExternalResourceVerificationTokenIdNotFound,
  ],
}));
export type DescribeIpamPoliciesError =
  | RequestLimitExceeded
  | InvalidIpamPolicyIdNotFound
  | CommonErrors;
/**
 * Describes one or more IPAM policies.
 *
 * An IPAM policy is a set of rules that define how public IPv4 addresses from IPAM pools are allocated to Amazon Web Services resources. Each rule maps an Amazon Web Services service to IPAM pools that the service will use to get IP addresses. A single policy can have multiple rules and be applied to multiple Amazon Web Services Regions. If the IPAM pool run out of addresses then the services fallback to Amazon-provided IP addresses. A policy can be applied to an individual Amazon Web Services account or an entity within Amazon Web Services Organizations.
 */
export const describeIpamPolicies: API.OperationMethod<
  DescribeIpamPoliciesRequest,
  DescribeIpamPoliciesResult,
  DescribeIpamPoliciesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeIpamPoliciesRequest,
  output: DescribeIpamPoliciesResult,
  errors: [RequestLimitExceeded, InvalidIpamPolicyIdNotFound],
}));
export type DescribeIpamPoolsError =
  | RequestLimitExceeded
  | InvalidIpamPoolIdNotFound
  | CommonErrors;
/**
 * Get information about your IPAM pools.
 */
export const describeIpamPools: API.OperationMethod<
  DescribeIpamPoolsRequest,
  DescribeIpamPoolsResult,
  DescribeIpamPoolsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeIpamPoolsRequest,
  ) => stream.Stream<
    DescribeIpamPoolsResult,
    DescribeIpamPoolsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeIpamPoolsRequest,
  ) => stream.Stream<
    IpamPool,
    DescribeIpamPoolsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeIpamPoolsRequest,
  output: DescribeIpamPoolsResult,
  errors: [RequestLimitExceeded, InvalidIpamPoolIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "IpamPools",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeIpamPrefixListResolversError =
  | RequestLimitExceeded
  | InvalidIpamPrefixListResolverIdNotFound
  | CommonErrors;
/**
 * Describes one or more IPAM prefix list resolvers. Use this operation to view the configuration, status, and properties of your resolvers.
 */
export const describeIpamPrefixListResolvers: API.OperationMethod<
  DescribeIpamPrefixListResolversRequest,
  DescribeIpamPrefixListResolversResult,
  DescribeIpamPrefixListResolversError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeIpamPrefixListResolversRequest,
  ) => stream.Stream<
    DescribeIpamPrefixListResolversResult,
    DescribeIpamPrefixListResolversError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeIpamPrefixListResolversRequest,
  ) => stream.Stream<
    IpamPrefixListResolver,
    DescribeIpamPrefixListResolversError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeIpamPrefixListResolversRequest,
  output: DescribeIpamPrefixListResolversResult,
  errors: [RequestLimitExceeded, InvalidIpamPrefixListResolverIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "IpamPrefixListResolvers",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeIpamPrefixListResolverTargetsError =
  | RequestLimitExceeded
  | InvalidIpamPrefixListResolverTargetIdMalformed
  | CommonErrors;
/**
 * Describes one or more IPAM prefix list resolver Targets. Use this operation to view the configuration and status of resolver targets.
 */
export const describeIpamPrefixListResolverTargets: API.OperationMethod<
  DescribeIpamPrefixListResolverTargetsRequest,
  DescribeIpamPrefixListResolverTargetsResult,
  DescribeIpamPrefixListResolverTargetsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeIpamPrefixListResolverTargetsRequest,
  ) => stream.Stream<
    DescribeIpamPrefixListResolverTargetsResult,
    DescribeIpamPrefixListResolverTargetsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeIpamPrefixListResolverTargetsRequest,
  ) => stream.Stream<
    IpamPrefixListResolverTarget,
    DescribeIpamPrefixListResolverTargetsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeIpamPrefixListResolverTargetsRequest,
  output: DescribeIpamPrefixListResolverTargetsResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamPrefixListResolverTargetIdMalformed,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "IpamPrefixListResolverTargets",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeIpamResourceDiscoveriesError =
  | RequestLimitExceeded
  | InvalidIpamResourceDiscoveryIdNotFound
  | CommonErrors;
/**
 * Describes IPAM resource discoveries. A resource discovery is an IPAM component that enables IPAM to manage and monitor resources that belong to the owning account.
 */
export const describeIpamResourceDiscoveries: API.OperationMethod<
  DescribeIpamResourceDiscoveriesRequest,
  DescribeIpamResourceDiscoveriesResult,
  DescribeIpamResourceDiscoveriesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeIpamResourceDiscoveriesRequest,
  ) => stream.Stream<
    DescribeIpamResourceDiscoveriesResult,
    DescribeIpamResourceDiscoveriesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeIpamResourceDiscoveriesRequest,
  ) => stream.Stream<
    IpamResourceDiscovery,
    DescribeIpamResourceDiscoveriesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeIpamResourceDiscoveriesRequest,
  output: DescribeIpamResourceDiscoveriesResult,
  errors: [RequestLimitExceeded, InvalidIpamResourceDiscoveryIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "IpamResourceDiscoveries",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeIpamResourceDiscoveryAssociationsError =
  | RequestLimitExceeded
  | InvalidIpamResourceDiscoveryAssociationIdNotFound
  | CommonErrors;
/**
 * Describes resource discovery association with an Amazon VPC IPAM. An associated resource discovery is a resource discovery that has been associated with an IPAM..
 */
export const describeIpamResourceDiscoveryAssociations: API.OperationMethod<
  DescribeIpamResourceDiscoveryAssociationsRequest,
  DescribeIpamResourceDiscoveryAssociationsResult,
  DescribeIpamResourceDiscoveryAssociationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeIpamResourceDiscoveryAssociationsRequest,
  ) => stream.Stream<
    DescribeIpamResourceDiscoveryAssociationsResult,
    DescribeIpamResourceDiscoveryAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeIpamResourceDiscoveryAssociationsRequest,
  ) => stream.Stream<
    IpamResourceDiscoveryAssociation,
    DescribeIpamResourceDiscoveryAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeIpamResourceDiscoveryAssociationsRequest,
  output: DescribeIpamResourceDiscoveryAssociationsResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamResourceDiscoveryAssociationIdNotFound,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "IpamResourceDiscoveryAssociations",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeIpamsError =
  | RequestLimitExceeded
  | InvalidIpamIdNotFound
  | CommonErrors;
/**
 * Get information about your IPAM pools.
 *
 * For more information, see What is IPAM? in the *Amazon VPC IPAM User Guide*.
 */
export const describeIpams: API.OperationMethod<
  DescribeIpamsRequest,
  DescribeIpamsResult,
  DescribeIpamsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeIpamsRequest,
  ) => stream.Stream<
    DescribeIpamsResult,
    DescribeIpamsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeIpamsRequest,
  ) => stream.Stream<
    Ipam,
    DescribeIpamsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeIpamsRequest,
  output: DescribeIpamsResult,
  errors: [RequestLimitExceeded, InvalidIpamIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Ipams",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeIpamScopesError =
  | RequestLimitExceeded
  | InvalidIpamScopeIdNotFound
  | CommonErrors;
/**
 * Get information about your IPAM scopes.
 */
export const describeIpamScopes: API.OperationMethod<
  DescribeIpamScopesRequest,
  DescribeIpamScopesResult,
  DescribeIpamScopesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeIpamScopesRequest,
  ) => stream.Stream<
    DescribeIpamScopesResult,
    DescribeIpamScopesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeIpamScopesRequest,
  ) => stream.Stream<
    IpamScope,
    DescribeIpamScopesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeIpamScopesRequest,
  output: DescribeIpamScopesResult,
  errors: [RequestLimitExceeded, InvalidIpamScopeIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "IpamScopes",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeIpv6PoolsError =
  | RequestLimitExceeded
  | InvalidIpv6PoolIDNotFound
  | CommonErrors;
/**
 * Describes your IPv6 address pools.
 */
export const describeIpv6Pools: API.OperationMethod<
  DescribeIpv6PoolsRequest,
  DescribeIpv6PoolsResult,
  DescribeIpv6PoolsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeIpv6PoolsRequest,
  ) => stream.Stream<
    DescribeIpv6PoolsResult,
    DescribeIpv6PoolsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeIpv6PoolsRequest,
  ) => stream.Stream<
    Ipv6Pool,
    DescribeIpv6PoolsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeIpv6PoolsRequest,
  output: DescribeIpv6PoolsResult,
  errors: [RequestLimitExceeded, InvalidIpv6PoolIDNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Ipv6Pools",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeKeyPairsError =
  | RequestLimitExceeded
  | InvalidKeyPairNotFound
  | InvalidParameterValue
  | CommonErrors;
/**
 * Describes the specified key pairs or all of your key pairs.
 *
 * For more information about key pairs, see Amazon EC2 key pairs
 * in the *Amazon EC2 User Guide*.
 */
export const describeKeyPairs: API.OperationMethod<
  DescribeKeyPairsRequest,
  DescribeKeyPairsResult,
  DescribeKeyPairsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeKeyPairsRequest,
  output: DescribeKeyPairsResult,
  errors: [RequestLimitExceeded, InvalidKeyPairNotFound, InvalidParameterValue],
}));
export type DescribeLaunchTemplatesError =
  | RequestLimitExceeded
  | InvalidLaunchTemplateIdMalformed
  | ParseError
  | CommonErrors;
/**
 * Describes one or more launch templates.
 */
export const describeLaunchTemplates: API.OperationMethod<
  DescribeLaunchTemplatesRequest,
  DescribeLaunchTemplatesResult,
  DescribeLaunchTemplatesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeLaunchTemplatesRequest,
  ) => stream.Stream<
    DescribeLaunchTemplatesResult,
    DescribeLaunchTemplatesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeLaunchTemplatesRequest,
  ) => stream.Stream<
    LaunchTemplate,
    DescribeLaunchTemplatesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeLaunchTemplatesRequest,
  output: DescribeLaunchTemplatesResult,
  errors: [RequestLimitExceeded, InvalidLaunchTemplateIdMalformed, ParseError],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "LaunchTemplates",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeLaunchTemplateVersionsError =
  | RequestLimitExceeded
  | InvalidLaunchTemplateIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Describes one or more versions of a specified launch template. You can describe all
 * versions, individual versions, or a range of versions. You can also describe all the
 * latest versions or all the default versions of all the launch templates in your
 * account.
 */
export const describeLaunchTemplateVersions: API.OperationMethod<
  DescribeLaunchTemplateVersionsRequest,
  DescribeLaunchTemplateVersionsResult,
  DescribeLaunchTemplateVersionsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeLaunchTemplateVersionsRequest,
  ) => stream.Stream<
    DescribeLaunchTemplateVersionsResult,
    DescribeLaunchTemplateVersionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeLaunchTemplateVersionsRequest,
  ) => stream.Stream<
    LaunchTemplateVersion,
    DescribeLaunchTemplateVersionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeLaunchTemplateVersionsRequest,
  output: DescribeLaunchTemplateVersionsResult,
  errors: [
    RequestLimitExceeded,
    InvalidLaunchTemplateIdMalformed,
    MissingParameter,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "LaunchTemplateVersions",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeLocalGatewayRouteTablesError = CommonErrors;
/**
 * Describes one or more local gateway route tables. By default, all local gateway route tables are described.
 * Alternatively, you can filter the results.
 */
export const describeLocalGatewayRouteTables: API.OperationMethod<
  DescribeLocalGatewayRouteTablesRequest,
  DescribeLocalGatewayRouteTablesResult,
  DescribeLocalGatewayRouteTablesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeLocalGatewayRouteTablesRequest,
  ) => stream.Stream<
    DescribeLocalGatewayRouteTablesResult,
    DescribeLocalGatewayRouteTablesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeLocalGatewayRouteTablesRequest,
  ) => stream.Stream<
    LocalGatewayRouteTable,
    DescribeLocalGatewayRouteTablesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeLocalGatewayRouteTablesRequest,
  output: DescribeLocalGatewayRouteTablesResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "LocalGatewayRouteTables",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsError =
  CommonErrors;
/**
 * Describes the associations between virtual interface groups and local gateway route tables.
 */
export const describeLocalGatewayRouteTableVirtualInterfaceGroupAssociations: API.OperationMethod<
  DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest,
  DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult,
  DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest,
  ) => stream.Stream<
    DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult,
    DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest,
  ) => stream.Stream<
    LocalGatewayRouteTableVirtualInterfaceGroupAssociation,
    DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest,
  output: DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "LocalGatewayRouteTableVirtualInterfaceGroupAssociations",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeLocalGatewayRouteTableVpcAssociationsError = CommonErrors;
/**
 * Describes the specified associations between VPCs and local gateway route tables.
 */
export const describeLocalGatewayRouteTableVpcAssociations: API.OperationMethod<
  DescribeLocalGatewayRouteTableVpcAssociationsRequest,
  DescribeLocalGatewayRouteTableVpcAssociationsResult,
  DescribeLocalGatewayRouteTableVpcAssociationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeLocalGatewayRouteTableVpcAssociationsRequest,
  ) => stream.Stream<
    DescribeLocalGatewayRouteTableVpcAssociationsResult,
    DescribeLocalGatewayRouteTableVpcAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeLocalGatewayRouteTableVpcAssociationsRequest,
  ) => stream.Stream<
    LocalGatewayRouteTableVpcAssociation,
    DescribeLocalGatewayRouteTableVpcAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeLocalGatewayRouteTableVpcAssociationsRequest,
  output: DescribeLocalGatewayRouteTableVpcAssociationsResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "LocalGatewayRouteTableVpcAssociations",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeLocalGatewaysError = CommonErrors;
/**
 * Describes one or more local gateways. By default, all local gateways are described.
 * Alternatively, you can filter the results.
 */
export const describeLocalGateways: API.OperationMethod<
  DescribeLocalGatewaysRequest,
  DescribeLocalGatewaysResult,
  DescribeLocalGatewaysError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeLocalGatewaysRequest,
  ) => stream.Stream<
    DescribeLocalGatewaysResult,
    DescribeLocalGatewaysError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeLocalGatewaysRequest,
  ) => stream.Stream<
    LocalGateway,
    DescribeLocalGatewaysError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeLocalGatewaysRequest,
  output: DescribeLocalGatewaysResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "LocalGateways",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeLocalGatewayVirtualInterfaceGroupsError = CommonErrors;
/**
 * Describes the specified local gateway virtual interface groups.
 */
export const describeLocalGatewayVirtualInterfaceGroups: API.OperationMethod<
  DescribeLocalGatewayVirtualInterfaceGroupsRequest,
  DescribeLocalGatewayVirtualInterfaceGroupsResult,
  DescribeLocalGatewayVirtualInterfaceGroupsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeLocalGatewayVirtualInterfaceGroupsRequest,
  ) => stream.Stream<
    DescribeLocalGatewayVirtualInterfaceGroupsResult,
    DescribeLocalGatewayVirtualInterfaceGroupsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeLocalGatewayVirtualInterfaceGroupsRequest,
  ) => stream.Stream<
    LocalGatewayVirtualInterfaceGroup,
    DescribeLocalGatewayVirtualInterfaceGroupsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeLocalGatewayVirtualInterfaceGroupsRequest,
  output: DescribeLocalGatewayVirtualInterfaceGroupsResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "LocalGatewayVirtualInterfaceGroups",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeLocalGatewayVirtualInterfacesError = CommonErrors;
/**
 * Describes the specified local gateway virtual interfaces.
 */
export const describeLocalGatewayVirtualInterfaces: API.OperationMethod<
  DescribeLocalGatewayVirtualInterfacesRequest,
  DescribeLocalGatewayVirtualInterfacesResult,
  DescribeLocalGatewayVirtualInterfacesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeLocalGatewayVirtualInterfacesRequest,
  ) => stream.Stream<
    DescribeLocalGatewayVirtualInterfacesResult,
    DescribeLocalGatewayVirtualInterfacesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeLocalGatewayVirtualInterfacesRequest,
  ) => stream.Stream<
    LocalGatewayVirtualInterface,
    DescribeLocalGatewayVirtualInterfacesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeLocalGatewayVirtualInterfacesRequest,
  output: DescribeLocalGatewayVirtualInterfacesResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "LocalGatewayVirtualInterfaces",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeLockedSnapshotsError =
  | RequestLimitExceeded
  | InvalidRequest
  | CommonErrors;
/**
 * Describes the lock status for a snapshot.
 */
export const describeLockedSnapshots: API.OperationMethod<
  DescribeLockedSnapshotsRequest,
  DescribeLockedSnapshotsResult,
  DescribeLockedSnapshotsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeLockedSnapshotsRequest,
  output: DescribeLockedSnapshotsResult,
  errors: [RequestLimitExceeded, InvalidRequest],
}));
export type DescribeMacHostsError =
  | RequestLimitExceeded
  | InvalidHostIDMalformed
  | CommonErrors;
/**
 * Describes the specified EC2 Mac Dedicated Host or all of your EC2 Mac Dedicated Hosts.
 */
export const describeMacHosts: API.OperationMethod<
  DescribeMacHostsRequest,
  DescribeMacHostsResult,
  DescribeMacHostsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeMacHostsRequest,
  ) => stream.Stream<
    DescribeMacHostsResult,
    DescribeMacHostsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeMacHostsRequest,
  ) => stream.Stream<
    MacHost,
    DescribeMacHostsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeMacHostsRequest,
  output: DescribeMacHostsResult,
  errors: [RequestLimitExceeded, InvalidHostIDMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "MacHosts",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeMacModificationTasksError =
  | RequestLimitExceeded
  | InvalidParameter
  | CommonErrors;
/**
 * Describes a System Integrity Protection (SIP) modification task or volume ownership delegation
 * task for an Amazon EC2 Mac instance. For more information, see Configure
 * SIP for Amazon EC2 instances in the *Amazon EC2 User Guide*.
 */
export const describeMacModificationTasks: API.OperationMethod<
  DescribeMacModificationTasksRequest,
  DescribeMacModificationTasksResult,
  DescribeMacModificationTasksError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeMacModificationTasksRequest,
  ) => stream.Stream<
    DescribeMacModificationTasksResult,
    DescribeMacModificationTasksError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeMacModificationTasksRequest,
  ) => stream.Stream<
    MacModificationTask,
    DescribeMacModificationTasksError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeMacModificationTasksRequest,
  output: DescribeMacModificationTasksResult,
  errors: [RequestLimitExceeded, InvalidParameter],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "MacModificationTasks",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeManagedPrefixListsError =
  | RequestLimitExceeded
  | InvalidPrefixListIDNotFound
  | ParseError
  | CommonErrors;
/**
 * Describes your managed prefix lists and any Amazon Web Services-managed prefix lists.
 */
export const describeManagedPrefixLists: API.OperationMethod<
  DescribeManagedPrefixListsRequest,
  DescribeManagedPrefixListsResult,
  DescribeManagedPrefixListsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeManagedPrefixListsRequest,
  ) => stream.Stream<
    DescribeManagedPrefixListsResult,
    DescribeManagedPrefixListsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeManagedPrefixListsRequest,
  ) => stream.Stream<
    ManagedPrefixList,
    DescribeManagedPrefixListsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeManagedPrefixListsRequest,
  output: DescribeManagedPrefixListsResult,
  errors: [RequestLimitExceeded, InvalidPrefixListIDNotFound, ParseError],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PrefixLists",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeMovingAddressesError =
  | RequestLimitExceeded
  | UnsupportedOperation
  | CommonErrors;
/**
 * This action is deprecated.
 *
 * Describes your Elastic IP addresses that are being moved from or being restored to the EC2-Classic platform.
 * This request does not return information about any other Elastic IP addresses in your account.
 */
export const describeMovingAddresses: API.OperationMethod<
  DescribeMovingAddressesRequest,
  DescribeMovingAddressesResult,
  DescribeMovingAddressesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeMovingAddressesRequest,
  ) => stream.Stream<
    DescribeMovingAddressesResult,
    DescribeMovingAddressesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeMovingAddressesRequest,
  ) => stream.Stream<
    MovingAddressStatus,
    DescribeMovingAddressesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeMovingAddressesRequest,
  output: DescribeMovingAddressesResult,
  errors: [RequestLimitExceeded, UnsupportedOperation],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "MovingAddressStatuses",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeNatGatewaysError =
  | RequestLimitExceeded
  | DryRunOperation
  | FilterLimitExceeded
  | InvalidParameter
  | NatGatewayMalformed
  | NatGatewayNotFound
  | ParseError
  | CommonErrors;
/**
 * Describes your NAT gateways. The default is to describe all your NAT gateways.
 * Alternatively, you can specify specific NAT gateway IDs or filter the results to
 * include only the NAT gateways that match specific criteria.
 */
export const describeNatGateways: API.OperationMethod<
  DescribeNatGatewaysRequest,
  DescribeNatGatewaysResult,
  DescribeNatGatewaysError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeNatGatewaysRequest,
  ) => stream.Stream<
    DescribeNatGatewaysResult,
    DescribeNatGatewaysError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeNatGatewaysRequest,
  ) => stream.Stream<
    NatGateway,
    DescribeNatGatewaysError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeNatGatewaysRequest,
  output: DescribeNatGatewaysResult,
  errors: [
    RequestLimitExceeded,
    DryRunOperation,
    FilterLimitExceeded,
    InvalidParameter,
    NatGatewayMalformed,
    NatGatewayNotFound,
    ParseError,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "NatGateways",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeNetworkAclsError =
  | RequestLimitExceeded
  | InvalidNetworkAclIDNotFound
  | InvalidRouteTableIDNotFound
  | ParseError
  | CommonErrors;
/**
 * Describes your network ACLs. The default is to describe all your network ACLs.
 * Alternatively, you can specify specific network ACL IDs or filter the results to
 * include only the network ACLs that match specific criteria.
 *
 * For more information, see Network ACLs in the
 * *Amazon VPC User Guide*.
 */
export const describeNetworkAcls: API.OperationMethod<
  DescribeNetworkAclsRequest,
  DescribeNetworkAclsResult,
  DescribeNetworkAclsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeNetworkAclsRequest,
  ) => stream.Stream<
    DescribeNetworkAclsResult,
    DescribeNetworkAclsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeNetworkAclsRequest,
  ) => stream.Stream<
    NetworkAcl,
    DescribeNetworkAclsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeNetworkAclsRequest,
  output: DescribeNetworkAclsResult,
  errors: [
    RequestLimitExceeded,
    InvalidNetworkAclIDNotFound,
    InvalidRouteTableIDNotFound,
    ParseError,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "NetworkAcls",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeNetworkInsightsAccessScopeAnalysesError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Describes the specified Network Access Scope analyses.
 */
export const describeNetworkInsightsAccessScopeAnalyses: API.OperationMethod<
  DescribeNetworkInsightsAccessScopeAnalysesRequest,
  DescribeNetworkInsightsAccessScopeAnalysesResult,
  DescribeNetworkInsightsAccessScopeAnalysesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeNetworkInsightsAccessScopeAnalysesRequest,
  ) => stream.Stream<
    DescribeNetworkInsightsAccessScopeAnalysesResult,
    DescribeNetworkInsightsAccessScopeAnalysesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeNetworkInsightsAccessScopeAnalysesRequest,
  ) => stream.Stream<
    NetworkInsightsAccessScopeAnalysis,
    DescribeNetworkInsightsAccessScopeAnalysesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeNetworkInsightsAccessScopeAnalysesRequest,
  output: DescribeNetworkInsightsAccessScopeAnalysesResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "NetworkInsightsAccessScopeAnalyses",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeNetworkInsightsAccessScopesError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Describes the specified Network Access Scopes.
 */
export const describeNetworkInsightsAccessScopes: API.OperationMethod<
  DescribeNetworkInsightsAccessScopesRequest,
  DescribeNetworkInsightsAccessScopesResult,
  DescribeNetworkInsightsAccessScopesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeNetworkInsightsAccessScopesRequest,
  ) => stream.Stream<
    DescribeNetworkInsightsAccessScopesResult,
    DescribeNetworkInsightsAccessScopesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeNetworkInsightsAccessScopesRequest,
  ) => stream.Stream<
    NetworkInsightsAccessScope,
    DescribeNetworkInsightsAccessScopesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeNetworkInsightsAccessScopesRequest,
  output: DescribeNetworkInsightsAccessScopesResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "NetworkInsightsAccessScopes",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeNetworkInsightsAnalysesError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Describes one or more of your network insights analyses.
 */
export const describeNetworkInsightsAnalyses: API.OperationMethod<
  DescribeNetworkInsightsAnalysesRequest,
  DescribeNetworkInsightsAnalysesResult,
  DescribeNetworkInsightsAnalysesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeNetworkInsightsAnalysesRequest,
  ) => stream.Stream<
    DescribeNetworkInsightsAnalysesResult,
    DescribeNetworkInsightsAnalysesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeNetworkInsightsAnalysesRequest,
  ) => stream.Stream<
    NetworkInsightsAnalysis,
    DescribeNetworkInsightsAnalysesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeNetworkInsightsAnalysesRequest,
  output: DescribeNetworkInsightsAnalysesResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "NetworkInsightsAnalyses",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeNetworkInsightsPathsError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Describes one or more of your paths.
 */
export const describeNetworkInsightsPaths: API.OperationMethod<
  DescribeNetworkInsightsPathsRequest,
  DescribeNetworkInsightsPathsResult,
  DescribeNetworkInsightsPathsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeNetworkInsightsPathsRequest,
  ) => stream.Stream<
    DescribeNetworkInsightsPathsResult,
    DescribeNetworkInsightsPathsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeNetworkInsightsPathsRequest,
  ) => stream.Stream<
    NetworkInsightsPath,
    DescribeNetworkInsightsPathsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeNetworkInsightsPathsRequest,
  output: DescribeNetworkInsightsPathsResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "NetworkInsightsPaths",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeNetworkInterfaceAttributeError =
  | RequestLimitExceeded
  | InvalidNetworkInterfaceIDNotFound
  | InvalidNetworkInterfaceIdMalformed
  | InvalidParameterCombination
  | CommonErrors;
/**
 * Describes a network interface attribute. You can specify only one attribute at a
 * time.
 */
export const describeNetworkInterfaceAttribute: API.OperationMethod<
  DescribeNetworkInterfaceAttributeRequest,
  DescribeNetworkInterfaceAttributeResult,
  DescribeNetworkInterfaceAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeNetworkInterfaceAttributeRequest,
  output: DescribeNetworkInterfaceAttributeResult,
  errors: [
    RequestLimitExceeded,
    InvalidNetworkInterfaceIDNotFound,
    InvalidNetworkInterfaceIdMalformed,
    InvalidParameterCombination,
  ],
}));
export type DescribeNetworkInterfacePermissionsError =
  | RequestLimitExceeded
  | InvalidPermissionIDNotFound
  | CommonErrors;
/**
 * Describes the permissions for your network interfaces.
 */
export const describeNetworkInterfacePermissions: API.OperationMethod<
  DescribeNetworkInterfacePermissionsRequest,
  DescribeNetworkInterfacePermissionsResult,
  DescribeNetworkInterfacePermissionsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeNetworkInterfacePermissionsRequest,
  ) => stream.Stream<
    DescribeNetworkInterfacePermissionsResult,
    DescribeNetworkInterfacePermissionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeNetworkInterfacePermissionsRequest,
  ) => stream.Stream<
    NetworkInterfacePermission,
    DescribeNetworkInterfacePermissionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeNetworkInterfacePermissionsRequest,
  output: DescribeNetworkInterfacePermissionsResult,
  errors: [RequestLimitExceeded, InvalidPermissionIDNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "NetworkInterfacePermissions",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeNetworkInterfacesError =
  | RequestLimitExceeded
  | InvalidNetworkInterfaceIDNotFound
  | InvalidNetworkInterfaceIdMalformed
  | ParseError
  | CommonErrors;
/**
 * Describes the specified network interfaces or all your network interfaces.
 *
 * If you have a large number of network interfaces, the operation fails unless you use
 * pagination or one of the following filters: `group-id`,
 * `mac-address`, `private-dns-name`,
 * `private-ip-address`, `subnet-id`, or
 * `vpc-id`.
 *
 * We strongly recommend using only paginated requests. Unpaginated requests are
 * susceptible to throttling and timeouts.
 */
export const describeNetworkInterfaces: API.OperationMethod<
  DescribeNetworkInterfacesRequest,
  DescribeNetworkInterfacesResult,
  DescribeNetworkInterfacesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeNetworkInterfacesRequest,
  ) => stream.Stream<
    DescribeNetworkInterfacesResult,
    DescribeNetworkInterfacesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeNetworkInterfacesRequest,
  ) => stream.Stream<
    NetworkInterface,
    DescribeNetworkInterfacesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeNetworkInterfacesRequest,
  output: DescribeNetworkInterfacesResult,
  errors: [
    RequestLimitExceeded,
    InvalidNetworkInterfaceIDNotFound,
    InvalidNetworkInterfaceIdMalformed,
    ParseError,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "NetworkInterfaces",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeOutpostLagsError =
  | RequestLimitExceeded
  | InvalidOutpostLagIDMalformed
  | CommonErrors;
/**
 * Describes the Outposts link aggregation groups (LAGs).
 *
 * LAGs are only available for second-generation Outposts racks at this time.
 */
export const describeOutpostLags: API.OperationMethod<
  DescribeOutpostLagsRequest,
  DescribeOutpostLagsResult,
  DescribeOutpostLagsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeOutpostLagsRequest,
  output: DescribeOutpostLagsResult,
  errors: [RequestLimitExceeded, InvalidOutpostLagIDMalformed],
}));
export type DescribePlacementGroupsError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidPlacementGroupUnknown
  | CommonErrors;
/**
 * Describes the specified placement groups or all of your placement groups.
 *
 * To describe a specific placement group that is *shared* with
 * your account, you must specify the ID of the placement group using the
 * `GroupId` parameter. Specifying the name of a
 * *shared* placement group using the `GroupNames`
 * parameter will result in an error.
 *
 * For more information, see Placement groups in the
 * *Amazon EC2 User Guide*.
 */
export const describePlacementGroups: API.OperationMethod<
  DescribePlacementGroupsRequest,
  DescribePlacementGroupsResult,
  DescribePlacementGroupsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribePlacementGroupsRequest,
  output: DescribePlacementGroupsResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidPlacementGroupUnknown,
  ],
}));
export type DescribePrefixListsError =
  | RequestLimitExceeded
  | InvalidPrefixListIdNotFound
  | CommonErrors;
/**
 * Describes available Amazon Web Services services in a prefix list format, which includes the prefix list
 * name and prefix list ID of the service and the IP address range for the service.
 */
export const describePrefixLists: API.OperationMethod<
  DescribePrefixListsRequest,
  DescribePrefixListsResult,
  DescribePrefixListsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribePrefixListsRequest,
  ) => stream.Stream<
    DescribePrefixListsResult,
    DescribePrefixListsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribePrefixListsRequest,
  ) => stream.Stream<
    PrefixList,
    DescribePrefixListsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribePrefixListsRequest,
  output: DescribePrefixListsResult,
  errors: [RequestLimitExceeded, InvalidPrefixListIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PrefixLists",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribePrincipalIdFormatError = CommonErrors;
/**
 * Describes the ID format settings for the root user and all IAM roles and IAM users
 * that have explicitly specified a longer ID (17-character ID) preference.
 *
 * By default, all IAM roles and IAM users default to the same ID settings as the root user, unless they
 * explicitly override the settings. This request is useful for identifying those IAM users and IAM roles
 * that have overridden the default ID settings.
 *
 * The following resource types support longer IDs: `bundle` |
 * `conversion-task` | `customer-gateway` | `dhcp-options` |
 * `elastic-ip-allocation` | `elastic-ip-association` |
 * `export-task` | `flow-log` | `image` |
 * `import-task` | `instance` | `internet-gateway` |
 * `network-acl` | `network-acl-association` |
 * `network-interface` | `network-interface-attachment` |
 * `prefix-list` | `reservation` | `route-table` |
 * `route-table-association` | `security-group` |
 * `snapshot` | `subnet` |
 * `subnet-cidr-block-association` | `volume` | `vpc`
 * | `vpc-cidr-block-association` | `vpc-endpoint` |
 * `vpc-peering-connection` | `vpn-connection` | `vpn-gateway`.
 */
export const describePrincipalIdFormat: API.OperationMethod<
  DescribePrincipalIdFormatRequest,
  DescribePrincipalIdFormatResult,
  DescribePrincipalIdFormatError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribePrincipalIdFormatRequest,
  ) => stream.Stream<
    DescribePrincipalIdFormatResult,
    DescribePrincipalIdFormatError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribePrincipalIdFormatRequest,
  ) => stream.Stream<
    PrincipalIdFormat,
    DescribePrincipalIdFormatError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribePrincipalIdFormatRequest,
  output: DescribePrincipalIdFormatResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Principals",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribePublicIpv4PoolsError =
  | RequestLimitExceeded
  | InvalidPublicIpv4PoolIDNotFound
  | CommonErrors;
/**
 * Describes the specified IPv4 address pools.
 */
export const describePublicIpv4Pools: API.OperationMethod<
  DescribePublicIpv4PoolsRequest,
  DescribePublicIpv4PoolsResult,
  DescribePublicIpv4PoolsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribePublicIpv4PoolsRequest,
  ) => stream.Stream<
    DescribePublicIpv4PoolsResult,
    DescribePublicIpv4PoolsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribePublicIpv4PoolsRequest,
  ) => stream.Stream<
    PublicIpv4Pool,
    DescribePublicIpv4PoolsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribePublicIpv4PoolsRequest,
  output: DescribePublicIpv4PoolsResult,
  errors: [RequestLimitExceeded, InvalidPublicIpv4PoolIDNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PublicIpv4Pools",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeRegionsError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Describes the Regions that are enabled for your account, or all Regions.
 *
 * For a list of the Regions supported by Amazon EC2, see Amazon EC2 service endpoints.
 *
 * For information about enabling and disabling Regions for your account, see Specify which Amazon Web Services Regions
 * your account can use in the *Amazon Web Services Account Management Reference Guide*.
 *
 * The order of the elements in the response, including those within nested structures,
 * might vary. Applications should not assume the elements appear in a particular order.
 */
export const describeRegions: API.OperationMethod<
  DescribeRegionsRequest,
  DescribeRegionsResult,
  DescribeRegionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeRegionsRequest,
  output: DescribeRegionsResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type DescribeReplaceRootVolumeTasksError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Describes a root volume replacement task. For more information, see
 * Replace a root volume in the *Amazon EC2 User Guide*.
 */
export const describeReplaceRootVolumeTasks: API.OperationMethod<
  DescribeReplaceRootVolumeTasksRequest,
  DescribeReplaceRootVolumeTasksResult,
  DescribeReplaceRootVolumeTasksError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeReplaceRootVolumeTasksRequest,
  ) => stream.Stream<
    DescribeReplaceRootVolumeTasksResult,
    DescribeReplaceRootVolumeTasksError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeReplaceRootVolumeTasksRequest,
  ) => stream.Stream<
    ReplaceRootVolumeTask,
    DescribeReplaceRootVolumeTasksError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeReplaceRootVolumeTasksRequest,
  output: DescribeReplaceRootVolumeTasksResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ReplaceRootVolumeTasks",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeReservedInstancesError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Describes one or more of the Reserved Instances that you purchased.
 *
 * For more information about Reserved Instances, see Reserved
 * Instances in the *Amazon EC2 User Guide*.
 *
 * The order of the elements in the response, including those within nested structures,
 * might vary. Applications should not assume the elements appear in a particular order.
 */
export const describeReservedInstances: API.OperationMethod<
  DescribeReservedInstancesRequest,
  DescribeReservedInstancesResult,
  DescribeReservedInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeReservedInstancesRequest,
  output: DescribeReservedInstancesResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type DescribeReservedInstancesListingsError = CommonErrors;
/**
 * Describes your account's Reserved Instance listings in the Reserved Instance
 * Marketplace.
 *
 * The Reserved Instance Marketplace matches sellers who want to resell Reserved Instance
 * capacity that they no longer need with buyers who want to purchase additional capacity.
 * Reserved Instances bought and sold through the Reserved Instance Marketplace work like any
 * other Reserved Instances.
 *
 * As a seller, you choose to list some or all of your Reserved Instances, and you specify
 * the upfront price to receive for them. Your Reserved Instances are then listed in the Reserved
 * Instance Marketplace and are available for purchase.
 *
 * As a buyer, you specify the configuration of the Reserved Instance to purchase, and the
 * Marketplace matches what you're searching for with what's available. The Marketplace first
 * sells the lowest priced Reserved Instances to you, and continues to sell available Reserved
 * Instance listings to you until your demand is met. You are charged based on the total price of
 * all of the listings that you purchase.
 *
 * For more information, see Sell in the Reserved Instance
 * Marketplace in the *Amazon EC2 User Guide*.
 *
 * The order of the elements in the response, including those within nested structures,
 * might vary. Applications should not assume the elements appear in a particular order.
 */
export const describeReservedInstancesListings: API.OperationMethod<
  DescribeReservedInstancesListingsRequest,
  DescribeReservedInstancesListingsResult,
  DescribeReservedInstancesListingsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeReservedInstancesListingsRequest,
  output: DescribeReservedInstancesListingsResult,
  errors: [],
}));
export type DescribeReservedInstancesModificationsError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Describes the modifications made to your Reserved Instances. If no parameter is specified,
 * information about all your Reserved Instances modification requests is returned. If a
 * modification ID is specified, only information about the specific modification is
 * returned.
 *
 * For more information, see Modify Reserved Instances in the
 * *Amazon EC2 User Guide*.
 *
 * The order of the elements in the response, including those within nested structures,
 * might vary. Applications should not assume the elements appear in a particular order.
 */
export const describeReservedInstancesModifications: API.OperationMethod<
  DescribeReservedInstancesModificationsRequest,
  DescribeReservedInstancesModificationsResult,
  DescribeReservedInstancesModificationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeReservedInstancesModificationsRequest,
  ) => stream.Stream<
    DescribeReservedInstancesModificationsResult,
    DescribeReservedInstancesModificationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeReservedInstancesModificationsRequest,
  ) => stream.Stream<
    ReservedInstancesModification,
    DescribeReservedInstancesModificationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeReservedInstancesModificationsRequest,
  output: DescribeReservedInstancesModificationsResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ReservedInstancesModifications",
  } as const,
}));
export type DescribeReservedInstancesOfferingsError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Describes Reserved Instance offerings that are available for purchase. With Reserved
 * Instances, you purchase the right to launch instances for a period of time. During that time
 * period, you do not receive insufficient capacity errors, and you pay a lower usage rate than
 * the rate charged for On-Demand instances for the actual time used.
 *
 * If you have listed your own Reserved Instances for sale in the Reserved Instance
 * Marketplace, they will be excluded from these results. This is to ensure that you do not
 * purchase your own Reserved Instances.
 *
 * For more information, see Sell in the Reserved Instance
 * Marketplace in the *Amazon EC2 User Guide*.
 *
 * The order of the elements in the response, including those within nested structures,
 * might vary. Applications should not assume the elements appear in a particular order.
 */
export const describeReservedInstancesOfferings: API.OperationMethod<
  DescribeReservedInstancesOfferingsRequest,
  DescribeReservedInstancesOfferingsResult,
  DescribeReservedInstancesOfferingsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeReservedInstancesOfferingsRequest,
  ) => stream.Stream<
    DescribeReservedInstancesOfferingsResult,
    DescribeReservedInstancesOfferingsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeReservedInstancesOfferingsRequest,
  ) => stream.Stream<
    ReservedInstancesOffering,
    DescribeReservedInstancesOfferingsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeReservedInstancesOfferingsRequest,
  output: DescribeReservedInstancesOfferingsResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ReservedInstancesOfferings",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeRouteServerEndpointsError =
  | RequestLimitExceeded
  | InvalidRouteServerEndpointIdNotFound
  | CommonErrors;
/**
 * Describes one or more route server endpoints.
 *
 * A route server endpoint is an Amazon Web Services-managed component inside a subnet that facilitates BGP (Border Gateway Protocol) connections between your route server and your BGP peers.
 *
 * For more information see Dynamic routing in your VPC with VPC Route Server in the *Amazon VPC User Guide*.
 */
export const describeRouteServerEndpoints: API.OperationMethod<
  DescribeRouteServerEndpointsRequest,
  DescribeRouteServerEndpointsResult,
  DescribeRouteServerEndpointsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeRouteServerEndpointsRequest,
  ) => stream.Stream<
    DescribeRouteServerEndpointsResult,
    DescribeRouteServerEndpointsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeRouteServerEndpointsRequest,
  ) => stream.Stream<
    RouteServerEndpoint,
    DescribeRouteServerEndpointsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeRouteServerEndpointsRequest,
  output: DescribeRouteServerEndpointsResult,
  errors: [RequestLimitExceeded, InvalidRouteServerEndpointIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "RouteServerEndpoints",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeRouteServerPeersError =
  | RequestLimitExceeded
  | InvalidRouteServerPeerIdNotFound
  | CommonErrors;
/**
 * Describes one or more route server peers.
 *
 * A route server peer is a session between a route server endpoint and the device deployed in Amazon Web Services (such as a firewall appliance or other network security function running on an EC2 instance). The device must meet these requirements:
 *
 * - Have an elastic network interface in the VPC
 *
 * - Support BGP (Border Gateway Protocol)
 *
 * - Can initiate BGP sessions
 *
 * For more information see Dynamic routing in your VPC with VPC Route Server in the *Amazon VPC User Guide*.
 */
export const describeRouteServerPeers: API.OperationMethod<
  DescribeRouteServerPeersRequest,
  DescribeRouteServerPeersResult,
  DescribeRouteServerPeersError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeRouteServerPeersRequest,
  ) => stream.Stream<
    DescribeRouteServerPeersResult,
    DescribeRouteServerPeersError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeRouteServerPeersRequest,
  ) => stream.Stream<
    RouteServerPeer,
    DescribeRouteServerPeersError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeRouteServerPeersRequest,
  output: DescribeRouteServerPeersResult,
  errors: [RequestLimitExceeded, InvalidRouteServerPeerIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "RouteServerPeers",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeRouteServersError =
  | RequestLimitExceeded
  | InvalidRouteServerIdNotFound
  | CommonErrors;
/**
 * Describes one or more route servers.
 *
 * Amazon VPC Route Server simplifies routing for traffic between workloads that are deployed within a VPC and its internet gateways. With this feature,
 * VPC Route Server dynamically updates VPC and internet gateway route tables with your preferred IPv4 or IPv6 routes to achieve routing fault tolerance for those workloads. This enables you to automatically reroute traffic within a VPC, which increases the manageability of VPC routing and interoperability with third-party workloads.
 *
 * Route server supports the follow route table types:
 *
 * - VPC route tables not associated with subnets
 *
 * - Subnet route tables
 *
 * - Internet gateway route tables
 *
 * Route server does not support route tables associated with virtual private gateways. To propagate routes into a transit gateway route table, use Transit Gateway Connect.
 *
 * For more information see Dynamic routing in your VPC with VPC Route Server in the *Amazon VPC User Guide*.
 */
export const describeRouteServers: API.OperationMethod<
  DescribeRouteServersRequest,
  DescribeRouteServersResult,
  DescribeRouteServersError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeRouteServersRequest,
  ) => stream.Stream<
    DescribeRouteServersResult,
    DescribeRouteServersError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeRouteServersRequest,
  ) => stream.Stream<
    RouteServer,
    DescribeRouteServersError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeRouteServersRequest,
  output: DescribeRouteServersResult,
  errors: [RequestLimitExceeded, InvalidRouteServerIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "RouteServers",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeRouteTablesError =
  | RequestLimitExceeded
  | InvalidRouteTableIDNotFound
  | ParseError
  | CommonErrors;
/**
 * Describes your route tables. The default is to describe all your route tables.
 * Alternatively, you can specify specific route table IDs or filter the results to
 * include only the route tables that match specific criteria.
 *
 * Each subnet in your VPC must be associated with a route table. If a subnet is not explicitly associated with any route table, it is implicitly associated with the main route table. This command does not return the subnet ID for implicit associations.
 *
 * For more information, see Route tables in the
 * *Amazon VPC User Guide*.
 */
export const describeRouteTables: API.OperationMethod<
  DescribeRouteTablesRequest,
  DescribeRouteTablesResult,
  DescribeRouteTablesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeRouteTablesRequest,
  ) => stream.Stream<
    DescribeRouteTablesResult,
    DescribeRouteTablesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeRouteTablesRequest,
  ) => stream.Stream<
    RouteTable,
    DescribeRouteTablesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeRouteTablesRequest,
  output: DescribeRouteTablesResult,
  errors: [RequestLimitExceeded, InvalidRouteTableIDNotFound, ParseError],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "RouteTables",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeScheduledInstanceAvailabilityError = CommonErrors;
/**
 * Finds available schedules that meet the specified criteria.
 *
 * You can search for an available schedule no more than 3 months in advance. You must meet the minimum required duration of 1,200 hours per year. For example, the minimum daily schedule is 4 hours, the minimum weekly schedule is 24 hours, and the minimum monthly schedule is 100 hours.
 *
 * After you find a schedule that meets your needs, call PurchaseScheduledInstances
 * to purchase Scheduled Instances with that schedule.
 */
export const describeScheduledInstanceAvailability: API.OperationMethod<
  DescribeScheduledInstanceAvailabilityRequest,
  DescribeScheduledInstanceAvailabilityResult,
  DescribeScheduledInstanceAvailabilityError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeScheduledInstanceAvailabilityRequest,
  ) => stream.Stream<
    DescribeScheduledInstanceAvailabilityResult,
    DescribeScheduledInstanceAvailabilityError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeScheduledInstanceAvailabilityRequest,
  ) => stream.Stream<
    ScheduledInstanceAvailability,
    DescribeScheduledInstanceAvailabilityError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeScheduledInstanceAvailabilityRequest,
  output: DescribeScheduledInstanceAvailabilityResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ScheduledInstanceAvailabilitySet",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeScheduledInstancesError = CommonErrors;
/**
 * Describes the specified Scheduled Instances or all your Scheduled Instances.
 */
export const describeScheduledInstances: API.OperationMethod<
  DescribeScheduledInstancesRequest,
  DescribeScheduledInstancesResult,
  DescribeScheduledInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeScheduledInstancesRequest,
  ) => stream.Stream<
    DescribeScheduledInstancesResult,
    DescribeScheduledInstancesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeScheduledInstancesRequest,
  ) => stream.Stream<
    ScheduledInstance,
    DescribeScheduledInstancesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeScheduledInstancesRequest,
  output: DescribeScheduledInstancesResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ScheduledInstanceSet",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeSecondaryInterfacesError = CommonErrors;
/**
 * Describes one or more of your secondary interfaces.
 */
export const describeSecondaryInterfaces: API.OperationMethod<
  DescribeSecondaryInterfacesRequest,
  DescribeSecondaryInterfacesResult,
  DescribeSecondaryInterfacesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeSecondaryInterfacesRequest,
  ) => stream.Stream<
    DescribeSecondaryInterfacesResult,
    DescribeSecondaryInterfacesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeSecondaryInterfacesRequest,
  ) => stream.Stream<
    SecondaryInterface,
    DescribeSecondaryInterfacesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeSecondaryInterfacesRequest,
  output: DescribeSecondaryInterfacesResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SecondaryInterfaces",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeSecondaryNetworksError = CommonErrors;
/**
 * Describes one or more secondary networks.
 */
export const describeSecondaryNetworks: API.OperationMethod<
  DescribeSecondaryNetworksRequest,
  DescribeSecondaryNetworksResult,
  DescribeSecondaryNetworksError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeSecondaryNetworksRequest,
  ) => stream.Stream<
    DescribeSecondaryNetworksResult,
    DescribeSecondaryNetworksError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeSecondaryNetworksRequest,
  ) => stream.Stream<
    SecondaryNetwork,
    DescribeSecondaryNetworksError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeSecondaryNetworksRequest,
  output: DescribeSecondaryNetworksResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SecondaryNetworks",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeSecondarySubnetsError = CommonErrors;
/**
 * Describes one or more of your secondary subnets.
 */
export const describeSecondarySubnets: API.OperationMethod<
  DescribeSecondarySubnetsRequest,
  DescribeSecondarySubnetsResult,
  DescribeSecondarySubnetsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeSecondarySubnetsRequest,
  ) => stream.Stream<
    DescribeSecondarySubnetsResult,
    DescribeSecondarySubnetsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeSecondarySubnetsRequest,
  ) => stream.Stream<
    SecondarySubnet,
    DescribeSecondarySubnetsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeSecondarySubnetsRequest,
  output: DescribeSecondarySubnetsResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SecondarySubnets",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeSecurityGroupReferencesError = CommonErrors;
/**
 * Describes the VPCs on the other side of a VPC peering or Transit Gateway connection that are referencing the security groups you've specified in this request.
 */
export const describeSecurityGroupReferences: API.OperationMethod<
  DescribeSecurityGroupReferencesRequest,
  DescribeSecurityGroupReferencesResult,
  DescribeSecurityGroupReferencesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeSecurityGroupReferencesRequest,
  output: DescribeSecurityGroupReferencesResult,
  errors: [],
}));
export type DescribeSecurityGroupRulesError =
  | RequestLimitExceeded
  | InvalidSecurityGroupRuleIdNotFound
  | CommonErrors;
/**
 * Describes one or more of your security group rules.
 */
export const describeSecurityGroupRules: API.OperationMethod<
  DescribeSecurityGroupRulesRequest,
  DescribeSecurityGroupRulesResult,
  DescribeSecurityGroupRulesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeSecurityGroupRulesRequest,
  ) => stream.Stream<
    DescribeSecurityGroupRulesResult,
    DescribeSecurityGroupRulesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeSecurityGroupRulesRequest,
  ) => stream.Stream<
    SecurityGroupRule,
    DescribeSecurityGroupRulesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeSecurityGroupRulesRequest,
  output: DescribeSecurityGroupRulesResult,
  errors: [RequestLimitExceeded, InvalidSecurityGroupRuleIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SecurityGroupRules",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeSecurityGroupsError =
  | RequestLimitExceeded
  | InvalidGroupNotFound
  | InvalidGroupIdMalformed
  | ParseError
  | VPCIdNotSpecified
  | CommonErrors;
/**
 * Describes the specified security groups or all of your security groups.
 */
export const describeSecurityGroups: API.OperationMethod<
  DescribeSecurityGroupsRequest,
  DescribeSecurityGroupsResult,
  DescribeSecurityGroupsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeSecurityGroupsRequest,
  ) => stream.Stream<
    DescribeSecurityGroupsResult,
    DescribeSecurityGroupsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeSecurityGroupsRequest,
  ) => stream.Stream<
    SecurityGroup,
    DescribeSecurityGroupsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeSecurityGroupsRequest,
  output: DescribeSecurityGroupsResult,
  errors: [
    RequestLimitExceeded,
    InvalidGroupNotFound,
    InvalidGroupIdMalformed,
    ParseError,
    VPCIdNotSpecified,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SecurityGroups",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeSecurityGroupVpcAssociationsError = CommonErrors;
/**
 * Describes security group VPC associations made with AssociateSecurityGroupVpc.
 */
export const describeSecurityGroupVpcAssociations: API.OperationMethod<
  DescribeSecurityGroupVpcAssociationsRequest,
  DescribeSecurityGroupVpcAssociationsResult,
  DescribeSecurityGroupVpcAssociationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeSecurityGroupVpcAssociationsRequest,
  ) => stream.Stream<
    DescribeSecurityGroupVpcAssociationsResult,
    DescribeSecurityGroupVpcAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeSecurityGroupVpcAssociationsRequest,
  ) => stream.Stream<
    SecurityGroupVpcAssociation,
    DescribeSecurityGroupVpcAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeSecurityGroupVpcAssociationsRequest,
  output: DescribeSecurityGroupVpcAssociationsResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SecurityGroupVpcAssociations",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeServiceLinkVirtualInterfacesError =
  | RequestLimitExceeded
  | InvalidServiceLinkVirtualInterfaceIDMalformed
  | CommonErrors;
/**
 * Describes the Outpost service link virtual interfaces.
 */
export const describeServiceLinkVirtualInterfaces: API.OperationMethod<
  DescribeServiceLinkVirtualInterfacesRequest,
  DescribeServiceLinkVirtualInterfacesResult,
  DescribeServiceLinkVirtualInterfacesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeServiceLinkVirtualInterfacesRequest,
  output: DescribeServiceLinkVirtualInterfacesResult,
  errors: [RequestLimitExceeded, InvalidServiceLinkVirtualInterfaceIDMalformed],
}));
export type DescribeSnapshotAttributeError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidSnapshotNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Describes the specified attribute of the specified snapshot. You can specify only one
 * attribute at a time.
 *
 * For more information about EBS snapshots, see Amazon EBS snapshots in the *Amazon EBS User Guide*.
 */
export const describeSnapshotAttribute: API.OperationMethod<
  DescribeSnapshotAttributeRequest,
  DescribeSnapshotAttributeResult,
  DescribeSnapshotAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeSnapshotAttributeRequest,
  output: DescribeSnapshotAttributeResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidSnapshotNotFound,
    MissingParameter,
  ],
}));
export type DescribeSnapshotsError =
  | RequestLimitExceeded
  | InvalidSnapshotNotFound
  | InvalidUserIDMalformed
  | CommonErrors;
/**
 * Describes the specified EBS snapshots available to you or all of the EBS snapshots
 * available to you.
 *
 * The snapshots available to you include public snapshots, private snapshots that you own,
 * and private snapshots owned by other Amazon Web Services accounts for which you have explicit create volume
 * permissions.
 *
 * The create volume permissions fall into the following categories:
 *
 * - *public*: The owner of the snapshot granted create volume
 * permissions for the snapshot to the `all` group. All Amazon Web Services accounts have create
 * volume permissions for these snapshots.
 *
 * - *explicit*: The owner of the snapshot granted create volume
 * permissions to a specific Amazon Web Services account.
 *
 * - *implicit*: An Amazon Web Services account has implicit create volume permissions
 * for all snapshots it owns.
 *
 * The list of snapshots returned can be filtered by specifying snapshot IDs, snapshot
 * owners, or Amazon Web Services accounts with create volume permissions. If no options are specified,
 * Amazon EC2 returns all snapshots for which you have create volume permissions.
 *
 * If you specify one or more snapshot IDs, only snapshots that have the specified IDs are
 * returned. If you specify an invalid snapshot ID, an error is returned. If you specify a
 * snapshot ID for which you do not have access, it is not included in the returned
 * results.
 *
 * If you specify one or more snapshot owners using the `OwnerIds` option, only
 * snapshots from the specified owners and for which you have access are returned. The results
 * can include the Amazon Web Services account IDs of the specified owners, `amazon` for snapshots
 * owned by Amazon, or `self` for snapshots that you own.
 *
 * If you specify a list of restorable users, only snapshots with create snapshot permissions
 * for those users are returned. You can specify Amazon Web Services account IDs (if you own the snapshots),
 * `self` for snapshots for which you own or have explicit permissions, or
 * `all` for public snapshots.
 *
 * If you are describing a long list of snapshots, we recommend that you paginate the output to make the
 * list more manageable. For more information, see Pagination.
 *
 * For more information about EBS snapshots, see Amazon EBS snapshots in the *Amazon EBS User Guide*.
 *
 * We strongly recommend using only paginated requests. Unpaginated requests are
 * susceptible to throttling and timeouts.
 */
export const describeSnapshots: API.OperationMethod<
  DescribeSnapshotsRequest,
  DescribeSnapshotsResult,
  DescribeSnapshotsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeSnapshotsRequest,
  ) => stream.Stream<
    DescribeSnapshotsResult,
    DescribeSnapshotsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeSnapshotsRequest,
  ) => stream.Stream<
    Snapshot,
    DescribeSnapshotsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeSnapshotsRequest,
  output: DescribeSnapshotsResult,
  errors: [
    RequestLimitExceeded,
    InvalidSnapshotNotFound,
    InvalidUserIDMalformed,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Snapshots",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeSnapshotTierStatusError = CommonErrors;
/**
 * Describes the storage tier status of one or more Amazon EBS snapshots.
 */
export const describeSnapshotTierStatus: API.OperationMethod<
  DescribeSnapshotTierStatusRequest,
  DescribeSnapshotTierStatusResult,
  DescribeSnapshotTierStatusError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeSnapshotTierStatusRequest,
  ) => stream.Stream<
    DescribeSnapshotTierStatusResult,
    DescribeSnapshotTierStatusError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeSnapshotTierStatusRequest,
  ) => stream.Stream<
    SnapshotTierStatus,
    DescribeSnapshotTierStatusError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeSnapshotTierStatusRequest,
  output: DescribeSnapshotTierStatusResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SnapshotTierStatuses",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeSpotDatafeedSubscriptionError =
  | RequestLimitExceeded
  | InvalidSpotDatafeedNotFound
  | CommonErrors;
/**
 * Describes the data feed for Spot Instances. For more information, see Spot
 * Instance data feed in the *Amazon EC2 User Guide*.
 */
export const describeSpotDatafeedSubscription: API.OperationMethod<
  DescribeSpotDatafeedSubscriptionRequest,
  DescribeSpotDatafeedSubscriptionResult,
  DescribeSpotDatafeedSubscriptionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeSpotDatafeedSubscriptionRequest,
  output: DescribeSpotDatafeedSubscriptionResult,
  errors: [RequestLimitExceeded, InvalidSpotDatafeedNotFound],
}));
export type DescribeSpotFleetInstancesError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Describes the running instances for the specified Spot Fleet.
 */
export const describeSpotFleetInstances: API.OperationMethod<
  DescribeSpotFleetInstancesRequest,
  DescribeSpotFleetInstancesResponse,
  DescribeSpotFleetInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeSpotFleetInstancesRequest,
  output: DescribeSpotFleetInstancesResponse,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type DescribeSpotFleetRequestHistoryError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Describes the events for the specified Spot Fleet request during the specified
 * time.
 *
 * Spot Fleet events are delayed by up to 30 seconds before they can be described. This
 * ensures that you can query by the last evaluated time and not miss a recorded event.
 * Spot Fleet events are available for 48 hours.
 *
 * For more information, see Monitor fleet events using Amazon
 * EventBridge in the *Amazon EC2 User Guide*.
 */
export const describeSpotFleetRequestHistory: API.OperationMethod<
  DescribeSpotFleetRequestHistoryRequest,
  DescribeSpotFleetRequestHistoryResponse,
  DescribeSpotFleetRequestHistoryError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeSpotFleetRequestHistoryRequest,
  output: DescribeSpotFleetRequestHistoryResponse,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type DescribeSpotFleetRequestsError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | ParseError
  | CommonErrors;
/**
 * Describes your Spot Fleet requests.
 *
 * Spot Fleet requests are deleted 48 hours after they are canceled and their instances
 * are terminated.
 */
export const describeSpotFleetRequests: API.OperationMethod<
  DescribeSpotFleetRequestsRequest,
  DescribeSpotFleetRequestsResponse,
  DescribeSpotFleetRequestsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeSpotFleetRequestsRequest,
  ) => stream.Stream<
    DescribeSpotFleetRequestsResponse,
    DescribeSpotFleetRequestsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeSpotFleetRequestsRequest,
  ) => stream.Stream<
    SpotFleetRequestConfig,
    DescribeSpotFleetRequestsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeSpotFleetRequestsRequest,
  output: DescribeSpotFleetRequestsResponse,
  errors: [RequestLimitExceeded, InvalidParameterValue, ParseError],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SpotFleetRequestConfigs",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeSpotInstanceRequestsError =
  | RequestLimitExceeded
  | InvalidSpotInstanceRequestIDMalformed
  | ParseError
  | CommonErrors;
/**
 * Describes the specified Spot Instance requests.
 *
 * You can use `DescribeSpotInstanceRequests` to find a running Spot Instance by
 * examining the response. If the status of the Spot Instance is `fulfilled`, the
 * instance ID appears in the response and contains the identifier of the instance.
 * Alternatively, you can use DescribeInstances
 * with a filter to look for instances where the instance lifecycle is
 * `spot`.
 *
 * We recommend that you set `MaxResults` to a value between 5 and 1000 to
 * limit the number of items returned. This paginates the output, which makes the list
 * more manageable and returns the items faster. If the list of items exceeds your
 * `MaxResults` value, then that number of items is returned along with a
 * `NextToken` value that can be passed to a subsequent
 * `DescribeSpotInstanceRequests` request to retrieve the remaining
 * items.
 *
 * Spot Instance requests are deleted four hours after they are canceled and their instances are
 * terminated.
 */
export const describeSpotInstanceRequests: API.OperationMethod<
  DescribeSpotInstanceRequestsRequest,
  DescribeSpotInstanceRequestsResult,
  DescribeSpotInstanceRequestsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeSpotInstanceRequestsRequest,
  ) => stream.Stream<
    DescribeSpotInstanceRequestsResult,
    DescribeSpotInstanceRequestsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeSpotInstanceRequestsRequest,
  ) => stream.Stream<
    SpotInstanceRequest,
    DescribeSpotInstanceRequestsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeSpotInstanceRequestsRequest,
  output: DescribeSpotInstanceRequestsResult,
  errors: [
    RequestLimitExceeded,
    InvalidSpotInstanceRequestIDMalformed,
    ParseError,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SpotInstanceRequests",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeSpotPriceHistoryError = CommonErrors;
/**
 * Describes the Spot price history. For more information, see Spot Instance pricing history in the
 * *Amazon EC2 User Guide*.
 *
 * When you specify a start and end time, the operation returns the prices of the
 * instance types within that time range. It also returns the last price change before the
 * start time, which is the effective price as of the start time.
 */
export const describeSpotPriceHistory: API.OperationMethod<
  DescribeSpotPriceHistoryRequest,
  DescribeSpotPriceHistoryResult,
  DescribeSpotPriceHistoryError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeSpotPriceHistoryRequest,
  ) => stream.Stream<
    DescribeSpotPriceHistoryResult,
    DescribeSpotPriceHistoryError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeSpotPriceHistoryRequest,
  ) => stream.Stream<
    SpotPrice,
    DescribeSpotPriceHistoryError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeSpotPriceHistoryRequest,
  output: DescribeSpotPriceHistoryResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SpotPriceHistory",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeStaleSecurityGroupsError =
  | RequestLimitExceeded
  | InvalidVpcIDNotFound
  | CommonErrors;
/**
 * Describes the stale security group rules for security groups referenced across a VPC
 * peering connection, transit gateway connection, or with a security group VPC
 * association. Rules are stale when they reference a deleted security group. Rules can
 * also be stale if they reference a security group in a peer VPC for which the VPC peering
 * connection has been deleted, across a transit gateway where the transit gateway has been
 * deleted (or the transit
 * gateway security group referencing feature has been disabled), or if a
 * security group VPC association has been disassociated.
 */
export const describeStaleSecurityGroups: API.OperationMethod<
  DescribeStaleSecurityGroupsRequest,
  DescribeStaleSecurityGroupsResult,
  DescribeStaleSecurityGroupsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeStaleSecurityGroupsRequest,
  ) => stream.Stream<
    DescribeStaleSecurityGroupsResult,
    DescribeStaleSecurityGroupsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeStaleSecurityGroupsRequest,
  ) => stream.Stream<
    StaleSecurityGroup,
    DescribeStaleSecurityGroupsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeStaleSecurityGroupsRequest,
  output: DescribeStaleSecurityGroupsResult,
  errors: [RequestLimitExceeded, InvalidVpcIDNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "StaleSecurityGroupSet",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeStoreImageTasksError = CommonErrors;
/**
 * Describes the progress of the AMI store tasks. You can describe the store tasks for
 * specified AMIs. If you don't specify the AMIs, you get a paginated list of store tasks from
 * the last 31 days.
 *
 * For each AMI task, the response indicates if the task is `InProgress`,
 * `Completed`, or `Failed`. For tasks `InProgress`, the
 * response shows the estimated progress as a percentage.
 *
 * Tasks are listed in reverse chronological order. Currently, only tasks from the past 31
 * days can be viewed.
 *
 * To use this API, you must have the required permissions. For more information, see Permissions for storing and restoring AMIs using S3 in the
 * *Amazon EC2 User Guide*.
 *
 * For more information, see Store and restore an AMI using
 * S3 in the *Amazon EC2 User Guide*.
 */
export const describeStoreImageTasks: API.OperationMethod<
  DescribeStoreImageTasksRequest,
  DescribeStoreImageTasksResult,
  DescribeStoreImageTasksError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeStoreImageTasksRequest,
  ) => stream.Stream<
    DescribeStoreImageTasksResult,
    DescribeStoreImageTasksError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeStoreImageTasksRequest,
  ) => stream.Stream<
    StoreImageTaskResult,
    DescribeStoreImageTasksError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeStoreImageTasksRequest,
  output: DescribeStoreImageTasksResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "StoreImageTaskResults",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeSubnetsError =
  | RequestLimitExceeded
  | InvalidSubnetIDNotFound
  | ParseError
  | CommonErrors;
/**
 * Describes your subnets. The default is to describe all your subnets.
 * Alternatively, you can specify specific subnet IDs or filter the results to
 * include only the subnets that match specific criteria.
 *
 * For more information, see Subnets in the
 * *Amazon VPC User Guide*.
 */
export const describeSubnets: API.OperationMethod<
  DescribeSubnetsRequest,
  DescribeSubnetsResult,
  DescribeSubnetsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeSubnetsRequest,
  ) => stream.Stream<
    DescribeSubnetsResult,
    DescribeSubnetsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeSubnetsRequest,
  ) => stream.Stream<
    Subnet,
    DescribeSubnetsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeSubnetsRequest,
  output: DescribeSubnetsResult,
  errors: [RequestLimitExceeded, InvalidSubnetIDNotFound, ParseError],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Subnets",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeTagsError =
  | RequestLimitExceeded
  | ParseError
  | CommonErrors;
/**
 * Describes the specified tags for your EC2 resources.
 *
 * For more information about tags, see Tag your Amazon EC2 resources in the
 * *Amazon Elastic Compute Cloud User Guide*.
 *
 * We strongly recommend using only paginated requests. Unpaginated requests are
 * susceptible to throttling and timeouts.
 *
 * The order of the elements in the response, including those within nested
 * structures, might vary. Applications should not assume the elements appear in a
 * particular order.
 */
export const describeTags: API.OperationMethod<
  DescribeTagsRequest,
  DescribeTagsResult,
  DescribeTagsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeTagsRequest,
  ) => stream.Stream<
    DescribeTagsResult,
    DescribeTagsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeTagsRequest,
  ) => stream.Stream<
    TagDescription,
    DescribeTagsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeTagsRequest,
  output: DescribeTagsResult,
  errors: [RequestLimitExceeded, ParseError],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Tags",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeTrafficMirrorFilterRulesError = CommonErrors;
/**
 * Describe traffic mirror filters that determine the traffic that is mirrored.
 */
export const describeTrafficMirrorFilterRules: API.OperationMethod<
  DescribeTrafficMirrorFilterRulesRequest,
  DescribeTrafficMirrorFilterRulesResult,
  DescribeTrafficMirrorFilterRulesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeTrafficMirrorFilterRulesRequest,
  output: DescribeTrafficMirrorFilterRulesResult,
  errors: [],
}));
export type DescribeTrafficMirrorFiltersError =
  | RequestLimitExceeded
  | InvalidTrafficMirrorFilterIdNotFound
  | CommonErrors;
/**
 * Describes one or more Traffic Mirror filters.
 */
export const describeTrafficMirrorFilters: API.OperationMethod<
  DescribeTrafficMirrorFiltersRequest,
  DescribeTrafficMirrorFiltersResult,
  DescribeTrafficMirrorFiltersError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeTrafficMirrorFiltersRequest,
  ) => stream.Stream<
    DescribeTrafficMirrorFiltersResult,
    DescribeTrafficMirrorFiltersError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeTrafficMirrorFiltersRequest,
  ) => stream.Stream<
    TrafficMirrorFilter,
    DescribeTrafficMirrorFiltersError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeTrafficMirrorFiltersRequest,
  output: DescribeTrafficMirrorFiltersResult,
  errors: [RequestLimitExceeded, InvalidTrafficMirrorFilterIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TrafficMirrorFilters",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeTrafficMirrorSessionsError =
  | RequestLimitExceeded
  | InvalidTrafficMirrorSessionIdNotFound
  | CommonErrors;
/**
 * Describes one or more Traffic Mirror sessions. By default, all Traffic Mirror sessions are described. Alternatively, you can filter the results.
 */
export const describeTrafficMirrorSessions: API.OperationMethod<
  DescribeTrafficMirrorSessionsRequest,
  DescribeTrafficMirrorSessionsResult,
  DescribeTrafficMirrorSessionsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeTrafficMirrorSessionsRequest,
  ) => stream.Stream<
    DescribeTrafficMirrorSessionsResult,
    DescribeTrafficMirrorSessionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeTrafficMirrorSessionsRequest,
  ) => stream.Stream<
    TrafficMirrorSession,
    DescribeTrafficMirrorSessionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeTrafficMirrorSessionsRequest,
  output: DescribeTrafficMirrorSessionsResult,
  errors: [RequestLimitExceeded, InvalidTrafficMirrorSessionIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TrafficMirrorSessions",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeTrafficMirrorTargetsError =
  | RequestLimitExceeded
  | InvalidTrafficMirrorTargetIdNotFound
  | CommonErrors;
/**
 * Information about one or more Traffic Mirror targets.
 */
export const describeTrafficMirrorTargets: API.OperationMethod<
  DescribeTrafficMirrorTargetsRequest,
  DescribeTrafficMirrorTargetsResult,
  DescribeTrafficMirrorTargetsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeTrafficMirrorTargetsRequest,
  ) => stream.Stream<
    DescribeTrafficMirrorTargetsResult,
    DescribeTrafficMirrorTargetsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeTrafficMirrorTargetsRequest,
  ) => stream.Stream<
    TrafficMirrorTarget,
    DescribeTrafficMirrorTargetsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeTrafficMirrorTargetsRequest,
  output: DescribeTrafficMirrorTargetsResult,
  errors: [RequestLimitExceeded, InvalidTrafficMirrorTargetIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TrafficMirrorTargets",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeTransitGatewayAttachmentsError =
  | RequestLimitExceeded
  | InvalidTransitGatewayAttachmentIDNotFound
  | ParseError
  | CommonErrors;
/**
 * Describes one or more attachments between resources and transit gateways. By default, all attachments are described.
 * Alternatively, you can filter the results by attachment ID, attachment state, resource ID, or resource owner.
 */
export const describeTransitGatewayAttachments: API.OperationMethod<
  DescribeTransitGatewayAttachmentsRequest,
  DescribeTransitGatewayAttachmentsResult,
  DescribeTransitGatewayAttachmentsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeTransitGatewayAttachmentsRequest,
  ) => stream.Stream<
    DescribeTransitGatewayAttachmentsResult,
    DescribeTransitGatewayAttachmentsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeTransitGatewayAttachmentsRequest,
  ) => stream.Stream<
    TransitGatewayAttachment,
    DescribeTransitGatewayAttachmentsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeTransitGatewayAttachmentsRequest,
  output: DescribeTransitGatewayAttachmentsResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayAttachmentIDNotFound,
    ParseError,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TransitGatewayAttachments",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeTransitGatewayConnectPeersError =
  | RequestLimitExceeded
  | InvalidTransitGatewayConnectPeerIDNotFound
  | CommonErrors;
/**
 * Describes one or more Connect peers.
 */
export const describeTransitGatewayConnectPeers: API.OperationMethod<
  DescribeTransitGatewayConnectPeersRequest,
  DescribeTransitGatewayConnectPeersResult,
  DescribeTransitGatewayConnectPeersError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeTransitGatewayConnectPeersRequest,
  ) => stream.Stream<
    DescribeTransitGatewayConnectPeersResult,
    DescribeTransitGatewayConnectPeersError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeTransitGatewayConnectPeersRequest,
  ) => stream.Stream<
    TransitGatewayConnectPeer,
    DescribeTransitGatewayConnectPeersError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeTransitGatewayConnectPeersRequest,
  output: DescribeTransitGatewayConnectPeersResult,
  errors: [RequestLimitExceeded, InvalidTransitGatewayConnectPeerIDNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TransitGatewayConnectPeers",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeTransitGatewayConnectsError =
  | RequestLimitExceeded
  | InvalidTransitGatewayAttachmentIDNotFound
  | CommonErrors;
/**
 * Describes one or more Connect attachments.
 */
export const describeTransitGatewayConnects: API.OperationMethod<
  DescribeTransitGatewayConnectsRequest,
  DescribeTransitGatewayConnectsResult,
  DescribeTransitGatewayConnectsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeTransitGatewayConnectsRequest,
  ) => stream.Stream<
    DescribeTransitGatewayConnectsResult,
    DescribeTransitGatewayConnectsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeTransitGatewayConnectsRequest,
  ) => stream.Stream<
    TransitGatewayConnect,
    DescribeTransitGatewayConnectsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeTransitGatewayConnectsRequest,
  output: DescribeTransitGatewayConnectsResult,
  errors: [RequestLimitExceeded, InvalidTransitGatewayAttachmentIDNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TransitGatewayConnects",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeTransitGatewayMeteringPoliciesError =
  | RequestLimitExceeded
  | InvalidTransitGatewayMeteringPolicyIdNotFound
  | CommonErrors;
/**
 * Describes one or more transit gateway metering policies.
 */
export const describeTransitGatewayMeteringPolicies: API.OperationMethod<
  DescribeTransitGatewayMeteringPoliciesRequest,
  DescribeTransitGatewayMeteringPoliciesResult,
  DescribeTransitGatewayMeteringPoliciesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeTransitGatewayMeteringPoliciesRequest,
  output: DescribeTransitGatewayMeteringPoliciesResult,
  errors: [RequestLimitExceeded, InvalidTransitGatewayMeteringPolicyIdNotFound],
}));
export type DescribeTransitGatewayMulticastDomainsError =
  | RequestLimitExceeded
  | InvalidTransitGatewayMulticastDomainIdNotFound
  | CommonErrors;
/**
 * Describes one or more transit gateway multicast domains.
 */
export const describeTransitGatewayMulticastDomains: API.OperationMethod<
  DescribeTransitGatewayMulticastDomainsRequest,
  DescribeTransitGatewayMulticastDomainsResult,
  DescribeTransitGatewayMulticastDomainsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeTransitGatewayMulticastDomainsRequest,
  ) => stream.Stream<
    DescribeTransitGatewayMulticastDomainsResult,
    DescribeTransitGatewayMulticastDomainsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeTransitGatewayMulticastDomainsRequest,
  ) => stream.Stream<
    TransitGatewayMulticastDomain,
    DescribeTransitGatewayMulticastDomainsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeTransitGatewayMulticastDomainsRequest,
  output: DescribeTransitGatewayMulticastDomainsResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayMulticastDomainIdNotFound,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TransitGatewayMulticastDomains",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeTransitGatewayPeeringAttachmentsError =
  | RequestLimitExceeded
  | InvalidTransitGatewayAttachmentIDNotFound
  | CommonErrors;
/**
 * Describes your transit gateway peering attachments.
 */
export const describeTransitGatewayPeeringAttachments: API.OperationMethod<
  DescribeTransitGatewayPeeringAttachmentsRequest,
  DescribeTransitGatewayPeeringAttachmentsResult,
  DescribeTransitGatewayPeeringAttachmentsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeTransitGatewayPeeringAttachmentsRequest,
  ) => stream.Stream<
    DescribeTransitGatewayPeeringAttachmentsResult,
    DescribeTransitGatewayPeeringAttachmentsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeTransitGatewayPeeringAttachmentsRequest,
  ) => stream.Stream<
    TransitGatewayPeeringAttachment,
    DescribeTransitGatewayPeeringAttachmentsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeTransitGatewayPeeringAttachmentsRequest,
  output: DescribeTransitGatewayPeeringAttachmentsResult,
  errors: [RequestLimitExceeded, InvalidTransitGatewayAttachmentIDNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TransitGatewayPeeringAttachments",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeTransitGatewayPolicyTablesError =
  | RequestLimitExceeded
  | InvalidTransitGatewayPolicyTableIdNotFound
  | CommonErrors;
/**
 * Describes one or more transit gateway route policy tables.
 */
export const describeTransitGatewayPolicyTables: API.OperationMethod<
  DescribeTransitGatewayPolicyTablesRequest,
  DescribeTransitGatewayPolicyTablesResult,
  DescribeTransitGatewayPolicyTablesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeTransitGatewayPolicyTablesRequest,
  ) => stream.Stream<
    DescribeTransitGatewayPolicyTablesResult,
    DescribeTransitGatewayPolicyTablesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeTransitGatewayPolicyTablesRequest,
  ) => stream.Stream<
    TransitGatewayPolicyTable,
    DescribeTransitGatewayPolicyTablesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeTransitGatewayPolicyTablesRequest,
  output: DescribeTransitGatewayPolicyTablesResult,
  errors: [RequestLimitExceeded, InvalidTransitGatewayPolicyTableIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TransitGatewayPolicyTables",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeTransitGatewayRouteTableAnnouncementsError =
  | RequestLimitExceeded
  | InvalidTransitGatewayRouteTableAnnouncementIdMalformed
  | CommonErrors;
/**
 * Describes one or more transit gateway route table advertisements.
 */
export const describeTransitGatewayRouteTableAnnouncements: API.OperationMethod<
  DescribeTransitGatewayRouteTableAnnouncementsRequest,
  DescribeTransitGatewayRouteTableAnnouncementsResult,
  DescribeTransitGatewayRouteTableAnnouncementsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeTransitGatewayRouteTableAnnouncementsRequest,
  ) => stream.Stream<
    DescribeTransitGatewayRouteTableAnnouncementsResult,
    DescribeTransitGatewayRouteTableAnnouncementsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeTransitGatewayRouteTableAnnouncementsRequest,
  ) => stream.Stream<
    TransitGatewayRouteTableAnnouncement,
    DescribeTransitGatewayRouteTableAnnouncementsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeTransitGatewayRouteTableAnnouncementsRequest,
  output: DescribeTransitGatewayRouteTableAnnouncementsResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayRouteTableAnnouncementIdMalformed,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TransitGatewayRouteTableAnnouncements",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeTransitGatewayRouteTablesError =
  | RequestLimitExceeded
  | InvalidRouteTableIDNotFound
  | ParseError
  | CommonErrors;
/**
 * Describes one or more transit gateway route tables. By default, all transit gateway route tables are described.
 * Alternatively, you can filter the results.
 */
export const describeTransitGatewayRouteTables: API.OperationMethod<
  DescribeTransitGatewayRouteTablesRequest,
  DescribeTransitGatewayRouteTablesResult,
  DescribeTransitGatewayRouteTablesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeTransitGatewayRouteTablesRequest,
  ) => stream.Stream<
    DescribeTransitGatewayRouteTablesResult,
    DescribeTransitGatewayRouteTablesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeTransitGatewayRouteTablesRequest,
  ) => stream.Stream<
    TransitGatewayRouteTable,
    DescribeTransitGatewayRouteTablesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeTransitGatewayRouteTablesRequest,
  output: DescribeTransitGatewayRouteTablesResult,
  errors: [RequestLimitExceeded, InvalidRouteTableIDNotFound, ParseError],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TransitGatewayRouteTables",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeTransitGatewaysError =
  | RequestLimitExceeded
  | InvalidTransitGatewayIDNotFound
  | ParseError
  | CommonErrors;
/**
 * Describes one or more transit gateways. By default, all transit gateways are described. Alternatively, you can
 * filter the results.
 */
export const describeTransitGateways: API.OperationMethod<
  DescribeTransitGatewaysRequest,
  DescribeTransitGatewaysResult,
  DescribeTransitGatewaysError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeTransitGatewaysRequest,
  ) => stream.Stream<
    DescribeTransitGatewaysResult,
    DescribeTransitGatewaysError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeTransitGatewaysRequest,
  ) => stream.Stream<
    TransitGateway,
    DescribeTransitGatewaysError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeTransitGatewaysRequest,
  output: DescribeTransitGatewaysResult,
  errors: [RequestLimitExceeded, InvalidTransitGatewayIDNotFound, ParseError],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TransitGateways",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeTransitGatewayVpcAttachmentsError =
  | RequestLimitExceeded
  | InvalidTransitGatewayAttachmentIDNotFound
  | CommonErrors;
/**
 * Describes one or more VPC attachments. By default, all VPC attachments are described.
 * Alternatively, you can filter the results.
 */
export const describeTransitGatewayVpcAttachments: API.OperationMethod<
  DescribeTransitGatewayVpcAttachmentsRequest,
  DescribeTransitGatewayVpcAttachmentsResult,
  DescribeTransitGatewayVpcAttachmentsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeTransitGatewayVpcAttachmentsRequest,
  ) => stream.Stream<
    DescribeTransitGatewayVpcAttachmentsResult,
    DescribeTransitGatewayVpcAttachmentsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeTransitGatewayVpcAttachmentsRequest,
  ) => stream.Stream<
    TransitGatewayVpcAttachment,
    DescribeTransitGatewayVpcAttachmentsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeTransitGatewayVpcAttachmentsRequest,
  output: DescribeTransitGatewayVpcAttachmentsResult,
  errors: [RequestLimitExceeded, InvalidTransitGatewayAttachmentIDNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TransitGatewayVpcAttachments",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeTrunkInterfaceAssociationsError =
  | RequestLimitExceeded
  | OperationNotPermitted
  | CommonErrors;
/**
 * Describes one or more network interface trunk associations.
 */
export const describeTrunkInterfaceAssociations: API.OperationMethod<
  DescribeTrunkInterfaceAssociationsRequest,
  DescribeTrunkInterfaceAssociationsResult,
  DescribeTrunkInterfaceAssociationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeTrunkInterfaceAssociationsRequest,
  ) => stream.Stream<
    DescribeTrunkInterfaceAssociationsResult,
    DescribeTrunkInterfaceAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeTrunkInterfaceAssociationsRequest,
  ) => stream.Stream<
    TrunkInterfaceAssociation,
    DescribeTrunkInterfaceAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeTrunkInterfaceAssociationsRequest,
  output: DescribeTrunkInterfaceAssociationsResult,
  errors: [RequestLimitExceeded, OperationNotPermitted],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "InterfaceAssociations",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeVerifiedAccessEndpointsError =
  | RequestLimitExceeded
  | InvalidParameterCombination
  | CommonErrors;
/**
 * Describes the specified Amazon Web Services Verified Access endpoints.
 */
export const describeVerifiedAccessEndpoints: API.OperationMethod<
  DescribeVerifiedAccessEndpointsRequest,
  DescribeVerifiedAccessEndpointsResult,
  DescribeVerifiedAccessEndpointsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeVerifiedAccessEndpointsRequest,
  ) => stream.Stream<
    DescribeVerifiedAccessEndpointsResult,
    DescribeVerifiedAccessEndpointsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeVerifiedAccessEndpointsRequest,
  ) => stream.Stream<
    VerifiedAccessEndpoint,
    DescribeVerifiedAccessEndpointsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeVerifiedAccessEndpointsRequest,
  output: DescribeVerifiedAccessEndpointsResult,
  errors: [RequestLimitExceeded, InvalidParameterCombination],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "VerifiedAccessEndpoints",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeVerifiedAccessGroupsError =
  | RequestLimitExceeded
  | InvalidVerifiedAccessGroupIdNotFound
  | CommonErrors;
/**
 * Describes the specified Verified Access groups.
 */
export const describeVerifiedAccessGroups: API.OperationMethod<
  DescribeVerifiedAccessGroupsRequest,
  DescribeVerifiedAccessGroupsResult,
  DescribeVerifiedAccessGroupsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeVerifiedAccessGroupsRequest,
  ) => stream.Stream<
    DescribeVerifiedAccessGroupsResult,
    DescribeVerifiedAccessGroupsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeVerifiedAccessGroupsRequest,
  ) => stream.Stream<
    VerifiedAccessGroup,
    DescribeVerifiedAccessGroupsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeVerifiedAccessGroupsRequest,
  output: DescribeVerifiedAccessGroupsResult,
  errors: [RequestLimitExceeded, InvalidVerifiedAccessGroupIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "VerifiedAccessGroups",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeVerifiedAccessInstanceLoggingConfigurationsError =
  | RequestLimitExceeded
  | InvalidVerifiedAccessInstanceIdNotFound
  | CommonErrors;
/**
 * Describes the specified Amazon Web Services Verified Access instances.
 */
export const describeVerifiedAccessInstanceLoggingConfigurations: API.OperationMethod<
  DescribeVerifiedAccessInstanceLoggingConfigurationsRequest,
  DescribeVerifiedAccessInstanceLoggingConfigurationsResult,
  DescribeVerifiedAccessInstanceLoggingConfigurationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeVerifiedAccessInstanceLoggingConfigurationsRequest,
  ) => stream.Stream<
    DescribeVerifiedAccessInstanceLoggingConfigurationsResult,
    DescribeVerifiedAccessInstanceLoggingConfigurationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeVerifiedAccessInstanceLoggingConfigurationsRequest,
  ) => stream.Stream<
    VerifiedAccessInstanceLoggingConfiguration,
    DescribeVerifiedAccessInstanceLoggingConfigurationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeVerifiedAccessInstanceLoggingConfigurationsRequest,
  output: DescribeVerifiedAccessInstanceLoggingConfigurationsResult,
  errors: [RequestLimitExceeded, InvalidVerifiedAccessInstanceIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "LoggingConfigurations",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeVerifiedAccessInstancesError =
  | RequestLimitExceeded
  | InvalidVerifiedAccessInstanceIdNotFound
  | CommonErrors;
/**
 * Describes the specified Amazon Web Services Verified Access instances.
 */
export const describeVerifiedAccessInstances: API.OperationMethod<
  DescribeVerifiedAccessInstancesRequest,
  DescribeVerifiedAccessInstancesResult,
  DescribeVerifiedAccessInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeVerifiedAccessInstancesRequest,
  ) => stream.Stream<
    DescribeVerifiedAccessInstancesResult,
    DescribeVerifiedAccessInstancesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeVerifiedAccessInstancesRequest,
  ) => stream.Stream<
    VerifiedAccessInstance,
    DescribeVerifiedAccessInstancesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeVerifiedAccessInstancesRequest,
  output: DescribeVerifiedAccessInstancesResult,
  errors: [RequestLimitExceeded, InvalidVerifiedAccessInstanceIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "VerifiedAccessInstances",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeVerifiedAccessTrustProvidersError =
  | RequestLimitExceeded
  | InvalidVerifiedAccessTrustProviderIdNotFound
  | CommonErrors;
/**
 * Describes the specified Amazon Web Services Verified Access trust providers.
 */
export const describeVerifiedAccessTrustProviders: API.OperationMethod<
  DescribeVerifiedAccessTrustProvidersRequest,
  DescribeVerifiedAccessTrustProvidersResult,
  DescribeVerifiedAccessTrustProvidersError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeVerifiedAccessTrustProvidersRequest,
  ) => stream.Stream<
    DescribeVerifiedAccessTrustProvidersResult,
    DescribeVerifiedAccessTrustProvidersError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeVerifiedAccessTrustProvidersRequest,
  ) => stream.Stream<
    VerifiedAccessTrustProvider,
    DescribeVerifiedAccessTrustProvidersError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeVerifiedAccessTrustProvidersRequest,
  output: DescribeVerifiedAccessTrustProvidersResult,
  errors: [RequestLimitExceeded, InvalidVerifiedAccessTrustProviderIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "VerifiedAccessTrustProviders",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeVolumeAttributeError =
  | RequestLimitExceeded
  | InvalidParameterCombination
  | InvalidParameterValue
  | InvalidVolumeNotFound
  | CommonErrors;
/**
 * Describes the specified attribute of the specified volume. You can specify only one
 * attribute at a time.
 *
 * For more information about EBS volumes, see Amazon EBS volumes in the *Amazon EBS User Guide*.
 */
export const describeVolumeAttribute: API.OperationMethod<
  DescribeVolumeAttributeRequest,
  DescribeVolumeAttributeResult,
  DescribeVolumeAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeVolumeAttributeRequest,
  output: DescribeVolumeAttributeResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterCombination,
    InvalidParameterValue,
    InvalidVolumeNotFound,
  ],
}));
export type DescribeVolumesError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidVolumeNotFound
  | ParseError
  | CommonErrors;
/**
 * Describes the specified EBS volumes or all of your EBS volumes.
 *
 * If you are describing a long list of volumes, we recommend that you paginate the output to make the list
 * more manageable. For more information, see Pagination.
 *
 * For more information about EBS volumes, see Amazon EBS volumes in the *Amazon EBS User Guide*.
 *
 * We strongly recommend using only paginated requests. Unpaginated requests are
 * susceptible to throttling and timeouts.
 *
 * The order of the elements in the response, including those within nested
 * structures, might vary. Applications should not assume the elements appear in a
 * particular order.
 */
export const describeVolumes: API.OperationMethod<
  DescribeVolumesRequest,
  DescribeVolumesResult,
  DescribeVolumesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeVolumesRequest,
  ) => stream.Stream<
    DescribeVolumesResult,
    DescribeVolumesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeVolumesRequest,
  ) => stream.Stream<
    Volume,
    DescribeVolumesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeVolumesRequest,
  output: DescribeVolumesResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidVolumeNotFound,
    ParseError,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Volumes",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeVolumesModificationsError =
  | RequestLimitExceeded
  | InvalidVolumeIDMalformed
  | CommonErrors;
/**
 * Describes the most recent volume modification request for the specified EBS volumes.
 *
 * For more information, see
 * Monitor the progress of volume modifications in the *Amazon EBS User Guide*.
 */
export const describeVolumesModifications: API.OperationMethod<
  DescribeVolumesModificationsRequest,
  DescribeVolumesModificationsResult,
  DescribeVolumesModificationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeVolumesModificationsRequest,
  ) => stream.Stream<
    DescribeVolumesModificationsResult,
    DescribeVolumesModificationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeVolumesModificationsRequest,
  ) => stream.Stream<
    VolumeModification,
    DescribeVolumesModificationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeVolumesModificationsRequest,
  output: DescribeVolumesModificationsResult,
  errors: [RequestLimitExceeded, InvalidVolumeIDMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "VolumesModifications",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeVolumeStatusError =
  | RequestLimitExceeded
  | InvalidVolumeIDMalformed
  | CommonErrors;
/**
 * Describes the status of the specified volumes. Volume status provides the result of the
 * checks performed on your volumes to determine events that can impair the performance of your
 * volumes. The performance of a volume can be affected if an issue occurs on the volume's
 * underlying host. If the volume's underlying host experiences a power outage or system issue,
 * after the system is restored, there could be data inconsistencies on the volume. Volume events
 * notify you if this occurs. Volume actions notify you if any action needs to be taken in
 * response to the event.
 *
 * The `DescribeVolumeStatus` operation provides the following information about
 * the specified volumes:
 *
 * *Status*: Reflects the current status of the volume. The possible
 * values are `ok`, `impaired` , `warning`, or
 * `insufficient-data`. If all checks pass, the overall status of the volume is
 * `ok`. If the check fails, the overall status is `impaired`. If the
 * status is `insufficient-data`, then the checks might still be taking place on your
 * volume at the time. We recommend that you retry the request. For more information about volume
 * status, see Monitor the status of your volumes in the *Amazon EBS User Guide*.
 *
 * *Events*: Reflect the cause of a volume status and might require you to
 * take action. For example, if your volume returns an `impaired` status, then the
 * volume event might be `potential-data-inconsistency`. This means that your volume
 * has been affected by an issue with the underlying host, has all I/O operations disabled, and
 * might have inconsistent data.
 *
 * *Actions*: Reflect the actions you might have to take in response to an
 * event. For example, if the status of the volume is `impaired` and the volume event
 * shows `potential-data-inconsistency`, then the action shows
 * `enable-volume-io`. This means that you may want to enable the I/O operations for
 * the volume and then check the volume for data consistency. For more information, see
 * Work with an
 * impaired EBS volume.
 *
 * Volume status is based on the volume status checks, and does not reflect the volume state.
 * Therefore, volume status does not indicate volumes in the `error` state (for
 * example, when a volume is incapable of accepting I/O.)
 *
 * The order of the elements in the response, including those within nested
 * structures, might vary. Applications should not assume the elements appear in a
 * particular order.
 */
export const describeVolumeStatus: API.OperationMethod<
  DescribeVolumeStatusRequest,
  DescribeVolumeStatusResult,
  DescribeVolumeStatusError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeVolumeStatusRequest,
  ) => stream.Stream<
    DescribeVolumeStatusResult,
    DescribeVolumeStatusError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeVolumeStatusRequest,
  ) => stream.Stream<
    VolumeStatusItem,
    DescribeVolumeStatusError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeVolumeStatusRequest,
  output: DescribeVolumeStatusResult,
  errors: [RequestLimitExceeded, InvalidVolumeIDMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "VolumeStatuses",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeVpcAttributeError =
  | RequestLimitExceeded
  | InvalidParameterCombination
  | InvalidVpcIDNotFound
  | CommonErrors;
/**
 * Describes the specified attribute of the specified VPC. You can specify only one attribute at a time.
 */
export const describeVpcAttribute: API.OperationMethod<
  DescribeVpcAttributeRequest,
  DescribeVpcAttributeResult,
  DescribeVpcAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeVpcAttributeRequest,
  output: DescribeVpcAttributeResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterCombination,
    InvalidVpcIDNotFound,
  ],
}));
export type DescribeVpcBlockPublicAccessExclusionsError =
  | RequestLimitExceeded
  | MissingParameter
  | VpcBlockPublicAccessExclusionIdMalformed
  | CommonErrors;
/**
 * Describe VPC Block Public Access (BPA) exclusions. A VPC BPA exclusion is a mode that can be applied to a single VPC or subnet that exempts it from the accounts BPA mode and will allow bidirectional or egress-only access. You can create BPA exclusions for VPCs and subnets even when BPA is not enabled on the account to ensure that there is no traffic disruption to the exclusions when VPC BPA is turned on. To learn more about VPC BPA, see Block public access to VPCs and subnets in the *Amazon VPC User Guide*.
 */
export const describeVpcBlockPublicAccessExclusions: API.OperationMethod<
  DescribeVpcBlockPublicAccessExclusionsRequest,
  DescribeVpcBlockPublicAccessExclusionsResult,
  DescribeVpcBlockPublicAccessExclusionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeVpcBlockPublicAccessExclusionsRequest,
  output: DescribeVpcBlockPublicAccessExclusionsResult,
  errors: [
    RequestLimitExceeded,
    MissingParameter,
    VpcBlockPublicAccessExclusionIdMalformed,
  ],
}));
export type DescribeVpcBlockPublicAccessOptionsError = CommonErrors;
/**
 * Describe VPC Block Public Access (BPA) options. VPC Block Public Access (BPA) enables you to block resources in VPCs and subnets that you own in a Region from reaching or being reached from the internet through internet gateways and egress-only internet gateways. To learn more about VPC BPA, see Block public access to VPCs and subnets in the *Amazon VPC User Guide*.
 */
export const describeVpcBlockPublicAccessOptions: API.OperationMethod<
  DescribeVpcBlockPublicAccessOptionsRequest,
  DescribeVpcBlockPublicAccessOptionsResult,
  DescribeVpcBlockPublicAccessOptionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeVpcBlockPublicAccessOptionsRequest,
  output: DescribeVpcBlockPublicAccessOptionsResult,
  errors: [],
}));
export type DescribeVpcClassicLinkError =
  | RequestLimitExceeded
  | InvalidVpcIDNotFound
  | InvalidVpcIdMalformed
  | CommonErrors;
/**
 * This action is deprecated.
 *
 * Describes the ClassicLink status of the specified VPCs.
 */
export const describeVpcClassicLink: API.OperationMethod<
  DescribeVpcClassicLinkRequest,
  DescribeVpcClassicLinkResult,
  DescribeVpcClassicLinkError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeVpcClassicLinkRequest,
  output: DescribeVpcClassicLinkResult,
  errors: [RequestLimitExceeded, InvalidVpcIDNotFound, InvalidVpcIdMalformed],
}));
export type DescribeVpcClassicLinkDnsSupportError =
  | RequestLimitExceeded
  | InvalidVpcIDNotFound
  | CommonErrors;
/**
 * This action is deprecated.
 *
 * Describes the ClassicLink DNS support status of one or more VPCs. If enabled, the DNS
 * hostname of a linked EC2-Classic instance resolves to its private IP address when
 * addressed from an instance in the VPC to which it's linked. Similarly, the DNS hostname
 * of an instance in a VPC resolves to its private IP address when addressed from a linked
 * EC2-Classic instance.
 */
export const describeVpcClassicLinkDnsSupport: API.OperationMethod<
  DescribeVpcClassicLinkDnsSupportRequest,
  DescribeVpcClassicLinkDnsSupportResult,
  DescribeVpcClassicLinkDnsSupportError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeVpcClassicLinkDnsSupportRequest,
  ) => stream.Stream<
    DescribeVpcClassicLinkDnsSupportResult,
    DescribeVpcClassicLinkDnsSupportError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeVpcClassicLinkDnsSupportRequest,
  ) => stream.Stream<
    ClassicLinkDnsSupport,
    DescribeVpcClassicLinkDnsSupportError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeVpcClassicLinkDnsSupportRequest,
  output: DescribeVpcClassicLinkDnsSupportResult,
  errors: [RequestLimitExceeded, InvalidVpcIDNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Vpcs",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeVpcEncryptionControlsError =
  | RequestLimitExceeded
  | InvalidParameterCombination
  | CommonErrors;
/**
 * Describes one or more VPC Encryption Control configurations. VPC Encryption Control enables you to enforce encryption for all data in transit within and between VPCs to meet compliance requirements You can filter the results to return information about specific encryption controls or VPCs.
 *
 * For more information, see Enforce VPC encryption in transit in the *Amazon VPC User Guide*.
 */
export const describeVpcEncryptionControls: API.OperationMethod<
  DescribeVpcEncryptionControlsRequest,
  DescribeVpcEncryptionControlsResult,
  DescribeVpcEncryptionControlsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeVpcEncryptionControlsRequest,
  output: DescribeVpcEncryptionControlsResult,
  errors: [RequestLimitExceeded, InvalidParameterCombination],
}));
export type DescribeVpcEndpointAssociationsError = CommonErrors;
/**
 * Describes the VPC resources, VPC endpoint services, Amazon Lattice services, or service networks
 * associated with the VPC endpoint.
 */
export const describeVpcEndpointAssociations: API.OperationMethod<
  DescribeVpcEndpointAssociationsRequest,
  DescribeVpcEndpointAssociationsResult,
  DescribeVpcEndpointAssociationsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeVpcEndpointAssociationsRequest,
  output: DescribeVpcEndpointAssociationsResult,
  errors: [],
}));
export type DescribeVpcEndpointConnectionNotificationsError =
  | RequestLimitExceeded
  | InvalidConnectionNotification
  | CommonErrors;
/**
 * Describes the connection notifications for VPC endpoints and VPC endpoint
 * services.
 */
export const describeVpcEndpointConnectionNotifications: API.OperationMethod<
  DescribeVpcEndpointConnectionNotificationsRequest,
  DescribeVpcEndpointConnectionNotificationsResult,
  DescribeVpcEndpointConnectionNotificationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeVpcEndpointConnectionNotificationsRequest,
  ) => stream.Stream<
    DescribeVpcEndpointConnectionNotificationsResult,
    DescribeVpcEndpointConnectionNotificationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeVpcEndpointConnectionNotificationsRequest,
  ) => stream.Stream<
    ConnectionNotification,
    DescribeVpcEndpointConnectionNotificationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeVpcEndpointConnectionNotificationsRequest,
  output: DescribeVpcEndpointConnectionNotificationsResult,
  errors: [RequestLimitExceeded, InvalidConnectionNotification],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ConnectionNotificationSet",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeVpcEndpointConnectionsError = CommonErrors;
/**
 * Describes the VPC endpoint connections to your VPC endpoint services, including any
 * endpoints that are pending your acceptance.
 */
export const describeVpcEndpointConnections: API.OperationMethod<
  DescribeVpcEndpointConnectionsRequest,
  DescribeVpcEndpointConnectionsResult,
  DescribeVpcEndpointConnectionsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeVpcEndpointConnectionsRequest,
  ) => stream.Stream<
    DescribeVpcEndpointConnectionsResult,
    DescribeVpcEndpointConnectionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeVpcEndpointConnectionsRequest,
  ) => stream.Stream<
    VpcEndpointConnection,
    DescribeVpcEndpointConnectionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeVpcEndpointConnectionsRequest,
  output: DescribeVpcEndpointConnectionsResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "VpcEndpointConnections",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeVpcEndpointsError =
  | RequestLimitExceeded
  | InvalidVpcEndpointIdNotFound
  | ParseError
  | CommonErrors;
/**
 * Describes your VPC endpoints. The default is to describe all your VPC endpoints.
 * Alternatively, you can specify specific VPC endpoint IDs or filter the results to
 * include only the VPC endpoints that match specific criteria.
 */
export const describeVpcEndpoints: API.OperationMethod<
  DescribeVpcEndpointsRequest,
  DescribeVpcEndpointsResult,
  DescribeVpcEndpointsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeVpcEndpointsRequest,
  ) => stream.Stream<
    DescribeVpcEndpointsResult,
    DescribeVpcEndpointsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeVpcEndpointsRequest,
  ) => stream.Stream<
    VpcEndpoint,
    DescribeVpcEndpointsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeVpcEndpointsRequest,
  output: DescribeVpcEndpointsResult,
  errors: [RequestLimitExceeded, InvalidVpcEndpointIdNotFound, ParseError],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "VpcEndpoints",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeVpcEndpointServiceConfigurationsError =
  | RequestLimitExceeded
  | InvalidVpcEndpointServiceIdNotFound
  | CommonErrors;
/**
 * Describes the VPC endpoint service configurations in your account (your services).
 */
export const describeVpcEndpointServiceConfigurations: API.OperationMethod<
  DescribeVpcEndpointServiceConfigurationsRequest,
  DescribeVpcEndpointServiceConfigurationsResult,
  DescribeVpcEndpointServiceConfigurationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeVpcEndpointServiceConfigurationsRequest,
  ) => stream.Stream<
    DescribeVpcEndpointServiceConfigurationsResult,
    DescribeVpcEndpointServiceConfigurationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeVpcEndpointServiceConfigurationsRequest,
  ) => stream.Stream<
    ServiceConfiguration,
    DescribeVpcEndpointServiceConfigurationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeVpcEndpointServiceConfigurationsRequest,
  output: DescribeVpcEndpointServiceConfigurationsResult,
  errors: [RequestLimitExceeded, InvalidVpcEndpointServiceIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ServiceConfigurations",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeVpcEndpointServicePermissionsError =
  | RequestLimitExceeded
  | InvalidVpcEndpointServiceIdMalformed
  | InvalidVpcEndpointServiceIdNotFound
  | CommonErrors;
/**
 * Describes the principals (service consumers) that are permitted to discover your VPC
 * endpoint service. Principal ARNs with path components aren't supported.
 */
export const describeVpcEndpointServicePermissions: API.OperationMethod<
  DescribeVpcEndpointServicePermissionsRequest,
  DescribeVpcEndpointServicePermissionsResult,
  DescribeVpcEndpointServicePermissionsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeVpcEndpointServicePermissionsRequest,
  ) => stream.Stream<
    DescribeVpcEndpointServicePermissionsResult,
    DescribeVpcEndpointServicePermissionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeVpcEndpointServicePermissionsRequest,
  ) => stream.Stream<
    AllowedPrincipal,
    DescribeVpcEndpointServicePermissionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeVpcEndpointServicePermissionsRequest,
  output: DescribeVpcEndpointServicePermissionsResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcEndpointServiceIdMalformed,
    InvalidVpcEndpointServiceIdNotFound,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AllowedPrincipals",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeVpcEndpointServicesError =
  | RequestLimitExceeded
  | ParseError
  | CommonErrors;
/**
 * Describes available services to which you can create a VPC endpoint.
 *
 * When the service provider and the consumer have different accounts in multiple
 * Availability Zones, and the consumer views the VPC endpoint service information, the
 * response only includes the common Availability Zones. For example, when the service
 * provider account uses `us-east-1a` and `us-east-1c` and the
 * consumer uses `us-east-1a` and `us-east-1b`, the response includes
 * the VPC endpoint services in the common Availability Zone,
 * `us-east-1a`.
 */
export const describeVpcEndpointServices: API.OperationMethod<
  DescribeVpcEndpointServicesRequest,
  DescribeVpcEndpointServicesResult,
  DescribeVpcEndpointServicesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeVpcEndpointServicesRequest,
  output: DescribeVpcEndpointServicesResult,
  errors: [RequestLimitExceeded, ParseError],
}));
export type DescribeVpcPeeringConnectionsError =
  | RequestLimitExceeded
  | InvalidVpcPeeringConnectionIDNotFound
  | ParseError
  | CommonErrors;
/**
 * Describes your VPC peering connections. The default is to describe all your VPC peering connections.
 * Alternatively, you can specify specific VPC peering connection IDs or filter the results to
 * include only the VPC peering connections that match specific criteria.
 */
export const describeVpcPeeringConnections: API.OperationMethod<
  DescribeVpcPeeringConnectionsRequest,
  DescribeVpcPeeringConnectionsResult,
  DescribeVpcPeeringConnectionsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeVpcPeeringConnectionsRequest,
  ) => stream.Stream<
    DescribeVpcPeeringConnectionsResult,
    DescribeVpcPeeringConnectionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeVpcPeeringConnectionsRequest,
  ) => stream.Stream<
    VpcPeeringConnection,
    DescribeVpcPeeringConnectionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeVpcPeeringConnectionsRequest,
  output: DescribeVpcPeeringConnectionsResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcPeeringConnectionIDNotFound,
    ParseError,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "VpcPeeringConnections",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeVpcsError =
  | RequestLimitExceeded
  | InvalidVpcIDNotFound
  | ParseError
  | RequestError
  | CommonErrors;
/**
 * Describes your VPCs. The default is to describe all your VPCs.
 * Alternatively, you can specify specific VPC IDs or filter the results to
 * include only the VPCs that match specific criteria.
 */
export const describeVpcs: API.OperationMethod<
  DescribeVpcsRequest,
  DescribeVpcsResult,
  DescribeVpcsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeVpcsRequest,
  ) => stream.Stream<
    DescribeVpcsResult,
    DescribeVpcsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeVpcsRequest,
  ) => stream.Stream<
    Vpc,
    DescribeVpcsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeVpcsRequest,
  output: DescribeVpcsResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcIDNotFound,
    ParseError,
    RequestError,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Vpcs",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeVpnConcentratorsError =
  | RequestLimitExceeded
  | InvalidVpnConcentratorIdMalformed
  | CommonErrors;
/**
 * Describes one or more of your VPN concentrators.
 */
export const describeVpnConcentrators: API.OperationMethod<
  DescribeVpnConcentratorsRequest,
  DescribeVpnConcentratorsResult,
  DescribeVpnConcentratorsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: DescribeVpnConcentratorsRequest,
  ) => stream.Stream<
    DescribeVpnConcentratorsResult,
    DescribeVpnConcentratorsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: DescribeVpnConcentratorsRequest,
  ) => stream.Stream<
    VpnConcentrator,
    DescribeVpnConcentratorsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeVpnConcentratorsRequest,
  output: DescribeVpnConcentratorsResult,
  errors: [RequestLimitExceeded, InvalidVpnConcentratorIdMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "VpnConcentrators",
    pageSize: "MaxResults",
  } as const,
}));
export type DescribeVpnConnectionsError =
  | RequestLimitExceeded
  | InvalidVpnConnectionIDNotFound
  | CommonErrors;
/**
 * Describes one or more of your VPN connections.
 *
 * For more information, see Amazon Web Services Site-to-Site VPN in the Amazon Web Services Site-to-Site VPN
 * User Guide.
 */
export const describeVpnConnections: API.OperationMethod<
  DescribeVpnConnectionsRequest,
  DescribeVpnConnectionsResult,
  DescribeVpnConnectionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeVpnConnectionsRequest,
  output: DescribeVpnConnectionsResult,
  errors: [RequestLimitExceeded, InvalidVpnConnectionIDNotFound],
}));
export type DescribeVpnGatewaysError =
  | RequestLimitExceeded
  | InvalidVpnGatewayIDNotFound
  | ParseError
  | CommonErrors;
/**
 * Describes one or more of your virtual private gateways.
 *
 * For more information, see Amazon Web Services Site-to-Site VPN in the Amazon Web Services Site-to-Site VPN
 * User Guide.
 */
export const describeVpnGateways: API.OperationMethod<
  DescribeVpnGatewaysRequest,
  DescribeVpnGatewaysResult,
  DescribeVpnGatewaysError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeVpnGatewaysRequest,
  output: DescribeVpnGatewaysResult,
  errors: [RequestLimitExceeded, InvalidVpnGatewayIDNotFound, ParseError],
}));
export type DetachClassicLinkVpcError =
  | RequestLimitExceeded
  | DependencyViolation
  | InvalidInstanceIDMalformed
  | InvalidVpcIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * This action is deprecated.
 *
 * Unlinks (detaches) a linked EC2-Classic instance from a VPC. After the instance has been unlinked,
 * the VPC security groups are no longer associated with it. An instance is automatically unlinked from
 * a VPC when it's stopped.
 */
export const detachClassicLinkVpc: API.OperationMethod<
  DetachClassicLinkVpcRequest,
  DetachClassicLinkVpcResult,
  DetachClassicLinkVpcError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DetachClassicLinkVpcRequest,
  output: DetachClassicLinkVpcResult,
  errors: [
    RequestLimitExceeded,
    DependencyViolation,
    InvalidInstanceIDMalformed,
    InvalidVpcIDNotFound,
    MissingParameter,
  ],
}));
export type DetachInternetGatewayError =
  | RequestLimitExceeded
  | DependencyViolation
  | GatewayNotAttached
  | InvalidInternetGatewayIDNotFound
  | InvalidInternetGatewayIdMalformed
  | InvalidVpcIdMalformed
  | CommonErrors;
/**
 * Detaches an internet gateway from a VPC, disabling connectivity between the internet
 * and the VPC. The VPC must not contain any running instances with Elastic IP addresses or
 * public IPv4 addresses.
 */
export const detachInternetGateway: API.OperationMethod<
  DetachInternetGatewayRequest,
  DetachInternetGatewayResponse,
  DetachInternetGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DetachInternetGatewayRequest,
  output: DetachInternetGatewayResponse,
  errors: [
    RequestLimitExceeded,
    DependencyViolation,
    GatewayNotAttached,
    InvalidInternetGatewayIDNotFound,
    InvalidInternetGatewayIdMalformed,
    InvalidVpcIdMalformed,
  ],
}));
export type DetachNetworkInterfaceError =
  | RequestLimitExceeded
  | DependencyViolation
  | InvalidAttachmentIDNotFound
  | InvalidNetworkInterfaceAttachmentIdMalformed
  | CommonErrors;
/**
 * Detaches a network interface from an instance.
 */
export const detachNetworkInterface: API.OperationMethod<
  DetachNetworkInterfaceRequest,
  DetachNetworkInterfaceResponse,
  DetachNetworkInterfaceError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DetachNetworkInterfaceRequest,
  output: DetachNetworkInterfaceResponse,
  errors: [
    RequestLimitExceeded,
    DependencyViolation,
    InvalidAttachmentIDNotFound,
    InvalidNetworkInterfaceAttachmentIdMalformed,
  ],
}));
export type DetachVerifiedAccessTrustProviderError =
  | RequestLimitExceeded
  | DependencyViolation
  | InvalidVerifiedAccessInstanceIdNotFound
  | CommonErrors;
/**
 * Detaches the specified Amazon Web Services Verified Access trust provider from the specified Amazon Web Services Verified Access instance.
 */
export const detachVerifiedAccessTrustProvider: API.OperationMethod<
  DetachVerifiedAccessTrustProviderRequest,
  DetachVerifiedAccessTrustProviderResult,
  DetachVerifiedAccessTrustProviderError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DetachVerifiedAccessTrustProviderRequest,
  output: DetachVerifiedAccessTrustProviderResult,
  errors: [
    RequestLimitExceeded,
    DependencyViolation,
    InvalidVerifiedAccessInstanceIdNotFound,
  ],
}));
export type DetachVolumeError =
  | RequestLimitExceeded
  | DependencyViolation
  | IncorrectState
  | InvalidParameterValue
  | InvalidVolumeNotFound
  | CommonErrors;
/**
 * Detaches an EBS volume from an instance. Make sure to unmount any file systems on the
 * device within your operating system before detaching the volume. Failure to do so can result
 * in the volume becoming stuck in the `busy` state while detaching. If this happens,
 * detachment can be delayed indefinitely until you unmount the volume, force detachment, reboot
 * the instance, or all three. If an EBS volume is the root device of an instance, it can't be
 * detached while the instance is running. To detach the root volume, stop the instance
 * first.
 *
 * When a volume with an Amazon Web Services Marketplace product code is detached from an instance, the
 * product code is no longer associated with the instance.
 *
 * You can't detach or force detach volumes that are attached to Amazon Web Services-managed resources.
 * Attempting to do this results in the `UnsupportedOperationException`
 * exception.
 *
 * For more information, see Detach an Amazon EBS volume in the
 * *Amazon EBS User Guide*.
 */
export const detachVolume: API.OperationMethod<
  DetachVolumeRequest,
  VolumeAttachment,
  DetachVolumeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DetachVolumeRequest,
  output: VolumeAttachment,
  errors: [
    RequestLimitExceeded,
    DependencyViolation,
    IncorrectState,
    InvalidParameterValue,
    InvalidVolumeNotFound,
  ],
}));
export type DetachVpnGatewayError =
  | RequestLimitExceeded
  | DependencyViolation
  | IncorrectState
  | InvalidVpnGatewayIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Detaches a virtual private gateway from a VPC. You do this if you're planning to turn
 * off the VPC and not use it anymore. You can confirm a virtual private gateway has been
 * completely detached from a VPC by describing the virtual private gateway (any
 * attachments to the virtual private gateway are also described).
 *
 * You must wait for the attachment's state to switch to `detached` before you
 * can delete the VPC or attach a different VPC to the virtual private gateway.
 */
export const detachVpnGateway: API.OperationMethod<
  DetachVpnGatewayRequest,
  DetachVpnGatewayResponse,
  DetachVpnGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DetachVpnGatewayRequest,
  output: DetachVpnGatewayResponse,
  errors: [
    RequestLimitExceeded,
    DependencyViolation,
    IncorrectState,
    InvalidVpnGatewayIDNotFound,
    MissingParameter,
  ],
}));
export type DisableAddressTransferError =
  | RequestLimitExceeded
  | InvalidElasticIpIDNotFound
  | CommonErrors;
/**
 * Disables Elastic IP address transfer. For more information, see Transfer Elastic IP addresses in the *Amazon VPC User Guide*.
 */
export const disableAddressTransfer: API.OperationMethod<
  DisableAddressTransferRequest,
  DisableAddressTransferResult,
  DisableAddressTransferError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableAddressTransferRequest,
  output: DisableAddressTransferResult,
  errors: [RequestLimitExceeded, InvalidElasticIpIDNotFound],
}));
export type DisableAllowedImagesSettingsError = CommonErrors;
/**
 * Disables Allowed AMIs for your account in the specified Amazon Web Services Region. When set to
 * `disabled`, the image criteria in your Allowed AMIs settings do not apply, and no
 * restrictions are placed on AMI discoverability or usage. Users in your account can launch
 * instances using any public AMI or AMI shared with your account.
 *
 * The Allowed AMIs feature does not restrict the AMIs owned by your account. Regardless of
 * the criteria you set, the AMIs created by your account will always be discoverable and
 * usable by users in your account.
 *
 * For more information, see Control the discovery and use of AMIs in
 * Amazon EC2 with Allowed AMIs in
 * *Amazon EC2 User Guide*.
 */
export const disableAllowedImagesSettings: API.OperationMethod<
  DisableAllowedImagesSettingsRequest,
  DisableAllowedImagesSettingsResult,
  DisableAllowedImagesSettingsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableAllowedImagesSettingsRequest,
  output: DisableAllowedImagesSettingsResult,
  errors: [],
}));
export type DisableAwsNetworkPerformanceMetricSubscriptionError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Disables Infrastructure Performance metric subscriptions.
 */
export const disableAwsNetworkPerformanceMetricSubscription: API.OperationMethod<
  DisableAwsNetworkPerformanceMetricSubscriptionRequest,
  DisableAwsNetworkPerformanceMetricSubscriptionResult,
  DisableAwsNetworkPerformanceMetricSubscriptionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableAwsNetworkPerformanceMetricSubscriptionRequest,
  output: DisableAwsNetworkPerformanceMetricSubscriptionResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type DisableCapacityManagerError =
  | RequestLimitExceeded
  | CapacityManagerDisabled
  | CommonErrors;
/**
 * Disables EC2 Capacity Manager for your account. This stops data ingestion and removes access to capacity analytics and optimization recommendations.
 * Previously collected data is retained but no new data will be processed.
 */
export const disableCapacityManager: API.OperationMethod<
  DisableCapacityManagerRequest,
  DisableCapacityManagerResult,
  DisableCapacityManagerError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableCapacityManagerRequest,
  output: DisableCapacityManagerResult,
  errors: [RequestLimitExceeded, CapacityManagerDisabled],
}));
export type DisableEbsEncryptionByDefaultError = CommonErrors;
/**
 * Disables EBS encryption by default for your account in the current Region.
 *
 * After you disable encryption by default, you can still create encrypted volumes by
 * enabling encryption when you create each volume.
 *
 * Disabling encryption by default does not change the encryption status of your
 * existing volumes.
 *
 * For more information, see Amazon EBS encryption in the
 * *Amazon EBS User Guide*.
 */
export const disableEbsEncryptionByDefault: API.OperationMethod<
  DisableEbsEncryptionByDefaultRequest,
  DisableEbsEncryptionByDefaultResult,
  DisableEbsEncryptionByDefaultError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableEbsEncryptionByDefaultRequest,
  output: DisableEbsEncryptionByDefaultResult,
  errors: [],
}));
export type DisableFastLaunchError =
  | RequestLimitExceeded
  | InvalidRequest
  | CommonErrors;
/**
 * Discontinue Windows fast launch for a Windows AMI, and clean up existing pre-provisioned
 * snapshots. After you disable Windows fast launch, the AMI uses the standard launch process for
 * each new instance. Amazon EC2 must remove all pre-provisioned snapshots before you can enable
 * Windows fast launch again.
 *
 * You can only change these settings for Windows AMIs that you own or that have been
 * shared with you.
 */
export const disableFastLaunch: API.OperationMethod<
  DisableFastLaunchRequest,
  DisableFastLaunchResult,
  DisableFastLaunchError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableFastLaunchRequest,
  output: DisableFastLaunchResult,
  errors: [RequestLimitExceeded, InvalidRequest],
}));
export type DisableFastSnapshotRestoresError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Disables fast snapshot restores for the specified snapshots in the specified Availability Zones.
 */
export const disableFastSnapshotRestores: API.OperationMethod<
  DisableFastSnapshotRestoresRequest,
  DisableFastSnapshotRestoresResult,
  DisableFastSnapshotRestoresError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableFastSnapshotRestoresRequest,
  output: DisableFastSnapshotRestoresResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type DisableImageError =
  | RequestLimitExceeded
  | InvalidAMIIDMalformed
  | CommonErrors;
/**
 * Sets the AMI state to `disabled` and removes all launch permissions from the
 * AMI. A disabled AMI can't be used for instance launches.
 *
 * A disabled AMI can't be shared. If an AMI was public or previously shared, it is made
 * private. If an AMI was shared with an Amazon Web Services account, organization, or Organizational Unit,
 * they lose access to the disabled AMI.
 *
 * A disabled AMI does not appear in DescribeImages API calls by
 * default.
 *
 * Only the AMI owner can disable an AMI.
 *
 * You can re-enable a disabled AMI using EnableImage.
 *
 * For more information, see Disable an AMI in the
 * *Amazon EC2 User Guide*.
 */
export const disableImage: API.OperationMethod<
  DisableImageRequest,
  DisableImageResult,
  DisableImageError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableImageRequest,
  output: DisableImageResult,
  errors: [RequestLimitExceeded, InvalidAMIIDMalformed],
}));
export type DisableImageBlockPublicAccessError = CommonErrors;
/**
 * Disables *block public access for AMIs* at the account level in the
 * specified Amazon Web Services Region. This removes the *block public access* restriction
 * from your account. With the restriction removed, you can publicly share your AMIs in the
 * specified Amazon Web Services Region.
 *
 * For more information, see Block
 * public access to your AMIs in the *Amazon EC2 User Guide*.
 */
export const disableImageBlockPublicAccess: API.OperationMethod<
  DisableImageBlockPublicAccessRequest,
  DisableImageBlockPublicAccessResult,
  DisableImageBlockPublicAccessError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableImageBlockPublicAccessRequest,
  output: DisableImageBlockPublicAccessResult,
  errors: [],
}));
export type DisableImageDeprecationError =
  | RequestLimitExceeded
  | InvalidAMIIDMalformed
  | CommonErrors;
/**
 * Cancels the deprecation of the specified AMI.
 *
 * For more information, see Deprecate an Amazon EC2 AMI in the
 * *Amazon EC2 User Guide*.
 */
export const disableImageDeprecation: API.OperationMethod<
  DisableImageDeprecationRequest,
  DisableImageDeprecationResult,
  DisableImageDeprecationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableImageDeprecationRequest,
  output: DisableImageDeprecationResult,
  errors: [RequestLimitExceeded, InvalidAMIIDMalformed],
}));
export type DisableImageDeregistrationProtectionError =
  | RequestLimitExceeded
  | InvalidAMIIDMalformed
  | CommonErrors;
/**
 * Disables deregistration protection for an AMI. When deregistration protection is disabled,
 * the AMI can be deregistered.
 *
 * If you chose to include a 24-hour cooldown period when you enabled deregistration
 * protection for the AMI, then, when you disable deregistration protection, you wont
 * immediately be able to deregister the AMI.
 *
 * For more information, see Protect an Amazon EC2 AMI from
 * deregistration in the *Amazon EC2 User Guide*.
 */
export const disableImageDeregistrationProtection: API.OperationMethod<
  DisableImageDeregistrationProtectionRequest,
  DisableImageDeregistrationProtectionResult,
  DisableImageDeregistrationProtectionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableImageDeregistrationProtectionRequest,
  output: DisableImageDeregistrationProtectionResult,
  errors: [RequestLimitExceeded, InvalidAMIIDMalformed],
}));
export type DisableInstanceSqlHaStandbyDetectionsError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | CommonErrors;
/**
 * Disable Amazon EC2 instances running in an SQL Server High Availability cluster from SQL Server High Availability
 * instance standby detection monitoring. Once disabled, Amazon Web Services no longer monitors the
 * metadata for the instances to determine whether they are active or standby nodes in the
 * SQL Server High Availability cluster.
 */
export const disableInstanceSqlHaStandbyDetections: API.OperationMethod<
  DisableInstanceSqlHaStandbyDetectionsRequest,
  DisableInstanceSqlHaStandbyDetectionsResult,
  DisableInstanceSqlHaStandbyDetectionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableInstanceSqlHaStandbyDetectionsRequest,
  output: DisableInstanceSqlHaStandbyDetectionsResult,
  errors: [RequestLimitExceeded, InvalidInstanceIDMalformed],
}));
export type DisableIpamOrganizationAdminAccountError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Disable the IPAM account. For more information, see Enable integration with Organizations in the *Amazon VPC IPAM User Guide*.
 */
export const disableIpamOrganizationAdminAccount: API.OperationMethod<
  DisableIpamOrganizationAdminAccountRequest,
  DisableIpamOrganizationAdminAccountResult,
  DisableIpamOrganizationAdminAccountError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableIpamOrganizationAdminAccountRequest,
  output: DisableIpamOrganizationAdminAccountResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type DisableIpamPolicyError =
  | RequestLimitExceeded
  | InvalidIpamPolicyIdMalformed
  | InvalidIpamPolicyIdNotFound
  | CommonErrors;
/**
 * Disables an IPAM policy.
 *
 * An IPAM policy is a set of rules that define how public IPv4 addresses from IPAM pools are allocated to Amazon Web Services resources. Each rule maps an Amazon Web Services service to IPAM pools that the service will use to get IP addresses. A single policy can have multiple rules and be applied to multiple Amazon Web Services Regions. If the IPAM pool run out of addresses then the services fallback to Amazon-provided IP addresses. A policy can be applied to an individual Amazon Web Services account or an entity within Amazon Web Services Organizations.
 */
export const disableIpamPolicy: API.OperationMethod<
  DisableIpamPolicyRequest,
  DisableIpamPolicyResult,
  DisableIpamPolicyError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableIpamPolicyRequest,
  output: DisableIpamPolicyResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamPolicyIdMalformed,
    InvalidIpamPolicyIdNotFound,
  ],
}));
export type DisableRouteServerPropagationError =
  | RequestLimitExceeded
  | InvalidRouteServerIdNotFound
  | CommonErrors;
/**
 * Disables route propagation from a route server to a specified route table.
 *
 * When enabled, route server propagation installs the routes in the FIB on the route table you've specified. Route server supports IPv4 and IPv6 route propagation.
 *
 * Amazon VPC Route Server simplifies routing for traffic between workloads that are deployed within a VPC and its internet gateways. With this feature,
 * VPC Route Server dynamically updates VPC and internet gateway route tables with your preferred IPv4 or IPv6 routes to achieve routing fault tolerance for those workloads. This enables you to automatically reroute traffic within a VPC, which increases the manageability of VPC routing and interoperability with third-party workloads.
 *
 * Route server supports the follow route table types:
 *
 * - VPC route tables not associated with subnets
 *
 * - Subnet route tables
 *
 * - Internet gateway route tables
 *
 * Route server does not support route tables associated with virtual private gateways. To propagate routes into a transit gateway route table, use Transit Gateway Connect.
 *
 * For more information see Dynamic routing in your VPC with VPC Route Server in the *Amazon VPC User Guide*.
 */
export const disableRouteServerPropagation: API.OperationMethod<
  DisableRouteServerPropagationRequest,
  DisableRouteServerPropagationResult,
  DisableRouteServerPropagationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableRouteServerPropagationRequest,
  output: DisableRouteServerPropagationResult,
  errors: [RequestLimitExceeded, InvalidRouteServerIdNotFound],
}));
export type DisableSerialConsoleAccessError = CommonErrors;
/**
 * Disables access to the EC2 serial console of all instances for your account. By default,
 * access to the EC2 serial console is disabled for your account. For more information, see
 * Manage account access to the EC2 serial console in the Amazon EC2
 * User Guide.
 */
export const disableSerialConsoleAccess: API.OperationMethod<
  DisableSerialConsoleAccessRequest,
  DisableSerialConsoleAccessResult,
  DisableSerialConsoleAccessError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableSerialConsoleAccessRequest,
  output: DisableSerialConsoleAccessResult,
  errors: [],
}));
export type DisableSnapshotBlockPublicAccessError = CommonErrors;
/**
 * Disables the *block public access for snapshots* setting at
 * the account level for the specified Amazon Web Services Region. After you disable block public
 * access for snapshots in a Region, users can publicly share snapshots in that Region.
 *
 * Enabling block public access for snapshots in *block-all-sharing*
 * mode does not change the permissions for snapshots that are already publicly shared.
 * Instead, it prevents these snapshots from be publicly visible and publicly accessible.
 * Therefore, the attributes for these snapshots still indicate that they are publicly
 * shared, even though they are not publicly available.
 *
 * If you disable block public access , these snapshots will become publicly available
 * again.
 *
 * For more information, see
 * Block public access for snapshots in the *Amazon EBS User Guide* .
 */
export const disableSnapshotBlockPublicAccess: API.OperationMethod<
  DisableSnapshotBlockPublicAccessRequest,
  DisableSnapshotBlockPublicAccessResult,
  DisableSnapshotBlockPublicAccessError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableSnapshotBlockPublicAccessRequest,
  output: DisableSnapshotBlockPublicAccessResult,
  errors: [],
}));
export type DisableTransitGatewayRouteTablePropagationError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Disables the specified resource attachment from propagating routes to the specified
 * propagation route table.
 */
export const disableTransitGatewayRouteTablePropagation: API.OperationMethod<
  DisableTransitGatewayRouteTablePropagationRequest,
  DisableTransitGatewayRouteTablePropagationResult,
  DisableTransitGatewayRouteTablePropagationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableTransitGatewayRouteTablePropagationRequest,
  output: DisableTransitGatewayRouteTablePropagationResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type DisableVgwRoutePropagationError =
  | RequestLimitExceeded
  | InvalidRouteTableIDNotFound
  | CommonErrors;
/**
 * Disables a virtual private gateway (VGW) from propagating routes to a specified route
 * table of a VPC.
 */
export const disableVgwRoutePropagation: API.OperationMethod<
  DisableVgwRoutePropagationRequest,
  DisableVgwRoutePropagationResponse,
  DisableVgwRoutePropagationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableVgwRoutePropagationRequest,
  output: DisableVgwRoutePropagationResponse,
  errors: [RequestLimitExceeded, InvalidRouteTableIDNotFound],
}));
export type DisableVpcClassicLinkError =
  | RequestLimitExceeded
  | InvalidVpcIDNotFound
  | InvalidVpcIdMalformed
  | CommonErrors;
/**
 * This action is deprecated.
 *
 * Disables ClassicLink for a VPC. You cannot disable ClassicLink for a VPC that has EC2-Classic instances
 * linked to it.
 */
export const disableVpcClassicLink: API.OperationMethod<
  DisableVpcClassicLinkRequest,
  DisableVpcClassicLinkResult,
  DisableVpcClassicLinkError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableVpcClassicLinkRequest,
  output: DisableVpcClassicLinkResult,
  errors: [RequestLimitExceeded, InvalidVpcIDNotFound, InvalidVpcIdMalformed],
}));
export type DisableVpcClassicLinkDnsSupportError =
  | RequestLimitExceeded
  | InvalidVpcIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * This action is deprecated.
 *
 * Disables ClassicLink DNS support for a VPC. If disabled, DNS hostnames resolve to
 * public IP addresses when addressed between a linked EC2-Classic instance and instances
 * in the VPC to which it's linked.
 *
 * You must specify a VPC ID in the request.
 */
export const disableVpcClassicLinkDnsSupport: API.OperationMethod<
  DisableVpcClassicLinkDnsSupportRequest,
  DisableVpcClassicLinkDnsSupportResult,
  DisableVpcClassicLinkDnsSupportError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableVpcClassicLinkDnsSupportRequest,
  output: DisableVpcClassicLinkDnsSupportResult,
  errors: [RequestLimitExceeded, InvalidVpcIDNotFound, MissingParameter],
}));
export type DisassociateAddressError =
  | RequestLimitExceeded
  | InvalidAssociationIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Disassociates an Elastic IP address from the instance or network interface it's associated with.
 *
 * This is an idempotent operation. If you perform the operation more than once, Amazon EC2 doesn't return an error.
 *
 * An address cannot be disassociated if the all of the following conditions are met:
 *
 * - Network interface has a `publicDualStackDnsName` publicDnsName
 *
 * - Public IPv4 address is the primary public IPv4 address
 *
 * - Network interface only has one remaining public IPv4 address
 */
export const disassociateAddress: API.OperationMethod<
  DisassociateAddressRequest,
  DisassociateAddressResponse,
  DisassociateAddressError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateAddressRequest,
  output: DisassociateAddressResponse,
  errors: [
    RequestLimitExceeded,
    InvalidAssociationIDNotFound,
    MissingParameter,
  ],
}));
export type DisassociateCapacityReservationBillingOwnerError =
  | RequestLimitExceeded
  | InvalidCapacityReservationIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Cancels a pending request to assign billing of the unused capacity of a Capacity
 * Reservation to a consumer account, or revokes a request that has already been accepted.
 * For more information, see Billing assignment for shared
 * Amazon EC2 Capacity Reservations.
 */
export const disassociateCapacityReservationBillingOwner: API.OperationMethod<
  DisassociateCapacityReservationBillingOwnerRequest,
  DisassociateCapacityReservationBillingOwnerResult,
  DisassociateCapacityReservationBillingOwnerError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateCapacityReservationBillingOwnerRequest,
  output: DisassociateCapacityReservationBillingOwnerResult,
  errors: [
    RequestLimitExceeded,
    InvalidCapacityReservationIdMalformed,
    MissingParameter,
  ],
}));
export type DisassociateClientVpnTargetNetworkError =
  | RequestLimitExceeded
  | InvalidClientVpnEndpointIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Disassociates a target network from the specified Client VPN endpoint. When you disassociate the
 * last target network from a Client VPN, the following happens:
 *
 * - The route that was automatically added for the VPC is deleted
 *
 * - All active client connections are terminated
 *
 * - New client connections are disallowed
 *
 * - The Client VPN endpoint's status changes to `pending-associate`
 */
export const disassociateClientVpnTargetNetwork: API.OperationMethod<
  DisassociateClientVpnTargetNetworkRequest,
  DisassociateClientVpnTargetNetworkResult,
  DisassociateClientVpnTargetNetworkError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateClientVpnTargetNetworkRequest,
  output: DisassociateClientVpnTargetNetworkResult,
  errors: [
    RequestLimitExceeded,
    InvalidClientVpnEndpointIdNotFound,
    MissingParameter,
  ],
}));
export type DisassociateEnclaveCertificateIamRoleError =
  | RequestLimitExceeded
  | InvalidCertificateArnMalformed
  | InvalidRoleArnMalformed
  | CommonErrors;
/**
 * Disassociates an IAM role from an Certificate Manager (ACM) certificate. Disassociating an IAM role
 * from an ACM certificate removes the Amazon S3 object that contains the certificate, certificate chain, and
 * encrypted private key from the Amazon S3 bucket. It also revokes the IAM role's permission to use the
 * KMS key used to encrypt the private key. This effectively revokes the role's permission
 * to use the certificate.
 */
export const disassociateEnclaveCertificateIamRole: API.OperationMethod<
  DisassociateEnclaveCertificateIamRoleRequest,
  DisassociateEnclaveCertificateIamRoleResult,
  DisassociateEnclaveCertificateIamRoleError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateEnclaveCertificateIamRoleRequest,
  output: DisassociateEnclaveCertificateIamRoleResult,
  errors: [
    RequestLimitExceeded,
    InvalidCertificateArnMalformed,
    InvalidRoleArnMalformed,
  ],
}));
export type DisassociateIamInstanceProfileError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Disassociates an IAM instance profile from a running or stopped instance.
 *
 * Use DescribeIamInstanceProfileAssociations to get the association
 * ID.
 */
export const disassociateIamInstanceProfile: API.OperationMethod<
  DisassociateIamInstanceProfileRequest,
  DisassociateIamInstanceProfileResult,
  DisassociateIamInstanceProfileError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateIamInstanceProfileRequest,
  output: DisassociateIamInstanceProfileResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type DisassociateInstanceEventWindowError =
  | RequestLimitExceeded
  | DependencyViolation
  | MissingParameter
  | CommonErrors;
/**
 * Disassociates one or more targets from an event window.
 *
 * For more information, see Define event windows for scheduled
 * events in the *Amazon EC2 User Guide*.
 */
export const disassociateInstanceEventWindow: API.OperationMethod<
  DisassociateInstanceEventWindowRequest,
  DisassociateInstanceEventWindowResult,
  DisassociateInstanceEventWindowError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateInstanceEventWindowRequest,
  output: DisassociateInstanceEventWindowResult,
  errors: [RequestLimitExceeded, DependencyViolation, MissingParameter],
}));
export type DisassociateIpamByoasnError =
  | RequestLimitExceeded
  | InvalidCidrNotFound
  | CommonErrors;
/**
 * Remove the association between your Autonomous System Number (ASN) and your BYOIP CIDR. You may want to use this action to disassociate an ASN from a CIDR or if you want to swap ASNs.
 * For more information, see Tutorial: Bring your ASN to IPAM in the *Amazon VPC IPAM guide*.
 */
export const disassociateIpamByoasn: API.OperationMethod<
  DisassociateIpamByoasnRequest,
  DisassociateIpamByoasnResult,
  DisassociateIpamByoasnError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateIpamByoasnRequest,
  output: DisassociateIpamByoasnResult,
  errors: [RequestLimitExceeded, InvalidCidrNotFound],
}));
export type DisassociateIpamResourceDiscoveryError =
  | RequestLimitExceeded
  | InvalidIpamResourceDiscoveryAssociationIdMalformed
  | InvalidIpamResourceDiscoveryAssociationIdNotFound
  | CommonErrors;
/**
 * Disassociates a resource discovery from an Amazon VPC IPAM. A resource discovery is an IPAM component that enables IPAM to manage and monitor resources that belong to the owning account.
 */
export const disassociateIpamResourceDiscovery: API.OperationMethod<
  DisassociateIpamResourceDiscoveryRequest,
  DisassociateIpamResourceDiscoveryResult,
  DisassociateIpamResourceDiscoveryError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateIpamResourceDiscoveryRequest,
  output: DisassociateIpamResourceDiscoveryResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamResourceDiscoveryAssociationIdMalformed,
    InvalidIpamResourceDiscoveryAssociationIdNotFound,
  ],
}));
export type DisassociateNatGatewayAddressError =
  | RequestLimitExceeded
  | MissingParameter
  | NatGatewayMalformed
  | NatGatewayNotFound
  | CommonErrors;
/**
 * Disassociates secondary Elastic IP addresses (EIPs) from a public NAT gateway.
 * You cannot disassociate your primary EIP. For more information, see Edit secondary IP address associations in the *Amazon VPC User Guide*.
 *
 * While disassociating is in progress, you cannot associate/disassociate additional EIPs while the connections are being drained. You are, however, allowed to delete the NAT gateway.
 *
 * An EIP is released only at the end of MaxDrainDurationSeconds. It stays
 * associated and supports the existing connections but does not support any new connections
 * (new connections are distributed across the remaining associated EIPs). As the existing
 * connections drain out, the EIPs (and the corresponding private IP addresses mapped to them)
 * are released.
 */
export const disassociateNatGatewayAddress: API.OperationMethod<
  DisassociateNatGatewayAddressRequest,
  DisassociateNatGatewayAddressResult,
  DisassociateNatGatewayAddressError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateNatGatewayAddressRequest,
  output: DisassociateNatGatewayAddressResult,
  errors: [
    RequestLimitExceeded,
    MissingParameter,
    NatGatewayMalformed,
    NatGatewayNotFound,
  ],
}));
export type DisassociateRouteServerError =
  | RequestLimitExceeded
  | InvalidRouteServerIdNotFound
  | InvalidVpcIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Disassociates a route server from a VPC.
 *
 * A route server association is the connection established between a route server and a VPC.
 *
 * For more information see Dynamic routing in your VPC with VPC Route Server in the *Amazon VPC User Guide*.
 */
export const disassociateRouteServer: API.OperationMethod<
  DisassociateRouteServerRequest,
  DisassociateRouteServerResult,
  DisassociateRouteServerError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateRouteServerRequest,
  output: DisassociateRouteServerResult,
  errors: [
    RequestLimitExceeded,
    InvalidRouteServerIdNotFound,
    InvalidVpcIDNotFound,
    MissingParameter,
  ],
}));
export type DisassociateRouteTableError =
  | RequestLimitExceeded
  | InvalidAssociationIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Disassociates a subnet or gateway from a route table.
 *
 * After you perform this action, the subnet no longer uses the routes in the route table.
 * Instead, it uses the routes in the VPC's main route table. For more information
 * about route tables, see Route
 * tables in the *Amazon VPC User Guide*.
 */
export const disassociateRouteTable: API.OperationMethod<
  DisassociateRouteTableRequest,
  DisassociateRouteTableResponse,
  DisassociateRouteTableError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateRouteTableRequest,
  output: DisassociateRouteTableResponse,
  errors: [
    RequestLimitExceeded,
    InvalidAssociationIDNotFound,
    MissingParameter,
  ],
}));
export type DisassociateSecurityGroupVpcError =
  | RequestLimitExceeded
  | InvalidGroupIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Disassociates a security group from a VPC. You cannot disassociate the security group if any Elastic network interfaces in the associated VPC are still associated with the security group.
 *
 * Note that the disassociation is asynchronous and you can check the status of the request with DescribeSecurityGroupVpcAssociations.
 */
export const disassociateSecurityGroupVpc: API.OperationMethod<
  DisassociateSecurityGroupVpcRequest,
  DisassociateSecurityGroupVpcResult,
  DisassociateSecurityGroupVpcError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateSecurityGroupVpcRequest,
  output: DisassociateSecurityGroupVpcResult,
  errors: [RequestLimitExceeded, InvalidGroupIdMalformed, MissingParameter],
}));
export type DisassociateSubnetCidrBlockError =
  | RequestLimitExceeded
  | InvalidSubnetCidrBlockAssociationIDNotFound
  | InvalidSubnetCidrBlockAssociationIdMalformed
  | CommonErrors;
/**
 * Disassociates a CIDR block from a subnet. Currently, you can disassociate an IPv6 CIDR block only. You must detach or delete all gateways and resources that are associated with the CIDR block before you can disassociate it.
 */
export const disassociateSubnetCidrBlock: API.OperationMethod<
  DisassociateSubnetCidrBlockRequest,
  DisassociateSubnetCidrBlockResult,
  DisassociateSubnetCidrBlockError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateSubnetCidrBlockRequest,
  output: DisassociateSubnetCidrBlockResult,
  errors: [
    RequestLimitExceeded,
    InvalidSubnetCidrBlockAssociationIDNotFound,
    InvalidSubnetCidrBlockAssociationIdMalformed,
  ],
}));
export type DisassociateTransitGatewayMulticastDomainError =
  | RequestLimitExceeded
  | InvalidTransitGatewayMulticastDomainIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Disassociates the specified subnets from the transit gateway multicast domain.
 */
export const disassociateTransitGatewayMulticastDomain: API.OperationMethod<
  DisassociateTransitGatewayMulticastDomainRequest,
  DisassociateTransitGatewayMulticastDomainResult,
  DisassociateTransitGatewayMulticastDomainError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateTransitGatewayMulticastDomainRequest,
  output: DisassociateTransitGatewayMulticastDomainResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayMulticastDomainIdNotFound,
    MissingParameter,
  ],
}));
export type DisassociateTransitGatewayPolicyTableError =
  | RequestLimitExceeded
  | InvalidTransitGatewayPolicyTableIdMalformed
  | InvalidTransitGatewayPolicyTableIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Removes the association between an an attachment and a policy table.
 */
export const disassociateTransitGatewayPolicyTable: API.OperationMethod<
  DisassociateTransitGatewayPolicyTableRequest,
  DisassociateTransitGatewayPolicyTableResult,
  DisassociateTransitGatewayPolicyTableError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateTransitGatewayPolicyTableRequest,
  output: DisassociateTransitGatewayPolicyTableResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayPolicyTableIdMalformed,
    InvalidTransitGatewayPolicyTableIdNotFound,
    MissingParameter,
  ],
}));
export type DisassociateTransitGatewayRouteTableError =
  | RequestLimitExceeded
  | InvalidRouteTableIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Disassociates a resource attachment from a transit gateway route table.
 */
export const disassociateTransitGatewayRouteTable: API.OperationMethod<
  DisassociateTransitGatewayRouteTableRequest,
  DisassociateTransitGatewayRouteTableResult,
  DisassociateTransitGatewayRouteTableError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateTransitGatewayRouteTableRequest,
  output: DisassociateTransitGatewayRouteTableResult,
  errors: [RequestLimitExceeded, InvalidRouteTableIDNotFound, MissingParameter],
}));
export type DisassociateTrunkInterfaceError =
  | RequestLimitExceeded
  | OperationNotPermitted
  | CommonErrors;
/**
 * Removes an association between a branch network interface with a trunk network interface.
 */
export const disassociateTrunkInterface: API.OperationMethod<
  DisassociateTrunkInterfaceRequest,
  DisassociateTrunkInterfaceResult,
  DisassociateTrunkInterfaceError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateTrunkInterfaceRequest,
  output: DisassociateTrunkInterfaceResult,
  errors: [RequestLimitExceeded, OperationNotPermitted],
}));
export type DisassociateVpcCidrBlockError =
  | RequestLimitExceeded
  | InvalidVpcCidrBlockAssociationIDNotFound
  | InvalidVpcCidrBlockAssociationIdMalformed
  | InvalidVpcCidrBlockAssociationIdErrorNotFound
  | OperationNotPermitted
  | CommonErrors;
/**
 * Disassociates a CIDR block from a VPC. To disassociate the CIDR block, you must
 * specify its association ID. You can get the association ID by using
 * DescribeVpcs. You must detach or delete all gateways and resources that
 * are associated with the CIDR block before you can disassociate it.
 *
 * You cannot disassociate the CIDR block with which you originally created the VPC (the
 * primary CIDR block).
 */
export const disassociateVpcCidrBlock: API.OperationMethod<
  DisassociateVpcCidrBlockRequest,
  DisassociateVpcCidrBlockResult,
  DisassociateVpcCidrBlockError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateVpcCidrBlockRequest,
  output: DisassociateVpcCidrBlockResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcCidrBlockAssociationIDNotFound,
    InvalidVpcCidrBlockAssociationIdMalformed,
    InvalidVpcCidrBlockAssociationIdErrorNotFound,
    OperationNotPermitted,
  ],
}));
export type EnableAddressTransferError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Enables Elastic IP address transfer. For more information, see Transfer Elastic IP addresses in the *Amazon VPC User Guide*.
 */
export const enableAddressTransfer: API.OperationMethod<
  EnableAddressTransferRequest,
  EnableAddressTransferResult,
  EnableAddressTransferError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableAddressTransferRequest,
  output: EnableAddressTransferResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type EnableAllowedImagesSettingsError = CommonErrors;
/**
 * Enables Allowed AMIs for your account in the specified Amazon Web Services Region. Two values are
 * accepted:
 *
 * - `enabled`: The image criteria in your Allowed AMIs settings are applied. As
 * a result, only AMIs matching these criteria are discoverable and can be used by your
 * account to launch instances.
 *
 * - `audit-mode`: The image criteria in your Allowed AMIs settings are not
 * applied. No restrictions are placed on AMI discoverability or usage. Users in your account
 * can launch instances using any public AMI or AMI shared with your account.
 *
 * The purpose of `audit-mode` is to indicate which AMIs will be affected when
 * Allowed AMIs is `enabled`. In `audit-mode`, each AMI displays either
 * `"ImageAllowed": true` or `"ImageAllowed": false` to indicate
 * whether the AMI will be discoverable and available to users in the account when Allowed
 * AMIs is enabled.
 *
 * The Allowed AMIs feature does not restrict the AMIs owned by your account. Regardless of
 * the criteria you set, the AMIs created by your account will always be discoverable and
 * usable by users in your account.
 *
 * For more information, see Control the discovery and use of AMIs in
 * Amazon EC2 with Allowed AMIs in
 * *Amazon EC2 User Guide*.
 */
export const enableAllowedImagesSettings: API.OperationMethod<
  EnableAllowedImagesSettingsRequest,
  EnableAllowedImagesSettingsResult,
  EnableAllowedImagesSettingsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableAllowedImagesSettingsRequest,
  output: EnableAllowedImagesSettingsResult,
  errors: [],
}));
export type EnableAwsNetworkPerformanceMetricSubscriptionError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Enables Infrastructure Performance subscriptions.
 */
export const enableAwsNetworkPerformanceMetricSubscription: API.OperationMethod<
  EnableAwsNetworkPerformanceMetricSubscriptionRequest,
  EnableAwsNetworkPerformanceMetricSubscriptionResult,
  EnableAwsNetworkPerformanceMetricSubscriptionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableAwsNetworkPerformanceMetricSubscriptionRequest,
  output: EnableAwsNetworkPerformanceMetricSubscriptionResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type EnableCapacityManagerError = CommonErrors;
/**
 * Enables EC2 Capacity Manager for your account. This starts data ingestion for your EC2 capacity usage across On-Demand, Spot, and Capacity Reservations.
 * Initial data processing may take several hours to complete.
 */
export const enableCapacityManager: API.OperationMethod<
  EnableCapacityManagerRequest,
  EnableCapacityManagerResult,
  EnableCapacityManagerError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableCapacityManagerRequest,
  output: EnableCapacityManagerResult,
  errors: [],
}));
export type EnableEbsEncryptionByDefaultError = CommonErrors;
/**
 * Enables EBS encryption by default for your account in the current Region.
 *
 * After you enable encryption by default, the EBS volumes that you create are
 * always encrypted, either using the default KMS key or the KMS key that you specified
 * when you created each volume. For more information, see Amazon EBS encryption in the
 * *Amazon EBS User Guide*.
 *
 * Enabling encryption by default has no effect on the encryption status of your
 * existing volumes.
 *
 * After you enable encryption by default, you can no longer launch instances
 * using instance types that do not support encryption. For more information, see Supported
 * instance types.
 */
export const enableEbsEncryptionByDefault: API.OperationMethod<
  EnableEbsEncryptionByDefaultRequest,
  EnableEbsEncryptionByDefaultResult,
  EnableEbsEncryptionByDefaultError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableEbsEncryptionByDefaultRequest,
  output: EnableEbsEncryptionByDefaultResult,
  errors: [],
}));
export type EnableFastLaunchError =
  | RequestLimitExceeded
  | InvalidRequest
  | CommonErrors;
/**
 * When you enable Windows fast launch for a Windows AMI, images are pre-provisioned, using
 * snapshots to launch instances up to 65% faster. To create the optimized Windows image, Amazon EC2
 * launches an instance and runs through Sysprep steps, rebooting as required. Then it creates a
 * set of reserved snapshots that are used for subsequent launches. The reserved snapshots are
 * automatically replenished as they are used, depending on your settings for launch
 * frequency.
 *
 * You can only change these settings for Windows AMIs that you own or that have been
 * shared with you.
 */
export const enableFastLaunch: API.OperationMethod<
  EnableFastLaunchRequest,
  EnableFastLaunchResult,
  EnableFastLaunchError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableFastLaunchRequest,
  output: EnableFastLaunchResult,
  errors: [RequestLimitExceeded, InvalidRequest],
}));
export type EnableFastSnapshotRestoresError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Enables fast snapshot restores for the specified snapshots in the specified Availability Zones.
 *
 * You get the full benefit of fast snapshot restores after they enter the `enabled` state.
 *
 * For more information, see Amazon EBS fast snapshot
 * restore in the *Amazon EBS User Guide*.
 */
export const enableFastSnapshotRestores: API.OperationMethod<
  EnableFastSnapshotRestoresRequest,
  EnableFastSnapshotRestoresResult,
  EnableFastSnapshotRestoresError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableFastSnapshotRestoresRequest,
  output: EnableFastSnapshotRestoresResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type EnableImageError =
  | RequestLimitExceeded
  | InvalidAMIIDMalformed
  | CommonErrors;
/**
 * Re-enables a disabled AMI. The re-enabled AMI is marked as `available` and can
 * be used for instance launches, appears in describe operations, and can be shared. Amazon Web Services
 * accounts, organizations, and Organizational Units that lost access to the AMI when it was
 * disabled do not regain access automatically. Once the AMI is available, it can be shared with
 * them again.
 *
 * Only the AMI owner can re-enable a disabled AMI.
 *
 * For more information, see Disable an Amazon EC2 AMI
 * in the *Amazon EC2 User Guide*.
 */
export const enableImage: API.OperationMethod<
  EnableImageRequest,
  EnableImageResult,
  EnableImageError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableImageRequest,
  output: EnableImageResult,
  errors: [RequestLimitExceeded, InvalidAMIIDMalformed],
}));
export type EnableImageBlockPublicAccessError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Enables *block public access for AMIs* at the account level in the
 * specified Amazon Web Services Region. This prevents the public sharing of your AMIs. However, if you already
 * have public AMIs, they will remain publicly available.
 *
 * The API can take up to 10 minutes to configure this setting. During this time, if you run
 * GetImageBlockPublicAccessState, the response will be `unblocked`. When
 * the API has completed the configuration, the response will be
 * `block-new-sharing`.
 *
 * For more information, see Block
 * public access to your AMIs in the *Amazon EC2 User Guide*.
 */
export const enableImageBlockPublicAccess: API.OperationMethod<
  EnableImageBlockPublicAccessRequest,
  EnableImageBlockPublicAccessResult,
  EnableImageBlockPublicAccessError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableImageBlockPublicAccessRequest,
  output: EnableImageBlockPublicAccessResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type EnableImageDeprecationError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Enables deprecation of the specified AMI at the specified date and time.
 *
 * For more information, see Deprecate an AMI in the
 * *Amazon EC2 User Guide*.
 */
export const enableImageDeprecation: API.OperationMethod<
  EnableImageDeprecationRequest,
  EnableImageDeprecationResult,
  EnableImageDeprecationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableImageDeprecationRequest,
  output: EnableImageDeprecationResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type EnableImageDeregistrationProtectionError =
  | RequestLimitExceeded
  | InvalidAMIIDMalformed
  | CommonErrors;
/**
 * Enables deregistration protection for an AMI. When deregistration protection is enabled,
 * the AMI can't be deregistered.
 *
 * To allow the AMI to be deregistered, you must first disable deregistration protection.
 *
 * For more information, see Protect an
 * Amazon EC2 AMI from deregistration in the *Amazon EC2 User Guide*.
 */
export const enableImageDeregistrationProtection: API.OperationMethod<
  EnableImageDeregistrationProtectionRequest,
  EnableImageDeregistrationProtectionResult,
  EnableImageDeregistrationProtectionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableImageDeregistrationProtectionRequest,
  output: EnableImageDeregistrationProtectionResult,
  errors: [RequestLimitExceeded, InvalidAMIIDMalformed],
}));
export type EnableInstanceSqlHaStandbyDetectionsError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | CommonErrors;
/**
 * Enable Amazon EC2 instances running in an SQL Server High Availability cluster for SQL Server High Availability
 * instance standby detection monitoring. Once enabled, Amazon Web Services monitors the metadata for
 * the instances to determine whether they are active or standby nodes in the SQL Server High Availability cluster.
 * If the instances are determined to be standby failover nodes, Amazon Web Services
 * automatically applies SQL Server licensing fee waiver for those instances.
 *
 * To register an instance, it must be running a Windows SQL Server license-included
 * AMI and have the Amazon Web Services Systems Manager agent installed and running. Only Windows Server 2019 and later
 * and SQL Server (Standard and Enterprise editions) 2017 and later are supported. For more
 * information, see
 * Prerequisites for using SQL Server High Availability instance standby detection.
 */
export const enableInstanceSqlHaStandbyDetections: API.OperationMethod<
  EnableInstanceSqlHaStandbyDetectionsRequest,
  EnableInstanceSqlHaStandbyDetectionsResult,
  EnableInstanceSqlHaStandbyDetectionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableInstanceSqlHaStandbyDetectionsRequest,
  output: EnableInstanceSqlHaStandbyDetectionsResult,
  errors: [RequestLimitExceeded, InvalidInstanceIDMalformed],
}));
export type EnableIpamOrganizationAdminAccountError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Enable an Organizations member account as the IPAM admin account. You cannot select the Organizations management account as the IPAM admin account. For more information, see Enable integration with Organizations in the *Amazon VPC IPAM User Guide*.
 */
export const enableIpamOrganizationAdminAccount: API.OperationMethod<
  EnableIpamOrganizationAdminAccountRequest,
  EnableIpamOrganizationAdminAccountResult,
  EnableIpamOrganizationAdminAccountError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableIpamOrganizationAdminAccountRequest,
  output: EnableIpamOrganizationAdminAccountResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type EnableIpamPolicyError =
  | RequestLimitExceeded
  | InvalidIpamPolicyIdMalformed
  | InvalidIpamPolicyIdNotFound
  | CommonErrors;
/**
 * Enables an IPAM policy.
 *
 * An IPAM policy is a set of rules that define how public IPv4 addresses from IPAM pools are allocated to Amazon Web Services resources. Each rule maps an Amazon Web Services service to IPAM pools that the service will use to get IP addresses. A single policy can have multiple rules and be applied to multiple Amazon Web Services Regions. If the IPAM pool run out of addresses then the services fallback to Amazon-provided IP addresses. A policy can be applied to an individual Amazon Web Services account or an entity within Amazon Web Services Organizations.
 *
 * For more information, see Define public IPv4 allocation strategy with IPAM policies in the *Amazon VPC IPAM User Guide*.
 */
export const enableIpamPolicy: API.OperationMethod<
  EnableIpamPolicyRequest,
  EnableIpamPolicyResult,
  EnableIpamPolicyError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableIpamPolicyRequest,
  output: EnableIpamPolicyResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamPolicyIdMalformed,
    InvalidIpamPolicyIdNotFound,
  ],
}));
export type EnableReachabilityAnalyzerOrganizationSharingError = CommonErrors;
/**
 * Establishes a trust relationship between Reachability Analyzer and Organizations.
 * This operation must be performed by the management account for the organization.
 *
 * After you establish a trust relationship, a user in the management account or
 * a delegated administrator account can run a cross-account analysis using resources
 * from the member accounts.
 */
export const enableReachabilityAnalyzerOrganizationSharing: API.OperationMethod<
  EnableReachabilityAnalyzerOrganizationSharingRequest,
  EnableReachabilityAnalyzerOrganizationSharingResult,
  EnableReachabilityAnalyzerOrganizationSharingError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableReachabilityAnalyzerOrganizationSharingRequest,
  output: EnableReachabilityAnalyzerOrganizationSharingResult,
  errors: [],
}));
export type EnableRouteServerPropagationError =
  | RequestLimitExceeded
  | InvalidRouteServerIdNotFound
  | CommonErrors;
/**
 * Defines which route tables the route server can update with routes.
 *
 * When enabled, route server propagation installs the routes in the FIB on the route table you've specified. Route server supports IPv4 and IPv6 route propagation.
 *
 * For more information see Dynamic routing in your VPC with VPC Route Server in the *Amazon VPC User Guide*.
 */
export const enableRouteServerPropagation: API.OperationMethod<
  EnableRouteServerPropagationRequest,
  EnableRouteServerPropagationResult,
  EnableRouteServerPropagationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableRouteServerPropagationRequest,
  output: EnableRouteServerPropagationResult,
  errors: [RequestLimitExceeded, InvalidRouteServerIdNotFound],
}));
export type EnableSerialConsoleAccessError = CommonErrors;
/**
 * Enables access to the EC2 serial console of all instances for your account. By default,
 * access to the EC2 serial console is disabled for your account. For more information, see Manage account access to the EC2 serial console
 * in the *Amazon EC2 User Guide*.
 */
export const enableSerialConsoleAccess: API.OperationMethod<
  EnableSerialConsoleAccessRequest,
  EnableSerialConsoleAccessResult,
  EnableSerialConsoleAccessError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableSerialConsoleAccessRequest,
  output: EnableSerialConsoleAccessResult,
  errors: [],
}));
export type EnableSnapshotBlockPublicAccessError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Enables or modifies the *block public access for snapshots*
 * setting at the account level for the specified Amazon Web Services Region. After you enable block
 * public access for snapshots in a Region, users can no longer request public sharing
 * for snapshots in that Region. Snapshots that are already publicly shared are either
 * treated as private or they remain publicly shared, depending on the
 * **State** that you specify.
 *
 * Enabling block public access for snapshots in *block all sharing*
 * mode does not change the permissions for snapshots that are already publicly shared.
 * Instead, it prevents these snapshots from be publicly visible and publicly accessible.
 * Therefore, the attributes for these snapshots still indicate that they are publicly
 * shared, even though they are not publicly available.
 *
 * If you later disable block public access or change the mode to block new
 * sharing, these snapshots will become publicly available again.
 *
 * For more information, see
 * Block public access for snapshots in the *Amazon EBS User Guide*.
 */
export const enableSnapshotBlockPublicAccess: API.OperationMethod<
  EnableSnapshotBlockPublicAccessRequest,
  EnableSnapshotBlockPublicAccessResult,
  EnableSnapshotBlockPublicAccessError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableSnapshotBlockPublicAccessRequest,
  output: EnableSnapshotBlockPublicAccessResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type EnableTransitGatewayRouteTablePropagationError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Enables the specified attachment to propagate routes to the specified
 * propagation route table.
 */
export const enableTransitGatewayRouteTablePropagation: API.OperationMethod<
  EnableTransitGatewayRouteTablePropagationRequest,
  EnableTransitGatewayRouteTablePropagationResult,
  EnableTransitGatewayRouteTablePropagationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableTransitGatewayRouteTablePropagationRequest,
  output: EnableTransitGatewayRouteTablePropagationResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type EnableVgwRoutePropagationError =
  | RequestLimitExceeded
  | InvalidRouteTableIDNotFound
  | CommonErrors;
/**
 * Enables a virtual private gateway (VGW) to propagate routes to the specified route
 * table of a VPC.
 */
export const enableVgwRoutePropagation: API.OperationMethod<
  EnableVgwRoutePropagationRequest,
  EnableVgwRoutePropagationResponse,
  EnableVgwRoutePropagationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableVgwRoutePropagationRequest,
  output: EnableVgwRoutePropagationResponse,
  errors: [RequestLimitExceeded, InvalidRouteTableIDNotFound],
}));
export type EnableVolumeIOError = CommonErrors;
/**
 * Enables I/O operations for a volume that had I/O operations disabled because the data on
 * the volume was potentially inconsistent.
 */
export const enableVolumeIO: API.OperationMethod<
  EnableVolumeIORequest,
  EnableVolumeIOResponse,
  EnableVolumeIOError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableVolumeIORequest,
  output: EnableVolumeIOResponse,
  errors: [],
}));
export type EnableVpcClassicLinkError =
  | RequestLimitExceeded
  | InvalidVpcIDNotFound
  | InvalidVpcIdMalformed
  | CommonErrors;
/**
 * This action is deprecated.
 *
 * Enables a VPC for ClassicLink. You can then link EC2-Classic instances to your
 * ClassicLink-enabled VPC to allow communication over private IP addresses. You cannot
 * enable your VPC for ClassicLink if any of your VPC route tables have existing routes for
 * address ranges within the `10.0.0.0/8` IP address range, excluding local
 * routes for VPCs in the `10.0.0.0/16` and `10.1.0.0/16` IP address
 * ranges.
 */
export const enableVpcClassicLink: API.OperationMethod<
  EnableVpcClassicLinkRequest,
  EnableVpcClassicLinkResult,
  EnableVpcClassicLinkError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableVpcClassicLinkRequest,
  output: EnableVpcClassicLinkResult,
  errors: [RequestLimitExceeded, InvalidVpcIDNotFound, InvalidVpcIdMalformed],
}));
export type EnableVpcClassicLinkDnsSupportError =
  | RequestLimitExceeded
  | InvalidVpcIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * This action is deprecated.
 *
 * Enables a VPC to support DNS hostname resolution for ClassicLink. If enabled, the DNS
 * hostname of a linked EC2-Classic instance resolves to its private IP address when
 * addressed from an instance in the VPC to which it's linked. Similarly, the DNS hostname
 * of an instance in a VPC resolves to its private IP address when addressed from a linked
 * EC2-Classic instance.
 *
 * You must specify a VPC ID in the request.
 */
export const enableVpcClassicLinkDnsSupport: API.OperationMethod<
  EnableVpcClassicLinkDnsSupportRequest,
  EnableVpcClassicLinkDnsSupportResult,
  EnableVpcClassicLinkDnsSupportError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableVpcClassicLinkDnsSupportRequest,
  output: EnableVpcClassicLinkDnsSupportResult,
  errors: [RequestLimitExceeded, InvalidVpcIDNotFound, MissingParameter],
}));
export type ExportClientVpnClientCertificateRevocationListError =
  | RequestLimitExceeded
  | InvalidClientVpnEndpointIdNotFound
  | CommonErrors;
/**
 * Downloads the client certificate revocation list for the specified Client VPN endpoint.
 */
export const exportClientVpnClientCertificateRevocationList: API.OperationMethod<
  ExportClientVpnClientCertificateRevocationListRequest,
  ExportClientVpnClientCertificateRevocationListResult,
  ExportClientVpnClientCertificateRevocationListError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ExportClientVpnClientCertificateRevocationListRequest,
  output: ExportClientVpnClientCertificateRevocationListResult,
  errors: [RequestLimitExceeded, InvalidClientVpnEndpointIdNotFound],
}));
export type ExportClientVpnClientConfigurationError =
  | RequestLimitExceeded
  | InvalidClientVpnEndpointIdNotFound
  | CommonErrors;
/**
 * Downloads the contents of the Client VPN endpoint configuration file for the specified Client VPN endpoint. The Client VPN endpoint configuration
 * file includes the Client VPN endpoint and certificate information clients need to establish a connection
 * with the Client VPN endpoint.
 */
export const exportClientVpnClientConfiguration: API.OperationMethod<
  ExportClientVpnClientConfigurationRequest,
  ExportClientVpnClientConfigurationResult,
  ExportClientVpnClientConfigurationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ExportClientVpnClientConfigurationRequest,
  output: ExportClientVpnClientConfigurationResult,
  errors: [RequestLimitExceeded, InvalidClientVpnEndpointIdNotFound],
}));
export type ExportImageError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Exports an Amazon Machine Image (AMI) to a VM file. For more information, see Exporting a VM
 * directly from an Amazon Machine Image (AMI) in the
 * *VM Import/Export User Guide*.
 */
export const exportImage: API.OperationMethod<
  ExportImageRequest,
  ExportImageResult,
  ExportImageError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ExportImageRequest,
  output: ExportImageResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type ExportTransitGatewayRoutesError =
  | RequestLimitExceeded
  | InvalidRouteTableIDNotFound
  | CommonErrors;
/**
 * Exports routes from the specified transit gateway route table to the specified S3 bucket.
 * By default, all routes are exported. Alternatively, you can filter by CIDR range.
 *
 * The routes are saved to the specified bucket in a JSON file. For more information, see
 * Export route tables
 * to Amazon S3 in the *Amazon Web Services Transit Gateways Guide*.
 */
export const exportTransitGatewayRoutes: API.OperationMethod<
  ExportTransitGatewayRoutesRequest,
  ExportTransitGatewayRoutesResult,
  ExportTransitGatewayRoutesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ExportTransitGatewayRoutesRequest,
  output: ExportTransitGatewayRoutesResult,
  errors: [RequestLimitExceeded, InvalidRouteTableIDNotFound],
}));
export type ExportVerifiedAccessInstanceClientConfigurationError =
  | RequestLimitExceeded
  | InvalidVerifiedAccessInstanceIdNotFound
  | CommonErrors;
/**
 * Exports the client configuration for a Verified Access instance.
 */
export const exportVerifiedAccessInstanceClientConfiguration: API.OperationMethod<
  ExportVerifiedAccessInstanceClientConfigurationRequest,
  ExportVerifiedAccessInstanceClientConfigurationResult,
  ExportVerifiedAccessInstanceClientConfigurationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ExportVerifiedAccessInstanceClientConfigurationRequest,
  output: ExportVerifiedAccessInstanceClientConfigurationResult,
  errors: [RequestLimitExceeded, InvalidVerifiedAccessInstanceIdNotFound],
}));
export type GetActiveVpnTunnelStatusError =
  | RequestLimitExceeded
  | InvalidVpnConnectionIDNotFound
  | CommonErrors;
/**
 * Returns the currently negotiated security parameters for an active VPN tunnel, including IKE version, DH groups, encryption algorithms, and integrity algorithms.
 */
export const getActiveVpnTunnelStatus: API.OperationMethod<
  GetActiveVpnTunnelStatusRequest,
  GetActiveVpnTunnelStatusResult,
  GetActiveVpnTunnelStatusError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetActiveVpnTunnelStatusRequest,
  output: GetActiveVpnTunnelStatusResult,
  errors: [RequestLimitExceeded, InvalidVpnConnectionIDNotFound],
}));
export type GetAllowedImagesSettingsError = CommonErrors;
/**
 * Gets the current state of the Allowed AMIs setting and the list of Allowed AMIs criteria
 * at the account level in the specified Region.
 *
 * The Allowed AMIs feature does not restrict the AMIs owned by your account. Regardless of
 * the criteria you set, the AMIs created by your account will always be discoverable and
 * usable by users in your account.
 *
 * For more information, see Control the discovery and use of AMIs in
 * Amazon EC2 with Allowed AMIs in
 * *Amazon EC2 User Guide*.
 */
export const getAllowedImagesSettings: API.OperationMethod<
  GetAllowedImagesSettingsRequest,
  GetAllowedImagesSettingsResult,
  GetAllowedImagesSettingsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetAllowedImagesSettingsRequest,
  output: GetAllowedImagesSettingsResult,
  errors: [],
}));
export type GetAssociatedEnclaveCertificateIamRolesError =
  | RequestLimitExceeded
  | InvalidCertificateArnMalformed
  | UnauthorizedOperation
  | CommonErrors;
/**
 * Returns the IAM roles that are associated with the specified ACM (ACM) certificate.
 * It also returns the name of the Amazon S3 bucket and the Amazon S3 object key where the certificate,
 * certificate chain, and encrypted private key bundle are stored, and the ARN of the KMS key
 * that's used to encrypt the private key.
 */
export const getAssociatedEnclaveCertificateIamRoles: API.OperationMethod<
  GetAssociatedEnclaveCertificateIamRolesRequest,
  GetAssociatedEnclaveCertificateIamRolesResult,
  GetAssociatedEnclaveCertificateIamRolesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetAssociatedEnclaveCertificateIamRolesRequest,
  output: GetAssociatedEnclaveCertificateIamRolesResult,
  errors: [
    RequestLimitExceeded,
    InvalidCertificateArnMalformed,
    UnauthorizedOperation,
  ],
}));
export type GetAssociatedIpv6PoolCidrsError =
  | RequestLimitExceeded
  | InvalidIpv6PoolIDMalformed
  | CommonErrors;
/**
 * Gets information about the IPv6 CIDR block associations for a specified IPv6 address pool.
 */
export const getAssociatedIpv6PoolCidrs: API.OperationMethod<
  GetAssociatedIpv6PoolCidrsRequest,
  GetAssociatedIpv6PoolCidrsResult,
  GetAssociatedIpv6PoolCidrsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetAssociatedIpv6PoolCidrsRequest,
  ) => stream.Stream<
    GetAssociatedIpv6PoolCidrsResult,
    GetAssociatedIpv6PoolCidrsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetAssociatedIpv6PoolCidrsRequest,
  ) => stream.Stream<
    Ipv6CidrAssociation,
    GetAssociatedIpv6PoolCidrsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetAssociatedIpv6PoolCidrsRequest,
  output: GetAssociatedIpv6PoolCidrsResult,
  errors: [RequestLimitExceeded, InvalidIpv6PoolIDMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Ipv6CidrAssociations",
    pageSize: "MaxResults",
  } as const,
}));
export type GetAwsNetworkPerformanceDataError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Gets network performance data.
 */
export const getAwsNetworkPerformanceData: API.OperationMethod<
  GetAwsNetworkPerformanceDataRequest,
  GetAwsNetworkPerformanceDataResult,
  GetAwsNetworkPerformanceDataError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetAwsNetworkPerformanceDataRequest,
  ) => stream.Stream<
    GetAwsNetworkPerformanceDataResult,
    GetAwsNetworkPerformanceDataError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetAwsNetworkPerformanceDataRequest,
  ) => stream.Stream<
    DataResponse,
    GetAwsNetworkPerformanceDataError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetAwsNetworkPerformanceDataRequest,
  output: GetAwsNetworkPerformanceDataResult,
  errors: [RequestLimitExceeded, MissingParameter],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "DataResponses",
    pageSize: "MaxResults",
  } as const,
}));
export type GetCapacityManagerAttributesError = CommonErrors;
/**
 * Retrieves the current configuration and status of EC2 Capacity Manager for your account, including enablement status, Organizations access settings, and data ingestion status.
 */
export const getCapacityManagerAttributes: API.OperationMethod<
  GetCapacityManagerAttributesRequest,
  GetCapacityManagerAttributesResult,
  GetCapacityManagerAttributesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetCapacityManagerAttributesRequest,
  output: GetCapacityManagerAttributesResult,
  errors: [],
}));
export type GetCapacityManagerMetricDataError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Retrieves capacity usage metrics for your EC2 resources. Returns time-series data for metrics like unused capacity, utilization rates, and costs
 * across On-Demand, Spot, and Capacity Reservations. Data can be grouped and filtered by various dimensions such as region, account, and instance family.
 */
export const getCapacityManagerMetricData: API.OperationMethod<
  GetCapacityManagerMetricDataRequest,
  GetCapacityManagerMetricDataResult,
  GetCapacityManagerMetricDataError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetCapacityManagerMetricDataRequest,
  ) => stream.Stream<
    GetCapacityManagerMetricDataResult,
    GetCapacityManagerMetricDataError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetCapacityManagerMetricDataRequest,
  ) => stream.Stream<
    MetricDataResult,
    GetCapacityManagerMetricDataError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetCapacityManagerMetricDataRequest,
  output: GetCapacityManagerMetricDataResult,
  errors: [RequestLimitExceeded, MissingParameter],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "MetricDataResults",
    pageSize: "MaxResults",
  } as const,
}));
export type GetCapacityManagerMetricDimensionsError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Retrieves the available dimension values for capacity metrics within a specified time range. This is useful for discovering what accounts,
 * regions, instance families, and other dimensions have data available for filtering and grouping.
 */
export const getCapacityManagerMetricDimensions: API.OperationMethod<
  GetCapacityManagerMetricDimensionsRequest,
  GetCapacityManagerMetricDimensionsResult,
  GetCapacityManagerMetricDimensionsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetCapacityManagerMetricDimensionsRequest,
  ) => stream.Stream<
    GetCapacityManagerMetricDimensionsResult,
    GetCapacityManagerMetricDimensionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetCapacityManagerMetricDimensionsRequest,
  ) => stream.Stream<
    CapacityManagerDimension,
    GetCapacityManagerMetricDimensionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetCapacityManagerMetricDimensionsRequest,
  output: GetCapacityManagerMetricDimensionsResult,
  errors: [RequestLimitExceeded, MissingParameter],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "MetricDimensionResults",
    pageSize: "MaxResults",
  } as const,
}));
export type GetCapacityReservationUsageError =
  | RequestLimitExceeded
  | InvalidCapacityReservationIdMalformed
  | CommonErrors;
/**
 * Gets usage information about a Capacity Reservation. If the Capacity Reservation is
 * shared, it shows usage information for the Capacity Reservation owner and each Amazon Web Services account that is currently using the shared capacity. If the Capacity
 * Reservation is not shared, it shows only the Capacity Reservation owner's usage.
 */
export const getCapacityReservationUsage: API.OperationMethod<
  GetCapacityReservationUsageRequest,
  GetCapacityReservationUsageResult,
  GetCapacityReservationUsageError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetCapacityReservationUsageRequest,
  output: GetCapacityReservationUsageResult,
  errors: [RequestLimitExceeded, InvalidCapacityReservationIdMalformed],
}));
export type GetCoipPoolUsageError =
  | RequestLimitExceeded
  | InvalidPoolIDMalformed
  | CommonErrors;
/**
 * Describes the allocations from the specified customer-owned address pool.
 */
export const getCoipPoolUsage: API.OperationMethod<
  GetCoipPoolUsageRequest,
  GetCoipPoolUsageResult,
  GetCoipPoolUsageError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetCoipPoolUsageRequest,
  output: GetCoipPoolUsageResult,
  errors: [RequestLimitExceeded, InvalidPoolIDMalformed],
}));
export type GetConsoleOutputError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | InvalidInstanceIDNotFound
  | CommonErrors;
/**
 * Gets the console output for the specified instance. For Linux instances, the instance
 * console output displays the exact console output that would normally be displayed on a
 * physical monitor attached to a computer. For Windows instances, the instance console
 * output includes the last three system event log errors.
 *
 * For more information, see Instance
 * console output in the *Amazon EC2 User Guide*.
 */
export const getConsoleOutput: API.OperationMethod<
  GetConsoleOutputRequest,
  GetConsoleOutputResult,
  GetConsoleOutputError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetConsoleOutputRequest,
  output: GetConsoleOutputResult,
  errors: [
    RequestLimitExceeded,
    InvalidInstanceIDMalformed,
    InvalidInstanceIDNotFound,
  ],
}));
export type GetConsoleScreenshotError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | InvalidInstanceIDNotFound
  | CommonErrors;
/**
 * Retrieve a JPG-format screenshot of a running instance to help with
 * troubleshooting.
 *
 * The returned content is Base64-encoded.
 *
 * For more information, see Instance console output in the *Amazon EC2 User Guide*.
 */
export const getConsoleScreenshot: API.OperationMethod<
  GetConsoleScreenshotRequest,
  GetConsoleScreenshotResult,
  GetConsoleScreenshotError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetConsoleScreenshotRequest,
  output: GetConsoleScreenshotResult,
  errors: [
    RequestLimitExceeded,
    InvalidInstanceIDMalformed,
    InvalidInstanceIDNotFound,
  ],
}));
export type GetDeclarativePoliciesReportSummaryError =
  | RequestLimitExceeded
  | InvalidDeclarativePoliciesReportIdMalformed
  | CommonErrors;
/**
 * Retrieves a summary of the account status report.
 *
 * To view the full report, download it from the Amazon S3 bucket where it was saved.
 * Reports are accessible only when they have the `complete` status. Reports
 * with other statuses (`running`, `cancelled`, or
 * `error`) are not available in the S3 bucket. For more information about
 * downloading objects from an S3 bucket, see Downloading objects in
 * the *Amazon Simple Storage Service User Guide*.
 *
 * For more information, see Generating the account status report for declarative policies in the
 * *Amazon Web Services Organizations User Guide*.
 */
export const getDeclarativePoliciesReportSummary: API.OperationMethod<
  GetDeclarativePoliciesReportSummaryRequest,
  GetDeclarativePoliciesReportSummaryResult,
  GetDeclarativePoliciesReportSummaryError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetDeclarativePoliciesReportSummaryRequest,
  output: GetDeclarativePoliciesReportSummaryResult,
  errors: [RequestLimitExceeded, InvalidDeclarativePoliciesReportIdMalformed],
}));
export type GetDefaultCreditSpecificationError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Describes the default credit option for CPU usage of a burstable performance instance
 * family.
 *
 * For more information, see Burstable
 * performance instances in the *Amazon EC2 User Guide*.
 */
export const getDefaultCreditSpecification: API.OperationMethod<
  GetDefaultCreditSpecificationRequest,
  GetDefaultCreditSpecificationResult,
  GetDefaultCreditSpecificationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetDefaultCreditSpecificationRequest,
  output: GetDefaultCreditSpecificationResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type GetEbsDefaultKmsKeyIdError = CommonErrors;
/**
 * Describes the default KMS key for EBS encryption by default for your account in this Region.
 *
 * For more information, see Amazon EBS encryption
 * in the *Amazon EBS User Guide*.
 */
export const getEbsDefaultKmsKeyId: API.OperationMethod<
  GetEbsDefaultKmsKeyIdRequest,
  GetEbsDefaultKmsKeyIdResult,
  GetEbsDefaultKmsKeyIdError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetEbsDefaultKmsKeyIdRequest,
  output: GetEbsDefaultKmsKeyIdResult,
  errors: [],
}));
export type GetEbsEncryptionByDefaultError = CommonErrors;
/**
 * Describes whether EBS encryption by default is enabled for your account in the current
 * Region.
 *
 * For more information, see Amazon EBS encryption
 * in the *Amazon EBS User Guide*.
 */
export const getEbsEncryptionByDefault: API.OperationMethod<
  GetEbsEncryptionByDefaultRequest,
  GetEbsEncryptionByDefaultResult,
  GetEbsEncryptionByDefaultError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetEbsEncryptionByDefaultRequest,
  output: GetEbsEncryptionByDefaultResult,
  errors: [],
}));
export type GetEnabledIpamPolicyError = CommonErrors;
/**
 * Gets the enabled IPAM policy.
 *
 * An IPAM policy is a set of rules that define how public IPv4 addresses from IPAM pools are allocated to Amazon Web Services resources. Each rule maps an Amazon Web Services service to IPAM pools that the service will use to get IP addresses. A single policy can have multiple rules and be applied to multiple Amazon Web Services Regions. If the IPAM pool run out of addresses then the services fallback to Amazon-provided IP addresses. A policy can be applied to an individual Amazon Web Services account or an entity within Amazon Web Services Organizations.
 */
export const getEnabledIpamPolicy: API.OperationMethod<
  GetEnabledIpamPolicyRequest,
  GetEnabledIpamPolicyResult,
  GetEnabledIpamPolicyError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetEnabledIpamPolicyRequest,
  output: GetEnabledIpamPolicyResult,
  errors: [],
}));
export type GetFlowLogsIntegrationTemplateError = CommonErrors;
/**
 * Generates a CloudFormation template that streamlines and automates the integration of VPC flow logs
 * with Amazon Athena. This make it easier for you to query and gain insights from VPC flow logs data.
 * Based on the information that you provide, we configure resources in the template to do the following:
 *
 * - Create a table in Athena that maps fields to a custom log format
 *
 * - Create a Lambda function that updates the table with new partitions on a daily, weekly, or
 * monthly basis
 *
 * - Create a table partitioned between two timestamps in the past
 *
 * - Create a set of named queries in Athena that you can use to get started quickly
 *
 * `GetFlowLogsIntegrationTemplate` does not support integration between
 * Amazon Web Services Transit Gateway Flow Logs and Amazon Athena.
 */
export const getFlowLogsIntegrationTemplate: API.OperationMethod<
  GetFlowLogsIntegrationTemplateRequest,
  GetFlowLogsIntegrationTemplateResult,
  GetFlowLogsIntegrationTemplateError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetFlowLogsIntegrationTemplateRequest,
  output: GetFlowLogsIntegrationTemplateResult,
  errors: [],
}));
export type GetGroupsForCapacityReservationError =
  | RequestLimitExceeded
  | InvalidCapacityReservationIdMalformed
  | CommonErrors;
/**
 * Lists the resource groups to which a Capacity Reservation has been added.
 */
export const getGroupsForCapacityReservation: API.OperationMethod<
  GetGroupsForCapacityReservationRequest,
  GetGroupsForCapacityReservationResult,
  GetGroupsForCapacityReservationError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetGroupsForCapacityReservationRequest,
  ) => stream.Stream<
    GetGroupsForCapacityReservationResult,
    GetGroupsForCapacityReservationError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetGroupsForCapacityReservationRequest,
  ) => stream.Stream<
    CapacityReservationGroup,
    GetGroupsForCapacityReservationError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetGroupsForCapacityReservationRequest,
  output: GetGroupsForCapacityReservationResult,
  errors: [RequestLimitExceeded, InvalidCapacityReservationIdMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "CapacityReservationGroups",
    pageSize: "MaxResults",
  } as const,
}));
export type GetHostReservationPurchasePreviewError = CommonErrors;
/**
 * Preview a reservation purchase with configurations that match those of your Dedicated
 * Host. You must have active Dedicated Hosts in your account before you purchase a
 * reservation.
 *
 * This is a preview of the PurchaseHostReservation action and does not
 * result in the offering being purchased.
 */
export const getHostReservationPurchasePreview: API.OperationMethod<
  GetHostReservationPurchasePreviewRequest,
  GetHostReservationPurchasePreviewResult,
  GetHostReservationPurchasePreviewError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetHostReservationPurchasePreviewRequest,
  output: GetHostReservationPurchasePreviewResult,
  errors: [],
}));
export type GetImageAncestryError =
  | RequestLimitExceeded
  | InvalidAMIIDMalformed
  | CommonErrors;
/**
 * Retrieves the ancestry chain of the specified AMI, tracing its lineage back to the root
 * AMI. For more information, see AMI ancestry in
 * *Amazon EC2 User Guide*.
 */
export const getImageAncestry: API.OperationMethod<
  GetImageAncestryRequest,
  GetImageAncestryResult,
  GetImageAncestryError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetImageAncestryRequest,
  output: GetImageAncestryResult,
  errors: [RequestLimitExceeded, InvalidAMIIDMalformed],
}));
export type GetImageBlockPublicAccessStateError = CommonErrors;
/**
 * Gets the current state of *block public access for AMIs* at the account
 * level in the specified Amazon Web Services Region.
 *
 * For more information, see Block
 * public access to your AMIs in the *Amazon EC2 User Guide*.
 */
export const getImageBlockPublicAccessState: API.OperationMethod<
  GetImageBlockPublicAccessStateRequest,
  GetImageBlockPublicAccessStateResult,
  GetImageBlockPublicAccessStateError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetImageBlockPublicAccessStateRequest,
  output: GetImageBlockPublicAccessStateResult,
  errors: [],
}));
export type GetInstanceMetadataDefaultsError = CommonErrors;
/**
 * Gets the default instance metadata service (IMDS) settings that are set at the account
 * level in the specified Amazon Web Services
 Region.
 * 
 * For more information, see Order of precedence for instance metadata options in the
 * *Amazon EC2 User Guide*.
 */
export const getInstanceMetadataDefaults: API.OperationMethod<
  GetInstanceMetadataDefaultsRequest,
  GetInstanceMetadataDefaultsResult,
  GetInstanceMetadataDefaultsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetInstanceMetadataDefaultsRequest,
  output: GetInstanceMetadataDefaultsResult,
  errors: [],
}));
export type GetInstanceTpmEkPubError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Gets the public endorsement key associated with the Nitro Trusted
 * Platform Module (NitroTPM) for the specified instance.
 */
export const getInstanceTpmEkPub: API.OperationMethod<
  GetInstanceTpmEkPubRequest,
  GetInstanceTpmEkPubResult,
  GetInstanceTpmEkPubError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetInstanceTpmEkPubRequest,
  output: GetInstanceTpmEkPubResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type GetInstanceTypesFromInstanceRequirementsError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Returns a list of instance types with the specified instance attributes. You can
 * use the response to preview the instance types without launching instances. Note
 * that the response does not consider capacity.
 *
 * When you specify multiple parameters, you get instance types that satisfy all of the
 * specified parameters. If you specify multiple values for a parameter, you get instance
 * types that satisfy any of the specified values.
 *
 * For more information, see Preview instance types with specified attributes, Specify attributes for instance type selection for EC2 Fleet or Spot Fleet, and Spot
 * placement score in the *Amazon EC2 User Guide*, and Creating
 * mixed instance groups using attribute-based instance type selection in the
 * *Amazon EC2 Auto Scaling User Guide*.
 */
export const getInstanceTypesFromInstanceRequirements: API.OperationMethod<
  GetInstanceTypesFromInstanceRequirementsRequest,
  GetInstanceTypesFromInstanceRequirementsResult,
  GetInstanceTypesFromInstanceRequirementsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetInstanceTypesFromInstanceRequirementsRequest,
  ) => stream.Stream<
    GetInstanceTypesFromInstanceRequirementsResult,
    GetInstanceTypesFromInstanceRequirementsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetInstanceTypesFromInstanceRequirementsRequest,
  ) => stream.Stream<
    InstanceTypeInfoFromInstanceRequirements,
    GetInstanceTypesFromInstanceRequirementsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetInstanceTypesFromInstanceRequirementsRequest,
  output: GetInstanceTypesFromInstanceRequirementsResult,
  errors: [RequestLimitExceeded, MissingParameter],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "InstanceTypes",
    pageSize: "MaxResults",
  } as const,
}));
export type GetInstanceUefiDataError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | CommonErrors;
/**
 * A binary representation of the UEFI variable store. Only non-volatile variables are
 * stored. This is a base64 encoded and zlib compressed binary value that must be properly
 * encoded.
 *
 * When you use register-image to create
 * an AMI, you can create an exact copy of your variable store by passing the UEFI data in
 * the `UefiData` parameter. You can modify the UEFI data by using the python-uefivars tool on
 * GitHub. You can use the tool to convert the UEFI data into a human-readable format
 * (JSON), which you can inspect and modify, and then convert back into the binary format
 * to use with register-image.
 *
 * For more information, see UEFI Secure Boot in the
 * *Amazon EC2 User Guide*.
 */
export const getInstanceUefiData: API.OperationMethod<
  GetInstanceUefiDataRequest,
  GetInstanceUefiDataResult,
  GetInstanceUefiDataError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetInstanceUefiDataRequest,
  output: GetInstanceUefiDataResult,
  errors: [RequestLimitExceeded, InvalidInstanceIDMalformed],
}));
export type GetIpamAddressHistoryError =
  | RequestLimitExceeded
  | InvalidIpamScopeIdNotFound
  | CommonErrors;
/**
 * Retrieve historical information about a CIDR within an IPAM scope. For more information, see View the history of IP addresses in the *Amazon VPC IPAM User Guide*.
 */
export const getIpamAddressHistory: API.OperationMethod<
  GetIpamAddressHistoryRequest,
  GetIpamAddressHistoryResult,
  GetIpamAddressHistoryError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetIpamAddressHistoryRequest,
  ) => stream.Stream<
    GetIpamAddressHistoryResult,
    GetIpamAddressHistoryError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetIpamAddressHistoryRequest,
  ) => stream.Stream<
    IpamAddressHistoryRecord,
    GetIpamAddressHistoryError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetIpamAddressHistoryRequest,
  output: GetIpamAddressHistoryResult,
  errors: [RequestLimitExceeded, InvalidIpamScopeIdNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "HistoryRecords",
    pageSize: "MaxResults",
  } as const,
}));
export type GetIpamDiscoveredAccountsError =
  | RequestLimitExceeded
  | InvalidIpamResourceDiscoveryIdMalformed
  | InvalidIpamResourceDiscoveryIdNotFound
  | CommonErrors;
/**
 * Gets IPAM discovered accounts. A discovered account is an Amazon Web Services account that is monitored under a resource discovery. If you have integrated IPAM with Amazon Web Services Organizations, all accounts in the organization are discovered accounts. Only the IPAM account can get all discovered accounts in the organization.
 */
export const getIpamDiscoveredAccounts: API.OperationMethod<
  GetIpamDiscoveredAccountsRequest,
  GetIpamDiscoveredAccountsResult,
  GetIpamDiscoveredAccountsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetIpamDiscoveredAccountsRequest,
  ) => stream.Stream<
    GetIpamDiscoveredAccountsResult,
    GetIpamDiscoveredAccountsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetIpamDiscoveredAccountsRequest,
  ) => stream.Stream<
    IpamDiscoveredAccount,
    GetIpamDiscoveredAccountsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetIpamDiscoveredAccountsRequest,
  output: GetIpamDiscoveredAccountsResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamResourceDiscoveryIdMalformed,
    InvalidIpamResourceDiscoveryIdNotFound,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "IpamDiscoveredAccounts",
    pageSize: "MaxResults",
  } as const,
}));
export type GetIpamDiscoveredPublicAddressesError =
  | RequestLimitExceeded
  | InvalidIpamResourceDiscoveryIdMalformed
  | InvalidIpamResourceDiscoveryIdNotFound
  | CommonErrors;
/**
 * Gets the public IP addresses that have been discovered by IPAM.
 */
export const getIpamDiscoveredPublicAddresses: API.OperationMethod<
  GetIpamDiscoveredPublicAddressesRequest,
  GetIpamDiscoveredPublicAddressesResult,
  GetIpamDiscoveredPublicAddressesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetIpamDiscoveredPublicAddressesRequest,
  output: GetIpamDiscoveredPublicAddressesResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamResourceDiscoveryIdMalformed,
    InvalidIpamResourceDiscoveryIdNotFound,
  ],
}));
export type GetIpamDiscoveredResourceCidrsError =
  | RequestLimitExceeded
  | InvalidIpamResourceDiscoveryIdMalformed
  | InvalidIpamResourceDiscoveryIdNotFound
  | CommonErrors;
/**
 * Returns the resource CIDRs that are monitored as part of a resource discovery. A discovered resource is a resource CIDR monitored under a resource discovery. The following resources can be discovered: VPCs, Public IPv4 pools, VPC subnets, and Elastic IP addresses.
 */
export const getIpamDiscoveredResourceCidrs: API.OperationMethod<
  GetIpamDiscoveredResourceCidrsRequest,
  GetIpamDiscoveredResourceCidrsResult,
  GetIpamDiscoveredResourceCidrsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetIpamDiscoveredResourceCidrsRequest,
  ) => stream.Stream<
    GetIpamDiscoveredResourceCidrsResult,
    GetIpamDiscoveredResourceCidrsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetIpamDiscoveredResourceCidrsRequest,
  ) => stream.Stream<
    IpamDiscoveredResourceCidr,
    GetIpamDiscoveredResourceCidrsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetIpamDiscoveredResourceCidrsRequest,
  output: GetIpamDiscoveredResourceCidrsResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamResourceDiscoveryIdMalformed,
    InvalidIpamResourceDiscoveryIdNotFound,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "IpamDiscoveredResourceCidrs",
    pageSize: "MaxResults",
  } as const,
}));
export type GetIpamPolicyAllocationRulesError =
  | RequestLimitExceeded
  | InvalidIpamPolicyIdMalformed
  | InvalidIpamPolicyIdNotFound
  | CommonErrors;
/**
 * Gets the allocation rules for an IPAM policy.
 *
 * An IPAM policy is a set of rules that define how public IPv4 addresses from IPAM pools are allocated to Amazon Web Services resources. Each rule maps an Amazon Web Services service to IPAM pools that the service will use to get IP addresses. A single policy can have multiple rules and be applied to multiple Amazon Web Services Regions. If the IPAM pool run out of addresses then the services fallback to Amazon-provided IP addresses. A policy can be applied to an individual Amazon Web Services account or an entity within Amazon Web Services Organizations.
 *
 * Allocation rules are optional configurations within an IPAM policy that map Amazon Web Services resource types to specific IPAM pools. If no rules are defined, the resource types default to using Amazon-provided IP addresses.
 */
export const getIpamPolicyAllocationRules: API.OperationMethod<
  GetIpamPolicyAllocationRulesRequest,
  GetIpamPolicyAllocationRulesResult,
  GetIpamPolicyAllocationRulesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetIpamPolicyAllocationRulesRequest,
  output: GetIpamPolicyAllocationRulesResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamPolicyIdMalformed,
    InvalidIpamPolicyIdNotFound,
  ],
}));
export type GetIpamPolicyOrganizationTargetsError =
  | RequestLimitExceeded
  | InvalidIpamPolicyIdMalformed
  | InvalidIpamPolicyIdNotFound
  | CommonErrors;
/**
 * Gets the Amazon Web Services Organizations targets for an IPAM policy.
 *
 * An IPAM policy is a set of rules that define how public IPv4 addresses from IPAM pools are allocated to Amazon Web Services resources. Each rule maps an Amazon Web Services service to IPAM pools that the service will use to get IP addresses. A single policy can have multiple rules and be applied to multiple Amazon Web Services Regions. If the IPAM pool run out of addresses then the services fallback to Amazon-provided IP addresses. A policy can be applied to an individual Amazon Web Services account or an entity within Amazon Web Services Organizations.
 *
 * A target can be an individual Amazon Web Services account or an entity within an Amazon Web Services Organization to which an IPAM policy can be applied.
 */
export const getIpamPolicyOrganizationTargets: API.OperationMethod<
  GetIpamPolicyOrganizationTargetsRequest,
  GetIpamPolicyOrganizationTargetsResult,
  GetIpamPolicyOrganizationTargetsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetIpamPolicyOrganizationTargetsRequest,
  output: GetIpamPolicyOrganizationTargetsResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamPolicyIdMalformed,
    InvalidIpamPolicyIdNotFound,
  ],
}));
export type GetIpamPoolAllocationsError =
  | RequestLimitExceeded
  | InvalidIpamPoolIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Get a list of all the CIDR allocations in an IPAM pool. The Region you use should be the IPAM pool locale. The locale is the Amazon Web Services Region where this IPAM pool is available for allocations.
 *
 * If you use this action after AllocateIpamPoolCidr or ReleaseIpamPoolAllocation, note that all EC2 API actions follow an eventual consistency model.
 */
export const getIpamPoolAllocations: API.OperationMethod<
  GetIpamPoolAllocationsRequest,
  GetIpamPoolAllocationsResult,
  GetIpamPoolAllocationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetIpamPoolAllocationsRequest,
  ) => stream.Stream<
    GetIpamPoolAllocationsResult,
    GetIpamPoolAllocationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetIpamPoolAllocationsRequest,
  ) => stream.Stream<
    IpamPoolAllocation,
    GetIpamPoolAllocationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetIpamPoolAllocationsRequest,
  output: GetIpamPoolAllocationsResult,
  errors: [RequestLimitExceeded, InvalidIpamPoolIdNotFound, MissingParameter],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "IpamPoolAllocations",
    pageSize: "MaxResults",
  } as const,
}));
export type GetIpamPoolCidrsError =
  | RequestLimitExceeded
  | InvalidIpamPoolIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Get the CIDRs provisioned to an IPAM pool.
 */
export const getIpamPoolCidrs: API.OperationMethod<
  GetIpamPoolCidrsRequest,
  GetIpamPoolCidrsResult,
  GetIpamPoolCidrsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetIpamPoolCidrsRequest,
  ) => stream.Stream<
    GetIpamPoolCidrsResult,
    GetIpamPoolCidrsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetIpamPoolCidrsRequest,
  ) => stream.Stream<
    IpamPoolCidr,
    GetIpamPoolCidrsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetIpamPoolCidrsRequest,
  output: GetIpamPoolCidrsResult,
  errors: [RequestLimitExceeded, InvalidIpamPoolIdNotFound, MissingParameter],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "IpamPoolCidrs",
    pageSize: "MaxResults",
  } as const,
}));
export type GetIpamPrefixListResolverRulesError =
  | RequestLimitExceeded
  | InvalidIpamPrefixListResolverIdMalformed
  | InvalidIpamPrefixListResolverIdNotFound
  | CommonErrors;
/**
 * Retrieves the CIDR selection rules for an IPAM prefix list resolver. Use this operation to view the business logic that determines which CIDRs are selected for synchronization with prefix lists.
 */
export const getIpamPrefixListResolverRules: API.OperationMethod<
  GetIpamPrefixListResolverRulesRequest,
  GetIpamPrefixListResolverRulesResult,
  GetIpamPrefixListResolverRulesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetIpamPrefixListResolverRulesRequest,
  ) => stream.Stream<
    GetIpamPrefixListResolverRulesResult,
    GetIpamPrefixListResolverRulesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetIpamPrefixListResolverRulesRequest,
  ) => stream.Stream<
    IpamPrefixListResolverRule,
    GetIpamPrefixListResolverRulesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetIpamPrefixListResolverRulesRequest,
  output: GetIpamPrefixListResolverRulesResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamPrefixListResolverIdMalformed,
    InvalidIpamPrefixListResolverIdNotFound,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Rules",
    pageSize: "MaxResults",
  } as const,
}));
export type GetIpamPrefixListResolverVersionEntriesError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Retrieves the CIDR entries for a specific version of an IPAM prefix list resolver. This shows the actual CIDRs that were selected and synchronized at a particular point in time.
 */
export const getIpamPrefixListResolverVersionEntries: API.OperationMethod<
  GetIpamPrefixListResolverVersionEntriesRequest,
  GetIpamPrefixListResolverVersionEntriesResult,
  GetIpamPrefixListResolverVersionEntriesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetIpamPrefixListResolverVersionEntriesRequest,
  ) => stream.Stream<
    GetIpamPrefixListResolverVersionEntriesResult,
    GetIpamPrefixListResolverVersionEntriesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetIpamPrefixListResolverVersionEntriesRequest,
  ) => stream.Stream<
    IpamPrefixListResolverVersionEntry,
    GetIpamPrefixListResolverVersionEntriesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetIpamPrefixListResolverVersionEntriesRequest,
  output: GetIpamPrefixListResolverVersionEntriesResult,
  errors: [RequestLimitExceeded, MissingParameter],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Entries",
    pageSize: "MaxResults",
  } as const,
}));
export type GetIpamPrefixListResolverVersionsError =
  | RequestLimitExceeded
  | InvalidIpamPrefixListResolverIdMalformed
  | InvalidIpamPrefixListResolverIdNotFound
  | CommonErrors;
/**
 * Retrieves version information for an IPAM prefix list resolver.
 *
 * Each version is a snapshot of what CIDRs matched your rules at that moment in time. The version number increments every time the CIDR list
 * changes due to infrastructure changes.
 *
 * **Version example:**
 *
 * **Initial State (Version 1)**
 *
 * Production environment:
 *
 * - vpc-prod-web (10.1.0.0/16) - tagged env=prod
 *
 * - vpc-prod-db (10.2.0.0/16) - tagged env=prod
 *
 * Resolver rule: Include all VPCs tagged env=prod
 *
 * **Version 1 CIDRs:** 10.1.0.0/16, 10.2.0.0/16
 *
 * **Infrastructure Change (Version 2)**
 *
 * New VPC added:
 *
 * - vpc-prod-api (10.3.0.0/16) - tagged env=prod
 *
 * IPAM automatically detects the change and creates a new version.
 *
 * **Version 2 CIDRs:** 10.1.0.0/16, 10.2.0.0/16, 10.3.0.0/16
 */
export const getIpamPrefixListResolverVersions: API.OperationMethod<
  GetIpamPrefixListResolverVersionsRequest,
  GetIpamPrefixListResolverVersionsResult,
  GetIpamPrefixListResolverVersionsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetIpamPrefixListResolverVersionsRequest,
  ) => stream.Stream<
    GetIpamPrefixListResolverVersionsResult,
    GetIpamPrefixListResolverVersionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetIpamPrefixListResolverVersionsRequest,
  ) => stream.Stream<
    IpamPrefixListResolverVersion,
    GetIpamPrefixListResolverVersionsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetIpamPrefixListResolverVersionsRequest,
  output: GetIpamPrefixListResolverVersionsResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamPrefixListResolverIdMalformed,
    InvalidIpamPrefixListResolverIdNotFound,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "IpamPrefixListResolverVersions",
    pageSize: "MaxResults",
  } as const,
}));
export type GetIpamResourceCidrsError =
  | RequestLimitExceeded
  | InvalidIpamPoolIdNotFound
  | InvalidIpamScopeIdNotFound
  | CommonErrors;
/**
 * Returns resource CIDRs managed by IPAM in a given scope. If an IPAM is associated with more than one resource discovery, the resource CIDRs across all of the resource discoveries is returned. A resource discovery is an IPAM component that enables IPAM to manage and monitor resources that belong to the owning account.
 */
export const getIpamResourceCidrs: API.OperationMethod<
  GetIpamResourceCidrsRequest,
  GetIpamResourceCidrsResult,
  GetIpamResourceCidrsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetIpamResourceCidrsRequest,
  ) => stream.Stream<
    GetIpamResourceCidrsResult,
    GetIpamResourceCidrsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetIpamResourceCidrsRequest,
  ) => stream.Stream<
    IpamResourceCidr,
    GetIpamResourceCidrsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetIpamResourceCidrsRequest,
  output: GetIpamResourceCidrsResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamPoolIdNotFound,
    InvalidIpamScopeIdNotFound,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "IpamResourceCidrs",
    pageSize: "MaxResults",
  } as const,
}));
export type GetLaunchTemplateDataError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | CommonErrors;
/**
 * Retrieves the configuration data of the specified instance. You can use this data to
 * create a launch template.
 *
 * This action calls on other describe actions to get instance information. Depending on
 * your instance configuration, you may need to allow the following actions in your IAM
 * policy: `DescribeSpotInstanceRequests`,
 * `DescribeInstanceCreditSpecifications`, `DescribeVolumes`, and
 * `DescribeInstanceAttribute`.
 * Or, you can allow `describe*` depending on your instance requirements.
 */
export const getLaunchTemplateData: API.OperationMethod<
  GetLaunchTemplateDataRequest,
  GetLaunchTemplateDataResult,
  GetLaunchTemplateDataError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetLaunchTemplateDataRequest,
  output: GetLaunchTemplateDataResult,
  errors: [RequestLimitExceeded, InvalidInstanceIDMalformed],
}));
export type GetManagedPrefixListAssociationsError =
  | RequestLimitExceeded
  | InvalidPrefixListIDNotFound
  | InvalidPrefixListIdMalformed
  | CommonErrors;
/**
 * Gets information about the resources that are associated with the specified managed prefix list.
 */
export const getManagedPrefixListAssociations: API.OperationMethod<
  GetManagedPrefixListAssociationsRequest,
  GetManagedPrefixListAssociationsResult,
  GetManagedPrefixListAssociationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetManagedPrefixListAssociationsRequest,
  ) => stream.Stream<
    GetManagedPrefixListAssociationsResult,
    GetManagedPrefixListAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetManagedPrefixListAssociationsRequest,
  ) => stream.Stream<
    PrefixListAssociation,
    GetManagedPrefixListAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetManagedPrefixListAssociationsRequest,
  output: GetManagedPrefixListAssociationsResult,
  errors: [
    RequestLimitExceeded,
    InvalidPrefixListIDNotFound,
    InvalidPrefixListIdMalformed,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PrefixListAssociations",
    pageSize: "MaxResults",
  } as const,
}));
export type GetManagedPrefixListEntriesError =
  | RequestLimitExceeded
  | InvalidPrefixListIDNotFound
  | InvalidPrefixListIdMalformed
  | ParseError
  | CommonErrors;
/**
 * Gets information about the entries for a specified managed prefix list.
 */
export const getManagedPrefixListEntries: API.OperationMethod<
  GetManagedPrefixListEntriesRequest,
  GetManagedPrefixListEntriesResult,
  GetManagedPrefixListEntriesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetManagedPrefixListEntriesRequest,
  ) => stream.Stream<
    GetManagedPrefixListEntriesResult,
    GetManagedPrefixListEntriesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetManagedPrefixListEntriesRequest,
  ) => stream.Stream<
    PrefixListEntry,
    GetManagedPrefixListEntriesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetManagedPrefixListEntriesRequest,
  output: GetManagedPrefixListEntriesResult,
  errors: [
    RequestLimitExceeded,
    InvalidPrefixListIDNotFound,
    InvalidPrefixListIdMalformed,
    ParseError,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Entries",
    pageSize: "MaxResults",
  } as const,
}));
export type GetNetworkInsightsAccessScopeAnalysisFindingsError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Gets the findings for the specified Network Access Scope analysis.
 */
export const getNetworkInsightsAccessScopeAnalysisFindings: API.OperationMethod<
  GetNetworkInsightsAccessScopeAnalysisFindingsRequest,
  GetNetworkInsightsAccessScopeAnalysisFindingsResult,
  GetNetworkInsightsAccessScopeAnalysisFindingsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetNetworkInsightsAccessScopeAnalysisFindingsRequest,
  ) => stream.Stream<
    GetNetworkInsightsAccessScopeAnalysisFindingsResult,
    GetNetworkInsightsAccessScopeAnalysisFindingsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetNetworkInsightsAccessScopeAnalysisFindingsRequest,
  ) => stream.Stream<
    AccessScopeAnalysisFinding,
    GetNetworkInsightsAccessScopeAnalysisFindingsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetNetworkInsightsAccessScopeAnalysisFindingsRequest,
  output: GetNetworkInsightsAccessScopeAnalysisFindingsResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AnalysisFindings",
    pageSize: "MaxResults",
  } as const,
}));
export type GetNetworkInsightsAccessScopeContentError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Gets the content for the specified Network Access Scope.
 */
export const getNetworkInsightsAccessScopeContent: API.OperationMethod<
  GetNetworkInsightsAccessScopeContentRequest,
  GetNetworkInsightsAccessScopeContentResult,
  GetNetworkInsightsAccessScopeContentError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetNetworkInsightsAccessScopeContentRequest,
  output: GetNetworkInsightsAccessScopeContentResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type GetPasswordDataError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | InvalidInstanceIDNotFound
  | CommonErrors;
/**
 * Retrieves the encrypted administrator password for a running Windows instance.
 *
 * The Windows password is generated at boot by the `EC2Config` service or
 * `EC2Launch` scripts (Windows Server 2016 and later). This usually only
 * happens the first time an instance is launched. For more information, see EC2Config and EC2Launch in the
 * *Amazon EC2 User Guide*.
 *
 * For the `EC2Config` service, the password is not generated for rebundled
 * AMIs unless `Ec2SetPassword` is enabled before bundling.
 *
 * The password is encrypted using the key pair that you specified when you launched the
 * instance. You must provide the corresponding key pair file.
 *
 * When you launch an instance, password generation and encryption may take a few
 * minutes. If you try to retrieve the password before it's available, the output returns
 * an empty string. We recommend that you wait up to 15 minutes after launching an instance
 * before trying to retrieve the generated password.
 */
export const getPasswordData: API.OperationMethod<
  GetPasswordDataRequest,
  GetPasswordDataResult,
  GetPasswordDataError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetPasswordDataRequest,
  output: GetPasswordDataResult,
  errors: [
    RequestLimitExceeded,
    InvalidInstanceIDMalformed,
    InvalidInstanceIDNotFound,
  ],
}));
export type GetReservedInstancesExchangeQuoteError =
  | RequestLimitExceeded
  | InvalidReservedInstancesIDNotFound
  | CommonErrors;
/**
 * Returns a quote and exchange information for exchanging one or more specified Convertible
 * Reserved Instances for a new Convertible Reserved Instance. If the exchange cannot be
 * performed, the reason is returned in the response. Use AcceptReservedInstancesExchangeQuote to perform the exchange.
 */
export const getReservedInstancesExchangeQuote: API.OperationMethod<
  GetReservedInstancesExchangeQuoteRequest,
  GetReservedInstancesExchangeQuoteResult,
  GetReservedInstancesExchangeQuoteError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetReservedInstancesExchangeQuoteRequest,
  output: GetReservedInstancesExchangeQuoteResult,
  errors: [RequestLimitExceeded, InvalidReservedInstancesIDNotFound],
}));
export type GetRouteServerAssociationsError =
  | RequestLimitExceeded
  | InvalidRouteServerIdNotFound
  | CommonErrors;
/**
 * Gets information about the associations for the specified route server.
 *
 * A route server association is the connection established between a route server and a VPC.
 *
 * For more information see Dynamic routing in your VPC with VPC Route Server in the *Amazon VPC User Guide*.
 */
export const getRouteServerAssociations: API.OperationMethod<
  GetRouteServerAssociationsRequest,
  GetRouteServerAssociationsResult,
  GetRouteServerAssociationsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetRouteServerAssociationsRequest,
  output: GetRouteServerAssociationsResult,
  errors: [RequestLimitExceeded, InvalidRouteServerIdNotFound],
}));
export type GetRouteServerPropagationsError =
  | RequestLimitExceeded
  | InvalidRouteServerIdNotFound
  | CommonErrors;
/**
 * Gets information about the route propagations for the specified route server.
 *
 * When enabled, route server propagation installs the routes in the FIB on the route table you've specified. Route server supports IPv4 and IPv6 route propagation.
 *
 * Amazon VPC Route Server simplifies routing for traffic between workloads that are deployed within a VPC and its internet gateways. With this feature,
 * VPC Route Server dynamically updates VPC and internet gateway route tables with your preferred IPv4 or IPv6 routes to achieve routing fault tolerance for those workloads. This enables you to automatically reroute traffic within a VPC, which increases the manageability of VPC routing and interoperability with third-party workloads.
 *
 * Route server supports the follow route table types:
 *
 * - VPC route tables not associated with subnets
 *
 * - Subnet route tables
 *
 * - Internet gateway route tables
 *
 * Route server does not support route tables associated with virtual private gateways. To propagate routes into a transit gateway route table, use Transit Gateway Connect.
 */
export const getRouteServerPropagations: API.OperationMethod<
  GetRouteServerPropagationsRequest,
  GetRouteServerPropagationsResult,
  GetRouteServerPropagationsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetRouteServerPropagationsRequest,
  output: GetRouteServerPropagationsResult,
  errors: [RequestLimitExceeded, InvalidRouteServerIdNotFound],
}));
export type GetRouteServerRoutingDatabaseError =
  | RequestLimitExceeded
  | InvalidRouteServerIdNotFound
  | CommonErrors;
/**
 * Gets the routing database for the specified route server. The Routing Information Base (RIB) serves as a database that stores all the routing information and network topology data collected by a router or routing system, such as routes learned from BGP peers. The RIB is constantly updated as new routing information is received or existing routes change. This ensures that the route server always has the most current view of the network topology and can make optimal routing decisions.
 *
 * Amazon VPC Route Server simplifies routing for traffic between workloads that are deployed within a VPC and its internet gateways. With this feature,
 * VPC Route Server dynamically updates VPC and internet gateway route tables with your preferred IPv4 or IPv6 routes to achieve routing fault tolerance for those workloads. This enables you to automatically reroute traffic within a VPC, which increases the manageability of VPC routing and interoperability with third-party workloads.
 *
 * Route server supports the follow route table types:
 *
 * - VPC route tables not associated with subnets
 *
 * - Subnet route tables
 *
 * - Internet gateway route tables
 *
 * Route server does not support route tables associated with virtual private gateways. To propagate routes into a transit gateway route table, use Transit Gateway Connect.
 */
export const getRouteServerRoutingDatabase: API.OperationMethod<
  GetRouteServerRoutingDatabaseRequest,
  GetRouteServerRoutingDatabaseResult,
  GetRouteServerRoutingDatabaseError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetRouteServerRoutingDatabaseRequest,
  output: GetRouteServerRoutingDatabaseResult,
  errors: [RequestLimitExceeded, InvalidRouteServerIdNotFound],
}));
export type GetSecurityGroupsForVpcError =
  | RequestLimitExceeded
  | InvalidVpcIdMalformed
  | ParseError
  | CommonErrors;
/**
 * Gets security groups that can be associated by the Amazon Web Services account making the request with network interfaces in the specified VPC.
 */
export const getSecurityGroupsForVpc: API.OperationMethod<
  GetSecurityGroupsForVpcRequest,
  GetSecurityGroupsForVpcResult,
  GetSecurityGroupsForVpcError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetSecurityGroupsForVpcRequest,
  ) => stream.Stream<
    GetSecurityGroupsForVpcResult,
    GetSecurityGroupsForVpcError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetSecurityGroupsForVpcRequest,
  ) => stream.Stream<
    SecurityGroupForVpc,
    GetSecurityGroupsForVpcError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetSecurityGroupsForVpcRequest,
  output: GetSecurityGroupsForVpcResult,
  errors: [RequestLimitExceeded, InvalidVpcIdMalformed, ParseError],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SecurityGroupForVpcs",
    pageSize: "MaxResults",
  } as const,
}));
export type GetSerialConsoleAccessStatusError = CommonErrors;
/**
 * Retrieves the access status of your account to the EC2 serial console of all instances. By
 * default, access to the EC2 serial console is disabled for your account. For more
 * information, see Manage account access to the EC2 serial console in the Amazon EC2
 * User Guide.
 */
export const getSerialConsoleAccessStatus: API.OperationMethod<
  GetSerialConsoleAccessStatusRequest,
  GetSerialConsoleAccessStatusResult,
  GetSerialConsoleAccessStatusError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetSerialConsoleAccessStatusRequest,
  output: GetSerialConsoleAccessStatusResult,
  errors: [],
}));
export type GetSnapshotBlockPublicAccessStateError = CommonErrors;
/**
 * Gets the current state of *block public access for snapshots* setting
 * for the account and Region.
 *
 * For more information, see
 * Block public access for snapshots in the *Amazon EBS User Guide*.
 */
export const getSnapshotBlockPublicAccessState: API.OperationMethod<
  GetSnapshotBlockPublicAccessStateRequest,
  GetSnapshotBlockPublicAccessStateResult,
  GetSnapshotBlockPublicAccessStateError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetSnapshotBlockPublicAccessStateRequest,
  output: GetSnapshotBlockPublicAccessStateResult,
  errors: [],
}));
export type GetSpotPlacementScoresError = CommonErrors;
/**
 * Calculates the Spot placement score for a Region or Availability Zone based on the
 * specified target capacity and compute requirements.
 *
 * You can specify your compute requirements either by using
 * `InstanceRequirementsWithMetadata` and letting Amazon EC2 choose the optimal
 * instance types to fulfill your Spot request, or you can specify the instance types by using
 * `InstanceTypes`.
 *
 * For more information, see Spot placement score in
 * the *Amazon EC2 User Guide*.
 */
export const getSpotPlacementScores: API.OperationMethod<
  GetSpotPlacementScoresRequest,
  GetSpotPlacementScoresResult,
  GetSpotPlacementScoresError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetSpotPlacementScoresRequest,
  ) => stream.Stream<
    GetSpotPlacementScoresResult,
    GetSpotPlacementScoresError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetSpotPlacementScoresRequest,
  ) => stream.Stream<
    SpotPlacementScore,
    GetSpotPlacementScoresError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetSpotPlacementScoresRequest,
  output: GetSpotPlacementScoresResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SpotPlacementScores",
    pageSize: "MaxResults",
  } as const,
}));
export type GetSubnetCidrReservationsError =
  | RequestLimitExceeded
  | InvalidSubnetIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Gets information about the subnet CIDR reservations.
 */
export const getSubnetCidrReservations: API.OperationMethod<
  GetSubnetCidrReservationsRequest,
  GetSubnetCidrReservationsResult,
  GetSubnetCidrReservationsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetSubnetCidrReservationsRequest,
  output: GetSubnetCidrReservationsResult,
  errors: [RequestLimitExceeded, InvalidSubnetIDNotFound, MissingParameter],
}));
export type GetTransitGatewayAttachmentPropagationsError =
  | RequestLimitExceeded
  | InvalidTransitGatewayAttachmentIDNotFound
  | CommonErrors;
/**
 * Lists the route tables to which the specified resource attachment propagates routes.
 */
export const getTransitGatewayAttachmentPropagations: API.OperationMethod<
  GetTransitGatewayAttachmentPropagationsRequest,
  GetTransitGatewayAttachmentPropagationsResult,
  GetTransitGatewayAttachmentPropagationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetTransitGatewayAttachmentPropagationsRequest,
  ) => stream.Stream<
    GetTransitGatewayAttachmentPropagationsResult,
    GetTransitGatewayAttachmentPropagationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetTransitGatewayAttachmentPropagationsRequest,
  ) => stream.Stream<
    TransitGatewayAttachmentPropagation,
    GetTransitGatewayAttachmentPropagationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetTransitGatewayAttachmentPropagationsRequest,
  output: GetTransitGatewayAttachmentPropagationsResult,
  errors: [RequestLimitExceeded, InvalidTransitGatewayAttachmentIDNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TransitGatewayAttachmentPropagations",
    pageSize: "MaxResults",
  } as const,
}));
export type GetTransitGatewayMeteringPolicyEntriesError =
  | RequestLimitExceeded
  | InvalidTransitGatewayMeteringPolicyIdNotFound
  | InvalidTransitGatewayMeteringPolicyIdMalformedException
  | CommonErrors;
/**
 * Retrieves the entries for a transit gateway metering policy.
 */
export const getTransitGatewayMeteringPolicyEntries: API.OperationMethod<
  GetTransitGatewayMeteringPolicyEntriesRequest,
  GetTransitGatewayMeteringPolicyEntriesResult,
  GetTransitGatewayMeteringPolicyEntriesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetTransitGatewayMeteringPolicyEntriesRequest,
  output: GetTransitGatewayMeteringPolicyEntriesResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayMeteringPolicyIdNotFound,
    InvalidTransitGatewayMeteringPolicyIdMalformedException,
  ],
}));
export type GetTransitGatewayMulticastDomainAssociationsError =
  | RequestLimitExceeded
  | InvalidTransitGatewayMulticastDomainIdMalformed
  | InvalidTransitGatewayMulticastDomainIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Gets information about the associations for the transit gateway multicast domain.
 */
export const getTransitGatewayMulticastDomainAssociations: API.OperationMethod<
  GetTransitGatewayMulticastDomainAssociationsRequest,
  GetTransitGatewayMulticastDomainAssociationsResult,
  GetTransitGatewayMulticastDomainAssociationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetTransitGatewayMulticastDomainAssociationsRequest,
  ) => stream.Stream<
    GetTransitGatewayMulticastDomainAssociationsResult,
    GetTransitGatewayMulticastDomainAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetTransitGatewayMulticastDomainAssociationsRequest,
  ) => stream.Stream<
    TransitGatewayMulticastDomainAssociation,
    GetTransitGatewayMulticastDomainAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetTransitGatewayMulticastDomainAssociationsRequest,
  output: GetTransitGatewayMulticastDomainAssociationsResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayMulticastDomainIdMalformed,
    InvalidTransitGatewayMulticastDomainIdNotFound,
    MissingParameter,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "MulticastDomainAssociations",
    pageSize: "MaxResults",
  } as const,
}));
export type GetTransitGatewayPolicyTableAssociationsError =
  | RequestLimitExceeded
  | InvalidTransitGatewayPolicyTableIdMalformed
  | InvalidTransitGatewayPolicyTableIdNotFound
  | CommonErrors;
/**
 * Gets a list of the transit gateway policy table associations.
 */
export const getTransitGatewayPolicyTableAssociations: API.OperationMethod<
  GetTransitGatewayPolicyTableAssociationsRequest,
  GetTransitGatewayPolicyTableAssociationsResult,
  GetTransitGatewayPolicyTableAssociationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetTransitGatewayPolicyTableAssociationsRequest,
  ) => stream.Stream<
    GetTransitGatewayPolicyTableAssociationsResult,
    GetTransitGatewayPolicyTableAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetTransitGatewayPolicyTableAssociationsRequest,
  ) => stream.Stream<
    TransitGatewayPolicyTableAssociation,
    GetTransitGatewayPolicyTableAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetTransitGatewayPolicyTableAssociationsRequest,
  output: GetTransitGatewayPolicyTableAssociationsResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayPolicyTableIdMalformed,
    InvalidTransitGatewayPolicyTableIdNotFound,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Associations",
    pageSize: "MaxResults",
  } as const,
}));
export type GetTransitGatewayPolicyTableEntriesError =
  | RequestLimitExceeded
  | InvalidTransitGatewayPolicyTableIdMalformed
  | InvalidTransitGatewayPolicyTableIdNotFound
  | CommonErrors;
/**
 * Returns a list of transit gateway policy table entries.
 */
export const getTransitGatewayPolicyTableEntries: API.OperationMethod<
  GetTransitGatewayPolicyTableEntriesRequest,
  GetTransitGatewayPolicyTableEntriesResult,
  GetTransitGatewayPolicyTableEntriesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetTransitGatewayPolicyTableEntriesRequest,
  output: GetTransitGatewayPolicyTableEntriesResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayPolicyTableIdMalformed,
    InvalidTransitGatewayPolicyTableIdNotFound,
  ],
}));
export type GetTransitGatewayPrefixListReferencesError =
  | RequestLimitExceeded
  | InvalidRouteTableIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Gets information about the prefix list references in a specified transit gateway route table.
 */
export const getTransitGatewayPrefixListReferences: API.OperationMethod<
  GetTransitGatewayPrefixListReferencesRequest,
  GetTransitGatewayPrefixListReferencesResult,
  GetTransitGatewayPrefixListReferencesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetTransitGatewayPrefixListReferencesRequest,
  ) => stream.Stream<
    GetTransitGatewayPrefixListReferencesResult,
    GetTransitGatewayPrefixListReferencesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetTransitGatewayPrefixListReferencesRequest,
  ) => stream.Stream<
    TransitGatewayPrefixListReference,
    GetTransitGatewayPrefixListReferencesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetTransitGatewayPrefixListReferencesRequest,
  output: GetTransitGatewayPrefixListReferencesResult,
  errors: [RequestLimitExceeded, InvalidRouteTableIDNotFound, MissingParameter],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TransitGatewayPrefixListReferences",
    pageSize: "MaxResults",
  } as const,
}));
export type GetTransitGatewayRouteTableAssociationsError =
  | RequestLimitExceeded
  | InvalidRouteTableIDNotFound
  | CommonErrors;
/**
 * Gets information about the associations for the specified transit gateway route table.
 */
export const getTransitGatewayRouteTableAssociations: API.OperationMethod<
  GetTransitGatewayRouteTableAssociationsRequest,
  GetTransitGatewayRouteTableAssociationsResult,
  GetTransitGatewayRouteTableAssociationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetTransitGatewayRouteTableAssociationsRequest,
  ) => stream.Stream<
    GetTransitGatewayRouteTableAssociationsResult,
    GetTransitGatewayRouteTableAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetTransitGatewayRouteTableAssociationsRequest,
  ) => stream.Stream<
    TransitGatewayRouteTableAssociation,
    GetTransitGatewayRouteTableAssociationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetTransitGatewayRouteTableAssociationsRequest,
  output: GetTransitGatewayRouteTableAssociationsResult,
  errors: [RequestLimitExceeded, InvalidRouteTableIDNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Associations",
    pageSize: "MaxResults",
  } as const,
}));
export type GetTransitGatewayRouteTablePropagationsError =
  | RequestLimitExceeded
  | InvalidRouteTableIDNotFound
  | CommonErrors;
/**
 * Gets information about the route table propagations for the specified transit gateway route table.
 */
export const getTransitGatewayRouteTablePropagations: API.OperationMethod<
  GetTransitGatewayRouteTablePropagationsRequest,
  GetTransitGatewayRouteTablePropagationsResult,
  GetTransitGatewayRouteTablePropagationsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetTransitGatewayRouteTablePropagationsRequest,
  ) => stream.Stream<
    GetTransitGatewayRouteTablePropagationsResult,
    GetTransitGatewayRouteTablePropagationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetTransitGatewayRouteTablePropagationsRequest,
  ) => stream.Stream<
    TransitGatewayRouteTablePropagation,
    GetTransitGatewayRouteTablePropagationsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetTransitGatewayRouteTablePropagationsRequest,
  output: GetTransitGatewayRouteTablePropagationsResult,
  errors: [RequestLimitExceeded, InvalidRouteTableIDNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TransitGatewayRouteTablePropagations",
    pageSize: "MaxResults",
  } as const,
}));
export type GetVerifiedAccessEndpointPolicyError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidVerifiedAccessEndpointIdNotFound
  | CommonErrors;
/**
 * Get the Verified Access policy associated with the endpoint.
 */
export const getVerifiedAccessEndpointPolicy: API.OperationMethod<
  GetVerifiedAccessEndpointPolicyRequest,
  GetVerifiedAccessEndpointPolicyResult,
  GetVerifiedAccessEndpointPolicyError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetVerifiedAccessEndpointPolicyRequest,
  output: GetVerifiedAccessEndpointPolicyResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidVerifiedAccessEndpointIdNotFound,
  ],
}));
export type GetVerifiedAccessEndpointTargetsError =
  | RequestLimitExceeded
  | InvalidVerifiedAccessEndpointIdNotFound
  | CommonErrors;
/**
 * Gets the targets for the specified network CIDR endpoint for Verified Access.
 */
export const getVerifiedAccessEndpointTargets: API.OperationMethod<
  GetVerifiedAccessEndpointTargetsRequest,
  GetVerifiedAccessEndpointTargetsResult,
  GetVerifiedAccessEndpointTargetsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetVerifiedAccessEndpointTargetsRequest,
  output: GetVerifiedAccessEndpointTargetsResult,
  errors: [RequestLimitExceeded, InvalidVerifiedAccessEndpointIdNotFound],
}));
export type GetVerifiedAccessGroupPolicyError =
  | RequestLimitExceeded
  | InvalidVerifiedAccessGroupIdNotFound
  | CommonErrors;
/**
 * Shows the contents of the Verified Access policy associated with the group.
 */
export const getVerifiedAccessGroupPolicy: API.OperationMethod<
  GetVerifiedAccessGroupPolicyRequest,
  GetVerifiedAccessGroupPolicyResult,
  GetVerifiedAccessGroupPolicyError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetVerifiedAccessGroupPolicyRequest,
  output: GetVerifiedAccessGroupPolicyResult,
  errors: [RequestLimitExceeded, InvalidVerifiedAccessGroupIdNotFound],
}));
export type GetVpcResourcesBlockingEncryptionEnforcementError =
  | RequestLimitExceeded
  | InvalidVpcIdMalformed
  | CommonErrors;
/**
 * Gets information about resources in a VPC that are blocking encryption enforcement.
 *
 * For more information, see Enforce VPC encryption in transit in the *Amazon VPC User Guide*.
 */
export const getVpcResourcesBlockingEncryptionEnforcement: API.OperationMethod<
  GetVpcResourcesBlockingEncryptionEnforcementRequest,
  GetVpcResourcesBlockingEncryptionEnforcementResult,
  GetVpcResourcesBlockingEncryptionEnforcementError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetVpcResourcesBlockingEncryptionEnforcementRequest,
  output: GetVpcResourcesBlockingEncryptionEnforcementResult,
  errors: [RequestLimitExceeded, InvalidVpcIdMalformed],
}));
export type GetVpnConnectionDeviceSampleConfigurationError =
  | RequestLimitExceeded
  | InvalidVpnConnectionDeviceTypeIdNotFound
  | CommonErrors;
/**
 * Download an Amazon Web Services-provided sample configuration file to be used with the customer
 * gateway device specified for your Site-to-Site VPN connection.
 */
export const getVpnConnectionDeviceSampleConfiguration: API.OperationMethod<
  GetVpnConnectionDeviceSampleConfigurationRequest,
  GetVpnConnectionDeviceSampleConfigurationResult,
  GetVpnConnectionDeviceSampleConfigurationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetVpnConnectionDeviceSampleConfigurationRequest,
  output: GetVpnConnectionDeviceSampleConfigurationResult,
  errors: [RequestLimitExceeded, InvalidVpnConnectionDeviceTypeIdNotFound],
}));
export type GetVpnConnectionDeviceTypesError = CommonErrors;
/**
 * Obtain a list of customer gateway devices for which sample configuration
 * files can be provided. The request has no additional parameters. You can also see the
 * list of device types with sample configuration files available under Your customer gateway
 * device in the *Amazon Web Services Site-to-Site VPN User Guide*.
 */
export const getVpnConnectionDeviceTypes: API.OperationMethod<
  GetVpnConnectionDeviceTypesRequest,
  GetVpnConnectionDeviceTypesResult,
  GetVpnConnectionDeviceTypesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: GetVpnConnectionDeviceTypesRequest,
  ) => stream.Stream<
    GetVpnConnectionDeviceTypesResult,
    GetVpnConnectionDeviceTypesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: GetVpnConnectionDeviceTypesRequest,
  ) => stream.Stream<
    VpnConnectionDeviceType,
    GetVpnConnectionDeviceTypesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetVpnConnectionDeviceTypesRequest,
  output: GetVpnConnectionDeviceTypesResult,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "VpnConnectionDeviceTypes",
    pageSize: "MaxResults",
  } as const,
}));
export type GetVpnTunnelReplacementStatusError =
  | RequestLimitExceeded
  | InvalidVpnConnectionId
  | CommonErrors;
/**
 * Get details of available tunnel endpoint maintenance.
 */
export const getVpnTunnelReplacementStatus: API.OperationMethod<
  GetVpnTunnelReplacementStatusRequest,
  GetVpnTunnelReplacementStatusResult,
  GetVpnTunnelReplacementStatusError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetVpnTunnelReplacementStatusRequest,
  output: GetVpnTunnelReplacementStatusResult,
  errors: [RequestLimitExceeded, InvalidVpnConnectionId],
}));
export type ImportClientVpnClientCertificateRevocationListError =
  | RequestLimitExceeded
  | InvalidClientVpnEndpointIdNotFound
  | CommonErrors;
/**
 * Uploads a client certificate revocation list to the specified Client VPN endpoint. Uploading a client certificate revocation list overwrites the existing client certificate revocation list.
 *
 * Uploading a client certificate revocation list resets existing client connections.
 */
export const importClientVpnClientCertificateRevocationList: API.OperationMethod<
  ImportClientVpnClientCertificateRevocationListRequest,
  ImportClientVpnClientCertificateRevocationListResult,
  ImportClientVpnClientCertificateRevocationListError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ImportClientVpnClientCertificateRevocationListRequest,
  output: ImportClientVpnClientCertificateRevocationListResult,
  errors: [RequestLimitExceeded, InvalidClientVpnEndpointIdNotFound],
}));
export type ImportImageError =
  | RequestLimitExceeded
  | MissingRequiredParameter
  | CommonErrors;
/**
 * To import your virtual machines (VMs) with a console-based experience, you can use the
 * *Import virtual machine images to Amazon Web Services* template in the Migration Hub Orchestrator console. For more
 * information, see the
 * *Migration Hub Orchestrator User Guide*
 * .
 *
 * Import single or multi-volume disk images or EBS snapshots into an Amazon Machine Image (AMI).
 *
 * Amazon Web Services VM Import/Export strongly recommends specifying a value for either the
 * `--license-type` or `--usage-operation` parameter when you create a new
 * VM Import task. This ensures your operating system is licensed appropriately and your billing is
 * optimized.
 *
 * For more information, see Importing a
 * VM as an image using VM Import/Export in the *VM Import/Export User Guide*.
 */
export const importImage: API.OperationMethod<
  ImportImageRequest,
  ImportImageResult,
  ImportImageError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ImportImageRequest,
  output: ImportImageResult,
  errors: [RequestLimitExceeded, MissingRequiredParameter],
}));
export type ImportInstanceError =
  | RequestLimitExceeded
  | InvalidParameter
  | CommonErrors;
/**
 * We recommend that you use the
 * `ImportImage`
 *
 * API instead. For more information, see Importing a VM as an image using VM
 * Import/Export in the *VM Import/Export User Guide*.
 *
 * Creates an import instance task using metadata from the specified disk image.
 *
 * This API action supports only single-volume VMs. To import multi-volume VMs, use ImportImage
 * instead.
 *
 * For information about the import manifest referenced by this API action, see VM Import Manifest.
 *
 * This API action is not supported by the Command Line Interface (CLI).
 */
export const importInstance: API.OperationMethod<
  ImportInstanceRequest,
  ImportInstanceResult,
  ImportInstanceError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ImportInstanceRequest,
  output: ImportInstanceResult,
  errors: [RequestLimitExceeded, InvalidParameter],
}));
export type ImportKeyPairError =
  | RequestLimitExceeded
  | InvalidKeyPairDuplicate
  | CommonErrors;
/**
 * Imports the public key from an RSA or ED25519 key pair that you created using a third-party tool.
 * You give Amazon Web Services only the public key. The private key is never transferred between you and Amazon Web Services.
 *
 * For more information about the requirements for importing a key pair, see Create a key pair and import the public key to Amazon EC2 in the *Amazon EC2 User Guide*.
 */
export const importKeyPair: API.OperationMethod<
  ImportKeyPairRequest,
  ImportKeyPairResult,
  ImportKeyPairError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ImportKeyPairRequest,
  output: ImportKeyPairResult,
  errors: [RequestLimitExceeded, InvalidKeyPairDuplicate],
}));
export type ImportSnapshotError =
  | RequestLimitExceeded
  | InvalidParameter
  | CommonErrors;
/**
 * Imports a disk into an EBS snapshot.
 *
 * For more information, see Importing a disk as a snapshot using VM Import/Export in the
 * *VM Import/Export User Guide*.
 */
export const importSnapshot: API.OperationMethod<
  ImportSnapshotRequest,
  ImportSnapshotResult,
  ImportSnapshotError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ImportSnapshotRequest,
  output: ImportSnapshotResult,
  errors: [RequestLimitExceeded, InvalidParameter],
}));
export type ImportVolumeError = CommonErrors;
/**
 * This API action supports only single-volume VMs. To import multi-volume VMs, use
 * ImportImage instead. To import a disk to a snapshot, use
 * ImportSnapshot instead.
 *
 * Creates an import volume task using metadata from the specified disk image.
 *
 * For information about the import manifest referenced by this API action, see VM Import Manifest.
 *
 * This API action is not supported by the Command Line Interface (CLI).
 */
export const importVolume: API.OperationMethod<
  ImportVolumeRequest,
  ImportVolumeResult,
  ImportVolumeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ImportVolumeRequest,
  output: ImportVolumeResult,
  errors: [],
}));
export type ListImagesInRecycleBinError =
  | RequestLimitExceeded
  | InvalidAMIIDNotFound
  | CommonErrors;
/**
 * Lists one or more AMIs that are currently in the Recycle Bin. For more information, see
 * Recycle
 * Bin in the *Amazon EC2 User Guide*.
 */
export const listImagesInRecycleBin: API.OperationMethod<
  ListImagesInRecycleBinRequest,
  ListImagesInRecycleBinResult,
  ListImagesInRecycleBinError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: ListImagesInRecycleBinRequest,
  ) => stream.Stream<
    ListImagesInRecycleBinResult,
    ListImagesInRecycleBinError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: ListImagesInRecycleBinRequest,
  ) => stream.Stream<
    ImageRecycleBinInfo,
    ListImagesInRecycleBinError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListImagesInRecycleBinRequest,
  output: ListImagesInRecycleBinResult,
  errors: [RequestLimitExceeded, InvalidAMIIDNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Images",
    pageSize: "MaxResults",
  } as const,
}));
export type ListSnapshotsInRecycleBinError =
  | RequestLimitExceeded
  | InvalidSnapshotIDMalformed
  | CommonErrors;
/**
 * Lists one or more snapshots that are currently in the Recycle Bin.
 */
export const listSnapshotsInRecycleBin: API.OperationMethod<
  ListSnapshotsInRecycleBinRequest,
  ListSnapshotsInRecycleBinResult,
  ListSnapshotsInRecycleBinError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: ListSnapshotsInRecycleBinRequest,
  ) => stream.Stream<
    ListSnapshotsInRecycleBinResult,
    ListSnapshotsInRecycleBinError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: ListSnapshotsInRecycleBinRequest,
  ) => stream.Stream<
    SnapshotRecycleBinInfo,
    ListSnapshotsInRecycleBinError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListSnapshotsInRecycleBinRequest,
  output: ListSnapshotsInRecycleBinResult,
  errors: [RequestLimitExceeded, InvalidSnapshotIDMalformed],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Snapshots",
    pageSize: "MaxResults",
  } as const,
}));
export type ListVolumesInRecycleBinError =
  | RequestLimitExceeded
  | InvalidVolumeIDMalformed
  | CommonErrors;
/**
 * Lists one or more volumes that are currently in the Recycle Bin.
 */
export const listVolumesInRecycleBin: API.OperationMethod<
  ListVolumesInRecycleBinRequest,
  ListVolumesInRecycleBinResult,
  ListVolumesInRecycleBinError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListVolumesInRecycleBinRequest,
  output: ListVolumesInRecycleBinResult,
  errors: [RequestLimitExceeded, InvalidVolumeIDMalformed],
}));
export type LockSnapshotError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Locks an Amazon EBS snapshot in either *governance* or *compliance*
 * mode to protect it against accidental or malicious deletions for a specific duration. A locked snapshot
 * can't be deleted.
 *
 * You can also use this action to modify the lock settings for a snapshot that is already locked. The
 * allowed modifications depend on the lock mode and lock state:
 *
 * - If the snapshot is locked in governance mode, you can modify the lock mode and the lock duration
 * or lock expiration date.
 *
 * - If the snapshot is locked in compliance mode and it is in the cooling-off period, you can modify
 * the lock mode and the lock duration or lock expiration date.
 *
 * - If the snapshot is locked in compliance mode and the cooling-off period has lapsed, you can
 * only increase the lock duration or extend the lock expiration date.
 */
export const lockSnapshot: API.OperationMethod<
  LockSnapshotRequest,
  LockSnapshotResult,
  LockSnapshotError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: LockSnapshotRequest,
  output: LockSnapshotResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type ModifyAddressAttributeError =
  | RequestLimitExceeded
  | InvalidAllocationIDNotFound
  | InvalidElasticIpIDNotFound
  | CommonErrors;
/**
 * Modifies an attribute of the specified Elastic IP address. For requirements, see Using reverse DNS for email applications.
 */
export const modifyAddressAttribute: API.OperationMethod<
  ModifyAddressAttributeRequest,
  ModifyAddressAttributeResult,
  ModifyAddressAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyAddressAttributeRequest,
  output: ModifyAddressAttributeResult,
  errors: [
    RequestLimitExceeded,
    InvalidAllocationIDNotFound,
    InvalidElasticIpIDNotFound,
  ],
}));
export type ModifyAvailabilityZoneGroupError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Changes the opt-in status of the specified zone group for your account.
 */
export const modifyAvailabilityZoneGroup: API.OperationMethod<
  ModifyAvailabilityZoneGroupRequest,
  ModifyAvailabilityZoneGroupResult,
  ModifyAvailabilityZoneGroupError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyAvailabilityZoneGroupRequest,
  output: ModifyAvailabilityZoneGroupResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type ModifyCapacityReservationError =
  | RequestLimitExceeded
  | InvalidCapacityReservationIdMalformed
  | CommonErrors;
/**
 * Modifies a Capacity Reservation's capacity, instance eligibility, and the conditions
 * under which it is to be released. You can't modify a Capacity Reservation's instance
 * type, EBS optimization, platform, instance store settings, Availability Zone, or
 * tenancy. If you need to modify any of these attributes, we recommend that you cancel the
 * Capacity Reservation, and then create a new one with the required attributes. For more
 * information, see Modify an active
 * Capacity Reservation.
 *
 * The allowed modifications depend on the state of the Capacity Reservation:
 *
 * - `assessing` or `scheduled` state - You can modify the
 * tags only.
 *
 * - `pending` state - You can't modify the Capacity Reservation in any
 * way.
 *
 * - `active` state but still within the commitment duration - You can't
 * decrease the instance count or set an end date that is within the commitment
 * duration. All other modifications are allowed.
 *
 * - `active` state with no commitment duration or elapsed commitment
 * duration - All modifications are allowed.
 *
 * - `expired`, `cancelled`, `unsupported`, or
 * `failed` state - You can't modify the Capacity Reservation in any
 * way.
 */
export const modifyCapacityReservation: API.OperationMethod<
  ModifyCapacityReservationRequest,
  ModifyCapacityReservationResult,
  ModifyCapacityReservationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyCapacityReservationRequest,
  output: ModifyCapacityReservationResult,
  errors: [RequestLimitExceeded, InvalidCapacityReservationIdMalformed],
}));
export type ModifyCapacityReservationFleetError =
  | RequestLimitExceeded
  | InvalidCapacityReservationFleetIdMalformed
  | CommonErrors;
/**
 * Modifies a Capacity Reservation Fleet.
 *
 * When you modify the total target capacity of a Capacity Reservation Fleet, the Fleet
 * automatically creates new Capacity Reservations, or modifies or cancels existing
 * Capacity Reservations in the Fleet to meet the new total target capacity. When you
 * modify the end date for the Fleet, the end dates for all of the individual Capacity
 * Reservations in the Fleet are updated accordingly.
 */
export const modifyCapacityReservationFleet: API.OperationMethod<
  ModifyCapacityReservationFleetRequest,
  ModifyCapacityReservationFleetResult,
  ModifyCapacityReservationFleetError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyCapacityReservationFleetRequest,
  output: ModifyCapacityReservationFleetResult,
  errors: [RequestLimitExceeded, InvalidCapacityReservationFleetIdMalformed],
}));
export type ModifyClientVpnEndpointError =
  | RequestLimitExceeded
  | InvalidClientVpnEndpointIdNotFound
  | CommonErrors;
/**
 * Modifies the specified Client VPN endpoint. Modifying the DNS server resets existing client connections.
 */
export const modifyClientVpnEndpoint: API.OperationMethod<
  ModifyClientVpnEndpointRequest,
  ModifyClientVpnEndpointResult,
  ModifyClientVpnEndpointError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyClientVpnEndpointRequest,
  output: ModifyClientVpnEndpointResult,
  errors: [RequestLimitExceeded, InvalidClientVpnEndpointIdNotFound],
}));
export type ModifyDefaultCreditSpecificationError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Modifies the default credit option for CPU usage of burstable performance instances.
 * The default credit option is set at the account level per Amazon Web Services Region, and
 * is specified per instance family. All new burstable performance instances in the account
 * launch using the default credit option.
 *
 * `ModifyDefaultCreditSpecification` is an asynchronous operation, which
 * works at an Amazon Web Services Region level and modifies the credit option for each
 * Availability Zone. All zones in a Region are updated within five minutes. But if
 * instances are launched during this operation, they might not get the new credit option
 * until the zone is updated. To verify whether the update has occurred, you can call
 * `GetDefaultCreditSpecification` and check
 * `DefaultCreditSpecification` for updates.
 *
 * For more information, see Burstable
 * performance instances in the *Amazon EC2 User Guide*.
 */
export const modifyDefaultCreditSpecification: API.OperationMethod<
  ModifyDefaultCreditSpecificationRequest,
  ModifyDefaultCreditSpecificationResult,
  ModifyDefaultCreditSpecificationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyDefaultCreditSpecificationRequest,
  output: ModifyDefaultCreditSpecificationResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type ModifyEbsDefaultKmsKeyIdError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Changes the default KMS key for EBS encryption by default for your account in this Region.
 *
 * Amazon Web Services creates a unique Amazon Web Services managed KMS key in each Region for use with encryption by default. If
 * you change the default KMS key to a symmetric customer managed KMS key, it is used instead of the Amazon Web Services
 * managed KMS key. Amazon EBS does not support asymmetric KMS keys.
 *
 * If you delete or disable the customer managed KMS key that you specified for use with
 * encryption by default, your instances will fail to launch.
 *
 * For more information, see Amazon EBS encryption
 * in the *Amazon EBS User Guide*.
 */
export const modifyEbsDefaultKmsKeyId: API.OperationMethod<
  ModifyEbsDefaultKmsKeyIdRequest,
  ModifyEbsDefaultKmsKeyIdResult,
  ModifyEbsDefaultKmsKeyIdError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyEbsDefaultKmsKeyIdRequest,
  output: ModifyEbsDefaultKmsKeyIdResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type ModifyFleetError =
  | RequestLimitExceeded
  | InvalidFleetIdMalformed
  | CommonErrors;
/**
 * Modifies the specified EC2 Fleet.
 *
 * You can only modify an EC2 Fleet request of type `maintain`.
 *
 * While the EC2 Fleet is being modified, it is in the `modifying` state.
 *
 * To scale up your EC2 Fleet, increase its target capacity. The EC2 Fleet launches the additional
 * Spot Instances according to the allocation strategy for the EC2 Fleet request. If the allocation
 * strategy is `lowest-price`, the EC2 Fleet launches instances using the Spot Instance
 * pool with the lowest price. If the allocation strategy is `diversified`, the
 * EC2 Fleet distributes the instances across the Spot Instance pools. If the allocation strategy
 * is `capacity-optimized`, EC2 Fleet launches instances from Spot Instance pools with optimal
 * capacity for the number of instances that are launching.
 *
 * To scale down your EC2 Fleet, decrease its target capacity. First, the EC2 Fleet cancels any open
 * requests that exceed the new target capacity. You can request that the EC2 Fleet terminate Spot
 * Instances until the size of the fleet no longer exceeds the new target capacity. If the
 * allocation strategy is `lowest-price`, the EC2 Fleet terminates the instances with
 * the highest price per unit. If the allocation strategy is `capacity-optimized`,
 * the EC2 Fleet terminates the instances in the Spot Instance pools that have the least available
 * Spot Instance capacity. If the allocation strategy is `diversified`, the EC2 Fleet terminates
 * instances across the Spot Instance pools. Alternatively, you can request that the EC2 Fleet keep
 * the fleet at its current size, but not replace any Spot Instances that are interrupted or
 * that you terminate manually.
 *
 * If you are finished with your EC2 Fleet for now, but will use it again later, you can set the
 * target capacity to 0.
 */
export const modifyFleet: API.OperationMethod<
  ModifyFleetRequest,
  ModifyFleetResult,
  ModifyFleetError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyFleetRequest,
  output: ModifyFleetResult,
  errors: [RequestLimitExceeded, InvalidFleetIdMalformed],
}));
export type ModifyFpgaImageAttributeError =
  | RequestLimitExceeded
  | InvalidFpgaImageIDMalformed
  | InvalidFpgaImageIDNotFound
  | CommonErrors;
/**
 * Modifies the specified attribute of the specified Amazon FPGA Image (AFI).
 */
export const modifyFpgaImageAttribute: API.OperationMethod<
  ModifyFpgaImageAttributeRequest,
  ModifyFpgaImageAttributeResult,
  ModifyFpgaImageAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyFpgaImageAttributeRequest,
  output: ModifyFpgaImageAttributeResult,
  errors: [
    RequestLimitExceeded,
    InvalidFpgaImageIDMalformed,
    InvalidFpgaImageIDNotFound,
  ],
}));
export type ModifyHostsError = CommonErrors;
/**
 * Modify the auto-placement setting of a Dedicated Host. When auto-placement is enabled,
 * any instances that you launch with a tenancy of `host` but without a specific
 * host ID are placed onto any available Dedicated Host in your account that has
 * auto-placement enabled. When auto-placement is disabled, you need to provide a host ID
 * to have the instance launch onto a specific host. If no host ID is provided, the
 * instance is launched onto a suitable host with auto-placement enabled.
 *
 * You can also use this API action to modify a Dedicated Host to support either multiple
 * instance types in an instance family, or to support a specific instance type
 * only.
 */
export const modifyHosts: API.OperationMethod<
  ModifyHostsRequest,
  ModifyHostsResult,
  ModifyHostsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyHostsRequest,
  output: ModifyHostsResult,
  errors: [],
}));
export type ModifyIdentityIdFormatError = CommonErrors;
/**
 * Modifies the ID format of a resource for a specified IAM user, IAM role, or the root
 * user for an account; or all IAM users, IAM roles, and the root user for an account. You can
 * specify that resources should receive longer IDs (17-character IDs) when they are created.
 *
 * This request can only be used to modify longer ID settings for resource types that are
 * within the opt-in period. Resources currently in their opt-in period include:
 * `bundle` | `conversion-task` | `customer-gateway` | `dhcp-options` |
 * `elastic-ip-allocation` | `elastic-ip-association` |
 * `export-task` | `flow-log` | `image` |
 * `import-task` | `internet-gateway` | `network-acl`
 * | `network-acl-association` | `network-interface` |
 * `network-interface-attachment` | `prefix-list` |
 * `route-table` | `route-table-association` |
 * `security-group` | `subnet` |
 * `subnet-cidr-block-association` | `vpc` |
 * `vpc-cidr-block-association` | `vpc-endpoint` | `vpc-peering-connection` | `vpn-connection` | `vpn-gateway`.
 *
 * For more information, see Resource IDs in the
 * *Amazon Elastic Compute Cloud User Guide*.
 *
 * This setting applies to the principal specified in the request; it does not apply to the
 * principal that makes the request.
 *
 * Resources created with longer IDs are visible to all IAM roles and users, regardless of these
 * settings and provided that they have permission to use the relevant `Describe`
 * command for the resource type.
 */
export const modifyIdentityIdFormat: API.OperationMethod<
  ModifyIdentityIdFormatRequest,
  ModifyIdentityIdFormatResponse,
  ModifyIdentityIdFormatError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyIdentityIdFormatRequest,
  output: ModifyIdentityIdFormatResponse,
  errors: [],
}));
export type ModifyIdFormatError = CommonErrors;
/**
 * Modifies the ID format for the specified resource on a per-Region basis. You can
 * specify that resources should receive longer IDs (17-character IDs) when they are
 * created.
 *
 * This request can only be used to modify longer ID settings for resource types that
 * are within the opt-in period. Resources currently in their opt-in period include:
 * `bundle` | `conversion-task` | `customer-gateway` | `dhcp-options` |
 * `elastic-ip-allocation` | `elastic-ip-association` |
 * `export-task` | `flow-log` | `image` |
 * `import-task` | `internet-gateway` | `network-acl`
 * | `network-acl-association` | `network-interface` |
 * `network-interface-attachment` | `prefix-list` |
 * `route-table` | `route-table-association` |
 * `security-group` | `subnet` |
 * `subnet-cidr-block-association` | `vpc` |
 * `vpc-cidr-block-association` | `vpc-endpoint` | `vpc-peering-connection` | `vpn-connection` | `vpn-gateway`.
 *
 * This setting applies to the IAM user who makes the request; it does not apply to the
 * entire Amazon Web Services account. By default, an IAM user defaults to the same settings as the root user. If
 * you're using this action as the root user, then these settings apply to the entire account,
 * unless an IAM user explicitly overrides these settings for themselves. For more information,
 * see Resource IDs
 * in the *Amazon Elastic Compute Cloud User Guide*.
 *
 * Resources created with longer IDs are visible to all IAM roles and users, regardless
 * of these settings and provided that they have permission to use the relevant
 * `Describe` command for the resource type.
 */
export const modifyIdFormat: API.OperationMethod<
  ModifyIdFormatRequest,
  ModifyIdFormatResponse,
  ModifyIdFormatError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyIdFormatRequest,
  output: ModifyIdFormatResponse,
  errors: [],
}));
export type ModifyImageAttributeError =
  | RequestLimitExceeded
  | InvalidAMIIDMalformed
  | InvalidAMIIDNotFound
  | InvalidParameterCombination
  | CommonErrors;
/**
 * Modifies the specified attribute of the specified AMI. You can specify only one attribute
 * at a time.
 *
 * To specify the attribute, you can use the `Attribute` parameter, or one of the
 * following parameters: `Description`, `ImdsSupport`, or
 * `LaunchPermission`.
 *
 * Images with an Amazon Web Services Marketplace product code cannot be made public.
 *
 * To enable the SriovNetSupport enhanced networking attribute of an image, enable
 * SriovNetSupport on an instance and create an AMI from the instance.
 */
export const modifyImageAttribute: API.OperationMethod<
  ModifyImageAttributeRequest,
  ModifyImageAttributeResponse,
  ModifyImageAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyImageAttributeRequest,
  output: ModifyImageAttributeResponse,
  errors: [
    RequestLimitExceeded,
    InvalidAMIIDMalformed,
    InvalidAMIIDNotFound,
    InvalidParameterCombination,
  ],
}));
export type ModifyInstanceAttributeError =
  | RequestLimitExceeded
  | InvalidInstanceIDNotFound
  | InvalidParameterValue
  | CommonErrors;
/**
 * Modifies the specified attribute of the specified instance. You can specify only one
 * attribute at a time.
 *
 * **Note: **Using this action to change the security groups
 * associated with an elastic network interface (ENI) attached to an instance can
 * result in an error if the instance has more than one ENI. To change the security groups
 * associated with an ENI attached to an instance that has multiple ENIs, we recommend that
 * you use the ModifyNetworkInterfaceAttribute action.
 *
 * To modify some attributes, the instance must be stopped. For more information, see
 * Modify a stopped instance in the
 * *Amazon EC2 User Guide*.
 */
export const modifyInstanceAttribute: API.OperationMethod<
  ModifyInstanceAttributeRequest,
  ModifyInstanceAttributeResponse,
  ModifyInstanceAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyInstanceAttributeRequest,
  output: ModifyInstanceAttributeResponse,
  errors: [
    RequestLimitExceeded,
    InvalidInstanceIDNotFound,
    InvalidParameterValue,
  ],
}));
export type ModifyInstanceCapacityReservationAttributesError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Modifies the Capacity Reservation settings for a stopped instance. Use this action to
 * configure an instance to target a specific Capacity Reservation, run in any
 * `open` Capacity Reservation with matching attributes, run in On-Demand
 * Instance capacity, or only run in a Capacity Reservation.
 */
export const modifyInstanceCapacityReservationAttributes: API.OperationMethod<
  ModifyInstanceCapacityReservationAttributesRequest,
  ModifyInstanceCapacityReservationAttributesResult,
  ModifyInstanceCapacityReservationAttributesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyInstanceCapacityReservationAttributesRequest,
  output: ModifyInstanceCapacityReservationAttributesResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type ModifyInstanceConnectEndpointError =
  | RequestLimitExceeded
  | InvalidInstanceConnectEndpointIdMalformed
  | InvalidInstanceConnectEndpointIdNotFound
  | CommonErrors;
/**
 * Modifies the specified EC2 Instance Connect Endpoint.
 *
 * For more information, see Modify an
 * EC2 Instance Connect Endpoint in the
 * *Amazon EC2 User Guide*.
 */
export const modifyInstanceConnectEndpoint: API.OperationMethod<
  ModifyInstanceConnectEndpointRequest,
  ModifyInstanceConnectEndpointResult,
  ModifyInstanceConnectEndpointError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyInstanceConnectEndpointRequest,
  output: ModifyInstanceConnectEndpointResult,
  errors: [
    RequestLimitExceeded,
    InvalidInstanceConnectEndpointIdMalformed,
    InvalidInstanceConnectEndpointIdNotFound,
  ],
}));
export type ModifyInstanceCpuOptionsError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | CommonErrors;
/**
 * By default, all vCPUs for the instance type are active when you launch an instance. When you
 * configure the number of active vCPUs for the instance, it can help you save on licensing costs and
 * optimize performance. The base cost of the instance remains unchanged.
 *
 * The number of active vCPUs equals the number of threads per CPU core multiplied by the number
 * of cores. The instance must be in a `Stopped` state before you make changes.
 *
 * Some instance type options do not support this capability. For more information, see
 * Supported CPU
 * options in the *Amazon EC2 User Guide*.
 */
export const modifyInstanceCpuOptions: API.OperationMethod<
  ModifyInstanceCpuOptionsRequest,
  ModifyInstanceCpuOptionsResult,
  ModifyInstanceCpuOptionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyInstanceCpuOptionsRequest,
  output: ModifyInstanceCpuOptionsResult,
  errors: [RequestLimitExceeded, InvalidInstanceIDMalformed],
}));
export type ModifyInstanceCreditSpecificationError = CommonErrors;
/**
 * Modifies the credit option for CPU usage on a running or stopped burstable performance
 * instance. The credit options are `standard` and
 * `unlimited`.
 *
 * For more information, see Burstable
 * performance instances in the *Amazon EC2 User Guide*.
 */
export const modifyInstanceCreditSpecification: API.OperationMethod<
  ModifyInstanceCreditSpecificationRequest,
  ModifyInstanceCreditSpecificationResult,
  ModifyInstanceCreditSpecificationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyInstanceCreditSpecificationRequest,
  output: ModifyInstanceCreditSpecificationResult,
  errors: [],
}));
export type ModifyInstanceEventStartTimeError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Modifies the start time for a scheduled Amazon EC2 instance event.
 */
export const modifyInstanceEventStartTime: API.OperationMethod<
  ModifyInstanceEventStartTimeRequest,
  ModifyInstanceEventStartTimeResult,
  ModifyInstanceEventStartTimeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyInstanceEventStartTimeRequest,
  output: ModifyInstanceEventStartTimeResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type ModifyInstanceEventWindowError =
  | RequestLimitExceeded
  | InvalidInstanceEventWindowIDNotFound
  | InvalidInstanceEventWindowIdMalformed
  | CommonErrors;
/**
 * Modifies the specified event window.
 *
 * You can define either a set of time ranges or a cron expression when modifying the event
 * window, but not both.
 *
 * To modify the targets associated with the event window, use the AssociateInstanceEventWindow and DisassociateInstanceEventWindow API.
 *
 * If Amazon Web Services has already scheduled an event, modifying an event window won't change the time
 * of the scheduled event.
 *
 * For more information, see Define event windows for scheduled
 * events in the *Amazon EC2 User Guide*.
 */
export const modifyInstanceEventWindow: API.OperationMethod<
  ModifyInstanceEventWindowRequest,
  ModifyInstanceEventWindowResult,
  ModifyInstanceEventWindowError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyInstanceEventWindowRequest,
  output: ModifyInstanceEventWindowResult,
  errors: [
    RequestLimitExceeded,
    InvalidInstanceEventWindowIDNotFound,
    InvalidInstanceEventWindowIdMalformed,
  ],
}));
export type ModifyInstanceMaintenanceOptionsError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | CommonErrors;
/**
 * Modifies the recovery behavior of your instance to disable simplified automatic
 * recovery or set the recovery behavior to default. The default configuration will not
 * enable simplified automatic recovery for an unsupported instance type. For more
 * information, see Simplified automatic recovery.
 *
 * Modifies the reboot migration behavior during a user-initiated reboot of an instance
 * that has a pending `system-reboot` event. For more information, see Enable or disable reboot migration.
 */
export const modifyInstanceMaintenanceOptions: API.OperationMethod<
  ModifyInstanceMaintenanceOptionsRequest,
  ModifyInstanceMaintenanceOptionsResult,
  ModifyInstanceMaintenanceOptionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyInstanceMaintenanceOptionsRequest,
  output: ModifyInstanceMaintenanceOptionsResult,
  errors: [RequestLimitExceeded, InvalidInstanceIDMalformed],
}));
export type ModifyInstanceMetadataDefaultsError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Modifies the default instance metadata service (IMDS) settings at the account level in
 * the specified Amazon Web Services
 Region.
 * 
 * To remove a parameter's account-level default setting, specify
 * `no-preference`. If an account-level setting is cleared with
 * `no-preference`, then the instance launch considers the other
 * instance metadata settings. For more information, see Order of precedence for instance metadata options in the
 * *Amazon EC2 User Guide*.
 */
export const modifyInstanceMetadataDefaults: API.OperationMethod<
  ModifyInstanceMetadataDefaultsRequest,
  ModifyInstanceMetadataDefaultsResult,
  ModifyInstanceMetadataDefaultsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyInstanceMetadataDefaultsRequest,
  output: ModifyInstanceMetadataDefaultsResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type ModifyInstanceMetadataOptionsError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | CommonErrors;
/**
 * Modify the instance metadata parameters on a running or stopped instance. When you
 * modify the parameters on a stopped instance, they are applied when the instance is
 * started. When you modify the parameters on a running instance, the API responds with a
 * state of pending. After the parameter modifications are successfully applied to the
 * instance, the state of the modifications changes from pending to applied in
 * subsequent describe-instances API calls. For more information, see Instance metadata and user data in the
 * *Amazon EC2 User Guide*.
 */
export const modifyInstanceMetadataOptions: API.OperationMethod<
  ModifyInstanceMetadataOptionsRequest,
  ModifyInstanceMetadataOptionsResult,
  ModifyInstanceMetadataOptionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyInstanceMetadataOptionsRequest,
  output: ModifyInstanceMetadataOptionsResult,
  errors: [RequestLimitExceeded, InvalidInstanceIDMalformed],
}));
export type ModifyInstanceNetworkPerformanceOptionsError =
  | RequestLimitExceeded
  | InvalidAction
  | CommonErrors;
/**
 * Change the configuration of the network performance options for an existing
 * instance.
 */
export const modifyInstanceNetworkPerformanceOptions: API.OperationMethod<
  ModifyInstanceNetworkPerformanceRequest,
  ModifyInstanceNetworkPerformanceResult,
  ModifyInstanceNetworkPerformanceOptionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyInstanceNetworkPerformanceRequest,
  output: ModifyInstanceNetworkPerformanceResult,
  errors: [RequestLimitExceeded, InvalidAction],
}));
export type ModifyInstancePlacementError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | CommonErrors;
/**
 * Modifies the placement attributes for a specified instance. You can do the
 * following:
 *
 * - Modify the affinity between an instance and a Dedicated
 * Host. When affinity is set to `host` and the instance is
 * not associated with a specific Dedicated Host, the next time the instance is
 * started, it is automatically associated with the host on which it lands. If the
 * instance is restarted or rebooted, this relationship persists.
 *
 * - Change the Dedicated Host with which an instance is associated.
 *
 * - Change the instance tenancy of an instance.
 *
 * - Move an instance to or from a placement
 * group.
 *
 * At least one attribute for affinity, host ID, tenancy, or placement group name must be
 * specified in the request. Affinity and tenancy can be modified in the same
 * request.
 *
 * To modify the host ID, tenancy, placement group, or partition for an instance, the
 * instance must be in the `stopped` state.
 */
export const modifyInstancePlacement: API.OperationMethod<
  ModifyInstancePlacementRequest,
  ModifyInstancePlacementResult,
  ModifyInstancePlacementError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyInstancePlacementRequest,
  output: ModifyInstancePlacementResult,
  errors: [RequestLimitExceeded, InvalidInstanceIDMalformed],
}));
export type ModifyIpamError =
  | RequestLimitExceeded
  | InvalidParameterCombination
  | CommonErrors;
/**
 * Modify the configurations of an IPAM.
 */
export const modifyIpam: API.OperationMethod<
  ModifyIpamRequest,
  ModifyIpamResult,
  ModifyIpamError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyIpamRequest,
  output: ModifyIpamResult,
  errors: [RequestLimitExceeded, InvalidParameterCombination],
}));
export type ModifyIpamPolicyAllocationRulesError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Modifies the allocation rules in an IPAM policy.
 *
 * An IPAM policy is a set of rules that define how public IPv4 addresses from IPAM pools are allocated to Amazon Web Services resources. Each rule maps an Amazon Web Services service to IPAM pools that the service will use to get IP addresses. A single policy can have multiple rules and be applied to multiple Amazon Web Services Regions. If the IPAM pool run out of addresses then the services fallback to Amazon-provided IP addresses. A policy can be applied to an individual Amazon Web Services account or an entity within Amazon Web Services Organizations.
 *
 * Allocation rules are optional configurations within an IPAM policy that map Amazon Web Services resource types to specific IPAM pools. If no rules are defined, the resource types default to using Amazon-provided IP addresses.
 */
export const modifyIpamPolicyAllocationRules: API.OperationMethod<
  ModifyIpamPolicyAllocationRulesRequest,
  ModifyIpamPolicyAllocationRulesResult,
  ModifyIpamPolicyAllocationRulesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyIpamPolicyAllocationRulesRequest,
  output: ModifyIpamPolicyAllocationRulesResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type ModifyIpamPoolError =
  | RequestLimitExceeded
  | InvalidIpamPoolIdNotFound
  | CommonErrors;
/**
 * Modify the configurations of an IPAM pool.
 *
 * For more information, see Modify a pool in the *Amazon VPC IPAM User Guide*.
 */
export const modifyIpamPool: API.OperationMethod<
  ModifyIpamPoolRequest,
  ModifyIpamPoolResult,
  ModifyIpamPoolError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyIpamPoolRequest,
  output: ModifyIpamPoolResult,
  errors: [RequestLimitExceeded, InvalidIpamPoolIdNotFound],
}));
export type ModifyIpamPrefixListResolverError =
  | RequestLimitExceeded
  | InvalidIpamPrefixListResolverIdMalformed
  | InvalidIpamPrefixListResolverIdNotFound
  | CommonErrors;
/**
 * Modifies an IPAM prefix list resolver. You can update the description and CIDR selection rules. Changes to rules will trigger re-evaluation and potential updates to associated prefix lists.
 */
export const modifyIpamPrefixListResolver: API.OperationMethod<
  ModifyIpamPrefixListResolverRequest,
  ModifyIpamPrefixListResolverResult,
  ModifyIpamPrefixListResolverError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyIpamPrefixListResolverRequest,
  output: ModifyIpamPrefixListResolverResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamPrefixListResolverIdMalformed,
    InvalidIpamPrefixListResolverIdNotFound,
  ],
}));
export type ModifyIpamPrefixListResolverTargetError =
  | RequestLimitExceeded
  | InvalidIpamPrefixListResolverTargetIdMalformed
  | CommonErrors;
/**
 * Modifies an IPAM prefix list resolver target. You can update version tracking settings and the desired version of the target prefix list.
 */
export const modifyIpamPrefixListResolverTarget: API.OperationMethod<
  ModifyIpamPrefixListResolverTargetRequest,
  ModifyIpamPrefixListResolverTargetResult,
  ModifyIpamPrefixListResolverTargetError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyIpamPrefixListResolverTargetRequest,
  output: ModifyIpamPrefixListResolverTargetResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamPrefixListResolverTargetIdMalformed,
  ],
}));
export type ModifyIpamResourceCidrError =
  | RequestLimitExceeded
  | InvalidIpamScopeIdMalformed
  | InvalidParameterValue
  | CommonErrors;
/**
 * Modify a resource CIDR. You can use this action to transfer resource CIDRs between scopes and ignore resource CIDRs that you do not want to manage. If set to false, the resource will not be tracked for overlap, it cannot be auto-imported into a pool, and it will be removed from any pool it has an allocation in.
 *
 * For more information, see Move resource CIDRs between scopes and Change the monitoring state of resource CIDRs in the *Amazon VPC IPAM User Guide*.
 */
export const modifyIpamResourceCidr: API.OperationMethod<
  ModifyIpamResourceCidrRequest,
  ModifyIpamResourceCidrResult,
  ModifyIpamResourceCidrError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyIpamResourceCidrRequest,
  output: ModifyIpamResourceCidrResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamScopeIdMalformed,
    InvalidParameterValue,
  ],
}));
export type ModifyIpamResourceDiscoveryError =
  | RequestLimitExceeded
  | InvalidIpamResourceDiscoveryIdMalformed
  | InvalidIpamResourceDiscoveryIdNotFound
  | CommonErrors;
/**
 * Modifies a resource discovery. A resource discovery is an IPAM component that enables IPAM to manage and monitor resources that belong to the owning account.
 */
export const modifyIpamResourceDiscovery: API.OperationMethod<
  ModifyIpamResourceDiscoveryRequest,
  ModifyIpamResourceDiscoveryResult,
  ModifyIpamResourceDiscoveryError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyIpamResourceDiscoveryRequest,
  output: ModifyIpamResourceDiscoveryResult,
  errors: [
    RequestLimitExceeded,
    InvalidIpamResourceDiscoveryIdMalformed,
    InvalidIpamResourceDiscoveryIdNotFound,
  ],
}));
export type ModifyIpamScopeError =
  | RequestLimitExceeded
  | InvalidParameterCombination
  | CommonErrors;
/**
 * Modify an IPAM scope.
 */
export const modifyIpamScope: API.OperationMethod<
  ModifyIpamScopeRequest,
  ModifyIpamScopeResult,
  ModifyIpamScopeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyIpamScopeRequest,
  output: ModifyIpamScopeResult,
  errors: [RequestLimitExceeded, InvalidParameterCombination],
}));
export type ModifyLaunchTemplateError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Modifies a launch template. You can specify which version of the launch template to
 * set as the default version. When launching an instance, the default version applies when
 * a launch template version is not specified.
 */
export const modifyLaunchTemplate: API.OperationMethod<
  ModifyLaunchTemplateRequest,
  ModifyLaunchTemplateResult,
  ModifyLaunchTemplateError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyLaunchTemplateRequest,
  output: ModifyLaunchTemplateResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type ModifyLocalGatewayRouteError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Modifies the specified local gateway route.
 */
export const modifyLocalGatewayRoute: API.OperationMethod<
  ModifyLocalGatewayRouteRequest,
  ModifyLocalGatewayRouteResult,
  ModifyLocalGatewayRouteError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyLocalGatewayRouteRequest,
  output: ModifyLocalGatewayRouteResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type ModifyManagedPrefixListError =
  | RequestLimitExceeded
  | InvalidParameterCombination
  | InvalidPrefixListIDNotFound
  | InvalidPrefixListIdMalformed
  | CommonErrors;
/**
 * Modifies the specified managed prefix list.
 *
 * Adding or removing entries in a prefix list creates a new version of the prefix list.
 * Changing the name of the prefix list does not affect the version.
 *
 * If you specify a current version number that does not match the true current version
 * number, the request fails.
 */
export const modifyManagedPrefixList: API.OperationMethod<
  ModifyManagedPrefixListRequest,
  ModifyManagedPrefixListResult,
  ModifyManagedPrefixListError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyManagedPrefixListRequest,
  output: ModifyManagedPrefixListResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterCombination,
    InvalidPrefixListIDNotFound,
    InvalidPrefixListIdMalformed,
  ],
}));
export type ModifyNetworkInterfaceAttributeError =
  | RequestLimitExceeded
  | InvalidNetworkInterfaceIDNotFound
  | InvalidNetworkInterfaceIdMalformed
  | InvalidParameterCombination
  | CommonErrors;
/**
 * Modifies the specified network interface attribute. You can specify only one attribute
 * at a time. You can use this action to attach and detach security groups from an existing
 * EC2 instance.
 */
export const modifyNetworkInterfaceAttribute: API.OperationMethod<
  ModifyNetworkInterfaceAttributeRequest,
  ModifyNetworkInterfaceAttributeResponse,
  ModifyNetworkInterfaceAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyNetworkInterfaceAttributeRequest,
  output: ModifyNetworkInterfaceAttributeResponse,
  errors: [
    RequestLimitExceeded,
    InvalidNetworkInterfaceIDNotFound,
    InvalidNetworkInterfaceIdMalformed,
    InvalidParameterCombination,
  ],
}));
export type ModifyPrivateDnsNameOptionsError =
  | RequestLimitExceeded
  | UnknownResource
  | CommonErrors;
/**
 * Modifies the options for instance hostnames for the specified instance.
 */
export const modifyPrivateDnsNameOptions: API.OperationMethod<
  ModifyPrivateDnsNameOptionsRequest,
  ModifyPrivateDnsNameOptionsResult,
  ModifyPrivateDnsNameOptionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyPrivateDnsNameOptionsRequest,
  output: ModifyPrivateDnsNameOptionsResult,
  errors: [RequestLimitExceeded, UnknownResource],
}));
export type ModifyPublicIpDnsNameOptionsError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Modify public hostname options for a network interface. For more information, see EC2 instance hostnames, DNS names, and domains in the *Amazon EC2 User Guide*.
 */
export const modifyPublicIpDnsNameOptions: API.OperationMethod<
  ModifyPublicIpDnsNameOptionsRequest,
  ModifyPublicIpDnsNameOptionsResult,
  ModifyPublicIpDnsNameOptionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyPublicIpDnsNameOptionsRequest,
  output: ModifyPublicIpDnsNameOptionsResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type ModifyReservedInstancesError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Modifies the configuration of your Reserved Instances, such as the Availability Zone,
 * instance count, or instance type. The Reserved Instances to be modified must be identical,
 * except for Availability Zone, network platform, and instance type.
 *
 * For more information, see Modify Reserved Instances in the
 * *Amazon EC2 User Guide*.
 */
export const modifyReservedInstances: API.OperationMethod<
  ModifyReservedInstancesRequest,
  ModifyReservedInstancesResult,
  ModifyReservedInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyReservedInstancesRequest,
  output: ModifyReservedInstancesResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type ModifyRouteServerError =
  | RequestLimitExceeded
  | InvalidRouteServerIdNotFound
  | CommonErrors;
/**
 * Modifies the configuration of an existing route server.
 *
 * Amazon VPC Route Server simplifies routing for traffic between workloads that are deployed within a VPC and its internet gateways. With this feature,
 * VPC Route Server dynamically updates VPC and internet gateway route tables with your preferred IPv4 or IPv6 routes to achieve routing fault tolerance for those workloads. This enables you to automatically reroute traffic within a VPC, which increases the manageability of VPC routing and interoperability with third-party workloads.
 *
 * Route server supports the follow route table types:
 *
 * - VPC route tables not associated with subnets
 *
 * - Subnet route tables
 *
 * - Internet gateway route tables
 *
 * Route server does not support route tables associated with virtual private gateways. To propagate routes into a transit gateway route table, use Transit Gateway Connect.
 *
 * For more information see Dynamic routing in your VPC with VPC Route Server in the *Amazon VPC User Guide*.
 */
export const modifyRouteServer: API.OperationMethod<
  ModifyRouteServerRequest,
  ModifyRouteServerResult,
  ModifyRouteServerError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyRouteServerRequest,
  output: ModifyRouteServerResult,
  errors: [RequestLimitExceeded, InvalidRouteServerIdNotFound],
}));
export type ModifySecurityGroupRulesError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Modifies the rules of a security group.
 */
export const modifySecurityGroupRules: API.OperationMethod<
  ModifySecurityGroupRulesRequest,
  ModifySecurityGroupRulesResult,
  ModifySecurityGroupRulesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifySecurityGroupRulesRequest,
  output: ModifySecurityGroupRulesResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type ModifySnapshotAttributeError =
  | RequestLimitExceeded
  | InvalidParameterCombination
  | InvalidSnapshotNotFound
  | CommonErrors;
/**
 * Adds or removes permission settings for the specified snapshot. You may add or remove
 * specified Amazon Web Services account IDs from a snapshot's list of create volume permissions, but you cannot
 * do both in a single operation. If you need to both add and remove account IDs for a snapshot,
 * you must use multiple operations. You can make up to 500 modifications to a snapshot in a single operation.
 *
 * Encrypted snapshots and snapshots with Amazon Web Services Marketplace product codes cannot be made
 * public. Snapshots encrypted with your default KMS key cannot be shared with other accounts.
 *
 * For more information about modifying snapshot permissions, see Share a snapshot in the
 * *Amazon EBS User Guide*.
 */
export const modifySnapshotAttribute: API.OperationMethod<
  ModifySnapshotAttributeRequest,
  ModifySnapshotAttributeResponse,
  ModifySnapshotAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifySnapshotAttributeRequest,
  output: ModifySnapshotAttributeResponse,
  errors: [
    RequestLimitExceeded,
    InvalidParameterCombination,
    InvalidSnapshotNotFound,
  ],
}));
export type ModifySnapshotTierError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Archives an Amazon EBS snapshot. When you archive a snapshot, it is converted to a full
 * snapshot that includes all of the blocks of data that were written to the volume at the
 * time the snapshot was created, and moved from the standard tier to the archive
 * tier. For more information, see Archive Amazon EBS snapshots
 * in the *Amazon EBS User Guide*.
 */
export const modifySnapshotTier: API.OperationMethod<
  ModifySnapshotTierRequest,
  ModifySnapshotTierResult,
  ModifySnapshotTierError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifySnapshotTierRequest,
  output: ModifySnapshotTierResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type ModifySpotFleetRequestError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Modifies the specified Spot Fleet request.
 *
 * You can only modify a Spot Fleet request of type `maintain`.
 *
 * While the Spot Fleet request is being modified, it is in the `modifying`
 * state.
 *
 * To scale up your Spot Fleet, increase its target capacity. The Spot Fleet launches the
 * additional Spot Instances according to the allocation strategy for the Spot Fleet
 * request. If the allocation strategy is `lowestPrice`, the Spot Fleet launches
 * instances using the Spot Instance pool with the lowest price. If the allocation strategy
 * is `diversified`, the Spot Fleet distributes the instances across the Spot
 * Instance pools. If the allocation strategy is `capacityOptimized`, Spot Fleet
 * launches instances from Spot Instance pools with optimal capacity for the number of instances
 * that are launching.
 *
 * To scale down your Spot Fleet, decrease its target capacity. First, the Spot Fleet
 * cancels any open requests that exceed the new target capacity. You can request that the
 * Spot Fleet terminate Spot Instances until the size of the fleet no longer exceeds the
 * new target capacity. If the allocation strategy is `lowestPrice`, the Spot
 * Fleet terminates the instances with the highest price per unit. If the allocation
 * strategy is `capacityOptimized`, the Spot Fleet terminates the instances in
 * the Spot Instance pools that have the least available Spot Instance capacity. If the allocation
 * strategy is `diversified`, the Spot Fleet terminates instances across the
 * Spot Instance pools. Alternatively, you can request that the Spot Fleet keep the fleet
 * at its current size, but not replace any Spot Instances that are interrupted or that you
 * terminate manually.
 *
 * If you are finished with your Spot Fleet for now, but will use it again later, you can
 * set the target capacity to 0.
 */
export const modifySpotFleetRequest: API.OperationMethod<
  ModifySpotFleetRequestRequest,
  ModifySpotFleetRequestResponse,
  ModifySpotFleetRequestError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifySpotFleetRequestRequest,
  output: ModifySpotFleetRequestResponse,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type ModifySubnetAttributeError =
  | RequestLimitExceeded
  | InvalidSubnetIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Modifies a subnet attribute. You can only modify one attribute at a time.
 *
 * Use this action to modify subnets on Amazon Web Services Outposts.
 *
 * - To modify a subnet on an Outpost rack, set both
 * `MapCustomerOwnedIpOnLaunch` and
 * `CustomerOwnedIpv4Pool`. These two parameters act as a single
 * attribute.
 *
 * - To modify a subnet on an Outpost server, set either
 * `EnableLniAtDeviceIndex` or
 * `DisableLniAtDeviceIndex`.
 *
 * For more information about Amazon Web Services Outposts, see the following:
 *
 * - Outpost servers
 *
 * - Outpost racks
 */
export const modifySubnetAttribute: API.OperationMethod<
  ModifySubnetAttributeRequest,
  ModifySubnetAttributeResponse,
  ModifySubnetAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifySubnetAttributeRequest,
  output: ModifySubnetAttributeResponse,
  errors: [RequestLimitExceeded, InvalidSubnetIDNotFound, MissingParameter],
}));
export type ModifyTrafficMirrorFilterNetworkServicesError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Allows or restricts mirroring network services.
 *
 * By default, Amazon DNS network services are not eligible for Traffic Mirror. Use `AddNetworkServices` to add network services to a Traffic Mirror filter. When a network service is added to the Traffic Mirror filter, all traffic related to that network service will be mirrored.
 * When you no longer want to mirror network services, use `RemoveNetworkServices` to remove the network services from the Traffic Mirror filter.
 */
export const modifyTrafficMirrorFilterNetworkServices: API.OperationMethod<
  ModifyTrafficMirrorFilterNetworkServicesRequest,
  ModifyTrafficMirrorFilterNetworkServicesResult,
  ModifyTrafficMirrorFilterNetworkServicesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyTrafficMirrorFilterNetworkServicesRequest,
  output: ModifyTrafficMirrorFilterNetworkServicesResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type ModifyTrafficMirrorFilterRuleError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidTrafficMirrorFilterRuleIdNotFound
  | CommonErrors;
/**
 * Modifies the specified Traffic Mirror rule.
 *
 * `DestinationCidrBlock` and `SourceCidrBlock` must both be an IPv4
 * range or an IPv6 range.
 */
export const modifyTrafficMirrorFilterRule: API.OperationMethod<
  ModifyTrafficMirrorFilterRuleRequest,
  ModifyTrafficMirrorFilterRuleResult,
  ModifyTrafficMirrorFilterRuleError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyTrafficMirrorFilterRuleRequest,
  output: ModifyTrafficMirrorFilterRuleResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidTrafficMirrorFilterRuleIdNotFound,
  ],
}));
export type ModifyTrafficMirrorSessionError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Modifies a Traffic Mirror session.
 */
export const modifyTrafficMirrorSession: API.OperationMethod<
  ModifyTrafficMirrorSessionRequest,
  ModifyTrafficMirrorSessionResult,
  ModifyTrafficMirrorSessionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyTrafficMirrorSessionRequest,
  output: ModifyTrafficMirrorSessionResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type ModifyTransitGatewayError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Modifies the specified transit gateway. When you modify a transit gateway, the modified options are applied to new transit gateway attachments only. Your existing transit gateway attachments are not modified.
 */
export const modifyTransitGateway: API.OperationMethod<
  ModifyTransitGatewayRequest,
  ModifyTransitGatewayResult,
  ModifyTransitGatewayError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyTransitGatewayRequest,
  output: ModifyTransitGatewayResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type ModifyTransitGatewayMeteringPolicyError =
  | RequestLimitExceeded
  | InvalidTransitGatewayMeteringPolicyIdMalformedException
  | MissingParameter
  | CommonErrors;
/**
 * Modifies a transit gateway metering policy.
 */
export const modifyTransitGatewayMeteringPolicy: API.OperationMethod<
  ModifyTransitGatewayMeteringPolicyRequest,
  ModifyTransitGatewayMeteringPolicyResult,
  ModifyTransitGatewayMeteringPolicyError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyTransitGatewayMeteringPolicyRequest,
  output: ModifyTransitGatewayMeteringPolicyResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayMeteringPolicyIdMalformedException,
    MissingParameter,
  ],
}));
export type ModifyTransitGatewayPrefixListReferenceError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Modifies a reference (route) to a prefix list in a specified transit gateway route table.
 */
export const modifyTransitGatewayPrefixListReference: API.OperationMethod<
  ModifyTransitGatewayPrefixListReferenceRequest,
  ModifyTransitGatewayPrefixListReferenceResult,
  ModifyTransitGatewayPrefixListReferenceError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyTransitGatewayPrefixListReferenceRequest,
  output: ModifyTransitGatewayPrefixListReferenceResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type ModifyTransitGatewayVpcAttachmentError =
  | RequestLimitExceeded
  | InvalidTransitGatewayAttachmentIDNotFound
  | CommonErrors;
/**
 * Modifies the specified VPC attachment.
 */
export const modifyTransitGatewayVpcAttachment: API.OperationMethod<
  ModifyTransitGatewayVpcAttachmentRequest,
  ModifyTransitGatewayVpcAttachmentResult,
  ModifyTransitGatewayVpcAttachmentError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyTransitGatewayVpcAttachmentRequest,
  output: ModifyTransitGatewayVpcAttachmentResult,
  errors: [RequestLimitExceeded, InvalidTransitGatewayAttachmentIDNotFound],
}));
export type ModifyVerifiedAccessEndpointError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidVerifiedAccessEndpointIdNotFound
  | CommonErrors;
/**
 * Modifies the configuration of the specified Amazon Web Services Verified Access endpoint.
 */
export const modifyVerifiedAccessEndpoint: API.OperationMethod<
  ModifyVerifiedAccessEndpointRequest,
  ModifyVerifiedAccessEndpointResult,
  ModifyVerifiedAccessEndpointError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVerifiedAccessEndpointRequest,
  output: ModifyVerifiedAccessEndpointResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidVerifiedAccessEndpointIdNotFound,
  ],
}));
export type ModifyVerifiedAccessEndpointPolicyError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidVerifiedAccessEndpointIdNotFound
  | CommonErrors;
/**
 * Modifies the specified Amazon Web Services Verified Access endpoint policy.
 */
export const modifyVerifiedAccessEndpointPolicy: API.OperationMethod<
  ModifyVerifiedAccessEndpointPolicyRequest,
  ModifyVerifiedAccessEndpointPolicyResult,
  ModifyVerifiedAccessEndpointPolicyError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVerifiedAccessEndpointPolicyRequest,
  output: ModifyVerifiedAccessEndpointPolicyResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidVerifiedAccessEndpointIdNotFound,
  ],
}));
export type ModifyVerifiedAccessGroupError =
  | RequestLimitExceeded
  | InvalidVerifiedAccessGroupIdNotFound
  | CommonErrors;
/**
 * Modifies the specified Amazon Web Services Verified Access group configuration.
 */
export const modifyVerifiedAccessGroup: API.OperationMethod<
  ModifyVerifiedAccessGroupRequest,
  ModifyVerifiedAccessGroupResult,
  ModifyVerifiedAccessGroupError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVerifiedAccessGroupRequest,
  output: ModifyVerifiedAccessGroupResult,
  errors: [RequestLimitExceeded, InvalidVerifiedAccessGroupIdNotFound],
}));
export type ModifyVerifiedAccessGroupPolicyError =
  | RequestLimitExceeded
  | InvalidVerifiedAccessGroupIdNotFound
  | CommonErrors;
/**
 * Modifies the specified Amazon Web Services Verified Access group policy.
 */
export const modifyVerifiedAccessGroupPolicy: API.OperationMethod<
  ModifyVerifiedAccessGroupPolicyRequest,
  ModifyVerifiedAccessGroupPolicyResult,
  ModifyVerifiedAccessGroupPolicyError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVerifiedAccessGroupPolicyRequest,
  output: ModifyVerifiedAccessGroupPolicyResult,
  errors: [RequestLimitExceeded, InvalidVerifiedAccessGroupIdNotFound],
}));
export type ModifyVerifiedAccessInstanceError =
  | RequestLimitExceeded
  | InvalidVerifiedAccessInstanceIdNotFound
  | CommonErrors;
/**
 * Modifies the configuration of the specified Amazon Web Services Verified Access instance.
 */
export const modifyVerifiedAccessInstance: API.OperationMethod<
  ModifyVerifiedAccessInstanceRequest,
  ModifyVerifiedAccessInstanceResult,
  ModifyVerifiedAccessInstanceError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVerifiedAccessInstanceRequest,
  output: ModifyVerifiedAccessInstanceResult,
  errors: [RequestLimitExceeded, InvalidVerifiedAccessInstanceIdNotFound],
}));
export type ModifyVerifiedAccessInstanceLoggingConfigurationError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Modifies the logging configuration for the specified Amazon Web Services Verified Access instance.
 */
export const modifyVerifiedAccessInstanceLoggingConfiguration: API.OperationMethod<
  ModifyVerifiedAccessInstanceLoggingConfigurationRequest,
  ModifyVerifiedAccessInstanceLoggingConfigurationResult,
  ModifyVerifiedAccessInstanceLoggingConfigurationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVerifiedAccessInstanceLoggingConfigurationRequest,
  output: ModifyVerifiedAccessInstanceLoggingConfigurationResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type ModifyVerifiedAccessTrustProviderError =
  | RequestLimitExceeded
  | InvalidVerifiedAccessTrustProviderIdNotFound
  | CommonErrors;
/**
 * Modifies the configuration of the specified Amazon Web Services Verified Access trust provider.
 */
export const modifyVerifiedAccessTrustProvider: API.OperationMethod<
  ModifyVerifiedAccessTrustProviderRequest,
  ModifyVerifiedAccessTrustProviderResult,
  ModifyVerifiedAccessTrustProviderError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVerifiedAccessTrustProviderRequest,
  output: ModifyVerifiedAccessTrustProviderResult,
  errors: [RequestLimitExceeded, InvalidVerifiedAccessTrustProviderIdNotFound],
}));
export type ModifyVolumeError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | InvalidVolumeNotFound
  | InvalidVolumeIDMalformed
  | CommonErrors;
/**
 * You can modify several parameters of an existing EBS volume, including volume size, volume
 * type, and IOPS capacity. If your EBS volume is attached to a current-generation EC2 instance
 * type, you might be able to apply these changes without stopping the instance or detaching the
 * volume from it. For more information about modifying EBS volumes, see Amazon EBS Elastic Volumes
 * in the *Amazon EBS User Guide*.
 *
 * When you complete a resize operation on your volume, you need to extend the volume's
 * file-system size to take advantage of the new storage capacity. For more information, see Extend the file system.
 *
 * For more information, see Monitor the progress of volume modifications in the *Amazon EBS User Guide*.
 *
 * With previous-generation instance types, resizing an EBS volume might require detaching and
 * reattaching the volume or stopping and restarting the instance.
 *
 * After you initiate a volume modification, you must wait for that modification to reach the
 * `completed` state before you can initiate another modification for the same volume.
 * You can modify a volume up to four times within a rolling 24-hour period, as long as the volume
 * is in the `in-use` or `available` state, and all previous modifications
 * for that volume are `completed`. If you exceed this limit, you get an error message
 * that indicates when you can perform your next modification.
 */
export const modifyVolume: API.OperationMethod<
  ModifyVolumeRequest,
  ModifyVolumeResult,
  ModifyVolumeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVolumeRequest,
  output: ModifyVolumeResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameterValue,
    InvalidVolumeNotFound,
    InvalidVolumeIDMalformed,
  ],
}));
export type ModifyVolumeAttributeError =
  | RequestLimitExceeded
  | InvalidVolumeNotFound
  | InvalidVolumeIDMalformed
  | CommonErrors;
/**
 * Modifies a volume attribute.
 *
 * By default, all I/O operations for the volume are suspended when the data on the volume is
 * determined to be potentially inconsistent, to prevent undetectable, latent data corruption.
 * The I/O access to the volume can be resumed by first enabling I/O access and then checking the
 * data consistency on your volume.
 *
 * You can change the default behavior to resume I/O operations. We recommend that you change
 * this only for boot volumes or for volumes that are stateless or disposable.
 */
export const modifyVolumeAttribute: API.OperationMethod<
  ModifyVolumeAttributeRequest,
  ModifyVolumeAttributeResponse,
  ModifyVolumeAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVolumeAttributeRequest,
  output: ModifyVolumeAttributeResponse,
  errors: [
    RequestLimitExceeded,
    InvalidVolumeNotFound,
    InvalidVolumeIDMalformed,
  ],
}));
export type ModifyVpcAttributeError =
  | RequestLimitExceeded
  | InvalidParameterCombination
  | InvalidVpcIDNotFound
  | CommonErrors;
/**
 * Modifies the specified attribute of the specified VPC.
 */
export const modifyVpcAttribute: API.OperationMethod<
  ModifyVpcAttributeRequest,
  ModifyVpcAttributeResponse,
  ModifyVpcAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVpcAttributeRequest,
  output: ModifyVpcAttributeResponse,
  errors: [
    RequestLimitExceeded,
    InvalidParameterCombination,
    InvalidVpcIDNotFound,
  ],
}));
export type ModifyVpcBlockPublicAccessExclusionError = CommonErrors;
/**
 * Modify VPC Block Public Access (BPA) exclusions. A VPC BPA exclusion is a mode that can be applied to a single VPC or subnet that exempts it from the accounts BPA mode and will allow bidirectional or egress-only access. You can create BPA exclusions for VPCs and subnets even when BPA is not enabled on the account to ensure that there is no traffic disruption to the exclusions when VPC BPA is turned on.
 */
export const modifyVpcBlockPublicAccessExclusion: API.OperationMethod<
  ModifyVpcBlockPublicAccessExclusionRequest,
  ModifyVpcBlockPublicAccessExclusionResult,
  ModifyVpcBlockPublicAccessExclusionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVpcBlockPublicAccessExclusionRequest,
  output: ModifyVpcBlockPublicAccessExclusionResult,
  errors: [],
}));
export type ModifyVpcBlockPublicAccessOptionsError = CommonErrors;
/**
 * Modify VPC Block Public Access (BPA) options. VPC Block Public Access (BPA) enables you to block resources in VPCs and subnets that you own in a Region from reaching or being reached from the internet through internet gateways and egress-only internet gateways. To learn more about VPC BPA, see Block public access to VPCs and subnets in the *Amazon VPC User Guide*.
 */
export const modifyVpcBlockPublicAccessOptions: API.OperationMethod<
  ModifyVpcBlockPublicAccessOptionsRequest,
  ModifyVpcBlockPublicAccessOptionsResult,
  ModifyVpcBlockPublicAccessOptionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVpcBlockPublicAccessOptionsRequest,
  output: ModifyVpcBlockPublicAccessOptionsResult,
  errors: [],
}));
export type ModifyVpcEncryptionControlError =
  | RequestLimitExceeded
  | InvalidVpcEncryptionControlIdMalformed
  | InvalidVpcEncryptionControlIdNotFound
  | CommonErrors;
/**
 * Modifies the encryption control configuration for a VPC. You can update the encryption mode and exclusion settings for various gateway types and peering connections.
 *
 * For more information, see Enforce VPC encryption in transit in the *Amazon VPC User Guide*.
 */
export const modifyVpcEncryptionControl: API.OperationMethod<
  ModifyVpcEncryptionControlRequest,
  ModifyVpcEncryptionControlResult,
  ModifyVpcEncryptionControlError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVpcEncryptionControlRequest,
  output: ModifyVpcEncryptionControlResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcEncryptionControlIdMalformed,
    InvalidVpcEncryptionControlIdNotFound,
  ],
}));
export type ModifyVpcEndpointError =
  | RequestLimitExceeded
  | InvalidVpcEndpointIdNotFound
  | CommonErrors;
/**
 * Modifies attributes of a specified VPC endpoint. The attributes that you can modify
 * depend on the type of VPC endpoint (interface, gateway, or Gateway Load Balancer). For more information,
 * see the Amazon Web Services PrivateLink
 * Guide.
 */
export const modifyVpcEndpoint: API.OperationMethod<
  ModifyVpcEndpointRequest,
  ModifyVpcEndpointResult,
  ModifyVpcEndpointError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVpcEndpointRequest,
  output: ModifyVpcEndpointResult,
  errors: [RequestLimitExceeded, InvalidVpcEndpointIdNotFound],
}));
export type ModifyVpcEndpointConnectionNotificationError =
  | RequestLimitExceeded
  | InvalidConnectionNotification
  | InvalidParameter
  | CommonErrors;
/**
 * Modifies a connection notification for VPC endpoint or VPC endpoint service. You
 * can change the SNS topic for the notification, or the events for which to be notified.
 */
export const modifyVpcEndpointConnectionNotification: API.OperationMethod<
  ModifyVpcEndpointConnectionNotificationRequest,
  ModifyVpcEndpointConnectionNotificationResult,
  ModifyVpcEndpointConnectionNotificationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVpcEndpointConnectionNotificationRequest,
  output: ModifyVpcEndpointConnectionNotificationResult,
  errors: [
    RequestLimitExceeded,
    InvalidConnectionNotification,
    InvalidParameter,
  ],
}));
export type ModifyVpcEndpointServiceConfigurationError =
  | RequestLimitExceeded
  | InvalidVpcEndpointServiceIdMalformed
  | InvalidVpcEndpointServiceIdNotFound
  | CommonErrors;
/**
 * Modifies the attributes of the specified VPC endpoint service configuration.
 *
 * If you set or modify the private DNS name, you must prove that you own the private DNS
 * domain name.
 */
export const modifyVpcEndpointServiceConfiguration: API.OperationMethod<
  ModifyVpcEndpointServiceConfigurationRequest,
  ModifyVpcEndpointServiceConfigurationResult,
  ModifyVpcEndpointServiceConfigurationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVpcEndpointServiceConfigurationRequest,
  output: ModifyVpcEndpointServiceConfigurationResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcEndpointServiceIdMalformed,
    InvalidVpcEndpointServiceIdNotFound,
  ],
}));
export type ModifyVpcEndpointServicePayerResponsibilityError =
  | RequestLimitExceeded
  | UnsupportedOperation
  | CommonErrors;
/**
 * Modifies the payer responsibility for your VPC endpoint service.
 */
export const modifyVpcEndpointServicePayerResponsibility: API.OperationMethod<
  ModifyVpcEndpointServicePayerResponsibilityRequest,
  ModifyVpcEndpointServicePayerResponsibilityResult,
  ModifyVpcEndpointServicePayerResponsibilityError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVpcEndpointServicePayerResponsibilityRequest,
  output: ModifyVpcEndpointServicePayerResponsibilityResult,
  errors: [RequestLimitExceeded, UnsupportedOperation],
}));
export type ModifyVpcEndpointServicePermissionsError =
  | RequestLimitExceeded
  | InvalidVpcEndpointServiceIdMalformed
  | InvalidVpcEndpointServiceIdNotFound
  | CommonErrors;
/**
 * Modifies the permissions for your VPC endpoint service. You can add or remove permissions
 * for service consumers (Amazon Web Services accounts, users, and IAM roles) to connect to
 * your endpoint service. Principal ARNs with path components aren't supported.
 *
 * If you grant permissions to all principals, the service is public. Any users who know the name of a
 * public service can send a request to attach an endpoint. If the service does not require manual approval,
 * attachments are automatically approved.
 */
export const modifyVpcEndpointServicePermissions: API.OperationMethod<
  ModifyVpcEndpointServicePermissionsRequest,
  ModifyVpcEndpointServicePermissionsResult,
  ModifyVpcEndpointServicePermissionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVpcEndpointServicePermissionsRequest,
  output: ModifyVpcEndpointServicePermissionsResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcEndpointServiceIdMalformed,
    InvalidVpcEndpointServiceIdNotFound,
  ],
}));
export type ModifyVpcPeeringConnectionOptionsError =
  | RequestLimitExceeded
  | InvalidVpcPeeringConnectionIDNotFound
  | InvalidVpcPeeringConnectionIdNotFound
  | CommonErrors;
/**
 * Modifies the VPC peering connection options on one side of a VPC peering connection.
 *
 * If the peered VPCs are in the same Amazon Web Services account, you can enable DNS
 * resolution for queries from the local VPC. This ensures that queries from the local VPC
 * resolve to private IP addresses in the peer VPC. This option is not available if the
 * peered VPCs are in different Amazon Web Services accounts or different Regions. For
 * peered VPCs in different Amazon Web Services accounts, each Amazon Web Services account
 * owner must initiate a separate request to modify the peering connection options. For
 * inter-region peering connections, you must use the Region for the requester VPC to
 * modify the requester VPC peering options and the Region for the accepter VPC to modify
 * the accepter VPC peering options. To verify which VPCs are the accepter and the
 * requester for a VPC peering connection, use the DescribeVpcPeeringConnections command.
 */
export const modifyVpcPeeringConnectionOptions: API.OperationMethod<
  ModifyVpcPeeringConnectionOptionsRequest,
  ModifyVpcPeeringConnectionOptionsResult,
  ModifyVpcPeeringConnectionOptionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVpcPeeringConnectionOptionsRequest,
  output: ModifyVpcPeeringConnectionOptionsResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcPeeringConnectionIDNotFound,
    InvalidVpcPeeringConnectionIdNotFound,
  ],
}));
export type ModifyVpcTenancyError =
  | RequestLimitExceeded
  | InvalidVpcIDNotFound
  | InvalidVpcIdMalformed
  | CommonErrors;
/**
 * Modifies the instance tenancy attribute of the specified VPC. You can change the
 * instance tenancy attribute of a VPC to `default` only. You cannot change the
 * instance tenancy attribute to `dedicated`.
 *
 * After you modify the tenancy of the VPC, any new instances that you launch into the
 * VPC have a tenancy of `default`, unless you specify otherwise during launch.
 * The tenancy of any existing instances in the VPC is not affected.
 *
 * For more information, see Dedicated Instances in the
 * *Amazon EC2 User Guide*.
 */
export const modifyVpcTenancy: API.OperationMethod<
  ModifyVpcTenancyRequest,
  ModifyVpcTenancyResult,
  ModifyVpcTenancyError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVpcTenancyRequest,
  output: ModifyVpcTenancyResult,
  errors: [RequestLimitExceeded, InvalidVpcIDNotFound, InvalidVpcIdMalformed],
}));
export type ModifyVpnConnectionError =
  | RequestLimitExceeded
  | InvalidVpnConnectionId
  | CommonErrors;
/**
 * Modifies the customer gateway or the target gateway of an Amazon Web Services Site-to-Site VPN connection. To
 * modify the target gateway, the following migration options are available:
 *
 * - An existing virtual private gateway to a new virtual private gateway
 *
 * - An existing virtual private gateway to a transit gateway
 *
 * - An existing transit gateway to a new transit gateway
 *
 * - An existing transit gateway to a virtual private gateway
 *
 * Before you perform the migration to the new gateway, you must configure the new
 * gateway. Use CreateVpnGateway to create a virtual private gateway, or
 * CreateTransitGateway to create a transit gateway.
 *
 * This step is required when you migrate from a virtual private gateway with static
 * routes to a transit gateway.
 *
 * You must delete the static routes before you migrate to the new gateway.
 *
 * Keep a copy of the static route before you delete it. You will need to add back these
 * routes to the transit gateway after the VPN connection migration is complete.
 *
 * After you migrate to the new gateway, you might need to modify your VPC route table.
 * Use CreateRoute and DeleteRoute to make the changes
 * described in Update VPC route
 * tables in the *Amazon Web Services Site-to-Site VPN User Guide*.
 *
 * When the new gateway is a transit gateway, modify the transit gateway route table to
 * allow traffic between the VPC and the Amazon Web Services Site-to-Site VPN connection.
 * Use CreateTransitGatewayRoute to add the routes.
 *
 * If you deleted VPN static routes, you must add the static routes to the transit
 * gateway route table.
 *
 * After you perform this operation, the VPN endpoint's IP addresses on the Amazon Web Services side and the tunnel options remain intact. Your Amazon Web Services Site-to-Site VPN connection will
 * be temporarily unavailable for a brief period while we provision the new
 * endpoints.
 */
export const modifyVpnConnection: API.OperationMethod<
  ModifyVpnConnectionRequest,
  ModifyVpnConnectionResult,
  ModifyVpnConnectionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVpnConnectionRequest,
  output: ModifyVpnConnectionResult,
  errors: [RequestLimitExceeded, InvalidVpnConnectionId],
}));
export type ModifyVpnConnectionOptionsError =
  | RequestLimitExceeded
  | InvalidVpnConnectionIDNotFound
  | CommonErrors;
/**
 * Modifies the connection options for your Site-to-Site VPN connection.
 *
 * When you modify the VPN connection options, the VPN endpoint IP addresses on the
 * Amazon Web Services side do not change, and the tunnel options do not change. Your
 * VPN connection will be temporarily unavailable for a brief period while the VPN
 * connection is updated.
 */
export const modifyVpnConnectionOptions: API.OperationMethod<
  ModifyVpnConnectionOptionsRequest,
  ModifyVpnConnectionOptionsResult,
  ModifyVpnConnectionOptionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVpnConnectionOptionsRequest,
  output: ModifyVpnConnectionOptionsResult,
  errors: [RequestLimitExceeded, InvalidVpnConnectionIDNotFound],
}));
export type ModifyVpnTunnelCertificateError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Modifies the VPN tunnel endpoint certificate.
 */
export const modifyVpnTunnelCertificate: API.OperationMethod<
  ModifyVpnTunnelCertificateRequest,
  ModifyVpnTunnelCertificateResult,
  ModifyVpnTunnelCertificateError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVpnTunnelCertificateRequest,
  output: ModifyVpnTunnelCertificateResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type ModifyVpnTunnelOptionsError =
  | RequestLimitExceeded
  | InvalidVpnConnectionId
  | CommonErrors;
/**
 * Modifies the options for a VPN tunnel in an Amazon Web Services Site-to-Site VPN connection. You can modify
 * multiple options for a tunnel in a single request, but you can only modify one tunnel at
 * a time. For more information, see Site-to-Site VPN tunnel options for your Site-to-Site VPN
 * connection in the *Amazon Web Services Site-to-Site VPN User Guide*.
 */
export const modifyVpnTunnelOptions: API.OperationMethod<
  ModifyVpnTunnelOptionsRequest,
  ModifyVpnTunnelOptionsResult,
  ModifyVpnTunnelOptionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ModifyVpnTunnelOptionsRequest,
  output: ModifyVpnTunnelOptionsResult,
  errors: [RequestLimitExceeded, InvalidVpnConnectionId],
}));
export type MonitorInstancesError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | MissingParameter
  | CommonErrors;
/**
 * Enables detailed monitoring for a running instance. Otherwise, basic monitoring is
 * enabled. For more information, see Monitor your instances using
 * CloudWatch in the *Amazon EC2 User Guide*.
 *
 * To disable detailed monitoring, see UnmonitorInstances.
 */
export const monitorInstances: API.OperationMethod<
  MonitorInstancesRequest,
  MonitorInstancesResult,
  MonitorInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: MonitorInstancesRequest,
  output: MonitorInstancesResult,
  errors: [RequestLimitExceeded, InvalidParameterValue, MissingParameter],
}));
export type MoveAddressToVpcError =
  | RequestLimitExceeded
  | UnsupportedOperation
  | CommonErrors;
/**
 * This action is deprecated.
 *
 * Moves an Elastic IP address from the EC2-Classic platform to the EC2-VPC platform. The
 * Elastic IP address must be allocated to your account for more than 24 hours, and it must not
 * be associated with an instance. After the Elastic IP address is moved, it is no longer
 * available for use in the EC2-Classic platform. You cannot move an Elastic IP address that was
 * originally allocated for use in the EC2-VPC platform to the EC2-Classic platform.
 */
export const moveAddressToVpc: API.OperationMethod<
  MoveAddressToVpcRequest,
  MoveAddressToVpcResult,
  MoveAddressToVpcError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: MoveAddressToVpcRequest,
  output: MoveAddressToVpcResult,
  errors: [RequestLimitExceeded, UnsupportedOperation],
}));
export type MoveByoipCidrToIpamError =
  | RequestLimitExceeded
  | InvalidIpamPoolIdNotFound
  | CommonErrors;
/**
 * Move a BYOIPv4 CIDR to IPAM from a public IPv4 pool.
 *
 * If you already have a BYOIPv4 CIDR with Amazon Web Services, you can move the CIDR to IPAM from a public IPv4 pool. You cannot move an IPv6 CIDR to IPAM. If you are bringing a new IP address to Amazon Web Services for the first time, complete the steps in Tutorial: BYOIP address CIDRs to IPAM.
 */
export const moveByoipCidrToIpam: API.OperationMethod<
  MoveByoipCidrToIpamRequest,
  MoveByoipCidrToIpamResult,
  MoveByoipCidrToIpamError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: MoveByoipCidrToIpamRequest,
  output: MoveByoipCidrToIpamResult,
  errors: [RequestLimitExceeded, InvalidIpamPoolIdNotFound],
}));
export type MoveCapacityReservationInstancesError =
  | RequestLimitExceeded
  | InvalidCapacityReservationIdMalformed
  | CommonErrors;
/**
 * Move available capacity from a source Capacity Reservation to a destination Capacity
 * Reservation. The source Capacity Reservation and the destination Capacity Reservation
 * must be `active`, owned by your Amazon Web Services account, and share the following:
 *
 * - Instance type
 *
 * - Platform
 *
 * - Availability Zone
 *
 * - Tenancy
 *
 * - Placement group
 *
 * - Capacity Reservation end time - `At specific time` or
 * `Manually`.
 */
export const moveCapacityReservationInstances: API.OperationMethod<
  MoveCapacityReservationInstancesRequest,
  MoveCapacityReservationInstancesResult,
  MoveCapacityReservationInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: MoveCapacityReservationInstancesRequest,
  output: MoveCapacityReservationInstancesResult,
  errors: [RequestLimitExceeded, InvalidCapacityReservationIdMalformed],
}));
export type ProvisionByoipCidrError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Provisions an IPv4 or IPv6 address range for use with your Amazon Web Services resources through bring your own IP
 * addresses (BYOIP) and creates a corresponding address pool. After the address range is
 * provisioned, it is ready to be advertised.
 *
 * Amazon Web Services verifies that you own the address range and are authorized to advertise it.
 * You must ensure that the address range is registered to you and that you created an
 * RPKI ROA to authorize Amazon ASNs 16509 and 14618 to advertise the address range.
 * For more information, see Bring your own IP addresses (BYOIP) in the *Amazon EC2 User Guide*.
 *
 * Provisioning an address range is an asynchronous operation, so the call returns immediately,
 * but the address range is not ready to use until its status changes from `pending-provision`
 * to `provisioned`. For more information, see Onboard your address range.
 */
export const provisionByoipCidr: API.OperationMethod<
  ProvisionByoipCidrRequest,
  ProvisionByoipCidrResult,
  ProvisionByoipCidrError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ProvisionByoipCidrRequest,
  output: ProvisionByoipCidrResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type ProvisionIpamByoasnError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Provisions your Autonomous System Number (ASN) for use in your Amazon Web Services account. This action requires authorization context for Amazon to bring the ASN to an Amazon Web Services account. For more information, see Tutorial: Bring your ASN to IPAM in the *Amazon VPC IPAM guide*.
 */
export const provisionIpamByoasn: API.OperationMethod<
  ProvisionIpamByoasnRequest,
  ProvisionIpamByoasnResult,
  ProvisionIpamByoasnError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ProvisionIpamByoasnRequest,
  output: ProvisionIpamByoasnResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type ProvisionIpamPoolCidrError =
  | RequestLimitExceeded
  | InvalidIpamPoolIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Provision a CIDR to an IPAM pool. You can use this action to provision new CIDRs to a top-level pool or to transfer a CIDR from a top-level pool to a pool within it.
 *
 * For more information, see Provision CIDRs to pools in the *Amazon VPC IPAM User Guide*.
 */
export const provisionIpamPoolCidr: API.OperationMethod<
  ProvisionIpamPoolCidrRequest,
  ProvisionIpamPoolCidrResult,
  ProvisionIpamPoolCidrError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ProvisionIpamPoolCidrRequest,
  output: ProvisionIpamPoolCidrResult,
  errors: [RequestLimitExceeded, InvalidIpamPoolIdNotFound, MissingParameter],
}));
export type ProvisionPublicIpv4PoolCidrError =
  | RequestLimitExceeded
  | InvalidIpamPoolIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Provision a CIDR to a public IPv4 pool.
 *
 * For more information about IPAM, see What is IPAM? in the *Amazon VPC IPAM User Guide*.
 */
export const provisionPublicIpv4PoolCidr: API.OperationMethod<
  ProvisionPublicIpv4PoolCidrRequest,
  ProvisionPublicIpv4PoolCidrResult,
  ProvisionPublicIpv4PoolCidrError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ProvisionPublicIpv4PoolCidrRequest,
  output: ProvisionPublicIpv4PoolCidrResult,
  errors: [RequestLimitExceeded, InvalidIpamPoolIdNotFound, MissingParameter],
}));
export type PurchaseCapacityBlockError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Purchase the Capacity Block for use with your account. With Capacity Blocks you ensure
 * GPU capacity is available for machine learning (ML) workloads. You must specify the ID
 * of the Capacity Block offering you are purchasing.
 */
export const purchaseCapacityBlock: API.OperationMethod<
  PurchaseCapacityBlockRequest,
  PurchaseCapacityBlockResult,
  PurchaseCapacityBlockError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: PurchaseCapacityBlockRequest,
  output: PurchaseCapacityBlockResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type PurchaseCapacityBlockExtensionError =
  | RequestLimitExceeded
  | InvalidCapacityReservationIdNotFound
  | CommonErrors;
/**
 * Purchase the Capacity Block extension for use with your account. You must specify the
 * ID of the Capacity Block extension offering you are purchasing.
 */
export const purchaseCapacityBlockExtension: API.OperationMethod<
  PurchaseCapacityBlockExtensionRequest,
  PurchaseCapacityBlockExtensionResult,
  PurchaseCapacityBlockExtensionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: PurchaseCapacityBlockExtensionRequest,
  output: PurchaseCapacityBlockExtensionResult,
  errors: [RequestLimitExceeded, InvalidCapacityReservationIdNotFound],
}));
export type PurchaseHostReservationError = CommonErrors;
/**
 * Purchase a reservation with configurations that match those of your Dedicated Host.
 * You must have active Dedicated Hosts in your account before you purchase a reservation.
 * This action results in the specified reservation being purchased and charged to your
 * account.
 */
export const purchaseHostReservation: API.OperationMethod<
  PurchaseHostReservationRequest,
  PurchaseHostReservationResult,
  PurchaseHostReservationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: PurchaseHostReservationRequest,
  output: PurchaseHostReservationResult,
  errors: [],
}));
export type PurchaseReservedInstancesOfferingError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Purchases a Reserved Instance for use with your account. With Reserved Instances, you pay
 * a lower hourly rate compared to On-Demand instance pricing.
 *
 * Use DescribeReservedInstancesOfferings to get a list of Reserved
 * Instance offerings that match your specifications. After you've purchased a Reserved Instance,
 * you can check for your new Reserved Instance with DescribeReservedInstances.
 *
 * To queue a purchase for a future date and time, specify a purchase time. If you do not
 * specify a purchase time, the default is the current time.
 *
 * For more information, see Reserved
 * Instances and Sell in the Reserved Instance
 * Marketplace in the *Amazon EC2 User Guide*.
 */
export const purchaseReservedInstancesOffering: API.OperationMethod<
  PurchaseReservedInstancesOfferingRequest,
  PurchaseReservedInstancesOfferingResult,
  PurchaseReservedInstancesOfferingError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: PurchaseReservedInstancesOfferingRequest,
  output: PurchaseReservedInstancesOfferingResult,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type PurchaseScheduledInstancesError =
  | RequestLimitExceeded
  | InvalidPurchaseTokenMalformed
  | CommonErrors;
/**
 * You can no longer purchase Scheduled Instances.
 *
 * Purchases the Scheduled Instances with the specified schedule.
 *
 * Scheduled Instances enable you to purchase Amazon EC2 compute capacity by the hour for a one-year term.
 * Before you can purchase a Scheduled Instance, you must call DescribeScheduledInstanceAvailability
 * to check for available schedules and obtain a purchase token. After you purchase a Scheduled Instance,
 * you must call RunScheduledInstances during each scheduled time period.
 *
 * After you purchase a Scheduled Instance, you can't cancel, modify, or resell your purchase.
 */
export const purchaseScheduledInstances: API.OperationMethod<
  PurchaseScheduledInstancesRequest,
  PurchaseScheduledInstancesResult,
  PurchaseScheduledInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: PurchaseScheduledInstancesRequest,
  output: PurchaseScheduledInstancesResult,
  errors: [RequestLimitExceeded, InvalidPurchaseTokenMalformed],
}));
export type RebootInstancesError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | InvalidInstanceIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Requests a reboot of the specified instances. This operation is asynchronous; it only
 * queues a request to reboot the specified instances. The operation succeeds if the
 * instances are valid and belong to you. Requests to reboot terminated instances are
 * ignored.
 *
 * If an instance does not cleanly shut down within a few minutes, Amazon EC2 performs a
 * hard reboot.
 *
 * For more information about troubleshooting, see Troubleshoot an unreachable
 * instance in the *Amazon EC2 User Guide*.
 */
export const rebootInstances: API.OperationMethod<
  RebootInstancesRequest,
  RebootInstancesResponse,
  RebootInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RebootInstancesRequest,
  output: RebootInstancesResponse,
  errors: [
    RequestLimitExceeded,
    InvalidInstanceIDMalformed,
    InvalidInstanceIDNotFound,
    MissingParameter,
  ],
}));
export type RegisterImageError =
  | RequestLimitExceeded
  | InvalidParameterCombination
  | CommonErrors;
/**
 * Registers an AMI. When you're creating an instance-store backed AMI, registering the AMI
 * is the final step in the creation process. For more information about creating AMIs, see
 * Create an AMI from a snapshot and Create an instance-store
 * backed AMI in the *Amazon EC2 User Guide*.
 *
 * If needed, you can deregister an AMI at any time. Any modifications you make to an AMI
 * backed by an instance store volume invalidates its registration. If you make changes to an
 * image, deregister the previous image and register the new image.
 *
 * **Register a snapshot of a root device volume**
 *
 * You can use `RegisterImage` to create an Amazon EBS-backed Linux AMI from a snapshot
 * of a root device volume. You specify the snapshot using a block device mapping. You can't set
 * the encryption state of the volume using the block device mapping. If the snapshot is
 * encrypted, or encryption by default is enabled, the root volume of an instance launched from
 * the AMI is encrypted.
 *
 * For more information, see Create an AMI from a snapshot and Use encryption with EBS-backed AMIs
 * in the *Amazon EC2 User Guide*.
 *
 * **Amazon Web Services Marketplace product codes**
 *
 * If any snapshots have Amazon Web Services Marketplace product codes, they are copied to the new AMI.
 *
 * In most cases, AMIs for Windows, RedHat, SUSE, and SQL Server require correct licensing
 * information to be present on the AMI. For more information, see Understand AMI billing
 * information in the *Amazon EC2 User Guide*. When creating an AMI from
 * a snapshot, the `RegisterImage` operation derives the correct billing information
 * from the snapshot's metadata, but this requires the appropriate metadata to be present. To
 * verify if the correct billing information was applied, check the `PlatformDetails`
 * field on the new AMI. If the field is empty or doesn't match the expected operating system
 * code (for example, Windows, RedHat, SUSE, or SQL), the AMI creation was unsuccessful, and you
 * should discard the AMI and instead create the AMI from an instance.
 * For more information, see Create an AMI
 * from an instance in the *Amazon EC2 User Guide*.
 *
 * If you purchase a Reserved Instance to apply to an On-Demand Instance that was launched
 * from an AMI with a billing product code, make sure that the Reserved Instance has the matching
 * billing product code. If you purchase a Reserved Instance without the matching billing product
 * code, the Reserved Instance is not applied to the On-Demand Instance. For information
 * about how to obtain the platform details and billing information of an AMI, see Understand AMI
 * billing information in the *Amazon EC2 User Guide*.
 */
export const registerImage: API.OperationMethod<
  RegisterImageRequest,
  RegisterImageResult,
  RegisterImageError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RegisterImageRequest,
  output: RegisterImageResult,
  errors: [RequestLimitExceeded, InvalidParameterCombination],
}));
export type RegisterInstanceEventNotificationAttributesError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Registers a set of tag keys to include in scheduled event notifications for your
 * resources.
 *
 * To remove tags, use DeregisterInstanceEventNotificationAttributes.
 */
export const registerInstanceEventNotificationAttributes: API.OperationMethod<
  RegisterInstanceEventNotificationAttributesRequest,
  RegisterInstanceEventNotificationAttributesResult,
  RegisterInstanceEventNotificationAttributesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RegisterInstanceEventNotificationAttributesRequest,
  output: RegisterInstanceEventNotificationAttributesResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type RegisterTransitGatewayMulticastGroupMembersError =
  | RequestLimitExceeded
  | InvalidNetworkInterfaceIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Registers members (network interfaces) with the transit gateway multicast group. A member is a network interface associated
 * with a supported EC2 instance that receives multicast traffic. For more information, see
 * Multicast
 * on transit gateways in the *Amazon Web Services Transit Gateways Guide*.
 *
 * After you add the members, use SearchTransitGatewayMulticastGroups to verify that the members were added
 * to the transit gateway multicast group.
 */
export const registerTransitGatewayMulticastGroupMembers: API.OperationMethod<
  RegisterTransitGatewayMulticastGroupMembersRequest,
  RegisterTransitGatewayMulticastGroupMembersResult,
  RegisterTransitGatewayMulticastGroupMembersError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RegisterTransitGatewayMulticastGroupMembersRequest,
  output: RegisterTransitGatewayMulticastGroupMembersResult,
  errors: [
    RequestLimitExceeded,
    InvalidNetworkInterfaceIdMalformed,
    MissingParameter,
  ],
}));
export type RegisterTransitGatewayMulticastGroupSourcesError =
  | RequestLimitExceeded
  | InvalidNetworkInterfaceIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Registers sources (network interfaces) with the specified transit gateway multicast group.
 *
 * A multicast source is a network interface attached to a supported instance that sends
 * multicast traffic. For more information about supported instances, see Multicast
 * on transit gateways in the *Amazon Web Services Transit Gateways Guide*.
 *
 * After you add the source, use SearchTransitGatewayMulticastGroups to verify that the source was added to the multicast
 * group.
 */
export const registerTransitGatewayMulticastGroupSources: API.OperationMethod<
  RegisterTransitGatewayMulticastGroupSourcesRequest,
  RegisterTransitGatewayMulticastGroupSourcesResult,
  RegisterTransitGatewayMulticastGroupSourcesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RegisterTransitGatewayMulticastGroupSourcesRequest,
  output: RegisterTransitGatewayMulticastGroupSourcesResult,
  errors: [
    RequestLimitExceeded,
    InvalidNetworkInterfaceIdMalformed,
    MissingParameter,
  ],
}));
export type RejectCapacityReservationBillingOwnershipError =
  | RequestLimitExceeded
  | InvalidCapacityReservationIdMalformed
  | CommonErrors;
/**
 * Rejects a request to assign billing of the available capacity of a shared Capacity
 * Reservation to your account. For more information, see Billing assignment for shared
 * Amazon EC2 Capacity Reservations.
 */
export const rejectCapacityReservationBillingOwnership: API.OperationMethod<
  RejectCapacityReservationBillingOwnershipRequest,
  RejectCapacityReservationBillingOwnershipResult,
  RejectCapacityReservationBillingOwnershipError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RejectCapacityReservationBillingOwnershipRequest,
  output: RejectCapacityReservationBillingOwnershipResult,
  errors: [RequestLimitExceeded, InvalidCapacityReservationIdMalformed],
}));
export type RejectTransitGatewayMulticastDomainAssociationsError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Rejects a request to associate cross-account subnets with a transit gateway multicast domain.
 */
export const rejectTransitGatewayMulticastDomainAssociations: API.OperationMethod<
  RejectTransitGatewayMulticastDomainAssociationsRequest,
  RejectTransitGatewayMulticastDomainAssociationsResult,
  RejectTransitGatewayMulticastDomainAssociationsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RejectTransitGatewayMulticastDomainAssociationsRequest,
  output: RejectTransitGatewayMulticastDomainAssociationsResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type RejectTransitGatewayPeeringAttachmentError =
  | RequestLimitExceeded
  | InvalidTransitGatewayAttachmentIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Rejects a transit gateway peering attachment request.
 */
export const rejectTransitGatewayPeeringAttachment: API.OperationMethod<
  RejectTransitGatewayPeeringAttachmentRequest,
  RejectTransitGatewayPeeringAttachmentResult,
  RejectTransitGatewayPeeringAttachmentError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RejectTransitGatewayPeeringAttachmentRequest,
  output: RejectTransitGatewayPeeringAttachmentResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayAttachmentIDNotFound,
    MissingParameter,
  ],
}));
export type RejectTransitGatewayVpcAttachmentError =
  | RequestLimitExceeded
  | InvalidTransitGatewayAttachmentIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Rejects a request to attach a VPC to a transit gateway.
 *
 * The VPC attachment must be in the `pendingAcceptance` state.
 * Use DescribeTransitGatewayVpcAttachments to view your pending VPC attachment requests.
 * Use AcceptTransitGatewayVpcAttachment to accept a VPC attachment request.
 */
export const rejectTransitGatewayVpcAttachment: API.OperationMethod<
  RejectTransitGatewayVpcAttachmentRequest,
  RejectTransitGatewayVpcAttachmentResult,
  RejectTransitGatewayVpcAttachmentError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RejectTransitGatewayVpcAttachmentRequest,
  output: RejectTransitGatewayVpcAttachmentResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayAttachmentIDNotFound,
    MissingParameter,
  ],
}));
export type RejectVpcEndpointConnectionsError =
  | RequestLimitExceeded
  | InvalidParameter
  | InvalidVpcEndpointServiceIdNotFound
  | CommonErrors;
/**
 * Rejects VPC endpoint connection requests to your VPC endpoint service.
 */
export const rejectVpcEndpointConnections: API.OperationMethod<
  RejectVpcEndpointConnectionsRequest,
  RejectVpcEndpointConnectionsResult,
  RejectVpcEndpointConnectionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RejectVpcEndpointConnectionsRequest,
  output: RejectVpcEndpointConnectionsResult,
  errors: [
    RequestLimitExceeded,
    InvalidParameter,
    InvalidVpcEndpointServiceIdNotFound,
  ],
}));
export type RejectVpcPeeringConnectionError =
  | RequestLimitExceeded
  | InvalidVpcPeeringConnectionIDNotFound
  | InvalidVpcPeeringConnectionIdNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Rejects a VPC peering connection request. The VPC peering connection must be in the
 * `pending-acceptance` state. Use the DescribeVpcPeeringConnections request
 * to view your outstanding VPC peering connection requests. To delete an active VPC peering
 * connection, or to delete a VPC peering connection request that you initiated, use DeleteVpcPeeringConnection.
 */
export const rejectVpcPeeringConnection: API.OperationMethod<
  RejectVpcPeeringConnectionRequest,
  RejectVpcPeeringConnectionResult,
  RejectVpcPeeringConnectionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RejectVpcPeeringConnectionRequest,
  output: RejectVpcPeeringConnectionResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcPeeringConnectionIDNotFound,
    InvalidVpcPeeringConnectionIdNotFound,
    MissingParameter,
  ],
}));
export type ReleaseAddressError =
  | RequestLimitExceeded
  | AuthFailure
  | DryRunOperation
  | InvalidAddressNotFound
  | InvalidAllocationIDNotFound
  | InvalidIPAddressInUse
  | InvalidParameterCombination
  | InvalidParameterValue
  | MissingParameter
  | CommonErrors;
/**
 * Releases the specified Elastic IP address.
 *
 * [Default VPC] Releasing an Elastic IP address automatically disassociates it
 * from any instance that it's associated with. Alternatively, you can disassociate an Elastic IP address without
 * releasing it.
 *
 * [Nondefault VPC] You must disassociate the Elastic IP address
 * before you can release it. Otherwise, Amazon EC2 returns an error (`InvalidIPAddress.InUse`).
 *
 * After releasing an Elastic IP address, it is released to the IP address pool.
 * Be sure to update your DNS records and any servers or devices that communicate with the address.
 * If you attempt to release an Elastic IP address that you already released, you'll get an
 * `AuthFailure` error if the address is already allocated to another Amazon Web Services account.
 *
 * After you release an Elastic IP address, you might be able to recover it.
 * For more information, see Release an Elastic IP address.
 */
export const releaseAddress: API.OperationMethod<
  ReleaseAddressRequest,
  ReleaseAddressResponse,
  ReleaseAddressError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ReleaseAddressRequest,
  output: ReleaseAddressResponse,
  errors: [
    RequestLimitExceeded,
    AuthFailure,
    DryRunOperation,
    InvalidAddressNotFound,
    InvalidAllocationIDNotFound,
    InvalidIPAddressInUse,
    InvalidParameterCombination,
    InvalidParameterValue,
    MissingParameter,
  ],
}));
export type ReleaseHostsError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * When you no longer want to use an On-Demand Dedicated Host it can be released.
 * On-Demand billing is stopped and the host goes into `released` state. The
 * host ID of Dedicated Hosts that have been released can no longer be specified in another
 * request, for example, to modify the host. You must stop or terminate all instances on a
 * host before it can be released.
 *
 * When Dedicated Hosts are released, it may take some time for them to stop counting
 * toward your limit and you may receive capacity errors when trying to allocate new
 * Dedicated Hosts. Wait a few minutes and then try again.
 *
 * Released hosts still appear in a DescribeHosts response.
 */
export const releaseHosts: API.OperationMethod<
  ReleaseHostsRequest,
  ReleaseHostsResult,
  ReleaseHostsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ReleaseHostsRequest,
  output: ReleaseHostsResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type ReleaseIpamPoolAllocationError =
  | RequestLimitExceeded
  | InvalidIpamPoolIdNotFound
  | CommonErrors;
/**
 * Release an allocation within an IPAM pool. The Region you use should be the IPAM pool locale. The locale is the Amazon Web Services Region where this IPAM pool is available for allocations. You can only use this action to release manual allocations. To remove an allocation for a resource without deleting the resource, set its monitored state to false using ModifyIpamResourceCidr. For more information, see Release an allocation in the *Amazon VPC IPAM User Guide*.
 *
 * All EC2 API actions follow an eventual consistency model.
 */
export const releaseIpamPoolAllocation: API.OperationMethod<
  ReleaseIpamPoolAllocationRequest,
  ReleaseIpamPoolAllocationResult,
  ReleaseIpamPoolAllocationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ReleaseIpamPoolAllocationRequest,
  output: ReleaseIpamPoolAllocationResult,
  errors: [RequestLimitExceeded, InvalidIpamPoolIdNotFound],
}));
export type ReplaceIamInstanceProfileAssociationError = CommonErrors;
/**
 * Replaces an IAM instance profile for the specified running instance. You can use
 * this action to change the IAM instance profile that's associated with an instance
 * without having to disassociate the existing IAM instance profile first.
 *
 * Use DescribeIamInstanceProfileAssociations to get the association
 * ID.
 */
export const replaceIamInstanceProfileAssociation: API.OperationMethod<
  ReplaceIamInstanceProfileAssociationRequest,
  ReplaceIamInstanceProfileAssociationResult,
  ReplaceIamInstanceProfileAssociationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ReplaceIamInstanceProfileAssociationRequest,
  output: ReplaceIamInstanceProfileAssociationResult,
  errors: [],
}));
export type ReplaceImageCriteriaInAllowedImagesSettingsError = CommonErrors;
/**
 * Sets or replaces the criteria for Allowed AMIs.
 *
 * The Allowed AMIs feature does not restrict the AMIs owned by your account. Regardless of
 * the criteria you set, the AMIs created by your account will always be discoverable and
 * usable by users in your account.
 *
 * For more information, see Control the discovery and use of AMIs in
 * Amazon EC2 with Allowed AMIs in
 * *Amazon EC2 User Guide*.
 */
export const replaceImageCriteriaInAllowedImagesSettings: API.OperationMethod<
  ReplaceImageCriteriaInAllowedImagesSettingsRequest,
  ReplaceImageCriteriaInAllowedImagesSettingsResult,
  ReplaceImageCriteriaInAllowedImagesSettingsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ReplaceImageCriteriaInAllowedImagesSettingsRequest,
  output: ReplaceImageCriteriaInAllowedImagesSettingsResult,
  errors: [],
}));
export type ReplaceNetworkAclAssociationError =
  | RequestLimitExceeded
  | DryRunOperation
  | InvalidAssociationIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Changes which network ACL a subnet is associated with. By default when you create a
 * subnet, it's automatically associated with the default network ACL. For more
 * information, see Network ACLs in the *Amazon VPC User Guide*.
 *
 * This is an idempotent operation.
 */
export const replaceNetworkAclAssociation: API.OperationMethod<
  ReplaceNetworkAclAssociationRequest,
  ReplaceNetworkAclAssociationResult,
  ReplaceNetworkAclAssociationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ReplaceNetworkAclAssociationRequest,
  output: ReplaceNetworkAclAssociationResult,
  errors: [
    RequestLimitExceeded,
    DryRunOperation,
    InvalidAssociationIDNotFound,
    MissingParameter,
  ],
}));
export type ReplaceNetworkAclEntryError =
  | RequestLimitExceeded
  | InvalidNetworkAclIDNotFound
  | InvalidNetworkAclIdMalformed
  | CommonErrors;
/**
 * Replaces an entry (rule) in a network ACL. For more information, see Network ACLs in the
 * *Amazon VPC User Guide*.
 */
export const replaceNetworkAclEntry: API.OperationMethod<
  ReplaceNetworkAclEntryRequest,
  ReplaceNetworkAclEntryResponse,
  ReplaceNetworkAclEntryError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ReplaceNetworkAclEntryRequest,
  output: ReplaceNetworkAclEntryResponse,
  errors: [
    RequestLimitExceeded,
    InvalidNetworkAclIDNotFound,
    InvalidNetworkAclIdMalformed,
  ],
}));
export type ReplaceRouteError =
  | RequestLimitExceeded
  | InvalidRouteTableIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Replaces an existing route within a route table in a VPC.
 *
 * You must specify either a destination CIDR block or a prefix list ID. You must also specify
 * exactly one of the resources from the parameter list, or reset the local route to its default
 * target.
 *
 * For more information, see Route tables in the
 * *Amazon VPC User Guide*.
 */
export const replaceRoute: API.OperationMethod<
  ReplaceRouteRequest,
  ReplaceRouteResponse,
  ReplaceRouteError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ReplaceRouteRequest,
  output: ReplaceRouteResponse,
  errors: [RequestLimitExceeded, InvalidRouteTableIDNotFound, MissingParameter],
}));
export type ReplaceRouteTableAssociationError =
  | RequestLimitExceeded
  | InvalidRouteTableAssociationIdMalformed
  | InvalidRouteTableIDNotFound
  | CommonErrors;
/**
 * Changes the route table associated with a given subnet, internet gateway, or virtual private gateway in a VPC. After the operation
 * completes, the subnet or gateway uses the routes in the new route table. For more
 * information about route tables, see Route
 * tables in the *Amazon VPC User Guide*.
 *
 * You can also use this operation to change which table is the main route table in the VPC. Specify the main route table's association ID and the route table ID of the new main route table.
 */
export const replaceRouteTableAssociation: API.OperationMethod<
  ReplaceRouteTableAssociationRequest,
  ReplaceRouteTableAssociationResult,
  ReplaceRouteTableAssociationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ReplaceRouteTableAssociationRequest,
  output: ReplaceRouteTableAssociationResult,
  errors: [
    RequestLimitExceeded,
    InvalidRouteTableAssociationIdMalformed,
    InvalidRouteTableIDNotFound,
  ],
}));
export type ReplaceTransitGatewayRouteError =
  | RequestLimitExceeded
  | InvalidRouteTableIDNotFound
  | CommonErrors;
/**
 * Replaces the specified route in the specified transit gateway route table.
 */
export const replaceTransitGatewayRoute: API.OperationMethod<
  ReplaceTransitGatewayRouteRequest,
  ReplaceTransitGatewayRouteResult,
  ReplaceTransitGatewayRouteError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ReplaceTransitGatewayRouteRequest,
  output: ReplaceTransitGatewayRouteResult,
  errors: [RequestLimitExceeded, InvalidRouteTableIDNotFound],
}));
export type ReplaceVpnTunnelError =
  | RequestLimitExceeded
  | InvalidVpnConnectionId
  | CommonErrors;
/**
 * Trigger replacement of specified VPN tunnel.
 */
export const replaceVpnTunnel: API.OperationMethod<
  ReplaceVpnTunnelRequest,
  ReplaceVpnTunnelResult,
  ReplaceVpnTunnelError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ReplaceVpnTunnelRequest,
  output: ReplaceVpnTunnelResult,
  errors: [RequestLimitExceeded, InvalidVpnConnectionId],
}));
export type ReportInstanceStatusError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Submits feedback about the status of an instance. The instance must be in the
 * `running` state. If your experience with the instance differs from the
 * instance status returned by DescribeInstanceStatus, use ReportInstanceStatus to report your experience with the instance. Amazon
 * EC2 collects this information to improve the accuracy of status checks.
 *
 * Use of this action does not change the value returned by DescribeInstanceStatus.
 */
export const reportInstanceStatus: API.OperationMethod<
  ReportInstanceStatusRequest,
  ReportInstanceStatusResponse,
  ReportInstanceStatusError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ReportInstanceStatusRequest,
  output: ReportInstanceStatusResponse,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type RequestSpotFleetError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates a Spot Fleet request.
 *
 * The Spot Fleet request specifies the total target capacity and the On-Demand target
 * capacity. Amazon EC2 calculates the difference between the total capacity and On-Demand
 * capacity, and launches the difference as Spot capacity.
 *
 * You can submit a single request that includes multiple launch specifications that vary
 * by instance type, AMI, Availability Zone, or subnet.
 *
 * By default, the Spot Fleet requests Spot Instances in the Spot Instance pool where the
 * price per unit is the lowest. Each launch specification can include its own instance
 * weighting that reflects the value of the instance type to your application
 * workload.
 *
 * Alternatively, you can specify that the Spot Fleet distribute the target capacity
 * across the Spot pools included in its launch specifications. By ensuring that the Spot
 * Instances in your Spot Fleet are in different Spot pools, you can improve the
 * availability of your fleet.
 *
 * You can specify tags for the Spot Fleet request and instances launched by the fleet.
 * You cannot tag other resource types in a Spot Fleet request because only the
 * `spot-fleet-request` and `instance` resource types are
 * supported.
 *
 * For more information, see Spot Fleet requests
 * in the *Amazon EC2 User Guide*.
 *
 * We strongly discourage using the RequestSpotFleet API because it is a legacy
 * API with no planned investment. For options for requesting Spot Instances, see
 * Which
 * is the best Spot request method to use? in the
 * *Amazon EC2 User Guide*.
 */
export const requestSpotFleet: API.OperationMethod<
  RequestSpotFleetRequest,
  RequestSpotFleetResponse,
  RequestSpotFleetError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RequestSpotFleetRequest,
  output: RequestSpotFleetResponse,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type RequestSpotInstancesError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Creates a Spot Instance request.
 *
 * For more information, see Work with Spot Instance in
 * the *Amazon EC2 User Guide*.
 *
 * We strongly discourage using the RequestSpotInstances API because it is a legacy
 * API with no planned investment. For options for requesting Spot Instances, see
 * Which
 * is the best Spot request method to use? in the
 * *Amazon EC2 User Guide*.
 */
export const requestSpotInstances: API.OperationMethod<
  RequestSpotInstancesRequest,
  RequestSpotInstancesResult,
  RequestSpotInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RequestSpotInstancesRequest,
  output: RequestSpotInstancesResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type ResetAddressAttributeError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Resets the attribute of the specified IP address. For requirements, see Using reverse DNS for email applications.
 */
export const resetAddressAttribute: API.OperationMethod<
  ResetAddressAttributeRequest,
  ResetAddressAttributeResult,
  ResetAddressAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ResetAddressAttributeRequest,
  output: ResetAddressAttributeResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type ResetEbsDefaultKmsKeyIdError = CommonErrors;
/**
 * Resets the default KMS key for EBS encryption for your account in this Region
 * to the Amazon Web Services managed KMS key for EBS.
 *
 * After resetting the default KMS key to the Amazon Web Services managed KMS key, you can continue to encrypt by a
 * customer managed KMS key by specifying it when you create the volume. For more information, see
 * Amazon EBS encryption
 * in the *Amazon EBS User Guide*.
 */
export const resetEbsDefaultKmsKeyId: API.OperationMethod<
  ResetEbsDefaultKmsKeyIdRequest,
  ResetEbsDefaultKmsKeyIdResult,
  ResetEbsDefaultKmsKeyIdError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ResetEbsDefaultKmsKeyIdRequest,
  output: ResetEbsDefaultKmsKeyIdResult,
  errors: [],
}));
export type ResetFpgaImageAttributeError =
  | RequestLimitExceeded
  | InvalidFpgaImageIDMalformed
  | CommonErrors;
/**
 * Resets the specified attribute of the specified Amazon FPGA Image (AFI) to its default value.
 * You can only reset the load permission attribute.
 */
export const resetFpgaImageAttribute: API.OperationMethod<
  ResetFpgaImageAttributeRequest,
  ResetFpgaImageAttributeResult,
  ResetFpgaImageAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ResetFpgaImageAttributeRequest,
  output: ResetFpgaImageAttributeResult,
  errors: [RequestLimitExceeded, InvalidFpgaImageIDMalformed],
}));
export type ResetImageAttributeError =
  | RequestLimitExceeded
  | InvalidAMIIDMalformed
  | InvalidAMIIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Resets an attribute of an AMI to its default value.
 */
export const resetImageAttribute: API.OperationMethod<
  ResetImageAttributeRequest,
  ResetImageAttributeResponse,
  ResetImageAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ResetImageAttributeRequest,
  output: ResetImageAttributeResponse,
  errors: [
    RequestLimitExceeded,
    InvalidAMIIDMalformed,
    InvalidAMIIDNotFound,
    MissingParameter,
  ],
}));
export type ResetInstanceAttributeError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | CommonErrors;
/**
 * Resets an attribute of an instance to its default value. To reset the
 * `kernel` or `ramdisk`, the instance must be in a stopped
 * state. To reset the `sourceDestCheck`, the instance can be either running or
 * stopped.
 *
 * The `sourceDestCheck` attribute controls whether source/destination
 * checking is enabled. The default value is `true`, which means checking is
 * enabled. This value must be `false` for a NAT instance to perform NAT. For
 * more information, see NAT instances in the
 * *Amazon VPC User Guide*.
 */
export const resetInstanceAttribute: API.OperationMethod<
  ResetInstanceAttributeRequest,
  ResetInstanceAttributeResponse,
  ResetInstanceAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ResetInstanceAttributeRequest,
  output: ResetInstanceAttributeResponse,
  errors: [RequestLimitExceeded, InvalidParameterValue],
}));
export type ResetNetworkInterfaceAttributeError =
  | RequestLimitExceeded
  | InvalidParameterCombination
  | CommonErrors;
/**
 * Resets a network interface attribute. You can specify only one attribute at a
 * time.
 */
export const resetNetworkInterfaceAttribute: API.OperationMethod<
  ResetNetworkInterfaceAttributeRequest,
  ResetNetworkInterfaceAttributeResponse,
  ResetNetworkInterfaceAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ResetNetworkInterfaceAttributeRequest,
  output: ResetNetworkInterfaceAttributeResponse,
  errors: [RequestLimitExceeded, InvalidParameterCombination],
}));
export type ResetSnapshotAttributeError =
  | RequestLimitExceeded
  | InvalidSnapshotNotFound
  | InvalidSnapshotIDMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Resets permission settings for the specified snapshot.
 *
 * For more information about modifying snapshot permissions, see Share a snapshot in the
 * *Amazon EBS User Guide*.
 */
export const resetSnapshotAttribute: API.OperationMethod<
  ResetSnapshotAttributeRequest,
  ResetSnapshotAttributeResponse,
  ResetSnapshotAttributeError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ResetSnapshotAttributeRequest,
  output: ResetSnapshotAttributeResponse,
  errors: [
    RequestLimitExceeded,
    InvalidSnapshotNotFound,
    InvalidSnapshotIDMalformed,
    MissingParameter,
  ],
}));
export type RestoreAddressToClassicError =
  | RequestLimitExceeded
  | UnsupportedOperation
  | CommonErrors;
/**
 * This action is deprecated.
 *
 * Restores an Elastic IP address that was previously moved to the EC2-VPC platform back to the EC2-Classic platform. You cannot move an Elastic IP address that was originally allocated for use in EC2-VPC. The Elastic IP address must not be associated with an instance or network interface.
 */
export const restoreAddressToClassic: API.OperationMethod<
  RestoreAddressToClassicRequest,
  RestoreAddressToClassicResult,
  RestoreAddressToClassicError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RestoreAddressToClassicRequest,
  output: RestoreAddressToClassicResult,
  errors: [RequestLimitExceeded, UnsupportedOperation],
}));
export type RestoreImageFromRecycleBinError =
  | RequestLimitExceeded
  | InvalidAMIIDMalformed
  | CommonErrors;
/**
 * Restores an AMI from the Recycle Bin. For more information, see Recover deleted Amazon EBS
 * snapshots and EBS-back AMIs with Recycle Bin in the
 * *Amazon EC2 User Guide*.
 */
export const restoreImageFromRecycleBin: API.OperationMethod<
  RestoreImageFromRecycleBinRequest,
  RestoreImageFromRecycleBinResult,
  RestoreImageFromRecycleBinError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RestoreImageFromRecycleBinRequest,
  output: RestoreImageFromRecycleBinResult,
  errors: [RequestLimitExceeded, InvalidAMIIDMalformed],
}));
export type RestoreManagedPrefixListVersionError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Restores the entries from a previous version of a managed prefix list to a new version of the prefix list.
 */
export const restoreManagedPrefixListVersion: API.OperationMethod<
  RestoreManagedPrefixListVersionRequest,
  RestoreManagedPrefixListVersionResult,
  RestoreManagedPrefixListVersionError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RestoreManagedPrefixListVersionRequest,
  output: RestoreManagedPrefixListVersionResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type RestoreSnapshotFromRecycleBinError =
  | RequestLimitExceeded
  | InvalidSnapshotIDMalformed
  | CommonErrors;
/**
 * Restores a snapshot from the Recycle Bin. For more information, see Restore
 * snapshots from the Recycle Bin in the *Amazon EBS User Guide*.
 */
export const restoreSnapshotFromRecycleBin: API.OperationMethod<
  RestoreSnapshotFromRecycleBinRequest,
  RestoreSnapshotFromRecycleBinResult,
  RestoreSnapshotFromRecycleBinError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RestoreSnapshotFromRecycleBinRequest,
  output: RestoreSnapshotFromRecycleBinResult,
  errors: [RequestLimitExceeded, InvalidSnapshotIDMalformed],
}));
export type RestoreSnapshotTierError =
  | RequestLimitExceeded
  | InvalidSnapshotIDMalformed
  | CommonErrors;
/**
 * Restores an archived Amazon EBS snapshot for use temporarily or permanently, or modifies the restore
 * period or restore type for a snapshot that was previously temporarily restored.
 *
 * For more information see
 * Restore an archived snapshot and
 * modify the restore period or restore type for a temporarily restored snapshot in the *Amazon EBS User Guide*.
 */
export const restoreSnapshotTier: API.OperationMethod<
  RestoreSnapshotTierRequest,
  RestoreSnapshotTierResult,
  RestoreSnapshotTierError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RestoreSnapshotTierRequest,
  output: RestoreSnapshotTierResult,
  errors: [RequestLimitExceeded, InvalidSnapshotIDMalformed],
}));
export type RestoreVolumeFromRecycleBinError =
  | RequestLimitExceeded
  | InvalidVolumeIDMalformed
  | CommonErrors;
/**
 * Restores a volume from the Recycle Bin. For more information, see Restore
 * volumes from the Recycle Bin in the *Amazon EBS User Guide*.
 */
export const restoreVolumeFromRecycleBin: API.OperationMethod<
  RestoreVolumeFromRecycleBinRequest,
  RestoreVolumeFromRecycleBinResult,
  RestoreVolumeFromRecycleBinError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RestoreVolumeFromRecycleBinRequest,
  output: RestoreVolumeFromRecycleBinResult,
  errors: [RequestLimitExceeded, InvalidVolumeIDMalformed],
}));
export type RevokeClientVpnIngressError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Removes an ingress authorization rule from a Client VPN endpoint.
 */
export const revokeClientVpnIngress: API.OperationMethod<
  RevokeClientVpnIngressRequest,
  RevokeClientVpnIngressResult,
  RevokeClientVpnIngressError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RevokeClientVpnIngressRequest,
  output: RevokeClientVpnIngressResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type RevokeSecurityGroupEgressError =
  | RequestLimitExceeded
  | InvalidGroupNotFound
  | InvalidGroupIdMalformed
  | InvalidParameterValue
  | InvalidPrefixListIDNotFound
  | InvalidPermissionNotFound
  | InvalidSecurityGroupRuleIdMalformed
  | MissingParameter
  | UnknownParameter
  | CommonErrors;
/**
 * Removes the specified outbound (egress) rules from the specified security group.
 *
 * You can specify rules using either rule IDs or security group rule properties. If you use
 * rule properties, the values that you specify (for example, ports) must match the existing rule's
 * values exactly. Each rule has a protocol, from and to ports, and destination (CIDR range,
 * security group, or prefix list). For the TCP and UDP protocols, you must also specify the
 * destination port or range of ports. For the ICMP protocol, you must also specify the ICMP type
 * and code. If the security group rule has a description, you do not need to specify the description
 * to revoke the rule.
 *
 * For a default VPC, if the values you specify do not match the existing rule's values, no error is
 * returned, and the output describes the security group rules that were not revoked.
 *
 * Amazon Web Services recommends that you describe the security group to verify that the rules were removed.
 *
 * Rule changes are propagated to instances within the security group as quickly as possible. However,
 * a small delay might occur.
 */
export const revokeSecurityGroupEgress: API.OperationMethod<
  RevokeSecurityGroupEgressRequest,
  RevokeSecurityGroupEgressResult,
  RevokeSecurityGroupEgressError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RevokeSecurityGroupEgressRequest,
  output: RevokeSecurityGroupEgressResult,
  errors: [
    RequestLimitExceeded,
    InvalidGroupNotFound,
    InvalidGroupIdMalformed,
    InvalidParameterValue,
    InvalidPrefixListIDNotFound,
    InvalidPermissionNotFound,
    InvalidSecurityGroupRuleIdMalformed,
    MissingParameter,
    UnknownParameter,
  ],
}));
export type RevokeSecurityGroupIngressError =
  | RequestLimitExceeded
  | InvalidGroupNotFound
  | InvalidGroupIdMalformed
  | InvalidPermissionNotFound
  | MissingParameter
  | ParseError
  | CommonErrors;
/**
 * Removes the specified inbound (ingress) rules from a security group.
 *
 * You can specify rules using either rule IDs or security group rule properties. If you use
 * rule properties, the values that you specify (for example, ports) must match the existing rule's
 * values exactly. Each rule has a protocol, from and to ports, and source (CIDR range,
 * security group, or prefix list). For the TCP and UDP protocols, you must also specify the
 * destination port or range of ports. For the ICMP protocol, you must also specify the ICMP type
 * and code. If the security group rule has a description, you do not need to specify the description
 * to revoke the rule.
 *
 * For a default VPC, if the values you specify do not match the existing rule's values,
 * no error is returned, and the output describes the security group rules that were not
 * revoked.
 *
 * For a non-default VPC, if the values you specify do not match the existing rule's
 * values, an `InvalidPermission.NotFound` client error is returned, and no
 * rules are revoked.
 *
 * Amazon Web Services recommends that you describe the security group to verify that the rules were removed.
 *
 * Rule changes are propagated to instances within the security group as quickly as possible.
 * However, a small delay might occur.
 */
export const revokeSecurityGroupIngress: API.OperationMethod<
  RevokeSecurityGroupIngressRequest,
  RevokeSecurityGroupIngressResult,
  RevokeSecurityGroupIngressError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RevokeSecurityGroupIngressRequest,
  output: RevokeSecurityGroupIngressResult,
  errors: [
    RequestLimitExceeded,
    InvalidGroupNotFound,
    InvalidGroupIdMalformed,
    InvalidPermissionNotFound,
    MissingParameter,
    ParseError,
  ],
}));
export type RunInstancesError =
  | RequestLimitExceeded
  | InvalidAMIIDMalformed
  | InvalidAMIIDNotFound
  | MissingParameter
  | ParseError
  | CommonErrors;
/**
 * Launches the specified number of instances using an AMI for which you have
 * permissions.
 *
 * You can specify a number of options, or leave the default options. The following rules
 * apply:
 *
 * - If you don't specify a subnet ID, we choose a default subnet from
 * your default VPC for you. If you don't have a default VPC, you must specify a
 * subnet ID in the request.
 *
 * - All instances have a network interface with a primary private IPv4
 * address. If you don't specify this address, we choose one from the IPv4 range of
 * your subnet.
 *
 * - Not all instance types support IPv6 addresses. For more information, see
 * Instance
 * types.
 *
 * - If you don't specify a security group ID, we use the default security group
 * for the VPC. For more information, see Security
 * groups.
 *
 * - If any of the AMIs have a product code attached for which the user has not
 * subscribed, the request fails.
 *
 * You can create a launch template,
 * which is a resource that contains the parameters to launch an instance. When you launch
 * an instance using RunInstances, you can specify the launch template
 * instead of specifying the launch parameters.
 *
 * To ensure faster instance launches, break up large requests into smaller batches. For
 * example, create five separate launch requests for 100 instances each instead of one
 * launch request for 500 instances.
 *
 * `RunInstances` is subject to both request rate limiting and resource rate
 * limiting. For more information, see Request throttling.
 *
 * An instance is ready for you to use when it's in the `running` state. You
 * can check the state of your instance using DescribeInstances. You can
 * tag instances and EBS volumes during launch, after launch, or both. For more
 * information, see CreateTags and Tagging your Amazon EC2
 * resources.
 *
 * Linux instances have access to the public key of the key pair at boot. You can use
 * this key to provide secure access to the instance. Amazon EC2 public images use this
 * feature to provide secure access without passwords. For more information, see Key
 * pairs.
 *
 * For troubleshooting, see What to do if
 * an instance immediately terminates, and Troubleshooting connecting to your instance.
 */
export const runInstances: API.OperationMethod<
  RunInstancesRequest,
  Reservation,
  RunInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RunInstancesRequest,
  output: Reservation,
  errors: [
    RequestLimitExceeded,
    InvalidAMIIDMalformed,
    InvalidAMIIDNotFound,
    MissingParameter,
    ParseError,
  ],
}));
export type RunScheduledInstancesError =
  | RequestLimitExceeded
  | InvalidScheduledInstance
  | CommonErrors;
/**
 * Launches the specified Scheduled Instances.
 *
 * Before you can launch a Scheduled Instance, you must purchase it and obtain an identifier using PurchaseScheduledInstances.
 *
 * You must launch a Scheduled Instance during its scheduled time period. You can't stop or
 * reboot a Scheduled Instance, but you can terminate it as needed. If you terminate a
 * Scheduled Instance before the current scheduled time period ends, you can launch it again
 * after a few minutes.
 */
export const runScheduledInstances: API.OperationMethod<
  RunScheduledInstancesRequest,
  RunScheduledInstancesResult,
  RunScheduledInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RunScheduledInstancesRequest,
  output: RunScheduledInstancesResult,
  errors: [RequestLimitExceeded, InvalidScheduledInstance],
}));
export type SearchLocalGatewayRoutesError =
  | RequestLimitExceeded
  | InvalidLocalGatewayRouteTableIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Searches for routes in the specified local gateway route table.
 */
export const searchLocalGatewayRoutes: API.OperationMethod<
  SearchLocalGatewayRoutesRequest,
  SearchLocalGatewayRoutesResult,
  SearchLocalGatewayRoutesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: SearchLocalGatewayRoutesRequest,
  ) => stream.Stream<
    SearchLocalGatewayRoutesResult,
    SearchLocalGatewayRoutesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: SearchLocalGatewayRoutesRequest,
  ) => stream.Stream<
    LocalGatewayRoute,
    SearchLocalGatewayRoutesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchLocalGatewayRoutesRequest,
  output: SearchLocalGatewayRoutesResult,
  errors: [
    RequestLimitExceeded,
    InvalidLocalGatewayRouteTableIDNotFound,
    MissingParameter,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Routes",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchTransitGatewayMulticastGroupsError =
  | RequestLimitExceeded
  | InvalidTransitGatewayMulticastDomainIdMalformed
  | InvalidTransitGatewayMulticastDomainIdNotFound
  | CommonErrors;
/**
 * Searches one or more transit gateway multicast groups and returns the group membership information.
 */
export const searchTransitGatewayMulticastGroups: API.OperationMethod<
  SearchTransitGatewayMulticastGroupsRequest,
  SearchTransitGatewayMulticastGroupsResult,
  SearchTransitGatewayMulticastGroupsError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: SearchTransitGatewayMulticastGroupsRequest,
  ) => stream.Stream<
    SearchTransitGatewayMulticastGroupsResult,
    SearchTransitGatewayMulticastGroupsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: SearchTransitGatewayMulticastGroupsRequest,
  ) => stream.Stream<
    TransitGatewayMulticastGroup,
    SearchTransitGatewayMulticastGroupsError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchTransitGatewayMulticastGroupsRequest,
  output: SearchTransitGatewayMulticastGroupsResult,
  errors: [
    RequestLimitExceeded,
    InvalidTransitGatewayMulticastDomainIdMalformed,
    InvalidTransitGatewayMulticastDomainIdNotFound,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "MulticastGroups",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchTransitGatewayRoutesError =
  | RequestLimitExceeded
  | InvalidRouteTableIDNotFound
  | MissingParameter
  | CommonErrors;
/**
 * Searches for routes in the specified transit gateway route table.
 */
export const searchTransitGatewayRoutes: API.OperationMethod<
  SearchTransitGatewayRoutesRequest,
  SearchTransitGatewayRoutesResult,
  SearchTransitGatewayRoutesError,
  Credentials | Rgn | HttpClient.HttpClient
> & {
  pages: (
    input: SearchTransitGatewayRoutesRequest,
  ) => stream.Stream<
    SearchTransitGatewayRoutesResult,
    SearchTransitGatewayRoutesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
  items: (
    input: SearchTransitGatewayRoutesRequest,
  ) => stream.Stream<
    TransitGatewayRoute,
    SearchTransitGatewayRoutesError,
    Credentials | Rgn | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchTransitGatewayRoutesRequest,
  output: SearchTransitGatewayRoutesResult,
  errors: [RequestLimitExceeded, InvalidRouteTableIDNotFound, MissingParameter],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Routes",
    pageSize: "MaxResults",
  } as const,
}));
export type SendDiagnosticInterruptError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | CommonErrors;
/**
 * Sends a diagnostic interrupt to the specified Amazon EC2 instance to trigger a
 * *kernel panic* (on Linux instances), or a blue
 * screen/*stop error* (on Windows instances). For
 * instances based on Intel and AMD processors, the interrupt is received as a
 * *non-maskable interrupt* (NMI).
 *
 * In general, the operating system crashes and reboots when a kernel panic or stop error
 * is triggered. The operating system can also be configured to perform diagnostic tasks,
 * such as generating a memory dump file, loading a secondary kernel, or obtaining a call
 * trace.
 *
 * Before sending a diagnostic interrupt to your instance, ensure that its operating
 * system is configured to perform the required diagnostic tasks.
 *
 * For more information about configuring your operating system to generate a crash dump
 * when a kernel panic or stop error occurs, see Send a diagnostic interrupt
 * (for advanced users) in the *Amazon EC2 User Guide*.
 */
export const sendDiagnosticInterrupt: API.OperationMethod<
  SendDiagnosticInterruptRequest,
  SendDiagnosticInterruptResponse,
  SendDiagnosticInterruptError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SendDiagnosticInterruptRequest,
  output: SendDiagnosticInterruptResponse,
  errors: [RequestLimitExceeded, InvalidInstanceIDMalformed],
}));
export type StartDeclarativePoliciesReportError =
  | RequestLimitExceeded
  | DeclarativePoliciesAccessDenied
  | CommonErrors;
/**
 * Generates an account status report. The report is generated asynchronously, and can
 * take several hours to complete.
 *
 * The report provides the current status of all attributes supported by declarative
 * policies for the accounts within the specified scope. The scope is determined by the
 * specified `TargetId`, which can represent an individual account, or all the
 * accounts that fall under the specified organizational unit (OU) or root (the entire
 * Amazon Web Services Organization).
 *
 * The report is saved to your specified S3 bucket, using the following path structure
 * (with the capitalized placeholders representing your specific values):
 *
 * `s3://AMZN-S3-DEMO-BUCKET/YOUR-OPTIONAL-S3-PREFIX/ec2_TARGETID_REPORTID_YYYYMMDDTHHMMZ.csv`
 *
 * **Prerequisites for generating a report**
 *
 * - The `StartDeclarativePoliciesReport` API can only be called by the
 * management account or delegated administrators for the organization.
 *
 * - An S3 bucket must be available before generating the report (you can create a
 * new one or use an existing one), it must be in the same Region where the report
 * generation request is made, and it must have an appropriate bucket policy. For a
 * sample S3 policy, see *Sample Amazon S3 policy* under Examples.
 *
 * - Trusted access must be enabled for the service for which the declarative
 * policy will enforce a baseline configuration. If you use the Amazon Web Services Organizations
 * console, this is done automatically when you enable declarative policies. The
 * API uses the following service principal to identify the EC2 service:
 * `ec2.amazonaws.com`. For more information on how to enable
 * trusted access with the Amazon Web Services CLI and Amazon Web Services SDKs, see Using
 * Organizations with other Amazon Web Services services in the
 * *Amazon Web Services Organizations User Guide*.
 *
 * - Only one report per organization can be generated at a time. Attempting to
 * generate a report while another is in progress will result in an error.
 *
 * For more information, including the required IAM permissions to run this API, see
 * Generating the account status report for declarative policies in the
 * *Amazon Web Services Organizations User Guide*.
 */
export const startDeclarativePoliciesReport: API.OperationMethod<
  StartDeclarativePoliciesReportRequest,
  StartDeclarativePoliciesReportResult,
  StartDeclarativePoliciesReportError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartDeclarativePoliciesReportRequest,
  output: StartDeclarativePoliciesReportResult,
  errors: [RequestLimitExceeded, DeclarativePoliciesAccessDenied],
}));
export type StartInstancesError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | InvalidInstanceIDNotFound
  | InvalidParameterCombination
  | CommonErrors;
/**
 * Starts an Amazon EBS-backed instance that you've previously stopped.
 *
 * Instances that use Amazon EBS volumes as their root devices can be quickly stopped and
 * started. When an instance is stopped, the compute resources are released and you are not
 * billed for instance usage. However, your root partition Amazon EBS volume remains and
 * continues to persist your data, and you are charged for Amazon EBS volume usage. You can
 * restart your instance at any time. Every time you start your instance, Amazon EC2
 * charges a one-minute minimum for instance usage, and thereafter charges per second for
 * instance usage.
 *
 * Before stopping an instance, make sure it is in a state from which it can be
 * restarted. Stopping an instance does not preserve data stored in RAM.
 *
 * Performing this operation on an instance that uses an instance store as its root
 * device returns an error.
 *
 * If you attempt to start a T3 instance with `host` tenancy and the
 * `unlimited` CPU credit option, the request fails. The
 * `unlimited` CPU credit option is not supported on Dedicated Hosts. Before
 * you start the instance, either change its CPU credit option to `standard`, or
 * change its tenancy to `default` or `dedicated`.
 *
 * For more information, see Stop and start Amazon EC2
 * instances in the *Amazon EC2 User Guide*.
 */
export const startInstances: API.OperationMethod<
  StartInstancesRequest,
  StartInstancesResult,
  StartInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartInstancesRequest,
  output: StartInstancesResult,
  errors: [
    RequestLimitExceeded,
    InvalidInstanceIDMalformed,
    InvalidInstanceIDNotFound,
    InvalidParameterCombination,
  ],
}));
export type StartNetworkInsightsAccessScopeAnalysisError =
  | RequestLimitExceeded
  | IdempotentParameterMismatch
  | InvalidParameterValue
  | CommonErrors;
/**
 * Starts analyzing the specified Network Access Scope.
 */
export const startNetworkInsightsAccessScopeAnalysis: API.OperationMethod<
  StartNetworkInsightsAccessScopeAnalysisRequest,
  StartNetworkInsightsAccessScopeAnalysisResult,
  StartNetworkInsightsAccessScopeAnalysisError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartNetworkInsightsAccessScopeAnalysisRequest,
  output: StartNetworkInsightsAccessScopeAnalysisResult,
  errors: [
    RequestLimitExceeded,
    IdempotentParameterMismatch,
    InvalidParameterValue,
  ],
}));
export type StartNetworkInsightsAnalysisError =
  | RequestLimitExceeded
  | InvalidParameterValue
  | MissingParameter
  | CommonErrors;
/**
 * Starts analyzing the specified path. If the path is reachable, the
 * operation returns the shortest feasible path.
 */
export const startNetworkInsightsAnalysis: API.OperationMethod<
  StartNetworkInsightsAnalysisRequest,
  StartNetworkInsightsAnalysisResult,
  StartNetworkInsightsAnalysisError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartNetworkInsightsAnalysisRequest,
  output: StartNetworkInsightsAnalysisResult,
  errors: [RequestLimitExceeded, InvalidParameterValue, MissingParameter],
}));
export type StartVpcEndpointServicePrivateDnsVerificationError =
  | RequestLimitExceeded
  | InvalidVpcEndpointServiceIdMalformed
  | InvalidVpcEndpointServiceIdNotFound
  | CommonErrors;
/**
 * Initiates the verification process to prove that the service provider owns the private
 * DNS name domain for the endpoint service.
 *
 * The service provider must successfully perform the verification before the consumer can use the name to access the service.
 *
 * Before the service provider runs this command, they must add a record to the DNS server.
 */
export const startVpcEndpointServicePrivateDnsVerification: API.OperationMethod<
  StartVpcEndpointServicePrivateDnsVerificationRequest,
  StartVpcEndpointServicePrivateDnsVerificationResult,
  StartVpcEndpointServicePrivateDnsVerificationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartVpcEndpointServicePrivateDnsVerificationRequest,
  output: StartVpcEndpointServicePrivateDnsVerificationResult,
  errors: [
    RequestLimitExceeded,
    InvalidVpcEndpointServiceIdMalformed,
    InvalidVpcEndpointServiceIdNotFound,
  ],
}));
export type StopInstancesError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | InvalidInstanceIDNotFound
  | InvalidParameterCombination
  | CommonErrors;
/**
 * Stops an Amazon EBS-backed instance. You can restart your instance at any time using
 * the StartInstances API. For more information, see Stop and start Amazon EC2
 * instances in the *Amazon EC2 User Guide*.
 *
 * When you stop or hibernate an instance, we shut it down. By default, this includes a
 * graceful operating system (OS) shutdown. To bypass the graceful shutdown, use the
 * `skipOsShutdown` parameter; however, this might risk data
 * integrity.
 *
 * You can use the StopInstances operation together with the `Hibernate`
 * parameter to hibernate an instance if the instance is enabled for
 * hibernation and meets the hibernation
 * prerequisites. Stopping an instance doesn't preserve data stored in RAM,
 * while hibernation does. If hibernation fails, a normal shutdown occurs. For more
 * information, see Hibernate your Amazon EC2
 * instance in the *Amazon EC2 User Guide*.
 *
 * If your instance appears stuck in the `stopping` state, there might be an
 * issue with the underlying host computer. You can use the StopInstances operation
 * together with the Force parameter to force stop your instance. For more information, see
 * Troubleshoot
 * Amazon EC2 instance stop issues in the
 * *Amazon EC2 User Guide*.
 *
 * Stopping and hibernating an instance differs from rebooting or terminating it. For
 * example, a stopped or hibernated instance retains its root volume and any data volumes,
 * unlike terminated instances where these volumes are automatically deleted. For more
 * information about the differences between stopping, hibernating, rebooting, and
 * terminating instances, see Amazon EC2
 * instance state changes in the *Amazon EC2 User Guide*.
 *
 * We don't charge for instance usage or data transfer fees when an instance is stopped.
 * However, the root volume and any data volumes remain and continue to persist your data,
 * and you're charged for volume usage. Every time you start your instance, Amazon EC2 charges a one-minute minimum for instance usage, followed by per-second
 * billing.
 *
 * You can't stop or hibernate instance store-backed instances.
 */
export const stopInstances: API.OperationMethod<
  StopInstancesRequest,
  StopInstancesResult,
  StopInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopInstancesRequest,
  output: StopInstancesResult,
  errors: [
    RequestLimitExceeded,
    InvalidInstanceIDMalformed,
    InvalidInstanceIDNotFound,
    InvalidParameterCombination,
  ],
}));
export type TerminateClientVpnConnectionsError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Terminates active Client VPN endpoint connections. This action can be used to terminate a specific client connection, or up to five connections established by a specific user.
 */
export const terminateClientVpnConnections: API.OperationMethod<
  TerminateClientVpnConnectionsRequest,
  TerminateClientVpnConnectionsResult,
  TerminateClientVpnConnectionsError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: TerminateClientVpnConnectionsRequest,
  output: TerminateClientVpnConnectionsResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type TerminateInstancesError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | InvalidInstanceIDNotFound
  | InvalidParameterCombination
  | CommonErrors;
/**
 * Terminates (deletes) the specified instances. This operation is idempotent; if you
 * terminate an instance more than once, each call succeeds.
 *
 * **Terminating an instance is permanent and irreversible.**
 *
 * After you terminate an instance, you can no longer connect to it, and it can't be recovered.
 * All attached Amazon EBS volumes that are configured to be deleted on termination are also permanently
 * deleted and can't be recovered. All data stored on instance store volumes is permanently lost.
 * For more information, see
 * How instance termination works.
 *
 * Before you terminate an instance, ensure that you have backed up all data that you need to
 * retain after the termination to persistent storage.
 *
 * If you specify multiple instances and the request fails (for example, because of a
 * single incorrect instance ID), none of the instances are terminated.
 *
 * If you terminate multiple instances across multiple Availability Zones, and one or
 * more of the specified instances are enabled for termination protection, the request
 * fails with the following results:
 *
 * - The specified instances that are in the same Availability Zone as the
 * protected instance are not terminated.
 *
 * - The specified instances that are in different Availability Zones, where no
 * other specified instances are protected, are successfully terminated.
 *
 * For example, say you have the following instances:
 *
 * - Instance A: `us-east-1a`; Not protected
 *
 * - Instance B: `us-east-1a`; Not protected
 *
 * - Instance C: `us-east-1b`; Protected
 *
 * - Instance D: `us-east-1b`; not protected
 *
 * If you attempt to terminate all of these instances in the same request, the request
 * reports failure with the following results:
 *
 * - Instance A and Instance B are successfully terminated because none of the
 * specified instances in `us-east-1a` are enabled for termination
 * protection.
 *
 * - Instance C and Instance D fail to terminate because at least one of the
 * specified instances in `us-east-1b` (Instance C) is enabled for
 * termination protection.
 *
 * Terminated instances remain visible after termination (for approximately one
 * hour).
 *
 * By default, Amazon EC2 deletes all EBS volumes that were attached when the instance
 * launched. Volumes attached after instance launch continue running.
 *
 * By default, the TerminateInstances operation includes a graceful operating system (OS)
 * shutdown. To bypass the graceful shutdown, use the `skipOsShutdown`
 * parameter; however, this might risk data integrity.
 *
 * You can stop, start, and terminate EBS-backed instances. You can only terminate
 * instance store-backed instances. What happens to an instance differs if you stop or
 * terminate it. For example, when you stop an instance, the root device and any other
 * devices attached to the instance persist. When you terminate an instance, any attached
 * EBS volumes with the `DeleteOnTermination` block device mapping parameter set
 * to `true` are automatically deleted. For more information about the
 * differences between stopping and terminating instances, see Amazon EC2
 * instance state changes in the *Amazon EC2 User Guide*.
 *
 * When you terminate an instance, we attempt to terminate it forcibly after a short
 * while. If your instance appears stuck in the shutting-down state after a period of time,
 * there might be an issue with the underlying host computer. For more information about
 * terminating and troubleshooting terminating your instances, see Terminate Amazon EC2 instances and
 * Troubleshooting terminating your instance in the
 * *Amazon EC2 User Guide*.
 */
export const terminateInstances: API.OperationMethod<
  TerminateInstancesRequest,
  TerminateInstancesResult,
  TerminateInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: TerminateInstancesRequest,
  output: TerminateInstancesResult,
  errors: [
    RequestLimitExceeded,
    InvalidInstanceIDMalformed,
    InvalidInstanceIDNotFound,
    InvalidParameterCombination,
  ],
}));
export type UnassignIpv6AddressesError =
  | RequestLimitExceeded
  | InvalidNetworkInterfaceIDNotFound
  | InvalidParameterCombination
  | CommonErrors;
/**
 * Unassigns the specified IPv6 addresses or Prefix Delegation prefixes from a network
 * interface.
 */
export const unassignIpv6Addresses: API.OperationMethod<
  UnassignIpv6AddressesRequest,
  UnassignIpv6AddressesResult,
  UnassignIpv6AddressesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UnassignIpv6AddressesRequest,
  output: UnassignIpv6AddressesResult,
  errors: [
    RequestLimitExceeded,
    InvalidNetworkInterfaceIDNotFound,
    InvalidParameterCombination,
  ],
}));
export type UnassignPrivateIpAddressesError =
  | RequestLimitExceeded
  | InvalidNetworkInterfaceIDNotFound
  | InvalidNetworkInterfaceIdMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Unassigns the specified secondary private IP addresses or IPv4 Prefix Delegation
 * prefixes from a network interface.
 */
export const unassignPrivateIpAddresses: API.OperationMethod<
  UnassignPrivateIpAddressesRequest,
  UnassignPrivateIpAddressesResponse,
  UnassignPrivateIpAddressesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UnassignPrivateIpAddressesRequest,
  output: UnassignPrivateIpAddressesResponse,
  errors: [
    RequestLimitExceeded,
    InvalidNetworkInterfaceIDNotFound,
    InvalidNetworkInterfaceIdMalformed,
    MissingParameter,
  ],
}));
export type UnassignPrivateNatGatewayAddressError = CommonErrors;
/**
 * Unassigns secondary private IPv4 addresses from a private NAT gateway. You cannot unassign your primary private IP. For more information,
 * see Edit secondary IP address associations
 * in the *Amazon VPC User Guide*.
 *
 * While unassigning is in progress, you cannot assign/unassign additional IP addresses while the connections are being drained. You are, however, allowed to delete the NAT gateway.
 *
 * A private IP address will only be released at the end of MaxDrainDurationSeconds. The
 * private IP addresses stay associated and support the existing connections, but do not
 * support any new connections (new connections are distributed across the remaining
 * assigned private IP address). After the existing connections drain out, the private IP
 * addresses are released.
 */
export const unassignPrivateNatGatewayAddress: API.OperationMethod<
  UnassignPrivateNatGatewayAddressRequest,
  UnassignPrivateNatGatewayAddressResult,
  UnassignPrivateNatGatewayAddressError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UnassignPrivateNatGatewayAddressRequest,
  output: UnassignPrivateNatGatewayAddressResult,
  errors: [],
}));
export type UnlockSnapshotError =
  | RequestLimitExceeded
  | InvalidSnapshotIDMalformed
  | CommonErrors;
/**
 * Unlocks a snapshot that is locked in governance mode or that is locked in compliance mode
 * but still in the cooling-off period. You can't unlock a snapshot that is locked in compliance
 * mode after the cooling-off period has expired.
 */
export const unlockSnapshot: API.OperationMethod<
  UnlockSnapshotRequest,
  UnlockSnapshotResult,
  UnlockSnapshotError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UnlockSnapshotRequest,
  output: UnlockSnapshotResult,
  errors: [RequestLimitExceeded, InvalidSnapshotIDMalformed],
}));
export type UnmonitorInstancesError =
  | RequestLimitExceeded
  | InvalidInstanceIDMalformed
  | MissingParameter
  | CommonErrors;
/**
 * Disables detailed monitoring for a running instance. For more information, see Monitoring
 * your instances and volumes in the
 * *Amazon EC2 User Guide*.
 */
export const unmonitorInstances: API.OperationMethod<
  UnmonitorInstancesRequest,
  UnmonitorInstancesResult,
  UnmonitorInstancesError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UnmonitorInstancesRequest,
  output: UnmonitorInstancesResult,
  errors: [RequestLimitExceeded, InvalidInstanceIDMalformed, MissingParameter],
}));
export type UpdateCapacityManagerOrganizationsAccessError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Updates the Organizations access setting for EC2 Capacity Manager. This controls whether Capacity Manager can aggregate
 * data from all accounts in your Amazon Web Services Organization or only from the current account.
 */
export const updateCapacityManagerOrganizationsAccess: API.OperationMethod<
  UpdateCapacityManagerOrganizationsAccessRequest,
  UpdateCapacityManagerOrganizationsAccessResult,
  UpdateCapacityManagerOrganizationsAccessError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateCapacityManagerOrganizationsAccessRequest,
  output: UpdateCapacityManagerOrganizationsAccessResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type UpdateInterruptibleCapacityReservationAllocationError =
  | RequestLimitExceeded
  | InvalidCapacityReservationIdNotFound
  | CommonErrors;
/**
 * Modifies the number of instances allocated to an interruptible reservation, allowing you to add more capacity or reclaim capacity to your source Capacity Reservation.
 */
export const updateInterruptibleCapacityReservationAllocation: API.OperationMethod<
  UpdateInterruptibleCapacityReservationAllocationRequest,
  UpdateInterruptibleCapacityReservationAllocationResult,
  UpdateInterruptibleCapacityReservationAllocationError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateInterruptibleCapacityReservationAllocationRequest,
  output: UpdateInterruptibleCapacityReservationAllocationResult,
  errors: [RequestLimitExceeded, InvalidCapacityReservationIdNotFound],
}));
export type UpdateSecurityGroupRuleDescriptionsEgressError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Updates the description of an egress (outbound) security group rule. You
 * can replace an existing description, or add a description to a rule that did not have one
 * previously. You can remove a description for a security group rule by omitting the
 * description parameter in the request.
 */
export const updateSecurityGroupRuleDescriptionsEgress: API.OperationMethod<
  UpdateSecurityGroupRuleDescriptionsEgressRequest,
  UpdateSecurityGroupRuleDescriptionsEgressResult,
  UpdateSecurityGroupRuleDescriptionsEgressError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateSecurityGroupRuleDescriptionsEgressRequest,
  output: UpdateSecurityGroupRuleDescriptionsEgressResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type UpdateSecurityGroupRuleDescriptionsIngressError =
  | RequestLimitExceeded
  | MissingParameter
  | CommonErrors;
/**
 * Updates the description of an ingress (inbound) security group rule. You can replace an
 * existing description, or add a description to a rule that did not have one previously.
 * You can remove a description for a security group rule by omitting the description
 * parameter in the request.
 */
export const updateSecurityGroupRuleDescriptionsIngress: API.OperationMethod<
  UpdateSecurityGroupRuleDescriptionsIngressRequest,
  UpdateSecurityGroupRuleDescriptionsIngressResult,
  UpdateSecurityGroupRuleDescriptionsIngressError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateSecurityGroupRuleDescriptionsIngressRequest,
  output: UpdateSecurityGroupRuleDescriptionsIngressResult,
  errors: [RequestLimitExceeded, MissingParameter],
}));
export type WithdrawByoipCidrError = RequestLimitExceeded | CommonErrors;
/**
 * Stops advertising an address range that is provisioned as an address pool.
 *
 * You can perform this operation at most once every 10 seconds, even if you specify different
 * address ranges each time.
 *
 * It can take a few minutes before traffic to the specified addresses stops routing to Amazon Web Services
 * because of BGP propagation delays.
 */
export const withdrawByoipCidr: API.OperationMethod<
  WithdrawByoipCidrRequest,
  WithdrawByoipCidrResult,
  WithdrawByoipCidrError,
  Credentials | Rgn | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: WithdrawByoipCidrRequest,
  output: WithdrawByoipCidrResult,
  errors: [RequestLimitExceeded],
}));
