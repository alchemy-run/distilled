import * as HttpClient from "effect/unstable/http/HttpClient";
import * as effect from "effect/Effect";
import * as redacted from "effect/Redacted";
import * as S from "effect/Schema";
import * as stream from "effect/Stream";
import * as API from "../client/api.ts";
import * as T from "../traits.ts";
import * as C from "../category.ts";
import type { Credentials } from "../credentials.ts";
import type { CommonErrors } from "../errors.ts";
import type { Region } from "../region.ts";
import { SensitiveString, SensitiveBlob } from "../sensitive.ts";
const ns = T.XmlNamespace("http://sagemaker.amazonaws.com/doc/2017-05-13/");
const svc = T.AwsApiService({
  sdkId: "SageMaker",
  serviceShapeName: "SageMaker",
});
const auth = T.AwsAuthSigv4({ name: "sagemaker" });
const ver = T.ServiceVersion("2017-07-24");
const proto = T.AwsProtocolsAwsJson1_1();
const rules = T.EndpointResolver((p, _) => {
  const { Region, UseDualStack = false, UseFIPS = false, Endpoint } = p;
  const e = (u: unknown, p = {}, h = {}): T.EndpointResolverResult => ({
    type: "endpoint" as const,
    endpoint: { url: u as string, properties: p, headers: h },
  });
  const err = (m: unknown): T.EndpointResolverResult => ({
    type: "error" as const,
    message: m as string,
  });
  if (Endpoint != null) {
    if (UseFIPS === true) {
      return err(
        "Invalid Configuration: FIPS and custom endpoint are not supported",
      );
    }
    if (UseDualStack === true) {
      return err(
        "Invalid Configuration: Dualstack and custom endpoint are not supported",
      );
    }
    return e(Endpoint);
  }
  if (Region != null) {
    {
      const PartitionResult = _.partition(Region);
      if (PartitionResult != null && PartitionResult !== false) {
        if (UseFIPS === true && UseDualStack === true) {
          if (
            true === _.getAttr(PartitionResult, "supportsFIPS") &&
            true === _.getAttr(PartitionResult, "supportsDualStack")
          ) {
            return e(
              `https://api.sagemaker-fips.${Region}.${_.getAttr(PartitionResult, "dualStackDnsSuffix")}`,
            );
          }
          return err(
            "FIPS and DualStack are enabled, but this partition does not support one or both",
          );
        }
        if (UseFIPS === true) {
          if (_.getAttr(PartitionResult, "supportsFIPS") === true) {
            if (_.getAttr(PartitionResult, "name") === "aws") {
              return e(`https://api-fips.sagemaker.${Region}.amazonaws.com`);
            }
            if (_.getAttr(PartitionResult, "name") === "aws-us-gov") {
              return e(`https://api-fips.sagemaker.${Region}.amazonaws.com`);
            }
            return e(
              `https://api.sagemaker-fips.${Region}.${_.getAttr(PartitionResult, "dnsSuffix")}`,
            );
          }
          return err(
            "FIPS is enabled but this partition does not support FIPS",
          );
        }
        if (UseDualStack === true) {
          if (true === _.getAttr(PartitionResult, "supportsDualStack")) {
            return e(
              `https://api.sagemaker.${Region}.${_.getAttr(PartitionResult, "dualStackDnsSuffix")}`,
            );
          }
          return err(
            "DualStack is enabled but this partition does not support DualStack",
          );
        }
        return e(
          `https://api.sagemaker.${Region}.${_.getAttr(PartitionResult, "dnsSuffix")}`,
        );
      }
    }
  }
  return err("Invalid Configuration: Missing Region");
});

//# Newtypes
export type AssociationEntityArn = string;
export type FailureReason = string;
export type ResourceArn = string;
export type TagKey = string;
export type TagValue = string;
export type ExperimentEntityName = string;
export type TrialComponentArn = string;
export type TrialArn = string;
export type ClusterArn = string;
export type ClusterNodeId = string;
export type VolumeId = string;
export type VolumeDeviceName = string;
export type ClusterNameOrArn = string;
export type ClusterInstanceGroupName = string;
export type BatchAddIncrementCount = number;
export type ClusterNodeLogicalId = string;
export type InstanceGroupName = string;
export type BatchAddFailureCount = number;
export type ModelPackageArn = string;
export type EntityName = string;
export type ModelPackageVersion = number;
export type EntityDescription = string;
export type CreationTime = Date;
export type ContainerHostname = string;
export type ContainerImage = string;
export type ImageDigest = string;
export type Url = string;
export type S3ModelUri = string;
export type AcceptEula = boolean;
export type HubContentArn = string;
export type ProductId = string;
export type EnvironmentKey = string;
export type EnvironmentValue = string;
export type DataInputConfig = string;
export type ModelPackageFrameworkVersion = string;
export type S3Uri = string;
export type HubContentName = string;
export type HubContentVersion = string;
export type RecipeName = string;
export type ContentType = string;
export type ResponseMIMEType = string;
export type SourceUri = string;
export type String256 = string;
export type ExperimentDescription = string;
export type StringParameterValue = string;
export type MetadataPropertyValue = string;
export type ActionArn = string;
export type ParameterName = string;
export type ParameterValue = string;
export type HyperParameterValue = string;
export type MetricName = string;
export type MetricRegex = string;
export type ChannelName = string;
export type RoleArn = string;
export type HyperParameterKey = string;
export type AttributeName = string;
export type FileSystemId = string;
export type DirectoryPath = string;
export type HubDataSetArn = string;
export type Seed = number;
export type KmsKeyId = string;
export type TrainingInstanceCount = number;
export type OptionalVolumeSizeInGB = number;
export type KeepAlivePeriodInSeconds = number;
export type TrainingPlanArn = string;
export type MaxRuntimeInSeconds = number;
export type MaxWaitTimeInSeconds = number;
export type MaxPendingTimeInSeconds = number;
export type MaxConcurrentTransforms = number;
export type MaxPayloadInMB = number;
export type TransformEnvironmentKey = string;
export type TransformEnvironmentValue = string;
export type Accept = string;
export type TransformInstanceCount = number;
export type TransformAmiVersion = string;
export type CertifyForMarketplace = boolean;
export type AlgorithmArn = string;
export type DomainId = string;
export type UserProfileName = string;
export type SpaceName = string;
export type AppName = string;
export type ImageArn = string;
export type ImageVersionArn = string;
export type ImageVersionAlias = string;
export type StudioLifecycleConfigArn = string;
export type AppArn = string;
export type AppImageConfigName = string;
export type KernelName = string;
export type KernelDisplayName = string;
export type MountPath = string;
export type DefaultUid = number;
export type DefaultGid = number;
export type NonEmptyString64 = string;
export type NonEmptyString256 = string;
export type AppImageConfigArn = string;
export type ArtifactPropertyValue = string;
export type ArtifactArn = string;
export type AutoMLJobName = string;
export type TargetAttributeName = string;
export type SampleWeightAttributeName = string;
export type MaxCandidates = number;
export type MaxRuntimePerTrainingJobInSeconds = number;
export type MaxAutoMLJobRuntimeInSeconds = number;
export type SecurityGroupId = string;
export type SubnetId = string;
export type ValidationFraction = number;
export type GenerateCandidateDefinitionsOnly = boolean;
export type AutoGenerateEndpointName = boolean;
export type EndpointName = string;
export type AutoMLJobArn = string;
export type ContentColumn = string;
export type TargetLabelColumn = string;
export type ForecastFrequency = string;
export type ForecastHorizon = number;
export type ForecastQuantile = string;
export type TransformationAttributeName = string;
export type FillingTransformationValue = string;
export type TimestampAttributeName = string;
export type ItemIdentifierAttributeName = string;
export type GroupingAttributeName = string;
export type CountryCode = string;
export type BaseModelName = string;
export type TextGenerationHyperParameterKey = string;
export type TextGenerationHyperParameterValue = string;
export type ClusterName = string;
export type ClusterInstanceCount = number;
export type ClusterLifeCycleConfigFileName = string;
export type ClusterThreadsPerCore = number;
export type ClusterEbsVolumeSizeInGB = number;
export type CronScheduleExpression = string;
export type NodeUnavailabilityValue = number;
export type WaitTimeIntervalInSeconds = number;
export type AlarmName = string;
export type ImageId = string;
export type ClusterKubernetesLabelKey = string;
export type ClusterKubernetesLabelValue = string;
export type ClusterKubernetesTaintKey = string;
export type ClusterKubernetesTaintValue = string;
export type FSxLustreSizeInGiB = number;
export type FSxLustrePerUnitStorageThroughput = number;
export type EksClusterArn = string;
export type ClusterInstanceMemoryAllocationPercentage = number;
export type ClusterSchedulerPriorityClassName = string;
export type PriorityWeight = number;
export type ClusterSchedulerConfigArn = string;
export type ClusterSchedulerConfigId = string;
export type GitConfigUrl = string;
export type Branch = string;
export type SecretArn = string;
export type CodeRepositoryArn = string;
export type FrameworkVersion = string;
export type CompilerOptions = string;
export type NeoVpcSecurityGroupId = string;
export type NeoVpcSubnetId = string;
export type CompilationJobArn = string;
export type InstanceCount = number;
export type AcceleratorsAmount = number;
export type VCpuAmount = number;
export type MemoryInGiBAmount = number;
export type BorrowLimit = number;
export type ComputeQuotaTargetTeamName = string;
export type FairShareWeight = number;
export type ComputeQuotaArn = string;
export type ComputeQuotaId = string;
export type ContextName = string;
export type ContextArn = string;
export type MonitoringJobDefinitionName = string;
export type ProcessingJobName = string;
export type ImageUri = string;
export type ContainerEntrypointString = string;
export type ContainerArgument = string;
export type ProcessingEnvironmentKey = string;
export type ProcessingEnvironmentValue = string;
export type ProcessingLocalPath = string;
export type ProbabilityThresholdAttribute = number;
export type MonitoringTimeOffsetString = string;
export type ExcludeFeaturesAttribute = string;
export type DestinationS3Uri = string;
export type MonitoringS3Uri = string;
export type ProcessingInstanceCount = number;
export type ProcessingVolumeSizeInGB = number;
export type MonitoringMaxRuntimeInSeconds = number;
export type MonitoringJobDefinitionArn = string;
export type DeviceFleetDescription = string;
export type EnableIotRoleAlias = boolean;
export type DomainName = string;
export type RepositoryUrl = string;
export type ImageName = string;
export type ImageVersionNumber = number;
export type IdleTimeoutInMinutes = number;
export type SpaceEbsVolumeSizeInGb = number;
export type LandingUri = string;
export type Uid = number;
export type Gid = number;
export type FileSystemPath = string;
export type String1024 = string;
export type S3SchemaUri = string;
export type ImageVersionAliasPattern = string;
export type AccountId = string;
export type QProfileArn = string;
export type RegionName = string;
export type UnifiedStudioDomainId = string;
export type UnifiedStudioProjectId = string;
export type UnifiedStudioEnvironmentId = string;
export type SingleSignOnApplicationArn = string;
export type VpcId = string;
export type DomainArn = string;
export type Percentage = number;
export type DeviceName = string;
export type EdgeDeploymentPlanArn = string;
export type EdgeVersion = string;
export type EndpointConfigName = string;
export type WaitIntervalInSeconds = number;
export type CapacitySizeValue = number;
export type TerminationWaitInSeconds = number;
export type MaximumExecutionTimeoutInSeconds = number;
export type EndpointArn = string;
export type VariantName = string;
export type ModelName = string;
export type InitialTaskCount = number;
export type VariantWeight = number;
export type ServerlessMemorySizeInMB = number;
export type ServerlessMaxConcurrency = number;
export type ServerlessProvisionedConcurrency = number;
export type ProductionVariantVolumeSizeInGB = number;
export type ProductionVariantModelDataDownloadTimeoutInSeconds = number;
export type ProductionVariantContainerStartupHealthCheckTimeoutInSeconds =
  number;
export type ProductionVariantSSMAccess = boolean;
export type ManagedInstanceScalingMinInstanceCount = number;
export type ManagedInstanceScalingMaxInstanceCount = number;
export type MlReservationArn = string;
export type EnableCapture = boolean;
export type SamplingPercentage = number;
export type CsvContentType = string;
export type JsonContentType = string;
export type MaxConcurrentInvocationsPerInstance = number;
export type SnsTopicArn = string;
export type ClarifyEnableExplanations = string;
export type ClarifyFeaturesAttribute = string;
export type ClarifyContentTemplate = string;
export type ClarifyMaxRecordCount = number;
export type ClarifyMaxPayloadInMB = number;
export type ClarifyProbabilityIndex = number;
export type ClarifyLabelIndex = number;
export type ClarifyProbabilityAttribute = string;
export type ClarifyLabelAttribute = string;
export type ClarifyHeader = string;
export type ClarifyMimeType = string;
export type ClarifyShapBaseline = string;
export type ClarifyShapNumberOfSamples = number;
export type ClarifyShapUseLogit = boolean;
export type ClarifyShapSeed = number;
export type EnableEnhancedMetrics = boolean;
export type EndpointConfigArn = string;
export type ExperimentArn = string;
export type FeatureGroupName = string;
export type FeatureName = string;
export type Dimension = number;
export type TtlDurationValue = number;
export type TableName = string;
export type Catalog = string;
export type Database = string;
export type CapacityUnit = number;
export type Description = string;
export type FeatureGroupArn = string;
export type FlowDefinitionName = string;
export type HumanLoopActivationConditions = string;
export type WorkteamArn = string;
export type HumanTaskUiArn = string;
export type FlowDefinitionTaskTitle = string;
export type FlowDefinitionTaskDescription = string;
export type FlowDefinitionTaskCount = number;
export type FlowDefinitionTaskAvailabilityLifetimeInSeconds = number;
export type FlowDefinitionTaskTimeLimitInSeconds = number;
export type FlowDefinitionTaskKeyword = string;
export type Dollars = number;
export type Cents = number;
export type TenthFractionsOfACent = number;
export type FlowDefinitionArn = string;
export type HubName = string;
export type HubDescription = string;
export type HubDisplayName = string;
export type HubSearchKeyword = string;
export type S3OutputPath = string;
export type HubArn = string;
export type HubNameOrArn = string;
export type MaxResults = number;
export type NextToken = string;
export type LongS3Uri = string;
export type LocalPath = string;
export type SageMakerPublicHubContentArn = string;
export type HumanTaskUiName = string;
export type TemplateContent = string;
export type HyperParameterTuningJobName = string;
export type HyperbandStrategyMinResource = number;
export type HyperbandStrategyMaxResource = number;
export type MaxNumberOfTrainingJobs = number;
export type MaxParallelTrainingJobs = number;
export type HyperParameterTuningMaxRuntimeInSeconds = number;
export type ParameterKey = string;
export type TargetObjectiveMetricValue = number;
export type MaxNumberOfTrainingJobsNotImproving = number;
export type RandomSeed = number;
export type HyperParameterTrainingJobDefinitionName = string;
export type AlgorithmImage = string;
export type ArnOrName = string;
export type VolumeSizeInGB = number;
export type MaximumRetryAttempts = number;
export type HyperParameterTrainingJobEnvironmentKey = string;
export type HyperParameterTrainingJobEnvironmentValue = string;
export type HyperParameterTuningJobArn = string;
export type ImageDescription = string;
export type ImageDisplayName = string;
export type ImageBaseImage = string;
export type ClientToken = string;
export type SageMakerImageVersionAlias = string;
export type MLFramework = string;
export type ProgrammingLang = string;
export type Horovod = boolean;
export type ReleaseNotes = string;
export type InferenceComponentName = string;
export type NumberOfCpuCores = number;
export type NumberOfAcceleratorDevices = number;
export type MemoryInMb = number;
export type EnableCaching = boolean;
export type InferenceComponentCopyCount = number;
export type InferenceComponentArn = string;
export type InferenceExperimentName = string;
export type InferenceExperimentDescription = string;
export type ModelVariantName = string;
export type TaskCount = number;
export type InferenceExperimentArn = string;
export type RecommendationJobName = string;
export type JobDurationInSeconds = number;
export type InitialNumberOfUsers = number;
export type SpawnRate = number;
export type TrafficDurationInSeconds = number;
export type NumberOfSteps = number;
export type UsersPerStep = number;
export type MaxNumberOfTests = number;
export type MaxParallelOfTests = number;
export type InferenceSpecificationName = string;
export type String64 = string;
export type String128 = string;
export type RecommendationJobFrameworkVersion = string;
export type RecommendationJobSupportedContentType = string;
export type RecommendationJobDataInputConfig = string;
export type RecommendationJobSupportedResponseMIMEType = string;
export type RecommendationJobVpcSecurityGroupId = string;
export type RecommendationJobVpcSubnetId = string;
export type RecommendationJobDescription = string;
export type RecommendationJobArn = string;
export type LabelingJobName = string;
export type LabelAttributeName = string;
export type MaxHumanLabeledObjectCount = number;
export type MaxPercentageOfInputDatasetLabeled = number;
export type LabelingJobAlgorithmSpecificationArn = string;
export type ModelArn = string;
export type LambdaFunctionArn = string;
export type TaskKeyword = string;
export type TaskTitle = string;
export type TaskDescription = string;
export type NumberOfHumanWorkersPerDataObject = number;
export type TaskTimeLimitInSeconds = number;
export type TaskAvailabilityLifetimeInSeconds = number;
export type MaxConcurrentTaskCount = number;
export type LabelingJobArn = string;
export type MlflowAppName = string;
export type WeeklyMaintenanceWindowStart = string;
export type MlflowAppArn = string;
export type TrackingServerName = string;
export type MlflowVersion = string;
export type TrackingServerArn = string;
export type RepositoryCredentialsProviderArn = string;
export type AdditionalModelChannelName = string;
export type VersionedArnOrName = string;
export type ModelCardContent = string | redacted.Redacted<string>;
export type ModelCardArn = string;
export type ModelCardNameOrArn = string;
export type ModelCardExportJobArn = string;
export type ContentDigest = string;
export type CustomerMetadataKey = string;
export type CustomerMetadataValue = string;
export type ModelPackageSourceUri = string;
export type StageDescription = string;
export type ModelPackageGroupArn = string;
export type MonitoringScheduleName = string;
export type ScheduleExpression = string;
export type MonitoringScheduleArn = string;
export type NotebookInstanceName = string;
export type NotebookInstanceLifecycleConfigName = string;
export type NotebookInstanceVolumeSizeInGB = number;
export type CodeRepositoryNameOrUrl = string;
export type PlatformIdentifier = string;
export type MinimumInstanceMetadataServiceVersion = string;
export type NotebookInstanceArn = string;
export type NotebookInstanceLifecycleConfigContent = string;
export type NotebookInstanceLifecycleConfigArn = string;
export type OptimizationModelAcceptEula = boolean;
export type OptimizationJobMaxInstanceCount = number;
export type OptimizationContainerImage = string;
export type OptimizationVpcSecurityGroupId = string;
export type OptimizationVpcSubnetId = string;
export type OptimizationJobArn = string;
export type PartnerAppName = string;
export type WeeklyScheduleTimeFormat = string;
export type GroupNamePattern = string;
export type PartnerAppArn = string;
export type ExpiresInSeconds = number;
export type SessionExpirationDurationInSeconds = number;
export type String2048 = string;
export type PipelineName = string;
export type PipelineDefinition = string;
export type BucketName = string;
export type Key = string;
export type VersionId = string;
export type PipelineDescription = string;
export type IdempotencyToken = string;
export type MaxParallelExecutionSteps = number;
export type PipelineArn = string;
export type PresignedDomainUrl = string;
export type MlflowAppUrl = string;
export type TrackingServerUrl = string;
export type NotebookInstanceUrl = string;
export type AppManaged = boolean;
export type AthenaCatalog = string;
export type AthenaDatabase = string;
export type AthenaQueryString = string;
export type AthenaWorkGroup = string;
export type RedshiftClusterId = string;
export type RedshiftDatabase = string;
export type RedshiftUserName = string;
export type RedshiftQueryString = string;
export type ProcessingMaxRuntimeInSeconds = number;
export type ProcessingJobArn = string;
export type ProjectEntityName = string;
export type ServiceCatalogEntityId = string;
export type ProvisioningParameterKey = string;
export type ProvisioningParameterValue = string;
export type CfnTemplateName = string;
export type CfnTemplateURL = string;
export type CfnStackParameterKey = string;
export type CfnStackParameterValue = string;
export type ProjectArn = string;
export type ProjectId = string;
export type SpaceArn = string;
export type StudioLifecycleConfigName = string;
export type StudioLifecycleConfigContent = string;
export type TrainingJobName = string;
export type TrainingContainerEntrypointString = string;
export type TrainingContainerArgument = string;
export type TrainingRepositoryCredentialsProviderArn = string;
export type ConfigKey = string;
export type ConfigValue = string;
export type CollectionName = string;
export type RuleConfigurationName = string;
export type ProfilingIntervalInMilliseconds = number;
export type DisableProfiler = boolean;
export type TrainingEnvironmentKey = string;
export type TrainingEnvironmentValue = string;
export type EnableRemoteDebug = boolean;
export type EnableInfraCheck = boolean;
export type EnableSessionTagChaining = boolean;
export type ServerlessJobBaseModelArn = string;
export type EvaluatorArn = string;
export type MlFlowResourceArn = string;
export type MlflowExperimentName = string;
export type MlflowRunName = string;
export type TrainingJobArn = string;
export type TrainingPlanName = string;
export type TrainingPlanOfferingId = string;
export type SpareInstanceCountPerUltraServer = number;
export type TransformJobName = string;
export type InvocationsTimeoutInSeconds = number;
export type InvocationsMaxRetries = number;
export type JsonPath = string;
export type TransformJobArn = string;
export type TrialComponentStatusMessage = string;
export type TrialComponentKey320 = string;
export type DoubleParameterValue = number;
export type TrialComponentKey128 = string;
export type MediaType = string;
export type TrialComponentArtifactValue = string;
export type SingleSignOnUserIdentifier = string;
export type UserProfileArn = string;
export type CognitoUserPool = string;
export type ClientId = string;
export type ClientSecret = string | redacted.Redacted<string>;
export type OidcEndpoint = string;
export type Scope = string;
export type AuthenticationRequestExtraParamsKey = string;
export type AuthenticationRequestExtraParamsValue = string;
export type Cidr = string;
export type WorkforceName = string;
export type WorkforceVpcId = string;
export type WorkforceSecurityGroupId = string;
export type WorkforceSubnetId = string;
export type WorkforceArn = string;
export type WorkteamName = string;
export type CognitoUserGroup = string;
export type Group = string;
export type String200 = string;
export type NotificationTopicArn = string;
export type Success = boolean;
export type ExperimentEntityNameOrArn = string;
export type LineageGroupArn = string;
export type AutoMLFailureReason = string;
export type CandidateName = string;
export type MetricValue = number;
export type CandidateStepArn = string;
export type CandidateStepName = string;
export type ExplainabilityLocation = string;
export type ModelInsightsLocation = string;
export type BacktestResultsLocation = string;
export type CandidateDefinitionNotebookLocation = string;
export type DataExplorationNotebookLocation = string;
export type ClusterNonNegativeInstanceCount = number;
export type InstanceGroupTrainingPlanStatus = string;
export type ActiveClusterOperationCount = number;
export type EventId = string;
export type TargetCount = number;
export type ClusterPrivatePrimaryIp = string;
export type ClusterPrivatePrimaryIpv6 = string;
export type ClusterPrivateDnsHostname = string;
export type ClusterAvailabilityZone = string;
export type ClusterAvailabilityZoneId = string;
export type LastModifiedTime = Date;
export type InferenceImage = string;
export type ArtifactDigest = string;
export type ContextNameOrArn = string;
export type DeviceArn = string;
export type DeviceDescription = string;
export type ThingName = string;
export type DeviceFleetArn = string;
export type IotRoleAlias = string;
export type ResourceId = string;
export type DeploymentStageMaxResults = number;
export type EdgePackagingJobArn = string;
export type EdgePresetDeploymentArtifact = string;
export type VariantStatusMessage = string;
export type Ec2CapacityReservationId = string;
export type ExperimentSourceArn = string;
export type SourceType = string;
export type FeatureGroupNameOrArn = string;
export type BlockedReason = string;
export type OnlineStoreTotalSizeBytes = number;
export type FeatureDescription = string;
export type FeatureParameterKey = string;
export type FeatureParameterValue = string;
export type DocumentSchemaVersion = string;
export type HubContentDisplayName = string;
export type HubContentDescription = string;
export type HubContentMarkdown = string;
export type HubContentDocument = string;
export type ReferenceMinVersion = string;
export type HubContentSearchKeyword = string;
export type DependencyOriginPath = string;
export type DependencyCopyPath = string;
export type TemplateUrl = string;
export type TemplateContentSha256 = string;
export type TrainingJobStatusCounter = number;
export type ObjectiveStatusCounter = number;
export type ImageContainerImage = string;
export type InferenceExperimentStatusReason = string;
export type UtilizationMetric = number;
export type ModelSetupTime = number;
export type InitialInstanceCount = number;
export type RecommendationJobCompilationJobName = string;
export type InvocationEndTime = Date;
export type InvocationStartTime = Date;
export type LabelCounter = number;
export type JobReferenceCode = string;
export type ApprovalDescription = string;
export type NetworkInterfaceId = string;
export type MajorMinorVersion = string;
export type PipelineNameOrArn = string;
export type PipelineVersionId = number;
export type PipelineVersionName = string;
export type PipelineVersionDescription = string;
export type PipelineExecutionArn = string;
export type PipelineExecutionName = string;
export type PipelineExecutionDescription = string;
export type PipelineExecutionFailureReason = string;
export type MLflowArn = string;
export type MlflowExperimentEntityName = string;
export type ExitMessage = string;
export type ProvisionedProductStatusMessage = string;
export type CfnStackName = string;
export type CfnStackId = string;
export type CfnStackStatusMessage = string;
export type ReservedCapacityArn = string;
export type AvailabilityZone = string;
export type ReservedCapacityDurationHours = number;
export type ReservedCapacityDurationMinutes = number;
export type TotalInstanceCount = number;
export type AvailableInstanceCount = number;
export type InUseInstanceCount = number;
export type UltraServerType = string;
export type UltraServerCount = number;
export type AvailableSpareInstanceCount = number;
export type UnhealthyInstanceCount = number;
export type EfsUid = string;
export type ResourceRetainedBillableTimeInSeconds = number;
export type StatusMessage = string;
export type TrainingTimeInSeconds = number;
export type BillableTimeInSeconds = number;
export type BillableTokenCount = number;
export type StatusDetails = string;
export type MlflowExperimentId = string;
export type MlflowRunId = string;
export type TotalStepCountPerEpoch = number;
export type TrainingStepIndex = number;
export type TrainingEpochIndex = number;
export type TrainingEpochCount = number;
export type TrainingPlanStatusMessage = string;
export type TrainingPlanDurationHours = number;
export type TrainingPlanDurationMinutes = number;
export type CurrencyCode = string;
export type TrialSourceArn = string;
export type TrialComponentSourceArn = string;
export type OptionalDouble = number;
export type OptionalInteger = number;
export type WorkforceVpcEndpointId = string;
export type WorkforceFailureReason = string;
export type LineageGroupNameOrArn = string;
export type ResourcePolicyString = string;
export type PolicyString = string;
export type UtilizationPercentagePerCore = number;
export type PropertyNameHint = string;
export type ResourcePropertyName = string;
export type NameContains = string;
export type AutoMLNameContains = string;
export type AutoMLMaxResults = number;
export type AutoMLMaxResultsForTrials = number;
export type ClusterEventMaxResults = number;
export type IncludeNodeLogicalIdsBoolean = boolean;
export type CodeRepositoryNameContains = string;
export type ListMaxResults = number;
export type PaginationToken = string;
export type EndpointConfigNameContains = string;
export type EndpointNameContains = string;
export type FeatureGroupNameContains = string;
export type FeatureGroupMaxResults = number;
export type ImageNameContains = string;
export type InferenceComponentNameContains = string;
export type RecommendationFailureReason = string;
export type JobReferenceCodeContains = string;
export type ModelNameContains = string;
export type MonitoringAlertName = string;
export type MonitoringDatapointsToAlert = number;
export type MonitoringEvaluationPeriod = number;
export type NotebookInstanceLifecycleConfigNameContains = string;
export type NotebookInstanceNameContains = string;
export type CodeRepositoryContains = string;
export type OptimizationType = string;
export type String3072 = string;
export type StepName = string;
export type StepDisplayName = string;
export type StepDescription = string;
export type CallbackToken = string;
export type PipelineParameterName = string;
export type ResourceCatalogName = string;
export type ResourceCatalogArn = string;
export type ResourceCatalogDescription = string;
export type ListTagsMaxResults = number;
export type ConfiguredSpareInstanceCount = number;
export type String40 = string;
export type QueryLineageMaxDepth = number;
export type QueryLineageMaxResults = number;
export type String8192 = string;
export type TaskInput = string;
export type FilterValue = string;
export type VisibilityConditionsKey = string;
export type VisibilityConditionsValue = string;
export type ReservedCapacityInstanceCount = number;
export type TrainingPlanDurationHoursInput = number;
export type ResourceIdentifier = string;
export type SessionId = string;
export type StreamUrl = string;
export type TokenValue = string;
export type ImageDeleteProperty = string;
export type DisassociateNotebookInstanceLifecycleConfig = boolean;
export type DisassociateNotebookInstanceAcceleratorTypes = boolean;
export type DisassociateDefaultCodeRepository = boolean;
export type DisassociateAdditionalCodeRepositories = boolean;
export type TrialComponentKey256 = string;

//# Schemas
export type AssociationEdgeType =
  | "ContributedTo"
  | "AssociatedWith"
  | "DerivedFrom"
  | "Produced"
  | "SameAs"
  | (string & {});
export const AssociationEdgeType = S.String;
export interface AddAssociationRequest {
  SourceArn?: string;
  DestinationArn?: string;
  AssociationType?: AssociationEdgeType;
}
export const AddAssociationRequest = S.suspend(() =>
  S.Struct({
    SourceArn: S.optional(S.String),
    DestinationArn: S.optional(S.String),
    AssociationType: S.optional(AssociationEdgeType),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AddAssociationRequest",
}) as any as S.Schema<AddAssociationRequest>;
export interface AddAssociationResponse {
  SourceArn?: string;
  DestinationArn?: string;
}
export const AddAssociationResponse = S.suspend(() =>
  S.Struct({
    SourceArn: S.optional(S.String),
    DestinationArn: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "AddAssociationResponse",
}) as any as S.Schema<AddAssociationResponse>;
export interface Tag {
  Key?: string;
  Value?: string;
}
export const Tag = S.suspend(() =>
  S.Struct({ Key: S.optional(S.String), Value: S.optional(S.String) }),
).annotate({ identifier: "Tag" }) as any as S.Schema<Tag>;
export type TagList = Tag[];
export const TagList = S.Array(Tag);
export interface AddTagsInput {
  ResourceArn?: string;
  Tags?: Tag[];
}
export const AddTagsInput = S.suspend(() =>
  S.Struct({
    ResourceArn: S.optional(S.String),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({ identifier: "AddTagsInput" }) as any as S.Schema<AddTagsInput>;
export interface AddTagsOutput {
  Tags?: (Tag & { Key: TagKey; Value: TagValue })[];
}
export const AddTagsOutput = S.suspend(() =>
  S.Struct({ Tags: S.optional(TagList) }).pipe(ns),
).annotate({ identifier: "AddTagsOutput" }) as any as S.Schema<AddTagsOutput>;
export interface AssociateTrialComponentRequest {
  TrialComponentName?: string;
  TrialName?: string;
}
export const AssociateTrialComponentRequest = S.suspend(() =>
  S.Struct({
    TrialComponentName: S.optional(S.String),
    TrialName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateTrialComponentRequest",
}) as any as S.Schema<AssociateTrialComponentRequest>;
export interface AssociateTrialComponentResponse {
  TrialComponentArn?: string;
  TrialArn?: string;
}
export const AssociateTrialComponentResponse = S.suspend(() =>
  S.Struct({
    TrialComponentArn: S.optional(S.String),
    TrialArn: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "AssociateTrialComponentResponse",
}) as any as S.Schema<AssociateTrialComponentResponse>;
export interface AttachClusterNodeVolumeRequest {
  ClusterArn?: string;
  NodeId?: string;
  VolumeId?: string;
}
export const AttachClusterNodeVolumeRequest = S.suspend(() =>
  S.Struct({
    ClusterArn: S.optional(S.String),
    NodeId: S.optional(S.String),
    VolumeId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AttachClusterNodeVolumeRequest",
}) as any as S.Schema<AttachClusterNodeVolumeRequest>;
export type VolumeAttachmentStatus =
  | "attaching"
  | "attached"
  | "detaching"
  | "detached"
  | "busy"
  | (string & {});
export const VolumeAttachmentStatus = S.String;
export interface AttachClusterNodeVolumeResponse {
  ClusterArn: string;
  NodeId: string;
  VolumeId: string;
  AttachTime: Date;
  Status: VolumeAttachmentStatus;
  DeviceName: string;
}
export const AttachClusterNodeVolumeResponse = S.suspend(() =>
  S.Struct({
    ClusterArn: S.optional(S.String),
    NodeId: S.optional(S.String),
    VolumeId: S.optional(S.String),
    AttachTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Status: S.optional(VolumeAttachmentStatus),
    DeviceName: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "AttachClusterNodeVolumeResponse",
}) as any as S.Schema<AttachClusterNodeVolumeResponse>;
export interface AddClusterNodeSpecification {
  InstanceGroupName: string;
  IncrementTargetCountBy: number;
}
export const AddClusterNodeSpecification = S.suspend(() =>
  S.Struct({ InstanceGroupName: S.String, IncrementTargetCountBy: S.Number }),
).annotate({
  identifier: "AddClusterNodeSpecification",
}) as any as S.Schema<AddClusterNodeSpecification>;
export type AddClusterNodeSpecificationList = AddClusterNodeSpecification[];
export const AddClusterNodeSpecificationList = S.Array(
  AddClusterNodeSpecification,
);
export interface BatchAddClusterNodesRequest {
  ClusterName: string;
  ClientToken?: string;
  NodesToAdd?: AddClusterNodeSpecification[];
}
export const BatchAddClusterNodesRequest = S.suspend(() =>
  S.Struct({
    ClusterName: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    NodesToAdd: S.optional(AddClusterNodeSpecificationList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "BatchAddClusterNodesRequest",
}) as any as S.Schema<BatchAddClusterNodesRequest>;
export type ClusterInstanceStatus =
  | "Running"
  | "Failure"
  | "Pending"
  | "ShuttingDown"
  | "SystemUpdating"
  | "DeepHealthCheckInProgress"
  | "NotFound"
  | (string & {});
export const ClusterInstanceStatus = S.String;
export interface NodeAdditionResult {
  NodeLogicalId: string;
  InstanceGroupName: string;
  Status: ClusterInstanceStatus;
}
export const NodeAdditionResult = S.suspend(() =>
  S.Struct({
    NodeLogicalId: S.String,
    InstanceGroupName: S.String,
    Status: ClusterInstanceStatus,
  }),
).annotate({
  identifier: "NodeAdditionResult",
}) as any as S.Schema<NodeAdditionResult>;
export type NodeAdditionResultList = NodeAdditionResult[];
export const NodeAdditionResultList = S.Array(NodeAdditionResult);
export type BatchAddClusterNodesErrorCode =
  | "InstanceGroupNotFound"
  | "InvalidInstanceGroupStatus"
  | (string & {});
export const BatchAddClusterNodesErrorCode = S.String;
export interface BatchAddClusterNodesError {
  InstanceGroupName: string;
  ErrorCode: BatchAddClusterNodesErrorCode;
  FailedCount: number;
  Message?: string;
}
export const BatchAddClusterNodesError = S.suspend(() =>
  S.Struct({
    InstanceGroupName: S.String,
    ErrorCode: BatchAddClusterNodesErrorCode,
    FailedCount: S.Number,
    Message: S.optional(S.String),
  }),
).annotate({
  identifier: "BatchAddClusterNodesError",
}) as any as S.Schema<BatchAddClusterNodesError>;
export type BatchAddClusterNodesErrorList = BatchAddClusterNodesError[];
export const BatchAddClusterNodesErrorList = S.Array(BatchAddClusterNodesError);
export interface BatchAddClusterNodesResponse {
  Successful: NodeAdditionResult[];
  Failed: BatchAddClusterNodesError[];
}
export const BatchAddClusterNodesResponse = S.suspend(() =>
  S.Struct({
    Successful: NodeAdditionResultList,
    Failed: BatchAddClusterNodesErrorList,
  }).pipe(ns),
).annotate({
  identifier: "BatchAddClusterNodesResponse",
}) as any as S.Schema<BatchAddClusterNodesResponse>;
export type ClusterNodeIds = string[];
export const ClusterNodeIds = S.Array(S.String);
export type ClusterNodeLogicalIdList = string[];
export const ClusterNodeLogicalIdList = S.Array(S.String);
export interface BatchDeleteClusterNodesRequest {
  ClusterName?: string;
  NodeIds?: string[];
  NodeLogicalIds?: string[];
}
export const BatchDeleteClusterNodesRequest = S.suspend(() =>
  S.Struct({
    ClusterName: S.optional(S.String),
    NodeIds: S.optional(ClusterNodeIds),
    NodeLogicalIds: S.optional(ClusterNodeLogicalIdList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "BatchDeleteClusterNodesRequest",
}) as any as S.Schema<BatchDeleteClusterNodesRequest>;
export type BatchDeleteClusterNodesErrorCode =
  | "NodeIdNotFound"
  | "InvalidNodeStatus"
  | "NodeIdInUse"
  | (string & {});
export const BatchDeleteClusterNodesErrorCode = S.String;
export interface BatchDeleteClusterNodesError {
  Code?: BatchDeleteClusterNodesErrorCode;
  Message?: string;
  NodeId?: string;
}
export const BatchDeleteClusterNodesError = S.suspend(() =>
  S.Struct({
    Code: S.optional(BatchDeleteClusterNodesErrorCode),
    Message: S.optional(S.String),
    NodeId: S.optional(S.String),
  }),
).annotate({
  identifier: "BatchDeleteClusterNodesError",
}) as any as S.Schema<BatchDeleteClusterNodesError>;
export type BatchDeleteClusterNodesErrorList = BatchDeleteClusterNodesError[];
export const BatchDeleteClusterNodesErrorList = S.Array(
  BatchDeleteClusterNodesError,
);
export interface BatchDeleteClusterNodeLogicalIdsError {
  Code?: BatchDeleteClusterNodesErrorCode;
  Message?: string;
  NodeLogicalId?: string;
}
export const BatchDeleteClusterNodeLogicalIdsError = S.suspend(() =>
  S.Struct({
    Code: S.optional(BatchDeleteClusterNodesErrorCode),
    Message: S.optional(S.String),
    NodeLogicalId: S.optional(S.String),
  }),
).annotate({
  identifier: "BatchDeleteClusterNodeLogicalIdsError",
}) as any as S.Schema<BatchDeleteClusterNodeLogicalIdsError>;
export type BatchDeleteClusterNodeLogicalIdsErrorList =
  BatchDeleteClusterNodeLogicalIdsError[];
export const BatchDeleteClusterNodeLogicalIdsErrorList = S.Array(
  BatchDeleteClusterNodeLogicalIdsError,
);
export interface BatchDeleteClusterNodesResponse {
  Failed?: (BatchDeleteClusterNodesError & {
    Code: BatchDeleteClusterNodesErrorCode;
    Message: string;
    NodeId: ClusterNodeId;
  })[];
  Successful?: string[];
  FailedNodeLogicalIds?: (BatchDeleteClusterNodeLogicalIdsError & {
    Code: BatchDeleteClusterNodesErrorCode;
    Message: string;
    NodeLogicalId: ClusterNodeLogicalId;
  })[];
  SuccessfulNodeLogicalIds?: string[];
}
export const BatchDeleteClusterNodesResponse = S.suspend(() =>
  S.Struct({
    Failed: S.optional(BatchDeleteClusterNodesErrorList),
    Successful: S.optional(ClusterNodeIds),
    FailedNodeLogicalIds: S.optional(BatchDeleteClusterNodeLogicalIdsErrorList),
    SuccessfulNodeLogicalIds: S.optional(ClusterNodeLogicalIdList),
  }).pipe(ns),
).annotate({
  identifier: "BatchDeleteClusterNodesResponse",
}) as any as S.Schema<BatchDeleteClusterNodesResponse>;
export type ModelPackageArnList = string[];
export const ModelPackageArnList = S.Array(S.String);
export interface BatchDescribeModelPackageInput {
  ModelPackageArnList?: string[];
}
export const BatchDescribeModelPackageInput = S.suspend(() =>
  S.Struct({ ModelPackageArnList: S.optional(ModelPackageArnList) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "BatchDescribeModelPackageInput",
}) as any as S.Schema<BatchDescribeModelPackageInput>;
export type S3ModelDataType = "S3Prefix" | "S3Object" | (string & {});
export const S3ModelDataType = S.String;
export type ModelCompressionType = "None" | "Gzip" | (string & {});
export const ModelCompressionType = S.String;
export interface ModelAccessConfig {
  AcceptEula?: boolean;
}
export const ModelAccessConfig = S.suspend(() =>
  S.Struct({ AcceptEula: S.optional(S.Boolean) }),
).annotate({
  identifier: "ModelAccessConfig",
}) as any as S.Schema<ModelAccessConfig>;
export interface InferenceHubAccessConfig {
  HubContentArn?: string;
}
export const InferenceHubAccessConfig = S.suspend(() =>
  S.Struct({ HubContentArn: S.optional(S.String) }),
).annotate({
  identifier: "InferenceHubAccessConfig",
}) as any as S.Schema<InferenceHubAccessConfig>;
export interface S3ModelDataSource {
  S3Uri?: string;
  S3DataType?: S3ModelDataType;
  CompressionType?: ModelCompressionType;
  ModelAccessConfig?: ModelAccessConfig;
  HubAccessConfig?: InferenceHubAccessConfig;
  ManifestS3Uri?: string;
  ETag?: string;
  ManifestEtag?: string;
}
export const S3ModelDataSource = S.suspend(() =>
  S.Struct({
    S3Uri: S.optional(S.String),
    S3DataType: S.optional(S3ModelDataType),
    CompressionType: S.optional(ModelCompressionType),
    ModelAccessConfig: S.optional(ModelAccessConfig),
    HubAccessConfig: S.optional(InferenceHubAccessConfig),
    ManifestS3Uri: S.optional(S.String),
    ETag: S.optional(S.String),
    ManifestEtag: S.optional(S.String),
  }),
).annotate({
  identifier: "S3ModelDataSource",
}) as any as S.Schema<S3ModelDataSource>;
export interface ModelDataSource {
  S3DataSource?: S3ModelDataSource;
}
export const ModelDataSource = S.suspend(() =>
  S.Struct({ S3DataSource: S.optional(S3ModelDataSource) }),
).annotate({
  identifier: "ModelDataSource",
}) as any as S.Schema<ModelDataSource>;
export type EnvironmentMap = { [key: string]: string | undefined };
export const EnvironmentMap = S.Record(S.String, S.String.pipe(S.optional));
export interface ModelInput {
  DataInputConfig?: string;
}
export const ModelInput = S.suspend(() =>
  S.Struct({ DataInputConfig: S.optional(S.String) }),
).annotate({ identifier: "ModelInput" }) as any as S.Schema<ModelInput>;
export type AdditionalS3DataSourceDataType =
  | "S3Object"
  | "S3Prefix"
  | (string & {});
export const AdditionalS3DataSourceDataType = S.String;
export type CompressionType = "None" | "Gzip" | (string & {});
export const CompressionType = S.String;
export interface AdditionalS3DataSource {
  S3DataType?: AdditionalS3DataSourceDataType;
  S3Uri?: string;
  CompressionType?: CompressionType;
  ETag?: string;
}
export const AdditionalS3DataSource = S.suspend(() =>
  S.Struct({
    S3DataType: S.optional(AdditionalS3DataSourceDataType),
    S3Uri: S.optional(S.String),
    CompressionType: S.optional(CompressionType),
    ETag: S.optional(S.String),
  }),
).annotate({
  identifier: "AdditionalS3DataSource",
}) as any as S.Schema<AdditionalS3DataSource>;
export interface BaseModel {
  HubContentName?: string;
  HubContentVersion?: string;
  RecipeName?: string;
}
export const BaseModel = S.suspend(() =>
  S.Struct({
    HubContentName: S.optional(S.String),
    HubContentVersion: S.optional(S.String),
    RecipeName: S.optional(S.String),
  }),
).annotate({ identifier: "BaseModel" }) as any as S.Schema<BaseModel>;
export interface ModelPackageContainerDefinition {
  ContainerHostname?: string;
  Image?: string;
  ImageDigest?: string;
  ModelDataUrl?: string;
  ModelDataSource?: ModelDataSource;
  ProductId?: string;
  Environment?: { [key: string]: string | undefined };
  ModelInput?: ModelInput;
  Framework?: string;
  FrameworkVersion?: string;
  NearestModelName?: string;
  AdditionalS3DataSource?: AdditionalS3DataSource;
  ModelDataETag?: string;
  IsCheckpoint?: boolean;
  BaseModel?: BaseModel;
}
export const ModelPackageContainerDefinition = S.suspend(() =>
  S.Struct({
    ContainerHostname: S.optional(S.String),
    Image: S.optional(S.String),
    ImageDigest: S.optional(S.String),
    ModelDataUrl: S.optional(S.String),
    ModelDataSource: S.optional(ModelDataSource),
    ProductId: S.optional(S.String),
    Environment: S.optional(EnvironmentMap),
    ModelInput: S.optional(ModelInput),
    Framework: S.optional(S.String),
    FrameworkVersion: S.optional(S.String),
    NearestModelName: S.optional(S.String),
    AdditionalS3DataSource: S.optional(AdditionalS3DataSource),
    ModelDataETag: S.optional(S.String),
    IsCheckpoint: S.optional(S.Boolean),
    BaseModel: S.optional(BaseModel),
  }),
).annotate({
  identifier: "ModelPackageContainerDefinition",
}) as any as S.Schema<ModelPackageContainerDefinition>;
export type ModelPackageContainerDefinitionList =
  ModelPackageContainerDefinition[];
export const ModelPackageContainerDefinitionList = S.Array(
  ModelPackageContainerDefinition,
);
export type TransformInstanceType =
  | "ml.m4.xlarge"
  | "ml.m4.2xlarge"
  | "ml.m4.4xlarge"
  | "ml.m4.10xlarge"
  | "ml.m4.16xlarge"
  | "ml.c4.xlarge"
  | "ml.c4.2xlarge"
  | "ml.c4.4xlarge"
  | "ml.c4.8xlarge"
  | "ml.p2.xlarge"
  | "ml.p2.8xlarge"
  | "ml.p2.16xlarge"
  | "ml.p3.2xlarge"
  | "ml.p3.8xlarge"
  | "ml.p3.16xlarge"
  | "ml.c5.xlarge"
  | "ml.c5.2xlarge"
  | "ml.c5.4xlarge"
  | "ml.c5.9xlarge"
  | "ml.c5.18xlarge"
  | "ml.m5.large"
  | "ml.m5.xlarge"
  | "ml.m5.2xlarge"
  | "ml.m5.4xlarge"
  | "ml.m5.12xlarge"
  | "ml.m5.24xlarge"
  | "ml.m6i.large"
  | "ml.m6i.xlarge"
  | "ml.m6i.2xlarge"
  | "ml.m6i.4xlarge"
  | "ml.m6i.8xlarge"
  | "ml.m6i.12xlarge"
  | "ml.m6i.16xlarge"
  | "ml.m6i.24xlarge"
  | "ml.m6i.32xlarge"
  | "ml.c6i.large"
  | "ml.c6i.xlarge"
  | "ml.c6i.2xlarge"
  | "ml.c6i.4xlarge"
  | "ml.c6i.8xlarge"
  | "ml.c6i.12xlarge"
  | "ml.c6i.16xlarge"
  | "ml.c6i.24xlarge"
  | "ml.c6i.32xlarge"
  | "ml.r6i.large"
  | "ml.r6i.xlarge"
  | "ml.r6i.2xlarge"
  | "ml.r6i.4xlarge"
  | "ml.r6i.8xlarge"
  | "ml.r6i.12xlarge"
  | "ml.r6i.16xlarge"
  | "ml.r6i.24xlarge"
  | "ml.r6i.32xlarge"
  | "ml.m7i.large"
  | "ml.m7i.xlarge"
  | "ml.m7i.2xlarge"
  | "ml.m7i.4xlarge"
  | "ml.m7i.8xlarge"
  | "ml.m7i.12xlarge"
  | "ml.m7i.16xlarge"
  | "ml.m7i.24xlarge"
  | "ml.m7i.48xlarge"
  | "ml.c7i.large"
  | "ml.c7i.xlarge"
  | "ml.c7i.2xlarge"
  | "ml.c7i.4xlarge"
  | "ml.c7i.8xlarge"
  | "ml.c7i.12xlarge"
  | "ml.c7i.16xlarge"
  | "ml.c7i.24xlarge"
  | "ml.c7i.48xlarge"
  | "ml.r7i.large"
  | "ml.r7i.xlarge"
  | "ml.r7i.2xlarge"
  | "ml.r7i.4xlarge"
  | "ml.r7i.8xlarge"
  | "ml.r7i.12xlarge"
  | "ml.r7i.16xlarge"
  | "ml.r7i.24xlarge"
  | "ml.r7i.48xlarge"
  | "ml.g4dn.xlarge"
  | "ml.g4dn.2xlarge"
  | "ml.g4dn.4xlarge"
  | "ml.g4dn.8xlarge"
  | "ml.g4dn.12xlarge"
  | "ml.g4dn.16xlarge"
  | "ml.g5.xlarge"
  | "ml.g5.2xlarge"
  | "ml.g5.4xlarge"
  | "ml.g5.8xlarge"
  | "ml.g5.12xlarge"
  | "ml.g5.16xlarge"
  | "ml.g5.24xlarge"
  | "ml.g5.48xlarge"
  | "ml.trn1.2xlarge"
  | "ml.trn1.32xlarge"
  | "ml.inf2.xlarge"
  | "ml.inf2.8xlarge"
  | "ml.inf2.24xlarge"
  | "ml.inf2.48xlarge"
  | "ml.g6.xlarge"
  | "ml.g6.2xlarge"
  | "ml.g6.4xlarge"
  | "ml.g6.8xlarge"
  | "ml.g6.12xlarge"
  | "ml.g6.16xlarge"
  | "ml.g6.24xlarge"
  | "ml.g6.48xlarge"
  | (string & {});
export const TransformInstanceType = S.String;
export type TransformInstanceTypes = TransformInstanceType[];
export const TransformInstanceTypes = S.Array(TransformInstanceType);
export type ProductionVariantInstanceType =
  | "ml.t2.medium"
  | "ml.t2.large"
  | "ml.t2.xlarge"
  | "ml.t2.2xlarge"
  | "ml.m4.xlarge"
  | "ml.m4.2xlarge"
  | "ml.m4.4xlarge"
  | "ml.m4.10xlarge"
  | "ml.m4.16xlarge"
  | "ml.m5.large"
  | "ml.m5.xlarge"
  | "ml.m5.2xlarge"
  | "ml.m5.4xlarge"
  | "ml.m5.12xlarge"
  | "ml.m5.24xlarge"
  | "ml.m5d.large"
  | "ml.m5d.xlarge"
  | "ml.m5d.2xlarge"
  | "ml.m5d.4xlarge"
  | "ml.m5d.12xlarge"
  | "ml.m5d.24xlarge"
  | "ml.c4.large"
  | "ml.c4.xlarge"
  | "ml.c4.2xlarge"
  | "ml.c4.4xlarge"
  | "ml.c4.8xlarge"
  | "ml.p2.xlarge"
  | "ml.p2.8xlarge"
  | "ml.p2.16xlarge"
  | "ml.p3.2xlarge"
  | "ml.p3.8xlarge"
  | "ml.p3.16xlarge"
  | "ml.c5.large"
  | "ml.c5.xlarge"
  | "ml.c5.2xlarge"
  | "ml.c5.4xlarge"
  | "ml.c5.9xlarge"
  | "ml.c5.18xlarge"
  | "ml.c5d.large"
  | "ml.c5d.xlarge"
  | "ml.c5d.2xlarge"
  | "ml.c5d.4xlarge"
  | "ml.c5d.9xlarge"
  | "ml.c5d.18xlarge"
  | "ml.g4dn.xlarge"
  | "ml.g4dn.2xlarge"
  | "ml.g4dn.4xlarge"
  | "ml.g4dn.8xlarge"
  | "ml.g4dn.12xlarge"
  | "ml.g4dn.16xlarge"
  | "ml.r5.large"
  | "ml.r5.xlarge"
  | "ml.r5.2xlarge"
  | "ml.r5.4xlarge"
  | "ml.r5.12xlarge"
  | "ml.r5.24xlarge"
  | "ml.r5d.large"
  | "ml.r5d.xlarge"
  | "ml.r5d.2xlarge"
  | "ml.r5d.4xlarge"
  | "ml.r5d.12xlarge"
  | "ml.r5d.24xlarge"
  | "ml.inf1.xlarge"
  | "ml.inf1.2xlarge"
  | "ml.inf1.6xlarge"
  | "ml.inf1.24xlarge"
  | "ml.dl1.24xlarge"
  | "ml.c6i.large"
  | "ml.c6i.xlarge"
  | "ml.c6i.2xlarge"
  | "ml.c6i.4xlarge"
  | "ml.c6i.8xlarge"
  | "ml.c6i.12xlarge"
  | "ml.c6i.16xlarge"
  | "ml.c6i.24xlarge"
  | "ml.c6i.32xlarge"
  | "ml.m6i.large"
  | "ml.m6i.xlarge"
  | "ml.m6i.2xlarge"
  | "ml.m6i.4xlarge"
  | "ml.m6i.8xlarge"
  | "ml.m6i.12xlarge"
  | "ml.m6i.16xlarge"
  | "ml.m6i.24xlarge"
  | "ml.m6i.32xlarge"
  | "ml.r6i.large"
  | "ml.r6i.xlarge"
  | "ml.r6i.2xlarge"
  | "ml.r6i.4xlarge"
  | "ml.r6i.8xlarge"
  | "ml.r6i.12xlarge"
  | "ml.r6i.16xlarge"
  | "ml.r6i.24xlarge"
  | "ml.r6i.32xlarge"
  | "ml.g5.xlarge"
  | "ml.g5.2xlarge"
  | "ml.g5.4xlarge"
  | "ml.g5.8xlarge"
  | "ml.g5.12xlarge"
  | "ml.g5.16xlarge"
  | "ml.g5.24xlarge"
  | "ml.g5.48xlarge"
  | "ml.g6.xlarge"
  | "ml.g6.2xlarge"
  | "ml.g6.4xlarge"
  | "ml.g6.8xlarge"
  | "ml.g6.12xlarge"
  | "ml.g6.16xlarge"
  | "ml.g6.24xlarge"
  | "ml.g6.48xlarge"
  | "ml.r8g.medium"
  | "ml.r8g.large"
  | "ml.r8g.xlarge"
  | "ml.r8g.2xlarge"
  | "ml.r8g.4xlarge"
  | "ml.r8g.8xlarge"
  | "ml.r8g.12xlarge"
  | "ml.r8g.16xlarge"
  | "ml.r8g.24xlarge"
  | "ml.r8g.48xlarge"
  | "ml.g6e.xlarge"
  | "ml.g6e.2xlarge"
  | "ml.g6e.4xlarge"
  | "ml.g6e.8xlarge"
  | "ml.g6e.12xlarge"
  | "ml.g6e.16xlarge"
  | "ml.g6e.24xlarge"
  | "ml.g6e.48xlarge"
  | "ml.p4d.24xlarge"
  | "ml.c7g.large"
  | "ml.c7g.xlarge"
  | "ml.c7g.2xlarge"
  | "ml.c7g.4xlarge"
  | "ml.c7g.8xlarge"
  | "ml.c7g.12xlarge"
  | "ml.c7g.16xlarge"
  | "ml.m6g.large"
  | "ml.m6g.xlarge"
  | "ml.m6g.2xlarge"
  | "ml.m6g.4xlarge"
  | "ml.m6g.8xlarge"
  | "ml.m6g.12xlarge"
  | "ml.m6g.16xlarge"
  | "ml.m6gd.large"
  | "ml.m6gd.xlarge"
  | "ml.m6gd.2xlarge"
  | "ml.m6gd.4xlarge"
  | "ml.m6gd.8xlarge"
  | "ml.m6gd.12xlarge"
  | "ml.m6gd.16xlarge"
  | "ml.c6g.large"
  | "ml.c6g.xlarge"
  | "ml.c6g.2xlarge"
  | "ml.c6g.4xlarge"
  | "ml.c6g.8xlarge"
  | "ml.c6g.12xlarge"
  | "ml.c6g.16xlarge"
  | "ml.c6gd.large"
  | "ml.c6gd.xlarge"
  | "ml.c6gd.2xlarge"
  | "ml.c6gd.4xlarge"
  | "ml.c6gd.8xlarge"
  | "ml.c6gd.12xlarge"
  | "ml.c6gd.16xlarge"
  | "ml.c6gn.large"
  | "ml.c6gn.xlarge"
  | "ml.c6gn.2xlarge"
  | "ml.c6gn.4xlarge"
  | "ml.c6gn.8xlarge"
  | "ml.c6gn.12xlarge"
  | "ml.c6gn.16xlarge"
  | "ml.r6g.large"
  | "ml.r6g.xlarge"
  | "ml.r6g.2xlarge"
  | "ml.r6g.4xlarge"
  | "ml.r6g.8xlarge"
  | "ml.r6g.12xlarge"
  | "ml.r6g.16xlarge"
  | "ml.r6gd.large"
  | "ml.r6gd.xlarge"
  | "ml.r6gd.2xlarge"
  | "ml.r6gd.4xlarge"
  | "ml.r6gd.8xlarge"
  | "ml.r6gd.12xlarge"
  | "ml.r6gd.16xlarge"
  | "ml.p4de.24xlarge"
  | "ml.trn1.2xlarge"
  | "ml.trn1.32xlarge"
  | "ml.trn1n.32xlarge"
  | "ml.trn2.48xlarge"
  | "ml.inf2.xlarge"
  | "ml.inf2.8xlarge"
  | "ml.inf2.24xlarge"
  | "ml.inf2.48xlarge"
  | "ml.p5.48xlarge"
  | "ml.p5e.48xlarge"
  | "ml.p5en.48xlarge"
  | "ml.m7i.large"
  | "ml.m7i.xlarge"
  | "ml.m7i.2xlarge"
  | "ml.m7i.4xlarge"
  | "ml.m7i.8xlarge"
  | "ml.m7i.12xlarge"
  | "ml.m7i.16xlarge"
  | "ml.m7i.24xlarge"
  | "ml.m7i.48xlarge"
  | "ml.c7i.large"
  | "ml.c7i.xlarge"
  | "ml.c7i.2xlarge"
  | "ml.c7i.4xlarge"
  | "ml.c7i.8xlarge"
  | "ml.c7i.12xlarge"
  | "ml.c7i.16xlarge"
  | "ml.c7i.24xlarge"
  | "ml.c7i.48xlarge"
  | "ml.r7i.large"
  | "ml.r7i.xlarge"
  | "ml.r7i.2xlarge"
  | "ml.r7i.4xlarge"
  | "ml.r7i.8xlarge"
  | "ml.r7i.12xlarge"
  | "ml.r7i.16xlarge"
  | "ml.r7i.24xlarge"
  | "ml.r7i.48xlarge"
  | "ml.c8g.medium"
  | "ml.c8g.large"
  | "ml.c8g.xlarge"
  | "ml.c8g.2xlarge"
  | "ml.c8g.4xlarge"
  | "ml.c8g.8xlarge"
  | "ml.c8g.12xlarge"
  | "ml.c8g.16xlarge"
  | "ml.c8g.24xlarge"
  | "ml.c8g.48xlarge"
  | "ml.r7gd.medium"
  | "ml.r7gd.large"
  | "ml.r7gd.xlarge"
  | "ml.r7gd.2xlarge"
  | "ml.r7gd.4xlarge"
  | "ml.r7gd.8xlarge"
  | "ml.r7gd.12xlarge"
  | "ml.r7gd.16xlarge"
  | "ml.m8g.medium"
  | "ml.m8g.large"
  | "ml.m8g.xlarge"
  | "ml.m8g.2xlarge"
  | "ml.m8g.4xlarge"
  | "ml.m8g.8xlarge"
  | "ml.m8g.12xlarge"
  | "ml.m8g.16xlarge"
  | "ml.m8g.24xlarge"
  | "ml.m8g.48xlarge"
  | "ml.c6in.large"
  | "ml.c6in.xlarge"
  | "ml.c6in.2xlarge"
  | "ml.c6in.4xlarge"
  | "ml.c6in.8xlarge"
  | "ml.c6in.12xlarge"
  | "ml.c6in.16xlarge"
  | "ml.c6in.24xlarge"
  | "ml.c6in.32xlarge"
  | "ml.p6-b200.48xlarge"
  | "ml.p6e-gb200.36xlarge"
  | "ml.p5.4xlarge"
  | (string & {});
export const ProductionVariantInstanceType = S.String;
export type RealtimeInferenceInstanceTypes = ProductionVariantInstanceType[];
export const RealtimeInferenceInstanceTypes = S.Array(
  ProductionVariantInstanceType,
);
export type ContentTypes = string[];
export const ContentTypes = S.Array(S.String);
export type ResponseMIMETypes = string[];
export const ResponseMIMETypes = S.Array(S.String);
export interface InferenceSpecification {
  Containers?: ModelPackageContainerDefinition[];
  SupportedTransformInstanceTypes?: TransformInstanceType[];
  SupportedRealtimeInferenceInstanceTypes?: ProductionVariantInstanceType[];
  SupportedContentTypes?: string[];
  SupportedResponseMIMETypes?: string[];
}
export const InferenceSpecification = S.suspend(() =>
  S.Struct({
    Containers: S.optional(ModelPackageContainerDefinitionList),
    SupportedTransformInstanceTypes: S.optional(TransformInstanceTypes),
    SupportedRealtimeInferenceInstanceTypes: S.optional(
      RealtimeInferenceInstanceTypes,
    ),
    SupportedContentTypes: S.optional(ContentTypes),
    SupportedResponseMIMETypes: S.optional(ResponseMIMETypes),
  }),
).annotate({
  identifier: "InferenceSpecification",
}) as any as S.Schema<InferenceSpecification>;
export type ModelPackageStatus =
  | "Pending"
  | "InProgress"
  | "Completed"
  | "Failed"
  | "Deleting"
  | (string & {});
export const ModelPackageStatus = S.String;
export type ModelApprovalStatus =
  | "Approved"
  | "Rejected"
  | "PendingManualApproval"
  | (string & {});
export const ModelApprovalStatus = S.String;
export type ModelPackageRegistrationType =
  | "Logged"
  | "Registered"
  | (string & {});
export const ModelPackageRegistrationType = S.String;
export interface BatchDescribeModelPackageSummary {
  ModelPackageGroupName?: string;
  ModelPackageVersion?: number;
  ModelPackageArn?: string;
  ModelPackageDescription?: string;
  CreationTime?: Date;
  InferenceSpecification?: InferenceSpecification;
  ModelPackageStatus?: ModelPackageStatus;
  ModelApprovalStatus?: ModelApprovalStatus;
  ModelPackageRegistrationType?: ModelPackageRegistrationType;
}
export const BatchDescribeModelPackageSummary = S.suspend(() =>
  S.Struct({
    ModelPackageGroupName: S.optional(S.String),
    ModelPackageVersion: S.optional(S.Number),
    ModelPackageArn: S.optional(S.String),
    ModelPackageDescription: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    InferenceSpecification: S.optional(InferenceSpecification),
    ModelPackageStatus: S.optional(ModelPackageStatus),
    ModelApprovalStatus: S.optional(ModelApprovalStatus),
    ModelPackageRegistrationType: S.optional(ModelPackageRegistrationType),
  }),
).annotate({
  identifier: "BatchDescribeModelPackageSummary",
}) as any as S.Schema<BatchDescribeModelPackageSummary>;
export type ModelPackageSummaries = {
  [key: string]: BatchDescribeModelPackageSummary | undefined;
};
export const ModelPackageSummaries = S.Record(
  S.String,
  BatchDescribeModelPackageSummary.pipe(S.optional),
);
export interface BatchDescribeModelPackageError {
  ErrorCode?: string;
  ErrorResponse?: string;
}
export const BatchDescribeModelPackageError = S.suspend(() =>
  S.Struct({
    ErrorCode: S.optional(S.String),
    ErrorResponse: S.optional(S.String),
  }),
).annotate({
  identifier: "BatchDescribeModelPackageError",
}) as any as S.Schema<BatchDescribeModelPackageError>;
export type BatchDescribeModelPackageErrorMap = {
  [key: string]: BatchDescribeModelPackageError | undefined;
};
export const BatchDescribeModelPackageErrorMap = S.Record(
  S.String,
  BatchDescribeModelPackageError.pipe(S.optional),
);
export interface BatchDescribeModelPackageOutput {
  ModelPackageSummaries?: {
    [key: string]:
      | (BatchDescribeModelPackageSummary & {
          ModelPackageGroupName: EntityName;
          ModelPackageArn: ModelPackageArn;
          CreationTime: CreationTime;
          InferenceSpecification: InferenceSpecification & {
            Containers: (ModelPackageContainerDefinition & {
              ModelDataSource: ModelDataSource & {
                S3DataSource: S3ModelDataSource & {
                  S3Uri: S3ModelUri;
                  S3DataType: S3ModelDataType;
                  CompressionType: ModelCompressionType;
                  ModelAccessConfig: ModelAccessConfig & {
                    AcceptEula: AcceptEula;
                  };
                  HubAccessConfig: InferenceHubAccessConfig & {
                    HubContentArn: HubContentArn;
                  };
                };
              };
              ModelInput: ModelInput & { DataInputConfig: DataInputConfig };
              AdditionalS3DataSource: AdditionalS3DataSource & {
                S3DataType: AdditionalS3DataSourceDataType;
                S3Uri: S3Uri;
              };
            })[];
          };
          ModelPackageStatus: ModelPackageStatus;
        })
      | undefined;
  };
  BatchDescribeModelPackageErrorMap?: {
    [key: string]:
      | (BatchDescribeModelPackageError & {
          ErrorCode: string;
          ErrorResponse: string;
        })
      | undefined;
  };
}
export const BatchDescribeModelPackageOutput = S.suspend(() =>
  S.Struct({
    ModelPackageSummaries: S.optional(ModelPackageSummaries),
    BatchDescribeModelPackageErrorMap: S.optional(
      BatchDescribeModelPackageErrorMap,
    ),
  }).pipe(ns),
).annotate({
  identifier: "BatchDescribeModelPackageOutput",
}) as any as S.Schema<BatchDescribeModelPackageOutput>;
export interface BatchRebootClusterNodesRequest {
  ClusterName?: string;
  NodeIds?: string[];
  NodeLogicalIds?: string[];
}
export const BatchRebootClusterNodesRequest = S.suspend(() =>
  S.Struct({
    ClusterName: S.optional(S.String),
    NodeIds: S.optional(ClusterNodeIds),
    NodeLogicalIds: S.optional(ClusterNodeLogicalIdList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "BatchRebootClusterNodesRequest",
}) as any as S.Schema<BatchRebootClusterNodesRequest>;
export type BatchRebootClusterNodesErrorCode =
  | "InstanceIdNotFound"
  | "InvalidInstanceStatus"
  | "InstanceIdInUse"
  | "InternalServerError"
  | (string & {});
export const BatchRebootClusterNodesErrorCode = S.String;
export interface BatchRebootClusterNodesError {
  NodeId?: string;
  ErrorCode?: BatchRebootClusterNodesErrorCode;
  Message?: string;
}
export const BatchRebootClusterNodesError = S.suspend(() =>
  S.Struct({
    NodeId: S.optional(S.String),
    ErrorCode: S.optional(BatchRebootClusterNodesErrorCode),
    Message: S.optional(S.String),
  }),
).annotate({
  identifier: "BatchRebootClusterNodesError",
}) as any as S.Schema<BatchRebootClusterNodesError>;
export type BatchRebootClusterNodesErrors = BatchRebootClusterNodesError[];
export const BatchRebootClusterNodesErrors = S.Array(
  BatchRebootClusterNodesError,
);
export interface BatchRebootClusterNodeLogicalIdsError {
  NodeLogicalId?: string;
  ErrorCode?: BatchRebootClusterNodesErrorCode;
  Message?: string;
}
export const BatchRebootClusterNodeLogicalIdsError = S.suspend(() =>
  S.Struct({
    NodeLogicalId: S.optional(S.String),
    ErrorCode: S.optional(BatchRebootClusterNodesErrorCode),
    Message: S.optional(S.String),
  }),
).annotate({
  identifier: "BatchRebootClusterNodeLogicalIdsError",
}) as any as S.Schema<BatchRebootClusterNodeLogicalIdsError>;
export type BatchRebootClusterNodeLogicalIdsErrors =
  BatchRebootClusterNodeLogicalIdsError[];
export const BatchRebootClusterNodeLogicalIdsErrors = S.Array(
  BatchRebootClusterNodeLogicalIdsError,
);
export interface BatchRebootClusterNodesResponse {
  Successful?: string[];
  Failed?: (BatchRebootClusterNodesError & {
    NodeId: ClusterNodeId;
    ErrorCode: BatchRebootClusterNodesErrorCode;
    Message: string;
  })[];
  FailedNodeLogicalIds?: (BatchRebootClusterNodeLogicalIdsError & {
    NodeLogicalId: ClusterNodeLogicalId;
    ErrorCode: BatchRebootClusterNodesErrorCode;
    Message: string;
  })[];
  SuccessfulNodeLogicalIds?: string[];
}
export const BatchRebootClusterNodesResponse = S.suspend(() =>
  S.Struct({
    Successful: S.optional(ClusterNodeIds),
    Failed: S.optional(BatchRebootClusterNodesErrors),
    FailedNodeLogicalIds: S.optional(BatchRebootClusterNodeLogicalIdsErrors),
    SuccessfulNodeLogicalIds: S.optional(ClusterNodeLogicalIdList),
  }).pipe(ns),
).annotate({
  identifier: "BatchRebootClusterNodesResponse",
}) as any as S.Schema<BatchRebootClusterNodesResponse>;
export interface BatchReplaceClusterNodesRequest {
  ClusterName?: string;
  NodeIds?: string[];
  NodeLogicalIds?: string[];
}
export const BatchReplaceClusterNodesRequest = S.suspend(() =>
  S.Struct({
    ClusterName: S.optional(S.String),
    NodeIds: S.optional(ClusterNodeIds),
    NodeLogicalIds: S.optional(ClusterNodeLogicalIdList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "BatchReplaceClusterNodesRequest",
}) as any as S.Schema<BatchReplaceClusterNodesRequest>;
export type BatchReplaceClusterNodesErrorCode =
  | "InstanceIdNotFound"
  | "InvalidInstanceStatus"
  | "InstanceIdInUse"
  | "InternalServerError"
  | (string & {});
export const BatchReplaceClusterNodesErrorCode = S.String;
export interface BatchReplaceClusterNodesError {
  NodeId?: string;
  ErrorCode?: BatchReplaceClusterNodesErrorCode;
  Message?: string;
}
export const BatchReplaceClusterNodesError = S.suspend(() =>
  S.Struct({
    NodeId: S.optional(S.String),
    ErrorCode: S.optional(BatchReplaceClusterNodesErrorCode),
    Message: S.optional(S.String),
  }),
).annotate({
  identifier: "BatchReplaceClusterNodesError",
}) as any as S.Schema<BatchReplaceClusterNodesError>;
export type BatchReplaceClusterNodesErrors = BatchReplaceClusterNodesError[];
export const BatchReplaceClusterNodesErrors = S.Array(
  BatchReplaceClusterNodesError,
);
export interface BatchReplaceClusterNodeLogicalIdsError {
  NodeLogicalId?: string;
  ErrorCode?: BatchReplaceClusterNodesErrorCode;
  Message?: string;
}
export const BatchReplaceClusterNodeLogicalIdsError = S.suspend(() =>
  S.Struct({
    NodeLogicalId: S.optional(S.String),
    ErrorCode: S.optional(BatchReplaceClusterNodesErrorCode),
    Message: S.optional(S.String),
  }),
).annotate({
  identifier: "BatchReplaceClusterNodeLogicalIdsError",
}) as any as S.Schema<BatchReplaceClusterNodeLogicalIdsError>;
export type BatchReplaceClusterNodeLogicalIdsErrors =
  BatchReplaceClusterNodeLogicalIdsError[];
export const BatchReplaceClusterNodeLogicalIdsErrors = S.Array(
  BatchReplaceClusterNodeLogicalIdsError,
);
export interface BatchReplaceClusterNodesResponse {
  Successful?: string[];
  Failed?: (BatchReplaceClusterNodesError & {
    NodeId: ClusterNodeId;
    ErrorCode: BatchReplaceClusterNodesErrorCode;
    Message: string;
  })[];
  FailedNodeLogicalIds?: (BatchReplaceClusterNodeLogicalIdsError & {
    NodeLogicalId: ClusterNodeLogicalId;
    ErrorCode: BatchReplaceClusterNodesErrorCode;
    Message: string;
  })[];
  SuccessfulNodeLogicalIds?: string[];
}
export const BatchReplaceClusterNodesResponse = S.suspend(() =>
  S.Struct({
    Successful: S.optional(ClusterNodeIds),
    Failed: S.optional(BatchReplaceClusterNodesErrors),
    FailedNodeLogicalIds: S.optional(BatchReplaceClusterNodeLogicalIdsErrors),
    SuccessfulNodeLogicalIds: S.optional(ClusterNodeLogicalIdList),
  }).pipe(ns),
).annotate({
  identifier: "BatchReplaceClusterNodesResponse",
}) as any as S.Schema<BatchReplaceClusterNodesResponse>;
export interface ActionSource {
  SourceUri?: string;
  SourceType?: string;
  SourceId?: string;
}
export const ActionSource = S.suspend(() =>
  S.Struct({
    SourceUri: S.optional(S.String),
    SourceType: S.optional(S.String),
    SourceId: S.optional(S.String),
  }),
).annotate({ identifier: "ActionSource" }) as any as S.Schema<ActionSource>;
export type ActionStatus =
  | "Unknown"
  | "InProgress"
  | "Completed"
  | "Failed"
  | "Stopping"
  | "Stopped"
  | (string & {});
export const ActionStatus = S.String;
export type LineageEntityParameters = { [key: string]: string | undefined };
export const LineageEntityParameters = S.Record(
  S.String,
  S.String.pipe(S.optional),
);
export interface MetadataProperties {
  CommitId?: string;
  Repository?: string;
  GeneratedBy?: string;
  ProjectId?: string;
}
export const MetadataProperties = S.suspend(() =>
  S.Struct({
    CommitId: S.optional(S.String),
    Repository: S.optional(S.String),
    GeneratedBy: S.optional(S.String),
    ProjectId: S.optional(S.String),
  }),
).annotate({
  identifier: "MetadataProperties",
}) as any as S.Schema<MetadataProperties>;
export interface CreateActionRequest {
  ActionName?: string;
  Source?: ActionSource;
  ActionType?: string;
  Description?: string;
  Status?: ActionStatus;
  Properties?: { [key: string]: string | undefined };
  MetadataProperties?: MetadataProperties;
  Tags?: Tag[];
}
export const CreateActionRequest = S.suspend(() =>
  S.Struct({
    ActionName: S.optional(S.String),
    Source: S.optional(ActionSource),
    ActionType: S.optional(S.String),
    Description: S.optional(S.String),
    Status: S.optional(ActionStatus),
    Properties: S.optional(LineageEntityParameters),
    MetadataProperties: S.optional(MetadataProperties),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateActionRequest",
}) as any as S.Schema<CreateActionRequest>;
export interface CreateActionResponse {
  ActionArn?: string;
}
export const CreateActionResponse = S.suspend(() =>
  S.Struct({ ActionArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateActionResponse",
}) as any as S.Schema<CreateActionResponse>;
export type ParameterType =
  | "Integer"
  | "Continuous"
  | "Categorical"
  | "FreeText"
  | (string & {});
export const ParameterType = S.String;
export interface IntegerParameterRangeSpecification {
  MinValue?: string;
  MaxValue?: string;
}
export const IntegerParameterRangeSpecification = S.suspend(() =>
  S.Struct({ MinValue: S.optional(S.String), MaxValue: S.optional(S.String) }),
).annotate({
  identifier: "IntegerParameterRangeSpecification",
}) as any as S.Schema<IntegerParameterRangeSpecification>;
export interface ContinuousParameterRangeSpecification {
  MinValue?: string;
  MaxValue?: string;
}
export const ContinuousParameterRangeSpecification = S.suspend(() =>
  S.Struct({ MinValue: S.optional(S.String), MaxValue: S.optional(S.String) }),
).annotate({
  identifier: "ContinuousParameterRangeSpecification",
}) as any as S.Schema<ContinuousParameterRangeSpecification>;
export type ParameterValues = string[];
export const ParameterValues = S.Array(S.String);
export interface CategoricalParameterRangeSpecification {
  Values?: string[];
}
export const CategoricalParameterRangeSpecification = S.suspend(() =>
  S.Struct({ Values: S.optional(ParameterValues) }),
).annotate({
  identifier: "CategoricalParameterRangeSpecification",
}) as any as S.Schema<CategoricalParameterRangeSpecification>;
export interface ParameterRange {
  IntegerParameterRangeSpecification?: IntegerParameterRangeSpecification;
  ContinuousParameterRangeSpecification?: ContinuousParameterRangeSpecification;
  CategoricalParameterRangeSpecification?: CategoricalParameterRangeSpecification;
}
export const ParameterRange = S.suspend(() =>
  S.Struct({
    IntegerParameterRangeSpecification: S.optional(
      IntegerParameterRangeSpecification,
    ),
    ContinuousParameterRangeSpecification: S.optional(
      ContinuousParameterRangeSpecification,
    ),
    CategoricalParameterRangeSpecification: S.optional(
      CategoricalParameterRangeSpecification,
    ),
  }),
).annotate({ identifier: "ParameterRange" }) as any as S.Schema<ParameterRange>;
export interface HyperParameterSpecification {
  Name?: string;
  Description?: string;
  Type?: ParameterType;
  Range?: ParameterRange;
  IsTunable?: boolean;
  IsRequired?: boolean;
  DefaultValue?: string;
}
export const HyperParameterSpecification = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    Type: S.optional(ParameterType),
    Range: S.optional(ParameterRange),
    IsTunable: S.optional(S.Boolean),
    IsRequired: S.optional(S.Boolean),
    DefaultValue: S.optional(S.String),
  }),
).annotate({
  identifier: "HyperParameterSpecification",
}) as any as S.Schema<HyperParameterSpecification>;
export type HyperParameterSpecifications = HyperParameterSpecification[];
export const HyperParameterSpecifications = S.Array(
  HyperParameterSpecification,
);
export type TrainingInstanceType =
  | "ml.m4.xlarge"
  | "ml.m4.2xlarge"
  | "ml.m4.4xlarge"
  | "ml.m4.10xlarge"
  | "ml.m4.16xlarge"
  | "ml.g4dn.xlarge"
  | "ml.g4dn.2xlarge"
  | "ml.g4dn.4xlarge"
  | "ml.g4dn.8xlarge"
  | "ml.g4dn.12xlarge"
  | "ml.g4dn.16xlarge"
  | "ml.m5.large"
  | "ml.m5.xlarge"
  | "ml.m5.2xlarge"
  | "ml.m5.4xlarge"
  | "ml.m5.12xlarge"
  | "ml.m5.24xlarge"
  | "ml.c4.xlarge"
  | "ml.c4.2xlarge"
  | "ml.c4.4xlarge"
  | "ml.c4.8xlarge"
  | "ml.p2.xlarge"
  | "ml.p2.8xlarge"
  | "ml.p2.16xlarge"
  | "ml.p3.2xlarge"
  | "ml.p3.8xlarge"
  | "ml.p3.16xlarge"
  | "ml.p3dn.24xlarge"
  | "ml.p4d.24xlarge"
  | "ml.p4de.24xlarge"
  | "ml.p5.48xlarge"
  | "ml.p5e.48xlarge"
  | "ml.p5en.48xlarge"
  | "ml.c5.xlarge"
  | "ml.c5.2xlarge"
  | "ml.c5.4xlarge"
  | "ml.c5.9xlarge"
  | "ml.c5.18xlarge"
  | "ml.c5n.xlarge"
  | "ml.c5n.2xlarge"
  | "ml.c5n.4xlarge"
  | "ml.c5n.9xlarge"
  | "ml.c5n.18xlarge"
  | "ml.g5.xlarge"
  | "ml.g5.2xlarge"
  | "ml.g5.4xlarge"
  | "ml.g5.8xlarge"
  | "ml.g5.16xlarge"
  | "ml.g5.12xlarge"
  | "ml.g5.24xlarge"
  | "ml.g5.48xlarge"
  | "ml.g6.xlarge"
  | "ml.g6.2xlarge"
  | "ml.g6.4xlarge"
  | "ml.g6.8xlarge"
  | "ml.g6.16xlarge"
  | "ml.g6.12xlarge"
  | "ml.g6.24xlarge"
  | "ml.g6.48xlarge"
  | "ml.g6e.xlarge"
  | "ml.g6e.2xlarge"
  | "ml.g6e.4xlarge"
  | "ml.g6e.8xlarge"
  | "ml.g6e.16xlarge"
  | "ml.g6e.12xlarge"
  | "ml.g6e.24xlarge"
  | "ml.g6e.48xlarge"
  | "ml.trn1.2xlarge"
  | "ml.trn1.32xlarge"
  | "ml.trn1n.32xlarge"
  | "ml.trn2.48xlarge"
  | "ml.m6i.large"
  | "ml.m6i.xlarge"
  | "ml.m6i.2xlarge"
  | "ml.m6i.4xlarge"
  | "ml.m6i.8xlarge"
  | "ml.m6i.12xlarge"
  | "ml.m6i.16xlarge"
  | "ml.m6i.24xlarge"
  | "ml.m6i.32xlarge"
  | "ml.c6i.xlarge"
  | "ml.c6i.2xlarge"
  | "ml.c6i.8xlarge"
  | "ml.c6i.4xlarge"
  | "ml.c6i.12xlarge"
  | "ml.c6i.16xlarge"
  | "ml.c6i.24xlarge"
  | "ml.c6i.32xlarge"
  | "ml.r5d.large"
  | "ml.r5d.xlarge"
  | "ml.r5d.2xlarge"
  | "ml.r5d.4xlarge"
  | "ml.r5d.8xlarge"
  | "ml.r5d.12xlarge"
  | "ml.r5d.16xlarge"
  | "ml.r5d.24xlarge"
  | "ml.t3.medium"
  | "ml.t3.large"
  | "ml.t3.xlarge"
  | "ml.t3.2xlarge"
  | "ml.r5.large"
  | "ml.r5.xlarge"
  | "ml.r5.2xlarge"
  | "ml.r5.4xlarge"
  | "ml.r5.8xlarge"
  | "ml.r5.12xlarge"
  | "ml.r5.16xlarge"
  | "ml.r5.24xlarge"
  | "ml.p6-b200.48xlarge"
  | "ml.m7i.large"
  | "ml.m7i.xlarge"
  | "ml.m7i.2xlarge"
  | "ml.m7i.4xlarge"
  | "ml.m7i.8xlarge"
  | "ml.m7i.12xlarge"
  | "ml.m7i.16xlarge"
  | "ml.m7i.24xlarge"
  | "ml.m7i.48xlarge"
  | "ml.c7i.large"
  | "ml.c7i.xlarge"
  | "ml.c7i.2xlarge"
  | "ml.c7i.4xlarge"
  | "ml.c7i.8xlarge"
  | "ml.c7i.12xlarge"
  | "ml.c7i.16xlarge"
  | "ml.c7i.24xlarge"
  | "ml.c7i.48xlarge"
  | "ml.r7i.large"
  | "ml.r7i.xlarge"
  | "ml.r7i.2xlarge"
  | "ml.r7i.4xlarge"
  | "ml.r7i.8xlarge"
  | "ml.r7i.12xlarge"
  | "ml.r7i.16xlarge"
  | "ml.r7i.24xlarge"
  | "ml.r7i.48xlarge"
  | "ml.p6e-gb200.36xlarge"
  | "ml.p5.4xlarge"
  | "ml.p6-b300.48xlarge"
  | (string & {});
export const TrainingInstanceType = S.String;
export type TrainingInstanceTypes = TrainingInstanceType[];
export const TrainingInstanceTypes = S.Array(TrainingInstanceType);
export interface MetricDefinition {
  Name?: string;
  Regex?: string;
}
export const MetricDefinition = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Regex: S.optional(S.String) }),
).annotate({
  identifier: "MetricDefinition",
}) as any as S.Schema<MetricDefinition>;
export type MetricDefinitionList = MetricDefinition[];
export const MetricDefinitionList = S.Array(MetricDefinition);
export type CompressionTypes = CompressionType[];
export const CompressionTypes = S.Array(CompressionType);
export type TrainingInputMode = "Pipe" | "File" | "FastFile" | (string & {});
export const TrainingInputMode = S.String;
export type InputModes = TrainingInputMode[];
export const InputModes = S.Array(TrainingInputMode);
export interface ChannelSpecification {
  Name?: string;
  Description?: string;
  IsRequired?: boolean;
  SupportedContentTypes?: string[];
  SupportedCompressionTypes?: CompressionType[];
  SupportedInputModes?: TrainingInputMode[];
}
export const ChannelSpecification = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    IsRequired: S.optional(S.Boolean),
    SupportedContentTypes: S.optional(ContentTypes),
    SupportedCompressionTypes: S.optional(CompressionTypes),
    SupportedInputModes: S.optional(InputModes),
  }),
).annotate({
  identifier: "ChannelSpecification",
}) as any as S.Schema<ChannelSpecification>;
export type ChannelSpecifications = ChannelSpecification[];
export const ChannelSpecifications = S.Array(ChannelSpecification);
export type HyperParameterTuningJobObjectiveType =
  | "Maximize"
  | "Minimize"
  | (string & {});
export const HyperParameterTuningJobObjectiveType = S.String;
export interface HyperParameterTuningJobObjective {
  Type?: HyperParameterTuningJobObjectiveType;
  MetricName?: string;
}
export const HyperParameterTuningJobObjective = S.suspend(() =>
  S.Struct({
    Type: S.optional(HyperParameterTuningJobObjectiveType),
    MetricName: S.optional(S.String),
  }),
).annotate({
  identifier: "HyperParameterTuningJobObjective",
}) as any as S.Schema<HyperParameterTuningJobObjective>;
export type HyperParameterTuningJobObjectives =
  HyperParameterTuningJobObjective[];
export const HyperParameterTuningJobObjectives = S.Array(
  HyperParameterTuningJobObjective,
);
export interface TrainingSpecification {
  TrainingImage?: string;
  TrainingImageDigest?: string;
  SupportedHyperParameters?: HyperParameterSpecification[];
  SupportedTrainingInstanceTypes?: TrainingInstanceType[];
  SupportsDistributedTraining?: boolean;
  MetricDefinitions?: MetricDefinition[];
  TrainingChannels?: ChannelSpecification[];
  SupportedTuningJobObjectiveMetrics?: HyperParameterTuningJobObjective[];
  AdditionalS3DataSource?: AdditionalS3DataSource;
}
export const TrainingSpecification = S.suspend(() =>
  S.Struct({
    TrainingImage: S.optional(S.String),
    TrainingImageDigest: S.optional(S.String),
    SupportedHyperParameters: S.optional(HyperParameterSpecifications),
    SupportedTrainingInstanceTypes: S.optional(TrainingInstanceTypes),
    SupportsDistributedTraining: S.optional(S.Boolean),
    MetricDefinitions: S.optional(MetricDefinitionList),
    TrainingChannels: S.optional(ChannelSpecifications),
    SupportedTuningJobObjectiveMetrics: S.optional(
      HyperParameterTuningJobObjectives,
    ),
    AdditionalS3DataSource: S.optional(AdditionalS3DataSource),
  }),
).annotate({
  identifier: "TrainingSpecification",
}) as any as S.Schema<TrainingSpecification>;
export type HyperParameters = { [key: string]: string | undefined };
export const HyperParameters = S.Record(S.String, S.String.pipe(S.optional));
export type S3DataType =
  | "ManifestFile"
  | "S3Prefix"
  | "AugmentedManifestFile"
  | "Converse"
  | (string & {});
export const S3DataType = S.String;
export type S3DataDistribution =
  | "FullyReplicated"
  | "ShardedByS3Key"
  | (string & {});
export const S3DataDistribution = S.String;
export type AttributeNames = string[];
export const AttributeNames = S.Array(S.String);
export type InstanceGroupNames = string[];
export const InstanceGroupNames = S.Array(S.String);
export interface HubAccessConfig {
  HubContentArn?: string;
}
export const HubAccessConfig = S.suspend(() =>
  S.Struct({ HubContentArn: S.optional(S.String) }),
).annotate({
  identifier: "HubAccessConfig",
}) as any as S.Schema<HubAccessConfig>;
export interface S3DataSource {
  S3DataType?: S3DataType;
  S3Uri?: string;
  S3DataDistributionType?: S3DataDistribution;
  AttributeNames?: string[];
  InstanceGroupNames?: string[];
  ModelAccessConfig?: ModelAccessConfig;
  HubAccessConfig?: HubAccessConfig;
}
export const S3DataSource = S.suspend(() =>
  S.Struct({
    S3DataType: S.optional(S3DataType),
    S3Uri: S.optional(S.String),
    S3DataDistributionType: S.optional(S3DataDistribution),
    AttributeNames: S.optional(AttributeNames),
    InstanceGroupNames: S.optional(InstanceGroupNames),
    ModelAccessConfig: S.optional(ModelAccessConfig),
    HubAccessConfig: S.optional(HubAccessConfig),
  }),
).annotate({ identifier: "S3DataSource" }) as any as S.Schema<S3DataSource>;
export type FileSystemAccessMode = "rw" | "ro" | (string & {});
export const FileSystemAccessMode = S.String;
export type FileSystemType = "EFS" | "FSxLustre" | (string & {});
export const FileSystemType = S.String;
export interface FileSystemDataSource {
  FileSystemId?: string;
  FileSystemAccessMode?: FileSystemAccessMode;
  FileSystemType?: FileSystemType;
  DirectoryPath?: string;
}
export const FileSystemDataSource = S.suspend(() =>
  S.Struct({
    FileSystemId: S.optional(S.String),
    FileSystemAccessMode: S.optional(FileSystemAccessMode),
    FileSystemType: S.optional(FileSystemType),
    DirectoryPath: S.optional(S.String),
  }),
).annotate({
  identifier: "FileSystemDataSource",
}) as any as S.Schema<FileSystemDataSource>;
export interface DatasetSource {
  DatasetArn: string;
}
export const DatasetSource = S.suspend(() =>
  S.Struct({ DatasetArn: S.String }),
).annotate({ identifier: "DatasetSource" }) as any as S.Schema<DatasetSource>;
export interface DataSource {
  S3DataSource?: S3DataSource;
  FileSystemDataSource?: FileSystemDataSource;
  DatasetSource?: DatasetSource;
}
export const DataSource = S.suspend(() =>
  S.Struct({
    S3DataSource: S.optional(S3DataSource),
    FileSystemDataSource: S.optional(FileSystemDataSource),
    DatasetSource: S.optional(DatasetSource),
  }),
).annotate({ identifier: "DataSource" }) as any as S.Schema<DataSource>;
export type RecordWrapper = "None" | "RecordIO" | (string & {});
export const RecordWrapper = S.String;
export interface ShuffleConfig {
  Seed?: number;
}
export const ShuffleConfig = S.suspend(() =>
  S.Struct({ Seed: S.optional(S.Number) }),
).annotate({ identifier: "ShuffleConfig" }) as any as S.Schema<ShuffleConfig>;
export interface Channel {
  ChannelName?: string;
  DataSource?: DataSource;
  ContentType?: string;
  CompressionType?: CompressionType;
  RecordWrapperType?: RecordWrapper;
  InputMode?: TrainingInputMode;
  ShuffleConfig?: ShuffleConfig;
}
export const Channel = S.suspend(() =>
  S.Struct({
    ChannelName: S.optional(S.String),
    DataSource: S.optional(DataSource),
    ContentType: S.optional(S.String),
    CompressionType: S.optional(CompressionType),
    RecordWrapperType: S.optional(RecordWrapper),
    InputMode: S.optional(TrainingInputMode),
    ShuffleConfig: S.optional(ShuffleConfig),
  }),
).annotate({ identifier: "Channel" }) as any as S.Schema<Channel>;
export type InputDataConfig = Channel[];
export const InputDataConfig = S.Array(Channel);
export type OutputCompressionType = "GZIP" | "NONE" | (string & {});
export const OutputCompressionType = S.String;
export interface OutputDataConfig {
  KmsKeyId?: string;
  S3OutputPath?: string;
  CompressionType?: OutputCompressionType;
}
export const OutputDataConfig = S.suspend(() =>
  S.Struct({
    KmsKeyId: S.optional(S.String),
    S3OutputPath: S.optional(S.String),
    CompressionType: S.optional(OutputCompressionType),
  }),
).annotate({
  identifier: "OutputDataConfig",
}) as any as S.Schema<OutputDataConfig>;
export interface InstanceGroup {
  InstanceType?: TrainingInstanceType;
  InstanceCount?: number;
  InstanceGroupName?: string;
}
export const InstanceGroup = S.suspend(() =>
  S.Struct({
    InstanceType: S.optional(TrainingInstanceType),
    InstanceCount: S.optional(S.Number),
    InstanceGroupName: S.optional(S.String),
  }),
).annotate({ identifier: "InstanceGroup" }) as any as S.Schema<InstanceGroup>;
export type InstanceGroups = InstanceGroup[];
export const InstanceGroups = S.Array(InstanceGroup);
export interface PlacementSpecification {
  UltraServerId?: string;
  InstanceCount?: number;
}
export const PlacementSpecification = S.suspend(() =>
  S.Struct({
    UltraServerId: S.optional(S.String),
    InstanceCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "PlacementSpecification",
}) as any as S.Schema<PlacementSpecification>;
export type PlacementSpecifications = PlacementSpecification[];
export const PlacementSpecifications = S.Array(PlacementSpecification);
export interface InstancePlacementConfig {
  EnableMultipleJobs?: boolean;
  PlacementSpecifications?: PlacementSpecification[];
}
export const InstancePlacementConfig = S.suspend(() =>
  S.Struct({
    EnableMultipleJobs: S.optional(S.Boolean),
    PlacementSpecifications: S.optional(PlacementSpecifications),
  }),
).annotate({
  identifier: "InstancePlacementConfig",
}) as any as S.Schema<InstancePlacementConfig>;
export interface ResourceConfig {
  InstanceType?: TrainingInstanceType;
  InstanceCount?: number;
  VolumeSizeInGB?: number;
  VolumeKmsKeyId?: string;
  KeepAlivePeriodInSeconds?: number;
  InstanceGroups?: InstanceGroup[];
  TrainingPlanArn?: string;
  InstancePlacementConfig?: InstancePlacementConfig;
}
export const ResourceConfig = S.suspend(() =>
  S.Struct({
    InstanceType: S.optional(TrainingInstanceType),
    InstanceCount: S.optional(S.Number),
    VolumeSizeInGB: S.optional(S.Number),
    VolumeKmsKeyId: S.optional(S.String),
    KeepAlivePeriodInSeconds: S.optional(S.Number),
    InstanceGroups: S.optional(InstanceGroups),
    TrainingPlanArn: S.optional(S.String),
    InstancePlacementConfig: S.optional(InstancePlacementConfig),
  }),
).annotate({ identifier: "ResourceConfig" }) as any as S.Schema<ResourceConfig>;
export interface StoppingCondition {
  MaxRuntimeInSeconds?: number;
  MaxWaitTimeInSeconds?: number;
  MaxPendingTimeInSeconds?: number;
}
export const StoppingCondition = S.suspend(() =>
  S.Struct({
    MaxRuntimeInSeconds: S.optional(S.Number),
    MaxWaitTimeInSeconds: S.optional(S.Number),
    MaxPendingTimeInSeconds: S.optional(S.Number),
  }),
).annotate({
  identifier: "StoppingCondition",
}) as any as S.Schema<StoppingCondition>;
export interface TrainingJobDefinition {
  TrainingInputMode?: TrainingInputMode;
  HyperParameters?: { [key: string]: string | undefined };
  InputDataConfig?: Channel[];
  OutputDataConfig?: OutputDataConfig;
  ResourceConfig?: ResourceConfig;
  StoppingCondition?: StoppingCondition;
}
export const TrainingJobDefinition = S.suspend(() =>
  S.Struct({
    TrainingInputMode: S.optional(TrainingInputMode),
    HyperParameters: S.optional(HyperParameters),
    InputDataConfig: S.optional(InputDataConfig),
    OutputDataConfig: S.optional(OutputDataConfig),
    ResourceConfig: S.optional(ResourceConfig),
    StoppingCondition: S.optional(StoppingCondition),
  }),
).annotate({
  identifier: "TrainingJobDefinition",
}) as any as S.Schema<TrainingJobDefinition>;
export type BatchStrategy = "MultiRecord" | "SingleRecord" | (string & {});
export const BatchStrategy = S.String;
export type TransformEnvironmentMap = { [key: string]: string | undefined };
export const TransformEnvironmentMap = S.Record(
  S.String,
  S.String.pipe(S.optional),
);
export interface TransformS3DataSource {
  S3DataType?: S3DataType;
  S3Uri?: string;
}
export const TransformS3DataSource = S.suspend(() =>
  S.Struct({ S3DataType: S.optional(S3DataType), S3Uri: S.optional(S.String) }),
).annotate({
  identifier: "TransformS3DataSource",
}) as any as S.Schema<TransformS3DataSource>;
export interface TransformDataSource {
  S3DataSource?: TransformS3DataSource;
}
export const TransformDataSource = S.suspend(() =>
  S.Struct({ S3DataSource: S.optional(TransformS3DataSource) }),
).annotate({
  identifier: "TransformDataSource",
}) as any as S.Schema<TransformDataSource>;
export type SplitType =
  | "None"
  | "Line"
  | "RecordIO"
  | "TFRecord"
  | (string & {});
export const SplitType = S.String;
export interface TransformInput {
  DataSource?: TransformDataSource;
  ContentType?: string;
  CompressionType?: CompressionType;
  SplitType?: SplitType;
}
export const TransformInput = S.suspend(() =>
  S.Struct({
    DataSource: S.optional(TransformDataSource),
    ContentType: S.optional(S.String),
    CompressionType: S.optional(CompressionType),
    SplitType: S.optional(SplitType),
  }),
).annotate({ identifier: "TransformInput" }) as any as S.Schema<TransformInput>;
export type AssemblyType = "None" | "Line" | (string & {});
export const AssemblyType = S.String;
export interface TransformOutput {
  S3OutputPath?: string;
  Accept?: string;
  AssembleWith?: AssemblyType;
  KmsKeyId?: string;
}
export const TransformOutput = S.suspend(() =>
  S.Struct({
    S3OutputPath: S.optional(S.String),
    Accept: S.optional(S.String),
    AssembleWith: S.optional(AssemblyType),
    KmsKeyId: S.optional(S.String),
  }),
).annotate({
  identifier: "TransformOutput",
}) as any as S.Schema<TransformOutput>;
export interface TransformResources {
  InstanceType?: TransformInstanceType;
  InstanceCount?: number;
  VolumeKmsKeyId?: string;
  TransformAmiVersion?: string;
}
export const TransformResources = S.suspend(() =>
  S.Struct({
    InstanceType: S.optional(TransformInstanceType),
    InstanceCount: S.optional(S.Number),
    VolumeKmsKeyId: S.optional(S.String),
    TransformAmiVersion: S.optional(S.String),
  }),
).annotate({
  identifier: "TransformResources",
}) as any as S.Schema<TransformResources>;
export interface TransformJobDefinition {
  MaxConcurrentTransforms?: number;
  MaxPayloadInMB?: number;
  BatchStrategy?: BatchStrategy;
  Environment?: { [key: string]: string | undefined };
  TransformInput?: TransformInput;
  TransformOutput?: TransformOutput;
  TransformResources?: TransformResources;
}
export const TransformJobDefinition = S.suspend(() =>
  S.Struct({
    MaxConcurrentTransforms: S.optional(S.Number),
    MaxPayloadInMB: S.optional(S.Number),
    BatchStrategy: S.optional(BatchStrategy),
    Environment: S.optional(TransformEnvironmentMap),
    TransformInput: S.optional(TransformInput),
    TransformOutput: S.optional(TransformOutput),
    TransformResources: S.optional(TransformResources),
  }),
).annotate({
  identifier: "TransformJobDefinition",
}) as any as S.Schema<TransformJobDefinition>;
export interface AlgorithmValidationProfile {
  ProfileName?: string;
  TrainingJobDefinition?: TrainingJobDefinition;
  TransformJobDefinition?: TransformJobDefinition;
}
export const AlgorithmValidationProfile = S.suspend(() =>
  S.Struct({
    ProfileName: S.optional(S.String),
    TrainingJobDefinition: S.optional(TrainingJobDefinition),
    TransformJobDefinition: S.optional(TransformJobDefinition),
  }),
).annotate({
  identifier: "AlgorithmValidationProfile",
}) as any as S.Schema<AlgorithmValidationProfile>;
export type AlgorithmValidationProfiles = AlgorithmValidationProfile[];
export const AlgorithmValidationProfiles = S.Array(AlgorithmValidationProfile);
export interface AlgorithmValidationSpecification {
  ValidationRole?: string;
  ValidationProfiles?: AlgorithmValidationProfile[];
}
export const AlgorithmValidationSpecification = S.suspend(() =>
  S.Struct({
    ValidationRole: S.optional(S.String),
    ValidationProfiles: S.optional(AlgorithmValidationProfiles),
  }),
).annotate({
  identifier: "AlgorithmValidationSpecification",
}) as any as S.Schema<AlgorithmValidationSpecification>;
export interface CreateAlgorithmInput {
  AlgorithmName?: string;
  AlgorithmDescription?: string;
  TrainingSpecification?: TrainingSpecification;
  InferenceSpecification?: InferenceSpecification;
  ValidationSpecification?: AlgorithmValidationSpecification;
  CertifyForMarketplace?: boolean;
  Tags?: Tag[];
}
export const CreateAlgorithmInput = S.suspend(() =>
  S.Struct({
    AlgorithmName: S.optional(S.String),
    AlgorithmDescription: S.optional(S.String),
    TrainingSpecification: S.optional(TrainingSpecification),
    InferenceSpecification: S.optional(InferenceSpecification),
    ValidationSpecification: S.optional(AlgorithmValidationSpecification),
    CertifyForMarketplace: S.optional(S.Boolean),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateAlgorithmInput",
}) as any as S.Schema<CreateAlgorithmInput>;
export interface CreateAlgorithmOutput {
  AlgorithmArn: string;
}
export const CreateAlgorithmOutput = S.suspend(() =>
  S.Struct({ AlgorithmArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateAlgorithmOutput",
}) as any as S.Schema<CreateAlgorithmOutput>;
export type AppType =
  | "JupyterServer"
  | "KernelGateway"
  | "DetailedProfiler"
  | "TensorBoard"
  | "CodeEditor"
  | "JupyterLab"
  | "RStudioServerPro"
  | "RSessionGateway"
  | "Canvas"
  | (string & {});
export const AppType = S.String;
export type AppInstanceType =
  | "system"
  | "ml.t3.micro"
  | "ml.t3.small"
  | "ml.t3.medium"
  | "ml.t3.large"
  | "ml.t3.xlarge"
  | "ml.t3.2xlarge"
  | "ml.m5.large"
  | "ml.m5.xlarge"
  | "ml.m5.2xlarge"
  | "ml.m5.4xlarge"
  | "ml.m5.8xlarge"
  | "ml.m5.12xlarge"
  | "ml.m5.16xlarge"
  | "ml.m5.24xlarge"
  | "ml.m5d.large"
  | "ml.m5d.xlarge"
  | "ml.m5d.2xlarge"
  | "ml.m5d.4xlarge"
  | "ml.m5d.8xlarge"
  | "ml.m5d.12xlarge"
  | "ml.m5d.16xlarge"
  | "ml.m5d.24xlarge"
  | "ml.c5.large"
  | "ml.c5.xlarge"
  | "ml.c5.2xlarge"
  | "ml.c5.4xlarge"
  | "ml.c5.9xlarge"
  | "ml.c5.12xlarge"
  | "ml.c5.18xlarge"
  | "ml.c5.24xlarge"
  | "ml.p3.2xlarge"
  | "ml.p3.8xlarge"
  | "ml.p3.16xlarge"
  | "ml.p3dn.24xlarge"
  | "ml.g4dn.xlarge"
  | "ml.g4dn.2xlarge"
  | "ml.g4dn.4xlarge"
  | "ml.g4dn.8xlarge"
  | "ml.g4dn.12xlarge"
  | "ml.g4dn.16xlarge"
  | "ml.r5.large"
  | "ml.r5.xlarge"
  | "ml.r5.2xlarge"
  | "ml.r5.4xlarge"
  | "ml.r5.8xlarge"
  | "ml.r5.12xlarge"
  | "ml.r5.16xlarge"
  | "ml.r5.24xlarge"
  | "ml.g5.xlarge"
  | "ml.g5.2xlarge"
  | "ml.g5.4xlarge"
  | "ml.g5.8xlarge"
  | "ml.g5.16xlarge"
  | "ml.g5.12xlarge"
  | "ml.g5.24xlarge"
  | "ml.g5.48xlarge"
  | "ml.g6.xlarge"
  | "ml.g6.2xlarge"
  | "ml.g6.4xlarge"
  | "ml.g6.8xlarge"
  | "ml.g6.12xlarge"
  | "ml.g6.16xlarge"
  | "ml.g6.24xlarge"
  | "ml.g6.48xlarge"
  | "ml.g6e.xlarge"
  | "ml.g6e.2xlarge"
  | "ml.g6e.4xlarge"
  | "ml.g6e.8xlarge"
  | "ml.g6e.12xlarge"
  | "ml.g6e.16xlarge"
  | "ml.g6e.24xlarge"
  | "ml.g6e.48xlarge"
  | "ml.geospatial.interactive"
  | "ml.p4d.24xlarge"
  | "ml.p4de.24xlarge"
  | "ml.trn1.2xlarge"
  | "ml.trn1.32xlarge"
  | "ml.trn1n.32xlarge"
  | "ml.p5.48xlarge"
  | "ml.p5en.48xlarge"
  | "ml.p6-b200.48xlarge"
  | "ml.m6i.large"
  | "ml.m6i.xlarge"
  | "ml.m6i.2xlarge"
  | "ml.m6i.4xlarge"
  | "ml.m6i.8xlarge"
  | "ml.m6i.12xlarge"
  | "ml.m6i.16xlarge"
  | "ml.m6i.24xlarge"
  | "ml.m6i.32xlarge"
  | "ml.m7i.large"
  | "ml.m7i.xlarge"
  | "ml.m7i.2xlarge"
  | "ml.m7i.4xlarge"
  | "ml.m7i.8xlarge"
  | "ml.m7i.12xlarge"
  | "ml.m7i.16xlarge"
  | "ml.m7i.24xlarge"
  | "ml.m7i.48xlarge"
  | "ml.c6i.large"
  | "ml.c6i.xlarge"
  | "ml.c6i.2xlarge"
  | "ml.c6i.4xlarge"
  | "ml.c6i.8xlarge"
  | "ml.c6i.12xlarge"
  | "ml.c6i.16xlarge"
  | "ml.c6i.24xlarge"
  | "ml.c6i.32xlarge"
  | "ml.c7i.large"
  | "ml.c7i.xlarge"
  | "ml.c7i.2xlarge"
  | "ml.c7i.4xlarge"
  | "ml.c7i.8xlarge"
  | "ml.c7i.12xlarge"
  | "ml.c7i.16xlarge"
  | "ml.c7i.24xlarge"
  | "ml.c7i.48xlarge"
  | "ml.r6i.large"
  | "ml.r6i.xlarge"
  | "ml.r6i.2xlarge"
  | "ml.r6i.4xlarge"
  | "ml.r6i.8xlarge"
  | "ml.r6i.12xlarge"
  | "ml.r6i.16xlarge"
  | "ml.r6i.24xlarge"
  | "ml.r6i.32xlarge"
  | "ml.r7i.large"
  | "ml.r7i.xlarge"
  | "ml.r7i.2xlarge"
  | "ml.r7i.4xlarge"
  | "ml.r7i.8xlarge"
  | "ml.r7i.12xlarge"
  | "ml.r7i.16xlarge"
  | "ml.r7i.24xlarge"
  | "ml.r7i.48xlarge"
  | "ml.m6id.large"
  | "ml.m6id.xlarge"
  | "ml.m6id.2xlarge"
  | "ml.m6id.4xlarge"
  | "ml.m6id.8xlarge"
  | "ml.m6id.12xlarge"
  | "ml.m6id.16xlarge"
  | "ml.m6id.24xlarge"
  | "ml.m6id.32xlarge"
  | "ml.c6id.large"
  | "ml.c6id.xlarge"
  | "ml.c6id.2xlarge"
  | "ml.c6id.4xlarge"
  | "ml.c6id.8xlarge"
  | "ml.c6id.12xlarge"
  | "ml.c6id.16xlarge"
  | "ml.c6id.24xlarge"
  | "ml.c6id.32xlarge"
  | "ml.r6id.large"
  | "ml.r6id.xlarge"
  | "ml.r6id.2xlarge"
  | "ml.r6id.4xlarge"
  | "ml.r6id.8xlarge"
  | "ml.r6id.12xlarge"
  | "ml.r6id.16xlarge"
  | "ml.r6id.24xlarge"
  | "ml.r6id.32xlarge"
  | (string & {});
export const AppInstanceType = S.String;
export interface ResourceSpec {
  SageMakerImageArn?: string;
  SageMakerImageVersionArn?: string;
  SageMakerImageVersionAlias?: string;
  InstanceType?: AppInstanceType;
  LifecycleConfigArn?: string;
}
export const ResourceSpec = S.suspend(() =>
  S.Struct({
    SageMakerImageArn: S.optional(S.String),
    SageMakerImageVersionArn: S.optional(S.String),
    SageMakerImageVersionAlias: S.optional(S.String),
    InstanceType: S.optional(AppInstanceType),
    LifecycleConfigArn: S.optional(S.String),
  }),
).annotate({ identifier: "ResourceSpec" }) as any as S.Schema<ResourceSpec>;
export interface CreateAppRequest {
  DomainId?: string;
  UserProfileName?: string;
  SpaceName?: string;
  AppType?: AppType;
  AppName?: string;
  Tags?: Tag[];
  ResourceSpec?: ResourceSpec;
  RecoveryMode?: boolean;
}
export const CreateAppRequest = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    UserProfileName: S.optional(S.String),
    SpaceName: S.optional(S.String),
    AppType: S.optional(AppType),
    AppName: S.optional(S.String),
    Tags: S.optional(TagList),
    ResourceSpec: S.optional(ResourceSpec),
    RecoveryMode: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateAppRequest",
}) as any as S.Schema<CreateAppRequest>;
export interface CreateAppResponse {
  AppArn?: string;
}
export const CreateAppResponse = S.suspend(() =>
  S.Struct({ AppArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateAppResponse",
}) as any as S.Schema<CreateAppResponse>;
export interface KernelSpec {
  Name?: string;
  DisplayName?: string;
}
export const KernelSpec = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), DisplayName: S.optional(S.String) }),
).annotate({ identifier: "KernelSpec" }) as any as S.Schema<KernelSpec>;
export type KernelSpecs = KernelSpec[];
export const KernelSpecs = S.Array(KernelSpec);
export interface FileSystemConfig {
  MountPath?: string;
  DefaultUid?: number;
  DefaultGid?: number;
}
export const FileSystemConfig = S.suspend(() =>
  S.Struct({
    MountPath: S.optional(S.String),
    DefaultUid: S.optional(S.Number),
    DefaultGid: S.optional(S.Number),
  }),
).annotate({
  identifier: "FileSystemConfig",
}) as any as S.Schema<FileSystemConfig>;
export interface KernelGatewayImageConfig {
  KernelSpecs?: KernelSpec[];
  FileSystemConfig?: FileSystemConfig;
}
export const KernelGatewayImageConfig = S.suspend(() =>
  S.Struct({
    KernelSpecs: S.optional(KernelSpecs),
    FileSystemConfig: S.optional(FileSystemConfig),
  }),
).annotate({
  identifier: "KernelGatewayImageConfig",
}) as any as S.Schema<KernelGatewayImageConfig>;
export type CustomImageContainerArguments = string[];
export const CustomImageContainerArguments = S.Array(S.String);
export type CustomImageContainerEntrypoint = string[];
export const CustomImageContainerEntrypoint = S.Array(S.String);
export type CustomImageContainerEnvironmentVariables = {
  [key: string]: string | undefined;
};
export const CustomImageContainerEnvironmentVariables = S.Record(
  S.String,
  S.String.pipe(S.optional),
);
export interface ContainerConfig {
  ContainerArguments?: string[];
  ContainerEntrypoint?: string[];
  ContainerEnvironmentVariables?: { [key: string]: string | undefined };
}
export const ContainerConfig = S.suspend(() =>
  S.Struct({
    ContainerArguments: S.optional(CustomImageContainerArguments),
    ContainerEntrypoint: S.optional(CustomImageContainerEntrypoint),
    ContainerEnvironmentVariables: S.optional(
      CustomImageContainerEnvironmentVariables,
    ),
  }),
).annotate({
  identifier: "ContainerConfig",
}) as any as S.Schema<ContainerConfig>;
export interface JupyterLabAppImageConfig {
  FileSystemConfig?: FileSystemConfig;
  ContainerConfig?: ContainerConfig;
}
export const JupyterLabAppImageConfig = S.suspend(() =>
  S.Struct({
    FileSystemConfig: S.optional(FileSystemConfig),
    ContainerConfig: S.optional(ContainerConfig),
  }),
).annotate({
  identifier: "JupyterLabAppImageConfig",
}) as any as S.Schema<JupyterLabAppImageConfig>;
export interface CodeEditorAppImageConfig {
  FileSystemConfig?: FileSystemConfig;
  ContainerConfig?: ContainerConfig;
}
export const CodeEditorAppImageConfig = S.suspend(() =>
  S.Struct({
    FileSystemConfig: S.optional(FileSystemConfig),
    ContainerConfig: S.optional(ContainerConfig),
  }),
).annotate({
  identifier: "CodeEditorAppImageConfig",
}) as any as S.Schema<CodeEditorAppImageConfig>;
export interface CreateAppImageConfigRequest {
  AppImageConfigName?: string;
  Tags?: Tag[];
  KernelGatewayImageConfig?: KernelGatewayImageConfig;
  JupyterLabAppImageConfig?: JupyterLabAppImageConfig;
  CodeEditorAppImageConfig?: CodeEditorAppImageConfig;
}
export const CreateAppImageConfigRequest = S.suspend(() =>
  S.Struct({
    AppImageConfigName: S.optional(S.String),
    Tags: S.optional(TagList),
    KernelGatewayImageConfig: S.optional(KernelGatewayImageConfig),
    JupyterLabAppImageConfig: S.optional(JupyterLabAppImageConfig),
    CodeEditorAppImageConfig: S.optional(CodeEditorAppImageConfig),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateAppImageConfigRequest",
}) as any as S.Schema<CreateAppImageConfigRequest>;
export interface CreateAppImageConfigResponse {
  AppImageConfigArn?: string;
}
export const CreateAppImageConfigResponse = S.suspend(() =>
  S.Struct({ AppImageConfigArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateAppImageConfigResponse",
}) as any as S.Schema<CreateAppImageConfigResponse>;
export type ArtifactSourceIdType =
  | "MD5Hash"
  | "S3ETag"
  | "S3Version"
  | "Custom"
  | (string & {});
export const ArtifactSourceIdType = S.String;
export interface ArtifactSourceType {
  SourceIdType?: ArtifactSourceIdType;
  Value?: string;
}
export const ArtifactSourceType = S.suspend(() =>
  S.Struct({
    SourceIdType: S.optional(ArtifactSourceIdType),
    Value: S.optional(S.String),
  }),
).annotate({
  identifier: "ArtifactSourceType",
}) as any as S.Schema<ArtifactSourceType>;
export type ArtifactSourceTypes = ArtifactSourceType[];
export const ArtifactSourceTypes = S.Array(ArtifactSourceType);
export interface ArtifactSource {
  SourceUri?: string;
  SourceTypes?: ArtifactSourceType[];
}
export const ArtifactSource = S.suspend(() =>
  S.Struct({
    SourceUri: S.optional(S.String),
    SourceTypes: S.optional(ArtifactSourceTypes),
  }),
).annotate({ identifier: "ArtifactSource" }) as any as S.Schema<ArtifactSource>;
export type ArtifactProperties = { [key: string]: string | undefined };
export const ArtifactProperties = S.Record(S.String, S.String.pipe(S.optional));
export interface CreateArtifactRequest {
  ArtifactName?: string;
  Source?: ArtifactSource;
  ArtifactType?: string;
  Properties?: { [key: string]: string | undefined };
  MetadataProperties?: MetadataProperties;
  Tags?: Tag[];
}
export const CreateArtifactRequest = S.suspend(() =>
  S.Struct({
    ArtifactName: S.optional(S.String),
    Source: S.optional(ArtifactSource),
    ArtifactType: S.optional(S.String),
    Properties: S.optional(ArtifactProperties),
    MetadataProperties: S.optional(MetadataProperties),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateArtifactRequest",
}) as any as S.Schema<CreateArtifactRequest>;
export interface CreateArtifactResponse {
  ArtifactArn?: string;
}
export const CreateArtifactResponse = S.suspend(() =>
  S.Struct({ ArtifactArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateArtifactResponse",
}) as any as S.Schema<CreateArtifactResponse>;
export type AutoMLS3DataType =
  | "ManifestFile"
  | "S3Prefix"
  | "AugmentedManifestFile"
  | (string & {});
export const AutoMLS3DataType = S.String;
export interface AutoMLS3DataSource {
  S3DataType?: AutoMLS3DataType;
  S3Uri?: string;
}
export const AutoMLS3DataSource = S.suspend(() =>
  S.Struct({
    S3DataType: S.optional(AutoMLS3DataType),
    S3Uri: S.optional(S.String),
  }),
).annotate({
  identifier: "AutoMLS3DataSource",
}) as any as S.Schema<AutoMLS3DataSource>;
export interface AutoMLDataSource {
  S3DataSource?: AutoMLS3DataSource;
}
export const AutoMLDataSource = S.suspend(() =>
  S.Struct({ S3DataSource: S.optional(AutoMLS3DataSource) }),
).annotate({
  identifier: "AutoMLDataSource",
}) as any as S.Schema<AutoMLDataSource>;
export type AutoMLChannelType = "training" | "validation" | (string & {});
export const AutoMLChannelType = S.String;
export interface AutoMLChannel {
  DataSource?: AutoMLDataSource;
  CompressionType?: CompressionType;
  TargetAttributeName?: string;
  ContentType?: string;
  ChannelType?: AutoMLChannelType;
  SampleWeightAttributeName?: string;
}
export const AutoMLChannel = S.suspend(() =>
  S.Struct({
    DataSource: S.optional(AutoMLDataSource),
    CompressionType: S.optional(CompressionType),
    TargetAttributeName: S.optional(S.String),
    ContentType: S.optional(S.String),
    ChannelType: S.optional(AutoMLChannelType),
    SampleWeightAttributeName: S.optional(S.String),
  }),
).annotate({ identifier: "AutoMLChannel" }) as any as S.Schema<AutoMLChannel>;
export type AutoMLInputDataConfig = AutoMLChannel[];
export const AutoMLInputDataConfig = S.Array(AutoMLChannel);
export interface AutoMLOutputDataConfig {
  KmsKeyId?: string;
  S3OutputPath?: string;
}
export const AutoMLOutputDataConfig = S.suspend(() =>
  S.Struct({
    KmsKeyId: S.optional(S.String),
    S3OutputPath: S.optional(S.String),
  }),
).annotate({
  identifier: "AutoMLOutputDataConfig",
}) as any as S.Schema<AutoMLOutputDataConfig>;
export type ProblemType =
  | "BinaryClassification"
  | "MulticlassClassification"
  | "Regression"
  | (string & {});
export const ProblemType = S.String;
export type AutoMLMetricEnum =
  | "Accuracy"
  | "MSE"
  | "F1"
  | "F1macro"
  | "AUC"
  | "RMSE"
  | "BalancedAccuracy"
  | "R2"
  | "Recall"
  | "RecallMacro"
  | "Precision"
  | "PrecisionMacro"
  | "MAE"
  | "MAPE"
  | "MASE"
  | "WAPE"
  | "AverageWeightedQuantileLoss"
  | (string & {});
export const AutoMLMetricEnum = S.String;
export interface AutoMLJobObjective {
  MetricName?: AutoMLMetricEnum;
}
export const AutoMLJobObjective = S.suspend(() =>
  S.Struct({ MetricName: S.optional(AutoMLMetricEnum) }),
).annotate({
  identifier: "AutoMLJobObjective",
}) as any as S.Schema<AutoMLJobObjective>;
export interface AutoMLJobCompletionCriteria {
  MaxCandidates?: number;
  MaxRuntimePerTrainingJobInSeconds?: number;
  MaxAutoMLJobRuntimeInSeconds?: number;
}
export const AutoMLJobCompletionCriteria = S.suspend(() =>
  S.Struct({
    MaxCandidates: S.optional(S.Number),
    MaxRuntimePerTrainingJobInSeconds: S.optional(S.Number),
    MaxAutoMLJobRuntimeInSeconds: S.optional(S.Number),
  }),
).annotate({
  identifier: "AutoMLJobCompletionCriteria",
}) as any as S.Schema<AutoMLJobCompletionCriteria>;
export type VpcSecurityGroupIds = string[];
export const VpcSecurityGroupIds = S.Array(S.String);
export type Subnets = string[];
export const Subnets = S.Array(S.String);
export interface VpcConfig {
  SecurityGroupIds?: string[];
  Subnets?: string[];
}
export const VpcConfig = S.suspend(() =>
  S.Struct({
    SecurityGroupIds: S.optional(VpcSecurityGroupIds),
    Subnets: S.optional(Subnets),
  }),
).annotate({ identifier: "VpcConfig" }) as any as S.Schema<VpcConfig>;
export interface AutoMLSecurityConfig {
  VolumeKmsKeyId?: string;
  EnableInterContainerTrafficEncryption?: boolean;
  VpcConfig?: VpcConfig;
}
export const AutoMLSecurityConfig = S.suspend(() =>
  S.Struct({
    VolumeKmsKeyId: S.optional(S.String),
    EnableInterContainerTrafficEncryption: S.optional(S.Boolean),
    VpcConfig: S.optional(VpcConfig),
  }),
).annotate({
  identifier: "AutoMLSecurityConfig",
}) as any as S.Schema<AutoMLSecurityConfig>;
export type AutoMLAlgorithm =
  | "xgboost"
  | "linear-learner"
  | "mlp"
  | "lightgbm"
  | "catboost"
  | "randomforest"
  | "extra-trees"
  | "nn-torch"
  | "fastai"
  | "cnn-qr"
  | "deepar"
  | "prophet"
  | "npts"
  | "arima"
  | "ets"
  | (string & {});
export const AutoMLAlgorithm = S.String;
export type AutoMLAlgorithms = AutoMLAlgorithm[];
export const AutoMLAlgorithms = S.Array(AutoMLAlgorithm);
export interface AutoMLAlgorithmConfig {
  AutoMLAlgorithms?: AutoMLAlgorithm[];
}
export const AutoMLAlgorithmConfig = S.suspend(() =>
  S.Struct({ AutoMLAlgorithms: S.optional(AutoMLAlgorithms) }),
).annotate({
  identifier: "AutoMLAlgorithmConfig",
}) as any as S.Schema<AutoMLAlgorithmConfig>;
export type AutoMLAlgorithmsConfig = AutoMLAlgorithmConfig[];
export const AutoMLAlgorithmsConfig = S.Array(AutoMLAlgorithmConfig);
export interface AutoMLCandidateGenerationConfig {
  FeatureSpecificationS3Uri?: string;
  AlgorithmsConfig?: AutoMLAlgorithmConfig[];
}
export const AutoMLCandidateGenerationConfig = S.suspend(() =>
  S.Struct({
    FeatureSpecificationS3Uri: S.optional(S.String),
    AlgorithmsConfig: S.optional(AutoMLAlgorithmsConfig),
  }),
).annotate({
  identifier: "AutoMLCandidateGenerationConfig",
}) as any as S.Schema<AutoMLCandidateGenerationConfig>;
export interface AutoMLDataSplitConfig {
  ValidationFraction?: number;
}
export const AutoMLDataSplitConfig = S.suspend(() =>
  S.Struct({ ValidationFraction: S.optional(S.Number) }),
).annotate({
  identifier: "AutoMLDataSplitConfig",
}) as any as S.Schema<AutoMLDataSplitConfig>;
export type AutoMLMode =
  | "AUTO"
  | "ENSEMBLING"
  | "HYPERPARAMETER_TUNING"
  | (string & {});
export const AutoMLMode = S.String;
export interface AutoMLJobConfig {
  CompletionCriteria?: AutoMLJobCompletionCriteria;
  SecurityConfig?: AutoMLSecurityConfig;
  CandidateGenerationConfig?: AutoMLCandidateGenerationConfig;
  DataSplitConfig?: AutoMLDataSplitConfig;
  Mode?: AutoMLMode;
}
export const AutoMLJobConfig = S.suspend(() =>
  S.Struct({
    CompletionCriteria: S.optional(AutoMLJobCompletionCriteria),
    SecurityConfig: S.optional(AutoMLSecurityConfig),
    CandidateGenerationConfig: S.optional(AutoMLCandidateGenerationConfig),
    DataSplitConfig: S.optional(AutoMLDataSplitConfig),
    Mode: S.optional(AutoMLMode),
  }),
).annotate({
  identifier: "AutoMLJobConfig",
}) as any as S.Schema<AutoMLJobConfig>;
export interface ModelDeployConfig {
  AutoGenerateEndpointName?: boolean;
  EndpointName?: string;
}
export const ModelDeployConfig = S.suspend(() =>
  S.Struct({
    AutoGenerateEndpointName: S.optional(S.Boolean),
    EndpointName: S.optional(S.String),
  }),
).annotate({
  identifier: "ModelDeployConfig",
}) as any as S.Schema<ModelDeployConfig>;
export interface CreateAutoMLJobRequest {
  AutoMLJobName?: string;
  InputDataConfig?: AutoMLChannel[];
  OutputDataConfig?: AutoMLOutputDataConfig;
  ProblemType?: ProblemType;
  AutoMLJobObjective?: AutoMLJobObjective;
  AutoMLJobConfig?: AutoMLJobConfig;
  RoleArn?: string;
  GenerateCandidateDefinitionsOnly?: boolean;
  Tags?: Tag[];
  ModelDeployConfig?: ModelDeployConfig;
}
export const CreateAutoMLJobRequest = S.suspend(() =>
  S.Struct({
    AutoMLJobName: S.optional(S.String),
    InputDataConfig: S.optional(AutoMLInputDataConfig),
    OutputDataConfig: S.optional(AutoMLOutputDataConfig),
    ProblemType: S.optional(ProblemType),
    AutoMLJobObjective: S.optional(AutoMLJobObjective),
    AutoMLJobConfig: S.optional(AutoMLJobConfig),
    RoleArn: S.optional(S.String),
    GenerateCandidateDefinitionsOnly: S.optional(S.Boolean),
    Tags: S.optional(TagList),
    ModelDeployConfig: S.optional(ModelDeployConfig),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateAutoMLJobRequest",
}) as any as S.Schema<CreateAutoMLJobRequest>;
export interface CreateAutoMLJobResponse {
  AutoMLJobArn: string;
}
export const CreateAutoMLJobResponse = S.suspend(() =>
  S.Struct({ AutoMLJobArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateAutoMLJobResponse",
}) as any as S.Schema<CreateAutoMLJobResponse>;
export interface AutoMLJobChannel {
  ChannelType?: AutoMLChannelType;
  ContentType?: string;
  CompressionType?: CompressionType;
  DataSource?: AutoMLDataSource;
}
export const AutoMLJobChannel = S.suspend(() =>
  S.Struct({
    ChannelType: S.optional(AutoMLChannelType),
    ContentType: S.optional(S.String),
    CompressionType: S.optional(CompressionType),
    DataSource: S.optional(AutoMLDataSource),
  }),
).annotate({
  identifier: "AutoMLJobChannel",
}) as any as S.Schema<AutoMLJobChannel>;
export type AutoMLJobInputDataConfig = AutoMLJobChannel[];
export const AutoMLJobInputDataConfig = S.Array(AutoMLJobChannel);
export interface ImageClassificationJobConfig {
  CompletionCriteria?: AutoMLJobCompletionCriteria;
}
export const ImageClassificationJobConfig = S.suspend(() =>
  S.Struct({ CompletionCriteria: S.optional(AutoMLJobCompletionCriteria) }),
).annotate({
  identifier: "ImageClassificationJobConfig",
}) as any as S.Schema<ImageClassificationJobConfig>;
export interface TextClassificationJobConfig {
  CompletionCriteria?: AutoMLJobCompletionCriteria;
  ContentColumn?: string;
  TargetLabelColumn?: string;
}
export const TextClassificationJobConfig = S.suspend(() =>
  S.Struct({
    CompletionCriteria: S.optional(AutoMLJobCompletionCriteria),
    ContentColumn: S.optional(S.String),
    TargetLabelColumn: S.optional(S.String),
  }),
).annotate({
  identifier: "TextClassificationJobConfig",
}) as any as S.Schema<TextClassificationJobConfig>;
export type ForecastQuantiles = string[];
export const ForecastQuantiles = S.Array(S.String);
export type FillingType =
  | "frontfill"
  | "middlefill"
  | "backfill"
  | "futurefill"
  | "frontfill_value"
  | "middlefill_value"
  | "backfill_value"
  | "futurefill_value"
  | (string & {});
export const FillingType = S.String;
export type FillingTransformationMap = { [key in FillingType]?: string };
export const FillingTransformationMap = S.Record(
  FillingType,
  S.String.pipe(S.optional),
);
export type FillingTransformations = {
  [key: string]: { [key: string]: string | undefined } | undefined;
};
export const FillingTransformations = S.Record(
  S.String,
  FillingTransformationMap.pipe(S.optional),
);
export type AggregationTransformationValue =
  | "sum"
  | "avg"
  | "first"
  | "min"
  | "max"
  | (string & {});
export const AggregationTransformationValue = S.String;
export type AggregationTransformations = {
  [key: string]: AggregationTransformationValue | undefined;
};
export const AggregationTransformations = S.Record(
  S.String,
  AggregationTransformationValue.pipe(S.optional),
);
export interface TimeSeriesTransformations {
  Filling?: {
    [key: string]: { [key: string]: string | undefined } | undefined;
  };
  Aggregation?: { [key: string]: AggregationTransformationValue | undefined };
}
export const TimeSeriesTransformations = S.suspend(() =>
  S.Struct({
    Filling: S.optional(FillingTransformations),
    Aggregation: S.optional(AggregationTransformations),
  }),
).annotate({
  identifier: "TimeSeriesTransformations",
}) as any as S.Schema<TimeSeriesTransformations>;
export type GroupingAttributeNames = string[];
export const GroupingAttributeNames = S.Array(S.String);
export interface TimeSeriesConfig {
  TargetAttributeName?: string;
  TimestampAttributeName?: string;
  ItemIdentifierAttributeName?: string;
  GroupingAttributeNames?: string[];
}
export const TimeSeriesConfig = S.suspend(() =>
  S.Struct({
    TargetAttributeName: S.optional(S.String),
    TimestampAttributeName: S.optional(S.String),
    ItemIdentifierAttributeName: S.optional(S.String),
    GroupingAttributeNames: S.optional(GroupingAttributeNames),
  }),
).annotate({
  identifier: "TimeSeriesConfig",
}) as any as S.Schema<TimeSeriesConfig>;
export interface HolidayConfigAttributes {
  CountryCode?: string;
}
export const HolidayConfigAttributes = S.suspend(() =>
  S.Struct({ CountryCode: S.optional(S.String) }),
).annotate({
  identifier: "HolidayConfigAttributes",
}) as any as S.Schema<HolidayConfigAttributes>;
export type HolidayConfig = HolidayConfigAttributes[];
export const HolidayConfig = S.Array(HolidayConfigAttributes);
export interface CandidateGenerationConfig {
  AlgorithmsConfig?: AutoMLAlgorithmConfig[];
}
export const CandidateGenerationConfig = S.suspend(() =>
  S.Struct({ AlgorithmsConfig: S.optional(AutoMLAlgorithmsConfig) }),
).annotate({
  identifier: "CandidateGenerationConfig",
}) as any as S.Schema<CandidateGenerationConfig>;
export interface TimeSeriesForecastingJobConfig {
  FeatureSpecificationS3Uri?: string;
  CompletionCriteria?: AutoMLJobCompletionCriteria;
  ForecastFrequency?: string;
  ForecastHorizon?: number;
  ForecastQuantiles?: string[];
  Transformations?: TimeSeriesTransformations;
  TimeSeriesConfig?: TimeSeriesConfig;
  HolidayConfig?: HolidayConfigAttributes[];
  CandidateGenerationConfig?: CandidateGenerationConfig;
}
export const TimeSeriesForecastingJobConfig = S.suspend(() =>
  S.Struct({
    FeatureSpecificationS3Uri: S.optional(S.String),
    CompletionCriteria: S.optional(AutoMLJobCompletionCriteria),
    ForecastFrequency: S.optional(S.String),
    ForecastHorizon: S.optional(S.Number),
    ForecastQuantiles: S.optional(ForecastQuantiles),
    Transformations: S.optional(TimeSeriesTransformations),
    TimeSeriesConfig: S.optional(TimeSeriesConfig),
    HolidayConfig: S.optional(HolidayConfig),
    CandidateGenerationConfig: S.optional(CandidateGenerationConfig),
  }),
).annotate({
  identifier: "TimeSeriesForecastingJobConfig",
}) as any as S.Schema<TimeSeriesForecastingJobConfig>;
export interface TabularJobConfig {
  CandidateGenerationConfig?: CandidateGenerationConfig;
  CompletionCriteria?: AutoMLJobCompletionCriteria;
  FeatureSpecificationS3Uri?: string;
  Mode?: AutoMLMode;
  GenerateCandidateDefinitionsOnly?: boolean;
  ProblemType?: ProblemType;
  TargetAttributeName?: string;
  SampleWeightAttributeName?: string;
}
export const TabularJobConfig = S.suspend(() =>
  S.Struct({
    CandidateGenerationConfig: S.optional(CandidateGenerationConfig),
    CompletionCriteria: S.optional(AutoMLJobCompletionCriteria),
    FeatureSpecificationS3Uri: S.optional(S.String),
    Mode: S.optional(AutoMLMode),
    GenerateCandidateDefinitionsOnly: S.optional(S.Boolean),
    ProblemType: S.optional(ProblemType),
    TargetAttributeName: S.optional(S.String),
    SampleWeightAttributeName: S.optional(S.String),
  }),
).annotate({
  identifier: "TabularJobConfig",
}) as any as S.Schema<TabularJobConfig>;
export type TextGenerationHyperParameters = {
  [key: string]: string | undefined;
};
export const TextGenerationHyperParameters = S.Record(
  S.String,
  S.String.pipe(S.optional),
);
export interface TextGenerationJobConfig {
  CompletionCriteria?: AutoMLJobCompletionCriteria;
  BaseModelName?: string;
  TextGenerationHyperParameters?: { [key: string]: string | undefined };
  ModelAccessConfig?: ModelAccessConfig;
}
export const TextGenerationJobConfig = S.suspend(() =>
  S.Struct({
    CompletionCriteria: S.optional(AutoMLJobCompletionCriteria),
    BaseModelName: S.optional(S.String),
    TextGenerationHyperParameters: S.optional(TextGenerationHyperParameters),
    ModelAccessConfig: S.optional(ModelAccessConfig),
  }),
).annotate({
  identifier: "TextGenerationJobConfig",
}) as any as S.Schema<TextGenerationJobConfig>;
export type AutoMLProblemTypeConfig =
  | {
      ImageClassificationJobConfig: ImageClassificationJobConfig;
      TextClassificationJobConfig?: never;
      TimeSeriesForecastingJobConfig?: never;
      TabularJobConfig?: never;
      TextGenerationJobConfig?: never;
    }
  | {
      ImageClassificationJobConfig?: never;
      TextClassificationJobConfig: TextClassificationJobConfig;
      TimeSeriesForecastingJobConfig?: never;
      TabularJobConfig?: never;
      TextGenerationJobConfig?: never;
    }
  | {
      ImageClassificationJobConfig?: never;
      TextClassificationJobConfig?: never;
      TimeSeriesForecastingJobConfig: TimeSeriesForecastingJobConfig;
      TabularJobConfig?: never;
      TextGenerationJobConfig?: never;
    }
  | {
      ImageClassificationJobConfig?: never;
      TextClassificationJobConfig?: never;
      TimeSeriesForecastingJobConfig?: never;
      TabularJobConfig: TabularJobConfig;
      TextGenerationJobConfig?: never;
    }
  | {
      ImageClassificationJobConfig?: never;
      TextClassificationJobConfig?: never;
      TimeSeriesForecastingJobConfig?: never;
      TabularJobConfig?: never;
      TextGenerationJobConfig: TextGenerationJobConfig;
    };
export const AutoMLProblemTypeConfig = S.Union([
  S.Struct({ ImageClassificationJobConfig: ImageClassificationJobConfig }),
  S.Struct({ TextClassificationJobConfig: TextClassificationJobConfig }),
  S.Struct({ TimeSeriesForecastingJobConfig: TimeSeriesForecastingJobConfig }),
  S.Struct({ TabularJobConfig: TabularJobConfig }),
  S.Struct({ TextGenerationJobConfig: TextGenerationJobConfig }),
]);
export interface EmrServerlessComputeConfig {
  ExecutionRoleARN?: string;
}
export const EmrServerlessComputeConfig = S.suspend(() =>
  S.Struct({ ExecutionRoleARN: S.optional(S.String) }),
).annotate({
  identifier: "EmrServerlessComputeConfig",
}) as any as S.Schema<EmrServerlessComputeConfig>;
export interface AutoMLComputeConfig {
  EmrServerlessComputeConfig?: EmrServerlessComputeConfig;
}
export const AutoMLComputeConfig = S.suspend(() =>
  S.Struct({
    EmrServerlessComputeConfig: S.optional(EmrServerlessComputeConfig),
  }),
).annotate({
  identifier: "AutoMLComputeConfig",
}) as any as S.Schema<AutoMLComputeConfig>;
export interface CreateAutoMLJobV2Request {
  AutoMLJobName?: string;
  AutoMLJobInputDataConfig?: AutoMLJobChannel[];
  OutputDataConfig?: AutoMLOutputDataConfig;
  AutoMLProblemTypeConfig?: AutoMLProblemTypeConfig;
  RoleArn?: string;
  Tags?: Tag[];
  SecurityConfig?: AutoMLSecurityConfig;
  AutoMLJobObjective?: AutoMLJobObjective;
  ModelDeployConfig?: ModelDeployConfig;
  DataSplitConfig?: AutoMLDataSplitConfig;
  AutoMLComputeConfig?: AutoMLComputeConfig;
}
export const CreateAutoMLJobV2Request = S.suspend(() =>
  S.Struct({
    AutoMLJobName: S.optional(S.String),
    AutoMLJobInputDataConfig: S.optional(AutoMLJobInputDataConfig),
    OutputDataConfig: S.optional(AutoMLOutputDataConfig),
    AutoMLProblemTypeConfig: S.optional(AutoMLProblemTypeConfig),
    RoleArn: S.optional(S.String),
    Tags: S.optional(TagList),
    SecurityConfig: S.optional(AutoMLSecurityConfig),
    AutoMLJobObjective: S.optional(AutoMLJobObjective),
    ModelDeployConfig: S.optional(ModelDeployConfig),
    DataSplitConfig: S.optional(AutoMLDataSplitConfig),
    AutoMLComputeConfig: S.optional(AutoMLComputeConfig),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateAutoMLJobV2Request",
}) as any as S.Schema<CreateAutoMLJobV2Request>;
export interface CreateAutoMLJobV2Response {
  AutoMLJobArn: string;
}
export const CreateAutoMLJobV2Response = S.suspend(() =>
  S.Struct({ AutoMLJobArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateAutoMLJobV2Response",
}) as any as S.Schema<CreateAutoMLJobV2Response>;
export type ClusterInstanceType =
  | "ml.p4d.24xlarge"
  | "ml.p4de.24xlarge"
  | "ml.p5.48xlarge"
  | "ml.p5.4xlarge"
  | "ml.p6e-gb200.36xlarge"
  | "ml.trn1.32xlarge"
  | "ml.trn1n.32xlarge"
  | "ml.g5.xlarge"
  | "ml.g5.2xlarge"
  | "ml.g5.4xlarge"
  | "ml.g5.8xlarge"
  | "ml.g5.12xlarge"
  | "ml.g5.16xlarge"
  | "ml.g5.24xlarge"
  | "ml.g5.48xlarge"
  | "ml.c5.large"
  | "ml.c5.xlarge"
  | "ml.c5.2xlarge"
  | "ml.c5.4xlarge"
  | "ml.c5.9xlarge"
  | "ml.c5.12xlarge"
  | "ml.c5.18xlarge"
  | "ml.c5.24xlarge"
  | "ml.c5n.large"
  | "ml.c5n.2xlarge"
  | "ml.c5n.4xlarge"
  | "ml.c5n.9xlarge"
  | "ml.c5n.18xlarge"
  | "ml.m5.large"
  | "ml.m5.xlarge"
  | "ml.m5.2xlarge"
  | "ml.m5.4xlarge"
  | "ml.m5.8xlarge"
  | "ml.m5.12xlarge"
  | "ml.m5.16xlarge"
  | "ml.m5.24xlarge"
  | "ml.t3.medium"
  | "ml.t3.large"
  | "ml.t3.xlarge"
  | "ml.t3.2xlarge"
  | "ml.g6.xlarge"
  | "ml.g6.2xlarge"
  | "ml.g6.4xlarge"
  | "ml.g6.8xlarge"
  | "ml.g6.16xlarge"
  | "ml.g6.12xlarge"
  | "ml.g6.24xlarge"
  | "ml.g6.48xlarge"
  | "ml.gr6.4xlarge"
  | "ml.gr6.8xlarge"
  | "ml.g6e.xlarge"
  | "ml.g6e.2xlarge"
  | "ml.g6e.4xlarge"
  | "ml.g6e.8xlarge"
  | "ml.g6e.16xlarge"
  | "ml.g6e.12xlarge"
  | "ml.g6e.24xlarge"
  | "ml.g6e.48xlarge"
  | "ml.p5e.48xlarge"
  | "ml.p5en.48xlarge"
  | "ml.p6-b200.48xlarge"
  | "ml.trn2.3xlarge"
  | "ml.trn2.48xlarge"
  | "ml.c6i.large"
  | "ml.c6i.xlarge"
  | "ml.c6i.2xlarge"
  | "ml.c6i.4xlarge"
  | "ml.c6i.8xlarge"
  | "ml.c6i.12xlarge"
  | "ml.c6i.16xlarge"
  | "ml.c6i.24xlarge"
  | "ml.c6i.32xlarge"
  | "ml.m6i.large"
  | "ml.m6i.xlarge"
  | "ml.m6i.2xlarge"
  | "ml.m6i.4xlarge"
  | "ml.m6i.8xlarge"
  | "ml.m6i.12xlarge"
  | "ml.m6i.16xlarge"
  | "ml.m6i.24xlarge"
  | "ml.m6i.32xlarge"
  | "ml.r6i.large"
  | "ml.r6i.xlarge"
  | "ml.r6i.2xlarge"
  | "ml.r6i.4xlarge"
  | "ml.r6i.8xlarge"
  | "ml.r6i.12xlarge"
  | "ml.r6i.16xlarge"
  | "ml.r6i.24xlarge"
  | "ml.r6i.32xlarge"
  | "ml.i3en.large"
  | "ml.i3en.xlarge"
  | "ml.i3en.2xlarge"
  | "ml.i3en.3xlarge"
  | "ml.i3en.6xlarge"
  | "ml.i3en.12xlarge"
  | "ml.i3en.24xlarge"
  | "ml.m7i.large"
  | "ml.m7i.xlarge"
  | "ml.m7i.2xlarge"
  | "ml.m7i.4xlarge"
  | "ml.m7i.8xlarge"
  | "ml.m7i.12xlarge"
  | "ml.m7i.16xlarge"
  | "ml.m7i.24xlarge"
  | "ml.m7i.48xlarge"
  | "ml.r7i.large"
  | "ml.r7i.xlarge"
  | "ml.r7i.2xlarge"
  | "ml.r7i.4xlarge"
  | "ml.r7i.8xlarge"
  | "ml.r7i.12xlarge"
  | "ml.r7i.16xlarge"
  | "ml.r7i.24xlarge"
  | "ml.r7i.48xlarge"
  | "ml.p6-b300.48xlarge"
  | (string & {});
export const ClusterInstanceType = S.String;
export interface ClusterLifeCycleConfig {
  SourceS3Uri?: string;
  OnCreate?: string;
}
export const ClusterLifeCycleConfig = S.suspend(() =>
  S.Struct({
    SourceS3Uri: S.optional(S.String),
    OnCreate: S.optional(S.String),
  }),
).annotate({
  identifier: "ClusterLifeCycleConfig",
}) as any as S.Schema<ClusterLifeCycleConfig>;
export interface ClusterEbsVolumeConfig {
  VolumeSizeInGB?: number;
  VolumeKmsKeyId?: string;
  RootVolume?: boolean;
}
export const ClusterEbsVolumeConfig = S.suspend(() =>
  S.Struct({
    VolumeSizeInGB: S.optional(S.Number),
    VolumeKmsKeyId: S.optional(S.String),
    RootVolume: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "ClusterEbsVolumeConfig",
}) as any as S.Schema<ClusterEbsVolumeConfig>;
export type ClusterInstanceStorageConfig = {
  EbsVolumeConfig: ClusterEbsVolumeConfig;
};
export const ClusterInstanceStorageConfig = S.Union([
  S.Struct({ EbsVolumeConfig: ClusterEbsVolumeConfig }),
]);
export type ClusterInstanceStorageConfigs = ClusterInstanceStorageConfig[];
export const ClusterInstanceStorageConfigs = S.Array(
  ClusterInstanceStorageConfig,
);
export type DeepHealthCheckType =
  | "InstanceStress"
  | "InstanceConnectivity"
  | (string & {});
export const DeepHealthCheckType = S.String;
export type OnStartDeepHealthChecks = DeepHealthCheckType[];
export const OnStartDeepHealthChecks = S.Array(DeepHealthCheckType);
export type NodeUnavailabilityType =
  | "INSTANCE_COUNT"
  | "CAPACITY_PERCENTAGE"
  | (string & {});
export const NodeUnavailabilityType = S.String;
export interface CapacitySizeConfig {
  Type?: NodeUnavailabilityType;
  Value?: number;
}
export const CapacitySizeConfig = S.suspend(() =>
  S.Struct({
    Type: S.optional(NodeUnavailabilityType),
    Value: S.optional(S.Number),
  }),
).annotate({
  identifier: "CapacitySizeConfig",
}) as any as S.Schema<CapacitySizeConfig>;
export interface RollingDeploymentPolicy {
  MaximumBatchSize?: CapacitySizeConfig;
  RollbackMaximumBatchSize?: CapacitySizeConfig;
}
export const RollingDeploymentPolicy = S.suspend(() =>
  S.Struct({
    MaximumBatchSize: S.optional(CapacitySizeConfig),
    RollbackMaximumBatchSize: S.optional(CapacitySizeConfig),
  }),
).annotate({
  identifier: "RollingDeploymentPolicy",
}) as any as S.Schema<RollingDeploymentPolicy>;
export interface AlarmDetails {
  AlarmName?: string;
}
export const AlarmDetails = S.suspend(() =>
  S.Struct({ AlarmName: S.optional(S.String) }),
).annotate({ identifier: "AlarmDetails" }) as any as S.Schema<AlarmDetails>;
export type AutoRollbackAlarms = AlarmDetails[];
export const AutoRollbackAlarms = S.Array(AlarmDetails);
export interface DeploymentConfiguration {
  RollingUpdatePolicy?: RollingDeploymentPolicy;
  WaitIntervalInSeconds?: number;
  AutoRollbackConfiguration?: AlarmDetails[];
}
export const DeploymentConfiguration = S.suspend(() =>
  S.Struct({
    RollingUpdatePolicy: S.optional(RollingDeploymentPolicy),
    WaitIntervalInSeconds: S.optional(S.Number),
    AutoRollbackConfiguration: S.optional(AutoRollbackAlarms),
  }),
).annotate({
  identifier: "DeploymentConfiguration",
}) as any as S.Schema<DeploymentConfiguration>;
export interface ScheduledUpdateConfig {
  ScheduleExpression?: string;
  DeploymentConfig?: DeploymentConfiguration;
}
export const ScheduledUpdateConfig = S.suspend(() =>
  S.Struct({
    ScheduleExpression: S.optional(S.String),
    DeploymentConfig: S.optional(DeploymentConfiguration),
  }),
).annotate({
  identifier: "ScheduledUpdateConfig",
}) as any as S.Schema<ScheduledUpdateConfig>;
export type ClusterKubernetesLabels = { [key: string]: string | undefined };
export const ClusterKubernetesLabels = S.Record(
  S.String,
  S.String.pipe(S.optional),
);
export type ClusterKubernetesTaintEffect =
  | "NoSchedule"
  | "PreferNoSchedule"
  | "NoExecute"
  | (string & {});
export const ClusterKubernetesTaintEffect = S.String;
export interface ClusterKubernetesTaint {
  Key: string;
  Value?: string;
  Effect: ClusterKubernetesTaintEffect;
}
export const ClusterKubernetesTaint = S.suspend(() =>
  S.Struct({
    Key: S.String,
    Value: S.optional(S.String),
    Effect: ClusterKubernetesTaintEffect,
  }),
).annotate({
  identifier: "ClusterKubernetesTaint",
}) as any as S.Schema<ClusterKubernetesTaint>;
export type ClusterKubernetesTaints = ClusterKubernetesTaint[];
export const ClusterKubernetesTaints = S.Array(ClusterKubernetesTaint);
export interface ClusterKubernetesConfig {
  Labels?: { [key: string]: string | undefined };
  Taints?: ClusterKubernetesTaint[];
}
export const ClusterKubernetesConfig = S.suspend(() =>
  S.Struct({
    Labels: S.optional(ClusterKubernetesLabels),
    Taints: S.optional(ClusterKubernetesTaints),
  }),
).annotate({
  identifier: "ClusterKubernetesConfig",
}) as any as S.Schema<ClusterKubernetesConfig>;
export interface ClusterSpotOptions {}
export const ClusterSpotOptions = S.suspend(() => S.Struct({})).annotate({
  identifier: "ClusterSpotOptions",
}) as any as S.Schema<ClusterSpotOptions>;
export interface ClusterOnDemandOptions {}
export const ClusterOnDemandOptions = S.suspend(() => S.Struct({})).annotate({
  identifier: "ClusterOnDemandOptions",
}) as any as S.Schema<ClusterOnDemandOptions>;
export interface ClusterCapacityRequirements {
  Spot?: ClusterSpotOptions;
  OnDemand?: ClusterOnDemandOptions;
}
export const ClusterCapacityRequirements = S.suspend(() =>
  S.Struct({
    Spot: S.optional(ClusterSpotOptions),
    OnDemand: S.optional(ClusterOnDemandOptions),
  }),
).annotate({
  identifier: "ClusterCapacityRequirements",
}) as any as S.Schema<ClusterCapacityRequirements>;
export interface ClusterInstanceGroupSpecification {
  InstanceCount?: number;
  MinInstanceCount?: number;
  InstanceGroupName?: string;
  InstanceType?: ClusterInstanceType;
  LifeCycleConfig?: ClusterLifeCycleConfig;
  ExecutionRole?: string;
  ThreadsPerCore?: number;
  InstanceStorageConfigs?: ClusterInstanceStorageConfig[];
  OnStartDeepHealthChecks?: DeepHealthCheckType[];
  TrainingPlanArn?: string;
  OverrideVpcConfig?: VpcConfig;
  ScheduledUpdateConfig?: ScheduledUpdateConfig;
  ImageId?: string;
  KubernetesConfig?: ClusterKubernetesConfig;
  CapacityRequirements?: ClusterCapacityRequirements;
}
export const ClusterInstanceGroupSpecification = S.suspend(() =>
  S.Struct({
    InstanceCount: S.optional(S.Number),
    MinInstanceCount: S.optional(S.Number),
    InstanceGroupName: S.optional(S.String),
    InstanceType: S.optional(ClusterInstanceType),
    LifeCycleConfig: S.optional(ClusterLifeCycleConfig),
    ExecutionRole: S.optional(S.String),
    ThreadsPerCore: S.optional(S.Number),
    InstanceStorageConfigs: S.optional(ClusterInstanceStorageConfigs),
    OnStartDeepHealthChecks: S.optional(OnStartDeepHealthChecks),
    TrainingPlanArn: S.optional(S.String),
    OverrideVpcConfig: S.optional(VpcConfig),
    ScheduledUpdateConfig: S.optional(ScheduledUpdateConfig),
    ImageId: S.optional(S.String),
    KubernetesConfig: S.optional(ClusterKubernetesConfig),
    CapacityRequirements: S.optional(ClusterCapacityRequirements),
  }),
).annotate({
  identifier: "ClusterInstanceGroupSpecification",
}) as any as S.Schema<ClusterInstanceGroupSpecification>;
export type ClusterInstanceGroupSpecifications =
  ClusterInstanceGroupSpecification[];
export const ClusterInstanceGroupSpecifications = S.Array(
  ClusterInstanceGroupSpecification,
);
export interface FSxLustreConfig {
  SizeInGiB?: number;
  PerUnitStorageThroughput?: number;
}
export const FSxLustreConfig = S.suspend(() =>
  S.Struct({
    SizeInGiB: S.optional(S.Number),
    PerUnitStorageThroughput: S.optional(S.Number),
  }),
).annotate({
  identifier: "FSxLustreConfig",
}) as any as S.Schema<FSxLustreConfig>;
export interface EnvironmentConfig {
  FSxLustreConfig?: FSxLustreConfig;
}
export const EnvironmentConfig = S.suspend(() =>
  S.Struct({ FSxLustreConfig: S.optional(FSxLustreConfig) }),
).annotate({
  identifier: "EnvironmentConfig",
}) as any as S.Schema<EnvironmentConfig>;
export interface ClusterRestrictedInstanceGroupSpecification {
  InstanceCount?: number;
  InstanceGroupName?: string;
  InstanceType?: ClusterInstanceType;
  ExecutionRole?: string;
  ThreadsPerCore?: number;
  InstanceStorageConfigs?: ClusterInstanceStorageConfig[];
  OnStartDeepHealthChecks?: DeepHealthCheckType[];
  TrainingPlanArn?: string;
  OverrideVpcConfig?: VpcConfig;
  ScheduledUpdateConfig?: ScheduledUpdateConfig;
  EnvironmentConfig?: EnvironmentConfig;
}
export const ClusterRestrictedInstanceGroupSpecification = S.suspend(() =>
  S.Struct({
    InstanceCount: S.optional(S.Number),
    InstanceGroupName: S.optional(S.String),
    InstanceType: S.optional(ClusterInstanceType),
    ExecutionRole: S.optional(S.String),
    ThreadsPerCore: S.optional(S.Number),
    InstanceStorageConfigs: S.optional(ClusterInstanceStorageConfigs),
    OnStartDeepHealthChecks: S.optional(OnStartDeepHealthChecks),
    TrainingPlanArn: S.optional(S.String),
    OverrideVpcConfig: S.optional(VpcConfig),
    ScheduledUpdateConfig: S.optional(ScheduledUpdateConfig),
    EnvironmentConfig: S.optional(EnvironmentConfig),
  }),
).annotate({
  identifier: "ClusterRestrictedInstanceGroupSpecification",
}) as any as S.Schema<ClusterRestrictedInstanceGroupSpecification>;
export type ClusterRestrictedInstanceGroupSpecifications =
  ClusterRestrictedInstanceGroupSpecification[];
export const ClusterRestrictedInstanceGroupSpecifications = S.Array(
  ClusterRestrictedInstanceGroupSpecification,
);
export interface ClusterOrchestratorEksConfig {
  ClusterArn?: string;
}
export const ClusterOrchestratorEksConfig = S.suspend(() =>
  S.Struct({ ClusterArn: S.optional(S.String) }),
).annotate({
  identifier: "ClusterOrchestratorEksConfig",
}) as any as S.Schema<ClusterOrchestratorEksConfig>;
export interface ClusterOrchestrator {
  Eks?: ClusterOrchestratorEksConfig;
}
export const ClusterOrchestrator = S.suspend(() =>
  S.Struct({ Eks: S.optional(ClusterOrchestratorEksConfig) }),
).annotate({
  identifier: "ClusterOrchestrator",
}) as any as S.Schema<ClusterOrchestrator>;
export type ClusterNodeRecovery = "Automatic" | "None" | (string & {});
export const ClusterNodeRecovery = S.String;
export type ClusterConfigMode = "Enable" | "Disable" | (string & {});
export const ClusterConfigMode = S.String;
export interface ClusterTieredStorageConfig {
  Mode?: ClusterConfigMode;
  InstanceMemoryAllocationPercentage?: number;
}
export const ClusterTieredStorageConfig = S.suspend(() =>
  S.Struct({
    Mode: S.optional(ClusterConfigMode),
    InstanceMemoryAllocationPercentage: S.optional(S.Number),
  }),
).annotate({
  identifier: "ClusterTieredStorageConfig",
}) as any as S.Schema<ClusterTieredStorageConfig>;
export type ClusterNodeProvisioningMode = "Continuous" | (string & {});
export const ClusterNodeProvisioningMode = S.String;
export type ClusterAutoScalingMode = "Enable" | "Disable" | (string & {});
export const ClusterAutoScalingMode = S.String;
export type ClusterAutoScalerType = "Karpenter" | (string & {});
export const ClusterAutoScalerType = S.String;
export interface ClusterAutoScalingConfig {
  Mode: ClusterAutoScalingMode;
  AutoScalerType?: ClusterAutoScalerType;
}
export const ClusterAutoScalingConfig = S.suspend(() =>
  S.Struct({
    Mode: ClusterAutoScalingMode,
    AutoScalerType: S.optional(ClusterAutoScalerType),
  }),
).annotate({
  identifier: "ClusterAutoScalingConfig",
}) as any as S.Schema<ClusterAutoScalingConfig>;
export interface CreateClusterRequest {
  ClusterName?: string;
  InstanceGroups?: ClusterInstanceGroupSpecification[];
  RestrictedInstanceGroups?: ClusterRestrictedInstanceGroupSpecification[];
  VpcConfig?: VpcConfig;
  Tags?: Tag[];
  Orchestrator?: ClusterOrchestrator;
  NodeRecovery?: ClusterNodeRecovery;
  TieredStorageConfig?: ClusterTieredStorageConfig;
  NodeProvisioningMode?: ClusterNodeProvisioningMode;
  ClusterRole?: string;
  AutoScaling?: ClusterAutoScalingConfig;
}
export const CreateClusterRequest = S.suspend(() =>
  S.Struct({
    ClusterName: S.optional(S.String),
    InstanceGroups: S.optional(ClusterInstanceGroupSpecifications),
    RestrictedInstanceGroups: S.optional(
      ClusterRestrictedInstanceGroupSpecifications,
    ),
    VpcConfig: S.optional(VpcConfig),
    Tags: S.optional(TagList),
    Orchestrator: S.optional(ClusterOrchestrator),
    NodeRecovery: S.optional(ClusterNodeRecovery),
    TieredStorageConfig: S.optional(ClusterTieredStorageConfig),
    NodeProvisioningMode: S.optional(ClusterNodeProvisioningMode),
    ClusterRole: S.optional(S.String),
    AutoScaling: S.optional(ClusterAutoScalingConfig),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateClusterRequest",
}) as any as S.Schema<CreateClusterRequest>;
export interface CreateClusterResponse {
  ClusterArn: string;
}
export const CreateClusterResponse = S.suspend(() =>
  S.Struct({ ClusterArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateClusterResponse",
}) as any as S.Schema<CreateClusterResponse>;
export interface PriorityClass {
  Name?: string;
  Weight?: number;
}
export const PriorityClass = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Weight: S.optional(S.Number) }),
).annotate({ identifier: "PriorityClass" }) as any as S.Schema<PriorityClass>;
export type PriorityClassList = PriorityClass[];
export const PriorityClassList = S.Array(PriorityClass);
export type FairShare = "Enabled" | "Disabled" | (string & {});
export const FairShare = S.String;
export interface SchedulerConfig {
  PriorityClasses?: PriorityClass[];
  FairShare?: FairShare;
}
export const SchedulerConfig = S.suspend(() =>
  S.Struct({
    PriorityClasses: S.optional(PriorityClassList),
    FairShare: S.optional(FairShare),
  }),
).annotate({
  identifier: "SchedulerConfig",
}) as any as S.Schema<SchedulerConfig>;
export interface CreateClusterSchedulerConfigRequest {
  Name?: string;
  ClusterArn?: string;
  SchedulerConfig?: SchedulerConfig;
  Description?: string;
  Tags?: Tag[];
}
export const CreateClusterSchedulerConfigRequest = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    ClusterArn: S.optional(S.String),
    SchedulerConfig: S.optional(SchedulerConfig),
    Description: S.optional(S.String),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateClusterSchedulerConfigRequest",
}) as any as S.Schema<CreateClusterSchedulerConfigRequest>;
export interface CreateClusterSchedulerConfigResponse {
  ClusterSchedulerConfigArn: string;
  ClusterSchedulerConfigId: string;
}
export const CreateClusterSchedulerConfigResponse = S.suspend(() =>
  S.Struct({
    ClusterSchedulerConfigArn: S.optional(S.String),
    ClusterSchedulerConfigId: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "CreateClusterSchedulerConfigResponse",
}) as any as S.Schema<CreateClusterSchedulerConfigResponse>;
export interface GitConfig {
  RepositoryUrl?: string;
  Branch?: string;
  SecretArn?: string;
}
export const GitConfig = S.suspend(() =>
  S.Struct({
    RepositoryUrl: S.optional(S.String),
    Branch: S.optional(S.String),
    SecretArn: S.optional(S.String),
  }),
).annotate({ identifier: "GitConfig" }) as any as S.Schema<GitConfig>;
export interface CreateCodeRepositoryInput {
  CodeRepositoryName?: string;
  GitConfig?: GitConfig;
  Tags?: Tag[];
}
export const CreateCodeRepositoryInput = S.suspend(() =>
  S.Struct({
    CodeRepositoryName: S.optional(S.String),
    GitConfig: S.optional(GitConfig),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateCodeRepositoryInput",
}) as any as S.Schema<CreateCodeRepositoryInput>;
export interface CreateCodeRepositoryOutput {
  CodeRepositoryArn: string;
}
export const CreateCodeRepositoryOutput = S.suspend(() =>
  S.Struct({ CodeRepositoryArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateCodeRepositoryOutput",
}) as any as S.Schema<CreateCodeRepositoryOutput>;
export type Framework =
  | "TENSORFLOW"
  | "KERAS"
  | "MXNET"
  | "ONNX"
  | "PYTORCH"
  | "XGBOOST"
  | "TFLITE"
  | "DARKNET"
  | "SKLEARN"
  | (string & {});
export const Framework = S.String;
export interface InputConfig {
  S3Uri?: string;
  DataInputConfig?: string;
  Framework?: Framework;
  FrameworkVersion?: string;
}
export const InputConfig = S.suspend(() =>
  S.Struct({
    S3Uri: S.optional(S.String),
    DataInputConfig: S.optional(S.String),
    Framework: S.optional(Framework),
    FrameworkVersion: S.optional(S.String),
  }),
).annotate({ identifier: "InputConfig" }) as any as S.Schema<InputConfig>;
export type TargetDevice =
  | "lambda"
  | "ml_m4"
  | "ml_m5"
  | "ml_m6g"
  | "ml_c4"
  | "ml_c5"
  | "ml_c6g"
  | "ml_p2"
  | "ml_p3"
  | "ml_g4dn"
  | "ml_inf1"
  | "ml_inf2"
  | "ml_trn1"
  | "ml_eia2"
  | "jetson_tx1"
  | "jetson_tx2"
  | "jetson_nano"
  | "jetson_xavier"
  | "rasp3b"
  | "rasp4b"
  | "imx8qm"
  | "deeplens"
  | "rk3399"
  | "rk3288"
  | "aisage"
  | "sbe_c"
  | "qcs605"
  | "qcs603"
  | "sitara_am57x"
  | "amba_cv2"
  | "amba_cv22"
  | "amba_cv25"
  | "x86_win32"
  | "x86_win64"
  | "coreml"
  | "jacinto_tda4vm"
  | "imx8mplus"
  | (string & {});
export const TargetDevice = S.String;
export type TargetPlatformOs = "ANDROID" | "LINUX" | (string & {});
export const TargetPlatformOs = S.String;
export type TargetPlatformArch =
  | "X86_64"
  | "X86"
  | "ARM64"
  | "ARM_EABI"
  | "ARM_EABIHF"
  | (string & {});
export const TargetPlatformArch = S.String;
export type TargetPlatformAccelerator =
  | "INTEL_GRAPHICS"
  | "MALI"
  | "NVIDIA"
  | "NNA"
  | (string & {});
export const TargetPlatformAccelerator = S.String;
export interface TargetPlatform {
  Os?: TargetPlatformOs;
  Arch?: TargetPlatformArch;
  Accelerator?: TargetPlatformAccelerator;
}
export const TargetPlatform = S.suspend(() =>
  S.Struct({
    Os: S.optional(TargetPlatformOs),
    Arch: S.optional(TargetPlatformArch),
    Accelerator: S.optional(TargetPlatformAccelerator),
  }),
).annotate({ identifier: "TargetPlatform" }) as any as S.Schema<TargetPlatform>;
export interface OutputConfig {
  S3OutputLocation?: string;
  TargetDevice?: TargetDevice;
  TargetPlatform?: TargetPlatform;
  CompilerOptions?: string;
  KmsKeyId?: string;
}
export const OutputConfig = S.suspend(() =>
  S.Struct({
    S3OutputLocation: S.optional(S.String),
    TargetDevice: S.optional(TargetDevice),
    TargetPlatform: S.optional(TargetPlatform),
    CompilerOptions: S.optional(S.String),
    KmsKeyId: S.optional(S.String),
  }),
).annotate({ identifier: "OutputConfig" }) as any as S.Schema<OutputConfig>;
export type NeoVpcSecurityGroupIds = string[];
export const NeoVpcSecurityGroupIds = S.Array(S.String);
export type NeoVpcSubnets = string[];
export const NeoVpcSubnets = S.Array(S.String);
export interface NeoVpcConfig {
  SecurityGroupIds?: string[];
  Subnets?: string[];
}
export const NeoVpcConfig = S.suspend(() =>
  S.Struct({
    SecurityGroupIds: S.optional(NeoVpcSecurityGroupIds),
    Subnets: S.optional(NeoVpcSubnets),
  }),
).annotate({ identifier: "NeoVpcConfig" }) as any as S.Schema<NeoVpcConfig>;
export interface CreateCompilationJobRequest {
  CompilationJobName?: string;
  RoleArn?: string;
  ModelPackageVersionArn?: string;
  InputConfig?: InputConfig;
  OutputConfig?: OutputConfig;
  VpcConfig?: NeoVpcConfig;
  StoppingCondition?: StoppingCondition;
  Tags?: Tag[];
}
export const CreateCompilationJobRequest = S.suspend(() =>
  S.Struct({
    CompilationJobName: S.optional(S.String),
    RoleArn: S.optional(S.String),
    ModelPackageVersionArn: S.optional(S.String),
    InputConfig: S.optional(InputConfig),
    OutputConfig: S.optional(OutputConfig),
    VpcConfig: S.optional(NeoVpcConfig),
    StoppingCondition: S.optional(StoppingCondition),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateCompilationJobRequest",
}) as any as S.Schema<CreateCompilationJobRequest>;
export interface CreateCompilationJobResponse {
  CompilationJobArn: string;
}
export const CreateCompilationJobResponse = S.suspend(() =>
  S.Struct({ CompilationJobArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateCompilationJobResponse",
}) as any as S.Schema<CreateCompilationJobResponse>;
export type MIGProfileType =
  | "mig-1g.5gb"
  | "mig-1g.10gb"
  | "mig-1g.18gb"
  | "mig-1g.20gb"
  | "mig-1g.23gb"
  | "mig-1g.35gb"
  | "mig-1g.45gb"
  | "mig-1g.47gb"
  | "mig-2g.10gb"
  | "mig-2g.20gb"
  | "mig-2g.35gb"
  | "mig-2g.45gb"
  | "mig-2g.47gb"
  | "mig-3g.20gb"
  | "mig-3g.40gb"
  | "mig-3g.71gb"
  | "mig-3g.90gb"
  | "mig-3g.93gb"
  | "mig-4g.20gb"
  | "mig-4g.40gb"
  | "mig-4g.71gb"
  | "mig-4g.90gb"
  | "mig-4g.93gb"
  | "mig-7g.40gb"
  | "mig-7g.80gb"
  | "mig-7g.141gb"
  | "mig-7g.180gb"
  | "mig-7g.186gb"
  | (string & {});
export const MIGProfileType = S.String;
export interface AcceleratorPartitionConfig {
  Type?: MIGProfileType;
  Count?: number;
}
export const AcceleratorPartitionConfig = S.suspend(() =>
  S.Struct({ Type: S.optional(MIGProfileType), Count: S.optional(S.Number) }),
).annotate({
  identifier: "AcceleratorPartitionConfig",
}) as any as S.Schema<AcceleratorPartitionConfig>;
export interface ComputeQuotaResourceConfig {
  InstanceType?: ClusterInstanceType;
  Count?: number;
  Accelerators?: number;
  VCpu?: number;
  MemoryInGiB?: number;
  AcceleratorPartition?: AcceleratorPartitionConfig;
}
export const ComputeQuotaResourceConfig = S.suspend(() =>
  S.Struct({
    InstanceType: S.optional(ClusterInstanceType),
    Count: S.optional(S.Number),
    Accelerators: S.optional(S.Number),
    VCpu: S.optional(S.Number),
    MemoryInGiB: S.optional(S.Number),
    AcceleratorPartition: S.optional(AcceleratorPartitionConfig),
  }),
).annotate({
  identifier: "ComputeQuotaResourceConfig",
}) as any as S.Schema<ComputeQuotaResourceConfig>;
export type ComputeQuotaResourceConfigList = ComputeQuotaResourceConfig[];
export const ComputeQuotaResourceConfigList = S.Array(
  ComputeQuotaResourceConfig,
);
export type ResourceSharingStrategy =
  | "Lend"
  | "DontLend"
  | "LendAndBorrow"
  | (string & {});
export const ResourceSharingStrategy = S.String;
export interface ResourceSharingConfig {
  Strategy?: ResourceSharingStrategy;
  BorrowLimit?: number;
}
export const ResourceSharingConfig = S.suspend(() =>
  S.Struct({
    Strategy: S.optional(ResourceSharingStrategy),
    BorrowLimit: S.optional(S.Number),
  }),
).annotate({
  identifier: "ResourceSharingConfig",
}) as any as S.Schema<ResourceSharingConfig>;
export type PreemptTeamTasks = "Never" | "LowerPriority" | (string & {});
export const PreemptTeamTasks = S.String;
export interface ComputeQuotaConfig {
  ComputeQuotaResources?: ComputeQuotaResourceConfig[];
  ResourceSharingConfig?: ResourceSharingConfig;
  PreemptTeamTasks?: PreemptTeamTasks;
}
export const ComputeQuotaConfig = S.suspend(() =>
  S.Struct({
    ComputeQuotaResources: S.optional(ComputeQuotaResourceConfigList),
    ResourceSharingConfig: S.optional(ResourceSharingConfig),
    PreemptTeamTasks: S.optional(PreemptTeamTasks),
  }),
).annotate({
  identifier: "ComputeQuotaConfig",
}) as any as S.Schema<ComputeQuotaConfig>;
export interface ComputeQuotaTarget {
  TeamName?: string;
  FairShareWeight?: number;
}
export const ComputeQuotaTarget = S.suspend(() =>
  S.Struct({
    TeamName: S.optional(S.String),
    FairShareWeight: S.optional(S.Number),
  }),
).annotate({
  identifier: "ComputeQuotaTarget",
}) as any as S.Schema<ComputeQuotaTarget>;
export type ActivationState = "Enabled" | "Disabled" | (string & {});
export const ActivationState = S.String;
export interface CreateComputeQuotaRequest {
  Name?: string;
  Description?: string;
  ClusterArn?: string;
  ComputeQuotaConfig?: ComputeQuotaConfig;
  ComputeQuotaTarget?: ComputeQuotaTarget;
  ActivationState?: ActivationState;
  Tags?: Tag[];
}
export const CreateComputeQuotaRequest = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    ClusterArn: S.optional(S.String),
    ComputeQuotaConfig: S.optional(ComputeQuotaConfig),
    ComputeQuotaTarget: S.optional(ComputeQuotaTarget),
    ActivationState: S.optional(ActivationState),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateComputeQuotaRequest",
}) as any as S.Schema<CreateComputeQuotaRequest>;
export interface CreateComputeQuotaResponse {
  ComputeQuotaArn: string;
  ComputeQuotaId: string;
}
export const CreateComputeQuotaResponse = S.suspend(() =>
  S.Struct({
    ComputeQuotaArn: S.optional(S.String),
    ComputeQuotaId: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "CreateComputeQuotaResponse",
}) as any as S.Schema<CreateComputeQuotaResponse>;
export interface ContextSource {
  SourceUri?: string;
  SourceType?: string;
  SourceId?: string;
}
export const ContextSource = S.suspend(() =>
  S.Struct({
    SourceUri: S.optional(S.String),
    SourceType: S.optional(S.String),
    SourceId: S.optional(S.String),
  }),
).annotate({ identifier: "ContextSource" }) as any as S.Schema<ContextSource>;
export interface CreateContextRequest {
  ContextName?: string;
  Source?: ContextSource;
  ContextType?: string;
  Description?: string;
  Properties?: { [key: string]: string | undefined };
  Tags?: Tag[];
}
export const CreateContextRequest = S.suspend(() =>
  S.Struct({
    ContextName: S.optional(S.String),
    Source: S.optional(ContextSource),
    ContextType: S.optional(S.String),
    Description: S.optional(S.String),
    Properties: S.optional(LineageEntityParameters),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateContextRequest",
}) as any as S.Schema<CreateContextRequest>;
export interface CreateContextResponse {
  ContextArn?: string;
}
export const CreateContextResponse = S.suspend(() =>
  S.Struct({ ContextArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateContextResponse",
}) as any as S.Schema<CreateContextResponse>;
export interface MonitoringConstraintsResource {
  S3Uri?: string;
}
export const MonitoringConstraintsResource = S.suspend(() =>
  S.Struct({ S3Uri: S.optional(S.String) }),
).annotate({
  identifier: "MonitoringConstraintsResource",
}) as any as S.Schema<MonitoringConstraintsResource>;
export interface MonitoringStatisticsResource {
  S3Uri?: string;
}
export const MonitoringStatisticsResource = S.suspend(() =>
  S.Struct({ S3Uri: S.optional(S.String) }),
).annotate({
  identifier: "MonitoringStatisticsResource",
}) as any as S.Schema<MonitoringStatisticsResource>;
export interface DataQualityBaselineConfig {
  BaseliningJobName?: string;
  ConstraintsResource?: MonitoringConstraintsResource;
  StatisticsResource?: MonitoringStatisticsResource;
}
export const DataQualityBaselineConfig = S.suspend(() =>
  S.Struct({
    BaseliningJobName: S.optional(S.String),
    ConstraintsResource: S.optional(MonitoringConstraintsResource),
    StatisticsResource: S.optional(MonitoringStatisticsResource),
  }),
).annotate({
  identifier: "DataQualityBaselineConfig",
}) as any as S.Schema<DataQualityBaselineConfig>;
export type ContainerEntrypoint = string[];
export const ContainerEntrypoint = S.Array(S.String);
export type MonitoringContainerArguments = string[];
export const MonitoringContainerArguments = S.Array(S.String);
export type MonitoringEnvironmentMap = { [key: string]: string | undefined };
export const MonitoringEnvironmentMap = S.Record(
  S.String,
  S.String.pipe(S.optional),
);
export interface DataQualityAppSpecification {
  ImageUri?: string;
  ContainerEntrypoint?: string[];
  ContainerArguments?: string[];
  RecordPreprocessorSourceUri?: string;
  PostAnalyticsProcessorSourceUri?: string;
  Environment?: { [key: string]: string | undefined };
}
export const DataQualityAppSpecification = S.suspend(() =>
  S.Struct({
    ImageUri: S.optional(S.String),
    ContainerEntrypoint: S.optional(ContainerEntrypoint),
    ContainerArguments: S.optional(MonitoringContainerArguments),
    RecordPreprocessorSourceUri: S.optional(S.String),
    PostAnalyticsProcessorSourceUri: S.optional(S.String),
    Environment: S.optional(MonitoringEnvironmentMap),
  }),
).annotate({
  identifier: "DataQualityAppSpecification",
}) as any as S.Schema<DataQualityAppSpecification>;
export type ProcessingS3InputMode = "Pipe" | "File" | (string & {});
export const ProcessingS3InputMode = S.String;
export type ProcessingS3DataDistributionType =
  | "FullyReplicated"
  | "ShardedByS3Key"
  | (string & {});
export const ProcessingS3DataDistributionType = S.String;
export interface EndpointInput {
  EndpointName?: string;
  LocalPath?: string;
  S3InputMode?: ProcessingS3InputMode;
  S3DataDistributionType?: ProcessingS3DataDistributionType;
  FeaturesAttribute?: string;
  InferenceAttribute?: string;
  ProbabilityAttribute?: string;
  ProbabilityThresholdAttribute?: number;
  StartTimeOffset?: string;
  EndTimeOffset?: string;
  ExcludeFeaturesAttribute?: string;
}
export const EndpointInput = S.suspend(() =>
  S.Struct({
    EndpointName: S.optional(S.String),
    LocalPath: S.optional(S.String),
    S3InputMode: S.optional(ProcessingS3InputMode),
    S3DataDistributionType: S.optional(ProcessingS3DataDistributionType),
    FeaturesAttribute: S.optional(S.String),
    InferenceAttribute: S.optional(S.String),
    ProbabilityAttribute: S.optional(S.String),
    ProbabilityThresholdAttribute: S.optional(S.Number),
    StartTimeOffset: S.optional(S.String),
    EndTimeOffset: S.optional(S.String),
    ExcludeFeaturesAttribute: S.optional(S.String),
  }),
).annotate({ identifier: "EndpointInput" }) as any as S.Schema<EndpointInput>;
export interface MonitoringCsvDatasetFormat {
  Header?: boolean;
}
export const MonitoringCsvDatasetFormat = S.suspend(() =>
  S.Struct({ Header: S.optional(S.Boolean) }),
).annotate({
  identifier: "MonitoringCsvDatasetFormat",
}) as any as S.Schema<MonitoringCsvDatasetFormat>;
export interface MonitoringJsonDatasetFormat {
  Line?: boolean;
}
export const MonitoringJsonDatasetFormat = S.suspend(() =>
  S.Struct({ Line: S.optional(S.Boolean) }),
).annotate({
  identifier: "MonitoringJsonDatasetFormat",
}) as any as S.Schema<MonitoringJsonDatasetFormat>;
export interface MonitoringParquetDatasetFormat {}
export const MonitoringParquetDatasetFormat = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "MonitoringParquetDatasetFormat",
}) as any as S.Schema<MonitoringParquetDatasetFormat>;
export interface MonitoringDatasetFormat {
  Csv?: MonitoringCsvDatasetFormat;
  Json?: MonitoringJsonDatasetFormat;
  Parquet?: MonitoringParquetDatasetFormat;
}
export const MonitoringDatasetFormat = S.suspend(() =>
  S.Struct({
    Csv: S.optional(MonitoringCsvDatasetFormat),
    Json: S.optional(MonitoringJsonDatasetFormat),
    Parquet: S.optional(MonitoringParquetDatasetFormat),
  }),
).annotate({
  identifier: "MonitoringDatasetFormat",
}) as any as S.Schema<MonitoringDatasetFormat>;
export interface BatchTransformInput {
  DataCapturedDestinationS3Uri?: string;
  DatasetFormat?: MonitoringDatasetFormat;
  LocalPath?: string;
  S3InputMode?: ProcessingS3InputMode;
  S3DataDistributionType?: ProcessingS3DataDistributionType;
  FeaturesAttribute?: string;
  InferenceAttribute?: string;
  ProbabilityAttribute?: string;
  ProbabilityThresholdAttribute?: number;
  StartTimeOffset?: string;
  EndTimeOffset?: string;
  ExcludeFeaturesAttribute?: string;
}
export const BatchTransformInput = S.suspend(() =>
  S.Struct({
    DataCapturedDestinationS3Uri: S.optional(S.String),
    DatasetFormat: S.optional(MonitoringDatasetFormat),
    LocalPath: S.optional(S.String),
    S3InputMode: S.optional(ProcessingS3InputMode),
    S3DataDistributionType: S.optional(ProcessingS3DataDistributionType),
    FeaturesAttribute: S.optional(S.String),
    InferenceAttribute: S.optional(S.String),
    ProbabilityAttribute: S.optional(S.String),
    ProbabilityThresholdAttribute: S.optional(S.Number),
    StartTimeOffset: S.optional(S.String),
    EndTimeOffset: S.optional(S.String),
    ExcludeFeaturesAttribute: S.optional(S.String),
  }),
).annotate({
  identifier: "BatchTransformInput",
}) as any as S.Schema<BatchTransformInput>;
export interface DataQualityJobInput {
  EndpointInput?: EndpointInput;
  BatchTransformInput?: BatchTransformInput;
}
export const DataQualityJobInput = S.suspend(() =>
  S.Struct({
    EndpointInput: S.optional(EndpointInput),
    BatchTransformInput: S.optional(BatchTransformInput),
  }),
).annotate({
  identifier: "DataQualityJobInput",
}) as any as S.Schema<DataQualityJobInput>;
export type ProcessingS3UploadMode = "Continuous" | "EndOfJob" | (string & {});
export const ProcessingS3UploadMode = S.String;
export interface MonitoringS3Output {
  S3Uri?: string;
  LocalPath?: string;
  S3UploadMode?: ProcessingS3UploadMode;
}
export const MonitoringS3Output = S.suspend(() =>
  S.Struct({
    S3Uri: S.optional(S.String),
    LocalPath: S.optional(S.String),
    S3UploadMode: S.optional(ProcessingS3UploadMode),
  }),
).annotate({
  identifier: "MonitoringS3Output",
}) as any as S.Schema<MonitoringS3Output>;
export interface MonitoringOutput {
  S3Output?: MonitoringS3Output;
}
export const MonitoringOutput = S.suspend(() =>
  S.Struct({ S3Output: S.optional(MonitoringS3Output) }),
).annotate({
  identifier: "MonitoringOutput",
}) as any as S.Schema<MonitoringOutput>;
export type MonitoringOutputs = MonitoringOutput[];
export const MonitoringOutputs = S.Array(MonitoringOutput);
export interface MonitoringOutputConfig {
  MonitoringOutputs?: MonitoringOutput[];
  KmsKeyId?: string;
}
export const MonitoringOutputConfig = S.suspend(() =>
  S.Struct({
    MonitoringOutputs: S.optional(MonitoringOutputs),
    KmsKeyId: S.optional(S.String),
  }),
).annotate({
  identifier: "MonitoringOutputConfig",
}) as any as S.Schema<MonitoringOutputConfig>;
export type ProcessingInstanceType =
  | "ml.t3.medium"
  | "ml.t3.large"
  | "ml.t3.xlarge"
  | "ml.t3.2xlarge"
  | "ml.m4.xlarge"
  | "ml.m4.2xlarge"
  | "ml.m4.4xlarge"
  | "ml.m4.10xlarge"
  | "ml.m4.16xlarge"
  | "ml.c4.xlarge"
  | "ml.c4.2xlarge"
  | "ml.c4.4xlarge"
  | "ml.c4.8xlarge"
  | "ml.p2.xlarge"
  | "ml.p2.8xlarge"
  | "ml.p2.16xlarge"
  | "ml.p3.2xlarge"
  | "ml.p3.8xlarge"
  | "ml.p3.16xlarge"
  | "ml.c5.xlarge"
  | "ml.c5.2xlarge"
  | "ml.c5.4xlarge"
  | "ml.c5.9xlarge"
  | "ml.c5.18xlarge"
  | "ml.m5.large"
  | "ml.m5.xlarge"
  | "ml.m5.2xlarge"
  | "ml.m5.4xlarge"
  | "ml.m5.12xlarge"
  | "ml.m5.24xlarge"
  | "ml.r5.large"
  | "ml.r5.xlarge"
  | "ml.r5.2xlarge"
  | "ml.r5.4xlarge"
  | "ml.r5.8xlarge"
  | "ml.r5.12xlarge"
  | "ml.r5.16xlarge"
  | "ml.r5.24xlarge"
  | "ml.g4dn.xlarge"
  | "ml.g4dn.2xlarge"
  | "ml.g4dn.4xlarge"
  | "ml.g4dn.8xlarge"
  | "ml.g4dn.12xlarge"
  | "ml.g4dn.16xlarge"
  | "ml.g5.xlarge"
  | "ml.g5.2xlarge"
  | "ml.g5.4xlarge"
  | "ml.g5.8xlarge"
  | "ml.g5.16xlarge"
  | "ml.g5.12xlarge"
  | "ml.g5.24xlarge"
  | "ml.g5.48xlarge"
  | "ml.r5d.large"
  | "ml.r5d.xlarge"
  | "ml.r5d.2xlarge"
  | "ml.r5d.4xlarge"
  | "ml.r5d.8xlarge"
  | "ml.r5d.12xlarge"
  | "ml.r5d.16xlarge"
  | "ml.r5d.24xlarge"
  | "ml.g6.xlarge"
  | "ml.g6.2xlarge"
  | "ml.g6.4xlarge"
  | "ml.g6.8xlarge"
  | "ml.g6.12xlarge"
  | "ml.g6.16xlarge"
  | "ml.g6.24xlarge"
  | "ml.g6.48xlarge"
  | "ml.g6e.xlarge"
  | "ml.g6e.2xlarge"
  | "ml.g6e.4xlarge"
  | "ml.g6e.8xlarge"
  | "ml.g6e.12xlarge"
  | "ml.g6e.16xlarge"
  | "ml.g6e.24xlarge"
  | "ml.g6e.48xlarge"
  | "ml.m6i.large"
  | "ml.m6i.xlarge"
  | "ml.m6i.2xlarge"
  | "ml.m6i.4xlarge"
  | "ml.m6i.8xlarge"
  | "ml.m6i.12xlarge"
  | "ml.m6i.16xlarge"
  | "ml.m6i.24xlarge"
  | "ml.m6i.32xlarge"
  | "ml.c6i.xlarge"
  | "ml.c6i.2xlarge"
  | "ml.c6i.4xlarge"
  | "ml.c6i.8xlarge"
  | "ml.c6i.12xlarge"
  | "ml.c6i.16xlarge"
  | "ml.c6i.24xlarge"
  | "ml.c6i.32xlarge"
  | "ml.m7i.large"
  | "ml.m7i.xlarge"
  | "ml.m7i.2xlarge"
  | "ml.m7i.4xlarge"
  | "ml.m7i.8xlarge"
  | "ml.m7i.12xlarge"
  | "ml.m7i.16xlarge"
  | "ml.m7i.24xlarge"
  | "ml.m7i.48xlarge"
  | "ml.c7i.large"
  | "ml.c7i.xlarge"
  | "ml.c7i.2xlarge"
  | "ml.c7i.4xlarge"
  | "ml.c7i.8xlarge"
  | "ml.c7i.12xlarge"
  | "ml.c7i.16xlarge"
  | "ml.c7i.24xlarge"
  | "ml.c7i.48xlarge"
  | "ml.r7i.large"
  | "ml.r7i.xlarge"
  | "ml.r7i.2xlarge"
  | "ml.r7i.4xlarge"
  | "ml.r7i.8xlarge"
  | "ml.r7i.12xlarge"
  | "ml.r7i.16xlarge"
  | "ml.r7i.24xlarge"
  | "ml.r7i.48xlarge"
  | "ml.p5.4xlarge"
  | (string & {});
export const ProcessingInstanceType = S.String;
export interface MonitoringClusterConfig {
  InstanceCount?: number;
  InstanceType?: ProcessingInstanceType;
  VolumeSizeInGB?: number;
  VolumeKmsKeyId?: string;
}
export const MonitoringClusterConfig = S.suspend(() =>
  S.Struct({
    InstanceCount: S.optional(S.Number),
    InstanceType: S.optional(ProcessingInstanceType),
    VolumeSizeInGB: S.optional(S.Number),
    VolumeKmsKeyId: S.optional(S.String),
  }),
).annotate({
  identifier: "MonitoringClusterConfig",
}) as any as S.Schema<MonitoringClusterConfig>;
export interface MonitoringResources {
  ClusterConfig?: MonitoringClusterConfig;
}
export const MonitoringResources = S.suspend(() =>
  S.Struct({ ClusterConfig: S.optional(MonitoringClusterConfig) }),
).annotate({
  identifier: "MonitoringResources",
}) as any as S.Schema<MonitoringResources>;
export interface MonitoringNetworkConfig {
  EnableInterContainerTrafficEncryption?: boolean;
  EnableNetworkIsolation?: boolean;
  VpcConfig?: VpcConfig;
}
export const MonitoringNetworkConfig = S.suspend(() =>
  S.Struct({
    EnableInterContainerTrafficEncryption: S.optional(S.Boolean),
    EnableNetworkIsolation: S.optional(S.Boolean),
    VpcConfig: S.optional(VpcConfig),
  }),
).annotate({
  identifier: "MonitoringNetworkConfig",
}) as any as S.Schema<MonitoringNetworkConfig>;
export interface MonitoringStoppingCondition {
  MaxRuntimeInSeconds?: number;
}
export const MonitoringStoppingCondition = S.suspend(() =>
  S.Struct({ MaxRuntimeInSeconds: S.optional(S.Number) }),
).annotate({
  identifier: "MonitoringStoppingCondition",
}) as any as S.Schema<MonitoringStoppingCondition>;
export interface CreateDataQualityJobDefinitionRequest {
  JobDefinitionName?: string;
  DataQualityBaselineConfig?: DataQualityBaselineConfig;
  DataQualityAppSpecification?: DataQualityAppSpecification;
  DataQualityJobInput?: DataQualityJobInput;
  DataQualityJobOutputConfig?: MonitoringOutputConfig;
  JobResources?: MonitoringResources;
  NetworkConfig?: MonitoringNetworkConfig;
  RoleArn?: string;
  StoppingCondition?: MonitoringStoppingCondition;
  Tags?: Tag[];
}
export const CreateDataQualityJobDefinitionRequest = S.suspend(() =>
  S.Struct({
    JobDefinitionName: S.optional(S.String),
    DataQualityBaselineConfig: S.optional(DataQualityBaselineConfig),
    DataQualityAppSpecification: S.optional(DataQualityAppSpecification),
    DataQualityJobInput: S.optional(DataQualityJobInput),
    DataQualityJobOutputConfig: S.optional(MonitoringOutputConfig),
    JobResources: S.optional(MonitoringResources),
    NetworkConfig: S.optional(MonitoringNetworkConfig),
    RoleArn: S.optional(S.String),
    StoppingCondition: S.optional(MonitoringStoppingCondition),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateDataQualityJobDefinitionRequest",
}) as any as S.Schema<CreateDataQualityJobDefinitionRequest>;
export interface CreateDataQualityJobDefinitionResponse {
  JobDefinitionArn: string;
}
export const CreateDataQualityJobDefinitionResponse = S.suspend(() =>
  S.Struct({ JobDefinitionArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateDataQualityJobDefinitionResponse",
}) as any as S.Schema<CreateDataQualityJobDefinitionResponse>;
export type EdgePresetDeploymentType = "GreengrassV2Component" | (string & {});
export const EdgePresetDeploymentType = S.String;
export interface EdgeOutputConfig {
  S3OutputLocation?: string;
  KmsKeyId?: string;
  PresetDeploymentType?: EdgePresetDeploymentType;
  PresetDeploymentConfig?: string;
}
export const EdgeOutputConfig = S.suspend(() =>
  S.Struct({
    S3OutputLocation: S.optional(S.String),
    KmsKeyId: S.optional(S.String),
    PresetDeploymentType: S.optional(EdgePresetDeploymentType),
    PresetDeploymentConfig: S.optional(S.String),
  }),
).annotate({
  identifier: "EdgeOutputConfig",
}) as any as S.Schema<EdgeOutputConfig>;
export interface CreateDeviceFleetRequest {
  DeviceFleetName?: string;
  RoleArn?: string;
  Description?: string;
  OutputConfig?: EdgeOutputConfig;
  Tags?: Tag[];
  EnableIotRoleAlias?: boolean;
}
export const CreateDeviceFleetRequest = S.suspend(() =>
  S.Struct({
    DeviceFleetName: S.optional(S.String),
    RoleArn: S.optional(S.String),
    Description: S.optional(S.String),
    OutputConfig: S.optional(EdgeOutputConfig),
    Tags: S.optional(TagList),
    EnableIotRoleAlias: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateDeviceFleetRequest",
}) as any as S.Schema<CreateDeviceFleetRequest>;
export interface CreateDeviceFleetResponse {}
export const CreateDeviceFleetResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "CreateDeviceFleetResponse",
}) as any as S.Schema<CreateDeviceFleetResponse>;
export type AuthMode = "SSO" | "IAM" | (string & {});
export const AuthMode = S.String;
export type SecurityGroupIds = string[];
export const SecurityGroupIds = S.Array(S.String);
export type NotebookOutputOption = "Allowed" | "Disabled" | (string & {});
export const NotebookOutputOption = S.String;
export interface SharingSettings {
  NotebookOutputOption?: NotebookOutputOption;
  S3OutputPath?: string;
  S3KmsKeyId?: string;
}
export const SharingSettings = S.suspend(() =>
  S.Struct({
    NotebookOutputOption: S.optional(NotebookOutputOption),
    S3OutputPath: S.optional(S.String),
    S3KmsKeyId: S.optional(S.String),
  }),
).annotate({
  identifier: "SharingSettings",
}) as any as S.Schema<SharingSettings>;
export type LifecycleConfigArns = string[];
export const LifecycleConfigArns = S.Array(S.String);
export interface CodeRepository {
  RepositoryUrl?: string;
}
export const CodeRepository = S.suspend(() =>
  S.Struct({ RepositoryUrl: S.optional(S.String) }),
).annotate({ identifier: "CodeRepository" }) as any as S.Schema<CodeRepository>;
export type CodeRepositories = CodeRepository[];
export const CodeRepositories = S.Array(CodeRepository);
export interface JupyterServerAppSettings {
  DefaultResourceSpec?: ResourceSpec;
  LifecycleConfigArns?: string[];
  CodeRepositories?: CodeRepository[];
}
export const JupyterServerAppSettings = S.suspend(() =>
  S.Struct({
    DefaultResourceSpec: S.optional(ResourceSpec),
    LifecycleConfigArns: S.optional(LifecycleConfigArns),
    CodeRepositories: S.optional(CodeRepositories),
  }),
).annotate({
  identifier: "JupyterServerAppSettings",
}) as any as S.Schema<JupyterServerAppSettings>;
export interface CustomImage {
  ImageName?: string;
  ImageVersionNumber?: number;
  AppImageConfigName?: string;
}
export const CustomImage = S.suspend(() =>
  S.Struct({
    ImageName: S.optional(S.String),
    ImageVersionNumber: S.optional(S.Number),
    AppImageConfigName: S.optional(S.String),
  }),
).annotate({ identifier: "CustomImage" }) as any as S.Schema<CustomImage>;
export type CustomImages = CustomImage[];
export const CustomImages = S.Array(CustomImage);
export interface KernelGatewayAppSettings {
  DefaultResourceSpec?: ResourceSpec;
  CustomImages?: CustomImage[];
  LifecycleConfigArns?: string[];
}
export const KernelGatewayAppSettings = S.suspend(() =>
  S.Struct({
    DefaultResourceSpec: S.optional(ResourceSpec),
    CustomImages: S.optional(CustomImages),
    LifecycleConfigArns: S.optional(LifecycleConfigArns),
  }),
).annotate({
  identifier: "KernelGatewayAppSettings",
}) as any as S.Schema<KernelGatewayAppSettings>;
export interface TensorBoardAppSettings {
  DefaultResourceSpec?: ResourceSpec;
}
export const TensorBoardAppSettings = S.suspend(() =>
  S.Struct({ DefaultResourceSpec: S.optional(ResourceSpec) }),
).annotate({
  identifier: "TensorBoardAppSettings",
}) as any as S.Schema<TensorBoardAppSettings>;
export type RStudioServerProAccessStatus =
  | "ENABLED"
  | "DISABLED"
  | (string & {});
export const RStudioServerProAccessStatus = S.String;
export type RStudioServerProUserGroup =
  | "R_STUDIO_ADMIN"
  | "R_STUDIO_USER"
  | (string & {});
export const RStudioServerProUserGroup = S.String;
export interface RStudioServerProAppSettings {
  AccessStatus?: RStudioServerProAccessStatus;
  UserGroup?: RStudioServerProUserGroup;
}
export const RStudioServerProAppSettings = S.suspend(() =>
  S.Struct({
    AccessStatus: S.optional(RStudioServerProAccessStatus),
    UserGroup: S.optional(RStudioServerProUserGroup),
  }),
).annotate({
  identifier: "RStudioServerProAppSettings",
}) as any as S.Schema<RStudioServerProAppSettings>;
export interface RSessionAppSettings {
  DefaultResourceSpec?: ResourceSpec;
  CustomImages?: CustomImage[];
}
export const RSessionAppSettings = S.suspend(() =>
  S.Struct({
    DefaultResourceSpec: S.optional(ResourceSpec),
    CustomImages: S.optional(CustomImages),
  }),
).annotate({
  identifier: "RSessionAppSettings",
}) as any as S.Schema<RSessionAppSettings>;
export type FeatureStatus = "ENABLED" | "DISABLED" | (string & {});
export const FeatureStatus = S.String;
export interface TimeSeriesForecastingSettings {
  Status?: FeatureStatus;
  AmazonForecastRoleArn?: string;
}
export const TimeSeriesForecastingSettings = S.suspend(() =>
  S.Struct({
    Status: S.optional(FeatureStatus),
    AmazonForecastRoleArn: S.optional(S.String),
  }),
).annotate({
  identifier: "TimeSeriesForecastingSettings",
}) as any as S.Schema<TimeSeriesForecastingSettings>;
export interface ModelRegisterSettings {
  Status?: FeatureStatus;
  CrossAccountModelRegisterRoleArn?: string;
}
export const ModelRegisterSettings = S.suspend(() =>
  S.Struct({
    Status: S.optional(FeatureStatus),
    CrossAccountModelRegisterRoleArn: S.optional(S.String),
  }),
).annotate({
  identifier: "ModelRegisterSettings",
}) as any as S.Schema<ModelRegisterSettings>;
export interface WorkspaceSettings {
  S3ArtifactPath?: string;
  S3KmsKeyId?: string;
}
export const WorkspaceSettings = S.suspend(() =>
  S.Struct({
    S3ArtifactPath: S.optional(S.String),
    S3KmsKeyId: S.optional(S.String),
  }),
).annotate({
  identifier: "WorkspaceSettings",
}) as any as S.Schema<WorkspaceSettings>;
export type DataSourceName = "SalesforceGenie" | "Snowflake" | (string & {});
export const DataSourceName = S.String;
export interface IdentityProviderOAuthSetting {
  DataSourceName?: DataSourceName;
  Status?: FeatureStatus;
  SecretArn?: string;
}
export const IdentityProviderOAuthSetting = S.suspend(() =>
  S.Struct({
    DataSourceName: S.optional(DataSourceName),
    Status: S.optional(FeatureStatus),
    SecretArn: S.optional(S.String),
  }),
).annotate({
  identifier: "IdentityProviderOAuthSetting",
}) as any as S.Schema<IdentityProviderOAuthSetting>;
export type IdentityProviderOAuthSettings = IdentityProviderOAuthSetting[];
export const IdentityProviderOAuthSettings = S.Array(
  IdentityProviderOAuthSetting,
);
export interface DirectDeploySettings {
  Status?: FeatureStatus;
}
export const DirectDeploySettings = S.suspend(() =>
  S.Struct({ Status: S.optional(FeatureStatus) }),
).annotate({
  identifier: "DirectDeploySettings",
}) as any as S.Schema<DirectDeploySettings>;
export interface KendraSettings {
  Status?: FeatureStatus;
}
export const KendraSettings = S.suspend(() =>
  S.Struct({ Status: S.optional(FeatureStatus) }),
).annotate({ identifier: "KendraSettings" }) as any as S.Schema<KendraSettings>;
export interface GenerativeAiSettings {
  AmazonBedrockRoleArn?: string;
}
export const GenerativeAiSettings = S.suspend(() =>
  S.Struct({ AmazonBedrockRoleArn: S.optional(S.String) }),
).annotate({
  identifier: "GenerativeAiSettings",
}) as any as S.Schema<GenerativeAiSettings>;
export interface EmrServerlessSettings {
  ExecutionRoleArn?: string;
  Status?: FeatureStatus;
}
export const EmrServerlessSettings = S.suspend(() =>
  S.Struct({
    ExecutionRoleArn: S.optional(S.String),
    Status: S.optional(FeatureStatus),
  }),
).annotate({
  identifier: "EmrServerlessSettings",
}) as any as S.Schema<EmrServerlessSettings>;
export interface CanvasAppSettings {
  TimeSeriesForecastingSettings?: TimeSeriesForecastingSettings;
  ModelRegisterSettings?: ModelRegisterSettings;
  WorkspaceSettings?: WorkspaceSettings;
  IdentityProviderOAuthSettings?: IdentityProviderOAuthSetting[];
  DirectDeploySettings?: DirectDeploySettings;
  KendraSettings?: KendraSettings;
  GenerativeAiSettings?: GenerativeAiSettings;
  EmrServerlessSettings?: EmrServerlessSettings;
}
export const CanvasAppSettings = S.suspend(() =>
  S.Struct({
    TimeSeriesForecastingSettings: S.optional(TimeSeriesForecastingSettings),
    ModelRegisterSettings: S.optional(ModelRegisterSettings),
    WorkspaceSettings: S.optional(WorkspaceSettings),
    IdentityProviderOAuthSettings: S.optional(IdentityProviderOAuthSettings),
    DirectDeploySettings: S.optional(DirectDeploySettings),
    KendraSettings: S.optional(KendraSettings),
    GenerativeAiSettings: S.optional(GenerativeAiSettings),
    EmrServerlessSettings: S.optional(EmrServerlessSettings),
  }),
).annotate({
  identifier: "CanvasAppSettings",
}) as any as S.Schema<CanvasAppSettings>;
export type LifecycleManagement = "ENABLED" | "DISABLED" | (string & {});
export const LifecycleManagement = S.String;
export interface IdleSettings {
  LifecycleManagement?: LifecycleManagement;
  IdleTimeoutInMinutes?: number;
  MinIdleTimeoutInMinutes?: number;
  MaxIdleTimeoutInMinutes?: number;
}
export const IdleSettings = S.suspend(() =>
  S.Struct({
    LifecycleManagement: S.optional(LifecycleManagement),
    IdleTimeoutInMinutes: S.optional(S.Number),
    MinIdleTimeoutInMinutes: S.optional(S.Number),
    MaxIdleTimeoutInMinutes: S.optional(S.Number),
  }),
).annotate({ identifier: "IdleSettings" }) as any as S.Schema<IdleSettings>;
export interface AppLifecycleManagement {
  IdleSettings?: IdleSettings;
}
export const AppLifecycleManagement = S.suspend(() =>
  S.Struct({ IdleSettings: S.optional(IdleSettings) }),
).annotate({
  identifier: "AppLifecycleManagement",
}) as any as S.Schema<AppLifecycleManagement>;
export interface CodeEditorAppSettings {
  DefaultResourceSpec?: ResourceSpec;
  CustomImages?: CustomImage[];
  LifecycleConfigArns?: string[];
  AppLifecycleManagement?: AppLifecycleManagement;
  BuiltInLifecycleConfigArn?: string;
}
export const CodeEditorAppSettings = S.suspend(() =>
  S.Struct({
    DefaultResourceSpec: S.optional(ResourceSpec),
    CustomImages: S.optional(CustomImages),
    LifecycleConfigArns: S.optional(LifecycleConfigArns),
    AppLifecycleManagement: S.optional(AppLifecycleManagement),
    BuiltInLifecycleConfigArn: S.optional(S.String),
  }),
).annotate({
  identifier: "CodeEditorAppSettings",
}) as any as S.Schema<CodeEditorAppSettings>;
export type AssumableRoleArns = string[];
export const AssumableRoleArns = S.Array(S.String);
export type ExecutionRoleArns = string[];
export const ExecutionRoleArns = S.Array(S.String);
export interface EmrSettings {
  AssumableRoleArns?: string[];
  ExecutionRoleArns?: string[];
}
export const EmrSettings = S.suspend(() =>
  S.Struct({
    AssumableRoleArns: S.optional(AssumableRoleArns),
    ExecutionRoleArns: S.optional(ExecutionRoleArns),
  }),
).annotate({ identifier: "EmrSettings" }) as any as S.Schema<EmrSettings>;
export interface JupyterLabAppSettings {
  DefaultResourceSpec?: ResourceSpec;
  CustomImages?: CustomImage[];
  LifecycleConfigArns?: string[];
  CodeRepositories?: CodeRepository[];
  AppLifecycleManagement?: AppLifecycleManagement;
  EmrSettings?: EmrSettings;
  BuiltInLifecycleConfigArn?: string;
}
export const JupyterLabAppSettings = S.suspend(() =>
  S.Struct({
    DefaultResourceSpec: S.optional(ResourceSpec),
    CustomImages: S.optional(CustomImages),
    LifecycleConfigArns: S.optional(LifecycleConfigArns),
    CodeRepositories: S.optional(CodeRepositories),
    AppLifecycleManagement: S.optional(AppLifecycleManagement),
    EmrSettings: S.optional(EmrSettings),
    BuiltInLifecycleConfigArn: S.optional(S.String),
  }),
).annotate({
  identifier: "JupyterLabAppSettings",
}) as any as S.Schema<JupyterLabAppSettings>;
export interface DefaultEbsStorageSettings {
  DefaultEbsVolumeSizeInGb?: number;
  MaximumEbsVolumeSizeInGb?: number;
}
export const DefaultEbsStorageSettings = S.suspend(() =>
  S.Struct({
    DefaultEbsVolumeSizeInGb: S.optional(S.Number),
    MaximumEbsVolumeSizeInGb: S.optional(S.Number),
  }),
).annotate({
  identifier: "DefaultEbsStorageSettings",
}) as any as S.Schema<DefaultEbsStorageSettings>;
export interface DefaultSpaceStorageSettings {
  DefaultEbsStorageSettings?: DefaultEbsStorageSettings;
}
export const DefaultSpaceStorageSettings = S.suspend(() =>
  S.Struct({
    DefaultEbsStorageSettings: S.optional(DefaultEbsStorageSettings),
  }),
).annotate({
  identifier: "DefaultSpaceStorageSettings",
}) as any as S.Schema<DefaultSpaceStorageSettings>;
export type StudioWebPortal = "ENABLED" | "DISABLED" | (string & {});
export const StudioWebPortal = S.String;
export interface CustomPosixUserConfig {
  Uid?: number;
  Gid?: number;
}
export const CustomPosixUserConfig = S.suspend(() =>
  S.Struct({ Uid: S.optional(S.Number), Gid: S.optional(S.Number) }),
).annotate({
  identifier: "CustomPosixUserConfig",
}) as any as S.Schema<CustomPosixUserConfig>;
export interface EFSFileSystemConfig {
  FileSystemId?: string;
  FileSystemPath?: string;
}
export const EFSFileSystemConfig = S.suspend(() =>
  S.Struct({
    FileSystemId: S.optional(S.String),
    FileSystemPath: S.optional(S.String),
  }),
).annotate({
  identifier: "EFSFileSystemConfig",
}) as any as S.Schema<EFSFileSystemConfig>;
export interface FSxLustreFileSystemConfig {
  FileSystemId?: string;
  FileSystemPath?: string;
}
export const FSxLustreFileSystemConfig = S.suspend(() =>
  S.Struct({
    FileSystemId: S.optional(S.String),
    FileSystemPath: S.optional(S.String),
  }),
).annotate({
  identifier: "FSxLustreFileSystemConfig",
}) as any as S.Schema<FSxLustreFileSystemConfig>;
export interface S3FileSystemConfig {
  MountPath?: string;
  S3Uri?: string;
}
export const S3FileSystemConfig = S.suspend(() =>
  S.Struct({ MountPath: S.optional(S.String), S3Uri: S.optional(S.String) }),
).annotate({
  identifier: "S3FileSystemConfig",
}) as any as S.Schema<S3FileSystemConfig>;
export type CustomFileSystemConfig =
  | {
      EFSFileSystemConfig: EFSFileSystemConfig;
      FSxLustreFileSystemConfig?: never;
      S3FileSystemConfig?: never;
    }
  | {
      EFSFileSystemConfig?: never;
      FSxLustreFileSystemConfig: FSxLustreFileSystemConfig;
      S3FileSystemConfig?: never;
    }
  | {
      EFSFileSystemConfig?: never;
      FSxLustreFileSystemConfig?: never;
      S3FileSystemConfig: S3FileSystemConfig;
    };
export const CustomFileSystemConfig = S.Union([
  S.Struct({ EFSFileSystemConfig: EFSFileSystemConfig }),
  S.Struct({ FSxLustreFileSystemConfig: FSxLustreFileSystemConfig }),
  S.Struct({ S3FileSystemConfig: S3FileSystemConfig }),
]);
export type CustomFileSystemConfigs = CustomFileSystemConfig[];
export const CustomFileSystemConfigs = S.Array(CustomFileSystemConfig);
export type MlTools =
  | "DataWrangler"
  | "FeatureStore"
  | "EmrClusters"
  | "AutoMl"
  | "Experiments"
  | "Training"
  | "ModelEvaluation"
  | "Pipelines"
  | "Models"
  | "JumpStart"
  | "InferenceRecommender"
  | "Endpoints"
  | "Projects"
  | "InferenceOptimization"
  | "PerformanceEvaluation"
  | "LakeraGuard"
  | "Comet"
  | "DeepchecksLLMEvaluation"
  | "Fiddler"
  | "HyperPodClusters"
  | "RunningInstances"
  | "Datasets"
  | "Evaluators"
  | (string & {});
export const MlTools = S.String;
export type HiddenMlToolsList = MlTools[];
export const HiddenMlToolsList = S.Array(MlTools);
export type HiddenAppTypesList = AppType[];
export const HiddenAppTypesList = S.Array(AppType);
export type HiddenInstanceTypesList = AppInstanceType[];
export const HiddenInstanceTypesList = S.Array(AppInstanceType);
export type SageMakerImageName = "sagemaker_distribution" | (string & {});
export const SageMakerImageName = S.String;
export type VersionAliasesList = string[];
export const VersionAliasesList = S.Array(S.String);
export interface HiddenSageMakerImage {
  SageMakerImageName?: SageMakerImageName;
  VersionAliases?: string[];
}
export const HiddenSageMakerImage = S.suspend(() =>
  S.Struct({
    SageMakerImageName: S.optional(SageMakerImageName),
    VersionAliases: S.optional(VersionAliasesList),
  }),
).annotate({
  identifier: "HiddenSageMakerImage",
}) as any as S.Schema<HiddenSageMakerImage>;
export type HiddenSageMakerImageVersionAliasesList = HiddenSageMakerImage[];
export const HiddenSageMakerImageVersionAliasesList =
  S.Array(HiddenSageMakerImage);
export interface StudioWebPortalSettings {
  HiddenMlTools?: MlTools[];
  HiddenAppTypes?: AppType[];
  HiddenInstanceTypes?: AppInstanceType[];
  HiddenSageMakerImageVersionAliases?: HiddenSageMakerImage[];
}
export const StudioWebPortalSettings = S.suspend(() =>
  S.Struct({
    HiddenMlTools: S.optional(HiddenMlToolsList),
    HiddenAppTypes: S.optional(HiddenAppTypesList),
    HiddenInstanceTypes: S.optional(HiddenInstanceTypesList),
    HiddenSageMakerImageVersionAliases: S.optional(
      HiddenSageMakerImageVersionAliasesList,
    ),
  }),
).annotate({
  identifier: "StudioWebPortalSettings",
}) as any as S.Schema<StudioWebPortalSettings>;
export type AutoMountHomeEFS =
  | "Enabled"
  | "Disabled"
  | "DefaultAsDomain"
  | (string & {});
export const AutoMountHomeEFS = S.String;
export interface UserSettings {
  ExecutionRole?: string;
  SecurityGroups?: string[];
  SharingSettings?: SharingSettings;
  JupyterServerAppSettings?: JupyterServerAppSettings;
  KernelGatewayAppSettings?: KernelGatewayAppSettings;
  TensorBoardAppSettings?: TensorBoardAppSettings;
  RStudioServerProAppSettings?: RStudioServerProAppSettings;
  RSessionAppSettings?: RSessionAppSettings;
  CanvasAppSettings?: CanvasAppSettings;
  CodeEditorAppSettings?: CodeEditorAppSettings;
  JupyterLabAppSettings?: JupyterLabAppSettings;
  SpaceStorageSettings?: DefaultSpaceStorageSettings;
  DefaultLandingUri?: string;
  StudioWebPortal?: StudioWebPortal;
  CustomPosixUserConfig?: CustomPosixUserConfig;
  CustomFileSystemConfigs?: CustomFileSystemConfig[];
  StudioWebPortalSettings?: StudioWebPortalSettings;
  AutoMountHomeEFS?: AutoMountHomeEFS;
}
export const UserSettings = S.suspend(() =>
  S.Struct({
    ExecutionRole: S.optional(S.String),
    SecurityGroups: S.optional(SecurityGroupIds),
    SharingSettings: S.optional(SharingSettings),
    JupyterServerAppSettings: S.optional(JupyterServerAppSettings),
    KernelGatewayAppSettings: S.optional(KernelGatewayAppSettings),
    TensorBoardAppSettings: S.optional(TensorBoardAppSettings),
    RStudioServerProAppSettings: S.optional(RStudioServerProAppSettings),
    RSessionAppSettings: S.optional(RSessionAppSettings),
    CanvasAppSettings: S.optional(CanvasAppSettings),
    CodeEditorAppSettings: S.optional(CodeEditorAppSettings),
    JupyterLabAppSettings: S.optional(JupyterLabAppSettings),
    SpaceStorageSettings: S.optional(DefaultSpaceStorageSettings),
    DefaultLandingUri: S.optional(S.String),
    StudioWebPortal: S.optional(StudioWebPortal),
    CustomPosixUserConfig: S.optional(CustomPosixUserConfig),
    CustomFileSystemConfigs: S.optional(CustomFileSystemConfigs),
    StudioWebPortalSettings: S.optional(StudioWebPortalSettings),
    AutoMountHomeEFS: S.optional(AutoMountHomeEFS),
  }),
).annotate({ identifier: "UserSettings" }) as any as S.Schema<UserSettings>;
export type DomainSecurityGroupIds = string[];
export const DomainSecurityGroupIds = S.Array(S.String);
export interface RStudioServerProDomainSettings {
  DomainExecutionRoleArn?: string;
  RStudioConnectUrl?: string;
  RStudioPackageManagerUrl?: string;
  DefaultResourceSpec?: ResourceSpec;
}
export const RStudioServerProDomainSettings = S.suspend(() =>
  S.Struct({
    DomainExecutionRoleArn: S.optional(S.String),
    RStudioConnectUrl: S.optional(S.String),
    RStudioPackageManagerUrl: S.optional(S.String),
    DefaultResourceSpec: S.optional(ResourceSpec),
  }),
).annotate({
  identifier: "RStudioServerProDomainSettings",
}) as any as S.Schema<RStudioServerProDomainSettings>;
export type ExecutionRoleIdentityConfig =
  | "USER_PROFILE_NAME"
  | "DISABLED"
  | (string & {});
export const ExecutionRoleIdentityConfig = S.String;
export interface TrustedIdentityPropagationSettings {
  Status?: FeatureStatus;
}
export const TrustedIdentityPropagationSettings = S.suspend(() =>
  S.Struct({ Status: S.optional(FeatureStatus) }),
).annotate({
  identifier: "TrustedIdentityPropagationSettings",
}) as any as S.Schema<TrustedIdentityPropagationSettings>;
export type VpcOnlyTrustedAccounts = string[];
export const VpcOnlyTrustedAccounts = S.Array(S.String);
export interface DockerSettings {
  EnableDockerAccess?: FeatureStatus;
  VpcOnlyTrustedAccounts?: string[];
  RootlessDocker?: FeatureStatus;
}
export const DockerSettings = S.suspend(() =>
  S.Struct({
    EnableDockerAccess: S.optional(FeatureStatus),
    VpcOnlyTrustedAccounts: S.optional(VpcOnlyTrustedAccounts),
    RootlessDocker: S.optional(FeatureStatus),
  }),
).annotate({ identifier: "DockerSettings" }) as any as S.Schema<DockerSettings>;
export interface AmazonQSettings {
  Status?: FeatureStatus;
  QProfileArn?: string;
}
export const AmazonQSettings = S.suspend(() =>
  S.Struct({
    Status: S.optional(FeatureStatus),
    QProfileArn: S.optional(S.String),
  }),
).annotate({
  identifier: "AmazonQSettings",
}) as any as S.Schema<AmazonQSettings>;
export interface UnifiedStudioSettings {
  StudioWebPortalAccess?: FeatureStatus;
  DomainAccountId?: string;
  DomainRegion?: string;
  DomainId?: string;
  ProjectId?: string;
  EnvironmentId?: string;
  ProjectS3Path?: string;
  SingleSignOnApplicationArn?: string;
}
export const UnifiedStudioSettings = S.suspend(() =>
  S.Struct({
    StudioWebPortalAccess: S.optional(FeatureStatus),
    DomainAccountId: S.optional(S.String),
    DomainRegion: S.optional(S.String),
    DomainId: S.optional(S.String),
    ProjectId: S.optional(S.String),
    EnvironmentId: S.optional(S.String),
    ProjectS3Path: S.optional(S.String),
    SingleSignOnApplicationArn: S.optional(S.String),
  }),
).annotate({
  identifier: "UnifiedStudioSettings",
}) as any as S.Schema<UnifiedStudioSettings>;
export type IPAddressType = "ipv4" | "dualstack" | (string & {});
export const IPAddressType = S.String;
export interface DomainSettings {
  SecurityGroupIds?: string[];
  RStudioServerProDomainSettings?: RStudioServerProDomainSettings;
  ExecutionRoleIdentityConfig?: ExecutionRoleIdentityConfig;
  TrustedIdentityPropagationSettings?: TrustedIdentityPropagationSettings;
  DockerSettings?: DockerSettings;
  AmazonQSettings?: AmazonQSettings;
  UnifiedStudioSettings?: UnifiedStudioSettings;
  IpAddressType?: IPAddressType;
}
export const DomainSettings = S.suspend(() =>
  S.Struct({
    SecurityGroupIds: S.optional(DomainSecurityGroupIds),
    RStudioServerProDomainSettings: S.optional(RStudioServerProDomainSettings),
    ExecutionRoleIdentityConfig: S.optional(ExecutionRoleIdentityConfig),
    TrustedIdentityPropagationSettings: S.optional(
      TrustedIdentityPropagationSettings,
    ),
    DockerSettings: S.optional(DockerSettings),
    AmazonQSettings: S.optional(AmazonQSettings),
    UnifiedStudioSettings: S.optional(UnifiedStudioSettings),
    IpAddressType: S.optional(IPAddressType),
  }),
).annotate({ identifier: "DomainSettings" }) as any as S.Schema<DomainSettings>;
export type AppNetworkAccessType =
  | "PublicInternetOnly"
  | "VpcOnly"
  | (string & {});
export const AppNetworkAccessType = S.String;
export type AppSecurityGroupManagement = "Service" | "Customer" | (string & {});
export const AppSecurityGroupManagement = S.String;
export type TagPropagation = "ENABLED" | "DISABLED" | (string & {});
export const TagPropagation = S.String;
export interface DefaultSpaceSettings {
  ExecutionRole?: string;
  SecurityGroups?: string[];
  JupyterServerAppSettings?: JupyterServerAppSettings;
  KernelGatewayAppSettings?: KernelGatewayAppSettings;
  JupyterLabAppSettings?: JupyterLabAppSettings;
  SpaceStorageSettings?: DefaultSpaceStorageSettings;
  CustomPosixUserConfig?: CustomPosixUserConfig;
  CustomFileSystemConfigs?: CustomFileSystemConfig[];
}
export const DefaultSpaceSettings = S.suspend(() =>
  S.Struct({
    ExecutionRole: S.optional(S.String),
    SecurityGroups: S.optional(SecurityGroupIds),
    JupyterServerAppSettings: S.optional(JupyterServerAppSettings),
    KernelGatewayAppSettings: S.optional(KernelGatewayAppSettings),
    JupyterLabAppSettings: S.optional(JupyterLabAppSettings),
    SpaceStorageSettings: S.optional(DefaultSpaceStorageSettings),
    CustomPosixUserConfig: S.optional(CustomPosixUserConfig),
    CustomFileSystemConfigs: S.optional(CustomFileSystemConfigs),
  }),
).annotate({
  identifier: "DefaultSpaceSettings",
}) as any as S.Schema<DefaultSpaceSettings>;
export interface CreateDomainRequest {
  DomainName?: string;
  AuthMode?: AuthMode;
  DefaultUserSettings?: UserSettings;
  DomainSettings?: DomainSettings;
  SubnetIds?: string[];
  VpcId?: string;
  Tags?: Tag[];
  AppNetworkAccessType?: AppNetworkAccessType;
  HomeEfsFileSystemKmsKeyId?: string;
  KmsKeyId?: string;
  AppSecurityGroupManagement?: AppSecurityGroupManagement;
  TagPropagation?: TagPropagation;
  DefaultSpaceSettings?: DefaultSpaceSettings;
}
export const CreateDomainRequest = S.suspend(() =>
  S.Struct({
    DomainName: S.optional(S.String),
    AuthMode: S.optional(AuthMode),
    DefaultUserSettings: S.optional(UserSettings),
    DomainSettings: S.optional(DomainSettings),
    SubnetIds: S.optional(Subnets),
    VpcId: S.optional(S.String),
    Tags: S.optional(TagList),
    AppNetworkAccessType: S.optional(AppNetworkAccessType),
    HomeEfsFileSystemKmsKeyId: S.optional(S.String),
    KmsKeyId: S.optional(S.String),
    AppSecurityGroupManagement: S.optional(AppSecurityGroupManagement),
    TagPropagation: S.optional(TagPropagation),
    DefaultSpaceSettings: S.optional(DefaultSpaceSettings),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateDomainRequest",
}) as any as S.Schema<CreateDomainRequest>;
export interface CreateDomainResponse {
  DomainArn?: string;
  DomainId?: string;
  Url?: string;
}
export const CreateDomainResponse = S.suspend(() =>
  S.Struct({
    DomainArn: S.optional(S.String),
    DomainId: S.optional(S.String),
    Url: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "CreateDomainResponse",
}) as any as S.Schema<CreateDomainResponse>;
export interface EdgeDeploymentModelConfig {
  ModelHandle?: string;
  EdgePackagingJobName?: string;
}
export const EdgeDeploymentModelConfig = S.suspend(() =>
  S.Struct({
    ModelHandle: S.optional(S.String),
    EdgePackagingJobName: S.optional(S.String),
  }),
).annotate({
  identifier: "EdgeDeploymentModelConfig",
}) as any as S.Schema<EdgeDeploymentModelConfig>;
export type EdgeDeploymentModelConfigs = EdgeDeploymentModelConfig[];
export const EdgeDeploymentModelConfigs = S.Array(EdgeDeploymentModelConfig);
export type DeviceSubsetType =
  | "PERCENTAGE"
  | "SELECTION"
  | "NAMECONTAINS"
  | (string & {});
export const DeviceSubsetType = S.String;
export type DeviceNames = string[];
export const DeviceNames = S.Array(S.String);
export interface DeviceSelectionConfig {
  DeviceSubsetType?: DeviceSubsetType;
  Percentage?: number;
  DeviceNames?: string[];
  DeviceNameContains?: string;
}
export const DeviceSelectionConfig = S.suspend(() =>
  S.Struct({
    DeviceSubsetType: S.optional(DeviceSubsetType),
    Percentage: S.optional(S.Number),
    DeviceNames: S.optional(DeviceNames),
    DeviceNameContains: S.optional(S.String),
  }),
).annotate({
  identifier: "DeviceSelectionConfig",
}) as any as S.Schema<DeviceSelectionConfig>;
export type FailureHandlingPolicy =
  | "ROLLBACK_ON_FAILURE"
  | "DO_NOTHING"
  | (string & {});
export const FailureHandlingPolicy = S.String;
export interface EdgeDeploymentConfig {
  FailureHandlingPolicy?: FailureHandlingPolicy;
}
export const EdgeDeploymentConfig = S.suspend(() =>
  S.Struct({ FailureHandlingPolicy: S.optional(FailureHandlingPolicy) }),
).annotate({
  identifier: "EdgeDeploymentConfig",
}) as any as S.Schema<EdgeDeploymentConfig>;
export interface DeploymentStage {
  StageName?: string;
  DeviceSelectionConfig?: DeviceSelectionConfig;
  DeploymentConfig?: EdgeDeploymentConfig;
}
export const DeploymentStage = S.suspend(() =>
  S.Struct({
    StageName: S.optional(S.String),
    DeviceSelectionConfig: S.optional(DeviceSelectionConfig),
    DeploymentConfig: S.optional(EdgeDeploymentConfig),
  }),
).annotate({
  identifier: "DeploymentStage",
}) as any as S.Schema<DeploymentStage>;
export type DeploymentStages = DeploymentStage[];
export const DeploymentStages = S.Array(DeploymentStage);
export interface CreateEdgeDeploymentPlanRequest {
  EdgeDeploymentPlanName?: string;
  ModelConfigs?: EdgeDeploymentModelConfig[];
  DeviceFleetName?: string;
  Stages?: DeploymentStage[];
  Tags?: Tag[];
}
export const CreateEdgeDeploymentPlanRequest = S.suspend(() =>
  S.Struct({
    EdgeDeploymentPlanName: S.optional(S.String),
    ModelConfigs: S.optional(EdgeDeploymentModelConfigs),
    DeviceFleetName: S.optional(S.String),
    Stages: S.optional(DeploymentStages),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateEdgeDeploymentPlanRequest",
}) as any as S.Schema<CreateEdgeDeploymentPlanRequest>;
export interface CreateEdgeDeploymentPlanResponse {
  EdgeDeploymentPlanArn: string;
}
export const CreateEdgeDeploymentPlanResponse = S.suspend(() =>
  S.Struct({ EdgeDeploymentPlanArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateEdgeDeploymentPlanResponse",
}) as any as S.Schema<CreateEdgeDeploymentPlanResponse>;
export interface CreateEdgeDeploymentStageRequest {
  EdgeDeploymentPlanName?: string;
  Stages?: DeploymentStage[];
}
export const CreateEdgeDeploymentStageRequest = S.suspend(() =>
  S.Struct({
    EdgeDeploymentPlanName: S.optional(S.String),
    Stages: S.optional(DeploymentStages),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateEdgeDeploymentStageRequest",
}) as any as S.Schema<CreateEdgeDeploymentStageRequest>;
export interface CreateEdgeDeploymentStageResponse {}
export const CreateEdgeDeploymentStageResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "CreateEdgeDeploymentStageResponse",
}) as any as S.Schema<CreateEdgeDeploymentStageResponse>;
export interface CreateEdgePackagingJobRequest {
  EdgePackagingJobName?: string;
  CompilationJobName?: string;
  ModelName?: string;
  ModelVersion?: string;
  RoleArn?: string;
  OutputConfig?: EdgeOutputConfig;
  ResourceKey?: string;
  Tags?: Tag[];
}
export const CreateEdgePackagingJobRequest = S.suspend(() =>
  S.Struct({
    EdgePackagingJobName: S.optional(S.String),
    CompilationJobName: S.optional(S.String),
    ModelName: S.optional(S.String),
    ModelVersion: S.optional(S.String),
    RoleArn: S.optional(S.String),
    OutputConfig: S.optional(EdgeOutputConfig),
    ResourceKey: S.optional(S.String),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateEdgePackagingJobRequest",
}) as any as S.Schema<CreateEdgePackagingJobRequest>;
export interface CreateEdgePackagingJobResponse {}
export const CreateEdgePackagingJobResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "CreateEdgePackagingJobResponse",
}) as any as S.Schema<CreateEdgePackagingJobResponse>;
export type TrafficRoutingConfigType =
  | "ALL_AT_ONCE"
  | "CANARY"
  | "LINEAR"
  | (string & {});
export const TrafficRoutingConfigType = S.String;
export type CapacitySizeType =
  | "INSTANCE_COUNT"
  | "CAPACITY_PERCENT"
  | (string & {});
export const CapacitySizeType = S.String;
export interface CapacitySize {
  Type?: CapacitySizeType;
  Value?: number;
}
export const CapacitySize = S.suspend(() =>
  S.Struct({ Type: S.optional(CapacitySizeType), Value: S.optional(S.Number) }),
).annotate({ identifier: "CapacitySize" }) as any as S.Schema<CapacitySize>;
export interface TrafficRoutingConfig {
  Type?: TrafficRoutingConfigType;
  WaitIntervalInSeconds?: number;
  CanarySize?: CapacitySize;
  LinearStepSize?: CapacitySize;
}
export const TrafficRoutingConfig = S.suspend(() =>
  S.Struct({
    Type: S.optional(TrafficRoutingConfigType),
    WaitIntervalInSeconds: S.optional(S.Number),
    CanarySize: S.optional(CapacitySize),
    LinearStepSize: S.optional(CapacitySize),
  }),
).annotate({
  identifier: "TrafficRoutingConfig",
}) as any as S.Schema<TrafficRoutingConfig>;
export interface BlueGreenUpdatePolicy {
  TrafficRoutingConfiguration?: TrafficRoutingConfig;
  TerminationWaitInSeconds?: number;
  MaximumExecutionTimeoutInSeconds?: number;
}
export const BlueGreenUpdatePolicy = S.suspend(() =>
  S.Struct({
    TrafficRoutingConfiguration: S.optional(TrafficRoutingConfig),
    TerminationWaitInSeconds: S.optional(S.Number),
    MaximumExecutionTimeoutInSeconds: S.optional(S.Number),
  }),
).annotate({
  identifier: "BlueGreenUpdatePolicy",
}) as any as S.Schema<BlueGreenUpdatePolicy>;
export interface RollingUpdatePolicy {
  MaximumBatchSize?: CapacitySize;
  WaitIntervalInSeconds?: number;
  MaximumExecutionTimeoutInSeconds?: number;
  RollbackMaximumBatchSize?: CapacitySize;
}
export const RollingUpdatePolicy = S.suspend(() =>
  S.Struct({
    MaximumBatchSize: S.optional(CapacitySize),
    WaitIntervalInSeconds: S.optional(S.Number),
    MaximumExecutionTimeoutInSeconds: S.optional(S.Number),
    RollbackMaximumBatchSize: S.optional(CapacitySize),
  }),
).annotate({
  identifier: "RollingUpdatePolicy",
}) as any as S.Schema<RollingUpdatePolicy>;
export interface Alarm {
  AlarmName?: string;
}
export const Alarm = S.suspend(() =>
  S.Struct({ AlarmName: S.optional(S.String) }),
).annotate({ identifier: "Alarm" }) as any as S.Schema<Alarm>;
export type AlarmList = Alarm[];
export const AlarmList = S.Array(Alarm);
export interface AutoRollbackConfig {
  Alarms?: Alarm[];
}
export const AutoRollbackConfig = S.suspend(() =>
  S.Struct({ Alarms: S.optional(AlarmList) }),
).annotate({
  identifier: "AutoRollbackConfig",
}) as any as S.Schema<AutoRollbackConfig>;
export interface DeploymentConfig {
  BlueGreenUpdatePolicy?: BlueGreenUpdatePolicy;
  RollingUpdatePolicy?: RollingUpdatePolicy;
  AutoRollbackConfiguration?: AutoRollbackConfig;
}
export const DeploymentConfig = S.suspend(() =>
  S.Struct({
    BlueGreenUpdatePolicy: S.optional(BlueGreenUpdatePolicy),
    RollingUpdatePolicy: S.optional(RollingUpdatePolicy),
    AutoRollbackConfiguration: S.optional(AutoRollbackConfig),
  }),
).annotate({
  identifier: "DeploymentConfig",
}) as any as S.Schema<DeploymentConfig>;
export interface CreateEndpointInput {
  EndpointName?: string;
  EndpointConfigName?: string;
  DeploymentConfig?: DeploymentConfig;
  Tags?: Tag[];
}
export const CreateEndpointInput = S.suspend(() =>
  S.Struct({
    EndpointName: S.optional(S.String),
    EndpointConfigName: S.optional(S.String),
    DeploymentConfig: S.optional(DeploymentConfig),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateEndpointInput",
}) as any as S.Schema<CreateEndpointInput>;
export interface CreateEndpointOutput {
  EndpointArn: string;
}
export const CreateEndpointOutput = S.suspend(() =>
  S.Struct({ EndpointArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateEndpointOutput",
}) as any as S.Schema<CreateEndpointOutput>;
export type ProductionVariantAcceleratorType =
  | "ml.eia1.medium"
  | "ml.eia1.large"
  | "ml.eia1.xlarge"
  | "ml.eia2.medium"
  | "ml.eia2.large"
  | "ml.eia2.xlarge"
  | (string & {});
export const ProductionVariantAcceleratorType = S.String;
export interface ProductionVariantCoreDumpConfig {
  DestinationS3Uri?: string;
  KmsKeyId?: string;
}
export const ProductionVariantCoreDumpConfig = S.suspend(() =>
  S.Struct({
    DestinationS3Uri: S.optional(S.String),
    KmsKeyId: S.optional(S.String),
  }),
).annotate({
  identifier: "ProductionVariantCoreDumpConfig",
}) as any as S.Schema<ProductionVariantCoreDumpConfig>;
export interface ProductionVariantServerlessConfig {
  MemorySizeInMB?: number;
  MaxConcurrency?: number;
  ProvisionedConcurrency?: number;
}
export const ProductionVariantServerlessConfig = S.suspend(() =>
  S.Struct({
    MemorySizeInMB: S.optional(S.Number),
    MaxConcurrency: S.optional(S.Number),
    ProvisionedConcurrency: S.optional(S.Number),
  }),
).annotate({
  identifier: "ProductionVariantServerlessConfig",
}) as any as S.Schema<ProductionVariantServerlessConfig>;
export type ManagedInstanceScalingStatus =
  | "ENABLED"
  | "DISABLED"
  | (string & {});
export const ManagedInstanceScalingStatus = S.String;
export interface ProductionVariantManagedInstanceScaling {
  Status?: ManagedInstanceScalingStatus;
  MinInstanceCount?: number;
  MaxInstanceCount?: number;
}
export const ProductionVariantManagedInstanceScaling = S.suspend(() =>
  S.Struct({
    Status: S.optional(ManagedInstanceScalingStatus),
    MinInstanceCount: S.optional(S.Number),
    MaxInstanceCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "ProductionVariantManagedInstanceScaling",
}) as any as S.Schema<ProductionVariantManagedInstanceScaling>;
export type RoutingStrategy =
  | "LEAST_OUTSTANDING_REQUESTS"
  | "RANDOM"
  | (string & {});
export const RoutingStrategy = S.String;
export interface ProductionVariantRoutingConfig {
  RoutingStrategy?: RoutingStrategy;
}
export const ProductionVariantRoutingConfig = S.suspend(() =>
  S.Struct({ RoutingStrategy: S.optional(RoutingStrategy) }),
).annotate({
  identifier: "ProductionVariantRoutingConfig",
}) as any as S.Schema<ProductionVariantRoutingConfig>;
export type ProductionVariantInferenceAmiVersion =
  | "al2-ami-sagemaker-inference-gpu-2"
  | "al2-ami-sagemaker-inference-gpu-2-1"
  | "al2-ami-sagemaker-inference-gpu-3-1"
  | "al2-ami-sagemaker-inference-neuron-2"
  | (string & {});
export const ProductionVariantInferenceAmiVersion = S.String;
export type CapacityReservationPreference =
  | "capacity-reservations-only"
  | (string & {});
export const CapacityReservationPreference = S.String;
export interface ProductionVariantCapacityReservationConfig {
  CapacityReservationPreference?: CapacityReservationPreference;
  MlReservationArn?: string;
}
export const ProductionVariantCapacityReservationConfig = S.suspend(() =>
  S.Struct({
    CapacityReservationPreference: S.optional(CapacityReservationPreference),
    MlReservationArn: S.optional(S.String),
  }),
).annotate({
  identifier: "ProductionVariantCapacityReservationConfig",
}) as any as S.Schema<ProductionVariantCapacityReservationConfig>;
export interface ProductionVariant {
  VariantName?: string;
  ModelName?: string;
  InitialInstanceCount?: number;
  InstanceType?: ProductionVariantInstanceType;
  InitialVariantWeight?: number;
  AcceleratorType?: ProductionVariantAcceleratorType;
  CoreDumpConfig?: ProductionVariantCoreDumpConfig;
  ServerlessConfig?: ProductionVariantServerlessConfig;
  VolumeSizeInGB?: number;
  ModelDataDownloadTimeoutInSeconds?: number;
  ContainerStartupHealthCheckTimeoutInSeconds?: number;
  EnableSSMAccess?: boolean;
  ManagedInstanceScaling?: ProductionVariantManagedInstanceScaling;
  RoutingConfig?: ProductionVariantRoutingConfig;
  InferenceAmiVersion?: ProductionVariantInferenceAmiVersion;
  CapacityReservationConfig?: ProductionVariantCapacityReservationConfig;
}
export const ProductionVariant = S.suspend(() =>
  S.Struct({
    VariantName: S.optional(S.String),
    ModelName: S.optional(S.String),
    InitialInstanceCount: S.optional(S.Number),
    InstanceType: S.optional(ProductionVariantInstanceType),
    InitialVariantWeight: S.optional(S.Number),
    AcceleratorType: S.optional(ProductionVariantAcceleratorType),
    CoreDumpConfig: S.optional(ProductionVariantCoreDumpConfig),
    ServerlessConfig: S.optional(ProductionVariantServerlessConfig),
    VolumeSizeInGB: S.optional(S.Number),
    ModelDataDownloadTimeoutInSeconds: S.optional(S.Number),
    ContainerStartupHealthCheckTimeoutInSeconds: S.optional(S.Number),
    EnableSSMAccess: S.optional(S.Boolean),
    ManagedInstanceScaling: S.optional(ProductionVariantManagedInstanceScaling),
    RoutingConfig: S.optional(ProductionVariantRoutingConfig),
    InferenceAmiVersion: S.optional(ProductionVariantInferenceAmiVersion),
    CapacityReservationConfig: S.optional(
      ProductionVariantCapacityReservationConfig,
    ),
  }),
).annotate({
  identifier: "ProductionVariant",
}) as any as S.Schema<ProductionVariant>;
export type ProductionVariantList = ProductionVariant[];
export const ProductionVariantList = S.Array(ProductionVariant);
export type CaptureMode = "Input" | "Output" | "InputAndOutput" | (string & {});
export const CaptureMode = S.String;
export interface CaptureOption {
  CaptureMode?: CaptureMode;
}
export const CaptureOption = S.suspend(() =>
  S.Struct({ CaptureMode: S.optional(CaptureMode) }),
).annotate({ identifier: "CaptureOption" }) as any as S.Schema<CaptureOption>;
export type CaptureOptionList = CaptureOption[];
export const CaptureOptionList = S.Array(CaptureOption);
export type CsvContentTypes = string[];
export const CsvContentTypes = S.Array(S.String);
export type JsonContentTypes = string[];
export const JsonContentTypes = S.Array(S.String);
export interface CaptureContentTypeHeader {
  CsvContentTypes?: string[];
  JsonContentTypes?: string[];
}
export const CaptureContentTypeHeader = S.suspend(() =>
  S.Struct({
    CsvContentTypes: S.optional(CsvContentTypes),
    JsonContentTypes: S.optional(JsonContentTypes),
  }),
).annotate({
  identifier: "CaptureContentTypeHeader",
}) as any as S.Schema<CaptureContentTypeHeader>;
export interface DataCaptureConfig {
  EnableCapture?: boolean;
  InitialSamplingPercentage?: number;
  DestinationS3Uri?: string;
  KmsKeyId?: string;
  CaptureOptions?: CaptureOption[];
  CaptureContentTypeHeader?: CaptureContentTypeHeader;
}
export const DataCaptureConfig = S.suspend(() =>
  S.Struct({
    EnableCapture: S.optional(S.Boolean),
    InitialSamplingPercentage: S.optional(S.Number),
    DestinationS3Uri: S.optional(S.String),
    KmsKeyId: S.optional(S.String),
    CaptureOptions: S.optional(CaptureOptionList),
    CaptureContentTypeHeader: S.optional(CaptureContentTypeHeader),
  }),
).annotate({
  identifier: "DataCaptureConfig",
}) as any as S.Schema<DataCaptureConfig>;
export interface AsyncInferenceClientConfig {
  MaxConcurrentInvocationsPerInstance?: number;
}
export const AsyncInferenceClientConfig = S.suspend(() =>
  S.Struct({ MaxConcurrentInvocationsPerInstance: S.optional(S.Number) }),
).annotate({
  identifier: "AsyncInferenceClientConfig",
}) as any as S.Schema<AsyncInferenceClientConfig>;
export type AsyncNotificationTopicTypes =
  | "SUCCESS_NOTIFICATION_TOPIC"
  | "ERROR_NOTIFICATION_TOPIC"
  | (string & {});
export const AsyncNotificationTopicTypes = S.String;
export type AsyncNotificationTopicTypeList = AsyncNotificationTopicTypes[];
export const AsyncNotificationTopicTypeList = S.Array(
  AsyncNotificationTopicTypes,
);
export interface AsyncInferenceNotificationConfig {
  SuccessTopic?: string;
  ErrorTopic?: string;
  IncludeInferenceResponseIn?: AsyncNotificationTopicTypes[];
}
export const AsyncInferenceNotificationConfig = S.suspend(() =>
  S.Struct({
    SuccessTopic: S.optional(S.String),
    ErrorTopic: S.optional(S.String),
    IncludeInferenceResponseIn: S.optional(AsyncNotificationTopicTypeList),
  }),
).annotate({
  identifier: "AsyncInferenceNotificationConfig",
}) as any as S.Schema<AsyncInferenceNotificationConfig>;
export interface AsyncInferenceOutputConfig {
  KmsKeyId?: string;
  S3OutputPath?: string;
  NotificationConfig?: AsyncInferenceNotificationConfig;
  S3FailurePath?: string;
}
export const AsyncInferenceOutputConfig = S.suspend(() =>
  S.Struct({
    KmsKeyId: S.optional(S.String),
    S3OutputPath: S.optional(S.String),
    NotificationConfig: S.optional(AsyncInferenceNotificationConfig),
    S3FailurePath: S.optional(S.String),
  }),
).annotate({
  identifier: "AsyncInferenceOutputConfig",
}) as any as S.Schema<AsyncInferenceOutputConfig>;
export interface AsyncInferenceConfig {
  ClientConfig?: AsyncInferenceClientConfig;
  OutputConfig?: AsyncInferenceOutputConfig;
}
export const AsyncInferenceConfig = S.suspend(() =>
  S.Struct({
    ClientConfig: S.optional(AsyncInferenceClientConfig),
    OutputConfig: S.optional(AsyncInferenceOutputConfig),
  }),
).annotate({
  identifier: "AsyncInferenceConfig",
}) as any as S.Schema<AsyncInferenceConfig>;
export type ClarifyLabelHeaders = string[];
export const ClarifyLabelHeaders = S.Array(S.String);
export type ClarifyFeatureHeaders = string[];
export const ClarifyFeatureHeaders = S.Array(S.String);
export type ClarifyFeatureType =
  | "numerical"
  | "categorical"
  | "text"
  | (string & {});
export const ClarifyFeatureType = S.String;
export type ClarifyFeatureTypes = ClarifyFeatureType[];
export const ClarifyFeatureTypes = S.Array(ClarifyFeatureType);
export interface ClarifyInferenceConfig {
  FeaturesAttribute?: string;
  ContentTemplate?: string;
  MaxRecordCount?: number;
  MaxPayloadInMB?: number;
  ProbabilityIndex?: number;
  LabelIndex?: number;
  ProbabilityAttribute?: string;
  LabelAttribute?: string;
  LabelHeaders?: string[];
  FeatureHeaders?: string[];
  FeatureTypes?: ClarifyFeatureType[];
}
export const ClarifyInferenceConfig = S.suspend(() =>
  S.Struct({
    FeaturesAttribute: S.optional(S.String),
    ContentTemplate: S.optional(S.String),
    MaxRecordCount: S.optional(S.Number),
    MaxPayloadInMB: S.optional(S.Number),
    ProbabilityIndex: S.optional(S.Number),
    LabelIndex: S.optional(S.Number),
    ProbabilityAttribute: S.optional(S.String),
    LabelAttribute: S.optional(S.String),
    LabelHeaders: S.optional(ClarifyLabelHeaders),
    FeatureHeaders: S.optional(ClarifyFeatureHeaders),
    FeatureTypes: S.optional(ClarifyFeatureTypes),
  }),
).annotate({
  identifier: "ClarifyInferenceConfig",
}) as any as S.Schema<ClarifyInferenceConfig>;
export interface ClarifyShapBaselineConfig {
  MimeType?: string;
  ShapBaseline?: string;
  ShapBaselineUri?: string;
}
export const ClarifyShapBaselineConfig = S.suspend(() =>
  S.Struct({
    MimeType: S.optional(S.String),
    ShapBaseline: S.optional(S.String),
    ShapBaselineUri: S.optional(S.String),
  }),
).annotate({
  identifier: "ClarifyShapBaselineConfig",
}) as any as S.Schema<ClarifyShapBaselineConfig>;
export type ClarifyTextLanguage =
  | "af"
  | "sq"
  | "ar"
  | "hy"
  | "eu"
  | "bn"
  | "bg"
  | "ca"
  | "zh"
  | "hr"
  | "cs"
  | "da"
  | "nl"
  | "en"
  | "et"
  | "fi"
  | "fr"
  | "de"
  | "el"
  | "gu"
  | "he"
  | "hi"
  | "hu"
  | "is"
  | "id"
  | "ga"
  | "it"
  | "kn"
  | "ky"
  | "lv"
  | "lt"
  | "lb"
  | "mk"
  | "ml"
  | "mr"
  | "ne"
  | "nb"
  | "fa"
  | "pl"
  | "pt"
  | "ro"
  | "ru"
  | "sa"
  | "sr"
  | "tn"
  | "si"
  | "sk"
  | "sl"
  | "es"
  | "sv"
  | "tl"
  | "ta"
  | "tt"
  | "te"
  | "tr"
  | "uk"
  | "ur"
  | "yo"
  | "lij"
  | "xx"
  | (string & {});
export const ClarifyTextLanguage = S.String;
export type ClarifyTextGranularity =
  | "token"
  | "sentence"
  | "paragraph"
  | (string & {});
export const ClarifyTextGranularity = S.String;
export interface ClarifyTextConfig {
  Language?: ClarifyTextLanguage;
  Granularity?: ClarifyTextGranularity;
}
export const ClarifyTextConfig = S.suspend(() =>
  S.Struct({
    Language: S.optional(ClarifyTextLanguage),
    Granularity: S.optional(ClarifyTextGranularity),
  }),
).annotate({
  identifier: "ClarifyTextConfig",
}) as any as S.Schema<ClarifyTextConfig>;
export interface ClarifyShapConfig {
  ShapBaselineConfig?: ClarifyShapBaselineConfig;
  NumberOfSamples?: number;
  UseLogit?: boolean;
  Seed?: number;
  TextConfig?: ClarifyTextConfig;
}
export const ClarifyShapConfig = S.suspend(() =>
  S.Struct({
    ShapBaselineConfig: S.optional(ClarifyShapBaselineConfig),
    NumberOfSamples: S.optional(S.Number),
    UseLogit: S.optional(S.Boolean),
    Seed: S.optional(S.Number),
    TextConfig: S.optional(ClarifyTextConfig),
  }),
).annotate({
  identifier: "ClarifyShapConfig",
}) as any as S.Schema<ClarifyShapConfig>;
export interface ClarifyExplainerConfig {
  EnableExplanations?: string;
  InferenceConfig?: ClarifyInferenceConfig;
  ShapConfig?: ClarifyShapConfig;
}
export const ClarifyExplainerConfig = S.suspend(() =>
  S.Struct({
    EnableExplanations: S.optional(S.String),
    InferenceConfig: S.optional(ClarifyInferenceConfig),
    ShapConfig: S.optional(ClarifyShapConfig),
  }),
).annotate({
  identifier: "ClarifyExplainerConfig",
}) as any as S.Schema<ClarifyExplainerConfig>;
export interface ExplainerConfig {
  ClarifyExplainerConfig?: ClarifyExplainerConfig;
}
export const ExplainerConfig = S.suspend(() =>
  S.Struct({ ClarifyExplainerConfig: S.optional(ClarifyExplainerConfig) }),
).annotate({
  identifier: "ExplainerConfig",
}) as any as S.Schema<ExplainerConfig>;
export type MetricPublishFrequencyInSeconds =
  | 10
  | 30
  | 60
  | 120
  | 180
  | 240
  | 300;
export const MetricPublishFrequencyInSeconds = S.Literals([
  10, 30, 60, 120, 180, 240, 300,
]);
export interface MetricsConfig {
  EnableEnhancedMetrics?: boolean;
  MetricPublishFrequencyInSeconds?: MetricPublishFrequencyInSeconds;
}
export const MetricsConfig = S.suspend(() =>
  S.Struct({
    EnableEnhancedMetrics: S.optional(S.Boolean),
    MetricPublishFrequencyInSeconds: S.optional(
      MetricPublishFrequencyInSeconds,
    ),
  }),
).annotate({ identifier: "MetricsConfig" }) as any as S.Schema<MetricsConfig>;
export interface CreateEndpointConfigInput {
  EndpointConfigName?: string;
  ProductionVariants?: ProductionVariant[];
  DataCaptureConfig?: DataCaptureConfig;
  Tags?: Tag[];
  KmsKeyId?: string;
  AsyncInferenceConfig?: AsyncInferenceConfig;
  ExplainerConfig?: ExplainerConfig;
  ShadowProductionVariants?: ProductionVariant[];
  ExecutionRoleArn?: string;
  VpcConfig?: VpcConfig;
  EnableNetworkIsolation?: boolean;
  MetricsConfig?: MetricsConfig;
}
export const CreateEndpointConfigInput = S.suspend(() =>
  S.Struct({
    EndpointConfigName: S.optional(S.String),
    ProductionVariants: S.optional(ProductionVariantList),
    DataCaptureConfig: S.optional(DataCaptureConfig),
    Tags: S.optional(TagList),
    KmsKeyId: S.optional(S.String),
    AsyncInferenceConfig: S.optional(AsyncInferenceConfig),
    ExplainerConfig: S.optional(ExplainerConfig),
    ShadowProductionVariants: S.optional(ProductionVariantList),
    ExecutionRoleArn: S.optional(S.String),
    VpcConfig: S.optional(VpcConfig),
    EnableNetworkIsolation: S.optional(S.Boolean),
    MetricsConfig: S.optional(MetricsConfig),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateEndpointConfigInput",
}) as any as S.Schema<CreateEndpointConfigInput>;
export interface CreateEndpointConfigOutput {
  EndpointConfigArn: string;
}
export const CreateEndpointConfigOutput = S.suspend(() =>
  S.Struct({ EndpointConfigArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateEndpointConfigOutput",
}) as any as S.Schema<CreateEndpointConfigOutput>;
export interface CreateExperimentRequest {
  ExperimentName?: string;
  DisplayName?: string;
  Description?: string;
  Tags?: Tag[];
}
export const CreateExperimentRequest = S.suspend(() =>
  S.Struct({
    ExperimentName: S.optional(S.String),
    DisplayName: S.optional(S.String),
    Description: S.optional(S.String),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateExperimentRequest",
}) as any as S.Schema<CreateExperimentRequest>;
export interface CreateExperimentResponse {
  ExperimentArn?: string;
}
export const CreateExperimentResponse = S.suspend(() =>
  S.Struct({ ExperimentArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateExperimentResponse",
}) as any as S.Schema<CreateExperimentResponse>;
export type FeatureType = "Integral" | "Fractional" | "String" | (string & {});
export const FeatureType = S.String;
export type CollectionType = "List" | "Set" | "Vector" | (string & {});
export const CollectionType = S.String;
export interface VectorConfig {
  Dimension?: number;
}
export const VectorConfig = S.suspend(() =>
  S.Struct({ Dimension: S.optional(S.Number) }),
).annotate({ identifier: "VectorConfig" }) as any as S.Schema<VectorConfig>;
export type CollectionConfig = { VectorConfig: VectorConfig };
export const CollectionConfig = S.Union([
  S.Struct({ VectorConfig: VectorConfig }),
]);
export interface FeatureDefinition {
  FeatureName?: string;
  FeatureType?: FeatureType;
  CollectionType?: CollectionType;
  CollectionConfig?: CollectionConfig;
}
export const FeatureDefinition = S.suspend(() =>
  S.Struct({
    FeatureName: S.optional(S.String),
    FeatureType: S.optional(FeatureType),
    CollectionType: S.optional(CollectionType),
    CollectionConfig: S.optional(CollectionConfig),
  }),
).annotate({
  identifier: "FeatureDefinition",
}) as any as S.Schema<FeatureDefinition>;
export type FeatureDefinitions = FeatureDefinition[];
export const FeatureDefinitions = S.Array(FeatureDefinition);
export interface OnlineStoreSecurityConfig {
  KmsKeyId?: string;
}
export const OnlineStoreSecurityConfig = S.suspend(() =>
  S.Struct({ KmsKeyId: S.optional(S.String) }),
).annotate({
  identifier: "OnlineStoreSecurityConfig",
}) as any as S.Schema<OnlineStoreSecurityConfig>;
export type TtlDurationUnit =
  | "Seconds"
  | "Minutes"
  | "Hours"
  | "Days"
  | "Weeks"
  | (string & {});
export const TtlDurationUnit = S.String;
export interface TtlDuration {
  Unit?: TtlDurationUnit;
  Value?: number;
}
export const TtlDuration = S.suspend(() =>
  S.Struct({ Unit: S.optional(TtlDurationUnit), Value: S.optional(S.Number) }),
).annotate({ identifier: "TtlDuration" }) as any as S.Schema<TtlDuration>;
export type StorageType = "Standard" | "InMemory" | (string & {});
export const StorageType = S.String;
export interface OnlineStoreConfig {
  SecurityConfig?: OnlineStoreSecurityConfig;
  EnableOnlineStore?: boolean;
  TtlDuration?: TtlDuration;
  StorageType?: StorageType;
}
export const OnlineStoreConfig = S.suspend(() =>
  S.Struct({
    SecurityConfig: S.optional(OnlineStoreSecurityConfig),
    EnableOnlineStore: S.optional(S.Boolean),
    TtlDuration: S.optional(TtlDuration),
    StorageType: S.optional(StorageType),
  }),
).annotate({
  identifier: "OnlineStoreConfig",
}) as any as S.Schema<OnlineStoreConfig>;
export interface S3StorageConfig {
  S3Uri?: string;
  KmsKeyId?: string;
  ResolvedOutputS3Uri?: string;
}
export const S3StorageConfig = S.suspend(() =>
  S.Struct({
    S3Uri: S.optional(S.String),
    KmsKeyId: S.optional(S.String),
    ResolvedOutputS3Uri: S.optional(S.String),
  }),
).annotate({
  identifier: "S3StorageConfig",
}) as any as S.Schema<S3StorageConfig>;
export interface DataCatalogConfig {
  TableName?: string;
  Catalog?: string;
  Database?: string;
}
export const DataCatalogConfig = S.suspend(() =>
  S.Struct({
    TableName: S.optional(S.String),
    Catalog: S.optional(S.String),
    Database: S.optional(S.String),
  }),
).annotate({
  identifier: "DataCatalogConfig",
}) as any as S.Schema<DataCatalogConfig>;
export type TableFormat = "Default" | "Glue" | "Iceberg" | (string & {});
export const TableFormat = S.String;
export interface OfflineStoreConfig {
  S3StorageConfig?: S3StorageConfig;
  DisableGlueTableCreation?: boolean;
  DataCatalogConfig?: DataCatalogConfig;
  TableFormat?: TableFormat;
}
export const OfflineStoreConfig = S.suspend(() =>
  S.Struct({
    S3StorageConfig: S.optional(S3StorageConfig),
    DisableGlueTableCreation: S.optional(S.Boolean),
    DataCatalogConfig: S.optional(DataCatalogConfig),
    TableFormat: S.optional(TableFormat),
  }),
).annotate({
  identifier: "OfflineStoreConfig",
}) as any as S.Schema<OfflineStoreConfig>;
export type ThroughputMode = "OnDemand" | "Provisioned" | (string & {});
export const ThroughputMode = S.String;
export interface ThroughputConfig {
  ThroughputMode?: ThroughputMode;
  ProvisionedReadCapacityUnits?: number;
  ProvisionedWriteCapacityUnits?: number;
}
export const ThroughputConfig = S.suspend(() =>
  S.Struct({
    ThroughputMode: S.optional(ThroughputMode),
    ProvisionedReadCapacityUnits: S.optional(S.Number),
    ProvisionedWriteCapacityUnits: S.optional(S.Number),
  }),
).annotate({
  identifier: "ThroughputConfig",
}) as any as S.Schema<ThroughputConfig>;
export interface CreateFeatureGroupRequest {
  FeatureGroupName?: string;
  RecordIdentifierFeatureName?: string;
  EventTimeFeatureName?: string;
  FeatureDefinitions?: FeatureDefinition[];
  OnlineStoreConfig?: OnlineStoreConfig;
  OfflineStoreConfig?: OfflineStoreConfig;
  ThroughputConfig?: ThroughputConfig;
  RoleArn?: string;
  Description?: string;
  Tags?: Tag[];
}
export const CreateFeatureGroupRequest = S.suspend(() =>
  S.Struct({
    FeatureGroupName: S.optional(S.String),
    RecordIdentifierFeatureName: S.optional(S.String),
    EventTimeFeatureName: S.optional(S.String),
    FeatureDefinitions: S.optional(FeatureDefinitions),
    OnlineStoreConfig: S.optional(OnlineStoreConfig),
    OfflineStoreConfig: S.optional(OfflineStoreConfig),
    ThroughputConfig: S.optional(ThroughputConfig),
    RoleArn: S.optional(S.String),
    Description: S.optional(S.String),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateFeatureGroupRequest",
}) as any as S.Schema<CreateFeatureGroupRequest>;
export interface CreateFeatureGroupResponse {
  FeatureGroupArn: string;
}
export const CreateFeatureGroupResponse = S.suspend(() =>
  S.Struct({ FeatureGroupArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateFeatureGroupResponse",
}) as any as S.Schema<CreateFeatureGroupResponse>;
export type AwsManagedHumanLoopRequestSource =
  | "AWS/Rekognition/DetectModerationLabels/Image/V3"
  | "AWS/Textract/AnalyzeDocument/Forms/V1"
  | (string & {});
export const AwsManagedHumanLoopRequestSource = S.String;
export interface HumanLoopRequestSource {
  AwsManagedHumanLoopRequestSource?: AwsManagedHumanLoopRequestSource;
}
export const HumanLoopRequestSource = S.suspend(() =>
  S.Struct({
    AwsManagedHumanLoopRequestSource: S.optional(
      AwsManagedHumanLoopRequestSource,
    ),
  }),
).annotate({
  identifier: "HumanLoopRequestSource",
}) as any as S.Schema<HumanLoopRequestSource>;
export interface HumanLoopActivationConditionsConfig {
  HumanLoopActivationConditions?: string;
}
export const HumanLoopActivationConditionsConfig = S.suspend(() =>
  S.Struct({ HumanLoopActivationConditions: S.optional(S.String) }),
).annotate({
  identifier: "HumanLoopActivationConditionsConfig",
}) as any as S.Schema<HumanLoopActivationConditionsConfig>;
export interface HumanLoopActivationConfig {
  HumanLoopActivationConditionsConfig?: HumanLoopActivationConditionsConfig;
}
export const HumanLoopActivationConfig = S.suspend(() =>
  S.Struct({
    HumanLoopActivationConditionsConfig: S.optional(
      HumanLoopActivationConditionsConfig,
    ),
  }),
).annotate({
  identifier: "HumanLoopActivationConfig",
}) as any as S.Schema<HumanLoopActivationConfig>;
export type FlowDefinitionTaskKeywords = string[];
export const FlowDefinitionTaskKeywords = S.Array(S.String);
export interface USD {
  Dollars?: number;
  Cents?: number;
  TenthFractionsOfACent?: number;
}
export const USD = S.suspend(() =>
  S.Struct({
    Dollars: S.optional(S.Number),
    Cents: S.optional(S.Number),
    TenthFractionsOfACent: S.optional(S.Number),
  }),
).annotate({ identifier: "USD" }) as any as S.Schema<USD>;
export interface PublicWorkforceTaskPrice {
  AmountInUsd?: USD;
}
export const PublicWorkforceTaskPrice = S.suspend(() =>
  S.Struct({ AmountInUsd: S.optional(USD) }),
).annotate({
  identifier: "PublicWorkforceTaskPrice",
}) as any as S.Schema<PublicWorkforceTaskPrice>;
export interface HumanLoopConfig {
  WorkteamArn?: string;
  HumanTaskUiArn?: string;
  TaskTitle?: string;
  TaskDescription?: string;
  TaskCount?: number;
  TaskAvailabilityLifetimeInSeconds?: number;
  TaskTimeLimitInSeconds?: number;
  TaskKeywords?: string[];
  PublicWorkforceTaskPrice?: PublicWorkforceTaskPrice;
}
export const HumanLoopConfig = S.suspend(() =>
  S.Struct({
    WorkteamArn: S.optional(S.String),
    HumanTaskUiArn: S.optional(S.String),
    TaskTitle: S.optional(S.String),
    TaskDescription: S.optional(S.String),
    TaskCount: S.optional(S.Number),
    TaskAvailabilityLifetimeInSeconds: S.optional(S.Number),
    TaskTimeLimitInSeconds: S.optional(S.Number),
    TaskKeywords: S.optional(FlowDefinitionTaskKeywords),
    PublicWorkforceTaskPrice: S.optional(PublicWorkforceTaskPrice),
  }),
).annotate({
  identifier: "HumanLoopConfig",
}) as any as S.Schema<HumanLoopConfig>;
export interface FlowDefinitionOutputConfig {
  S3OutputPath?: string;
  KmsKeyId?: string;
}
export const FlowDefinitionOutputConfig = S.suspend(() =>
  S.Struct({
    S3OutputPath: S.optional(S.String),
    KmsKeyId: S.optional(S.String),
  }),
).annotate({
  identifier: "FlowDefinitionOutputConfig",
}) as any as S.Schema<FlowDefinitionOutputConfig>;
export interface CreateFlowDefinitionRequest {
  FlowDefinitionName?: string;
  HumanLoopRequestSource?: HumanLoopRequestSource;
  HumanLoopActivationConfig?: HumanLoopActivationConfig;
  HumanLoopConfig?: HumanLoopConfig;
  OutputConfig?: FlowDefinitionOutputConfig;
  RoleArn?: string;
  Tags?: Tag[];
}
export const CreateFlowDefinitionRequest = S.suspend(() =>
  S.Struct({
    FlowDefinitionName: S.optional(S.String),
    HumanLoopRequestSource: S.optional(HumanLoopRequestSource),
    HumanLoopActivationConfig: S.optional(HumanLoopActivationConfig),
    HumanLoopConfig: S.optional(HumanLoopConfig),
    OutputConfig: S.optional(FlowDefinitionOutputConfig),
    RoleArn: S.optional(S.String),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateFlowDefinitionRequest",
}) as any as S.Schema<CreateFlowDefinitionRequest>;
export interface CreateFlowDefinitionResponse {
  FlowDefinitionArn: string;
}
export const CreateFlowDefinitionResponse = S.suspend(() =>
  S.Struct({ FlowDefinitionArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateFlowDefinitionResponse",
}) as any as S.Schema<CreateFlowDefinitionResponse>;
export type HubSearchKeywordList = string[];
export const HubSearchKeywordList = S.Array(S.String);
export interface HubS3StorageConfig {
  S3OutputPath?: string;
}
export const HubS3StorageConfig = S.suspend(() =>
  S.Struct({ S3OutputPath: S.optional(S.String) }),
).annotate({
  identifier: "HubS3StorageConfig",
}) as any as S.Schema<HubS3StorageConfig>;
export interface CreateHubRequest {
  HubName?: string;
  HubDescription?: string;
  HubDisplayName?: string;
  HubSearchKeywords?: string[];
  S3StorageConfig?: HubS3StorageConfig;
  Tags?: Tag[];
}
export const CreateHubRequest = S.suspend(() =>
  S.Struct({
    HubName: S.optional(S.String),
    HubDescription: S.optional(S.String),
    HubDisplayName: S.optional(S.String),
    HubSearchKeywords: S.optional(HubSearchKeywordList),
    S3StorageConfig: S.optional(HubS3StorageConfig),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateHubRequest",
}) as any as S.Schema<CreateHubRequest>;
export interface CreateHubResponse {
  HubArn: string;
}
export const CreateHubResponse = S.suspend(() =>
  S.Struct({ HubArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateHubResponse",
}) as any as S.Schema<CreateHubResponse>;
export type HubContentType =
  | "Model"
  | "Notebook"
  | "ModelReference"
  | "DataSet"
  | "JsonDoc"
  | (string & {});
export const HubContentType = S.String;
export interface PresignedUrlAccessConfig {
  AcceptEula?: boolean;
  ExpectedS3Url?: string;
}
export const PresignedUrlAccessConfig = S.suspend(() =>
  S.Struct({
    AcceptEula: S.optional(S.Boolean),
    ExpectedS3Url: S.optional(S.String),
  }),
).annotate({
  identifier: "PresignedUrlAccessConfig",
}) as any as S.Schema<PresignedUrlAccessConfig>;
export interface CreateHubContentPresignedUrlsRequest {
  HubName?: string;
  HubContentType?: HubContentType;
  HubContentName?: string;
  HubContentVersion?: string;
  AccessConfig?: PresignedUrlAccessConfig;
  MaxResults?: number;
  NextToken?: string;
}
export const CreateHubContentPresignedUrlsRequest = S.suspend(() =>
  S.Struct({
    HubName: S.optional(S.String),
    HubContentType: S.optional(HubContentType),
    HubContentName: S.optional(S.String),
    HubContentVersion: S.optional(S.String),
    AccessConfig: S.optional(PresignedUrlAccessConfig),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateHubContentPresignedUrlsRequest",
}) as any as S.Schema<CreateHubContentPresignedUrlsRequest>;
export interface AuthorizedUrl {
  Url?: string;
  LocalPath?: string;
}
export const AuthorizedUrl = S.suspend(() =>
  S.Struct({ Url: S.optional(S.String), LocalPath: S.optional(S.String) }),
).annotate({ identifier: "AuthorizedUrl" }) as any as S.Schema<AuthorizedUrl>;
export type AuthorizedUrlConfigs = AuthorizedUrl[];
export const AuthorizedUrlConfigs = S.Array(AuthorizedUrl);
export interface CreateHubContentPresignedUrlsResponse {
  AuthorizedUrlConfigs: AuthorizedUrl[];
  NextToken?: string;
}
export const CreateHubContentPresignedUrlsResponse = S.suspend(() =>
  S.Struct({
    AuthorizedUrlConfigs: S.optional(AuthorizedUrlConfigs),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "CreateHubContentPresignedUrlsResponse",
}) as any as S.Schema<CreateHubContentPresignedUrlsResponse>;
export interface CreateHubContentReferenceRequest {
  HubName?: string;
  SageMakerPublicHubContentArn?: string;
  HubContentName?: string;
  MinVersion?: string;
  Tags?: Tag[];
}
export const CreateHubContentReferenceRequest = S.suspend(() =>
  S.Struct({
    HubName: S.optional(S.String),
    SageMakerPublicHubContentArn: S.optional(S.String),
    HubContentName: S.optional(S.String),
    MinVersion: S.optional(S.String),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateHubContentReferenceRequest",
}) as any as S.Schema<CreateHubContentReferenceRequest>;
export interface CreateHubContentReferenceResponse {
  HubArn: string;
  HubContentArn: string;
}
export const CreateHubContentReferenceResponse = S.suspend(() =>
  S.Struct({
    HubArn: S.optional(S.String),
    HubContentArn: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "CreateHubContentReferenceResponse",
}) as any as S.Schema<CreateHubContentReferenceResponse>;
export interface UiTemplate {
  Content?: string;
}
export const UiTemplate = S.suspend(() =>
  S.Struct({ Content: S.optional(S.String) }),
).annotate({ identifier: "UiTemplate" }) as any as S.Schema<UiTemplate>;
export interface CreateHumanTaskUiRequest {
  HumanTaskUiName?: string;
  UiTemplate?: UiTemplate;
  Tags?: Tag[];
}
export const CreateHumanTaskUiRequest = S.suspend(() =>
  S.Struct({
    HumanTaskUiName: S.optional(S.String),
    UiTemplate: S.optional(UiTemplate),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateHumanTaskUiRequest",
}) as any as S.Schema<CreateHumanTaskUiRequest>;
export interface CreateHumanTaskUiResponse {
  HumanTaskUiArn: string;
}
export const CreateHumanTaskUiResponse = S.suspend(() =>
  S.Struct({ HumanTaskUiArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateHumanTaskUiResponse",
}) as any as S.Schema<CreateHumanTaskUiResponse>;
export type HyperParameterTuningJobStrategyType =
  | "Bayesian"
  | "Random"
  | "Hyperband"
  | "Grid"
  | (string & {});
export const HyperParameterTuningJobStrategyType = S.String;
export interface HyperbandStrategyConfig {
  MinResource?: number;
  MaxResource?: number;
}
export const HyperbandStrategyConfig = S.suspend(() =>
  S.Struct({
    MinResource: S.optional(S.Number),
    MaxResource: S.optional(S.Number),
  }),
).annotate({
  identifier: "HyperbandStrategyConfig",
}) as any as S.Schema<HyperbandStrategyConfig>;
export interface HyperParameterTuningJobStrategyConfig {
  HyperbandStrategyConfig?: HyperbandStrategyConfig;
}
export const HyperParameterTuningJobStrategyConfig = S.suspend(() =>
  S.Struct({ HyperbandStrategyConfig: S.optional(HyperbandStrategyConfig) }),
).annotate({
  identifier: "HyperParameterTuningJobStrategyConfig",
}) as any as S.Schema<HyperParameterTuningJobStrategyConfig>;
export interface ResourceLimits {
  MaxNumberOfTrainingJobs?: number;
  MaxParallelTrainingJobs?: number;
  MaxRuntimeInSeconds?: number;
}
export const ResourceLimits = S.suspend(() =>
  S.Struct({
    MaxNumberOfTrainingJobs: S.optional(S.Number),
    MaxParallelTrainingJobs: S.optional(S.Number),
    MaxRuntimeInSeconds: S.optional(S.Number),
  }),
).annotate({ identifier: "ResourceLimits" }) as any as S.Schema<ResourceLimits>;
export type HyperParameterScalingType =
  | "Auto"
  | "Linear"
  | "Logarithmic"
  | "ReverseLogarithmic"
  | (string & {});
export const HyperParameterScalingType = S.String;
export interface IntegerParameterRange {
  Name?: string;
  MinValue?: string;
  MaxValue?: string;
  ScalingType?: HyperParameterScalingType;
}
export const IntegerParameterRange = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    MinValue: S.optional(S.String),
    MaxValue: S.optional(S.String),
    ScalingType: S.optional(HyperParameterScalingType),
  }),
).annotate({
  identifier: "IntegerParameterRange",
}) as any as S.Schema<IntegerParameterRange>;
export type IntegerParameterRanges = IntegerParameterRange[];
export const IntegerParameterRanges = S.Array(IntegerParameterRange);
export interface ContinuousParameterRange {
  Name?: string;
  MinValue?: string;
  MaxValue?: string;
  ScalingType?: HyperParameterScalingType;
}
export const ContinuousParameterRange = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    MinValue: S.optional(S.String),
    MaxValue: S.optional(S.String),
    ScalingType: S.optional(HyperParameterScalingType),
  }),
).annotate({
  identifier: "ContinuousParameterRange",
}) as any as S.Schema<ContinuousParameterRange>;
export type ContinuousParameterRanges = ContinuousParameterRange[];
export const ContinuousParameterRanges = S.Array(ContinuousParameterRange);
export interface CategoricalParameterRange {
  Name?: string;
  Values?: string[];
}
export const CategoricalParameterRange = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Values: S.optional(ParameterValues) }),
).annotate({
  identifier: "CategoricalParameterRange",
}) as any as S.Schema<CategoricalParameterRange>;
export type CategoricalParameterRanges = CategoricalParameterRange[];
export const CategoricalParameterRanges = S.Array(CategoricalParameterRange);
export interface AutoParameter {
  Name?: string;
  ValueHint?: string;
}
export const AutoParameter = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), ValueHint: S.optional(S.String) }),
).annotate({ identifier: "AutoParameter" }) as any as S.Schema<AutoParameter>;
export type AutoParameters = AutoParameter[];
export const AutoParameters = S.Array(AutoParameter);
export interface ParameterRanges {
  IntegerParameterRanges?: IntegerParameterRange[];
  ContinuousParameterRanges?: ContinuousParameterRange[];
  CategoricalParameterRanges?: CategoricalParameterRange[];
  AutoParameters?: AutoParameter[];
}
export const ParameterRanges = S.suspend(() =>
  S.Struct({
    IntegerParameterRanges: S.optional(IntegerParameterRanges),
    ContinuousParameterRanges: S.optional(ContinuousParameterRanges),
    CategoricalParameterRanges: S.optional(CategoricalParameterRanges),
    AutoParameters: S.optional(AutoParameters),
  }),
).annotate({
  identifier: "ParameterRanges",
}) as any as S.Schema<ParameterRanges>;
export type TrainingJobEarlyStoppingType = "Off" | "Auto" | (string & {});
export const TrainingJobEarlyStoppingType = S.String;
export interface BestObjectiveNotImproving {
  MaxNumberOfTrainingJobsNotImproving?: number;
}
export const BestObjectiveNotImproving = S.suspend(() =>
  S.Struct({ MaxNumberOfTrainingJobsNotImproving: S.optional(S.Number) }),
).annotate({
  identifier: "BestObjectiveNotImproving",
}) as any as S.Schema<BestObjectiveNotImproving>;
export type CompleteOnConvergence = "Disabled" | "Enabled" | (string & {});
export const CompleteOnConvergence = S.String;
export interface ConvergenceDetected {
  CompleteOnConvergence?: CompleteOnConvergence;
}
export const ConvergenceDetected = S.suspend(() =>
  S.Struct({ CompleteOnConvergence: S.optional(CompleteOnConvergence) }),
).annotate({
  identifier: "ConvergenceDetected",
}) as any as S.Schema<ConvergenceDetected>;
export interface TuningJobCompletionCriteria {
  TargetObjectiveMetricValue?: number;
  BestObjectiveNotImproving?: BestObjectiveNotImproving;
  ConvergenceDetected?: ConvergenceDetected;
}
export const TuningJobCompletionCriteria = S.suspend(() =>
  S.Struct({
    TargetObjectiveMetricValue: S.optional(S.Number),
    BestObjectiveNotImproving: S.optional(BestObjectiveNotImproving),
    ConvergenceDetected: S.optional(ConvergenceDetected),
  }),
).annotate({
  identifier: "TuningJobCompletionCriteria",
}) as any as S.Schema<TuningJobCompletionCriteria>;
export interface HyperParameterTuningJobConfig {
  Strategy?: HyperParameterTuningJobStrategyType;
  StrategyConfig?: HyperParameterTuningJobStrategyConfig;
  HyperParameterTuningJobObjective?: HyperParameterTuningJobObjective;
  ResourceLimits?: ResourceLimits;
  ParameterRanges?: ParameterRanges;
  TrainingJobEarlyStoppingType?: TrainingJobEarlyStoppingType;
  TuningJobCompletionCriteria?: TuningJobCompletionCriteria;
  RandomSeed?: number;
}
export const HyperParameterTuningJobConfig = S.suspend(() =>
  S.Struct({
    Strategy: S.optional(HyperParameterTuningJobStrategyType),
    StrategyConfig: S.optional(HyperParameterTuningJobStrategyConfig),
    HyperParameterTuningJobObjective: S.optional(
      HyperParameterTuningJobObjective,
    ),
    ResourceLimits: S.optional(ResourceLimits),
    ParameterRanges: S.optional(ParameterRanges),
    TrainingJobEarlyStoppingType: S.optional(TrainingJobEarlyStoppingType),
    TuningJobCompletionCriteria: S.optional(TuningJobCompletionCriteria),
    RandomSeed: S.optional(S.Number),
  }),
).annotate({
  identifier: "HyperParameterTuningJobConfig",
}) as any as S.Schema<HyperParameterTuningJobConfig>;
export interface HyperParameterAlgorithmSpecification {
  TrainingImage?: string;
  TrainingInputMode?: TrainingInputMode;
  AlgorithmName?: string;
  MetricDefinitions?: MetricDefinition[];
}
export const HyperParameterAlgorithmSpecification = S.suspend(() =>
  S.Struct({
    TrainingImage: S.optional(S.String),
    TrainingInputMode: S.optional(TrainingInputMode),
    AlgorithmName: S.optional(S.String),
    MetricDefinitions: S.optional(MetricDefinitionList),
  }),
).annotate({
  identifier: "HyperParameterAlgorithmSpecification",
}) as any as S.Schema<HyperParameterAlgorithmSpecification>;
export type HyperParameterTuningAllocationStrategy =
  | "Prioritized"
  | (string & {});
export const HyperParameterTuningAllocationStrategy = S.String;
export interface HyperParameterTuningInstanceConfig {
  InstanceType?: TrainingInstanceType;
  InstanceCount?: number;
  VolumeSizeInGB?: number;
}
export const HyperParameterTuningInstanceConfig = S.suspend(() =>
  S.Struct({
    InstanceType: S.optional(TrainingInstanceType),
    InstanceCount: S.optional(S.Number),
    VolumeSizeInGB: S.optional(S.Number),
  }),
).annotate({
  identifier: "HyperParameterTuningInstanceConfig",
}) as any as S.Schema<HyperParameterTuningInstanceConfig>;
export type HyperParameterTuningInstanceConfigs =
  HyperParameterTuningInstanceConfig[];
export const HyperParameterTuningInstanceConfigs = S.Array(
  HyperParameterTuningInstanceConfig,
);
export interface HyperParameterTuningResourceConfig {
  InstanceType?: TrainingInstanceType;
  InstanceCount?: number;
  VolumeSizeInGB?: number;
  VolumeKmsKeyId?: string;
  AllocationStrategy?: HyperParameterTuningAllocationStrategy;
  InstanceConfigs?: HyperParameterTuningInstanceConfig[];
}
export const HyperParameterTuningResourceConfig = S.suspend(() =>
  S.Struct({
    InstanceType: S.optional(TrainingInstanceType),
    InstanceCount: S.optional(S.Number),
    VolumeSizeInGB: S.optional(S.Number),
    VolumeKmsKeyId: S.optional(S.String),
    AllocationStrategy: S.optional(HyperParameterTuningAllocationStrategy),
    InstanceConfigs: S.optional(HyperParameterTuningInstanceConfigs),
  }),
).annotate({
  identifier: "HyperParameterTuningResourceConfig",
}) as any as S.Schema<HyperParameterTuningResourceConfig>;
export interface CheckpointConfig {
  S3Uri?: string;
  LocalPath?: string;
}
export const CheckpointConfig = S.suspend(() =>
  S.Struct({ S3Uri: S.optional(S.String), LocalPath: S.optional(S.String) }),
).annotate({
  identifier: "CheckpointConfig",
}) as any as S.Schema<CheckpointConfig>;
export interface RetryStrategy {
  MaximumRetryAttempts?: number;
}
export const RetryStrategy = S.suspend(() =>
  S.Struct({ MaximumRetryAttempts: S.optional(S.Number) }),
).annotate({ identifier: "RetryStrategy" }) as any as S.Schema<RetryStrategy>;
export type HyperParameterTrainingJobEnvironmentMap = {
  [key: string]: string | undefined;
};
export const HyperParameterTrainingJobEnvironmentMap = S.Record(
  S.String,
  S.String.pipe(S.optional),
);
export interface HyperParameterTrainingJobDefinition {
  DefinitionName?: string;
  TuningObjective?: HyperParameterTuningJobObjective;
  HyperParameterRanges?: ParameterRanges;
  StaticHyperParameters?: { [key: string]: string | undefined };
  AlgorithmSpecification?: HyperParameterAlgorithmSpecification;
  RoleArn?: string;
  InputDataConfig?: Channel[];
  VpcConfig?: VpcConfig;
  OutputDataConfig?: OutputDataConfig;
  ResourceConfig?: ResourceConfig;
  HyperParameterTuningResourceConfig?: HyperParameterTuningResourceConfig;
  StoppingCondition?: StoppingCondition;
  EnableNetworkIsolation?: boolean;
  EnableInterContainerTrafficEncryption?: boolean;
  EnableManagedSpotTraining?: boolean;
  CheckpointConfig?: CheckpointConfig;
  RetryStrategy?: RetryStrategy;
  Environment?: { [key: string]: string | undefined };
}
export const HyperParameterTrainingJobDefinition = S.suspend(() =>
  S.Struct({
    DefinitionName: S.optional(S.String),
    TuningObjective: S.optional(HyperParameterTuningJobObjective),
    HyperParameterRanges: S.optional(ParameterRanges),
    StaticHyperParameters: S.optional(HyperParameters),
    AlgorithmSpecification: S.optional(HyperParameterAlgorithmSpecification),
    RoleArn: S.optional(S.String),
    InputDataConfig: S.optional(InputDataConfig),
    VpcConfig: S.optional(VpcConfig),
    OutputDataConfig: S.optional(OutputDataConfig),
    ResourceConfig: S.optional(ResourceConfig),
    HyperParameterTuningResourceConfig: S.optional(
      HyperParameterTuningResourceConfig,
    ),
    StoppingCondition: S.optional(StoppingCondition),
    EnableNetworkIsolation: S.optional(S.Boolean),
    EnableInterContainerTrafficEncryption: S.optional(S.Boolean),
    EnableManagedSpotTraining: S.optional(S.Boolean),
    CheckpointConfig: S.optional(CheckpointConfig),
    RetryStrategy: S.optional(RetryStrategy),
    Environment: S.optional(HyperParameterTrainingJobEnvironmentMap),
  }),
).annotate({
  identifier: "HyperParameterTrainingJobDefinition",
}) as any as S.Schema<HyperParameterTrainingJobDefinition>;
export type HyperParameterTrainingJobDefinitions =
  HyperParameterTrainingJobDefinition[];
export const HyperParameterTrainingJobDefinitions = S.Array(
  HyperParameterTrainingJobDefinition,
);
export interface ParentHyperParameterTuningJob {
  HyperParameterTuningJobName?: string;
}
export const ParentHyperParameterTuningJob = S.suspend(() =>
  S.Struct({ HyperParameterTuningJobName: S.optional(S.String) }),
).annotate({
  identifier: "ParentHyperParameterTuningJob",
}) as any as S.Schema<ParentHyperParameterTuningJob>;
export type ParentHyperParameterTuningJobs = ParentHyperParameterTuningJob[];
export const ParentHyperParameterTuningJobs = S.Array(
  ParentHyperParameterTuningJob,
);
export type HyperParameterTuningJobWarmStartType =
  | "IdenticalDataAndAlgorithm"
  | "TransferLearning"
  | (string & {});
export const HyperParameterTuningJobWarmStartType = S.String;
export interface HyperParameterTuningJobWarmStartConfig {
  ParentHyperParameterTuningJobs?: ParentHyperParameterTuningJob[];
  WarmStartType?: HyperParameterTuningJobWarmStartType;
}
export const HyperParameterTuningJobWarmStartConfig = S.suspend(() =>
  S.Struct({
    ParentHyperParameterTuningJobs: S.optional(ParentHyperParameterTuningJobs),
    WarmStartType: S.optional(HyperParameterTuningJobWarmStartType),
  }),
).annotate({
  identifier: "HyperParameterTuningJobWarmStartConfig",
}) as any as S.Schema<HyperParameterTuningJobWarmStartConfig>;
export type AutotuneMode = "Enabled" | (string & {});
export const AutotuneMode = S.String;
export interface Autotune {
  Mode?: AutotuneMode;
}
export const Autotune = S.suspend(() =>
  S.Struct({ Mode: S.optional(AutotuneMode) }),
).annotate({ identifier: "Autotune" }) as any as S.Schema<Autotune>;
export interface CreateHyperParameterTuningJobRequest {
  HyperParameterTuningJobName?: string;
  HyperParameterTuningJobConfig?: HyperParameterTuningJobConfig;
  TrainingJobDefinition?: HyperParameterTrainingJobDefinition;
  TrainingJobDefinitions?: HyperParameterTrainingJobDefinition[];
  WarmStartConfig?: HyperParameterTuningJobWarmStartConfig;
  Tags?: Tag[];
  Autotune?: Autotune;
}
export const CreateHyperParameterTuningJobRequest = S.suspend(() =>
  S.Struct({
    HyperParameterTuningJobName: S.optional(S.String),
    HyperParameterTuningJobConfig: S.optional(HyperParameterTuningJobConfig),
    TrainingJobDefinition: S.optional(HyperParameterTrainingJobDefinition),
    TrainingJobDefinitions: S.optional(HyperParameterTrainingJobDefinitions),
    WarmStartConfig: S.optional(HyperParameterTuningJobWarmStartConfig),
    Tags: S.optional(TagList),
    Autotune: S.optional(Autotune),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateHyperParameterTuningJobRequest",
}) as any as S.Schema<CreateHyperParameterTuningJobRequest>;
export interface CreateHyperParameterTuningJobResponse {
  HyperParameterTuningJobArn: string;
}
export const CreateHyperParameterTuningJobResponse = S.suspend(() =>
  S.Struct({ HyperParameterTuningJobArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateHyperParameterTuningJobResponse",
}) as any as S.Schema<CreateHyperParameterTuningJobResponse>;
export interface CreateImageRequest {
  Description?: string;
  DisplayName?: string;
  ImageName?: string;
  RoleArn?: string;
  Tags?: Tag[];
}
export const CreateImageRequest = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String),
    DisplayName: S.optional(S.String),
    ImageName: S.optional(S.String),
    RoleArn: S.optional(S.String),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateImageRequest",
}) as any as S.Schema<CreateImageRequest>;
export interface CreateImageResponse {
  ImageArn?: string;
}
export const CreateImageResponse = S.suspend(() =>
  S.Struct({ ImageArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateImageResponse",
}) as any as S.Schema<CreateImageResponse>;
export type SageMakerImageVersionAliases = string[];
export const SageMakerImageVersionAliases = S.Array(S.String);
export type VendorGuidance =
  | "NOT_PROVIDED"
  | "STABLE"
  | "TO_BE_ARCHIVED"
  | "ARCHIVED"
  | (string & {});
export const VendorGuidance = S.String;
export type JobType =
  | "TRAINING"
  | "INFERENCE"
  | "NOTEBOOK_KERNEL"
  | (string & {});
export const JobType = S.String;
export type Processor = "CPU" | "GPU" | (string & {});
export const Processor = S.String;
export interface CreateImageVersionRequest {
  BaseImage?: string;
  ClientToken?: string;
  ImageName?: string;
  Aliases?: string[];
  VendorGuidance?: VendorGuidance;
  JobType?: JobType;
  MLFramework?: string;
  ProgrammingLang?: string;
  Processor?: Processor;
  Horovod?: boolean;
  ReleaseNotes?: string;
}
export const CreateImageVersionRequest = S.suspend(() =>
  S.Struct({
    BaseImage: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    ImageName: S.optional(S.String),
    Aliases: S.optional(SageMakerImageVersionAliases),
    VendorGuidance: S.optional(VendorGuidance),
    JobType: S.optional(JobType),
    MLFramework: S.optional(S.String),
    ProgrammingLang: S.optional(S.String),
    Processor: S.optional(Processor),
    Horovod: S.optional(S.Boolean),
    ReleaseNotes: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateImageVersionRequest",
}) as any as S.Schema<CreateImageVersionRequest>;
export interface CreateImageVersionResponse {
  ImageVersionArn?: string;
}
export const CreateImageVersionResponse = S.suspend(() =>
  S.Struct({ ImageVersionArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateImageVersionResponse",
}) as any as S.Schema<CreateImageVersionResponse>;
export interface InferenceComponentContainerSpecification {
  Image?: string;
  ArtifactUrl?: string;
  Environment?: { [key: string]: string | undefined };
}
export const InferenceComponentContainerSpecification = S.suspend(() =>
  S.Struct({
    Image: S.optional(S.String),
    ArtifactUrl: S.optional(S.String),
    Environment: S.optional(EnvironmentMap),
  }),
).annotate({
  identifier: "InferenceComponentContainerSpecification",
}) as any as S.Schema<InferenceComponentContainerSpecification>;
export interface InferenceComponentStartupParameters {
  ModelDataDownloadTimeoutInSeconds?: number;
  ContainerStartupHealthCheckTimeoutInSeconds?: number;
}
export const InferenceComponentStartupParameters = S.suspend(() =>
  S.Struct({
    ModelDataDownloadTimeoutInSeconds: S.optional(S.Number),
    ContainerStartupHealthCheckTimeoutInSeconds: S.optional(S.Number),
  }),
).annotate({
  identifier: "InferenceComponentStartupParameters",
}) as any as S.Schema<InferenceComponentStartupParameters>;
export interface InferenceComponentComputeResourceRequirements {
  NumberOfCpuCoresRequired?: number;
  NumberOfAcceleratorDevicesRequired?: number;
  MinMemoryRequiredInMb?: number;
  MaxMemoryRequiredInMb?: number;
}
export const InferenceComponentComputeResourceRequirements = S.suspend(() =>
  S.Struct({
    NumberOfCpuCoresRequired: S.optional(S.Number),
    NumberOfAcceleratorDevicesRequired: S.optional(S.Number),
    MinMemoryRequiredInMb: S.optional(S.Number),
    MaxMemoryRequiredInMb: S.optional(S.Number),
  }),
).annotate({
  identifier: "InferenceComponentComputeResourceRequirements",
}) as any as S.Schema<InferenceComponentComputeResourceRequirements>;
export interface InferenceComponentDataCacheConfig {
  EnableCaching?: boolean;
}
export const InferenceComponentDataCacheConfig = S.suspend(() =>
  S.Struct({ EnableCaching: S.optional(S.Boolean) }),
).annotate({
  identifier: "InferenceComponentDataCacheConfig",
}) as any as S.Schema<InferenceComponentDataCacheConfig>;
export interface InferenceComponentSpecification {
  ModelName?: string;
  Container?: InferenceComponentContainerSpecification;
  StartupParameters?: InferenceComponentStartupParameters;
  ComputeResourceRequirements?: InferenceComponentComputeResourceRequirements;
  BaseInferenceComponentName?: string;
  DataCacheConfig?: InferenceComponentDataCacheConfig;
}
export const InferenceComponentSpecification = S.suspend(() =>
  S.Struct({
    ModelName: S.optional(S.String),
    Container: S.optional(InferenceComponentContainerSpecification),
    StartupParameters: S.optional(InferenceComponentStartupParameters),
    ComputeResourceRequirements: S.optional(
      InferenceComponentComputeResourceRequirements,
    ),
    BaseInferenceComponentName: S.optional(S.String),
    DataCacheConfig: S.optional(InferenceComponentDataCacheConfig),
  }),
).annotate({
  identifier: "InferenceComponentSpecification",
}) as any as S.Schema<InferenceComponentSpecification>;
export interface InferenceComponentRuntimeConfig {
  CopyCount?: number;
}
export const InferenceComponentRuntimeConfig = S.suspend(() =>
  S.Struct({ CopyCount: S.optional(S.Number) }),
).annotate({
  identifier: "InferenceComponentRuntimeConfig",
}) as any as S.Schema<InferenceComponentRuntimeConfig>;
export interface CreateInferenceComponentInput {
  InferenceComponentName?: string;
  EndpointName?: string;
  VariantName?: string;
  Specification?: InferenceComponentSpecification;
  RuntimeConfig?: InferenceComponentRuntimeConfig;
  Tags?: Tag[];
}
export const CreateInferenceComponentInput = S.suspend(() =>
  S.Struct({
    InferenceComponentName: S.optional(S.String),
    EndpointName: S.optional(S.String),
    VariantName: S.optional(S.String),
    Specification: S.optional(InferenceComponentSpecification),
    RuntimeConfig: S.optional(InferenceComponentRuntimeConfig),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateInferenceComponentInput",
}) as any as S.Schema<CreateInferenceComponentInput>;
export interface CreateInferenceComponentOutput {
  InferenceComponentArn: string;
}
export const CreateInferenceComponentOutput = S.suspend(() =>
  S.Struct({ InferenceComponentArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateInferenceComponentOutput",
}) as any as S.Schema<CreateInferenceComponentOutput>;
export type InferenceExperimentType = "ShadowMode" | (string & {});
export const InferenceExperimentType = S.String;
export interface InferenceExperimentSchedule {
  StartTime?: Date;
  EndTime?: Date;
}
export const InferenceExperimentSchedule = S.suspend(() =>
  S.Struct({
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotate({
  identifier: "InferenceExperimentSchedule",
}) as any as S.Schema<InferenceExperimentSchedule>;
export type ModelInfrastructureType = "RealTimeInference" | (string & {});
export const ModelInfrastructureType = S.String;
export type InstanceType =
  | "ml.t2.medium"
  | "ml.t2.large"
  | "ml.t2.xlarge"
  | "ml.t2.2xlarge"
  | "ml.t3.medium"
  | "ml.t3.large"
  | "ml.t3.xlarge"
  | "ml.t3.2xlarge"
  | "ml.m4.xlarge"
  | "ml.m4.2xlarge"
  | "ml.m4.4xlarge"
  | "ml.m4.10xlarge"
  | "ml.m4.16xlarge"
  | "ml.m5.xlarge"
  | "ml.m5.2xlarge"
  | "ml.m5.4xlarge"
  | "ml.m5.12xlarge"
  | "ml.m5.24xlarge"
  | "ml.m5d.large"
  | "ml.m5d.xlarge"
  | "ml.m5d.2xlarge"
  | "ml.m5d.4xlarge"
  | "ml.m5d.8xlarge"
  | "ml.m5d.12xlarge"
  | "ml.m5d.16xlarge"
  | "ml.m5d.24xlarge"
  | "ml.c4.xlarge"
  | "ml.c4.2xlarge"
  | "ml.c4.4xlarge"
  | "ml.c4.8xlarge"
  | "ml.c5.xlarge"
  | "ml.c5.2xlarge"
  | "ml.c5.4xlarge"
  | "ml.c5.9xlarge"
  | "ml.c5.18xlarge"
  | "ml.c5d.xlarge"
  | "ml.c5d.2xlarge"
  | "ml.c5d.4xlarge"
  | "ml.c5d.9xlarge"
  | "ml.c5d.18xlarge"
  | "ml.p2.xlarge"
  | "ml.p2.8xlarge"
  | "ml.p2.16xlarge"
  | "ml.p3.2xlarge"
  | "ml.p3.8xlarge"
  | "ml.p3.16xlarge"
  | "ml.p3dn.24xlarge"
  | "ml.g4dn.xlarge"
  | "ml.g4dn.2xlarge"
  | "ml.g4dn.4xlarge"
  | "ml.g4dn.8xlarge"
  | "ml.g4dn.12xlarge"
  | "ml.g4dn.16xlarge"
  | "ml.r5.large"
  | "ml.r5.xlarge"
  | "ml.r5.2xlarge"
  | "ml.r5.4xlarge"
  | "ml.r5.8xlarge"
  | "ml.r5.12xlarge"
  | "ml.r5.16xlarge"
  | "ml.r5.24xlarge"
  | "ml.g5.xlarge"
  | "ml.g5.2xlarge"
  | "ml.g5.4xlarge"
  | "ml.g5.8xlarge"
  | "ml.g5.16xlarge"
  | "ml.g5.12xlarge"
  | "ml.g5.24xlarge"
  | "ml.g5.48xlarge"
  | "ml.inf1.xlarge"
  | "ml.inf1.2xlarge"
  | "ml.inf1.6xlarge"
  | "ml.inf1.24xlarge"
  | "ml.trn1.2xlarge"
  | "ml.trn1.32xlarge"
  | "ml.trn1n.32xlarge"
  | "ml.inf2.xlarge"
  | "ml.inf2.8xlarge"
  | "ml.inf2.24xlarge"
  | "ml.inf2.48xlarge"
  | "ml.p4d.24xlarge"
  | "ml.p4de.24xlarge"
  | "ml.p5.48xlarge"
  | "ml.p6-b200.48xlarge"
  | "ml.m6i.large"
  | "ml.m6i.xlarge"
  | "ml.m6i.2xlarge"
  | "ml.m6i.4xlarge"
  | "ml.m6i.8xlarge"
  | "ml.m6i.12xlarge"
  | "ml.m6i.16xlarge"
  | "ml.m6i.24xlarge"
  | "ml.m6i.32xlarge"
  | "ml.m7i.large"
  | "ml.m7i.xlarge"
  | "ml.m7i.2xlarge"
  | "ml.m7i.4xlarge"
  | "ml.m7i.8xlarge"
  | "ml.m7i.12xlarge"
  | "ml.m7i.16xlarge"
  | "ml.m7i.24xlarge"
  | "ml.m7i.48xlarge"
  | "ml.c6i.large"
  | "ml.c6i.xlarge"
  | "ml.c6i.2xlarge"
  | "ml.c6i.4xlarge"
  | "ml.c6i.8xlarge"
  | "ml.c6i.12xlarge"
  | "ml.c6i.16xlarge"
  | "ml.c6i.24xlarge"
  | "ml.c6i.32xlarge"
  | "ml.c7i.large"
  | "ml.c7i.xlarge"
  | "ml.c7i.2xlarge"
  | "ml.c7i.4xlarge"
  | "ml.c7i.8xlarge"
  | "ml.c7i.12xlarge"
  | "ml.c7i.16xlarge"
  | "ml.c7i.24xlarge"
  | "ml.c7i.48xlarge"
  | "ml.r6i.large"
  | "ml.r6i.xlarge"
  | "ml.r6i.2xlarge"
  | "ml.r6i.4xlarge"
  | "ml.r6i.8xlarge"
  | "ml.r6i.12xlarge"
  | "ml.r6i.16xlarge"
  | "ml.r6i.24xlarge"
  | "ml.r6i.32xlarge"
  | "ml.r7i.large"
  | "ml.r7i.xlarge"
  | "ml.r7i.2xlarge"
  | "ml.r7i.4xlarge"
  | "ml.r7i.8xlarge"
  | "ml.r7i.12xlarge"
  | "ml.r7i.16xlarge"
  | "ml.r7i.24xlarge"
  | "ml.r7i.48xlarge"
  | "ml.m6id.large"
  | "ml.m6id.xlarge"
  | "ml.m6id.2xlarge"
  | "ml.m6id.4xlarge"
  | "ml.m6id.8xlarge"
  | "ml.m6id.12xlarge"
  | "ml.m6id.16xlarge"
  | "ml.m6id.24xlarge"
  | "ml.m6id.32xlarge"
  | "ml.c6id.large"
  | "ml.c6id.xlarge"
  | "ml.c6id.2xlarge"
  | "ml.c6id.4xlarge"
  | "ml.c6id.8xlarge"
  | "ml.c6id.12xlarge"
  | "ml.c6id.16xlarge"
  | "ml.c6id.24xlarge"
  | "ml.c6id.32xlarge"
  | "ml.r6id.large"
  | "ml.r6id.xlarge"
  | "ml.r6id.2xlarge"
  | "ml.r6id.4xlarge"
  | "ml.r6id.8xlarge"
  | "ml.r6id.12xlarge"
  | "ml.r6id.16xlarge"
  | "ml.r6id.24xlarge"
  | "ml.r6id.32xlarge"
  | "ml.g6.xlarge"
  | "ml.g6.2xlarge"
  | "ml.g6.4xlarge"
  | "ml.g6.8xlarge"
  | "ml.g6.12xlarge"
  | "ml.g6.16xlarge"
  | "ml.g6.24xlarge"
  | "ml.g6.48xlarge"
  | (string & {});
export const InstanceType = S.String;
export interface RealTimeInferenceConfig {
  InstanceType?: InstanceType;
  InstanceCount?: number;
}
export const RealTimeInferenceConfig = S.suspend(() =>
  S.Struct({
    InstanceType: S.optional(InstanceType),
    InstanceCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "RealTimeInferenceConfig",
}) as any as S.Schema<RealTimeInferenceConfig>;
export interface ModelInfrastructureConfig {
  InfrastructureType?: ModelInfrastructureType;
  RealTimeInferenceConfig?: RealTimeInferenceConfig;
}
export const ModelInfrastructureConfig = S.suspend(() =>
  S.Struct({
    InfrastructureType: S.optional(ModelInfrastructureType),
    RealTimeInferenceConfig: S.optional(RealTimeInferenceConfig),
  }),
).annotate({
  identifier: "ModelInfrastructureConfig",
}) as any as S.Schema<ModelInfrastructureConfig>;
export interface ModelVariantConfig {
  ModelName?: string;
  VariantName?: string;
  InfrastructureConfig?: ModelInfrastructureConfig;
}
export const ModelVariantConfig = S.suspend(() =>
  S.Struct({
    ModelName: S.optional(S.String),
    VariantName: S.optional(S.String),
    InfrastructureConfig: S.optional(ModelInfrastructureConfig),
  }),
).annotate({
  identifier: "ModelVariantConfig",
}) as any as S.Schema<ModelVariantConfig>;
export type ModelVariantConfigList = ModelVariantConfig[];
export const ModelVariantConfigList = S.Array(ModelVariantConfig);
export interface InferenceExperimentDataStorageConfig {
  Destination?: string;
  KmsKey?: string;
  ContentType?: CaptureContentTypeHeader;
}
export const InferenceExperimentDataStorageConfig = S.suspend(() =>
  S.Struct({
    Destination: S.optional(S.String),
    KmsKey: S.optional(S.String),
    ContentType: S.optional(CaptureContentTypeHeader),
  }),
).annotate({
  identifier: "InferenceExperimentDataStorageConfig",
}) as any as S.Schema<InferenceExperimentDataStorageConfig>;
export interface ShadowModelVariantConfig {
  ShadowModelVariantName?: string;
  SamplingPercentage?: number;
}
export const ShadowModelVariantConfig = S.suspend(() =>
  S.Struct({
    ShadowModelVariantName: S.optional(S.String),
    SamplingPercentage: S.optional(S.Number),
  }),
).annotate({
  identifier: "ShadowModelVariantConfig",
}) as any as S.Schema<ShadowModelVariantConfig>;
export type ShadowModelVariantConfigList = ShadowModelVariantConfig[];
export const ShadowModelVariantConfigList = S.Array(ShadowModelVariantConfig);
export interface ShadowModeConfig {
  SourceModelVariantName?: string;
  ShadowModelVariants?: ShadowModelVariantConfig[];
}
export const ShadowModeConfig = S.suspend(() =>
  S.Struct({
    SourceModelVariantName: S.optional(S.String),
    ShadowModelVariants: S.optional(ShadowModelVariantConfigList),
  }),
).annotate({
  identifier: "ShadowModeConfig",
}) as any as S.Schema<ShadowModeConfig>;
export interface CreateInferenceExperimentRequest {
  Name?: string;
  Type?: InferenceExperimentType;
  Schedule?: InferenceExperimentSchedule;
  Description?: string;
  RoleArn?: string;
  EndpointName?: string;
  ModelVariants?: ModelVariantConfig[];
  DataStorageConfig?: InferenceExperimentDataStorageConfig;
  ShadowModeConfig?: ShadowModeConfig;
  KmsKey?: string;
  Tags?: Tag[];
}
export const CreateInferenceExperimentRequest = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Type: S.optional(InferenceExperimentType),
    Schedule: S.optional(InferenceExperimentSchedule),
    Description: S.optional(S.String),
    RoleArn: S.optional(S.String),
    EndpointName: S.optional(S.String),
    ModelVariants: S.optional(ModelVariantConfigList),
    DataStorageConfig: S.optional(InferenceExperimentDataStorageConfig),
    ShadowModeConfig: S.optional(ShadowModeConfig),
    KmsKey: S.optional(S.String),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateInferenceExperimentRequest",
}) as any as S.Schema<CreateInferenceExperimentRequest>;
export interface CreateInferenceExperimentResponse {
  InferenceExperimentArn: string;
}
export const CreateInferenceExperimentResponse = S.suspend(() =>
  S.Struct({ InferenceExperimentArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateInferenceExperimentResponse",
}) as any as S.Schema<CreateInferenceExperimentResponse>;
export type RecommendationJobType = "Default" | "Advanced" | (string & {});
export const RecommendationJobType = S.String;
export type TrafficType = "PHASES" | "STAIRS" | (string & {});
export const TrafficType = S.String;
export interface Phase {
  InitialNumberOfUsers?: number;
  SpawnRate?: number;
  DurationInSeconds?: number;
}
export const Phase = S.suspend(() =>
  S.Struct({
    InitialNumberOfUsers: S.optional(S.Number),
    SpawnRate: S.optional(S.Number),
    DurationInSeconds: S.optional(S.Number),
  }),
).annotate({ identifier: "Phase" }) as any as S.Schema<Phase>;
export type Phases = Phase[];
export const Phases = S.Array(Phase);
export interface Stairs {
  DurationInSeconds?: number;
  NumberOfSteps?: number;
  UsersPerStep?: number;
}
export const Stairs = S.suspend(() =>
  S.Struct({
    DurationInSeconds: S.optional(S.Number),
    NumberOfSteps: S.optional(S.Number),
    UsersPerStep: S.optional(S.Number),
  }),
).annotate({ identifier: "Stairs" }) as any as S.Schema<Stairs>;
export interface TrafficPattern {
  TrafficType?: TrafficType;
  Phases?: Phase[];
  Stairs?: Stairs;
}
export const TrafficPattern = S.suspend(() =>
  S.Struct({
    TrafficType: S.optional(TrafficType),
    Phases: S.optional(Phases),
    Stairs: S.optional(Stairs),
  }),
).annotate({ identifier: "TrafficPattern" }) as any as S.Schema<TrafficPattern>;
export interface RecommendationJobResourceLimit {
  MaxNumberOfTests?: number;
  MaxParallelOfTests?: number;
}
export const RecommendationJobResourceLimit = S.suspend(() =>
  S.Struct({
    MaxNumberOfTests: S.optional(S.Number),
    MaxParallelOfTests: S.optional(S.Number),
  }),
).annotate({
  identifier: "RecommendationJobResourceLimit",
}) as any as S.Schema<RecommendationJobResourceLimit>;
export type CategoricalParameterRangeValues = string[];
export const CategoricalParameterRangeValues = S.Array(S.String);
export interface CategoricalParameter {
  Name?: string;
  Value?: string[];
}
export const CategoricalParameter = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Value: S.optional(CategoricalParameterRangeValues),
  }),
).annotate({
  identifier: "CategoricalParameter",
}) as any as S.Schema<CategoricalParameter>;
export type CategoricalParameters = CategoricalParameter[];
export const CategoricalParameters = S.Array(CategoricalParameter);
export interface EnvironmentParameterRanges {
  CategoricalParameterRanges?: CategoricalParameter[];
}
export const EnvironmentParameterRanges = S.suspend(() =>
  S.Struct({ CategoricalParameterRanges: S.optional(CategoricalParameters) }),
).annotate({
  identifier: "EnvironmentParameterRanges",
}) as any as S.Schema<EnvironmentParameterRanges>;
export interface EndpointInputConfiguration {
  InstanceType?: ProductionVariantInstanceType;
  ServerlessConfig?: ProductionVariantServerlessConfig;
  InferenceSpecificationName?: string;
  EnvironmentParameterRanges?: EnvironmentParameterRanges;
}
export const EndpointInputConfiguration = S.suspend(() =>
  S.Struct({
    InstanceType: S.optional(ProductionVariantInstanceType),
    ServerlessConfig: S.optional(ProductionVariantServerlessConfig),
    InferenceSpecificationName: S.optional(S.String),
    EnvironmentParameterRanges: S.optional(EnvironmentParameterRanges),
  }),
).annotate({
  identifier: "EndpointInputConfiguration",
}) as any as S.Schema<EndpointInputConfiguration>;
export type EndpointInputConfigurations = EndpointInputConfiguration[];
export const EndpointInputConfigurations = S.Array(EndpointInputConfiguration);
export type RecommendationJobSupportedContentTypes = string[];
export const RecommendationJobSupportedContentTypes = S.Array(S.String);
export interface RecommendationJobPayloadConfig {
  SamplePayloadUrl?: string;
  SupportedContentTypes?: string[];
}
export const RecommendationJobPayloadConfig = S.suspend(() =>
  S.Struct({
    SamplePayloadUrl: S.optional(S.String),
    SupportedContentTypes: S.optional(RecommendationJobSupportedContentTypes),
  }),
).annotate({
  identifier: "RecommendationJobPayloadConfig",
}) as any as S.Schema<RecommendationJobPayloadConfig>;
export type RecommendationJobSupportedInstanceTypes = string[];
export const RecommendationJobSupportedInstanceTypes = S.Array(S.String);
export type RecommendationJobSupportedEndpointType =
  | "RealTime"
  | "Serverless"
  | (string & {});
export const RecommendationJobSupportedEndpointType = S.String;
export type RecommendationJobSupportedResponseMIMETypes = string[];
export const RecommendationJobSupportedResponseMIMETypes = S.Array(S.String);
export interface RecommendationJobContainerConfig {
  Domain?: string;
  Task?: string;
  Framework?: string;
  FrameworkVersion?: string;
  PayloadConfig?: RecommendationJobPayloadConfig;
  NearestModelName?: string;
  SupportedInstanceTypes?: string[];
  SupportedEndpointType?: RecommendationJobSupportedEndpointType;
  DataInputConfig?: string;
  SupportedResponseMIMETypes?: string[];
}
export const RecommendationJobContainerConfig = S.suspend(() =>
  S.Struct({
    Domain: S.optional(S.String),
    Task: S.optional(S.String),
    Framework: S.optional(S.String),
    FrameworkVersion: S.optional(S.String),
    PayloadConfig: S.optional(RecommendationJobPayloadConfig),
    NearestModelName: S.optional(S.String),
    SupportedInstanceTypes: S.optional(RecommendationJobSupportedInstanceTypes),
    SupportedEndpointType: S.optional(RecommendationJobSupportedEndpointType),
    DataInputConfig: S.optional(S.String),
    SupportedResponseMIMETypes: S.optional(
      RecommendationJobSupportedResponseMIMETypes,
    ),
  }),
).annotate({
  identifier: "RecommendationJobContainerConfig",
}) as any as S.Schema<RecommendationJobContainerConfig>;
export interface EndpointInfo {
  EndpointName?: string;
}
export const EndpointInfo = S.suspend(() =>
  S.Struct({ EndpointName: S.optional(S.String) }),
).annotate({ identifier: "EndpointInfo" }) as any as S.Schema<EndpointInfo>;
export type Endpoints = EndpointInfo[];
export const Endpoints = S.Array(EndpointInfo);
export type RecommendationJobVpcSecurityGroupIds = string[];
export const RecommendationJobVpcSecurityGroupIds = S.Array(S.String);
export type RecommendationJobVpcSubnets = string[];
export const RecommendationJobVpcSubnets = S.Array(S.String);
export interface RecommendationJobVpcConfig {
  SecurityGroupIds?: string[];
  Subnets?: string[];
}
export const RecommendationJobVpcConfig = S.suspend(() =>
  S.Struct({
    SecurityGroupIds: S.optional(RecommendationJobVpcSecurityGroupIds),
    Subnets: S.optional(RecommendationJobVpcSubnets),
  }),
).annotate({
  identifier: "RecommendationJobVpcConfig",
}) as any as S.Schema<RecommendationJobVpcConfig>;
export interface RecommendationJobInputConfig {
  ModelPackageVersionArn?: string;
  ModelName?: string;
  JobDurationInSeconds?: number;
  TrafficPattern?: TrafficPattern;
  ResourceLimit?: RecommendationJobResourceLimit;
  EndpointConfigurations?: EndpointInputConfiguration[];
  VolumeKmsKeyId?: string;
  ContainerConfig?: RecommendationJobContainerConfig;
  Endpoints?: EndpointInfo[];
  VpcConfig?: RecommendationJobVpcConfig;
}
export const RecommendationJobInputConfig = S.suspend(() =>
  S.Struct({
    ModelPackageVersionArn: S.optional(S.String),
    ModelName: S.optional(S.String),
    JobDurationInSeconds: S.optional(S.Number),
    TrafficPattern: S.optional(TrafficPattern),
    ResourceLimit: S.optional(RecommendationJobResourceLimit),
    EndpointConfigurations: S.optional(EndpointInputConfigurations),
    VolumeKmsKeyId: S.optional(S.String),
    ContainerConfig: S.optional(RecommendationJobContainerConfig),
    Endpoints: S.optional(Endpoints),
    VpcConfig: S.optional(RecommendationJobVpcConfig),
  }),
).annotate({
  identifier: "RecommendationJobInputConfig",
}) as any as S.Schema<RecommendationJobInputConfig>;
export interface ModelLatencyThreshold {
  Percentile?: string;
  ValueInMilliseconds?: number;
}
export const ModelLatencyThreshold = S.suspend(() =>
  S.Struct({
    Percentile: S.optional(S.String),
    ValueInMilliseconds: S.optional(S.Number),
  }),
).annotate({
  identifier: "ModelLatencyThreshold",
}) as any as S.Schema<ModelLatencyThreshold>;
export type ModelLatencyThresholds = ModelLatencyThreshold[];
export const ModelLatencyThresholds = S.Array(ModelLatencyThreshold);
export type FlatInvocations = "Continue" | "Stop" | (string & {});
export const FlatInvocations = S.String;
export interface RecommendationJobStoppingConditions {
  MaxInvocations?: number;
  ModelLatencyThresholds?: ModelLatencyThreshold[];
  FlatInvocations?: FlatInvocations;
}
export const RecommendationJobStoppingConditions = S.suspend(() =>
  S.Struct({
    MaxInvocations: S.optional(S.Number),
    ModelLatencyThresholds: S.optional(ModelLatencyThresholds),
    FlatInvocations: S.optional(FlatInvocations),
  }),
).annotate({
  identifier: "RecommendationJobStoppingConditions",
}) as any as S.Schema<RecommendationJobStoppingConditions>;
export interface RecommendationJobCompiledOutputConfig {
  S3OutputUri?: string;
}
export const RecommendationJobCompiledOutputConfig = S.suspend(() =>
  S.Struct({ S3OutputUri: S.optional(S.String) }),
).annotate({
  identifier: "RecommendationJobCompiledOutputConfig",
}) as any as S.Schema<RecommendationJobCompiledOutputConfig>;
export interface RecommendationJobOutputConfig {
  KmsKeyId?: string;
  CompiledOutputConfig?: RecommendationJobCompiledOutputConfig;
}
export const RecommendationJobOutputConfig = S.suspend(() =>
  S.Struct({
    KmsKeyId: S.optional(S.String),
    CompiledOutputConfig: S.optional(RecommendationJobCompiledOutputConfig),
  }),
).annotate({
  identifier: "RecommendationJobOutputConfig",
}) as any as S.Schema<RecommendationJobOutputConfig>;
export interface CreateInferenceRecommendationsJobRequest {
  JobName?: string;
  JobType?: RecommendationJobType;
  RoleArn?: string;
  InputConfig?: RecommendationJobInputConfig;
  JobDescription?: string;
  StoppingConditions?: RecommendationJobStoppingConditions;
  OutputConfig?: RecommendationJobOutputConfig;
  Tags?: Tag[];
}
export const CreateInferenceRecommendationsJobRequest = S.suspend(() =>
  S.Struct({
    JobName: S.optional(S.String),
    JobType: S.optional(RecommendationJobType),
    RoleArn: S.optional(S.String),
    InputConfig: S.optional(RecommendationJobInputConfig),
    JobDescription: S.optional(S.String),
    StoppingConditions: S.optional(RecommendationJobStoppingConditions),
    OutputConfig: S.optional(RecommendationJobOutputConfig),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateInferenceRecommendationsJobRequest",
}) as any as S.Schema<CreateInferenceRecommendationsJobRequest>;
export interface CreateInferenceRecommendationsJobResponse {
  JobArn: string;
}
export const CreateInferenceRecommendationsJobResponse = S.suspend(() =>
  S.Struct({ JobArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateInferenceRecommendationsJobResponse",
}) as any as S.Schema<CreateInferenceRecommendationsJobResponse>;
export interface LabelingJobS3DataSource {
  ManifestS3Uri?: string;
}
export const LabelingJobS3DataSource = S.suspend(() =>
  S.Struct({ ManifestS3Uri: S.optional(S.String) }),
).annotate({
  identifier: "LabelingJobS3DataSource",
}) as any as S.Schema<LabelingJobS3DataSource>;
export interface LabelingJobSnsDataSource {
  SnsTopicArn?: string;
}
export const LabelingJobSnsDataSource = S.suspend(() =>
  S.Struct({ SnsTopicArn: S.optional(S.String) }),
).annotate({
  identifier: "LabelingJobSnsDataSource",
}) as any as S.Schema<LabelingJobSnsDataSource>;
export interface LabelingJobDataSource {
  S3DataSource?: LabelingJobS3DataSource;
  SnsDataSource?: LabelingJobSnsDataSource;
}
export const LabelingJobDataSource = S.suspend(() =>
  S.Struct({
    S3DataSource: S.optional(LabelingJobS3DataSource),
    SnsDataSource: S.optional(LabelingJobSnsDataSource),
  }),
).annotate({
  identifier: "LabelingJobDataSource",
}) as any as S.Schema<LabelingJobDataSource>;
export type ContentClassifier =
  | "FreeOfPersonallyIdentifiableInformation"
  | "FreeOfAdultContent"
  | (string & {});
export const ContentClassifier = S.String;
export type ContentClassifiers = ContentClassifier[];
export const ContentClassifiers = S.Array(ContentClassifier);
export interface LabelingJobDataAttributes {
  ContentClassifiers?: ContentClassifier[];
}
export const LabelingJobDataAttributes = S.suspend(() =>
  S.Struct({ ContentClassifiers: S.optional(ContentClassifiers) }),
).annotate({
  identifier: "LabelingJobDataAttributes",
}) as any as S.Schema<LabelingJobDataAttributes>;
export interface LabelingJobInputConfig {
  DataSource?: LabelingJobDataSource;
  DataAttributes?: LabelingJobDataAttributes;
}
export const LabelingJobInputConfig = S.suspend(() =>
  S.Struct({
    DataSource: S.optional(LabelingJobDataSource),
    DataAttributes: S.optional(LabelingJobDataAttributes),
  }),
).annotate({
  identifier: "LabelingJobInputConfig",
}) as any as S.Schema<LabelingJobInputConfig>;
export interface LabelingJobOutputConfig {
  S3OutputPath?: string;
  KmsKeyId?: string;
  SnsTopicArn?: string;
}
export const LabelingJobOutputConfig = S.suspend(() =>
  S.Struct({
    S3OutputPath: S.optional(S.String),
    KmsKeyId: S.optional(S.String),
    SnsTopicArn: S.optional(S.String),
  }),
).annotate({
  identifier: "LabelingJobOutputConfig",
}) as any as S.Schema<LabelingJobOutputConfig>;
export interface LabelingJobStoppingConditions {
  MaxHumanLabeledObjectCount?: number;
  MaxPercentageOfInputDatasetLabeled?: number;
}
export const LabelingJobStoppingConditions = S.suspend(() =>
  S.Struct({
    MaxHumanLabeledObjectCount: S.optional(S.Number),
    MaxPercentageOfInputDatasetLabeled: S.optional(S.Number),
  }),
).annotate({
  identifier: "LabelingJobStoppingConditions",
}) as any as S.Schema<LabelingJobStoppingConditions>;
export interface LabelingJobResourceConfig {
  VolumeKmsKeyId?: string;
  VpcConfig?: VpcConfig;
}
export const LabelingJobResourceConfig = S.suspend(() =>
  S.Struct({
    VolumeKmsKeyId: S.optional(S.String),
    VpcConfig: S.optional(VpcConfig),
  }),
).annotate({
  identifier: "LabelingJobResourceConfig",
}) as any as S.Schema<LabelingJobResourceConfig>;
export interface LabelingJobAlgorithmsConfig {
  LabelingJobAlgorithmSpecificationArn?: string;
  InitialActiveLearningModelArn?: string;
  LabelingJobResourceConfig?: LabelingJobResourceConfig;
}
export const LabelingJobAlgorithmsConfig = S.suspend(() =>
  S.Struct({
    LabelingJobAlgorithmSpecificationArn: S.optional(S.String),
    InitialActiveLearningModelArn: S.optional(S.String),
    LabelingJobResourceConfig: S.optional(LabelingJobResourceConfig),
  }),
).annotate({
  identifier: "LabelingJobAlgorithmsConfig",
}) as any as S.Schema<LabelingJobAlgorithmsConfig>;
export interface UiConfig {
  UiTemplateS3Uri?: string;
  HumanTaskUiArn?: string;
}
export const UiConfig = S.suspend(() =>
  S.Struct({
    UiTemplateS3Uri: S.optional(S.String),
    HumanTaskUiArn: S.optional(S.String),
  }),
).annotate({ identifier: "UiConfig" }) as any as S.Schema<UiConfig>;
export type TaskKeywords = string[];
export const TaskKeywords = S.Array(S.String);
export interface AnnotationConsolidationConfig {
  AnnotationConsolidationLambdaArn?: string;
}
export const AnnotationConsolidationConfig = S.suspend(() =>
  S.Struct({ AnnotationConsolidationLambdaArn: S.optional(S.String) }),
).annotate({
  identifier: "AnnotationConsolidationConfig",
}) as any as S.Schema<AnnotationConsolidationConfig>;
export interface HumanTaskConfig {
  WorkteamArn?: string;
  UiConfig?: UiConfig;
  PreHumanTaskLambdaArn?: string;
  TaskKeywords?: string[];
  TaskTitle?: string;
  TaskDescription?: string;
  NumberOfHumanWorkersPerDataObject?: number;
  TaskTimeLimitInSeconds?: number;
  TaskAvailabilityLifetimeInSeconds?: number;
  MaxConcurrentTaskCount?: number;
  AnnotationConsolidationConfig?: AnnotationConsolidationConfig;
  PublicWorkforceTaskPrice?: PublicWorkforceTaskPrice;
}
export const HumanTaskConfig = S.suspend(() =>
  S.Struct({
    WorkteamArn: S.optional(S.String),
    UiConfig: S.optional(UiConfig),
    PreHumanTaskLambdaArn: S.optional(S.String),
    TaskKeywords: S.optional(TaskKeywords),
    TaskTitle: S.optional(S.String),
    TaskDescription: S.optional(S.String),
    NumberOfHumanWorkersPerDataObject: S.optional(S.Number),
    TaskTimeLimitInSeconds: S.optional(S.Number),
    TaskAvailabilityLifetimeInSeconds: S.optional(S.Number),
    MaxConcurrentTaskCount: S.optional(S.Number),
    AnnotationConsolidationConfig: S.optional(AnnotationConsolidationConfig),
    PublicWorkforceTaskPrice: S.optional(PublicWorkforceTaskPrice),
  }),
).annotate({
  identifier: "HumanTaskConfig",
}) as any as S.Schema<HumanTaskConfig>;
export interface CreateLabelingJobRequest {
  LabelingJobName?: string;
  LabelAttributeName?: string;
  InputConfig?: LabelingJobInputConfig;
  OutputConfig?: LabelingJobOutputConfig;
  RoleArn?: string;
  LabelCategoryConfigS3Uri?: string;
  StoppingConditions?: LabelingJobStoppingConditions;
  LabelingJobAlgorithmsConfig?: LabelingJobAlgorithmsConfig;
  HumanTaskConfig?: HumanTaskConfig;
  Tags?: Tag[];
}
export const CreateLabelingJobRequest = S.suspend(() =>
  S.Struct({
    LabelingJobName: S.optional(S.String),
    LabelAttributeName: S.optional(S.String),
    InputConfig: S.optional(LabelingJobInputConfig),
    OutputConfig: S.optional(LabelingJobOutputConfig),
    RoleArn: S.optional(S.String),
    LabelCategoryConfigS3Uri: S.optional(S.String),
    StoppingConditions: S.optional(LabelingJobStoppingConditions),
    LabelingJobAlgorithmsConfig: S.optional(LabelingJobAlgorithmsConfig),
    HumanTaskConfig: S.optional(HumanTaskConfig),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateLabelingJobRequest",
}) as any as S.Schema<CreateLabelingJobRequest>;
export interface CreateLabelingJobResponse {
  LabelingJobArn: string;
}
export const CreateLabelingJobResponse = S.suspend(() =>
  S.Struct({ LabelingJobArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateLabelingJobResponse",
}) as any as S.Schema<CreateLabelingJobResponse>;
export type ModelRegistrationMode =
  | "AutoModelRegistrationEnabled"
  | "AutoModelRegistrationDisabled"
  | (string & {});
export const ModelRegistrationMode = S.String;
export type AccountDefaultStatus = "ENABLED" | "DISABLED" | (string & {});
export const AccountDefaultStatus = S.String;
export type DefaultDomainIdList = string[];
export const DefaultDomainIdList = S.Array(S.String);
export interface CreateMlflowAppRequest {
  Name?: string;
  ArtifactStoreUri?: string;
  RoleArn?: string;
  ModelRegistrationMode?: ModelRegistrationMode;
  WeeklyMaintenanceWindowStart?: string;
  AccountDefaultStatus?: AccountDefaultStatus;
  DefaultDomainIdList?: string[];
  Tags?: Tag[];
}
export const CreateMlflowAppRequest = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    ArtifactStoreUri: S.optional(S.String),
    RoleArn: S.optional(S.String),
    ModelRegistrationMode: S.optional(ModelRegistrationMode),
    WeeklyMaintenanceWindowStart: S.optional(S.String),
    AccountDefaultStatus: S.optional(AccountDefaultStatus),
    DefaultDomainIdList: S.optional(DefaultDomainIdList),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateMlflowAppRequest",
}) as any as S.Schema<CreateMlflowAppRequest>;
export interface CreateMlflowAppResponse {
  Arn?: string;
}
export const CreateMlflowAppResponse = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateMlflowAppResponse",
}) as any as S.Schema<CreateMlflowAppResponse>;
export type TrackingServerSize = "Small" | "Medium" | "Large" | (string & {});
export const TrackingServerSize = S.String;
export interface CreateMlflowTrackingServerRequest {
  TrackingServerName?: string;
  ArtifactStoreUri?: string;
  TrackingServerSize?: TrackingServerSize;
  MlflowVersion?: string;
  RoleArn?: string;
  AutomaticModelRegistration?: boolean;
  WeeklyMaintenanceWindowStart?: string;
  Tags?: Tag[];
}
export const CreateMlflowTrackingServerRequest = S.suspend(() =>
  S.Struct({
    TrackingServerName: S.optional(S.String),
    ArtifactStoreUri: S.optional(S.String),
    TrackingServerSize: S.optional(TrackingServerSize),
    MlflowVersion: S.optional(S.String),
    RoleArn: S.optional(S.String),
    AutomaticModelRegistration: S.optional(S.Boolean),
    WeeklyMaintenanceWindowStart: S.optional(S.String),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateMlflowTrackingServerRequest",
}) as any as S.Schema<CreateMlflowTrackingServerRequest>;
export interface CreateMlflowTrackingServerResponse {
  TrackingServerArn?: string;
}
export const CreateMlflowTrackingServerResponse = S.suspend(() =>
  S.Struct({ TrackingServerArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateMlflowTrackingServerResponse",
}) as any as S.Schema<CreateMlflowTrackingServerResponse>;
export type RepositoryAccessMode = "Platform" | "Vpc" | (string & {});
export const RepositoryAccessMode = S.String;
export interface RepositoryAuthConfig {
  RepositoryCredentialsProviderArn?: string;
}
export const RepositoryAuthConfig = S.suspend(() =>
  S.Struct({ RepositoryCredentialsProviderArn: S.optional(S.String) }),
).annotate({
  identifier: "RepositoryAuthConfig",
}) as any as S.Schema<RepositoryAuthConfig>;
export interface ImageConfig {
  RepositoryAccessMode?: RepositoryAccessMode;
  RepositoryAuthConfig?: RepositoryAuthConfig;
}
export const ImageConfig = S.suspend(() =>
  S.Struct({
    RepositoryAccessMode: S.optional(RepositoryAccessMode),
    RepositoryAuthConfig: S.optional(RepositoryAuthConfig),
  }),
).annotate({ identifier: "ImageConfig" }) as any as S.Schema<ImageConfig>;
export type ContainerMode = "SingleModel" | "MultiModel" | (string & {});
export const ContainerMode = S.String;
export interface AdditionalModelDataSource {
  ChannelName?: string;
  S3DataSource?: S3ModelDataSource;
}
export const AdditionalModelDataSource = S.suspend(() =>
  S.Struct({
    ChannelName: S.optional(S.String),
    S3DataSource: S.optional(S3ModelDataSource),
  }),
).annotate({
  identifier: "AdditionalModelDataSource",
}) as any as S.Schema<AdditionalModelDataSource>;
export type AdditionalModelDataSources = AdditionalModelDataSource[];
export const AdditionalModelDataSources = S.Array(AdditionalModelDataSource);
export type ModelCacheSetting = "Enabled" | "Disabled" | (string & {});
export const ModelCacheSetting = S.String;
export interface MultiModelConfig {
  ModelCacheSetting?: ModelCacheSetting;
}
export const MultiModelConfig = S.suspend(() =>
  S.Struct({ ModelCacheSetting: S.optional(ModelCacheSetting) }),
).annotate({
  identifier: "MultiModelConfig",
}) as any as S.Schema<MultiModelConfig>;
export interface ContainerDefinition {
  ContainerHostname?: string;
  Image?: string;
  ImageConfig?: ImageConfig;
  Mode?: ContainerMode;
  ModelDataUrl?: string;
  ModelDataSource?: ModelDataSource;
  AdditionalModelDataSources?: AdditionalModelDataSource[];
  Environment?: { [key: string]: string | undefined };
  ModelPackageName?: string;
  InferenceSpecificationName?: string;
  MultiModelConfig?: MultiModelConfig;
}
export const ContainerDefinition = S.suspend(() =>
  S.Struct({
    ContainerHostname: S.optional(S.String),
    Image: S.optional(S.String),
    ImageConfig: S.optional(ImageConfig),
    Mode: S.optional(ContainerMode),
    ModelDataUrl: S.optional(S.String),
    ModelDataSource: S.optional(ModelDataSource),
    AdditionalModelDataSources: S.optional(AdditionalModelDataSources),
    Environment: S.optional(EnvironmentMap),
    ModelPackageName: S.optional(S.String),
    InferenceSpecificationName: S.optional(S.String),
    MultiModelConfig: S.optional(MultiModelConfig),
  }),
).annotate({
  identifier: "ContainerDefinition",
}) as any as S.Schema<ContainerDefinition>;
export type ContainerDefinitionList = ContainerDefinition[];
export const ContainerDefinitionList = S.Array(ContainerDefinition);
export type InferenceExecutionMode = "Serial" | "Direct" | (string & {});
export const InferenceExecutionMode = S.String;
export interface InferenceExecutionConfig {
  Mode?: InferenceExecutionMode;
}
export const InferenceExecutionConfig = S.suspend(() =>
  S.Struct({ Mode: S.optional(InferenceExecutionMode) }),
).annotate({
  identifier: "InferenceExecutionConfig",
}) as any as S.Schema<InferenceExecutionConfig>;
export interface CreateModelInput {
  ModelName?: string;
  PrimaryContainer?: ContainerDefinition;
  Containers?: ContainerDefinition[];
  InferenceExecutionConfig?: InferenceExecutionConfig;
  ExecutionRoleArn?: string;
  Tags?: Tag[];
  VpcConfig?: VpcConfig;
  EnableNetworkIsolation?: boolean;
}
export const CreateModelInput = S.suspend(() =>
  S.Struct({
    ModelName: S.optional(S.String),
    PrimaryContainer: S.optional(ContainerDefinition),
    Containers: S.optional(ContainerDefinitionList),
    InferenceExecutionConfig: S.optional(InferenceExecutionConfig),
    ExecutionRoleArn: S.optional(S.String),
    Tags: S.optional(TagList),
    VpcConfig: S.optional(VpcConfig),
    EnableNetworkIsolation: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateModelInput",
}) as any as S.Schema<CreateModelInput>;
export interface CreateModelOutput {
  ModelArn: string;
}
export const CreateModelOutput = S.suspend(() =>
  S.Struct({ ModelArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateModelOutput",
}) as any as S.Schema<CreateModelOutput>;
export interface ModelBiasBaselineConfig {
  BaseliningJobName?: string;
  ConstraintsResource?: MonitoringConstraintsResource;
}
export const ModelBiasBaselineConfig = S.suspend(() =>
  S.Struct({
    BaseliningJobName: S.optional(S.String),
    ConstraintsResource: S.optional(MonitoringConstraintsResource),
  }),
).annotate({
  identifier: "ModelBiasBaselineConfig",
}) as any as S.Schema<ModelBiasBaselineConfig>;
export interface ModelBiasAppSpecification {
  ImageUri?: string;
  ConfigUri?: string;
  Environment?: { [key: string]: string | undefined };
}
export const ModelBiasAppSpecification = S.suspend(() =>
  S.Struct({
    ImageUri: S.optional(S.String),
    ConfigUri: S.optional(S.String),
    Environment: S.optional(MonitoringEnvironmentMap),
  }),
).annotate({
  identifier: "ModelBiasAppSpecification",
}) as any as S.Schema<ModelBiasAppSpecification>;
export interface MonitoringGroundTruthS3Input {
  S3Uri?: string;
}
export const MonitoringGroundTruthS3Input = S.suspend(() =>
  S.Struct({ S3Uri: S.optional(S.String) }),
).annotate({
  identifier: "MonitoringGroundTruthS3Input",
}) as any as S.Schema<MonitoringGroundTruthS3Input>;
export interface ModelBiasJobInput {
  EndpointInput?: EndpointInput;
  BatchTransformInput?: BatchTransformInput;
  GroundTruthS3Input?: MonitoringGroundTruthS3Input;
}
export const ModelBiasJobInput = S.suspend(() =>
  S.Struct({
    EndpointInput: S.optional(EndpointInput),
    BatchTransformInput: S.optional(BatchTransformInput),
    GroundTruthS3Input: S.optional(MonitoringGroundTruthS3Input),
  }),
).annotate({
  identifier: "ModelBiasJobInput",
}) as any as S.Schema<ModelBiasJobInput>;
export interface CreateModelBiasJobDefinitionRequest {
  JobDefinitionName?: string;
  ModelBiasBaselineConfig?: ModelBiasBaselineConfig;
  ModelBiasAppSpecification?: ModelBiasAppSpecification;
  ModelBiasJobInput?: ModelBiasJobInput;
  ModelBiasJobOutputConfig?: MonitoringOutputConfig;
  JobResources?: MonitoringResources;
  NetworkConfig?: MonitoringNetworkConfig;
  RoleArn?: string;
  StoppingCondition?: MonitoringStoppingCondition;
  Tags?: Tag[];
}
export const CreateModelBiasJobDefinitionRequest = S.suspend(() =>
  S.Struct({
    JobDefinitionName: S.optional(S.String),
    ModelBiasBaselineConfig: S.optional(ModelBiasBaselineConfig),
    ModelBiasAppSpecification: S.optional(ModelBiasAppSpecification),
    ModelBiasJobInput: S.optional(ModelBiasJobInput),
    ModelBiasJobOutputConfig: S.optional(MonitoringOutputConfig),
    JobResources: S.optional(MonitoringResources),
    NetworkConfig: S.optional(MonitoringNetworkConfig),
    RoleArn: S.optional(S.String),
    StoppingCondition: S.optional(MonitoringStoppingCondition),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateModelBiasJobDefinitionRequest",
}) as any as S.Schema<CreateModelBiasJobDefinitionRequest>;
export interface CreateModelBiasJobDefinitionResponse {
  JobDefinitionArn: string;
}
export const CreateModelBiasJobDefinitionResponse = S.suspend(() =>
  S.Struct({ JobDefinitionArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateModelBiasJobDefinitionResponse",
}) as any as S.Schema<CreateModelBiasJobDefinitionResponse>;
export interface ModelCardSecurityConfig {
  KmsKeyId?: string;
}
export const ModelCardSecurityConfig = S.suspend(() =>
  S.Struct({ KmsKeyId: S.optional(S.String) }),
).annotate({
  identifier: "ModelCardSecurityConfig",
}) as any as S.Schema<ModelCardSecurityConfig>;
export type ModelCardStatus =
  | "Draft"
  | "PendingReview"
  | "Approved"
  | "Archived"
  | (string & {});
export const ModelCardStatus = S.String;
export interface CreateModelCardRequest {
  ModelCardName?: string;
  SecurityConfig?: ModelCardSecurityConfig;
  Content?: string | redacted.Redacted<string>;
  ModelCardStatus?: ModelCardStatus;
  Tags?: Tag[];
}
export const CreateModelCardRequest = S.suspend(() =>
  S.Struct({
    ModelCardName: S.optional(S.String),
    SecurityConfig: S.optional(ModelCardSecurityConfig),
    Content: S.optional(SensitiveString),
    ModelCardStatus: S.optional(ModelCardStatus),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateModelCardRequest",
}) as any as S.Schema<CreateModelCardRequest>;
export interface CreateModelCardResponse {
  ModelCardArn: string;
}
export const CreateModelCardResponse = S.suspend(() =>
  S.Struct({ ModelCardArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateModelCardResponse",
}) as any as S.Schema<CreateModelCardResponse>;
export interface ModelCardExportOutputConfig {
  S3OutputPath?: string;
}
export const ModelCardExportOutputConfig = S.suspend(() =>
  S.Struct({ S3OutputPath: S.optional(S.String) }),
).annotate({
  identifier: "ModelCardExportOutputConfig",
}) as any as S.Schema<ModelCardExportOutputConfig>;
export interface CreateModelCardExportJobRequest {
  ModelCardName?: string;
  ModelCardVersion?: number;
  ModelCardExportJobName?: string;
  OutputConfig?: ModelCardExportOutputConfig;
}
export const CreateModelCardExportJobRequest = S.suspend(() =>
  S.Struct({
    ModelCardName: S.optional(S.String),
    ModelCardVersion: S.optional(S.Number),
    ModelCardExportJobName: S.optional(S.String),
    OutputConfig: S.optional(ModelCardExportOutputConfig),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateModelCardExportJobRequest",
}) as any as S.Schema<CreateModelCardExportJobRequest>;
export interface CreateModelCardExportJobResponse {
  ModelCardExportJobArn: string;
}
export const CreateModelCardExportJobResponse = S.suspend(() =>
  S.Struct({ ModelCardExportJobArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateModelCardExportJobResponse",
}) as any as S.Schema<CreateModelCardExportJobResponse>;
export interface ModelExplainabilityBaselineConfig {
  BaseliningJobName?: string;
  ConstraintsResource?: MonitoringConstraintsResource;
}
export const ModelExplainabilityBaselineConfig = S.suspend(() =>
  S.Struct({
    BaseliningJobName: S.optional(S.String),
    ConstraintsResource: S.optional(MonitoringConstraintsResource),
  }),
).annotate({
  identifier: "ModelExplainabilityBaselineConfig",
}) as any as S.Schema<ModelExplainabilityBaselineConfig>;
export interface ModelExplainabilityAppSpecification {
  ImageUri?: string;
  ConfigUri?: string;
  Environment?: { [key: string]: string | undefined };
}
export const ModelExplainabilityAppSpecification = S.suspend(() =>
  S.Struct({
    ImageUri: S.optional(S.String),
    ConfigUri: S.optional(S.String),
    Environment: S.optional(MonitoringEnvironmentMap),
  }),
).annotate({
  identifier: "ModelExplainabilityAppSpecification",
}) as any as S.Schema<ModelExplainabilityAppSpecification>;
export interface ModelExplainabilityJobInput {
  EndpointInput?: EndpointInput;
  BatchTransformInput?: BatchTransformInput;
}
export const ModelExplainabilityJobInput = S.suspend(() =>
  S.Struct({
    EndpointInput: S.optional(EndpointInput),
    BatchTransformInput: S.optional(BatchTransformInput),
  }),
).annotate({
  identifier: "ModelExplainabilityJobInput",
}) as any as S.Schema<ModelExplainabilityJobInput>;
export interface CreateModelExplainabilityJobDefinitionRequest {
  JobDefinitionName?: string;
  ModelExplainabilityBaselineConfig?: ModelExplainabilityBaselineConfig;
  ModelExplainabilityAppSpecification?: ModelExplainabilityAppSpecification;
  ModelExplainabilityJobInput?: ModelExplainabilityJobInput;
  ModelExplainabilityJobOutputConfig?: MonitoringOutputConfig;
  JobResources?: MonitoringResources;
  NetworkConfig?: MonitoringNetworkConfig;
  RoleArn?: string;
  StoppingCondition?: MonitoringStoppingCondition;
  Tags?: Tag[];
}
export const CreateModelExplainabilityJobDefinitionRequest = S.suspend(() =>
  S.Struct({
    JobDefinitionName: S.optional(S.String),
    ModelExplainabilityBaselineConfig: S.optional(
      ModelExplainabilityBaselineConfig,
    ),
    ModelExplainabilityAppSpecification: S.optional(
      ModelExplainabilityAppSpecification,
    ),
    ModelExplainabilityJobInput: S.optional(ModelExplainabilityJobInput),
    ModelExplainabilityJobOutputConfig: S.optional(MonitoringOutputConfig),
    JobResources: S.optional(MonitoringResources),
    NetworkConfig: S.optional(MonitoringNetworkConfig),
    RoleArn: S.optional(S.String),
    StoppingCondition: S.optional(MonitoringStoppingCondition),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateModelExplainabilityJobDefinitionRequest",
}) as any as S.Schema<CreateModelExplainabilityJobDefinitionRequest>;
export interface CreateModelExplainabilityJobDefinitionResponse {
  JobDefinitionArn: string;
}
export const CreateModelExplainabilityJobDefinitionResponse = S.suspend(() =>
  S.Struct({ JobDefinitionArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateModelExplainabilityJobDefinitionResponse",
}) as any as S.Schema<CreateModelExplainabilityJobDefinitionResponse>;
export interface ModelPackageValidationProfile {
  ProfileName?: string;
  TransformJobDefinition?: TransformJobDefinition;
}
export const ModelPackageValidationProfile = S.suspend(() =>
  S.Struct({
    ProfileName: S.optional(S.String),
    TransformJobDefinition: S.optional(TransformJobDefinition),
  }),
).annotate({
  identifier: "ModelPackageValidationProfile",
}) as any as S.Schema<ModelPackageValidationProfile>;
export type ModelPackageValidationProfiles = ModelPackageValidationProfile[];
export const ModelPackageValidationProfiles = S.Array(
  ModelPackageValidationProfile,
);
export interface ModelPackageValidationSpecification {
  ValidationRole?: string;
  ValidationProfiles?: ModelPackageValidationProfile[];
}
export const ModelPackageValidationSpecification = S.suspend(() =>
  S.Struct({
    ValidationRole: S.optional(S.String),
    ValidationProfiles: S.optional(ModelPackageValidationProfiles),
  }),
).annotate({
  identifier: "ModelPackageValidationSpecification",
}) as any as S.Schema<ModelPackageValidationSpecification>;
export interface SourceAlgorithm {
  ModelDataUrl?: string;
  ModelDataSource?: ModelDataSource;
  ModelDataETag?: string;
  AlgorithmName?: string;
}
export const SourceAlgorithm = S.suspend(() =>
  S.Struct({
    ModelDataUrl: S.optional(S.String),
    ModelDataSource: S.optional(ModelDataSource),
    ModelDataETag: S.optional(S.String),
    AlgorithmName: S.optional(S.String),
  }),
).annotate({
  identifier: "SourceAlgorithm",
}) as any as S.Schema<SourceAlgorithm>;
export type SourceAlgorithmList = SourceAlgorithm[];
export const SourceAlgorithmList = S.Array(SourceAlgorithm);
export interface SourceAlgorithmSpecification {
  SourceAlgorithms?: SourceAlgorithm[];
}
export const SourceAlgorithmSpecification = S.suspend(() =>
  S.Struct({ SourceAlgorithms: S.optional(SourceAlgorithmList) }),
).annotate({
  identifier: "SourceAlgorithmSpecification",
}) as any as S.Schema<SourceAlgorithmSpecification>;
export interface MetricsSource {
  ContentType?: string;
  ContentDigest?: string;
  S3Uri?: string;
}
export const MetricsSource = S.suspend(() =>
  S.Struct({
    ContentType: S.optional(S.String),
    ContentDigest: S.optional(S.String),
    S3Uri: S.optional(S.String),
  }),
).annotate({ identifier: "MetricsSource" }) as any as S.Schema<MetricsSource>;
export interface ModelQuality {
  Statistics?: MetricsSource;
  Constraints?: MetricsSource;
}
export const ModelQuality = S.suspend(() =>
  S.Struct({
    Statistics: S.optional(MetricsSource),
    Constraints: S.optional(MetricsSource),
  }),
).annotate({ identifier: "ModelQuality" }) as any as S.Schema<ModelQuality>;
export interface ModelDataQuality {
  Statistics?: MetricsSource;
  Constraints?: MetricsSource;
}
export const ModelDataQuality = S.suspend(() =>
  S.Struct({
    Statistics: S.optional(MetricsSource),
    Constraints: S.optional(MetricsSource),
  }),
).annotate({
  identifier: "ModelDataQuality",
}) as any as S.Schema<ModelDataQuality>;
export interface Bias {
  Report?: MetricsSource;
  PreTrainingReport?: MetricsSource;
  PostTrainingReport?: MetricsSource;
}
export const Bias = S.suspend(() =>
  S.Struct({
    Report: S.optional(MetricsSource),
    PreTrainingReport: S.optional(MetricsSource),
    PostTrainingReport: S.optional(MetricsSource),
  }),
).annotate({ identifier: "Bias" }) as any as S.Schema<Bias>;
export interface Explainability {
  Report?: MetricsSource;
}
export const Explainability = S.suspend(() =>
  S.Struct({ Report: S.optional(MetricsSource) }),
).annotate({ identifier: "Explainability" }) as any as S.Schema<Explainability>;
export interface ModelMetrics {
  ModelQuality?: ModelQuality;
  ModelDataQuality?: ModelDataQuality;
  Bias?: Bias;
  Explainability?: Explainability;
}
export const ModelMetrics = S.suspend(() =>
  S.Struct({
    ModelQuality: S.optional(ModelQuality),
    ModelDataQuality: S.optional(ModelDataQuality),
    Bias: S.optional(Bias),
    Explainability: S.optional(Explainability),
  }),
).annotate({ identifier: "ModelMetrics" }) as any as S.Schema<ModelMetrics>;
export type CustomerMetadataMap = { [key: string]: string | undefined };
export const CustomerMetadataMap = S.Record(
  S.String,
  S.String.pipe(S.optional),
);
export interface FileSource {
  ContentType?: string;
  ContentDigest?: string;
  S3Uri?: string;
}
export const FileSource = S.suspend(() =>
  S.Struct({
    ContentType: S.optional(S.String),
    ContentDigest: S.optional(S.String),
    S3Uri: S.optional(S.String),
  }),
).annotate({ identifier: "FileSource" }) as any as S.Schema<FileSource>;
export interface DriftCheckBias {
  ConfigFile?: FileSource;
  PreTrainingConstraints?: MetricsSource;
  PostTrainingConstraints?: MetricsSource;
}
export const DriftCheckBias = S.suspend(() =>
  S.Struct({
    ConfigFile: S.optional(FileSource),
    PreTrainingConstraints: S.optional(MetricsSource),
    PostTrainingConstraints: S.optional(MetricsSource),
  }),
).annotate({ identifier: "DriftCheckBias" }) as any as S.Schema<DriftCheckBias>;
export interface DriftCheckExplainability {
  Constraints?: MetricsSource;
  ConfigFile?: FileSource;
}
export const DriftCheckExplainability = S.suspend(() =>
  S.Struct({
    Constraints: S.optional(MetricsSource),
    ConfigFile: S.optional(FileSource),
  }),
).annotate({
  identifier: "DriftCheckExplainability",
}) as any as S.Schema<DriftCheckExplainability>;
export interface DriftCheckModelQuality {
  Statistics?: MetricsSource;
  Constraints?: MetricsSource;
}
export const DriftCheckModelQuality = S.suspend(() =>
  S.Struct({
    Statistics: S.optional(MetricsSource),
    Constraints: S.optional(MetricsSource),
  }),
).annotate({
  identifier: "DriftCheckModelQuality",
}) as any as S.Schema<DriftCheckModelQuality>;
export interface DriftCheckModelDataQuality {
  Statistics?: MetricsSource;
  Constraints?: MetricsSource;
}
export const DriftCheckModelDataQuality = S.suspend(() =>
  S.Struct({
    Statistics: S.optional(MetricsSource),
    Constraints: S.optional(MetricsSource),
  }),
).annotate({
  identifier: "DriftCheckModelDataQuality",
}) as any as S.Schema<DriftCheckModelDataQuality>;
export interface DriftCheckBaselines {
  Bias?: DriftCheckBias;
  Explainability?: DriftCheckExplainability;
  ModelQuality?: DriftCheckModelQuality;
  ModelDataQuality?: DriftCheckModelDataQuality;
}
export const DriftCheckBaselines = S.suspend(() =>
  S.Struct({
    Bias: S.optional(DriftCheckBias),
    Explainability: S.optional(DriftCheckExplainability),
    ModelQuality: S.optional(DriftCheckModelQuality),
    ModelDataQuality: S.optional(DriftCheckModelDataQuality),
  }),
).annotate({
  identifier: "DriftCheckBaselines",
}) as any as S.Schema<DriftCheckBaselines>;
export interface AdditionalInferenceSpecificationDefinition {
  Name?: string;
  Description?: string;
  Containers?: ModelPackageContainerDefinition[];
  SupportedTransformInstanceTypes?: TransformInstanceType[];
  SupportedRealtimeInferenceInstanceTypes?: ProductionVariantInstanceType[];
  SupportedContentTypes?: string[];
  SupportedResponseMIMETypes?: string[];
}
export const AdditionalInferenceSpecificationDefinition = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    Containers: S.optional(ModelPackageContainerDefinitionList),
    SupportedTransformInstanceTypes: S.optional(TransformInstanceTypes),
    SupportedRealtimeInferenceInstanceTypes: S.optional(
      RealtimeInferenceInstanceTypes,
    ),
    SupportedContentTypes: S.optional(ContentTypes),
    SupportedResponseMIMETypes: S.optional(ResponseMIMETypes),
  }),
).annotate({
  identifier: "AdditionalInferenceSpecificationDefinition",
}) as any as S.Schema<AdditionalInferenceSpecificationDefinition>;
export type AdditionalInferenceSpecifications =
  AdditionalInferenceSpecificationDefinition[];
export const AdditionalInferenceSpecifications = S.Array(
  AdditionalInferenceSpecificationDefinition,
);
export type SkipModelValidation = "All" | "None" | (string & {});
export const SkipModelValidation = S.String;
export interface ModelPackageSecurityConfig {
  KmsKeyId?: string;
}
export const ModelPackageSecurityConfig = S.suspend(() =>
  S.Struct({ KmsKeyId: S.optional(S.String) }),
).annotate({
  identifier: "ModelPackageSecurityConfig",
}) as any as S.Schema<ModelPackageSecurityConfig>;
export interface ModelPackageModelCard {
  ModelCardContent?: string | redacted.Redacted<string>;
  ModelCardStatus?: ModelCardStatus;
}
export const ModelPackageModelCard = S.suspend(() =>
  S.Struct({
    ModelCardContent: S.optional(SensitiveString),
    ModelCardStatus: S.optional(ModelCardStatus),
  }),
).annotate({
  identifier: "ModelPackageModelCard",
}) as any as S.Schema<ModelPackageModelCard>;
export interface ModelLifeCycle {
  Stage?: string;
  StageStatus?: string;
  StageDescription?: string;
}
export const ModelLifeCycle = S.suspend(() =>
  S.Struct({
    Stage: S.optional(S.String),
    StageStatus: S.optional(S.String),
    StageDescription: S.optional(S.String),
  }),
).annotate({ identifier: "ModelLifeCycle" }) as any as S.Schema<ModelLifeCycle>;
export interface CreateModelPackageInput {
  ModelPackageName?: string;
  ModelPackageGroupName?: string;
  ModelPackageDescription?: string;
  ModelPackageRegistrationType?: ModelPackageRegistrationType;
  InferenceSpecification?: InferenceSpecification;
  ValidationSpecification?: ModelPackageValidationSpecification;
  SourceAlgorithmSpecification?: SourceAlgorithmSpecification;
  CertifyForMarketplace?: boolean;
  Tags?: Tag[];
  ModelApprovalStatus?: ModelApprovalStatus;
  MetadataProperties?: MetadataProperties;
  ModelMetrics?: ModelMetrics;
  ClientToken?: string;
  Domain?: string;
  Task?: string;
  SamplePayloadUrl?: string;
  CustomerMetadataProperties?: { [key: string]: string | undefined };
  DriftCheckBaselines?: DriftCheckBaselines;
  AdditionalInferenceSpecifications?: AdditionalInferenceSpecificationDefinition[];
  SkipModelValidation?: SkipModelValidation;
  SourceUri?: string;
  SecurityConfig?: ModelPackageSecurityConfig;
  ModelCard?: ModelPackageModelCard;
  ModelLifeCycle?: ModelLifeCycle;
}
export const CreateModelPackageInput = S.suspend(() =>
  S.Struct({
    ModelPackageName: S.optional(S.String),
    ModelPackageGroupName: S.optional(S.String),
    ModelPackageDescription: S.optional(S.String),
    ModelPackageRegistrationType: S.optional(ModelPackageRegistrationType),
    InferenceSpecification: S.optional(InferenceSpecification),
    ValidationSpecification: S.optional(ModelPackageValidationSpecification),
    SourceAlgorithmSpecification: S.optional(SourceAlgorithmSpecification),
    CertifyForMarketplace: S.optional(S.Boolean),
    Tags: S.optional(TagList),
    ModelApprovalStatus: S.optional(ModelApprovalStatus),
    MetadataProperties: S.optional(MetadataProperties),
    ModelMetrics: S.optional(ModelMetrics),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    Domain: S.optional(S.String),
    Task: S.optional(S.String),
    SamplePayloadUrl: S.optional(S.String),
    CustomerMetadataProperties: S.optional(CustomerMetadataMap),
    DriftCheckBaselines: S.optional(DriftCheckBaselines),
    AdditionalInferenceSpecifications: S.optional(
      AdditionalInferenceSpecifications,
    ),
    SkipModelValidation: S.optional(SkipModelValidation),
    SourceUri: S.optional(S.String),
    SecurityConfig: S.optional(ModelPackageSecurityConfig),
    ModelCard: S.optional(ModelPackageModelCard),
    ModelLifeCycle: S.optional(ModelLifeCycle),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateModelPackageInput",
}) as any as S.Schema<CreateModelPackageInput>;
export interface CreateModelPackageOutput {
  ModelPackageArn: string;
}
export const CreateModelPackageOutput = S.suspend(() =>
  S.Struct({ ModelPackageArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateModelPackageOutput",
}) as any as S.Schema<CreateModelPackageOutput>;
export interface CreateModelPackageGroupInput {
  ModelPackageGroupName?: string;
  ModelPackageGroupDescription?: string;
  Tags?: Tag[];
}
export const CreateModelPackageGroupInput = S.suspend(() =>
  S.Struct({
    ModelPackageGroupName: S.optional(S.String),
    ModelPackageGroupDescription: S.optional(S.String),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateModelPackageGroupInput",
}) as any as S.Schema<CreateModelPackageGroupInput>;
export interface CreateModelPackageGroupOutput {
  ModelPackageGroupArn: string;
}
export const CreateModelPackageGroupOutput = S.suspend(() =>
  S.Struct({ ModelPackageGroupArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateModelPackageGroupOutput",
}) as any as S.Schema<CreateModelPackageGroupOutput>;
export interface ModelQualityBaselineConfig {
  BaseliningJobName?: string;
  ConstraintsResource?: MonitoringConstraintsResource;
}
export const ModelQualityBaselineConfig = S.suspend(() =>
  S.Struct({
    BaseliningJobName: S.optional(S.String),
    ConstraintsResource: S.optional(MonitoringConstraintsResource),
  }),
).annotate({
  identifier: "ModelQualityBaselineConfig",
}) as any as S.Schema<ModelQualityBaselineConfig>;
export type MonitoringProblemType =
  | "BinaryClassification"
  | "MulticlassClassification"
  | "Regression"
  | (string & {});
export const MonitoringProblemType = S.String;
export interface ModelQualityAppSpecification {
  ImageUri?: string;
  ContainerEntrypoint?: string[];
  ContainerArguments?: string[];
  RecordPreprocessorSourceUri?: string;
  PostAnalyticsProcessorSourceUri?: string;
  ProblemType?: MonitoringProblemType;
  Environment?: { [key: string]: string | undefined };
}
export const ModelQualityAppSpecification = S.suspend(() =>
  S.Struct({
    ImageUri: S.optional(S.String),
    ContainerEntrypoint: S.optional(ContainerEntrypoint),
    ContainerArguments: S.optional(MonitoringContainerArguments),
    RecordPreprocessorSourceUri: S.optional(S.String),
    PostAnalyticsProcessorSourceUri: S.optional(S.String),
    ProblemType: S.optional(MonitoringProblemType),
    Environment: S.optional(MonitoringEnvironmentMap),
  }),
).annotate({
  identifier: "ModelQualityAppSpecification",
}) as any as S.Schema<ModelQualityAppSpecification>;
export interface ModelQualityJobInput {
  EndpointInput?: EndpointInput;
  BatchTransformInput?: BatchTransformInput;
  GroundTruthS3Input?: MonitoringGroundTruthS3Input;
}
export const ModelQualityJobInput = S.suspend(() =>
  S.Struct({
    EndpointInput: S.optional(EndpointInput),
    BatchTransformInput: S.optional(BatchTransformInput),
    GroundTruthS3Input: S.optional(MonitoringGroundTruthS3Input),
  }),
).annotate({
  identifier: "ModelQualityJobInput",
}) as any as S.Schema<ModelQualityJobInput>;
export interface CreateModelQualityJobDefinitionRequest {
  JobDefinitionName?: string;
  ModelQualityBaselineConfig?: ModelQualityBaselineConfig;
  ModelQualityAppSpecification?: ModelQualityAppSpecification;
  ModelQualityJobInput?: ModelQualityJobInput;
  ModelQualityJobOutputConfig?: MonitoringOutputConfig;
  JobResources?: MonitoringResources;
  NetworkConfig?: MonitoringNetworkConfig;
  RoleArn?: string;
  StoppingCondition?: MonitoringStoppingCondition;
  Tags?: Tag[];
}
export const CreateModelQualityJobDefinitionRequest = S.suspend(() =>
  S.Struct({
    JobDefinitionName: S.optional(S.String),
    ModelQualityBaselineConfig: S.optional(ModelQualityBaselineConfig),
    ModelQualityAppSpecification: S.optional(ModelQualityAppSpecification),
    ModelQualityJobInput: S.optional(ModelQualityJobInput),
    ModelQualityJobOutputConfig: S.optional(MonitoringOutputConfig),
    JobResources: S.optional(MonitoringResources),
    NetworkConfig: S.optional(MonitoringNetworkConfig),
    RoleArn: S.optional(S.String),
    StoppingCondition: S.optional(MonitoringStoppingCondition),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateModelQualityJobDefinitionRequest",
}) as any as S.Schema<CreateModelQualityJobDefinitionRequest>;
export interface CreateModelQualityJobDefinitionResponse {
  JobDefinitionArn: string;
}
export const CreateModelQualityJobDefinitionResponse = S.suspend(() =>
  S.Struct({ JobDefinitionArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateModelQualityJobDefinitionResponse",
}) as any as S.Schema<CreateModelQualityJobDefinitionResponse>;
export interface ScheduleConfig {
  ScheduleExpression?: string;
  DataAnalysisStartTime?: string;
  DataAnalysisEndTime?: string;
}
export const ScheduleConfig = S.suspend(() =>
  S.Struct({
    ScheduleExpression: S.optional(S.String),
    DataAnalysisStartTime: S.optional(S.String),
    DataAnalysisEndTime: S.optional(S.String),
  }),
).annotate({ identifier: "ScheduleConfig" }) as any as S.Schema<ScheduleConfig>;
export interface MonitoringBaselineConfig {
  BaseliningJobName?: string;
  ConstraintsResource?: MonitoringConstraintsResource;
  StatisticsResource?: MonitoringStatisticsResource;
}
export const MonitoringBaselineConfig = S.suspend(() =>
  S.Struct({
    BaseliningJobName: S.optional(S.String),
    ConstraintsResource: S.optional(MonitoringConstraintsResource),
    StatisticsResource: S.optional(MonitoringStatisticsResource),
  }),
).annotate({
  identifier: "MonitoringBaselineConfig",
}) as any as S.Schema<MonitoringBaselineConfig>;
export interface MonitoringInput {
  EndpointInput?: EndpointInput;
  BatchTransformInput?: BatchTransformInput;
}
export const MonitoringInput = S.suspend(() =>
  S.Struct({
    EndpointInput: S.optional(EndpointInput),
    BatchTransformInput: S.optional(BatchTransformInput),
  }),
).annotate({
  identifier: "MonitoringInput",
}) as any as S.Schema<MonitoringInput>;
export type MonitoringInputs = MonitoringInput[];
export const MonitoringInputs = S.Array(MonitoringInput);
export interface MonitoringAppSpecification {
  ImageUri?: string;
  ContainerEntrypoint?: string[];
  ContainerArguments?: string[];
  RecordPreprocessorSourceUri?: string;
  PostAnalyticsProcessorSourceUri?: string;
}
export const MonitoringAppSpecification = S.suspend(() =>
  S.Struct({
    ImageUri: S.optional(S.String),
    ContainerEntrypoint: S.optional(ContainerEntrypoint),
    ContainerArguments: S.optional(MonitoringContainerArguments),
    RecordPreprocessorSourceUri: S.optional(S.String),
    PostAnalyticsProcessorSourceUri: S.optional(S.String),
  }),
).annotate({
  identifier: "MonitoringAppSpecification",
}) as any as S.Schema<MonitoringAppSpecification>;
export interface NetworkConfig {
  EnableInterContainerTrafficEncryption?: boolean;
  EnableNetworkIsolation?: boolean;
  VpcConfig?: VpcConfig;
}
export const NetworkConfig = S.suspend(() =>
  S.Struct({
    EnableInterContainerTrafficEncryption: S.optional(S.Boolean),
    EnableNetworkIsolation: S.optional(S.Boolean),
    VpcConfig: S.optional(VpcConfig),
  }),
).annotate({ identifier: "NetworkConfig" }) as any as S.Schema<NetworkConfig>;
export interface MonitoringJobDefinition {
  BaselineConfig?: MonitoringBaselineConfig;
  MonitoringInputs?: MonitoringInput[];
  MonitoringOutputConfig?: MonitoringOutputConfig;
  MonitoringResources?: MonitoringResources;
  MonitoringAppSpecification?: MonitoringAppSpecification;
  StoppingCondition?: MonitoringStoppingCondition;
  Environment?: { [key: string]: string | undefined };
  NetworkConfig?: NetworkConfig;
  RoleArn?: string;
}
export const MonitoringJobDefinition = S.suspend(() =>
  S.Struct({
    BaselineConfig: S.optional(MonitoringBaselineConfig),
    MonitoringInputs: S.optional(MonitoringInputs),
    MonitoringOutputConfig: S.optional(MonitoringOutputConfig),
    MonitoringResources: S.optional(MonitoringResources),
    MonitoringAppSpecification: S.optional(MonitoringAppSpecification),
    StoppingCondition: S.optional(MonitoringStoppingCondition),
    Environment: S.optional(MonitoringEnvironmentMap),
    NetworkConfig: S.optional(NetworkConfig),
    RoleArn: S.optional(S.String),
  }),
).annotate({
  identifier: "MonitoringJobDefinition",
}) as any as S.Schema<MonitoringJobDefinition>;
export type MonitoringType =
  | "DataQuality"
  | "ModelQuality"
  | "ModelBias"
  | "ModelExplainability"
  | (string & {});
export const MonitoringType = S.String;
export interface MonitoringScheduleConfig {
  ScheduleConfig?: ScheduleConfig;
  MonitoringJobDefinition?: MonitoringJobDefinition;
  MonitoringJobDefinitionName?: string;
  MonitoringType?: MonitoringType;
}
export const MonitoringScheduleConfig = S.suspend(() =>
  S.Struct({
    ScheduleConfig: S.optional(ScheduleConfig),
    MonitoringJobDefinition: S.optional(MonitoringJobDefinition),
    MonitoringJobDefinitionName: S.optional(S.String),
    MonitoringType: S.optional(MonitoringType),
  }),
).annotate({
  identifier: "MonitoringScheduleConfig",
}) as any as S.Schema<MonitoringScheduleConfig>;
export interface CreateMonitoringScheduleRequest {
  MonitoringScheduleName?: string;
  MonitoringScheduleConfig?: MonitoringScheduleConfig;
  Tags?: Tag[];
}
export const CreateMonitoringScheduleRequest = S.suspend(() =>
  S.Struct({
    MonitoringScheduleName: S.optional(S.String),
    MonitoringScheduleConfig: S.optional(MonitoringScheduleConfig),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateMonitoringScheduleRequest",
}) as any as S.Schema<CreateMonitoringScheduleRequest>;
export interface CreateMonitoringScheduleResponse {
  MonitoringScheduleArn: string;
}
export const CreateMonitoringScheduleResponse = S.suspend(() =>
  S.Struct({ MonitoringScheduleArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateMonitoringScheduleResponse",
}) as any as S.Schema<CreateMonitoringScheduleResponse>;
export type DirectInternetAccess = "Enabled" | "Disabled" | (string & {});
export const DirectInternetAccess = S.String;
export type NotebookInstanceAcceleratorType =
  | "ml.eia1.medium"
  | "ml.eia1.large"
  | "ml.eia1.xlarge"
  | "ml.eia2.medium"
  | "ml.eia2.large"
  | "ml.eia2.xlarge"
  | (string & {});
export const NotebookInstanceAcceleratorType = S.String;
export type NotebookInstanceAcceleratorTypes =
  NotebookInstanceAcceleratorType[];
export const NotebookInstanceAcceleratorTypes = S.Array(
  NotebookInstanceAcceleratorType,
);
export type AdditionalCodeRepositoryNamesOrUrls = string[];
export const AdditionalCodeRepositoryNamesOrUrls = S.Array(S.String);
export type RootAccess = "Enabled" | "Disabled" | (string & {});
export const RootAccess = S.String;
export interface InstanceMetadataServiceConfiguration {
  MinimumInstanceMetadataServiceVersion?: string;
}
export const InstanceMetadataServiceConfiguration = S.suspend(() =>
  S.Struct({ MinimumInstanceMetadataServiceVersion: S.optional(S.String) }),
).annotate({
  identifier: "InstanceMetadataServiceConfiguration",
}) as any as S.Schema<InstanceMetadataServiceConfiguration>;
export interface CreateNotebookInstanceInput {
  NotebookInstanceName?: string;
  InstanceType?: InstanceType;
  SubnetId?: string;
  SecurityGroupIds?: string[];
  IpAddressType?: IPAddressType;
  RoleArn?: string;
  KmsKeyId?: string;
  Tags?: Tag[];
  LifecycleConfigName?: string;
  DirectInternetAccess?: DirectInternetAccess;
  VolumeSizeInGB?: number;
  AcceleratorTypes?: NotebookInstanceAcceleratorType[];
  DefaultCodeRepository?: string;
  AdditionalCodeRepositories?: string[];
  RootAccess?: RootAccess;
  PlatformIdentifier?: string;
  InstanceMetadataServiceConfiguration?: InstanceMetadataServiceConfiguration;
}
export const CreateNotebookInstanceInput = S.suspend(() =>
  S.Struct({
    NotebookInstanceName: S.optional(S.String),
    InstanceType: S.optional(InstanceType),
    SubnetId: S.optional(S.String),
    SecurityGroupIds: S.optional(SecurityGroupIds),
    IpAddressType: S.optional(IPAddressType),
    RoleArn: S.optional(S.String),
    KmsKeyId: S.optional(S.String),
    Tags: S.optional(TagList),
    LifecycleConfigName: S.optional(S.String),
    DirectInternetAccess: S.optional(DirectInternetAccess),
    VolumeSizeInGB: S.optional(S.Number),
    AcceleratorTypes: S.optional(NotebookInstanceAcceleratorTypes),
    DefaultCodeRepository: S.optional(S.String),
    AdditionalCodeRepositories: S.optional(AdditionalCodeRepositoryNamesOrUrls),
    RootAccess: S.optional(RootAccess),
    PlatformIdentifier: S.optional(S.String),
    InstanceMetadataServiceConfiguration: S.optional(
      InstanceMetadataServiceConfiguration,
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateNotebookInstanceInput",
}) as any as S.Schema<CreateNotebookInstanceInput>;
export interface CreateNotebookInstanceOutput {
  NotebookInstanceArn?: string;
}
export const CreateNotebookInstanceOutput = S.suspend(() =>
  S.Struct({ NotebookInstanceArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateNotebookInstanceOutput",
}) as any as S.Schema<CreateNotebookInstanceOutput>;
export interface NotebookInstanceLifecycleHook {
  Content?: string;
}
export const NotebookInstanceLifecycleHook = S.suspend(() =>
  S.Struct({ Content: S.optional(S.String) }),
).annotate({
  identifier: "NotebookInstanceLifecycleHook",
}) as any as S.Schema<NotebookInstanceLifecycleHook>;
export type NotebookInstanceLifecycleConfigList =
  NotebookInstanceLifecycleHook[];
export const NotebookInstanceLifecycleConfigList = S.Array(
  NotebookInstanceLifecycleHook,
);
export interface CreateNotebookInstanceLifecycleConfigInput {
  NotebookInstanceLifecycleConfigName?: string;
  OnCreate?: NotebookInstanceLifecycleHook[];
  OnStart?: NotebookInstanceLifecycleHook[];
  Tags?: Tag[];
}
export const CreateNotebookInstanceLifecycleConfigInput = S.suspend(() =>
  S.Struct({
    NotebookInstanceLifecycleConfigName: S.optional(S.String),
    OnCreate: S.optional(NotebookInstanceLifecycleConfigList),
    OnStart: S.optional(NotebookInstanceLifecycleConfigList),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateNotebookInstanceLifecycleConfigInput",
}) as any as S.Schema<CreateNotebookInstanceLifecycleConfigInput>;
export interface CreateNotebookInstanceLifecycleConfigOutput {
  NotebookInstanceLifecycleConfigArn?: string;
}
export const CreateNotebookInstanceLifecycleConfigOutput = S.suspend(() =>
  S.Struct({ NotebookInstanceLifecycleConfigArn: S.optional(S.String) }).pipe(
    ns,
  ),
).annotate({
  identifier: "CreateNotebookInstanceLifecycleConfigOutput",
}) as any as S.Schema<CreateNotebookInstanceLifecycleConfigOutput>;
export interface OptimizationModelAccessConfig {
  AcceptEula?: boolean;
}
export const OptimizationModelAccessConfig = S.suspend(() =>
  S.Struct({ AcceptEula: S.optional(S.Boolean) }),
).annotate({
  identifier: "OptimizationModelAccessConfig",
}) as any as S.Schema<OptimizationModelAccessConfig>;
export interface OptimizationJobModelSourceS3 {
  S3Uri?: string;
  ModelAccessConfig?: OptimizationModelAccessConfig;
}
export const OptimizationJobModelSourceS3 = S.suspend(() =>
  S.Struct({
    S3Uri: S.optional(S.String),
    ModelAccessConfig: S.optional(OptimizationModelAccessConfig),
  }),
).annotate({
  identifier: "OptimizationJobModelSourceS3",
}) as any as S.Schema<OptimizationJobModelSourceS3>;
export interface OptimizationSageMakerModel {
  ModelName?: string;
}
export const OptimizationSageMakerModel = S.suspend(() =>
  S.Struct({ ModelName: S.optional(S.String) }),
).annotate({
  identifier: "OptimizationSageMakerModel",
}) as any as S.Schema<OptimizationSageMakerModel>;
export interface OptimizationJobModelSource {
  S3?: OptimizationJobModelSourceS3;
  SageMakerModel?: OptimizationSageMakerModel;
}
export const OptimizationJobModelSource = S.suspend(() =>
  S.Struct({
    S3: S.optional(OptimizationJobModelSourceS3),
    SageMakerModel: S.optional(OptimizationSageMakerModel),
  }),
).annotate({
  identifier: "OptimizationJobModelSource",
}) as any as S.Schema<OptimizationJobModelSource>;
export type OptimizationJobDeploymentInstanceType =
  | "ml.p4d.24xlarge"
  | "ml.p4de.24xlarge"
  | "ml.p5.48xlarge"
  | "ml.p5e.48xlarge"
  | "ml.p5en.48xlarge"
  | "ml.g5.xlarge"
  | "ml.g5.2xlarge"
  | "ml.g5.4xlarge"
  | "ml.g5.8xlarge"
  | "ml.g5.12xlarge"
  | "ml.g5.16xlarge"
  | "ml.g5.24xlarge"
  | "ml.g5.48xlarge"
  | "ml.g6.xlarge"
  | "ml.g6.2xlarge"
  | "ml.g6.4xlarge"
  | "ml.g6.8xlarge"
  | "ml.g6.12xlarge"
  | "ml.g6.16xlarge"
  | "ml.g6.24xlarge"
  | "ml.g6.48xlarge"
  | "ml.g6e.xlarge"
  | "ml.g6e.2xlarge"
  | "ml.g6e.4xlarge"
  | "ml.g6e.8xlarge"
  | "ml.g6e.12xlarge"
  | "ml.g6e.16xlarge"
  | "ml.g6e.24xlarge"
  | "ml.g6e.48xlarge"
  | "ml.inf2.xlarge"
  | "ml.inf2.8xlarge"
  | "ml.inf2.24xlarge"
  | "ml.inf2.48xlarge"
  | "ml.trn1.2xlarge"
  | "ml.trn1.32xlarge"
  | "ml.trn1n.32xlarge"
  | (string & {});
export const OptimizationJobDeploymentInstanceType = S.String;
export type OptimizationJobEnvironmentVariables = {
  [key: string]: string | undefined;
};
export const OptimizationJobEnvironmentVariables = S.Record(
  S.String,
  S.String.pipe(S.optional),
);
export interface ModelQuantizationConfig {
  Image?: string;
  OverrideEnvironment?: { [key: string]: string | undefined };
}
export const ModelQuantizationConfig = S.suspend(() =>
  S.Struct({
    Image: S.optional(S.String),
    OverrideEnvironment: S.optional(OptimizationJobEnvironmentVariables),
  }),
).annotate({
  identifier: "ModelQuantizationConfig",
}) as any as S.Schema<ModelQuantizationConfig>;
export interface ModelCompilationConfig {
  Image?: string;
  OverrideEnvironment?: { [key: string]: string | undefined };
}
export const ModelCompilationConfig = S.suspend(() =>
  S.Struct({
    Image: S.optional(S.String),
    OverrideEnvironment: S.optional(OptimizationJobEnvironmentVariables),
  }),
).annotate({
  identifier: "ModelCompilationConfig",
}) as any as S.Schema<ModelCompilationConfig>;
export interface ModelShardingConfig {
  Image?: string;
  OverrideEnvironment?: { [key: string]: string | undefined };
}
export const ModelShardingConfig = S.suspend(() =>
  S.Struct({
    Image: S.optional(S.String),
    OverrideEnvironment: S.optional(OptimizationJobEnvironmentVariables),
  }),
).annotate({
  identifier: "ModelShardingConfig",
}) as any as S.Schema<ModelShardingConfig>;
export type ModelSpeculativeDecodingTechnique = "EAGLE" | (string & {});
export const ModelSpeculativeDecodingTechnique = S.String;
export type ModelSpeculativeDecodingS3DataType =
  | "S3Prefix"
  | "ManifestFile"
  | (string & {});
export const ModelSpeculativeDecodingS3DataType = S.String;
export interface ModelSpeculativeDecodingTrainingDataSource {
  S3Uri?: string;
  S3DataType?: ModelSpeculativeDecodingS3DataType;
}
export const ModelSpeculativeDecodingTrainingDataSource = S.suspend(() =>
  S.Struct({
    S3Uri: S.optional(S.String),
    S3DataType: S.optional(ModelSpeculativeDecodingS3DataType),
  }),
).annotate({
  identifier: "ModelSpeculativeDecodingTrainingDataSource",
}) as any as S.Schema<ModelSpeculativeDecodingTrainingDataSource>;
export interface ModelSpeculativeDecodingConfig {
  Technique?: ModelSpeculativeDecodingTechnique;
  TrainingDataSource?: ModelSpeculativeDecodingTrainingDataSource;
}
export const ModelSpeculativeDecodingConfig = S.suspend(() =>
  S.Struct({
    Technique: S.optional(ModelSpeculativeDecodingTechnique),
    TrainingDataSource: S.optional(ModelSpeculativeDecodingTrainingDataSource),
  }),
).annotate({
  identifier: "ModelSpeculativeDecodingConfig",
}) as any as S.Schema<ModelSpeculativeDecodingConfig>;
export type OptimizationConfig =
  | {
      ModelQuantizationConfig: ModelQuantizationConfig;
      ModelCompilationConfig?: never;
      ModelShardingConfig?: never;
      ModelSpeculativeDecodingConfig?: never;
    }
  | {
      ModelQuantizationConfig?: never;
      ModelCompilationConfig: ModelCompilationConfig;
      ModelShardingConfig?: never;
      ModelSpeculativeDecodingConfig?: never;
    }
  | {
      ModelQuantizationConfig?: never;
      ModelCompilationConfig?: never;
      ModelShardingConfig: ModelShardingConfig;
      ModelSpeculativeDecodingConfig?: never;
    }
  | {
      ModelQuantizationConfig?: never;
      ModelCompilationConfig?: never;
      ModelShardingConfig?: never;
      ModelSpeculativeDecodingConfig: ModelSpeculativeDecodingConfig;
    };
export const OptimizationConfig = S.Union([
  S.Struct({ ModelQuantizationConfig: ModelQuantizationConfig }),
  S.Struct({ ModelCompilationConfig: ModelCompilationConfig }),
  S.Struct({ ModelShardingConfig: ModelShardingConfig }),
  S.Struct({ ModelSpeculativeDecodingConfig: ModelSpeculativeDecodingConfig }),
]);
export type OptimizationConfigs = OptimizationConfig[];
export const OptimizationConfigs = S.Array(OptimizationConfig);
export interface OptimizationJobOutputConfig {
  KmsKeyId?: string;
  S3OutputLocation?: string;
  SageMakerModel?: OptimizationSageMakerModel;
}
export const OptimizationJobOutputConfig = S.suspend(() =>
  S.Struct({
    KmsKeyId: S.optional(S.String),
    S3OutputLocation: S.optional(S.String),
    SageMakerModel: S.optional(OptimizationSageMakerModel),
  }),
).annotate({
  identifier: "OptimizationJobOutputConfig",
}) as any as S.Schema<OptimizationJobOutputConfig>;
export type OptimizationVpcSecurityGroupIds = string[];
export const OptimizationVpcSecurityGroupIds = S.Array(S.String);
export type OptimizationVpcSubnets = string[];
export const OptimizationVpcSubnets = S.Array(S.String);
export interface OptimizationVpcConfig {
  SecurityGroupIds?: string[];
  Subnets?: string[];
}
export const OptimizationVpcConfig = S.suspend(() =>
  S.Struct({
    SecurityGroupIds: S.optional(OptimizationVpcSecurityGroupIds),
    Subnets: S.optional(OptimizationVpcSubnets),
  }),
).annotate({
  identifier: "OptimizationVpcConfig",
}) as any as S.Schema<OptimizationVpcConfig>;
export interface CreateOptimizationJobRequest {
  OptimizationJobName?: string;
  RoleArn?: string;
  ModelSource?: OptimizationJobModelSource;
  DeploymentInstanceType?: OptimizationJobDeploymentInstanceType;
  MaxInstanceCount?: number;
  OptimizationEnvironment?: { [key: string]: string | undefined };
  OptimizationConfigs?: OptimizationConfig[];
  OutputConfig?: OptimizationJobOutputConfig;
  StoppingCondition?: StoppingCondition;
  Tags?: Tag[];
  VpcConfig?: OptimizationVpcConfig;
}
export const CreateOptimizationJobRequest = S.suspend(() =>
  S.Struct({
    OptimizationJobName: S.optional(S.String),
    RoleArn: S.optional(S.String),
    ModelSource: S.optional(OptimizationJobModelSource),
    DeploymentInstanceType: S.optional(OptimizationJobDeploymentInstanceType),
    MaxInstanceCount: S.optional(S.Number),
    OptimizationEnvironment: S.optional(OptimizationJobEnvironmentVariables),
    OptimizationConfigs: S.optional(OptimizationConfigs),
    OutputConfig: S.optional(OptimizationJobOutputConfig),
    StoppingCondition: S.optional(StoppingCondition),
    Tags: S.optional(TagList),
    VpcConfig: S.optional(OptimizationVpcConfig),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateOptimizationJobRequest",
}) as any as S.Schema<CreateOptimizationJobRequest>;
export interface CreateOptimizationJobResponse {
  OptimizationJobArn: string;
}
export const CreateOptimizationJobResponse = S.suspend(() =>
  S.Struct({ OptimizationJobArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateOptimizationJobResponse",
}) as any as S.Schema<CreateOptimizationJobResponse>;
export type PartnerAppType =
  | "lakera-guard"
  | "comet"
  | "deepchecks-llm-evaluation"
  | "fiddler"
  | (string & {});
export const PartnerAppType = S.String;
export interface PartnerAppMaintenanceConfig {
  MaintenanceWindowStart?: string;
}
export const PartnerAppMaintenanceConfig = S.suspend(() =>
  S.Struct({ MaintenanceWindowStart: S.optional(S.String) }),
).annotate({
  identifier: "PartnerAppMaintenanceConfig",
}) as any as S.Schema<PartnerAppMaintenanceConfig>;
export type PartnerAppAdminUserList = string[];
export const PartnerAppAdminUserList = S.Array(S.String);
export type PartnerAppArguments = { [key: string]: string | undefined };
export const PartnerAppArguments = S.Record(
  S.String,
  S.String.pipe(S.optional),
);
export type AssignedGroupPatternsList = string[];
export const AssignedGroupPatternsList = S.Array(S.String);
export type GroupPatternsList = string[];
export const GroupPatternsList = S.Array(S.String);
export interface RoleGroupAssignment {
  RoleName: string;
  GroupPatterns: string[];
}
export const RoleGroupAssignment = S.suspend(() =>
  S.Struct({ RoleName: S.String, GroupPatterns: GroupPatternsList }),
).annotate({
  identifier: "RoleGroupAssignment",
}) as any as S.Schema<RoleGroupAssignment>;
export type RoleGroupAssignmentsList = RoleGroupAssignment[];
export const RoleGroupAssignmentsList = S.Array(RoleGroupAssignment);
export interface PartnerAppConfig {
  AdminUsers?: string[];
  Arguments?: { [key: string]: string | undefined };
  AssignedGroupPatterns?: string[];
  RoleGroupAssignments?: RoleGroupAssignment[];
}
export const PartnerAppConfig = S.suspend(() =>
  S.Struct({
    AdminUsers: S.optional(PartnerAppAdminUserList),
    Arguments: S.optional(PartnerAppArguments),
    AssignedGroupPatterns: S.optional(AssignedGroupPatternsList),
    RoleGroupAssignments: S.optional(RoleGroupAssignmentsList),
  }),
).annotate({
  identifier: "PartnerAppConfig",
}) as any as S.Schema<PartnerAppConfig>;
export type PartnerAppAuthType = "IAM" | (string & {});
export const PartnerAppAuthType = S.String;
export interface CreatePartnerAppRequest {
  Name?: string;
  Type?: PartnerAppType;
  ExecutionRoleArn?: string;
  KmsKeyId?: string;
  MaintenanceConfig?: PartnerAppMaintenanceConfig;
  Tier?: string;
  ApplicationConfig?: PartnerAppConfig;
  AuthType?: PartnerAppAuthType;
  EnableIamSessionBasedIdentity?: boolean;
  EnableAutoMinorVersionUpgrade?: boolean;
  ClientToken?: string;
  Tags?: Tag[];
}
export const CreatePartnerAppRequest = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Type: S.optional(PartnerAppType),
    ExecutionRoleArn: S.optional(S.String),
    KmsKeyId: S.optional(S.String),
    MaintenanceConfig: S.optional(PartnerAppMaintenanceConfig),
    Tier: S.optional(S.String),
    ApplicationConfig: S.optional(PartnerAppConfig),
    AuthType: S.optional(PartnerAppAuthType),
    EnableIamSessionBasedIdentity: S.optional(S.Boolean),
    EnableAutoMinorVersionUpgrade: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreatePartnerAppRequest",
}) as any as S.Schema<CreatePartnerAppRequest>;
export interface CreatePartnerAppResponse {
  Arn?: string;
}
export const CreatePartnerAppResponse = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreatePartnerAppResponse",
}) as any as S.Schema<CreatePartnerAppResponse>;
export interface CreatePartnerAppPresignedUrlRequest {
  Arn?: string;
  ExpiresInSeconds?: number;
  SessionExpirationDurationInSeconds?: number;
}
export const CreatePartnerAppPresignedUrlRequest = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    ExpiresInSeconds: S.optional(S.Number),
    SessionExpirationDurationInSeconds: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreatePartnerAppPresignedUrlRequest",
}) as any as S.Schema<CreatePartnerAppPresignedUrlRequest>;
export interface CreatePartnerAppPresignedUrlResponse {
  Url?: string;
}
export const CreatePartnerAppPresignedUrlResponse = S.suspend(() =>
  S.Struct({ Url: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreatePartnerAppPresignedUrlResponse",
}) as any as S.Schema<CreatePartnerAppPresignedUrlResponse>;
export interface PipelineDefinitionS3Location {
  Bucket?: string;
  ObjectKey?: string;
  VersionId?: string;
}
export const PipelineDefinitionS3Location = S.suspend(() =>
  S.Struct({
    Bucket: S.optional(S.String),
    ObjectKey: S.optional(S.String),
    VersionId: S.optional(S.String),
  }),
).annotate({
  identifier: "PipelineDefinitionS3Location",
}) as any as S.Schema<PipelineDefinitionS3Location>;
export interface ParallelismConfiguration {
  MaxParallelExecutionSteps?: number;
}
export const ParallelismConfiguration = S.suspend(() =>
  S.Struct({ MaxParallelExecutionSteps: S.optional(S.Number) }),
).annotate({
  identifier: "ParallelismConfiguration",
}) as any as S.Schema<ParallelismConfiguration>;
export interface CreatePipelineRequest {
  PipelineName?: string;
  PipelineDisplayName?: string;
  PipelineDefinition?: string;
  PipelineDefinitionS3Location?: PipelineDefinitionS3Location;
  PipelineDescription?: string;
  ClientRequestToken?: string;
  RoleArn?: string;
  Tags?: Tag[];
  ParallelismConfiguration?: ParallelismConfiguration;
}
export const CreatePipelineRequest = S.suspend(() =>
  S.Struct({
    PipelineName: S.optional(S.String),
    PipelineDisplayName: S.optional(S.String),
    PipelineDefinition: S.optional(S.String),
    PipelineDefinitionS3Location: S.optional(PipelineDefinitionS3Location),
    PipelineDescription: S.optional(S.String),
    ClientRequestToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    RoleArn: S.optional(S.String),
    Tags: S.optional(TagList),
    ParallelismConfiguration: S.optional(ParallelismConfiguration),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreatePipelineRequest",
}) as any as S.Schema<CreatePipelineRequest>;
export interface CreatePipelineResponse {
  PipelineArn?: string;
}
export const CreatePipelineResponse = S.suspend(() =>
  S.Struct({ PipelineArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreatePipelineResponse",
}) as any as S.Schema<CreatePipelineResponse>;
export interface CreatePresignedDomainUrlRequest {
  DomainId?: string;
  UserProfileName?: string;
  SessionExpirationDurationInSeconds?: number;
  ExpiresInSeconds?: number;
  SpaceName?: string;
  LandingUri?: string;
}
export const CreatePresignedDomainUrlRequest = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    UserProfileName: S.optional(S.String),
    SessionExpirationDurationInSeconds: S.optional(S.Number),
    ExpiresInSeconds: S.optional(S.Number),
    SpaceName: S.optional(S.String),
    LandingUri: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreatePresignedDomainUrlRequest",
}) as any as S.Schema<CreatePresignedDomainUrlRequest>;
export interface CreatePresignedDomainUrlResponse {
  AuthorizedUrl?: string;
}
export const CreatePresignedDomainUrlResponse = S.suspend(() =>
  S.Struct({ AuthorizedUrl: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreatePresignedDomainUrlResponse",
}) as any as S.Schema<CreatePresignedDomainUrlResponse>;
export interface CreatePresignedMlflowAppUrlRequest {
  Arn?: string;
  ExpiresInSeconds?: number;
  SessionExpirationDurationInSeconds?: number;
}
export const CreatePresignedMlflowAppUrlRequest = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    ExpiresInSeconds: S.optional(S.Number),
    SessionExpirationDurationInSeconds: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreatePresignedMlflowAppUrlRequest",
}) as any as S.Schema<CreatePresignedMlflowAppUrlRequest>;
export interface CreatePresignedMlflowAppUrlResponse {
  AuthorizedUrl?: string;
}
export const CreatePresignedMlflowAppUrlResponse = S.suspend(() =>
  S.Struct({ AuthorizedUrl: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreatePresignedMlflowAppUrlResponse",
}) as any as S.Schema<CreatePresignedMlflowAppUrlResponse>;
export interface CreatePresignedMlflowTrackingServerUrlRequest {
  TrackingServerName?: string;
  ExpiresInSeconds?: number;
  SessionExpirationDurationInSeconds?: number;
}
export const CreatePresignedMlflowTrackingServerUrlRequest = S.suspend(() =>
  S.Struct({
    TrackingServerName: S.optional(S.String),
    ExpiresInSeconds: S.optional(S.Number),
    SessionExpirationDurationInSeconds: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreatePresignedMlflowTrackingServerUrlRequest",
}) as any as S.Schema<CreatePresignedMlflowTrackingServerUrlRequest>;
export interface CreatePresignedMlflowTrackingServerUrlResponse {
  AuthorizedUrl?: string;
}
export const CreatePresignedMlflowTrackingServerUrlResponse = S.suspend(() =>
  S.Struct({ AuthorizedUrl: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreatePresignedMlflowTrackingServerUrlResponse",
}) as any as S.Schema<CreatePresignedMlflowTrackingServerUrlResponse>;
export interface CreatePresignedNotebookInstanceUrlInput {
  NotebookInstanceName?: string;
  SessionExpirationDurationInSeconds?: number;
}
export const CreatePresignedNotebookInstanceUrlInput = S.suspend(() =>
  S.Struct({
    NotebookInstanceName: S.optional(S.String),
    SessionExpirationDurationInSeconds: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreatePresignedNotebookInstanceUrlInput",
}) as any as S.Schema<CreatePresignedNotebookInstanceUrlInput>;
export interface CreatePresignedNotebookInstanceUrlOutput {
  AuthorizedUrl?: string;
}
export const CreatePresignedNotebookInstanceUrlOutput = S.suspend(() =>
  S.Struct({ AuthorizedUrl: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreatePresignedNotebookInstanceUrlOutput",
}) as any as S.Schema<CreatePresignedNotebookInstanceUrlOutput>;
export type ProcessingS3DataType = "ManifestFile" | "S3Prefix" | (string & {});
export const ProcessingS3DataType = S.String;
export type ProcessingS3CompressionType = "None" | "Gzip" | (string & {});
export const ProcessingS3CompressionType = S.String;
export interface ProcessingS3Input {
  S3Uri?: string;
  LocalPath?: string;
  S3DataType?: ProcessingS3DataType;
  S3InputMode?: ProcessingS3InputMode;
  S3DataDistributionType?: ProcessingS3DataDistributionType;
  S3CompressionType?: ProcessingS3CompressionType;
}
export const ProcessingS3Input = S.suspend(() =>
  S.Struct({
    S3Uri: S.optional(S.String),
    LocalPath: S.optional(S.String),
    S3DataType: S.optional(ProcessingS3DataType),
    S3InputMode: S.optional(ProcessingS3InputMode),
    S3DataDistributionType: S.optional(ProcessingS3DataDistributionType),
    S3CompressionType: S.optional(ProcessingS3CompressionType),
  }),
).annotate({
  identifier: "ProcessingS3Input",
}) as any as S.Schema<ProcessingS3Input>;
export type AthenaResultFormat =
  | "PARQUET"
  | "ORC"
  | "AVRO"
  | "JSON"
  | "TEXTFILE"
  | (string & {});
export const AthenaResultFormat = S.String;
export type AthenaResultCompressionType =
  | "GZIP"
  | "SNAPPY"
  | "ZLIB"
  | (string & {});
export const AthenaResultCompressionType = S.String;
export interface AthenaDatasetDefinition {
  Catalog?: string;
  Database?: string;
  QueryString?: string;
  WorkGroup?: string;
  OutputS3Uri?: string;
  KmsKeyId?: string;
  OutputFormat?: AthenaResultFormat;
  OutputCompression?: AthenaResultCompressionType;
}
export const AthenaDatasetDefinition = S.suspend(() =>
  S.Struct({
    Catalog: S.optional(S.String),
    Database: S.optional(S.String),
    QueryString: S.optional(S.String),
    WorkGroup: S.optional(S.String),
    OutputS3Uri: S.optional(S.String),
    KmsKeyId: S.optional(S.String),
    OutputFormat: S.optional(AthenaResultFormat),
    OutputCompression: S.optional(AthenaResultCompressionType),
  }),
).annotate({
  identifier: "AthenaDatasetDefinition",
}) as any as S.Schema<AthenaDatasetDefinition>;
export type RedshiftResultFormat = "PARQUET" | "CSV" | (string & {});
export const RedshiftResultFormat = S.String;
export type RedshiftResultCompressionType =
  | "None"
  | "GZIP"
  | "BZIP2"
  | "ZSTD"
  | "SNAPPY"
  | (string & {});
export const RedshiftResultCompressionType = S.String;
export interface RedshiftDatasetDefinition {
  ClusterId?: string;
  Database?: string;
  DbUser?: string;
  QueryString?: string;
  ClusterRoleArn?: string;
  OutputS3Uri?: string;
  KmsKeyId?: string;
  OutputFormat?: RedshiftResultFormat;
  OutputCompression?: RedshiftResultCompressionType;
}
export const RedshiftDatasetDefinition = S.suspend(() =>
  S.Struct({
    ClusterId: S.optional(S.String),
    Database: S.optional(S.String),
    DbUser: S.optional(S.String),
    QueryString: S.optional(S.String),
    ClusterRoleArn: S.optional(S.String),
    OutputS3Uri: S.optional(S.String),
    KmsKeyId: S.optional(S.String),
    OutputFormat: S.optional(RedshiftResultFormat),
    OutputCompression: S.optional(RedshiftResultCompressionType),
  }),
).annotate({
  identifier: "RedshiftDatasetDefinition",
}) as any as S.Schema<RedshiftDatasetDefinition>;
export type DataDistributionType =
  | "FullyReplicated"
  | "ShardedByS3Key"
  | (string & {});
export const DataDistributionType = S.String;
export type InputMode = "Pipe" | "File" | (string & {});
export const InputMode = S.String;
export interface DatasetDefinition {
  AthenaDatasetDefinition?: AthenaDatasetDefinition;
  RedshiftDatasetDefinition?: RedshiftDatasetDefinition;
  LocalPath?: string;
  DataDistributionType?: DataDistributionType;
  InputMode?: InputMode;
}
export const DatasetDefinition = S.suspend(() =>
  S.Struct({
    AthenaDatasetDefinition: S.optional(AthenaDatasetDefinition),
    RedshiftDatasetDefinition: S.optional(RedshiftDatasetDefinition),
    LocalPath: S.optional(S.String),
    DataDistributionType: S.optional(DataDistributionType),
    InputMode: S.optional(InputMode),
  }),
).annotate({
  identifier: "DatasetDefinition",
}) as any as S.Schema<DatasetDefinition>;
export interface ProcessingInput {
  InputName?: string;
  AppManaged?: boolean;
  S3Input?: ProcessingS3Input;
  DatasetDefinition?: DatasetDefinition;
}
export const ProcessingInput = S.suspend(() =>
  S.Struct({
    InputName: S.optional(S.String),
    AppManaged: S.optional(S.Boolean),
    S3Input: S.optional(ProcessingS3Input),
    DatasetDefinition: S.optional(DatasetDefinition),
  }),
).annotate({
  identifier: "ProcessingInput",
}) as any as S.Schema<ProcessingInput>;
export type ProcessingInputs = ProcessingInput[];
export const ProcessingInputs = S.Array(ProcessingInput);
export interface ProcessingS3Output {
  S3Uri?: string;
  LocalPath?: string;
  S3UploadMode?: ProcessingS3UploadMode;
}
export const ProcessingS3Output = S.suspend(() =>
  S.Struct({
    S3Uri: S.optional(S.String),
    LocalPath: S.optional(S.String),
    S3UploadMode: S.optional(ProcessingS3UploadMode),
  }),
).annotate({
  identifier: "ProcessingS3Output",
}) as any as S.Schema<ProcessingS3Output>;
export interface ProcessingFeatureStoreOutput {
  FeatureGroupName?: string;
}
export const ProcessingFeatureStoreOutput = S.suspend(() =>
  S.Struct({ FeatureGroupName: S.optional(S.String) }),
).annotate({
  identifier: "ProcessingFeatureStoreOutput",
}) as any as S.Schema<ProcessingFeatureStoreOutput>;
export interface ProcessingOutput {
  OutputName?: string;
  S3Output?: ProcessingS3Output;
  FeatureStoreOutput?: ProcessingFeatureStoreOutput;
  AppManaged?: boolean;
}
export const ProcessingOutput = S.suspend(() =>
  S.Struct({
    OutputName: S.optional(S.String),
    S3Output: S.optional(ProcessingS3Output),
    FeatureStoreOutput: S.optional(ProcessingFeatureStoreOutput),
    AppManaged: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "ProcessingOutput",
}) as any as S.Schema<ProcessingOutput>;
export type ProcessingOutputs = ProcessingOutput[];
export const ProcessingOutputs = S.Array(ProcessingOutput);
export interface ProcessingOutputConfig {
  Outputs?: ProcessingOutput[];
  KmsKeyId?: string;
}
export const ProcessingOutputConfig = S.suspend(() =>
  S.Struct({
    Outputs: S.optional(ProcessingOutputs),
    KmsKeyId: S.optional(S.String),
  }),
).annotate({
  identifier: "ProcessingOutputConfig",
}) as any as S.Schema<ProcessingOutputConfig>;
export interface ProcessingClusterConfig {
  InstanceCount?: number;
  InstanceType?: ProcessingInstanceType;
  VolumeSizeInGB?: number;
  VolumeKmsKeyId?: string;
}
export const ProcessingClusterConfig = S.suspend(() =>
  S.Struct({
    InstanceCount: S.optional(S.Number),
    InstanceType: S.optional(ProcessingInstanceType),
    VolumeSizeInGB: S.optional(S.Number),
    VolumeKmsKeyId: S.optional(S.String),
  }),
).annotate({
  identifier: "ProcessingClusterConfig",
}) as any as S.Schema<ProcessingClusterConfig>;
export interface ProcessingResources {
  ClusterConfig?: ProcessingClusterConfig;
}
export const ProcessingResources = S.suspend(() =>
  S.Struct({ ClusterConfig: S.optional(ProcessingClusterConfig) }),
).annotate({
  identifier: "ProcessingResources",
}) as any as S.Schema<ProcessingResources>;
export interface ProcessingStoppingCondition {
  MaxRuntimeInSeconds?: number;
}
export const ProcessingStoppingCondition = S.suspend(() =>
  S.Struct({ MaxRuntimeInSeconds: S.optional(S.Number) }),
).annotate({
  identifier: "ProcessingStoppingCondition",
}) as any as S.Schema<ProcessingStoppingCondition>;
export type ContainerArguments = string[];
export const ContainerArguments = S.Array(S.String);
export interface AppSpecification {
  ImageUri?: string;
  ContainerEntrypoint?: string[];
  ContainerArguments?: string[];
}
export const AppSpecification = S.suspend(() =>
  S.Struct({
    ImageUri: S.optional(S.String),
    ContainerEntrypoint: S.optional(ContainerEntrypoint),
    ContainerArguments: S.optional(ContainerArguments),
  }),
).annotate({
  identifier: "AppSpecification",
}) as any as S.Schema<AppSpecification>;
export type ProcessingEnvironmentMap = { [key: string]: string | undefined };
export const ProcessingEnvironmentMap = S.Record(
  S.String,
  S.String.pipe(S.optional),
);
export interface ExperimentConfig {
  ExperimentName?: string;
  TrialName?: string;
  TrialComponentDisplayName?: string;
  RunName?: string;
}
export const ExperimentConfig = S.suspend(() =>
  S.Struct({
    ExperimentName: S.optional(S.String),
    TrialName: S.optional(S.String),
    TrialComponentDisplayName: S.optional(S.String),
    RunName: S.optional(S.String),
  }),
).annotate({
  identifier: "ExperimentConfig",
}) as any as S.Schema<ExperimentConfig>;
export interface CreateProcessingJobRequest {
  ProcessingInputs?: ProcessingInput[];
  ProcessingOutputConfig?: ProcessingOutputConfig;
  ProcessingJobName?: string;
  ProcessingResources?: ProcessingResources;
  StoppingCondition?: ProcessingStoppingCondition;
  AppSpecification?: AppSpecification;
  Environment?: { [key: string]: string | undefined };
  NetworkConfig?: NetworkConfig;
  RoleArn?: string;
  Tags?: Tag[];
  ExperimentConfig?: ExperimentConfig;
}
export const CreateProcessingJobRequest = S.suspend(() =>
  S.Struct({
    ProcessingInputs: S.optional(ProcessingInputs),
    ProcessingOutputConfig: S.optional(ProcessingOutputConfig),
    ProcessingJobName: S.optional(S.String),
    ProcessingResources: S.optional(ProcessingResources),
    StoppingCondition: S.optional(ProcessingStoppingCondition),
    AppSpecification: S.optional(AppSpecification),
    Environment: S.optional(ProcessingEnvironmentMap),
    NetworkConfig: S.optional(NetworkConfig),
    RoleArn: S.optional(S.String),
    Tags: S.optional(TagList),
    ExperimentConfig: S.optional(ExperimentConfig),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateProcessingJobRequest",
}) as any as S.Schema<CreateProcessingJobRequest>;
export interface CreateProcessingJobResponse {
  ProcessingJobArn: string;
}
export const CreateProcessingJobResponse = S.suspend(() =>
  S.Struct({ ProcessingJobArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateProcessingJobResponse",
}) as any as S.Schema<CreateProcessingJobResponse>;
export interface ProvisioningParameter {
  Key?: string;
  Value?: string;
}
export const ProvisioningParameter = S.suspend(() =>
  S.Struct({ Key: S.optional(S.String), Value: S.optional(S.String) }),
).annotate({
  identifier: "ProvisioningParameter",
}) as any as S.Schema<ProvisioningParameter>;
export type ProvisioningParameters = ProvisioningParameter[];
export const ProvisioningParameters = S.Array(ProvisioningParameter);
export interface ServiceCatalogProvisioningDetails {
  ProductId?: string;
  ProvisioningArtifactId?: string;
  PathId?: string;
  ProvisioningParameters?: ProvisioningParameter[];
}
export const ServiceCatalogProvisioningDetails = S.suspend(() =>
  S.Struct({
    ProductId: S.optional(S.String),
    ProvisioningArtifactId: S.optional(S.String),
    PathId: S.optional(S.String),
    ProvisioningParameters: S.optional(ProvisioningParameters),
  }),
).annotate({
  identifier: "ServiceCatalogProvisioningDetails",
}) as any as S.Schema<ServiceCatalogProvisioningDetails>;
export interface CfnStackCreateParameter {
  Key?: string;
  Value?: string;
}
export const CfnStackCreateParameter = S.suspend(() =>
  S.Struct({ Key: S.optional(S.String), Value: S.optional(S.String) }),
).annotate({
  identifier: "CfnStackCreateParameter",
}) as any as S.Schema<CfnStackCreateParameter>;
export type CfnStackCreateParameters = CfnStackCreateParameter[];
export const CfnStackCreateParameters = S.Array(CfnStackCreateParameter);
export interface CfnCreateTemplateProvider {
  TemplateName?: string;
  TemplateURL?: string;
  RoleARN?: string;
  Parameters?: CfnStackCreateParameter[];
}
export const CfnCreateTemplateProvider = S.suspend(() =>
  S.Struct({
    TemplateName: S.optional(S.String),
    TemplateURL: S.optional(S.String),
    RoleARN: S.optional(S.String),
    Parameters: S.optional(CfnStackCreateParameters),
  }),
).annotate({
  identifier: "CfnCreateTemplateProvider",
}) as any as S.Schema<CfnCreateTemplateProvider>;
export interface CreateTemplateProvider {
  CfnTemplateProvider?: CfnCreateTemplateProvider;
}
export const CreateTemplateProvider = S.suspend(() =>
  S.Struct({ CfnTemplateProvider: S.optional(CfnCreateTemplateProvider) }),
).annotate({
  identifier: "CreateTemplateProvider",
}) as any as S.Schema<CreateTemplateProvider>;
export type CreateTemplateProviderList = CreateTemplateProvider[];
export const CreateTemplateProviderList = S.Array(CreateTemplateProvider);
export interface CreateProjectInput {
  ProjectName?: string;
  ProjectDescription?: string;
  ServiceCatalogProvisioningDetails?: ServiceCatalogProvisioningDetails;
  Tags?: Tag[];
  TemplateProviders?: CreateTemplateProvider[];
}
export const CreateProjectInput = S.suspend(() =>
  S.Struct({
    ProjectName: S.optional(S.String),
    ProjectDescription: S.optional(S.String),
    ServiceCatalogProvisioningDetails: S.optional(
      ServiceCatalogProvisioningDetails,
    ),
    Tags: S.optional(TagList),
    TemplateProviders: S.optional(CreateTemplateProviderList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateProjectInput",
}) as any as S.Schema<CreateProjectInput>;
export interface CreateProjectOutput {
  ProjectArn: string;
  ProjectId: string;
}
export const CreateProjectOutput = S.suspend(() =>
  S.Struct({
    ProjectArn: S.optional(S.String),
    ProjectId: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "CreateProjectOutput",
}) as any as S.Schema<CreateProjectOutput>;
export interface SpaceIdleSettings {
  IdleTimeoutInMinutes?: number;
}
export const SpaceIdleSettings = S.suspend(() =>
  S.Struct({ IdleTimeoutInMinutes: S.optional(S.Number) }),
).annotate({
  identifier: "SpaceIdleSettings",
}) as any as S.Schema<SpaceIdleSettings>;
export interface SpaceAppLifecycleManagement {
  IdleSettings?: SpaceIdleSettings;
}
export const SpaceAppLifecycleManagement = S.suspend(() =>
  S.Struct({ IdleSettings: S.optional(SpaceIdleSettings) }),
).annotate({
  identifier: "SpaceAppLifecycleManagement",
}) as any as S.Schema<SpaceAppLifecycleManagement>;
export interface SpaceCodeEditorAppSettings {
  DefaultResourceSpec?: ResourceSpec;
  AppLifecycleManagement?: SpaceAppLifecycleManagement;
}
export const SpaceCodeEditorAppSettings = S.suspend(() =>
  S.Struct({
    DefaultResourceSpec: S.optional(ResourceSpec),
    AppLifecycleManagement: S.optional(SpaceAppLifecycleManagement),
  }),
).annotate({
  identifier: "SpaceCodeEditorAppSettings",
}) as any as S.Schema<SpaceCodeEditorAppSettings>;
export interface SpaceJupyterLabAppSettings {
  DefaultResourceSpec?: ResourceSpec;
  CodeRepositories?: CodeRepository[];
  AppLifecycleManagement?: SpaceAppLifecycleManagement;
}
export const SpaceJupyterLabAppSettings = S.suspend(() =>
  S.Struct({
    DefaultResourceSpec: S.optional(ResourceSpec),
    CodeRepositories: S.optional(CodeRepositories),
    AppLifecycleManagement: S.optional(SpaceAppLifecycleManagement),
  }),
).annotate({
  identifier: "SpaceJupyterLabAppSettings",
}) as any as S.Schema<SpaceJupyterLabAppSettings>;
export interface EbsStorageSettings {
  EbsVolumeSizeInGb?: number;
}
export const EbsStorageSettings = S.suspend(() =>
  S.Struct({ EbsVolumeSizeInGb: S.optional(S.Number) }),
).annotate({
  identifier: "EbsStorageSettings",
}) as any as S.Schema<EbsStorageSettings>;
export interface SpaceStorageSettings {
  EbsStorageSettings?: EbsStorageSettings;
}
export const SpaceStorageSettings = S.suspend(() =>
  S.Struct({ EbsStorageSettings: S.optional(EbsStorageSettings) }),
).annotate({
  identifier: "SpaceStorageSettings",
}) as any as S.Schema<SpaceStorageSettings>;
export interface EFSFileSystem {
  FileSystemId?: string;
}
export const EFSFileSystem = S.suspend(() =>
  S.Struct({ FileSystemId: S.optional(S.String) }),
).annotate({ identifier: "EFSFileSystem" }) as any as S.Schema<EFSFileSystem>;
export interface FSxLustreFileSystem {
  FileSystemId?: string;
}
export const FSxLustreFileSystem = S.suspend(() =>
  S.Struct({ FileSystemId: S.optional(S.String) }),
).annotate({
  identifier: "FSxLustreFileSystem",
}) as any as S.Schema<FSxLustreFileSystem>;
export interface S3FileSystem {
  S3Uri?: string;
}
export const S3FileSystem = S.suspend(() =>
  S.Struct({ S3Uri: S.optional(S.String) }),
).annotate({ identifier: "S3FileSystem" }) as any as S.Schema<S3FileSystem>;
export type CustomFileSystem =
  | {
      EFSFileSystem: EFSFileSystem;
      FSxLustreFileSystem?: never;
      S3FileSystem?: never;
    }
  | {
      EFSFileSystem?: never;
      FSxLustreFileSystem: FSxLustreFileSystem;
      S3FileSystem?: never;
    }
  | {
      EFSFileSystem?: never;
      FSxLustreFileSystem?: never;
      S3FileSystem: S3FileSystem;
    };
export const CustomFileSystem = S.Union([
  S.Struct({ EFSFileSystem: EFSFileSystem }),
  S.Struct({ FSxLustreFileSystem: FSxLustreFileSystem }),
  S.Struct({ S3FileSystem: S3FileSystem }),
]);
export type CustomFileSystems = CustomFileSystem[];
export const CustomFileSystems = S.Array(CustomFileSystem);
export interface SpaceSettings {
  JupyterServerAppSettings?: JupyterServerAppSettings;
  KernelGatewayAppSettings?: KernelGatewayAppSettings;
  CodeEditorAppSettings?: SpaceCodeEditorAppSettings;
  JupyterLabAppSettings?: SpaceJupyterLabAppSettings;
  AppType?: AppType;
  SpaceStorageSettings?: SpaceStorageSettings;
  SpaceManagedResources?: FeatureStatus;
  CustomFileSystems?: CustomFileSystem[];
  RemoteAccess?: FeatureStatus;
}
export const SpaceSettings = S.suspend(() =>
  S.Struct({
    JupyterServerAppSettings: S.optional(JupyterServerAppSettings),
    KernelGatewayAppSettings: S.optional(KernelGatewayAppSettings),
    CodeEditorAppSettings: S.optional(SpaceCodeEditorAppSettings),
    JupyterLabAppSettings: S.optional(SpaceJupyterLabAppSettings),
    AppType: S.optional(AppType),
    SpaceStorageSettings: S.optional(SpaceStorageSettings),
    SpaceManagedResources: S.optional(FeatureStatus),
    CustomFileSystems: S.optional(CustomFileSystems),
    RemoteAccess: S.optional(FeatureStatus),
  }),
).annotate({ identifier: "SpaceSettings" }) as any as S.Schema<SpaceSettings>;
export interface OwnershipSettings {
  OwnerUserProfileName?: string;
}
export const OwnershipSettings = S.suspend(() =>
  S.Struct({ OwnerUserProfileName: S.optional(S.String) }),
).annotate({
  identifier: "OwnershipSettings",
}) as any as S.Schema<OwnershipSettings>;
export type SharingType = "Private" | "Shared" | (string & {});
export const SharingType = S.String;
export interface SpaceSharingSettings {
  SharingType?: SharingType;
}
export const SpaceSharingSettings = S.suspend(() =>
  S.Struct({ SharingType: S.optional(SharingType) }),
).annotate({
  identifier: "SpaceSharingSettings",
}) as any as S.Schema<SpaceSharingSettings>;
export interface CreateSpaceRequest {
  DomainId?: string;
  SpaceName?: string;
  Tags?: Tag[];
  SpaceSettings?: SpaceSettings;
  OwnershipSettings?: OwnershipSettings;
  SpaceSharingSettings?: SpaceSharingSettings;
  SpaceDisplayName?: string;
}
export const CreateSpaceRequest = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    SpaceName: S.optional(S.String),
    Tags: S.optional(TagList),
    SpaceSettings: S.optional(SpaceSettings),
    OwnershipSettings: S.optional(OwnershipSettings),
    SpaceSharingSettings: S.optional(SpaceSharingSettings),
    SpaceDisplayName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateSpaceRequest",
}) as any as S.Schema<CreateSpaceRequest>;
export interface CreateSpaceResponse {
  SpaceArn?: string;
}
export const CreateSpaceResponse = S.suspend(() =>
  S.Struct({ SpaceArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateSpaceResponse",
}) as any as S.Schema<CreateSpaceResponse>;
export type StudioLifecycleConfigAppType =
  | "JupyterServer"
  | "KernelGateway"
  | "CodeEditor"
  | "JupyterLab"
  | (string & {});
export const StudioLifecycleConfigAppType = S.String;
export interface CreateStudioLifecycleConfigRequest {
  StudioLifecycleConfigName?: string;
  StudioLifecycleConfigContent?: string;
  StudioLifecycleConfigAppType?: StudioLifecycleConfigAppType;
  Tags?: Tag[];
}
export const CreateStudioLifecycleConfigRequest = S.suspend(() =>
  S.Struct({
    StudioLifecycleConfigName: S.optional(S.String),
    StudioLifecycleConfigContent: S.optional(S.String),
    StudioLifecycleConfigAppType: S.optional(StudioLifecycleConfigAppType),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateStudioLifecycleConfigRequest",
}) as any as S.Schema<CreateStudioLifecycleConfigRequest>;
export interface CreateStudioLifecycleConfigResponse {
  StudioLifecycleConfigArn?: string;
}
export const CreateStudioLifecycleConfigResponse = S.suspend(() =>
  S.Struct({ StudioLifecycleConfigArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateStudioLifecycleConfigResponse",
}) as any as S.Schema<CreateStudioLifecycleConfigResponse>;
export type TrainingContainerEntrypoint = string[];
export const TrainingContainerEntrypoint = S.Array(S.String);
export type TrainingContainerArguments = string[];
export const TrainingContainerArguments = S.Array(S.String);
export type TrainingRepositoryAccessMode = "Platform" | "Vpc" | (string & {});
export const TrainingRepositoryAccessMode = S.String;
export interface TrainingRepositoryAuthConfig {
  TrainingRepositoryCredentialsProviderArn?: string;
}
export const TrainingRepositoryAuthConfig = S.suspend(() =>
  S.Struct({ TrainingRepositoryCredentialsProviderArn: S.optional(S.String) }),
).annotate({
  identifier: "TrainingRepositoryAuthConfig",
}) as any as S.Schema<TrainingRepositoryAuthConfig>;
export interface TrainingImageConfig {
  TrainingRepositoryAccessMode?: TrainingRepositoryAccessMode;
  TrainingRepositoryAuthConfig?: TrainingRepositoryAuthConfig;
}
export const TrainingImageConfig = S.suspend(() =>
  S.Struct({
    TrainingRepositoryAccessMode: S.optional(TrainingRepositoryAccessMode),
    TrainingRepositoryAuthConfig: S.optional(TrainingRepositoryAuthConfig),
  }),
).annotate({
  identifier: "TrainingImageConfig",
}) as any as S.Schema<TrainingImageConfig>;
export interface AlgorithmSpecification {
  TrainingImage?: string;
  AlgorithmName?: string;
  TrainingInputMode?: TrainingInputMode;
  MetricDefinitions?: MetricDefinition[];
  EnableSageMakerMetricsTimeSeries?: boolean;
  ContainerEntrypoint?: string[];
  ContainerArguments?: string[];
  TrainingImageConfig?: TrainingImageConfig;
}
export const AlgorithmSpecification = S.suspend(() =>
  S.Struct({
    TrainingImage: S.optional(S.String),
    AlgorithmName: S.optional(S.String),
    TrainingInputMode: S.optional(TrainingInputMode),
    MetricDefinitions: S.optional(MetricDefinitionList),
    EnableSageMakerMetricsTimeSeries: S.optional(S.Boolean),
    ContainerEntrypoint: S.optional(TrainingContainerEntrypoint),
    ContainerArguments: S.optional(TrainingContainerArguments),
    TrainingImageConfig: S.optional(TrainingImageConfig),
  }),
).annotate({
  identifier: "AlgorithmSpecification",
}) as any as S.Schema<AlgorithmSpecification>;
export type HookParameters = { [key: string]: string | undefined };
export const HookParameters = S.Record(S.String, S.String.pipe(S.optional));
export type CollectionParameters = { [key: string]: string | undefined };
export const CollectionParameters = S.Record(
  S.String,
  S.String.pipe(S.optional),
);
export interface CollectionConfiguration {
  CollectionName?: string;
  CollectionParameters?: { [key: string]: string | undefined };
}
export const CollectionConfiguration = S.suspend(() =>
  S.Struct({
    CollectionName: S.optional(S.String),
    CollectionParameters: S.optional(CollectionParameters),
  }),
).annotate({
  identifier: "CollectionConfiguration",
}) as any as S.Schema<CollectionConfiguration>;
export type CollectionConfigurations = CollectionConfiguration[];
export const CollectionConfigurations = S.Array(CollectionConfiguration);
export interface DebugHookConfig {
  LocalPath?: string;
  S3OutputPath?: string;
  HookParameters?: { [key: string]: string | undefined };
  CollectionConfigurations?: CollectionConfiguration[];
}
export const DebugHookConfig = S.suspend(() =>
  S.Struct({
    LocalPath: S.optional(S.String),
    S3OutputPath: S.optional(S.String),
    HookParameters: S.optional(HookParameters),
    CollectionConfigurations: S.optional(CollectionConfigurations),
  }),
).annotate({
  identifier: "DebugHookConfig",
}) as any as S.Schema<DebugHookConfig>;
export type RuleParameters = { [key: string]: string | undefined };
export const RuleParameters = S.Record(S.String, S.String.pipe(S.optional));
export interface DebugRuleConfiguration {
  RuleConfigurationName?: string;
  LocalPath?: string;
  S3OutputPath?: string;
  RuleEvaluatorImage?: string;
  InstanceType?: ProcessingInstanceType;
  VolumeSizeInGB?: number;
  RuleParameters?: { [key: string]: string | undefined };
}
export const DebugRuleConfiguration = S.suspend(() =>
  S.Struct({
    RuleConfigurationName: S.optional(S.String),
    LocalPath: S.optional(S.String),
    S3OutputPath: S.optional(S.String),
    RuleEvaluatorImage: S.optional(S.String),
    InstanceType: S.optional(ProcessingInstanceType),
    VolumeSizeInGB: S.optional(S.Number),
    RuleParameters: S.optional(RuleParameters),
  }),
).annotate({
  identifier: "DebugRuleConfiguration",
}) as any as S.Schema<DebugRuleConfiguration>;
export type DebugRuleConfigurations = DebugRuleConfiguration[];
export const DebugRuleConfigurations = S.Array(DebugRuleConfiguration);
export interface TensorBoardOutputConfig {
  LocalPath?: string;
  S3OutputPath?: string;
}
export const TensorBoardOutputConfig = S.suspend(() =>
  S.Struct({
    LocalPath: S.optional(S.String),
    S3OutputPath: S.optional(S.String),
  }),
).annotate({
  identifier: "TensorBoardOutputConfig",
}) as any as S.Schema<TensorBoardOutputConfig>;
export type ProfilingParameters = { [key: string]: string | undefined };
export const ProfilingParameters = S.Record(
  S.String,
  S.String.pipe(S.optional),
);
export interface ProfilerConfig {
  S3OutputPath?: string;
  ProfilingIntervalInMilliseconds?: number;
  ProfilingParameters?: { [key: string]: string | undefined };
  DisableProfiler?: boolean;
}
export const ProfilerConfig = S.suspend(() =>
  S.Struct({
    S3OutputPath: S.optional(S.String),
    ProfilingIntervalInMilliseconds: S.optional(S.Number),
    ProfilingParameters: S.optional(ProfilingParameters),
    DisableProfiler: S.optional(S.Boolean),
  }),
).annotate({ identifier: "ProfilerConfig" }) as any as S.Schema<ProfilerConfig>;
export interface ProfilerRuleConfiguration {
  RuleConfigurationName?: string;
  LocalPath?: string;
  S3OutputPath?: string;
  RuleEvaluatorImage?: string;
  InstanceType?: ProcessingInstanceType;
  VolumeSizeInGB?: number;
  RuleParameters?: { [key: string]: string | undefined };
}
export const ProfilerRuleConfiguration = S.suspend(() =>
  S.Struct({
    RuleConfigurationName: S.optional(S.String),
    LocalPath: S.optional(S.String),
    S3OutputPath: S.optional(S.String),
    RuleEvaluatorImage: S.optional(S.String),
    InstanceType: S.optional(ProcessingInstanceType),
    VolumeSizeInGB: S.optional(S.Number),
    RuleParameters: S.optional(RuleParameters),
  }),
).annotate({
  identifier: "ProfilerRuleConfiguration",
}) as any as S.Schema<ProfilerRuleConfiguration>;
export type ProfilerRuleConfigurations = ProfilerRuleConfiguration[];
export const ProfilerRuleConfigurations = S.Array(ProfilerRuleConfiguration);
export type TrainingEnvironmentMap = { [key: string]: string | undefined };
export const TrainingEnvironmentMap = S.Record(
  S.String,
  S.String.pipe(S.optional),
);
export interface RemoteDebugConfig {
  EnableRemoteDebug?: boolean;
}
export const RemoteDebugConfig = S.suspend(() =>
  S.Struct({ EnableRemoteDebug: S.optional(S.Boolean) }),
).annotate({
  identifier: "RemoteDebugConfig",
}) as any as S.Schema<RemoteDebugConfig>;
export interface InfraCheckConfig {
  EnableInfraCheck?: boolean;
}
export const InfraCheckConfig = S.suspend(() =>
  S.Struct({ EnableInfraCheck: S.optional(S.Boolean) }),
).annotate({
  identifier: "InfraCheckConfig",
}) as any as S.Schema<InfraCheckConfig>;
export interface SessionChainingConfig {
  EnableSessionTagChaining?: boolean;
}
export const SessionChainingConfig = S.suspend(() =>
  S.Struct({ EnableSessionTagChaining: S.optional(S.Boolean) }),
).annotate({
  identifier: "SessionChainingConfig",
}) as any as S.Schema<SessionChainingConfig>;
export type ServerlessJobType = "FineTuning" | "Evaluation" | (string & {});
export const ServerlessJobType = S.String;
export type CustomizationTechnique =
  | "SFT"
  | "DPO"
  | "RLVR"
  | "RLAIF"
  | (string & {});
export const CustomizationTechnique = S.String;
export type Peft = "LORA" | (string & {});
export const Peft = S.String;
export type EvaluationType =
  | "LLMAJEvaluation"
  | "CustomScorerEvaluation"
  | "BenchmarkEvaluation"
  | (string & {});
export const EvaluationType = S.String;
export interface ServerlessJobConfig {
  BaseModelArn: string;
  AcceptEula?: boolean;
  JobType: ServerlessJobType;
  CustomizationTechnique?: CustomizationTechnique;
  Peft?: Peft;
  EvaluationType?: EvaluationType;
  EvaluatorArn?: string;
}
export const ServerlessJobConfig = S.suspend(() =>
  S.Struct({
    BaseModelArn: S.String,
    AcceptEula: S.optional(S.Boolean),
    JobType: ServerlessJobType,
    CustomizationTechnique: S.optional(CustomizationTechnique),
    Peft: S.optional(Peft),
    EvaluationType: S.optional(EvaluationType),
    EvaluatorArn: S.optional(S.String),
  }),
).annotate({
  identifier: "ServerlessJobConfig",
}) as any as S.Schema<ServerlessJobConfig>;
export interface MlflowConfig {
  MlflowResourceArn: string;
  MlflowExperimentName?: string;
  MlflowRunName?: string;
}
export const MlflowConfig = S.suspend(() =>
  S.Struct({
    MlflowResourceArn: S.String,
    MlflowExperimentName: S.optional(S.String),
    MlflowRunName: S.optional(S.String),
  }),
).annotate({ identifier: "MlflowConfig" }) as any as S.Schema<MlflowConfig>;
export interface ModelPackageConfig {
  ModelPackageGroupArn: string;
  SourceModelPackageArn?: string;
}
export const ModelPackageConfig = S.suspend(() =>
  S.Struct({
    ModelPackageGroupArn: S.String,
    SourceModelPackageArn: S.optional(S.String),
  }),
).annotate({
  identifier: "ModelPackageConfig",
}) as any as S.Schema<ModelPackageConfig>;
export interface CreateTrainingJobRequest {
  TrainingJobName?: string;
  HyperParameters?: { [key: string]: string | undefined };
  AlgorithmSpecification?: AlgorithmSpecification;
  RoleArn?: string;
  InputDataConfig?: Channel[];
  OutputDataConfig?: OutputDataConfig;
  ResourceConfig?: ResourceConfig;
  VpcConfig?: VpcConfig;
  StoppingCondition?: StoppingCondition;
  Tags?: Tag[];
  EnableNetworkIsolation?: boolean;
  EnableInterContainerTrafficEncryption?: boolean;
  EnableManagedSpotTraining?: boolean;
  CheckpointConfig?: CheckpointConfig;
  DebugHookConfig?: DebugHookConfig;
  DebugRuleConfigurations?: DebugRuleConfiguration[];
  TensorBoardOutputConfig?: TensorBoardOutputConfig;
  ExperimentConfig?: ExperimentConfig;
  ProfilerConfig?: ProfilerConfig;
  ProfilerRuleConfigurations?: ProfilerRuleConfiguration[];
  Environment?: { [key: string]: string | undefined };
  RetryStrategy?: RetryStrategy;
  RemoteDebugConfig?: RemoteDebugConfig;
  InfraCheckConfig?: InfraCheckConfig;
  SessionChainingConfig?: SessionChainingConfig;
  ServerlessJobConfig?: ServerlessJobConfig;
  MlflowConfig?: MlflowConfig;
  ModelPackageConfig?: ModelPackageConfig;
}
export const CreateTrainingJobRequest = S.suspend(() =>
  S.Struct({
    TrainingJobName: S.optional(S.String),
    HyperParameters: S.optional(HyperParameters),
    AlgorithmSpecification: S.optional(AlgorithmSpecification),
    RoleArn: S.optional(S.String),
    InputDataConfig: S.optional(InputDataConfig),
    OutputDataConfig: S.optional(OutputDataConfig),
    ResourceConfig: S.optional(ResourceConfig),
    VpcConfig: S.optional(VpcConfig),
    StoppingCondition: S.optional(StoppingCondition),
    Tags: S.optional(TagList),
    EnableNetworkIsolation: S.optional(S.Boolean),
    EnableInterContainerTrafficEncryption: S.optional(S.Boolean),
    EnableManagedSpotTraining: S.optional(S.Boolean),
    CheckpointConfig: S.optional(CheckpointConfig),
    DebugHookConfig: S.optional(DebugHookConfig),
    DebugRuleConfigurations: S.optional(DebugRuleConfigurations),
    TensorBoardOutputConfig: S.optional(TensorBoardOutputConfig),
    ExperimentConfig: S.optional(ExperimentConfig),
    ProfilerConfig: S.optional(ProfilerConfig),
    ProfilerRuleConfigurations: S.optional(ProfilerRuleConfigurations),
    Environment: S.optional(TrainingEnvironmentMap),
    RetryStrategy: S.optional(RetryStrategy),
    RemoteDebugConfig: S.optional(RemoteDebugConfig),
    InfraCheckConfig: S.optional(InfraCheckConfig),
    SessionChainingConfig: S.optional(SessionChainingConfig),
    ServerlessJobConfig: S.optional(ServerlessJobConfig),
    MlflowConfig: S.optional(MlflowConfig),
    ModelPackageConfig: S.optional(ModelPackageConfig),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTrainingJobRequest",
}) as any as S.Schema<CreateTrainingJobRequest>;
export interface CreateTrainingJobResponse {
  TrainingJobArn: string;
}
export const CreateTrainingJobResponse = S.suspend(() =>
  S.Struct({ TrainingJobArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateTrainingJobResponse",
}) as any as S.Schema<CreateTrainingJobResponse>;
export interface CreateTrainingPlanRequest {
  TrainingPlanName?: string;
  TrainingPlanOfferingId?: string;
  SpareInstanceCountPerUltraServer?: number;
  Tags?: Tag[];
}
export const CreateTrainingPlanRequest = S.suspend(() =>
  S.Struct({
    TrainingPlanName: S.optional(S.String),
    TrainingPlanOfferingId: S.optional(S.String),
    SpareInstanceCountPerUltraServer: S.optional(S.Number),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTrainingPlanRequest",
}) as any as S.Schema<CreateTrainingPlanRequest>;
export interface CreateTrainingPlanResponse {
  TrainingPlanArn: string;
}
export const CreateTrainingPlanResponse = S.suspend(() =>
  S.Struct({ TrainingPlanArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateTrainingPlanResponse",
}) as any as S.Schema<CreateTrainingPlanResponse>;
export interface ModelClientConfig {
  InvocationsTimeoutInSeconds?: number;
  InvocationsMaxRetries?: number;
}
export const ModelClientConfig = S.suspend(() =>
  S.Struct({
    InvocationsTimeoutInSeconds: S.optional(S.Number),
    InvocationsMaxRetries: S.optional(S.Number),
  }),
).annotate({
  identifier: "ModelClientConfig",
}) as any as S.Schema<ModelClientConfig>;
export interface BatchDataCaptureConfig {
  DestinationS3Uri?: string;
  KmsKeyId?: string;
  GenerateInferenceId?: boolean;
}
export const BatchDataCaptureConfig = S.suspend(() =>
  S.Struct({
    DestinationS3Uri: S.optional(S.String),
    KmsKeyId: S.optional(S.String),
    GenerateInferenceId: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "BatchDataCaptureConfig",
}) as any as S.Schema<BatchDataCaptureConfig>;
export type JoinSource = "Input" | "None" | (string & {});
export const JoinSource = S.String;
export interface DataProcessing {
  InputFilter?: string;
  OutputFilter?: string;
  JoinSource?: JoinSource;
}
export const DataProcessing = S.suspend(() =>
  S.Struct({
    InputFilter: S.optional(S.String),
    OutputFilter: S.optional(S.String),
    JoinSource: S.optional(JoinSource),
  }),
).annotate({ identifier: "DataProcessing" }) as any as S.Schema<DataProcessing>;
export interface CreateTransformJobRequest {
  TransformJobName?: string;
  ModelName?: string;
  MaxConcurrentTransforms?: number;
  ModelClientConfig?: ModelClientConfig;
  MaxPayloadInMB?: number;
  BatchStrategy?: BatchStrategy;
  Environment?: { [key: string]: string | undefined };
  TransformInput?: TransformInput;
  TransformOutput?: TransformOutput;
  DataCaptureConfig?: BatchDataCaptureConfig;
  TransformResources?: TransformResources;
  DataProcessing?: DataProcessing;
  Tags?: Tag[];
  ExperimentConfig?: ExperimentConfig;
}
export const CreateTransformJobRequest = S.suspend(() =>
  S.Struct({
    TransformJobName: S.optional(S.String),
    ModelName: S.optional(S.String),
    MaxConcurrentTransforms: S.optional(S.Number),
    ModelClientConfig: S.optional(ModelClientConfig),
    MaxPayloadInMB: S.optional(S.Number),
    BatchStrategy: S.optional(BatchStrategy),
    Environment: S.optional(TransformEnvironmentMap),
    TransformInput: S.optional(TransformInput),
    TransformOutput: S.optional(TransformOutput),
    DataCaptureConfig: S.optional(BatchDataCaptureConfig),
    TransformResources: S.optional(TransformResources),
    DataProcessing: S.optional(DataProcessing),
    Tags: S.optional(TagList),
    ExperimentConfig: S.optional(ExperimentConfig),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTransformJobRequest",
}) as any as S.Schema<CreateTransformJobRequest>;
export interface CreateTransformJobResponse {
  TransformJobArn: string;
}
export const CreateTransformJobResponse = S.suspend(() =>
  S.Struct({ TransformJobArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateTransformJobResponse",
}) as any as S.Schema<CreateTransformJobResponse>;
export interface CreateTrialRequest {
  TrialName?: string;
  DisplayName?: string;
  ExperimentName?: string;
  MetadataProperties?: MetadataProperties;
  Tags?: Tag[];
}
export const CreateTrialRequest = S.suspend(() =>
  S.Struct({
    TrialName: S.optional(S.String),
    DisplayName: S.optional(S.String),
    ExperimentName: S.optional(S.String),
    MetadataProperties: S.optional(MetadataProperties),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTrialRequest",
}) as any as S.Schema<CreateTrialRequest>;
export interface CreateTrialResponse {
  TrialArn?: string;
}
export const CreateTrialResponse = S.suspend(() =>
  S.Struct({ TrialArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateTrialResponse",
}) as any as S.Schema<CreateTrialResponse>;
export type TrialComponentPrimaryStatus =
  | "InProgress"
  | "Completed"
  | "Failed"
  | "Stopping"
  | "Stopped"
  | (string & {});
export const TrialComponentPrimaryStatus = S.String;
export interface TrialComponentStatus {
  PrimaryStatus?: TrialComponentPrimaryStatus;
  Message?: string;
}
export const TrialComponentStatus = S.suspend(() =>
  S.Struct({
    PrimaryStatus: S.optional(TrialComponentPrimaryStatus),
    Message: S.optional(S.String),
  }),
).annotate({
  identifier: "TrialComponentStatus",
}) as any as S.Schema<TrialComponentStatus>;
export type TrialComponentParameterValue =
  | { StringValue: string; NumberValue?: never }
  | { StringValue?: never; NumberValue: number };
export const TrialComponentParameterValue = S.Union([
  S.Struct({ StringValue: S.String }),
  S.Struct({ NumberValue: S.Number }),
]);
export type TrialComponentParameters = {
  [key: string]: TrialComponentParameterValue | undefined;
};
export const TrialComponentParameters = S.Record(
  S.String,
  TrialComponentParameterValue.pipe(S.optional),
);
export interface TrialComponentArtifact {
  MediaType?: string;
  Value?: string;
}
export const TrialComponentArtifact = S.suspend(() =>
  S.Struct({ MediaType: S.optional(S.String), Value: S.optional(S.String) }),
).annotate({
  identifier: "TrialComponentArtifact",
}) as any as S.Schema<TrialComponentArtifact>;
export type TrialComponentArtifacts = {
  [key: string]: TrialComponentArtifact | undefined;
};
export const TrialComponentArtifacts = S.Record(
  S.String,
  TrialComponentArtifact.pipe(S.optional),
);
export interface CreateTrialComponentRequest {
  TrialComponentName?: string;
  DisplayName?: string;
  Status?: TrialComponentStatus;
  StartTime?: Date;
  EndTime?: Date;
  Parameters?: { [key: string]: TrialComponentParameterValue | undefined };
  InputArtifacts?: { [key: string]: TrialComponentArtifact | undefined };
  OutputArtifacts?: { [key: string]: TrialComponentArtifact | undefined };
  MetadataProperties?: MetadataProperties;
  Tags?: Tag[];
}
export const CreateTrialComponentRequest = S.suspend(() =>
  S.Struct({
    TrialComponentName: S.optional(S.String),
    DisplayName: S.optional(S.String),
    Status: S.optional(TrialComponentStatus),
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Parameters: S.optional(TrialComponentParameters),
    InputArtifacts: S.optional(TrialComponentArtifacts),
    OutputArtifacts: S.optional(TrialComponentArtifacts),
    MetadataProperties: S.optional(MetadataProperties),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTrialComponentRequest",
}) as any as S.Schema<CreateTrialComponentRequest>;
export interface CreateTrialComponentResponse {
  TrialComponentArn?: string;
}
export const CreateTrialComponentResponse = S.suspend(() =>
  S.Struct({ TrialComponentArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateTrialComponentResponse",
}) as any as S.Schema<CreateTrialComponentResponse>;
export interface CreateUserProfileRequest {
  DomainId?: string;
  UserProfileName?: string;
  SingleSignOnUserIdentifier?: string;
  SingleSignOnUserValue?: string;
  Tags?: Tag[];
  UserSettings?: UserSettings;
}
export const CreateUserProfileRequest = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    UserProfileName: S.optional(S.String),
    SingleSignOnUserIdentifier: S.optional(S.String),
    SingleSignOnUserValue: S.optional(S.String),
    Tags: S.optional(TagList),
    UserSettings: S.optional(UserSettings),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateUserProfileRequest",
}) as any as S.Schema<CreateUserProfileRequest>;
export interface CreateUserProfileResponse {
  UserProfileArn?: string;
}
export const CreateUserProfileResponse = S.suspend(() =>
  S.Struct({ UserProfileArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateUserProfileResponse",
}) as any as S.Schema<CreateUserProfileResponse>;
export interface CognitoConfig {
  UserPool?: string;
  ClientId?: string;
}
export const CognitoConfig = S.suspend(() =>
  S.Struct({ UserPool: S.optional(S.String), ClientId: S.optional(S.String) }),
).annotate({ identifier: "CognitoConfig" }) as any as S.Schema<CognitoConfig>;
export type AuthenticationRequestExtraParams = {
  [key: string]: string | undefined;
};
export const AuthenticationRequestExtraParams = S.Record(
  S.String,
  S.String.pipe(S.optional),
);
export interface OidcConfig {
  ClientId?: string;
  ClientSecret?: string | redacted.Redacted<string>;
  Issuer?: string;
  AuthorizationEndpoint?: string;
  TokenEndpoint?: string;
  UserInfoEndpoint?: string;
  LogoutEndpoint?: string;
  JwksUri?: string;
  Scope?: string;
  AuthenticationRequestExtraParams?: { [key: string]: string | undefined };
}
export const OidcConfig = S.suspend(() =>
  S.Struct({
    ClientId: S.optional(S.String),
    ClientSecret: S.optional(SensitiveString),
    Issuer: S.optional(S.String),
    AuthorizationEndpoint: S.optional(S.String),
    TokenEndpoint: S.optional(S.String),
    UserInfoEndpoint: S.optional(S.String),
    LogoutEndpoint: S.optional(S.String),
    JwksUri: S.optional(S.String),
    Scope: S.optional(S.String),
    AuthenticationRequestExtraParams: S.optional(
      AuthenticationRequestExtraParams,
    ),
  }),
).annotate({ identifier: "OidcConfig" }) as any as S.Schema<OidcConfig>;
export type Cidrs = string[];
export const Cidrs = S.Array(S.String);
export interface SourceIpConfig {
  Cidrs?: string[];
}
export const SourceIpConfig = S.suspend(() =>
  S.Struct({ Cidrs: S.optional(Cidrs) }),
).annotate({ identifier: "SourceIpConfig" }) as any as S.Schema<SourceIpConfig>;
export type WorkforceSecurityGroupIds = string[];
export const WorkforceSecurityGroupIds = S.Array(S.String);
export type WorkforceSubnets = string[];
export const WorkforceSubnets = S.Array(S.String);
export interface WorkforceVpcConfigRequest {
  VpcId?: string;
  SecurityGroupIds?: string[];
  Subnets?: string[];
}
export const WorkforceVpcConfigRequest = S.suspend(() =>
  S.Struct({
    VpcId: S.optional(S.String),
    SecurityGroupIds: S.optional(WorkforceSecurityGroupIds),
    Subnets: S.optional(WorkforceSubnets),
  }),
).annotate({
  identifier: "WorkforceVpcConfigRequest",
}) as any as S.Schema<WorkforceVpcConfigRequest>;
export type WorkforceIpAddressType = "ipv4" | "dualstack" | (string & {});
export const WorkforceIpAddressType = S.String;
export interface CreateWorkforceRequest {
  CognitoConfig?: CognitoConfig;
  OidcConfig?: OidcConfig;
  SourceIpConfig?: SourceIpConfig;
  WorkforceName?: string;
  Tags?: Tag[];
  WorkforceVpcConfig?: WorkforceVpcConfigRequest;
  IpAddressType?: WorkforceIpAddressType;
}
export const CreateWorkforceRequest = S.suspend(() =>
  S.Struct({
    CognitoConfig: S.optional(CognitoConfig),
    OidcConfig: S.optional(OidcConfig),
    SourceIpConfig: S.optional(SourceIpConfig),
    WorkforceName: S.optional(S.String),
    Tags: S.optional(TagList),
    WorkforceVpcConfig: S.optional(WorkforceVpcConfigRequest),
    IpAddressType: S.optional(WorkforceIpAddressType),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateWorkforceRequest",
}) as any as S.Schema<CreateWorkforceRequest>;
export interface CreateWorkforceResponse {
  WorkforceArn: string;
}
export const CreateWorkforceResponse = S.suspend(() =>
  S.Struct({ WorkforceArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateWorkforceResponse",
}) as any as S.Schema<CreateWorkforceResponse>;
export interface CognitoMemberDefinition {
  UserPool?: string;
  UserGroup?: string;
  ClientId?: string;
}
export const CognitoMemberDefinition = S.suspend(() =>
  S.Struct({
    UserPool: S.optional(S.String),
    UserGroup: S.optional(S.String),
    ClientId: S.optional(S.String),
  }),
).annotate({
  identifier: "CognitoMemberDefinition",
}) as any as S.Schema<CognitoMemberDefinition>;
export type Groups = string[];
export const Groups = S.Array(S.String);
export interface OidcMemberDefinition {
  Groups?: string[];
}
export const OidcMemberDefinition = S.suspend(() =>
  S.Struct({ Groups: S.optional(Groups) }),
).annotate({
  identifier: "OidcMemberDefinition",
}) as any as S.Schema<OidcMemberDefinition>;
export interface MemberDefinition {
  CognitoMemberDefinition?: CognitoMemberDefinition;
  OidcMemberDefinition?: OidcMemberDefinition;
}
export const MemberDefinition = S.suspend(() =>
  S.Struct({
    CognitoMemberDefinition: S.optional(CognitoMemberDefinition),
    OidcMemberDefinition: S.optional(OidcMemberDefinition),
  }),
).annotate({
  identifier: "MemberDefinition",
}) as any as S.Schema<MemberDefinition>;
export type MemberDefinitions = MemberDefinition[];
export const MemberDefinitions = S.Array(MemberDefinition);
export interface NotificationConfiguration {
  NotificationTopicArn?: string;
}
export const NotificationConfiguration = S.suspend(() =>
  S.Struct({ NotificationTopicArn: S.optional(S.String) }),
).annotate({
  identifier: "NotificationConfiguration",
}) as any as S.Schema<NotificationConfiguration>;
export type EnabledOrDisabled = "Enabled" | "Disabled" | (string & {});
export const EnabledOrDisabled = S.String;
export interface IamPolicyConstraints {
  SourceIp?: EnabledOrDisabled;
  VpcSourceIp?: EnabledOrDisabled;
}
export const IamPolicyConstraints = S.suspend(() =>
  S.Struct({
    SourceIp: S.optional(EnabledOrDisabled),
    VpcSourceIp: S.optional(EnabledOrDisabled),
  }),
).annotate({
  identifier: "IamPolicyConstraints",
}) as any as S.Schema<IamPolicyConstraints>;
export interface S3Presign {
  IamPolicyConstraints?: IamPolicyConstraints;
}
export const S3Presign = S.suspend(() =>
  S.Struct({ IamPolicyConstraints: S.optional(IamPolicyConstraints) }),
).annotate({ identifier: "S3Presign" }) as any as S.Schema<S3Presign>;
export interface WorkerAccessConfiguration {
  S3Presign?: S3Presign;
}
export const WorkerAccessConfiguration = S.suspend(() =>
  S.Struct({ S3Presign: S.optional(S3Presign) }),
).annotate({
  identifier: "WorkerAccessConfiguration",
}) as any as S.Schema<WorkerAccessConfiguration>;
export interface CreateWorkteamRequest {
  WorkteamName?: string;
  WorkforceName?: string;
  MemberDefinitions?: MemberDefinition[];
  Description?: string;
  NotificationConfiguration?: NotificationConfiguration;
  WorkerAccessConfiguration?: WorkerAccessConfiguration;
  Tags?: Tag[];
}
export const CreateWorkteamRequest = S.suspend(() =>
  S.Struct({
    WorkteamName: S.optional(S.String),
    WorkforceName: S.optional(S.String),
    MemberDefinitions: S.optional(MemberDefinitions),
    Description: S.optional(S.String),
    NotificationConfiguration: S.optional(NotificationConfiguration),
    WorkerAccessConfiguration: S.optional(WorkerAccessConfiguration),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateWorkteamRequest",
}) as any as S.Schema<CreateWorkteamRequest>;
export interface CreateWorkteamResponse {
  WorkteamArn?: string;
}
export const CreateWorkteamResponse = S.suspend(() =>
  S.Struct({ WorkteamArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "CreateWorkteamResponse",
}) as any as S.Schema<CreateWorkteamResponse>;
export interface DeleteActionRequest {
  ActionName?: string;
}
export const DeleteActionRequest = S.suspend(() =>
  S.Struct({ ActionName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteActionRequest",
}) as any as S.Schema<DeleteActionRequest>;
export interface DeleteActionResponse {
  ActionArn?: string;
}
export const DeleteActionResponse = S.suspend(() =>
  S.Struct({ ActionArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "DeleteActionResponse",
}) as any as S.Schema<DeleteActionResponse>;
export interface DeleteAlgorithmInput {
  AlgorithmName?: string;
}
export const DeleteAlgorithmInput = S.suspend(() =>
  S.Struct({ AlgorithmName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteAlgorithmInput",
}) as any as S.Schema<DeleteAlgorithmInput>;
export interface DeleteAlgorithmResponse {}
export const DeleteAlgorithmResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteAlgorithmResponse",
}) as any as S.Schema<DeleteAlgorithmResponse>;
export interface DeleteAppRequest {
  DomainId?: string;
  UserProfileName?: string;
  SpaceName?: string;
  AppType?: AppType;
  AppName?: string;
}
export const DeleteAppRequest = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    UserProfileName: S.optional(S.String),
    SpaceName: S.optional(S.String),
    AppType: S.optional(AppType),
    AppName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteAppRequest",
}) as any as S.Schema<DeleteAppRequest>;
export interface DeleteAppResponse {}
export const DeleteAppResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteAppResponse",
}) as any as S.Schema<DeleteAppResponse>;
export interface DeleteAppImageConfigRequest {
  AppImageConfigName?: string;
}
export const DeleteAppImageConfigRequest = S.suspend(() =>
  S.Struct({ AppImageConfigName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteAppImageConfigRequest",
}) as any as S.Schema<DeleteAppImageConfigRequest>;
export interface DeleteAppImageConfigResponse {}
export const DeleteAppImageConfigResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteAppImageConfigResponse",
}) as any as S.Schema<DeleteAppImageConfigResponse>;
export interface DeleteArtifactRequest {
  ArtifactArn?: string;
  Source?: ArtifactSource;
}
export const DeleteArtifactRequest = S.suspend(() =>
  S.Struct({
    ArtifactArn: S.optional(S.String),
    Source: S.optional(ArtifactSource),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteArtifactRequest",
}) as any as S.Schema<DeleteArtifactRequest>;
export interface DeleteArtifactResponse {
  ArtifactArn?: string;
}
export const DeleteArtifactResponse = S.suspend(() =>
  S.Struct({ ArtifactArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "DeleteArtifactResponse",
}) as any as S.Schema<DeleteArtifactResponse>;
export interface DeleteAssociationRequest {
  SourceArn?: string;
  DestinationArn?: string;
}
export const DeleteAssociationRequest = S.suspend(() =>
  S.Struct({
    SourceArn: S.optional(S.String),
    DestinationArn: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteAssociationRequest",
}) as any as S.Schema<DeleteAssociationRequest>;
export interface DeleteAssociationResponse {
  SourceArn?: string;
  DestinationArn?: string;
}
export const DeleteAssociationResponse = S.suspend(() =>
  S.Struct({
    SourceArn: S.optional(S.String),
    DestinationArn: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "DeleteAssociationResponse",
}) as any as S.Schema<DeleteAssociationResponse>;
export interface DeleteClusterRequest {
  ClusterName?: string;
}
export const DeleteClusterRequest = S.suspend(() =>
  S.Struct({ ClusterName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteClusterRequest",
}) as any as S.Schema<DeleteClusterRequest>;
export interface DeleteClusterResponse {
  ClusterArn: string;
}
export const DeleteClusterResponse = S.suspend(() =>
  S.Struct({ ClusterArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "DeleteClusterResponse",
}) as any as S.Schema<DeleteClusterResponse>;
export interface DeleteClusterSchedulerConfigRequest {
  ClusterSchedulerConfigId?: string;
}
export const DeleteClusterSchedulerConfigRequest = S.suspend(() =>
  S.Struct({ ClusterSchedulerConfigId: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteClusterSchedulerConfigRequest",
}) as any as S.Schema<DeleteClusterSchedulerConfigRequest>;
export interface DeleteClusterSchedulerConfigResponse {}
export const DeleteClusterSchedulerConfigResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteClusterSchedulerConfigResponse",
}) as any as S.Schema<DeleteClusterSchedulerConfigResponse>;
export interface DeleteCodeRepositoryInput {
  CodeRepositoryName?: string;
}
export const DeleteCodeRepositoryInput = S.suspend(() =>
  S.Struct({ CodeRepositoryName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteCodeRepositoryInput",
}) as any as S.Schema<DeleteCodeRepositoryInput>;
export interface DeleteCodeRepositoryResponse {}
export const DeleteCodeRepositoryResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteCodeRepositoryResponse",
}) as any as S.Schema<DeleteCodeRepositoryResponse>;
export interface DeleteCompilationJobRequest {
  CompilationJobName?: string;
}
export const DeleteCompilationJobRequest = S.suspend(() =>
  S.Struct({ CompilationJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteCompilationJobRequest",
}) as any as S.Schema<DeleteCompilationJobRequest>;
export interface DeleteCompilationJobResponse {}
export const DeleteCompilationJobResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteCompilationJobResponse",
}) as any as S.Schema<DeleteCompilationJobResponse>;
export interface DeleteComputeQuotaRequest {
  ComputeQuotaId?: string;
}
export const DeleteComputeQuotaRequest = S.suspend(() =>
  S.Struct({ ComputeQuotaId: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteComputeQuotaRequest",
}) as any as S.Schema<DeleteComputeQuotaRequest>;
export interface DeleteComputeQuotaResponse {}
export const DeleteComputeQuotaResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteComputeQuotaResponse",
}) as any as S.Schema<DeleteComputeQuotaResponse>;
export interface DeleteContextRequest {
  ContextName?: string;
}
export const DeleteContextRequest = S.suspend(() =>
  S.Struct({ ContextName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteContextRequest",
}) as any as S.Schema<DeleteContextRequest>;
export interface DeleteContextResponse {
  ContextArn?: string;
}
export const DeleteContextResponse = S.suspend(() =>
  S.Struct({ ContextArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "DeleteContextResponse",
}) as any as S.Schema<DeleteContextResponse>;
export interface DeleteDataQualityJobDefinitionRequest {
  JobDefinitionName?: string;
}
export const DeleteDataQualityJobDefinitionRequest = S.suspend(() =>
  S.Struct({ JobDefinitionName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteDataQualityJobDefinitionRequest",
}) as any as S.Schema<DeleteDataQualityJobDefinitionRequest>;
export interface DeleteDataQualityJobDefinitionResponse {}
export const DeleteDataQualityJobDefinitionResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteDataQualityJobDefinitionResponse",
}) as any as S.Schema<DeleteDataQualityJobDefinitionResponse>;
export interface DeleteDeviceFleetRequest {
  DeviceFleetName?: string;
}
export const DeleteDeviceFleetRequest = S.suspend(() =>
  S.Struct({ DeviceFleetName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteDeviceFleetRequest",
}) as any as S.Schema<DeleteDeviceFleetRequest>;
export interface DeleteDeviceFleetResponse {}
export const DeleteDeviceFleetResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteDeviceFleetResponse",
}) as any as S.Schema<DeleteDeviceFleetResponse>;
export type RetentionType = "Retain" | "Delete" | (string & {});
export const RetentionType = S.String;
export interface RetentionPolicy {
  HomeEfsFileSystem?: RetentionType;
}
export const RetentionPolicy = S.suspend(() =>
  S.Struct({ HomeEfsFileSystem: S.optional(RetentionType) }),
).annotate({
  identifier: "RetentionPolicy",
}) as any as S.Schema<RetentionPolicy>;
export interface DeleteDomainRequest {
  DomainId?: string;
  RetentionPolicy?: RetentionPolicy;
}
export const DeleteDomainRequest = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    RetentionPolicy: S.optional(RetentionPolicy),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteDomainRequest",
}) as any as S.Schema<DeleteDomainRequest>;
export interface DeleteDomainResponse {}
export const DeleteDomainResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteDomainResponse",
}) as any as S.Schema<DeleteDomainResponse>;
export interface DeleteEdgeDeploymentPlanRequest {
  EdgeDeploymentPlanName?: string;
}
export const DeleteEdgeDeploymentPlanRequest = S.suspend(() =>
  S.Struct({ EdgeDeploymentPlanName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteEdgeDeploymentPlanRequest",
}) as any as S.Schema<DeleteEdgeDeploymentPlanRequest>;
export interface DeleteEdgeDeploymentPlanResponse {}
export const DeleteEdgeDeploymentPlanResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteEdgeDeploymentPlanResponse",
}) as any as S.Schema<DeleteEdgeDeploymentPlanResponse>;
export interface DeleteEdgeDeploymentStageRequest {
  EdgeDeploymentPlanName?: string;
  StageName?: string;
}
export const DeleteEdgeDeploymentStageRequest = S.suspend(() =>
  S.Struct({
    EdgeDeploymentPlanName: S.optional(S.String),
    StageName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteEdgeDeploymentStageRequest",
}) as any as S.Schema<DeleteEdgeDeploymentStageRequest>;
export interface DeleteEdgeDeploymentStageResponse {}
export const DeleteEdgeDeploymentStageResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteEdgeDeploymentStageResponse",
}) as any as S.Schema<DeleteEdgeDeploymentStageResponse>;
export interface DeleteEndpointInput {
  EndpointName?: string;
}
export const DeleteEndpointInput = S.suspend(() =>
  S.Struct({ EndpointName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteEndpointInput",
}) as any as S.Schema<DeleteEndpointInput>;
export interface DeleteEndpointResponse {}
export const DeleteEndpointResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteEndpointResponse",
}) as any as S.Schema<DeleteEndpointResponse>;
export interface DeleteEndpointConfigInput {
  EndpointConfigName?: string;
}
export const DeleteEndpointConfigInput = S.suspend(() =>
  S.Struct({ EndpointConfigName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteEndpointConfigInput",
}) as any as S.Schema<DeleteEndpointConfigInput>;
export interface DeleteEndpointConfigResponse {}
export const DeleteEndpointConfigResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteEndpointConfigResponse",
}) as any as S.Schema<DeleteEndpointConfigResponse>;
export interface DeleteExperimentRequest {
  ExperimentName?: string;
}
export const DeleteExperimentRequest = S.suspend(() =>
  S.Struct({ ExperimentName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteExperimentRequest",
}) as any as S.Schema<DeleteExperimentRequest>;
export interface DeleteExperimentResponse {
  ExperimentArn?: string;
}
export const DeleteExperimentResponse = S.suspend(() =>
  S.Struct({ ExperimentArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "DeleteExperimentResponse",
}) as any as S.Schema<DeleteExperimentResponse>;
export interface DeleteFeatureGroupRequest {
  FeatureGroupName?: string;
}
export const DeleteFeatureGroupRequest = S.suspend(() =>
  S.Struct({ FeatureGroupName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteFeatureGroupRequest",
}) as any as S.Schema<DeleteFeatureGroupRequest>;
export interface DeleteFeatureGroupResponse {}
export const DeleteFeatureGroupResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteFeatureGroupResponse",
}) as any as S.Schema<DeleteFeatureGroupResponse>;
export interface DeleteFlowDefinitionRequest {
  FlowDefinitionName?: string;
}
export const DeleteFlowDefinitionRequest = S.suspend(() =>
  S.Struct({ FlowDefinitionName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteFlowDefinitionRequest",
}) as any as S.Schema<DeleteFlowDefinitionRequest>;
export interface DeleteFlowDefinitionResponse {}
export const DeleteFlowDefinitionResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteFlowDefinitionResponse",
}) as any as S.Schema<DeleteFlowDefinitionResponse>;
export interface DeleteHubRequest {
  HubName?: string;
}
export const DeleteHubRequest = S.suspend(() =>
  S.Struct({ HubName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteHubRequest",
}) as any as S.Schema<DeleteHubRequest>;
export interface DeleteHubResponse {}
export const DeleteHubResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteHubResponse",
}) as any as S.Schema<DeleteHubResponse>;
export interface DeleteHubContentRequest {
  HubName?: string;
  HubContentType?: HubContentType;
  HubContentName?: string;
  HubContentVersion?: string;
}
export const DeleteHubContentRequest = S.suspend(() =>
  S.Struct({
    HubName: S.optional(S.String),
    HubContentType: S.optional(HubContentType),
    HubContentName: S.optional(S.String),
    HubContentVersion: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteHubContentRequest",
}) as any as S.Schema<DeleteHubContentRequest>;
export interface DeleteHubContentResponse {}
export const DeleteHubContentResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteHubContentResponse",
}) as any as S.Schema<DeleteHubContentResponse>;
export interface DeleteHubContentReferenceRequest {
  HubName?: string;
  HubContentType?: HubContentType;
  HubContentName?: string;
}
export const DeleteHubContentReferenceRequest = S.suspend(() =>
  S.Struct({
    HubName: S.optional(S.String),
    HubContentType: S.optional(HubContentType),
    HubContentName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteHubContentReferenceRequest",
}) as any as S.Schema<DeleteHubContentReferenceRequest>;
export interface DeleteHubContentReferenceResponse {}
export const DeleteHubContentReferenceResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteHubContentReferenceResponse",
}) as any as S.Schema<DeleteHubContentReferenceResponse>;
export interface DeleteHumanTaskUiRequest {
  HumanTaskUiName?: string;
}
export const DeleteHumanTaskUiRequest = S.suspend(() =>
  S.Struct({ HumanTaskUiName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteHumanTaskUiRequest",
}) as any as S.Schema<DeleteHumanTaskUiRequest>;
export interface DeleteHumanTaskUiResponse {}
export const DeleteHumanTaskUiResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteHumanTaskUiResponse",
}) as any as S.Schema<DeleteHumanTaskUiResponse>;
export interface DeleteHyperParameterTuningJobRequest {
  HyperParameterTuningJobName?: string;
}
export const DeleteHyperParameterTuningJobRequest = S.suspend(() =>
  S.Struct({ HyperParameterTuningJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteHyperParameterTuningJobRequest",
}) as any as S.Schema<DeleteHyperParameterTuningJobRequest>;
export interface DeleteHyperParameterTuningJobResponse {}
export const DeleteHyperParameterTuningJobResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteHyperParameterTuningJobResponse",
}) as any as S.Schema<DeleteHyperParameterTuningJobResponse>;
export interface DeleteImageRequest {
  ImageName?: string;
}
export const DeleteImageRequest = S.suspend(() =>
  S.Struct({ ImageName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteImageRequest",
}) as any as S.Schema<DeleteImageRequest>;
export interface DeleteImageResponse {}
export const DeleteImageResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteImageResponse",
}) as any as S.Schema<DeleteImageResponse>;
export interface DeleteImageVersionRequest {
  ImageName?: string;
  Version?: number;
  Alias?: string;
}
export const DeleteImageVersionRequest = S.suspend(() =>
  S.Struct({
    ImageName: S.optional(S.String),
    Version: S.optional(S.Number),
    Alias: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteImageVersionRequest",
}) as any as S.Schema<DeleteImageVersionRequest>;
export interface DeleteImageVersionResponse {}
export const DeleteImageVersionResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteImageVersionResponse",
}) as any as S.Schema<DeleteImageVersionResponse>;
export interface DeleteInferenceComponentInput {
  InferenceComponentName?: string;
}
export const DeleteInferenceComponentInput = S.suspend(() =>
  S.Struct({ InferenceComponentName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteInferenceComponentInput",
}) as any as S.Schema<DeleteInferenceComponentInput>;
export interface DeleteInferenceComponentResponse {}
export const DeleteInferenceComponentResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteInferenceComponentResponse",
}) as any as S.Schema<DeleteInferenceComponentResponse>;
export interface DeleteInferenceExperimentRequest {
  Name?: string;
}
export const DeleteInferenceExperimentRequest = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteInferenceExperimentRequest",
}) as any as S.Schema<DeleteInferenceExperimentRequest>;
export interface DeleteInferenceExperimentResponse {
  InferenceExperimentArn: string;
}
export const DeleteInferenceExperimentResponse = S.suspend(() =>
  S.Struct({ InferenceExperimentArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "DeleteInferenceExperimentResponse",
}) as any as S.Schema<DeleteInferenceExperimentResponse>;
export interface DeleteMlflowAppRequest {
  Arn?: string;
}
export const DeleteMlflowAppRequest = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteMlflowAppRequest",
}) as any as S.Schema<DeleteMlflowAppRequest>;
export interface DeleteMlflowAppResponse {
  Arn?: string;
}
export const DeleteMlflowAppResponse = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "DeleteMlflowAppResponse",
}) as any as S.Schema<DeleteMlflowAppResponse>;
export interface DeleteMlflowTrackingServerRequest {
  TrackingServerName?: string;
}
export const DeleteMlflowTrackingServerRequest = S.suspend(() =>
  S.Struct({ TrackingServerName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteMlflowTrackingServerRequest",
}) as any as S.Schema<DeleteMlflowTrackingServerRequest>;
export interface DeleteMlflowTrackingServerResponse {
  TrackingServerArn?: string;
}
export const DeleteMlflowTrackingServerResponse = S.suspend(() =>
  S.Struct({ TrackingServerArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "DeleteMlflowTrackingServerResponse",
}) as any as S.Schema<DeleteMlflowTrackingServerResponse>;
export interface DeleteModelInput {
  ModelName?: string;
}
export const DeleteModelInput = S.suspend(() =>
  S.Struct({ ModelName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteModelInput",
}) as any as S.Schema<DeleteModelInput>;
export interface DeleteModelResponse {}
export const DeleteModelResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteModelResponse",
}) as any as S.Schema<DeleteModelResponse>;
export interface DeleteModelBiasJobDefinitionRequest {
  JobDefinitionName?: string;
}
export const DeleteModelBiasJobDefinitionRequest = S.suspend(() =>
  S.Struct({ JobDefinitionName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteModelBiasJobDefinitionRequest",
}) as any as S.Schema<DeleteModelBiasJobDefinitionRequest>;
export interface DeleteModelBiasJobDefinitionResponse {}
export const DeleteModelBiasJobDefinitionResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteModelBiasJobDefinitionResponse",
}) as any as S.Schema<DeleteModelBiasJobDefinitionResponse>;
export interface DeleteModelCardRequest {
  ModelCardName?: string;
}
export const DeleteModelCardRequest = S.suspend(() =>
  S.Struct({ ModelCardName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteModelCardRequest",
}) as any as S.Schema<DeleteModelCardRequest>;
export interface DeleteModelCardResponse {}
export const DeleteModelCardResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteModelCardResponse",
}) as any as S.Schema<DeleteModelCardResponse>;
export interface DeleteModelExplainabilityJobDefinitionRequest {
  JobDefinitionName?: string;
}
export const DeleteModelExplainabilityJobDefinitionRequest = S.suspend(() =>
  S.Struct({ JobDefinitionName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteModelExplainabilityJobDefinitionRequest",
}) as any as S.Schema<DeleteModelExplainabilityJobDefinitionRequest>;
export interface DeleteModelExplainabilityJobDefinitionResponse {}
export const DeleteModelExplainabilityJobDefinitionResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteModelExplainabilityJobDefinitionResponse",
}) as any as S.Schema<DeleteModelExplainabilityJobDefinitionResponse>;
export interface DeleteModelPackageInput {
  ModelPackageName?: string;
}
export const DeleteModelPackageInput = S.suspend(() =>
  S.Struct({ ModelPackageName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteModelPackageInput",
}) as any as S.Schema<DeleteModelPackageInput>;
export interface DeleteModelPackageResponse {}
export const DeleteModelPackageResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteModelPackageResponse",
}) as any as S.Schema<DeleteModelPackageResponse>;
export interface DeleteModelPackageGroupInput {
  ModelPackageGroupName?: string;
}
export const DeleteModelPackageGroupInput = S.suspend(() =>
  S.Struct({ ModelPackageGroupName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteModelPackageGroupInput",
}) as any as S.Schema<DeleteModelPackageGroupInput>;
export interface DeleteModelPackageGroupResponse {}
export const DeleteModelPackageGroupResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteModelPackageGroupResponse",
}) as any as S.Schema<DeleteModelPackageGroupResponse>;
export interface DeleteModelPackageGroupPolicyInput {
  ModelPackageGroupName?: string;
}
export const DeleteModelPackageGroupPolicyInput = S.suspend(() =>
  S.Struct({ ModelPackageGroupName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteModelPackageGroupPolicyInput",
}) as any as S.Schema<DeleteModelPackageGroupPolicyInput>;
export interface DeleteModelPackageGroupPolicyResponse {}
export const DeleteModelPackageGroupPolicyResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteModelPackageGroupPolicyResponse",
}) as any as S.Schema<DeleteModelPackageGroupPolicyResponse>;
export interface DeleteModelQualityJobDefinitionRequest {
  JobDefinitionName?: string;
}
export const DeleteModelQualityJobDefinitionRequest = S.suspend(() =>
  S.Struct({ JobDefinitionName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteModelQualityJobDefinitionRequest",
}) as any as S.Schema<DeleteModelQualityJobDefinitionRequest>;
export interface DeleteModelQualityJobDefinitionResponse {}
export const DeleteModelQualityJobDefinitionResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteModelQualityJobDefinitionResponse",
}) as any as S.Schema<DeleteModelQualityJobDefinitionResponse>;
export interface DeleteMonitoringScheduleRequest {
  MonitoringScheduleName?: string;
}
export const DeleteMonitoringScheduleRequest = S.suspend(() =>
  S.Struct({ MonitoringScheduleName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteMonitoringScheduleRequest",
}) as any as S.Schema<DeleteMonitoringScheduleRequest>;
export interface DeleteMonitoringScheduleResponse {}
export const DeleteMonitoringScheduleResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteMonitoringScheduleResponse",
}) as any as S.Schema<DeleteMonitoringScheduleResponse>;
export interface DeleteNotebookInstanceInput {
  NotebookInstanceName?: string;
}
export const DeleteNotebookInstanceInput = S.suspend(() =>
  S.Struct({ NotebookInstanceName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteNotebookInstanceInput",
}) as any as S.Schema<DeleteNotebookInstanceInput>;
export interface DeleteNotebookInstanceResponse {}
export const DeleteNotebookInstanceResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteNotebookInstanceResponse",
}) as any as S.Schema<DeleteNotebookInstanceResponse>;
export interface DeleteNotebookInstanceLifecycleConfigInput {
  NotebookInstanceLifecycleConfigName?: string;
}
export const DeleteNotebookInstanceLifecycleConfigInput = S.suspend(() =>
  S.Struct({ NotebookInstanceLifecycleConfigName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteNotebookInstanceLifecycleConfigInput",
}) as any as S.Schema<DeleteNotebookInstanceLifecycleConfigInput>;
export interface DeleteNotebookInstanceLifecycleConfigResponse {}
export const DeleteNotebookInstanceLifecycleConfigResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteNotebookInstanceLifecycleConfigResponse",
}) as any as S.Schema<DeleteNotebookInstanceLifecycleConfigResponse>;
export interface DeleteOptimizationJobRequest {
  OptimizationJobName?: string;
}
export const DeleteOptimizationJobRequest = S.suspend(() =>
  S.Struct({ OptimizationJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteOptimizationJobRequest",
}) as any as S.Schema<DeleteOptimizationJobRequest>;
export interface DeleteOptimizationJobResponse {}
export const DeleteOptimizationJobResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteOptimizationJobResponse",
}) as any as S.Schema<DeleteOptimizationJobResponse>;
export interface DeletePartnerAppRequest {
  Arn?: string;
  ClientToken?: string;
}
export const DeletePartnerAppRequest = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeletePartnerAppRequest",
}) as any as S.Schema<DeletePartnerAppRequest>;
export interface DeletePartnerAppResponse {
  Arn?: string;
}
export const DeletePartnerAppResponse = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "DeletePartnerAppResponse",
}) as any as S.Schema<DeletePartnerAppResponse>;
export interface DeletePipelineRequest {
  PipelineName?: string;
  ClientRequestToken?: string;
}
export const DeletePipelineRequest = S.suspend(() =>
  S.Struct({
    PipelineName: S.optional(S.String),
    ClientRequestToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeletePipelineRequest",
}) as any as S.Schema<DeletePipelineRequest>;
export interface DeletePipelineResponse {
  PipelineArn?: string;
}
export const DeletePipelineResponse = S.suspend(() =>
  S.Struct({ PipelineArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "DeletePipelineResponse",
}) as any as S.Schema<DeletePipelineResponse>;
export interface DeleteProcessingJobRequest {
  ProcessingJobName?: string;
}
export const DeleteProcessingJobRequest = S.suspend(() =>
  S.Struct({ ProcessingJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteProcessingJobRequest",
}) as any as S.Schema<DeleteProcessingJobRequest>;
export interface DeleteProcessingJobResponse {}
export const DeleteProcessingJobResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteProcessingJobResponse",
}) as any as S.Schema<DeleteProcessingJobResponse>;
export interface DeleteProjectInput {
  ProjectName?: string;
}
export const DeleteProjectInput = S.suspend(() =>
  S.Struct({ ProjectName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteProjectInput",
}) as any as S.Schema<DeleteProjectInput>;
export interface DeleteProjectResponse {}
export const DeleteProjectResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteProjectResponse",
}) as any as S.Schema<DeleteProjectResponse>;
export interface DeleteSpaceRequest {
  DomainId?: string;
  SpaceName?: string;
}
export const DeleteSpaceRequest = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    SpaceName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteSpaceRequest",
}) as any as S.Schema<DeleteSpaceRequest>;
export interface DeleteSpaceResponse {}
export const DeleteSpaceResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteSpaceResponse",
}) as any as S.Schema<DeleteSpaceResponse>;
export interface DeleteStudioLifecycleConfigRequest {
  StudioLifecycleConfigName?: string;
}
export const DeleteStudioLifecycleConfigRequest = S.suspend(() =>
  S.Struct({ StudioLifecycleConfigName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteStudioLifecycleConfigRequest",
}) as any as S.Schema<DeleteStudioLifecycleConfigRequest>;
export interface DeleteStudioLifecycleConfigResponse {}
export const DeleteStudioLifecycleConfigResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteStudioLifecycleConfigResponse",
}) as any as S.Schema<DeleteStudioLifecycleConfigResponse>;
export type TagKeyList = string[];
export const TagKeyList = S.Array(S.String);
export interface DeleteTagsInput {
  ResourceArn?: string;
  TagKeys?: string[];
}
export const DeleteTagsInput = S.suspend(() =>
  S.Struct({
    ResourceArn: S.optional(S.String),
    TagKeys: S.optional(TagKeyList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTagsInput",
}) as any as S.Schema<DeleteTagsInput>;
export interface DeleteTagsOutput {}
export const DeleteTagsOutput = S.suspend(() => S.Struct({}).pipe(ns)).annotate(
  { identifier: "DeleteTagsOutput" },
) as any as S.Schema<DeleteTagsOutput>;
export interface DeleteTrainingJobRequest {
  TrainingJobName?: string;
}
export const DeleteTrainingJobRequest = S.suspend(() =>
  S.Struct({ TrainingJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTrainingJobRequest",
}) as any as S.Schema<DeleteTrainingJobRequest>;
export interface DeleteTrainingJobResponse {}
export const DeleteTrainingJobResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteTrainingJobResponse",
}) as any as S.Schema<DeleteTrainingJobResponse>;
export interface DeleteTrialRequest {
  TrialName?: string;
}
export const DeleteTrialRequest = S.suspend(() =>
  S.Struct({ TrialName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTrialRequest",
}) as any as S.Schema<DeleteTrialRequest>;
export interface DeleteTrialResponse {
  TrialArn?: string;
}
export const DeleteTrialResponse = S.suspend(() =>
  S.Struct({ TrialArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "DeleteTrialResponse",
}) as any as S.Schema<DeleteTrialResponse>;
export interface DeleteTrialComponentRequest {
  TrialComponentName?: string;
}
export const DeleteTrialComponentRequest = S.suspend(() =>
  S.Struct({ TrialComponentName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTrialComponentRequest",
}) as any as S.Schema<DeleteTrialComponentRequest>;
export interface DeleteTrialComponentResponse {
  TrialComponentArn?: string;
}
export const DeleteTrialComponentResponse = S.suspend(() =>
  S.Struct({ TrialComponentArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "DeleteTrialComponentResponse",
}) as any as S.Schema<DeleteTrialComponentResponse>;
export interface DeleteUserProfileRequest {
  DomainId?: string;
  UserProfileName?: string;
}
export const DeleteUserProfileRequest = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    UserProfileName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteUserProfileRequest",
}) as any as S.Schema<DeleteUserProfileRequest>;
export interface DeleteUserProfileResponse {}
export const DeleteUserProfileResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteUserProfileResponse",
}) as any as S.Schema<DeleteUserProfileResponse>;
export interface DeleteWorkforceRequest {
  WorkforceName?: string;
}
export const DeleteWorkforceRequest = S.suspend(() =>
  S.Struct({ WorkforceName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteWorkforceRequest",
}) as any as S.Schema<DeleteWorkforceRequest>;
export interface DeleteWorkforceResponse {}
export const DeleteWorkforceResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeleteWorkforceResponse",
}) as any as S.Schema<DeleteWorkforceResponse>;
export interface DeleteWorkteamRequest {
  WorkteamName?: string;
}
export const DeleteWorkteamRequest = S.suspend(() =>
  S.Struct({ WorkteamName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteWorkteamRequest",
}) as any as S.Schema<DeleteWorkteamRequest>;
export interface DeleteWorkteamResponse {
  Success: boolean;
}
export const DeleteWorkteamResponse = S.suspend(() =>
  S.Struct({ Success: S.optional(S.Boolean) }).pipe(ns),
).annotate({
  identifier: "DeleteWorkteamResponse",
}) as any as S.Schema<DeleteWorkteamResponse>;
export interface DeregisterDevicesRequest {
  DeviceFleetName?: string;
  DeviceNames?: string[];
}
export const DeregisterDevicesRequest = S.suspend(() =>
  S.Struct({
    DeviceFleetName: S.optional(S.String),
    DeviceNames: S.optional(DeviceNames),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeregisterDevicesRequest",
}) as any as S.Schema<DeregisterDevicesRequest>;
export interface DeregisterDevicesResponse {}
export const DeregisterDevicesResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DeregisterDevicesResponse",
}) as any as S.Schema<DeregisterDevicesResponse>;
export interface DescribeActionRequest {
  ActionName?: string;
}
export const DescribeActionRequest = S.suspend(() =>
  S.Struct({ ActionName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeActionRequest",
}) as any as S.Schema<DescribeActionRequest>;
export interface IamIdentity {
  Arn?: string;
  PrincipalId?: string;
  SourceIdentity?: string;
}
export const IamIdentity = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    PrincipalId: S.optional(S.String),
    SourceIdentity: S.optional(S.String),
  }),
).annotate({ identifier: "IamIdentity" }) as any as S.Schema<IamIdentity>;
export interface UserContext {
  UserProfileArn?: string;
  UserProfileName?: string;
  DomainId?: string;
  IamIdentity?: IamIdentity;
}
export const UserContext = S.suspend(() =>
  S.Struct({
    UserProfileArn: S.optional(S.String),
    UserProfileName: S.optional(S.String),
    DomainId: S.optional(S.String),
    IamIdentity: S.optional(IamIdentity),
  }),
).annotate({ identifier: "UserContext" }) as any as S.Schema<UserContext>;
export interface DescribeActionResponse {
  ActionName?: string;
  ActionArn?: string;
  Source?: ActionSource & { SourceUri: SourceUri };
  ActionType?: string;
  Description?: string;
  Status?: ActionStatus;
  Properties?: { [key: string]: string | undefined };
  CreationTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
  MetadataProperties?: MetadataProperties;
  LineageGroupArn?: string;
}
export const DescribeActionResponse = S.suspend(() =>
  S.Struct({
    ActionName: S.optional(S.String),
    ActionArn: S.optional(S.String),
    Source: S.optional(ActionSource),
    ActionType: S.optional(S.String),
    Description: S.optional(S.String),
    Status: S.optional(ActionStatus),
    Properties: S.optional(LineageEntityParameters),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
    MetadataProperties: S.optional(MetadataProperties),
    LineageGroupArn: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "DescribeActionResponse",
}) as any as S.Schema<DescribeActionResponse>;
export interface DescribeAlgorithmInput {
  AlgorithmName?: string;
}
export const DescribeAlgorithmInput = S.suspend(() =>
  S.Struct({ AlgorithmName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeAlgorithmInput",
}) as any as S.Schema<DescribeAlgorithmInput>;
export type AlgorithmStatus =
  | "Pending"
  | "InProgress"
  | "Completed"
  | "Failed"
  | "Deleting"
  | (string & {});
export const AlgorithmStatus = S.String;
export type DetailedAlgorithmStatus =
  | "NotStarted"
  | "InProgress"
  | "Completed"
  | "Failed"
  | (string & {});
export const DetailedAlgorithmStatus = S.String;
export interface AlgorithmStatusItem {
  Name?: string;
  Status?: DetailedAlgorithmStatus;
  FailureReason?: string;
}
export const AlgorithmStatusItem = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Status: S.optional(DetailedAlgorithmStatus),
    FailureReason: S.optional(S.String),
  }),
).annotate({
  identifier: "AlgorithmStatusItem",
}) as any as S.Schema<AlgorithmStatusItem>;
export type AlgorithmStatusItemList = AlgorithmStatusItem[];
export const AlgorithmStatusItemList = S.Array(AlgorithmStatusItem);
export interface AlgorithmStatusDetails {
  ValidationStatuses?: AlgorithmStatusItem[];
  ImageScanStatuses?: AlgorithmStatusItem[];
}
export const AlgorithmStatusDetails = S.suspend(() =>
  S.Struct({
    ValidationStatuses: S.optional(AlgorithmStatusItemList),
    ImageScanStatuses: S.optional(AlgorithmStatusItemList),
  }),
).annotate({
  identifier: "AlgorithmStatusDetails",
}) as any as S.Schema<AlgorithmStatusDetails>;
export interface DescribeAlgorithmOutput {
  AlgorithmName: string;
  AlgorithmArn: string;
  AlgorithmDescription?: string;
  CreationTime: Date;
  TrainingSpecification: TrainingSpecification & {
    TrainingImage: ContainerImage;
    SupportedTrainingInstanceTypes: TrainingInstanceTypes;
    TrainingChannels: (ChannelSpecification & {
      Name: ChannelName;
      SupportedContentTypes: ContentTypes;
      SupportedInputModes: InputModes;
    })[];
    SupportedHyperParameters: (HyperParameterSpecification & {
      Name: ParameterName;
      Type: ParameterType;
      Range: ParameterRange & {
        IntegerParameterRangeSpecification: IntegerParameterRangeSpecification & {
          MinValue: ParameterValue;
          MaxValue: ParameterValue;
        };
        ContinuousParameterRangeSpecification: ContinuousParameterRangeSpecification & {
          MinValue: ParameterValue;
          MaxValue: ParameterValue;
        };
        CategoricalParameterRangeSpecification: CategoricalParameterRangeSpecification & {
          Values: ParameterValues;
        };
      };
    })[];
    MetricDefinitions: (MetricDefinition & {
      Name: MetricName;
      Regex: MetricRegex;
    })[];
    SupportedTuningJobObjectiveMetrics: (HyperParameterTuningJobObjective & {
      Type: HyperParameterTuningJobObjectiveType;
      MetricName: MetricName;
    })[];
    AdditionalS3DataSource: AdditionalS3DataSource & {
      S3DataType: AdditionalS3DataSourceDataType;
      S3Uri: S3Uri;
    };
  };
  InferenceSpecification?: InferenceSpecification & {
    Containers: (ModelPackageContainerDefinition & {
      ModelDataSource: ModelDataSource & {
        S3DataSource: S3ModelDataSource & {
          S3Uri: S3ModelUri;
          S3DataType: S3ModelDataType;
          CompressionType: ModelCompressionType;
          ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
          HubAccessConfig: InferenceHubAccessConfig & {
            HubContentArn: HubContentArn;
          };
        };
      };
      ModelInput: ModelInput & { DataInputConfig: DataInputConfig };
      AdditionalS3DataSource: AdditionalS3DataSource & {
        S3DataType: AdditionalS3DataSourceDataType;
        S3Uri: S3Uri;
      };
    })[];
  };
  ValidationSpecification?: AlgorithmValidationSpecification & {
    ValidationRole: RoleArn;
    ValidationProfiles: (AlgorithmValidationProfile & {
      ProfileName: EntityName;
      TrainingJobDefinition: TrainingJobDefinition & {
        TrainingInputMode: TrainingInputMode;
        InputDataConfig: (Channel & {
          ChannelName: ChannelName;
          DataSource: DataSource & {
            S3DataSource: S3DataSource & {
              S3DataType: S3DataType;
              S3Uri: S3Uri;
              ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
              HubAccessConfig: HubAccessConfig & {
                HubContentArn: HubContentArn;
              };
            };
            FileSystemDataSource: FileSystemDataSource & {
              FileSystemId: FileSystemId;
              FileSystemAccessMode: FileSystemAccessMode;
              FileSystemType: FileSystemType;
              DirectoryPath: DirectoryPath;
            };
          };
          ShuffleConfig: ShuffleConfig & { Seed: Seed };
        })[];
        OutputDataConfig: OutputDataConfig & { S3OutputPath: S3Uri };
        ResourceConfig: ResourceConfig & {
          InstanceGroups: (InstanceGroup & {
            InstanceType: TrainingInstanceType;
            InstanceCount: TrainingInstanceCount;
            InstanceGroupName: InstanceGroupName;
          })[];
          InstancePlacementConfig: InstancePlacementConfig & {
            PlacementSpecifications: (PlacementSpecification & {
              InstanceCount: TrainingInstanceCount;
            })[];
          };
        };
        StoppingCondition: StoppingCondition;
      };
      TransformJobDefinition: TransformJobDefinition & {
        TransformInput: TransformInput & {
          DataSource: TransformDataSource & {
            S3DataSource: TransformS3DataSource & {
              S3DataType: S3DataType;
              S3Uri: S3Uri;
            };
          };
        };
        TransformOutput: TransformOutput & { S3OutputPath: S3Uri };
        TransformResources: TransformResources & {
          InstanceType: TransformInstanceType;
          InstanceCount: TransformInstanceCount;
        };
      };
    })[];
  };
  AlgorithmStatus: AlgorithmStatus;
  AlgorithmStatusDetails: AlgorithmStatusDetails & {
    ValidationStatuses: (AlgorithmStatusItem & {
      Name: EntityName;
      Status: DetailedAlgorithmStatus;
    })[];
    ImageScanStatuses: (AlgorithmStatusItem & {
      Name: EntityName;
      Status: DetailedAlgorithmStatus;
    })[];
  };
  ProductId?: string;
  CertifyForMarketplace?: boolean;
}
export const DescribeAlgorithmOutput = S.suspend(() =>
  S.Struct({
    AlgorithmName: S.optional(S.String),
    AlgorithmArn: S.optional(S.String),
    AlgorithmDescription: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    TrainingSpecification: S.optional(TrainingSpecification),
    InferenceSpecification: S.optional(InferenceSpecification),
    ValidationSpecification: S.optional(AlgorithmValidationSpecification),
    AlgorithmStatus: S.optional(AlgorithmStatus),
    AlgorithmStatusDetails: S.optional(AlgorithmStatusDetails),
    ProductId: S.optional(S.String),
    CertifyForMarketplace: S.optional(S.Boolean),
  }).pipe(ns),
).annotate({
  identifier: "DescribeAlgorithmOutput",
}) as any as S.Schema<DescribeAlgorithmOutput>;
export interface DescribeAppRequest {
  DomainId?: string;
  UserProfileName?: string;
  SpaceName?: string;
  AppType?: AppType;
  AppName?: string;
}
export const DescribeAppRequest = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    UserProfileName: S.optional(S.String),
    SpaceName: S.optional(S.String),
    AppType: S.optional(AppType),
    AppName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeAppRequest",
}) as any as S.Schema<DescribeAppRequest>;
export type AppStatus =
  | "Deleted"
  | "Deleting"
  | "Failed"
  | "InService"
  | "Pending"
  | (string & {});
export const AppStatus = S.String;
export interface DescribeAppResponse {
  AppArn?: string;
  AppType?: AppType;
  AppName?: string;
  DomainId?: string;
  UserProfileName?: string;
  SpaceName?: string;
  Status?: AppStatus;
  EffectiveTrustedIdentityPropagationStatus?: FeatureStatus;
  RecoveryMode?: boolean;
  LastHealthCheckTimestamp?: Date;
  LastUserActivityTimestamp?: Date;
  CreationTime?: Date;
  FailureReason?: string;
  ResourceSpec?: ResourceSpec;
  BuiltInLifecycleConfigArn?: string;
}
export const DescribeAppResponse = S.suspend(() =>
  S.Struct({
    AppArn: S.optional(S.String),
    AppType: S.optional(AppType),
    AppName: S.optional(S.String),
    DomainId: S.optional(S.String),
    UserProfileName: S.optional(S.String),
    SpaceName: S.optional(S.String),
    Status: S.optional(AppStatus),
    EffectiveTrustedIdentityPropagationStatus: S.optional(FeatureStatus),
    RecoveryMode: S.optional(S.Boolean),
    LastHealthCheckTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastUserActivityTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    FailureReason: S.optional(S.String),
    ResourceSpec: S.optional(ResourceSpec),
    BuiltInLifecycleConfigArn: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "DescribeAppResponse",
}) as any as S.Schema<DescribeAppResponse>;
export interface DescribeAppImageConfigRequest {
  AppImageConfigName?: string;
}
export const DescribeAppImageConfigRequest = S.suspend(() =>
  S.Struct({ AppImageConfigName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeAppImageConfigRequest",
}) as any as S.Schema<DescribeAppImageConfigRequest>;
export interface DescribeAppImageConfigResponse {
  AppImageConfigArn?: string;
  AppImageConfigName?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  KernelGatewayImageConfig?: KernelGatewayImageConfig & {
    KernelSpecs: (KernelSpec & { Name: KernelName })[];
  };
  JupyterLabAppImageConfig?: JupyterLabAppImageConfig;
  CodeEditorAppImageConfig?: CodeEditorAppImageConfig;
}
export const DescribeAppImageConfigResponse = S.suspend(() =>
  S.Struct({
    AppImageConfigArn: S.optional(S.String),
    AppImageConfigName: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    KernelGatewayImageConfig: S.optional(KernelGatewayImageConfig),
    JupyterLabAppImageConfig: S.optional(JupyterLabAppImageConfig),
    CodeEditorAppImageConfig: S.optional(CodeEditorAppImageConfig),
  }).pipe(ns),
).annotate({
  identifier: "DescribeAppImageConfigResponse",
}) as any as S.Schema<DescribeAppImageConfigResponse>;
export interface DescribeArtifactRequest {
  ArtifactArn?: string;
}
export const DescribeArtifactRequest = S.suspend(() =>
  S.Struct({ ArtifactArn: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeArtifactRequest",
}) as any as S.Schema<DescribeArtifactRequest>;
export interface DescribeArtifactResponse {
  ArtifactName?: string;
  ArtifactArn?: string;
  Source?: ArtifactSource & {
    SourceUri: SourceUri;
    SourceTypes: (ArtifactSourceType & {
      SourceIdType: ArtifactSourceIdType;
      Value: String256;
    })[];
  };
  ArtifactType?: string;
  Properties?: { [key: string]: string | undefined };
  CreationTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
  MetadataProperties?: MetadataProperties;
  LineageGroupArn?: string;
}
export const DescribeArtifactResponse = S.suspend(() =>
  S.Struct({
    ArtifactName: S.optional(S.String),
    ArtifactArn: S.optional(S.String),
    Source: S.optional(ArtifactSource),
    ArtifactType: S.optional(S.String),
    Properties: S.optional(LineageEntityParameters),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
    MetadataProperties: S.optional(MetadataProperties),
    LineageGroupArn: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "DescribeArtifactResponse",
}) as any as S.Schema<DescribeArtifactResponse>;
export interface DescribeAutoMLJobRequest {
  AutoMLJobName?: string;
}
export const DescribeAutoMLJobRequest = S.suspend(() =>
  S.Struct({ AutoMLJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeAutoMLJobRequest",
}) as any as S.Schema<DescribeAutoMLJobRequest>;
export interface AutoMLPartialFailureReason {
  PartialFailureMessage?: string;
}
export const AutoMLPartialFailureReason = S.suspend(() =>
  S.Struct({ PartialFailureMessage: S.optional(S.String) }),
).annotate({
  identifier: "AutoMLPartialFailureReason",
}) as any as S.Schema<AutoMLPartialFailureReason>;
export type AutoMLPartialFailureReasons = AutoMLPartialFailureReason[];
export const AutoMLPartialFailureReasons = S.Array(AutoMLPartialFailureReason);
export type AutoMLJobObjectiveType = "Maximize" | "Minimize" | (string & {});
export const AutoMLJobObjectiveType = S.String;
export interface FinalAutoMLJobObjectiveMetric {
  Type?: AutoMLJobObjectiveType;
  MetricName?: AutoMLMetricEnum;
  Value?: number;
  StandardMetricName?: AutoMLMetricEnum;
}
export const FinalAutoMLJobObjectiveMetric = S.suspend(() =>
  S.Struct({
    Type: S.optional(AutoMLJobObjectiveType),
    MetricName: S.optional(AutoMLMetricEnum),
    Value: S.optional(S.Number),
    StandardMetricName: S.optional(AutoMLMetricEnum),
  }),
).annotate({
  identifier: "FinalAutoMLJobObjectiveMetric",
}) as any as S.Schema<FinalAutoMLJobObjectiveMetric>;
export type ObjectiveStatus =
  | "Succeeded"
  | "Pending"
  | "Failed"
  | (string & {});
export const ObjectiveStatus = S.String;
export type CandidateStepType =
  | "AWS::SageMaker::TrainingJob"
  | "AWS::SageMaker::TransformJob"
  | "AWS::SageMaker::ProcessingJob"
  | (string & {});
export const CandidateStepType = S.String;
export interface AutoMLCandidateStep {
  CandidateStepType?: CandidateStepType;
  CandidateStepArn?: string;
  CandidateStepName?: string;
}
export const AutoMLCandidateStep = S.suspend(() =>
  S.Struct({
    CandidateStepType: S.optional(CandidateStepType),
    CandidateStepArn: S.optional(S.String),
    CandidateStepName: S.optional(S.String),
  }),
).annotate({
  identifier: "AutoMLCandidateStep",
}) as any as S.Schema<AutoMLCandidateStep>;
export type CandidateSteps = AutoMLCandidateStep[];
export const CandidateSteps = S.Array(AutoMLCandidateStep);
export type CandidateStatus =
  | "Completed"
  | "InProgress"
  | "Failed"
  | "Stopped"
  | "Stopping"
  | (string & {});
export const CandidateStatus = S.String;
export interface AutoMLContainerDefinition {
  Image?: string;
  ModelDataUrl?: string;
  Environment?: { [key: string]: string | undefined };
}
export const AutoMLContainerDefinition = S.suspend(() =>
  S.Struct({
    Image: S.optional(S.String),
    ModelDataUrl: S.optional(S.String),
    Environment: S.optional(EnvironmentMap),
  }),
).annotate({
  identifier: "AutoMLContainerDefinition",
}) as any as S.Schema<AutoMLContainerDefinition>;
export type AutoMLContainerDefinitions = AutoMLContainerDefinition[];
export const AutoMLContainerDefinitions = S.Array(AutoMLContainerDefinition);
export interface CandidateArtifactLocations {
  Explainability?: string;
  ModelInsights?: string;
  BacktestResults?: string;
}
export const CandidateArtifactLocations = S.suspend(() =>
  S.Struct({
    Explainability: S.optional(S.String),
    ModelInsights: S.optional(S.String),
    BacktestResults: S.optional(S.String),
  }),
).annotate({
  identifier: "CandidateArtifactLocations",
}) as any as S.Schema<CandidateArtifactLocations>;
export type AutoMLMetricExtendedEnum =
  | "Accuracy"
  | "MSE"
  | "F1"
  | "F1macro"
  | "AUC"
  | "RMSE"
  | "MAE"
  | "R2"
  | "BalancedAccuracy"
  | "Precision"
  | "PrecisionMacro"
  | "Recall"
  | "RecallMacro"
  | "LogLoss"
  | "InferenceLatency"
  | "MAPE"
  | "MASE"
  | "WAPE"
  | "AverageWeightedQuantileLoss"
  | "Rouge1"
  | "Rouge2"
  | "RougeL"
  | "RougeLSum"
  | "Perplexity"
  | "ValidationLoss"
  | "TrainingLoss"
  | (string & {});
export const AutoMLMetricExtendedEnum = S.String;
export type MetricSetSource = "Train" | "Validation" | "Test" | (string & {});
export const MetricSetSource = S.String;
export interface MetricDatum {
  MetricName?: AutoMLMetricEnum;
  StandardMetricName?: AutoMLMetricExtendedEnum;
  Value?: number;
  Set?: MetricSetSource;
}
export const MetricDatum = S.suspend(() =>
  S.Struct({
    MetricName: S.optional(AutoMLMetricEnum),
    StandardMetricName: S.optional(AutoMLMetricExtendedEnum),
    Value: S.optional(S.Number),
    Set: S.optional(MetricSetSource),
  }),
).annotate({ identifier: "MetricDatum" }) as any as S.Schema<MetricDatum>;
export type MetricDataList = MetricDatum[];
export const MetricDataList = S.Array(MetricDatum);
export interface CandidateProperties {
  CandidateArtifactLocations?: CandidateArtifactLocations;
  CandidateMetrics?: MetricDatum[];
}
export const CandidateProperties = S.suspend(() =>
  S.Struct({
    CandidateArtifactLocations: S.optional(CandidateArtifactLocations),
    CandidateMetrics: S.optional(MetricDataList),
  }),
).annotate({
  identifier: "CandidateProperties",
}) as any as S.Schema<CandidateProperties>;
export type AutoMLProcessingUnit = "CPU" | "GPU" | (string & {});
export const AutoMLProcessingUnit = S.String;
export type AutoMLInferenceContainerDefinitions = {
  [key in AutoMLProcessingUnit]?: AutoMLContainerDefinition[];
};
export const AutoMLInferenceContainerDefinitions = S.Record(
  AutoMLProcessingUnit,
  AutoMLContainerDefinitions.pipe(S.optional),
);
export interface AutoMLCandidate {
  CandidateName?: string;
  FinalAutoMLJobObjectiveMetric?: FinalAutoMLJobObjectiveMetric;
  ObjectiveStatus?: ObjectiveStatus;
  CandidateSteps?: AutoMLCandidateStep[];
  CandidateStatus?: CandidateStatus;
  InferenceContainers?: AutoMLContainerDefinition[];
  CreationTime?: Date;
  EndTime?: Date;
  LastModifiedTime?: Date;
  FailureReason?: string;
  CandidateProperties?: CandidateProperties;
  InferenceContainerDefinitions?: {
    [key: string]: AutoMLContainerDefinition[] | undefined;
  };
}
export const AutoMLCandidate = S.suspend(() =>
  S.Struct({
    CandidateName: S.optional(S.String),
    FinalAutoMLJobObjectiveMetric: S.optional(FinalAutoMLJobObjectiveMetric),
    ObjectiveStatus: S.optional(ObjectiveStatus),
    CandidateSteps: S.optional(CandidateSteps),
    CandidateStatus: S.optional(CandidateStatus),
    InferenceContainers: S.optional(AutoMLContainerDefinitions),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    FailureReason: S.optional(S.String),
    CandidateProperties: S.optional(CandidateProperties),
    InferenceContainerDefinitions: S.optional(
      AutoMLInferenceContainerDefinitions,
    ),
  }),
).annotate({
  identifier: "AutoMLCandidate",
}) as any as S.Schema<AutoMLCandidate>;
export type AutoMLJobStatus =
  | "Completed"
  | "InProgress"
  | "Failed"
  | "Stopped"
  | "Stopping"
  | (string & {});
export const AutoMLJobStatus = S.String;
export type AutoMLJobSecondaryStatus =
  | "Starting"
  | "MaxCandidatesReached"
  | "Failed"
  | "Stopped"
  | "MaxAutoMLJobRuntimeReached"
  | "Stopping"
  | "CandidateDefinitionsGenerated"
  | "Completed"
  | "ExplainabilityError"
  | "DeployingModel"
  | "ModelDeploymentError"
  | "GeneratingModelInsightsReport"
  | "ModelInsightsError"
  | "AnalyzingData"
  | "FeatureEngineering"
  | "ModelTuning"
  | "GeneratingExplainabilityReport"
  | "TrainingModels"
  | "PreTraining"
  | (string & {});
export const AutoMLJobSecondaryStatus = S.String;
export interface AutoMLJobArtifacts {
  CandidateDefinitionNotebookLocation?: string;
  DataExplorationNotebookLocation?: string;
}
export const AutoMLJobArtifacts = S.suspend(() =>
  S.Struct({
    CandidateDefinitionNotebookLocation: S.optional(S.String),
    DataExplorationNotebookLocation: S.optional(S.String),
  }),
).annotate({
  identifier: "AutoMLJobArtifacts",
}) as any as S.Schema<AutoMLJobArtifacts>;
export interface ResolvedAttributes {
  AutoMLJobObjective?: AutoMLJobObjective;
  ProblemType?: ProblemType;
  CompletionCriteria?: AutoMLJobCompletionCriteria;
}
export const ResolvedAttributes = S.suspend(() =>
  S.Struct({
    AutoMLJobObjective: S.optional(AutoMLJobObjective),
    ProblemType: S.optional(ProblemType),
    CompletionCriteria: S.optional(AutoMLJobCompletionCriteria),
  }),
).annotate({
  identifier: "ResolvedAttributes",
}) as any as S.Schema<ResolvedAttributes>;
export interface ModelDeployResult {
  EndpointName?: string;
}
export const ModelDeployResult = S.suspend(() =>
  S.Struct({ EndpointName: S.optional(S.String) }),
).annotate({
  identifier: "ModelDeployResult",
}) as any as S.Schema<ModelDeployResult>;
export interface DescribeAutoMLJobResponse {
  AutoMLJobName: string;
  AutoMLJobArn: string;
  InputDataConfig: (AutoMLChannel & {
    TargetAttributeName: TargetAttributeName;
    DataSource: AutoMLDataSource & {
      S3DataSource: AutoMLS3DataSource & {
        S3DataType: AutoMLS3DataType;
        S3Uri: S3Uri;
      };
    };
  })[];
  OutputDataConfig: AutoMLOutputDataConfig & { S3OutputPath: S3Uri };
  RoleArn: string;
  AutoMLJobObjective?: AutoMLJobObjective & { MetricName: AutoMLMetricEnum };
  ProblemType?: ProblemType;
  AutoMLJobConfig?: AutoMLJobConfig & {
    SecurityConfig: AutoMLSecurityConfig & {
      VpcConfig: VpcConfig & {
        SecurityGroupIds: VpcSecurityGroupIds;
        Subnets: Subnets;
      };
    };
    CandidateGenerationConfig: AutoMLCandidateGenerationConfig & {
      AlgorithmsConfig: (AutoMLAlgorithmConfig & {
        AutoMLAlgorithms: AutoMLAlgorithms;
      })[];
    };
  };
  CreationTime: Date;
  EndTime?: Date;
  LastModifiedTime: Date;
  FailureReason?: string;
  PartialFailureReasons?: AutoMLPartialFailureReason[];
  BestCandidate?: AutoMLCandidate & {
    CandidateName: CandidateName;
    ObjectiveStatus: ObjectiveStatus;
    CandidateSteps: (AutoMLCandidateStep & {
      CandidateStepType: CandidateStepType;
      CandidateStepArn: CandidateStepArn;
      CandidateStepName: CandidateStepName;
    })[];
    CandidateStatus: CandidateStatus;
    CreationTime: Date;
    LastModifiedTime: Date;
    FinalAutoMLJobObjectiveMetric: FinalAutoMLJobObjectiveMetric & {
      MetricName: AutoMLMetricEnum;
      Value: MetricValue;
    };
    InferenceContainers: (AutoMLContainerDefinition & {
      Image: ContainerImage;
      ModelDataUrl: Url;
    })[];
    CandidateProperties: CandidateProperties & {
      CandidateArtifactLocations: CandidateArtifactLocations & {
        Explainability: ExplainabilityLocation;
      };
    };
    InferenceContainerDefinitions: {
      [key: string]:
        | (AutoMLContainerDefinition & {
            Image: ContainerImage;
            ModelDataUrl: Url;
          })[]
        | undefined;
    };
  };
  AutoMLJobStatus: AutoMLJobStatus;
  AutoMLJobSecondaryStatus: AutoMLJobSecondaryStatus;
  GenerateCandidateDefinitionsOnly?: boolean;
  AutoMLJobArtifacts?: AutoMLJobArtifacts;
  ResolvedAttributes?: ResolvedAttributes & {
    AutoMLJobObjective: AutoMLJobObjective & { MetricName: AutoMLMetricEnum };
  };
  ModelDeployConfig?: ModelDeployConfig;
  ModelDeployResult?: ModelDeployResult;
}
export const DescribeAutoMLJobResponse = S.suspend(() =>
  S.Struct({
    AutoMLJobName: S.optional(S.String),
    AutoMLJobArn: S.optional(S.String),
    InputDataConfig: S.optional(AutoMLInputDataConfig),
    OutputDataConfig: S.optional(AutoMLOutputDataConfig),
    RoleArn: S.optional(S.String),
    AutoMLJobObjective: S.optional(AutoMLJobObjective),
    ProblemType: S.optional(ProblemType),
    AutoMLJobConfig: S.optional(AutoMLJobConfig),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    FailureReason: S.optional(S.String),
    PartialFailureReasons: S.optional(AutoMLPartialFailureReasons),
    BestCandidate: S.optional(AutoMLCandidate),
    AutoMLJobStatus: S.optional(AutoMLJobStatus),
    AutoMLJobSecondaryStatus: S.optional(AutoMLJobSecondaryStatus),
    GenerateCandidateDefinitionsOnly: S.optional(S.Boolean),
    AutoMLJobArtifacts: S.optional(AutoMLJobArtifacts),
    ResolvedAttributes: S.optional(ResolvedAttributes),
    ModelDeployConfig: S.optional(ModelDeployConfig),
    ModelDeployResult: S.optional(ModelDeployResult),
  }).pipe(ns),
).annotate({
  identifier: "DescribeAutoMLJobResponse",
}) as any as S.Schema<DescribeAutoMLJobResponse>;
export interface DescribeAutoMLJobV2Request {
  AutoMLJobName?: string;
}
export const DescribeAutoMLJobV2Request = S.suspend(() =>
  S.Struct({ AutoMLJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeAutoMLJobV2Request",
}) as any as S.Schema<DescribeAutoMLJobV2Request>;
export type AutoMLProblemTypeConfigName =
  | "ImageClassification"
  | "TextClassification"
  | "TimeSeriesForecasting"
  | "Tabular"
  | "TextGeneration"
  | (string & {});
export const AutoMLProblemTypeConfigName = S.String;
export interface TabularResolvedAttributes {
  ProblemType?: ProblemType;
}
export const TabularResolvedAttributes = S.suspend(() =>
  S.Struct({ ProblemType: S.optional(ProblemType) }),
).annotate({
  identifier: "TabularResolvedAttributes",
}) as any as S.Schema<TabularResolvedAttributes>;
export interface TextGenerationResolvedAttributes {
  BaseModelName?: string;
}
export const TextGenerationResolvedAttributes = S.suspend(() =>
  S.Struct({ BaseModelName: S.optional(S.String) }),
).annotate({
  identifier: "TextGenerationResolvedAttributes",
}) as any as S.Schema<TextGenerationResolvedAttributes>;
export type AutoMLProblemTypeResolvedAttributes =
  | {
      TabularResolvedAttributes: TabularResolvedAttributes;
      TextGenerationResolvedAttributes?: never;
    }
  | {
      TabularResolvedAttributes?: never;
      TextGenerationResolvedAttributes: TextGenerationResolvedAttributes;
    };
export const AutoMLProblemTypeResolvedAttributes = S.Union([
  S.Struct({ TabularResolvedAttributes: TabularResolvedAttributes }),
  S.Struct({
    TextGenerationResolvedAttributes: TextGenerationResolvedAttributes,
  }),
]);
export interface AutoMLResolvedAttributes {
  AutoMLJobObjective?: AutoMLJobObjective;
  CompletionCriteria?: AutoMLJobCompletionCriteria;
  AutoMLProblemTypeResolvedAttributes?: AutoMLProblemTypeResolvedAttributes;
}
export const AutoMLResolvedAttributes = S.suspend(() =>
  S.Struct({
    AutoMLJobObjective: S.optional(AutoMLJobObjective),
    CompletionCriteria: S.optional(AutoMLJobCompletionCriteria),
    AutoMLProblemTypeResolvedAttributes: S.optional(
      AutoMLProblemTypeResolvedAttributes,
    ),
  }),
).annotate({
  identifier: "AutoMLResolvedAttributes",
}) as any as S.Schema<AutoMLResolvedAttributes>;
export interface DescribeAutoMLJobV2Response {
  AutoMLJobName: string;
  AutoMLJobArn: string;
  AutoMLJobInputDataConfig: (AutoMLJobChannel & {
    DataSource: AutoMLDataSource & {
      S3DataSource: AutoMLS3DataSource & {
        S3DataType: AutoMLS3DataType;
        S3Uri: S3Uri;
      };
    };
  })[];
  OutputDataConfig: AutoMLOutputDataConfig & { S3OutputPath: S3Uri };
  RoleArn: string;
  AutoMLJobObjective?: AutoMLJobObjective & { MetricName: AutoMLMetricEnum };
  AutoMLProblemTypeConfig?: AutoMLProblemTypeConfig;
  AutoMLProblemTypeConfigName?: AutoMLProblemTypeConfigName;
  CreationTime: Date;
  EndTime?: Date;
  LastModifiedTime: Date;
  FailureReason?: string;
  PartialFailureReasons?: AutoMLPartialFailureReason[];
  BestCandidate?: AutoMLCandidate & {
    CandidateName: CandidateName;
    ObjectiveStatus: ObjectiveStatus;
    CandidateSteps: (AutoMLCandidateStep & {
      CandidateStepType: CandidateStepType;
      CandidateStepArn: CandidateStepArn;
      CandidateStepName: CandidateStepName;
    })[];
    CandidateStatus: CandidateStatus;
    CreationTime: Date;
    LastModifiedTime: Date;
    FinalAutoMLJobObjectiveMetric: FinalAutoMLJobObjectiveMetric & {
      MetricName: AutoMLMetricEnum;
      Value: MetricValue;
    };
    InferenceContainers: (AutoMLContainerDefinition & {
      Image: ContainerImage;
      ModelDataUrl: Url;
    })[];
    CandidateProperties: CandidateProperties & {
      CandidateArtifactLocations: CandidateArtifactLocations & {
        Explainability: ExplainabilityLocation;
      };
    };
    InferenceContainerDefinitions: {
      [key: string]:
        | (AutoMLContainerDefinition & {
            Image: ContainerImage;
            ModelDataUrl: Url;
          })[]
        | undefined;
    };
  };
  AutoMLJobStatus: AutoMLJobStatus;
  AutoMLJobSecondaryStatus: AutoMLJobSecondaryStatus;
  AutoMLJobArtifacts?: AutoMLJobArtifacts;
  ResolvedAttributes?: AutoMLResolvedAttributes & {
    AutoMLJobObjective: AutoMLJobObjective & { MetricName: AutoMLMetricEnum };
  };
  ModelDeployConfig?: ModelDeployConfig;
  ModelDeployResult?: ModelDeployResult;
  DataSplitConfig?: AutoMLDataSplitConfig;
  SecurityConfig?: AutoMLSecurityConfig & {
    VpcConfig: VpcConfig & {
      SecurityGroupIds: VpcSecurityGroupIds;
      Subnets: Subnets;
    };
  };
  AutoMLComputeConfig?: AutoMLComputeConfig & {
    EmrServerlessComputeConfig: EmrServerlessComputeConfig & {
      ExecutionRoleARN: RoleArn;
    };
  };
}
export const DescribeAutoMLJobV2Response = S.suspend(() =>
  S.Struct({
    AutoMLJobName: S.optional(S.String),
    AutoMLJobArn: S.optional(S.String),
    AutoMLJobInputDataConfig: S.optional(AutoMLJobInputDataConfig),
    OutputDataConfig: S.optional(AutoMLOutputDataConfig),
    RoleArn: S.optional(S.String),
    AutoMLJobObjective: S.optional(AutoMLJobObjective),
    AutoMLProblemTypeConfig: S.optional(AutoMLProblemTypeConfig),
    AutoMLProblemTypeConfigName: S.optional(AutoMLProblemTypeConfigName),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    FailureReason: S.optional(S.String),
    PartialFailureReasons: S.optional(AutoMLPartialFailureReasons),
    BestCandidate: S.optional(AutoMLCandidate),
    AutoMLJobStatus: S.optional(AutoMLJobStatus),
    AutoMLJobSecondaryStatus: S.optional(AutoMLJobSecondaryStatus),
    AutoMLJobArtifacts: S.optional(AutoMLJobArtifacts),
    ResolvedAttributes: S.optional(AutoMLResolvedAttributes),
    ModelDeployConfig: S.optional(ModelDeployConfig),
    ModelDeployResult: S.optional(ModelDeployResult),
    DataSplitConfig: S.optional(AutoMLDataSplitConfig),
    SecurityConfig: S.optional(AutoMLSecurityConfig),
    AutoMLComputeConfig: S.optional(AutoMLComputeConfig),
  }).pipe(ns),
).annotate({
  identifier: "DescribeAutoMLJobV2Response",
}) as any as S.Schema<DescribeAutoMLJobV2Response>;
export interface DescribeClusterRequest {
  ClusterName?: string;
}
export const DescribeClusterRequest = S.suspend(() =>
  S.Struct({ ClusterName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeClusterRequest",
}) as any as S.Schema<DescribeClusterRequest>;
export type ClusterStatus =
  | "Creating"
  | "Deleting"
  | "Failed"
  | "InService"
  | "RollingBack"
  | "SystemUpdating"
  | "Updating"
  | (string & {});
export const ClusterStatus = S.String;
export type InstanceGroupStatus =
  | "InService"
  | "Creating"
  | "Updating"
  | "Failed"
  | "Degraded"
  | "SystemUpdating"
  | "Deleting"
  | (string & {});
export const InstanceGroupStatus = S.String;
export type ActiveClusterOperationName = "Scaling" | (string & {});
export const ActiveClusterOperationName = S.String;
export type ActiveOperations = { [key in ActiveClusterOperationName]?: number };
export const ActiveOperations = S.Record(
  ActiveClusterOperationName,
  S.Number.pipe(S.optional),
);
export interface ClusterKubernetesConfigDetails {
  CurrentLabels?: { [key: string]: string | undefined };
  DesiredLabels?: { [key: string]: string | undefined };
  CurrentTaints?: ClusterKubernetesTaint[];
  DesiredTaints?: ClusterKubernetesTaint[];
}
export const ClusterKubernetesConfigDetails = S.suspend(() =>
  S.Struct({
    CurrentLabels: S.optional(ClusterKubernetesLabels),
    DesiredLabels: S.optional(ClusterKubernetesLabels),
    CurrentTaints: S.optional(ClusterKubernetesTaints),
    DesiredTaints: S.optional(ClusterKubernetesTaints),
  }),
).annotate({
  identifier: "ClusterKubernetesConfigDetails",
}) as any as S.Schema<ClusterKubernetesConfigDetails>;
export type SoftwareUpdateStatus =
  | "Pending"
  | "InProgress"
  | "Succeeded"
  | "Failed"
  | "RollbackInProgress"
  | "RollbackComplete"
  | (string & {});
export const SoftwareUpdateStatus = S.String;
export interface ClusterInstanceGroupDetails {
  CurrentCount?: number;
  TargetCount?: number;
  MinCount?: number;
  InstanceGroupName?: string;
  InstanceType?: ClusterInstanceType;
  LifeCycleConfig?: ClusterLifeCycleConfig;
  ExecutionRole?: string;
  ThreadsPerCore?: number;
  InstanceStorageConfigs?: ClusterInstanceStorageConfig[];
  OnStartDeepHealthChecks?: DeepHealthCheckType[];
  Status?: InstanceGroupStatus;
  TrainingPlanArn?: string;
  TrainingPlanStatus?: string;
  OverrideVpcConfig?: VpcConfig;
  ScheduledUpdateConfig?: ScheduledUpdateConfig;
  CurrentImageId?: string;
  DesiredImageId?: string;
  ActiveOperations?: { [key: string]: number | undefined };
  KubernetesConfig?: ClusterKubernetesConfigDetails;
  CapacityRequirements?: ClusterCapacityRequirements;
  TargetStateCount?: number;
  SoftwareUpdateStatus?: SoftwareUpdateStatus;
  ActiveSoftwareUpdateConfig?: DeploymentConfiguration;
}
export const ClusterInstanceGroupDetails = S.suspend(() =>
  S.Struct({
    CurrentCount: S.optional(S.Number),
    TargetCount: S.optional(S.Number),
    MinCount: S.optional(S.Number),
    InstanceGroupName: S.optional(S.String),
    InstanceType: S.optional(ClusterInstanceType),
    LifeCycleConfig: S.optional(ClusterLifeCycleConfig),
    ExecutionRole: S.optional(S.String),
    ThreadsPerCore: S.optional(S.Number),
    InstanceStorageConfigs: S.optional(ClusterInstanceStorageConfigs),
    OnStartDeepHealthChecks: S.optional(OnStartDeepHealthChecks),
    Status: S.optional(InstanceGroupStatus),
    TrainingPlanArn: S.optional(S.String),
    TrainingPlanStatus: S.optional(S.String),
    OverrideVpcConfig: S.optional(VpcConfig),
    ScheduledUpdateConfig: S.optional(ScheduledUpdateConfig),
    CurrentImageId: S.optional(S.String),
    DesiredImageId: S.optional(S.String),
    ActiveOperations: S.optional(ActiveOperations),
    KubernetesConfig: S.optional(ClusterKubernetesConfigDetails),
    CapacityRequirements: S.optional(ClusterCapacityRequirements),
    TargetStateCount: S.optional(S.Number),
    SoftwareUpdateStatus: S.optional(SoftwareUpdateStatus),
    ActiveSoftwareUpdateConfig: S.optional(DeploymentConfiguration),
  }),
).annotate({
  identifier: "ClusterInstanceGroupDetails",
}) as any as S.Schema<ClusterInstanceGroupDetails>;
export type ClusterInstanceGroupDetailsList = ClusterInstanceGroupDetails[];
export const ClusterInstanceGroupDetailsList = S.Array(
  ClusterInstanceGroupDetails,
);
export interface EnvironmentConfigDetails {
  FSxLustreConfig?: FSxLustreConfig;
  S3OutputPath?: string;
}
export const EnvironmentConfigDetails = S.suspend(() =>
  S.Struct({
    FSxLustreConfig: S.optional(FSxLustreConfig),
    S3OutputPath: S.optional(S.String),
  }),
).annotate({
  identifier: "EnvironmentConfigDetails",
}) as any as S.Schema<EnvironmentConfigDetails>;
export interface ClusterRestrictedInstanceGroupDetails {
  CurrentCount?: number;
  TargetCount?: number;
  InstanceGroupName?: string;
  InstanceType?: ClusterInstanceType;
  ExecutionRole?: string;
  ThreadsPerCore?: number;
  InstanceStorageConfigs?: ClusterInstanceStorageConfig[];
  OnStartDeepHealthChecks?: DeepHealthCheckType[];
  Status?: InstanceGroupStatus;
  TrainingPlanArn?: string;
  TrainingPlanStatus?: string;
  OverrideVpcConfig?: VpcConfig;
  ScheduledUpdateConfig?: ScheduledUpdateConfig;
  EnvironmentConfig?: EnvironmentConfigDetails;
}
export const ClusterRestrictedInstanceGroupDetails = S.suspend(() =>
  S.Struct({
    CurrentCount: S.optional(S.Number),
    TargetCount: S.optional(S.Number),
    InstanceGroupName: S.optional(S.String),
    InstanceType: S.optional(ClusterInstanceType),
    ExecutionRole: S.optional(S.String),
    ThreadsPerCore: S.optional(S.Number),
    InstanceStorageConfigs: S.optional(ClusterInstanceStorageConfigs),
    OnStartDeepHealthChecks: S.optional(OnStartDeepHealthChecks),
    Status: S.optional(InstanceGroupStatus),
    TrainingPlanArn: S.optional(S.String),
    TrainingPlanStatus: S.optional(S.String),
    OverrideVpcConfig: S.optional(VpcConfig),
    ScheduledUpdateConfig: S.optional(ScheduledUpdateConfig),
    EnvironmentConfig: S.optional(EnvironmentConfigDetails),
  }),
).annotate({
  identifier: "ClusterRestrictedInstanceGroupDetails",
}) as any as S.Schema<ClusterRestrictedInstanceGroupDetails>;
export type ClusterRestrictedInstanceGroupDetailsList =
  ClusterRestrictedInstanceGroupDetails[];
export const ClusterRestrictedInstanceGroupDetailsList = S.Array(
  ClusterRestrictedInstanceGroupDetails,
);
export type ClusterAutoScalingStatus =
  | "InService"
  | "Failed"
  | "Creating"
  | "Deleting"
  | (string & {});
export const ClusterAutoScalingStatus = S.String;
export interface ClusterAutoScalingConfigOutput {
  Mode: ClusterAutoScalingMode;
  AutoScalerType?: ClusterAutoScalerType;
  Status: ClusterAutoScalingStatus;
  FailureMessage?: string;
}
export const ClusterAutoScalingConfigOutput = S.suspend(() =>
  S.Struct({
    Mode: ClusterAutoScalingMode,
    AutoScalerType: S.optional(ClusterAutoScalerType),
    Status: ClusterAutoScalingStatus,
    FailureMessage: S.optional(S.String),
  }),
).annotate({
  identifier: "ClusterAutoScalingConfigOutput",
}) as any as S.Schema<ClusterAutoScalingConfigOutput>;
export interface DescribeClusterResponse {
  ClusterArn: string;
  ClusterName?: string;
  ClusterStatus: ClusterStatus;
  CreationTime?: Date;
  FailureMessage?: string;
  InstanceGroups: (ClusterInstanceGroupDetails & {
    LifeCycleConfig: ClusterLifeCycleConfig & {
      SourceS3Uri: S3Uri;
      OnCreate: ClusterLifeCycleConfigFileName;
    };
    OverrideVpcConfig: VpcConfig & {
      SecurityGroupIds: VpcSecurityGroupIds;
      Subnets: Subnets;
    };
    ScheduledUpdateConfig: ScheduledUpdateConfig & {
      ScheduleExpression: CronScheduleExpression;
      DeploymentConfig: DeploymentConfiguration & {
        RollingUpdatePolicy: RollingDeploymentPolicy & {
          MaximumBatchSize: CapacitySizeConfig & {
            Type: NodeUnavailabilityType;
            Value: NodeUnavailabilityValue;
          };
          RollbackMaximumBatchSize: CapacitySizeConfig & {
            Type: NodeUnavailabilityType;
            Value: NodeUnavailabilityValue;
          };
        };
        AutoRollbackConfiguration: (AlarmDetails & { AlarmName: AlarmName })[];
      };
    };
    ActiveSoftwareUpdateConfig: DeploymentConfiguration & {
      RollingUpdatePolicy: RollingDeploymentPolicy & {
        MaximumBatchSize: CapacitySizeConfig & {
          Type: NodeUnavailabilityType;
          Value: NodeUnavailabilityValue;
        };
        RollbackMaximumBatchSize: CapacitySizeConfig & {
          Type: NodeUnavailabilityType;
          Value: NodeUnavailabilityValue;
        };
      };
      AutoRollbackConfiguration: (AlarmDetails & { AlarmName: AlarmName })[];
    };
  })[];
  RestrictedInstanceGroups?: (ClusterRestrictedInstanceGroupDetails & {
    OverrideVpcConfig: VpcConfig & {
      SecurityGroupIds: VpcSecurityGroupIds;
      Subnets: Subnets;
    };
    ScheduledUpdateConfig: ScheduledUpdateConfig & {
      ScheduleExpression: CronScheduleExpression;
      DeploymentConfig: DeploymentConfiguration & {
        RollingUpdatePolicy: RollingDeploymentPolicy & {
          MaximumBatchSize: CapacitySizeConfig & {
            Type: NodeUnavailabilityType;
            Value: NodeUnavailabilityValue;
          };
          RollbackMaximumBatchSize: CapacitySizeConfig & {
            Type: NodeUnavailabilityType;
            Value: NodeUnavailabilityValue;
          };
        };
        AutoRollbackConfiguration: (AlarmDetails & { AlarmName: AlarmName })[];
      };
    };
    EnvironmentConfig: EnvironmentConfigDetails & {
      FSxLustreConfig: FSxLustreConfig & {
        SizeInGiB: FSxLustreSizeInGiB;
        PerUnitStorageThroughput: FSxLustrePerUnitStorageThroughput;
      };
    };
  })[];
  VpcConfig?: VpcConfig & {
    SecurityGroupIds: VpcSecurityGroupIds;
    Subnets: Subnets;
  };
  Orchestrator?: ClusterOrchestrator & {
    Eks: ClusterOrchestratorEksConfig & { ClusterArn: EksClusterArn };
  };
  TieredStorageConfig?: ClusterTieredStorageConfig & {
    Mode: ClusterConfigMode;
  };
  NodeRecovery?: ClusterNodeRecovery;
  NodeProvisioningMode?: ClusterNodeProvisioningMode;
  ClusterRole?: string;
  AutoScaling?: ClusterAutoScalingConfigOutput;
}
export const DescribeClusterResponse = S.suspend(() =>
  S.Struct({
    ClusterArn: S.optional(S.String),
    ClusterName: S.optional(S.String),
    ClusterStatus: S.optional(ClusterStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    FailureMessage: S.optional(S.String),
    InstanceGroups: S.optional(ClusterInstanceGroupDetailsList),
    RestrictedInstanceGroups: S.optional(
      ClusterRestrictedInstanceGroupDetailsList,
    ),
    VpcConfig: S.optional(VpcConfig),
    Orchestrator: S.optional(ClusterOrchestrator),
    TieredStorageConfig: S.optional(ClusterTieredStorageConfig),
    NodeRecovery: S.optional(ClusterNodeRecovery),
    NodeProvisioningMode: S.optional(ClusterNodeProvisioningMode),
    ClusterRole: S.optional(S.String),
    AutoScaling: S.optional(ClusterAutoScalingConfigOutput),
  }).pipe(ns),
).annotate({
  identifier: "DescribeClusterResponse",
}) as any as S.Schema<DescribeClusterResponse>;
export interface DescribeClusterEventRequest {
  EventId?: string;
  ClusterName?: string;
}
export const DescribeClusterEventRequest = S.suspend(() =>
  S.Struct({
    EventId: S.optional(S.String),
    ClusterName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeClusterEventRequest",
}) as any as S.Schema<DescribeClusterEventRequest>;
export type ClusterEventResourceType =
  | "Cluster"
  | "InstanceGroup"
  | "Instance"
  | (string & {});
export const ClusterEventResourceType = S.String;
export type EksRoleAccessEntries = string[];
export const EksRoleAccessEntries = S.Array(S.String);
export interface ClusterMetadata {
  FailureMessage?: string;
  EksRoleAccessEntries?: string[];
  SlrAccessEntry?: string;
}
export const ClusterMetadata = S.suspend(() =>
  S.Struct({
    FailureMessage: S.optional(S.String),
    EksRoleAccessEntries: S.optional(EksRoleAccessEntries),
    SlrAccessEntry: S.optional(S.String),
  }),
).annotate({
  identifier: "ClusterMetadata",
}) as any as S.Schema<ClusterMetadata>;
export type CapacityReservationType = "ODCR" | "CRG" | (string & {});
export const CapacityReservationType = S.String;
export interface CapacityReservation {
  Arn?: string;
  Type?: CapacityReservationType;
}
export const CapacityReservation = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Type: S.optional(CapacityReservationType),
  }),
).annotate({
  identifier: "CapacityReservation",
}) as any as S.Schema<CapacityReservation>;
export interface InstanceGroupMetadata {
  FailureMessage?: string;
  AvailabilityZoneId?: string;
  CapacityReservation?: CapacityReservation;
  SubnetId?: string;
  SecurityGroupIds?: string[];
  AmiOverride?: string;
}
export const InstanceGroupMetadata = S.suspend(() =>
  S.Struct({
    FailureMessage: S.optional(S.String),
    AvailabilityZoneId: S.optional(S.String),
    CapacityReservation: S.optional(CapacityReservation),
    SubnetId: S.optional(S.String),
    SecurityGroupIds: S.optional(SecurityGroupIds),
    AmiOverride: S.optional(S.String),
  }),
).annotate({
  identifier: "InstanceGroupMetadata",
}) as any as S.Schema<InstanceGroupMetadata>;
export interface InstanceGroupScalingMetadata {
  InstanceCount?: number;
  TargetCount?: number;
  MinCount?: number;
  FailureMessage?: string;
}
export const InstanceGroupScalingMetadata = S.suspend(() =>
  S.Struct({
    InstanceCount: S.optional(S.Number),
    TargetCount: S.optional(S.Number),
    MinCount: S.optional(S.Number),
    FailureMessage: S.optional(S.String),
  }),
).annotate({
  identifier: "InstanceGroupScalingMetadata",
}) as any as S.Schema<InstanceGroupScalingMetadata>;
export type EfaEnis = string[];
export const EfaEnis = S.Array(S.String);
export interface AdditionalEnis {
  EfaEnis?: string[];
}
export const AdditionalEnis = S.suspend(() =>
  S.Struct({ EfaEnis: S.optional(EfaEnis) }),
).annotate({ identifier: "AdditionalEnis" }) as any as S.Schema<AdditionalEnis>;
export interface InstanceMetadata {
  CustomerEni?: string;
  AdditionalEnis?: AdditionalEnis;
  CapacityReservation?: CapacityReservation;
  FailureMessage?: string;
  LcsExecutionState?: string;
  NodeLogicalId?: string;
}
export const InstanceMetadata = S.suspend(() =>
  S.Struct({
    CustomerEni: S.optional(S.String),
    AdditionalEnis: S.optional(AdditionalEnis),
    CapacityReservation: S.optional(CapacityReservation),
    FailureMessage: S.optional(S.String),
    LcsExecutionState: S.optional(S.String),
    NodeLogicalId: S.optional(S.String),
  }),
).annotate({
  identifier: "InstanceMetadata",
}) as any as S.Schema<InstanceMetadata>;
export type EventMetadata =
  | {
      Cluster: ClusterMetadata;
      InstanceGroup?: never;
      InstanceGroupScaling?: never;
      Instance?: never;
    }
  | {
      Cluster?: never;
      InstanceGroup: InstanceGroupMetadata;
      InstanceGroupScaling?: never;
      Instance?: never;
    }
  | {
      Cluster?: never;
      InstanceGroup?: never;
      InstanceGroupScaling: InstanceGroupScalingMetadata;
      Instance?: never;
    }
  | {
      Cluster?: never;
      InstanceGroup?: never;
      InstanceGroupScaling?: never;
      Instance: InstanceMetadata;
    };
export const EventMetadata = S.Union([
  S.Struct({ Cluster: ClusterMetadata }),
  S.Struct({ InstanceGroup: InstanceGroupMetadata }),
  S.Struct({ InstanceGroupScaling: InstanceGroupScalingMetadata }),
  S.Struct({ Instance: InstanceMetadata }),
]);
export interface EventDetails {
  EventMetadata?: EventMetadata;
}
export const EventDetails = S.suspend(() =>
  S.Struct({ EventMetadata: S.optional(EventMetadata) }),
).annotate({ identifier: "EventDetails" }) as any as S.Schema<EventDetails>;
export interface ClusterEventDetail {
  EventId?: string;
  ClusterArn?: string;
  ClusterName?: string;
  InstanceGroupName?: string;
  InstanceId?: string;
  ResourceType?: ClusterEventResourceType;
  EventTime?: Date;
  EventDetails?: EventDetails;
  Description?: string;
}
export const ClusterEventDetail = S.suspend(() =>
  S.Struct({
    EventId: S.optional(S.String),
    ClusterArn: S.optional(S.String),
    ClusterName: S.optional(S.String),
    InstanceGroupName: S.optional(S.String),
    InstanceId: S.optional(S.String),
    ResourceType: S.optional(ClusterEventResourceType),
    EventTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EventDetails: S.optional(EventDetails),
    Description: S.optional(S.String),
  }),
).annotate({
  identifier: "ClusterEventDetail",
}) as any as S.Schema<ClusterEventDetail>;
export interface DescribeClusterEventResponse {
  EventDetails?: ClusterEventDetail & {
    EventId: EventId;
    ClusterArn: ClusterArn;
    ClusterName: ClusterName;
    ResourceType: ClusterEventResourceType;
    EventTime: Date;
  };
}
export const DescribeClusterEventResponse = S.suspend(() =>
  S.Struct({ EventDetails: S.optional(ClusterEventDetail) }).pipe(ns),
).annotate({
  identifier: "DescribeClusterEventResponse",
}) as any as S.Schema<DescribeClusterEventResponse>;
export interface DescribeClusterNodeRequest {
  ClusterName?: string;
  NodeId?: string;
  NodeLogicalId?: string;
}
export const DescribeClusterNodeRequest = S.suspend(() =>
  S.Struct({
    ClusterName: S.optional(S.String),
    NodeId: S.optional(S.String),
    NodeLogicalId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeClusterNodeRequest",
}) as any as S.Schema<DescribeClusterNodeRequest>;
export interface ClusterInstanceStatusDetails {
  Status?: ClusterInstanceStatus;
  Message?: string;
}
export const ClusterInstanceStatusDetails = S.suspend(() =>
  S.Struct({
    Status: S.optional(ClusterInstanceStatus),
    Message: S.optional(S.String),
  }),
).annotate({
  identifier: "ClusterInstanceStatusDetails",
}) as any as S.Schema<ClusterInstanceStatusDetails>;
export interface ClusterInstancePlacement {
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
}
export const ClusterInstancePlacement = S.suspend(() =>
  S.Struct({
    AvailabilityZone: S.optional(S.String),
    AvailabilityZoneId: S.optional(S.String),
  }),
).annotate({
  identifier: "ClusterInstancePlacement",
}) as any as S.Schema<ClusterInstancePlacement>;
export interface UltraServerInfo {
  Id?: string;
}
export const UltraServerInfo = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String) }),
).annotate({
  identifier: "UltraServerInfo",
}) as any as S.Schema<UltraServerInfo>;
export interface ClusterKubernetesConfigNodeDetails {
  CurrentLabels?: { [key: string]: string | undefined };
  DesiredLabels?: { [key: string]: string | undefined };
  CurrentTaints?: ClusterKubernetesTaint[];
  DesiredTaints?: ClusterKubernetesTaint[];
}
export const ClusterKubernetesConfigNodeDetails = S.suspend(() =>
  S.Struct({
    CurrentLabels: S.optional(ClusterKubernetesLabels),
    DesiredLabels: S.optional(ClusterKubernetesLabels),
    CurrentTaints: S.optional(ClusterKubernetesTaints),
    DesiredTaints: S.optional(ClusterKubernetesTaints),
  }),
).annotate({
  identifier: "ClusterKubernetesConfigNodeDetails",
}) as any as S.Schema<ClusterKubernetesConfigNodeDetails>;
export type ClusterCapacityType = "Spot" | "OnDemand" | (string & {});
export const ClusterCapacityType = S.String;
export interface ClusterNodeDetails {
  InstanceGroupName?: string;
  InstanceId?: string;
  NodeLogicalId?: string;
  InstanceStatus?: ClusterInstanceStatusDetails;
  InstanceType?: ClusterInstanceType;
  LaunchTime?: Date;
  LastSoftwareUpdateTime?: Date;
  LifeCycleConfig?: ClusterLifeCycleConfig;
  OverrideVpcConfig?: VpcConfig;
  ThreadsPerCore?: number;
  InstanceStorageConfigs?: ClusterInstanceStorageConfig[];
  PrivatePrimaryIp?: string;
  PrivatePrimaryIpv6?: string;
  PrivateDnsHostname?: string;
  Placement?: ClusterInstancePlacement;
  CurrentImageId?: string;
  DesiredImageId?: string;
  UltraServerInfo?: UltraServerInfo;
  KubernetesConfig?: ClusterKubernetesConfigNodeDetails;
  CapacityType?: ClusterCapacityType;
}
export const ClusterNodeDetails = S.suspend(() =>
  S.Struct({
    InstanceGroupName: S.optional(S.String),
    InstanceId: S.optional(S.String),
    NodeLogicalId: S.optional(S.String),
    InstanceStatus: S.optional(ClusterInstanceStatusDetails),
    InstanceType: S.optional(ClusterInstanceType),
    LaunchTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastSoftwareUpdateTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LifeCycleConfig: S.optional(ClusterLifeCycleConfig),
    OverrideVpcConfig: S.optional(VpcConfig),
    ThreadsPerCore: S.optional(S.Number),
    InstanceStorageConfigs: S.optional(ClusterInstanceStorageConfigs),
    PrivatePrimaryIp: S.optional(S.String),
    PrivatePrimaryIpv6: S.optional(S.String),
    PrivateDnsHostname: S.optional(S.String),
    Placement: S.optional(ClusterInstancePlacement),
    CurrentImageId: S.optional(S.String),
    DesiredImageId: S.optional(S.String),
    UltraServerInfo: S.optional(UltraServerInfo),
    KubernetesConfig: S.optional(ClusterKubernetesConfigNodeDetails),
    CapacityType: S.optional(ClusterCapacityType),
  }),
).annotate({
  identifier: "ClusterNodeDetails",
}) as any as S.Schema<ClusterNodeDetails>;
export interface DescribeClusterNodeResponse {
  NodeDetails: ClusterNodeDetails & {
    InstanceStatus: ClusterInstanceStatusDetails & {
      Status: ClusterInstanceStatus;
    };
    LifeCycleConfig: ClusterLifeCycleConfig & {
      SourceS3Uri: S3Uri;
      OnCreate: ClusterLifeCycleConfigFileName;
    };
    OverrideVpcConfig: VpcConfig & {
      SecurityGroupIds: VpcSecurityGroupIds;
      Subnets: Subnets;
    };
  };
}
export const DescribeClusterNodeResponse = S.suspend(() =>
  S.Struct({ NodeDetails: S.optional(ClusterNodeDetails) }).pipe(ns),
).annotate({
  identifier: "DescribeClusterNodeResponse",
}) as any as S.Schema<DescribeClusterNodeResponse>;
export interface DescribeClusterSchedulerConfigRequest {
  ClusterSchedulerConfigId?: string;
  ClusterSchedulerConfigVersion?: number;
}
export const DescribeClusterSchedulerConfigRequest = S.suspend(() =>
  S.Struct({
    ClusterSchedulerConfigId: S.optional(S.String),
    ClusterSchedulerConfigVersion: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeClusterSchedulerConfigRequest",
}) as any as S.Schema<DescribeClusterSchedulerConfigRequest>;
export type SchedulerResourceStatus =
  | "Creating"
  | "CreateFailed"
  | "CreateRollbackFailed"
  | "Created"
  | "Updating"
  | "UpdateFailed"
  | "UpdateRollbackFailed"
  | "Updated"
  | "Deleting"
  | "DeleteFailed"
  | "DeleteRollbackFailed"
  | "Deleted"
  | (string & {});
export const SchedulerResourceStatus = S.String;
export interface DescribeClusterSchedulerConfigResponse {
  ClusterSchedulerConfigArn: string;
  ClusterSchedulerConfigId: string;
  Name: string;
  ClusterSchedulerConfigVersion: number;
  Status: SchedulerResourceStatus;
  FailureReason?: string;
  ClusterArn?: string;
  SchedulerConfig?: SchedulerConfig & {
    PriorityClasses: (PriorityClass & {
      Name: ClusterSchedulerPriorityClassName;
      Weight: PriorityWeight;
    })[];
  };
  Description?: string;
  CreationTime: Date;
  CreatedBy?: UserContext;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
}
export const DescribeClusterSchedulerConfigResponse = S.suspend(() =>
  S.Struct({
    ClusterSchedulerConfigArn: S.optional(S.String),
    ClusterSchedulerConfigId: S.optional(S.String),
    Name: S.optional(S.String),
    ClusterSchedulerConfigVersion: S.optional(S.Number),
    Status: S.optional(SchedulerResourceStatus),
    FailureReason: S.optional(S.String),
    ClusterArn: S.optional(S.String),
    SchedulerConfig: S.optional(SchedulerConfig),
    Description: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
  }).pipe(ns),
).annotate({
  identifier: "DescribeClusterSchedulerConfigResponse",
}) as any as S.Schema<DescribeClusterSchedulerConfigResponse>;
export interface DescribeCodeRepositoryInput {
  CodeRepositoryName?: string;
}
export const DescribeCodeRepositoryInput = S.suspend(() =>
  S.Struct({ CodeRepositoryName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeCodeRepositoryInput",
}) as any as S.Schema<DescribeCodeRepositoryInput>;
export interface DescribeCodeRepositoryOutput {
  CodeRepositoryName: string;
  CodeRepositoryArn: string;
  CreationTime: Date;
  LastModifiedTime: Date;
  GitConfig?: GitConfig & { RepositoryUrl: GitConfigUrl };
}
export const DescribeCodeRepositoryOutput = S.suspend(() =>
  S.Struct({
    CodeRepositoryName: S.optional(S.String),
    CodeRepositoryArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    GitConfig: S.optional(GitConfig),
  }).pipe(ns),
).annotate({
  identifier: "DescribeCodeRepositoryOutput",
}) as any as S.Schema<DescribeCodeRepositoryOutput>;
export interface DescribeCompilationJobRequest {
  CompilationJobName?: string;
}
export const DescribeCompilationJobRequest = S.suspend(() =>
  S.Struct({ CompilationJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeCompilationJobRequest",
}) as any as S.Schema<DescribeCompilationJobRequest>;
export type CompilationJobStatus =
  | "INPROGRESS"
  | "COMPLETED"
  | "FAILED"
  | "STARTING"
  | "STOPPING"
  | "STOPPED"
  | (string & {});
export const CompilationJobStatus = S.String;
export interface ModelArtifacts {
  S3ModelArtifacts?: string;
}
export const ModelArtifacts = S.suspend(() =>
  S.Struct({ S3ModelArtifacts: S.optional(S.String) }),
).annotate({ identifier: "ModelArtifacts" }) as any as S.Schema<ModelArtifacts>;
export interface ModelDigests {
  ArtifactDigest?: string;
}
export const ModelDigests = S.suspend(() =>
  S.Struct({ ArtifactDigest: S.optional(S.String) }),
).annotate({ identifier: "ModelDigests" }) as any as S.Schema<ModelDigests>;
export interface DerivedInformation {
  DerivedDataInputConfig?: string;
}
export const DerivedInformation = S.suspend(() =>
  S.Struct({ DerivedDataInputConfig: S.optional(S.String) }),
).annotate({
  identifier: "DerivedInformation",
}) as any as S.Schema<DerivedInformation>;
export interface DescribeCompilationJobResponse {
  CompilationJobName: string;
  CompilationJobArn: string;
  CompilationJobStatus: CompilationJobStatus;
  CompilationStartTime?: Date;
  CompilationEndTime?: Date;
  StoppingCondition: StoppingCondition;
  InferenceImage?: string;
  ModelPackageVersionArn?: string;
  CreationTime: Date;
  LastModifiedTime: Date;
  FailureReason: string;
  ModelArtifacts: ModelArtifacts & { S3ModelArtifacts: S3Uri };
  ModelDigests?: ModelDigests;
  RoleArn: string;
  InputConfig: InputConfig & { S3Uri: S3Uri; Framework: Framework };
  OutputConfig: OutputConfig & {
    S3OutputLocation: S3Uri;
    TargetPlatform: TargetPlatform & {
      Os: TargetPlatformOs;
      Arch: TargetPlatformArch;
    };
  };
  VpcConfig?: NeoVpcConfig & {
    SecurityGroupIds: NeoVpcSecurityGroupIds;
    Subnets: NeoVpcSubnets;
  };
  DerivedInformation?: DerivedInformation;
}
export const DescribeCompilationJobResponse = S.suspend(() =>
  S.Struct({
    CompilationJobName: S.optional(S.String),
    CompilationJobArn: S.optional(S.String),
    CompilationJobStatus: S.optional(CompilationJobStatus),
    CompilationStartTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CompilationEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    StoppingCondition: S.optional(StoppingCondition),
    InferenceImage: S.optional(S.String),
    ModelPackageVersionArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    FailureReason: S.optional(S.String),
    ModelArtifacts: S.optional(ModelArtifacts),
    ModelDigests: S.optional(ModelDigests),
    RoleArn: S.optional(S.String),
    InputConfig: S.optional(InputConfig),
    OutputConfig: S.optional(OutputConfig),
    VpcConfig: S.optional(NeoVpcConfig),
    DerivedInformation: S.optional(DerivedInformation),
  }).pipe(ns),
).annotate({
  identifier: "DescribeCompilationJobResponse",
}) as any as S.Schema<DescribeCompilationJobResponse>;
export interface DescribeComputeQuotaRequest {
  ComputeQuotaId?: string;
  ComputeQuotaVersion?: number;
}
export const DescribeComputeQuotaRequest = S.suspend(() =>
  S.Struct({
    ComputeQuotaId: S.optional(S.String),
    ComputeQuotaVersion: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeComputeQuotaRequest",
}) as any as S.Schema<DescribeComputeQuotaRequest>;
export interface DescribeComputeQuotaResponse {
  ComputeQuotaArn: string;
  ComputeQuotaId: string;
  Name: string;
  Description?: string;
  ComputeQuotaVersion: number;
  Status: SchedulerResourceStatus;
  FailureReason?: string;
  ClusterArn?: string;
  ComputeQuotaConfig?: ComputeQuotaConfig & {
    ComputeQuotaResources: (ComputeQuotaResourceConfig & {
      InstanceType: ClusterInstanceType;
      AcceleratorPartition: AcceleratorPartitionConfig & {
        Type: MIGProfileType;
        Count: number;
      };
    })[];
    ResourceSharingConfig: ResourceSharingConfig & {
      Strategy: ResourceSharingStrategy;
    };
  };
  ComputeQuotaTarget: ComputeQuotaTarget & {
    TeamName: ComputeQuotaTargetTeamName;
  };
  ActivationState?: ActivationState;
  CreationTime: Date;
  CreatedBy?: UserContext;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
}
export const DescribeComputeQuotaResponse = S.suspend(() =>
  S.Struct({
    ComputeQuotaArn: S.optional(S.String),
    ComputeQuotaId: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    ComputeQuotaVersion: S.optional(S.Number),
    Status: S.optional(SchedulerResourceStatus),
    FailureReason: S.optional(S.String),
    ClusterArn: S.optional(S.String),
    ComputeQuotaConfig: S.optional(ComputeQuotaConfig),
    ComputeQuotaTarget: S.optional(ComputeQuotaTarget),
    ActivationState: S.optional(ActivationState),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
  }).pipe(ns),
).annotate({
  identifier: "DescribeComputeQuotaResponse",
}) as any as S.Schema<DescribeComputeQuotaResponse>;
export interface DescribeContextRequest {
  ContextName?: string;
}
export const DescribeContextRequest = S.suspend(() =>
  S.Struct({ ContextName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeContextRequest",
}) as any as S.Schema<DescribeContextRequest>;
export interface DescribeContextResponse {
  ContextName?: string;
  ContextArn?: string;
  Source?: ContextSource & { SourceUri: SourceUri };
  ContextType?: string;
  Description?: string;
  Properties?: { [key: string]: string | undefined };
  CreationTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
  LineageGroupArn?: string;
}
export const DescribeContextResponse = S.suspend(() =>
  S.Struct({
    ContextName: S.optional(S.String),
    ContextArn: S.optional(S.String),
    Source: S.optional(ContextSource),
    ContextType: S.optional(S.String),
    Description: S.optional(S.String),
    Properties: S.optional(LineageEntityParameters),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
    LineageGroupArn: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "DescribeContextResponse",
}) as any as S.Schema<DescribeContextResponse>;
export interface DescribeDataQualityJobDefinitionRequest {
  JobDefinitionName?: string;
}
export const DescribeDataQualityJobDefinitionRequest = S.suspend(() =>
  S.Struct({ JobDefinitionName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeDataQualityJobDefinitionRequest",
}) as any as S.Schema<DescribeDataQualityJobDefinitionRequest>;
export interface DescribeDataQualityJobDefinitionResponse {
  JobDefinitionArn: string;
  JobDefinitionName: string;
  CreationTime: Date;
  DataQualityBaselineConfig?: DataQualityBaselineConfig;
  DataQualityAppSpecification: DataQualityAppSpecification & {
    ImageUri: ImageUri;
  };
  DataQualityJobInput: DataQualityJobInput & {
    EndpointInput: EndpointInput & {
      EndpointName: EndpointName;
      LocalPath: ProcessingLocalPath;
    };
    BatchTransformInput: BatchTransformInput & {
      DataCapturedDestinationS3Uri: DestinationS3Uri;
      DatasetFormat: MonitoringDatasetFormat;
      LocalPath: ProcessingLocalPath;
    };
  };
  DataQualityJobOutputConfig: MonitoringOutputConfig & {
    MonitoringOutputs: (MonitoringOutput & {
      S3Output: MonitoringS3Output & {
        S3Uri: MonitoringS3Uri;
        LocalPath: ProcessingLocalPath;
      };
    })[];
  };
  JobResources: MonitoringResources & {
    ClusterConfig: MonitoringClusterConfig & {
      InstanceCount: ProcessingInstanceCount;
      InstanceType: ProcessingInstanceType;
      VolumeSizeInGB: ProcessingVolumeSizeInGB;
    };
  };
  NetworkConfig?: MonitoringNetworkConfig & {
    VpcConfig: VpcConfig & {
      SecurityGroupIds: VpcSecurityGroupIds;
      Subnets: Subnets;
    };
  };
  RoleArn: string;
  StoppingCondition?: MonitoringStoppingCondition & {
    MaxRuntimeInSeconds: MonitoringMaxRuntimeInSeconds;
  };
}
export const DescribeDataQualityJobDefinitionResponse = S.suspend(() =>
  S.Struct({
    JobDefinitionArn: S.optional(S.String),
    JobDefinitionName: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    DataQualityBaselineConfig: S.optional(DataQualityBaselineConfig),
    DataQualityAppSpecification: S.optional(DataQualityAppSpecification),
    DataQualityJobInput: S.optional(DataQualityJobInput),
    DataQualityJobOutputConfig: S.optional(MonitoringOutputConfig),
    JobResources: S.optional(MonitoringResources),
    NetworkConfig: S.optional(MonitoringNetworkConfig),
    RoleArn: S.optional(S.String),
    StoppingCondition: S.optional(MonitoringStoppingCondition),
  }).pipe(ns),
).annotate({
  identifier: "DescribeDataQualityJobDefinitionResponse",
}) as any as S.Schema<DescribeDataQualityJobDefinitionResponse>;
export interface DescribeDeviceRequest {
  NextToken?: string;
  DeviceName?: string;
  DeviceFleetName?: string;
}
export const DescribeDeviceRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    DeviceName: S.optional(S.String),
    DeviceFleetName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeDeviceRequest",
}) as any as S.Schema<DescribeDeviceRequest>;
export interface EdgeModel {
  ModelName?: string;
  ModelVersion?: string;
  LatestSampleTime?: Date;
  LatestInference?: Date;
}
export const EdgeModel = S.suspend(() =>
  S.Struct({
    ModelName: S.optional(S.String),
    ModelVersion: S.optional(S.String),
    LatestSampleTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LatestInference: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({ identifier: "EdgeModel" }) as any as S.Schema<EdgeModel>;
export type EdgeModels = EdgeModel[];
export const EdgeModels = S.Array(EdgeModel);
export interface DescribeDeviceResponse {
  DeviceArn?: string;
  DeviceName: string;
  Description?: string;
  DeviceFleetName: string;
  IotThingName?: string;
  RegistrationTime: Date;
  LatestHeartbeat?: Date;
  Models?: (EdgeModel & { ModelName: EntityName; ModelVersion: EdgeVersion })[];
  MaxModels?: number;
  NextToken?: string;
  AgentVersion?: string;
}
export const DescribeDeviceResponse = S.suspend(() =>
  S.Struct({
    DeviceArn: S.optional(S.String),
    DeviceName: S.optional(S.String),
    Description: S.optional(S.String),
    DeviceFleetName: S.optional(S.String),
    IotThingName: S.optional(S.String),
    RegistrationTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LatestHeartbeat: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    Models: S.optional(EdgeModels),
    MaxModels: S.optional(S.Number),
    NextToken: S.optional(S.String),
    AgentVersion: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "DescribeDeviceResponse",
}) as any as S.Schema<DescribeDeviceResponse>;
export interface DescribeDeviceFleetRequest {
  DeviceFleetName?: string;
}
export const DescribeDeviceFleetRequest = S.suspend(() =>
  S.Struct({ DeviceFleetName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeDeviceFleetRequest",
}) as any as S.Schema<DescribeDeviceFleetRequest>;
export interface DescribeDeviceFleetResponse {
  DeviceFleetName: string;
  DeviceFleetArn: string;
  OutputConfig: EdgeOutputConfig & { S3OutputLocation: S3Uri };
  Description?: string;
  CreationTime: Date;
  LastModifiedTime: Date;
  RoleArn?: string;
  IotRoleAlias?: string;
}
export const DescribeDeviceFleetResponse = S.suspend(() =>
  S.Struct({
    DeviceFleetName: S.optional(S.String),
    DeviceFleetArn: S.optional(S.String),
    OutputConfig: S.optional(EdgeOutputConfig),
    Description: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    RoleArn: S.optional(S.String),
    IotRoleAlias: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "DescribeDeviceFleetResponse",
}) as any as S.Schema<DescribeDeviceFleetResponse>;
export interface DescribeDomainRequest {
  DomainId?: string;
}
export const DescribeDomainRequest = S.suspend(() =>
  S.Struct({ DomainId: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeDomainRequest",
}) as any as S.Schema<DescribeDomainRequest>;
export type DomainStatus =
  | "Deleting"
  | "Failed"
  | "InService"
  | "Pending"
  | "Updating"
  | "Update_Failed"
  | "Delete_Failed"
  | (string & {});
export const DomainStatus = S.String;
export interface DescribeDomainResponse {
  DomainArn?: string;
  DomainId?: string;
  DomainName?: string;
  HomeEfsFileSystemId?: string;
  SingleSignOnManagedApplicationInstanceId?: string;
  SingleSignOnApplicationArn?: string;
  Status?: DomainStatus;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  FailureReason?: string;
  SecurityGroupIdForDomainBoundary?: string;
  AuthMode?: AuthMode;
  DefaultUserSettings?: UserSettings & {
    JupyterServerAppSettings: JupyterServerAppSettings & {
      CodeRepositories: (CodeRepository & { RepositoryUrl: RepositoryUrl })[];
    };
    KernelGatewayAppSettings: KernelGatewayAppSettings & {
      CustomImages: (CustomImage & {
        ImageName: ImageName;
        AppImageConfigName: AppImageConfigName;
      })[];
    };
    RSessionAppSettings: RSessionAppSettings & {
      CustomImages: (CustomImage & {
        ImageName: ImageName;
        AppImageConfigName: AppImageConfigName;
      })[];
    };
    CodeEditorAppSettings: CodeEditorAppSettings & {
      CustomImages: (CustomImage & {
        ImageName: ImageName;
        AppImageConfigName: AppImageConfigName;
      })[];
    };
    JupyterLabAppSettings: JupyterLabAppSettings & {
      CustomImages: (CustomImage & {
        ImageName: ImageName;
        AppImageConfigName: AppImageConfigName;
      })[];
      CodeRepositories: (CodeRepository & { RepositoryUrl: RepositoryUrl })[];
    };
    SpaceStorageSettings: DefaultSpaceStorageSettings & {
      DefaultEbsStorageSettings: DefaultEbsStorageSettings & {
        DefaultEbsVolumeSizeInGb: SpaceEbsVolumeSizeInGb;
        MaximumEbsVolumeSizeInGb: SpaceEbsVolumeSizeInGb;
      };
    };
    CustomPosixUserConfig: CustomPosixUserConfig & { Uid: Uid; Gid: Gid };
  };
  DomainSettings?: DomainSettings & {
    RStudioServerProDomainSettings: RStudioServerProDomainSettings & {
      DomainExecutionRoleArn: RoleArn;
    };
    TrustedIdentityPropagationSettings: TrustedIdentityPropagationSettings & {
      Status: FeatureStatus;
    };
  };
  AppNetworkAccessType?: AppNetworkAccessType;
  HomeEfsFileSystemKmsKeyId?: string;
  SubnetIds?: string[];
  Url?: string;
  VpcId?: string;
  KmsKeyId?: string;
  AppSecurityGroupManagement?: AppSecurityGroupManagement;
  TagPropagation?: TagPropagation;
  DefaultSpaceSettings?: DefaultSpaceSettings & {
    JupyterServerAppSettings: JupyterServerAppSettings & {
      CodeRepositories: (CodeRepository & { RepositoryUrl: RepositoryUrl })[];
    };
    KernelGatewayAppSettings: KernelGatewayAppSettings & {
      CustomImages: (CustomImage & {
        ImageName: ImageName;
        AppImageConfigName: AppImageConfigName;
      })[];
    };
    JupyterLabAppSettings: JupyterLabAppSettings & {
      CustomImages: (CustomImage & {
        ImageName: ImageName;
        AppImageConfigName: AppImageConfigName;
      })[];
      CodeRepositories: (CodeRepository & { RepositoryUrl: RepositoryUrl })[];
    };
    SpaceStorageSettings: DefaultSpaceStorageSettings & {
      DefaultEbsStorageSettings: DefaultEbsStorageSettings & {
        DefaultEbsVolumeSizeInGb: SpaceEbsVolumeSizeInGb;
        MaximumEbsVolumeSizeInGb: SpaceEbsVolumeSizeInGb;
      };
    };
    CustomPosixUserConfig: CustomPosixUserConfig & { Uid: Uid; Gid: Gid };
  };
}
export const DescribeDomainResponse = S.suspend(() =>
  S.Struct({
    DomainArn: S.optional(S.String),
    DomainId: S.optional(S.String),
    DomainName: S.optional(S.String),
    HomeEfsFileSystemId: S.optional(S.String),
    SingleSignOnManagedApplicationInstanceId: S.optional(S.String),
    SingleSignOnApplicationArn: S.optional(S.String),
    Status: S.optional(DomainStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    FailureReason: S.optional(S.String),
    SecurityGroupIdForDomainBoundary: S.optional(S.String),
    AuthMode: S.optional(AuthMode),
    DefaultUserSettings: S.optional(UserSettings),
    DomainSettings: S.optional(DomainSettings),
    AppNetworkAccessType: S.optional(AppNetworkAccessType),
    HomeEfsFileSystemKmsKeyId: S.optional(S.String),
    SubnetIds: S.optional(Subnets),
    Url: S.optional(S.String),
    VpcId: S.optional(S.String),
    KmsKeyId: S.optional(S.String),
    AppSecurityGroupManagement: S.optional(AppSecurityGroupManagement),
    TagPropagation: S.optional(TagPropagation),
    DefaultSpaceSettings: S.optional(DefaultSpaceSettings),
  }).pipe(ns),
).annotate({
  identifier: "DescribeDomainResponse",
}) as any as S.Schema<DescribeDomainResponse>;
export interface DescribeEdgeDeploymentPlanRequest {
  EdgeDeploymentPlanName?: string;
  NextToken?: string;
  MaxResults?: number;
}
export const DescribeEdgeDeploymentPlanRequest = S.suspend(() =>
  S.Struct({
    EdgeDeploymentPlanName: S.optional(S.String),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeEdgeDeploymentPlanRequest",
}) as any as S.Schema<DescribeEdgeDeploymentPlanRequest>;
export type StageStatus =
  | "CREATING"
  | "READYTODEPLOY"
  | "STARTING"
  | "INPROGRESS"
  | "DEPLOYED"
  | "FAILED"
  | "STOPPING"
  | "STOPPED"
  | (string & {});
export const StageStatus = S.String;
export interface EdgeDeploymentStatus {
  StageStatus?: StageStatus;
  EdgeDeploymentSuccessInStage?: number;
  EdgeDeploymentPendingInStage?: number;
  EdgeDeploymentFailedInStage?: number;
  EdgeDeploymentStatusMessage?: string;
  EdgeDeploymentStageStartTime?: Date;
}
export const EdgeDeploymentStatus = S.suspend(() =>
  S.Struct({
    StageStatus: S.optional(StageStatus),
    EdgeDeploymentSuccessInStage: S.optional(S.Number),
    EdgeDeploymentPendingInStage: S.optional(S.Number),
    EdgeDeploymentFailedInStage: S.optional(S.Number),
    EdgeDeploymentStatusMessage: S.optional(S.String),
    EdgeDeploymentStageStartTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "EdgeDeploymentStatus",
}) as any as S.Schema<EdgeDeploymentStatus>;
export interface DeploymentStageStatusSummary {
  StageName?: string;
  DeviceSelectionConfig?: DeviceSelectionConfig;
  DeploymentConfig?: EdgeDeploymentConfig;
  DeploymentStatus?: EdgeDeploymentStatus;
}
export const DeploymentStageStatusSummary = S.suspend(() =>
  S.Struct({
    StageName: S.optional(S.String),
    DeviceSelectionConfig: S.optional(DeviceSelectionConfig),
    DeploymentConfig: S.optional(EdgeDeploymentConfig),
    DeploymentStatus: S.optional(EdgeDeploymentStatus),
  }),
).annotate({
  identifier: "DeploymentStageStatusSummary",
}) as any as S.Schema<DeploymentStageStatusSummary>;
export type DeploymentStageStatusSummaries = DeploymentStageStatusSummary[];
export const DeploymentStageStatusSummaries = S.Array(
  DeploymentStageStatusSummary,
);
export interface DescribeEdgeDeploymentPlanResponse {
  EdgeDeploymentPlanArn: string;
  EdgeDeploymentPlanName: string;
  ModelConfigs: (EdgeDeploymentModelConfig & {
    ModelHandle: EntityName;
    EdgePackagingJobName: EntityName;
  })[];
  DeviceFleetName: string;
  EdgeDeploymentSuccess?: number;
  EdgeDeploymentPending?: number;
  EdgeDeploymentFailed?: number;
  Stages: (DeploymentStageStatusSummary & {
    StageName: EntityName;
    DeviceSelectionConfig: DeviceSelectionConfig & {
      DeviceSubsetType: DeviceSubsetType;
    };
    DeploymentConfig: EdgeDeploymentConfig & {
      FailureHandlingPolicy: FailureHandlingPolicy;
    };
    DeploymentStatus: EdgeDeploymentStatus & {
      StageStatus: StageStatus;
      EdgeDeploymentSuccessInStage: number;
      EdgeDeploymentPendingInStage: number;
      EdgeDeploymentFailedInStage: number;
    };
  })[];
  NextToken?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
}
export const DescribeEdgeDeploymentPlanResponse = S.suspend(() =>
  S.Struct({
    EdgeDeploymentPlanArn: S.optional(S.String),
    EdgeDeploymentPlanName: S.optional(S.String),
    ModelConfigs: S.optional(EdgeDeploymentModelConfigs),
    DeviceFleetName: S.optional(S.String),
    EdgeDeploymentSuccess: S.optional(S.Number),
    EdgeDeploymentPending: S.optional(S.Number),
    EdgeDeploymentFailed: S.optional(S.Number),
    Stages: S.optional(DeploymentStageStatusSummaries),
    NextToken: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeEdgeDeploymentPlanResponse",
}) as any as S.Schema<DescribeEdgeDeploymentPlanResponse>;
export interface DescribeEdgePackagingJobRequest {
  EdgePackagingJobName?: string;
}
export const DescribeEdgePackagingJobRequest = S.suspend(() =>
  S.Struct({ EdgePackagingJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeEdgePackagingJobRequest",
}) as any as S.Schema<DescribeEdgePackagingJobRequest>;
export type EdgePackagingJobStatus =
  | "STARTING"
  | "INPROGRESS"
  | "COMPLETED"
  | "FAILED"
  | "STOPPING"
  | "STOPPED"
  | (string & {});
export const EdgePackagingJobStatus = S.String;
export type EdgePresetDeploymentStatus = "COMPLETED" | "FAILED" | (string & {});
export const EdgePresetDeploymentStatus = S.String;
export interface EdgePresetDeploymentOutput {
  Type?: EdgePresetDeploymentType;
  Artifact?: string;
  Status?: EdgePresetDeploymentStatus;
  StatusMessage?: string;
}
export const EdgePresetDeploymentOutput = S.suspend(() =>
  S.Struct({
    Type: S.optional(EdgePresetDeploymentType),
    Artifact: S.optional(S.String),
    Status: S.optional(EdgePresetDeploymentStatus),
    StatusMessage: S.optional(S.String),
  }),
).annotate({
  identifier: "EdgePresetDeploymentOutput",
}) as any as S.Schema<EdgePresetDeploymentOutput>;
export interface DescribeEdgePackagingJobResponse {
  EdgePackagingJobArn: string;
  EdgePackagingJobName: string;
  CompilationJobName?: string;
  ModelName?: string;
  ModelVersion?: string;
  RoleArn?: string;
  OutputConfig?: EdgeOutputConfig & { S3OutputLocation: S3Uri };
  ResourceKey?: string;
  EdgePackagingJobStatus: EdgePackagingJobStatus;
  EdgePackagingJobStatusMessage?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  ModelArtifact?: string;
  ModelSignature?: string;
  PresetDeploymentOutput?: EdgePresetDeploymentOutput & {
    Type: EdgePresetDeploymentType;
  };
}
export const DescribeEdgePackagingJobResponse = S.suspend(() =>
  S.Struct({
    EdgePackagingJobArn: S.optional(S.String),
    EdgePackagingJobName: S.optional(S.String),
    CompilationJobName: S.optional(S.String),
    ModelName: S.optional(S.String),
    ModelVersion: S.optional(S.String),
    RoleArn: S.optional(S.String),
    OutputConfig: S.optional(EdgeOutputConfig),
    ResourceKey: S.optional(S.String),
    EdgePackagingJobStatus: S.optional(EdgePackagingJobStatus),
    EdgePackagingJobStatusMessage: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ModelArtifact: S.optional(S.String),
    ModelSignature: S.optional(S.String),
    PresetDeploymentOutput: S.optional(EdgePresetDeploymentOutput),
  }).pipe(ns),
).annotate({
  identifier: "DescribeEdgePackagingJobResponse",
}) as any as S.Schema<DescribeEdgePackagingJobResponse>;
export interface DescribeEndpointInput {
  EndpointName?: string;
}
export const DescribeEndpointInput = S.suspend(() =>
  S.Struct({ EndpointName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeEndpointInput",
}) as any as S.Schema<DescribeEndpointInput>;
export interface DeployedImage {
  SpecifiedImage?: string;
  ResolvedImage?: string;
  ResolutionTime?: Date;
}
export const DeployedImage = S.suspend(() =>
  S.Struct({
    SpecifiedImage: S.optional(S.String),
    ResolvedImage: S.optional(S.String),
    ResolutionTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotate({ identifier: "DeployedImage" }) as any as S.Schema<DeployedImage>;
export type DeployedImages = DeployedImage[];
export const DeployedImages = S.Array(DeployedImage);
export type VariantStatus =
  | "Creating"
  | "Updating"
  | "Deleting"
  | "ActivatingTraffic"
  | "Baking"
  | (string & {});
export const VariantStatus = S.String;
export interface ProductionVariantStatus {
  Status?: VariantStatus;
  StatusMessage?: string;
  StartTime?: Date;
}
export const ProductionVariantStatus = S.suspend(() =>
  S.Struct({
    Status: S.optional(VariantStatus),
    StatusMessage: S.optional(S.String),
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotate({
  identifier: "ProductionVariantStatus",
}) as any as S.Schema<ProductionVariantStatus>;
export type ProductionVariantStatusList = ProductionVariantStatus[];
export const ProductionVariantStatusList = S.Array(ProductionVariantStatus);
export interface Ec2CapacityReservation {
  Ec2CapacityReservationId?: string;
  TotalInstanceCount?: number;
  AvailableInstanceCount?: number;
  UsedByCurrentEndpoint?: number;
}
export const Ec2CapacityReservation = S.suspend(() =>
  S.Struct({
    Ec2CapacityReservationId: S.optional(S.String),
    TotalInstanceCount: S.optional(S.Number),
    AvailableInstanceCount: S.optional(S.Number),
    UsedByCurrentEndpoint: S.optional(S.Number),
  }),
).annotate({
  identifier: "Ec2CapacityReservation",
}) as any as S.Schema<Ec2CapacityReservation>;
export type Ec2CapacityReservationsList = Ec2CapacityReservation[];
export const Ec2CapacityReservationsList = S.Array(Ec2CapacityReservation);
export interface ProductionVariantCapacityReservationSummary {
  MlReservationArn?: string;
  CapacityReservationPreference?: CapacityReservationPreference;
  TotalInstanceCount?: number;
  AvailableInstanceCount?: number;
  UsedByCurrentEndpoint?: number;
  Ec2CapacityReservations?: Ec2CapacityReservation[];
}
export const ProductionVariantCapacityReservationSummary = S.suspend(() =>
  S.Struct({
    MlReservationArn: S.optional(S.String),
    CapacityReservationPreference: S.optional(CapacityReservationPreference),
    TotalInstanceCount: S.optional(S.Number),
    AvailableInstanceCount: S.optional(S.Number),
    UsedByCurrentEndpoint: S.optional(S.Number),
    Ec2CapacityReservations: S.optional(Ec2CapacityReservationsList),
  }),
).annotate({
  identifier: "ProductionVariantCapacityReservationSummary",
}) as any as S.Schema<ProductionVariantCapacityReservationSummary>;
export interface ProductionVariantSummary {
  VariantName?: string;
  DeployedImages?: DeployedImage[];
  CurrentWeight?: number;
  DesiredWeight?: number;
  CurrentInstanceCount?: number;
  DesiredInstanceCount?: number;
  VariantStatus?: ProductionVariantStatus[];
  CurrentServerlessConfig?: ProductionVariantServerlessConfig;
  DesiredServerlessConfig?: ProductionVariantServerlessConfig;
  ManagedInstanceScaling?: ProductionVariantManagedInstanceScaling;
  RoutingConfig?: ProductionVariantRoutingConfig;
  CapacityReservationConfig?: ProductionVariantCapacityReservationSummary;
}
export const ProductionVariantSummary = S.suspend(() =>
  S.Struct({
    VariantName: S.optional(S.String),
    DeployedImages: S.optional(DeployedImages),
    CurrentWeight: S.optional(S.Number),
    DesiredWeight: S.optional(S.Number),
    CurrentInstanceCount: S.optional(S.Number),
    DesiredInstanceCount: S.optional(S.Number),
    VariantStatus: S.optional(ProductionVariantStatusList),
    CurrentServerlessConfig: S.optional(ProductionVariantServerlessConfig),
    DesiredServerlessConfig: S.optional(ProductionVariantServerlessConfig),
    ManagedInstanceScaling: S.optional(ProductionVariantManagedInstanceScaling),
    RoutingConfig: S.optional(ProductionVariantRoutingConfig),
    CapacityReservationConfig: S.optional(
      ProductionVariantCapacityReservationSummary,
    ),
  }),
).annotate({
  identifier: "ProductionVariantSummary",
}) as any as S.Schema<ProductionVariantSummary>;
export type ProductionVariantSummaryList = ProductionVariantSummary[];
export const ProductionVariantSummaryList = S.Array(ProductionVariantSummary);
export type CaptureStatus = "Started" | "Stopped" | (string & {});
export const CaptureStatus = S.String;
export interface DataCaptureConfigSummary {
  EnableCapture?: boolean;
  CaptureStatus?: CaptureStatus;
  CurrentSamplingPercentage?: number;
  DestinationS3Uri?: string;
  KmsKeyId?: string;
}
export const DataCaptureConfigSummary = S.suspend(() =>
  S.Struct({
    EnableCapture: S.optional(S.Boolean),
    CaptureStatus: S.optional(CaptureStatus),
    CurrentSamplingPercentage: S.optional(S.Number),
    DestinationS3Uri: S.optional(S.String),
    KmsKeyId: S.optional(S.String),
  }),
).annotate({
  identifier: "DataCaptureConfigSummary",
}) as any as S.Schema<DataCaptureConfigSummary>;
export type EndpointStatus =
  | "OutOfService"
  | "Creating"
  | "Updating"
  | "SystemUpdating"
  | "RollingBack"
  | "InService"
  | "Deleting"
  | "Failed"
  | "UpdateRollbackFailed"
  | (string & {});
export const EndpointStatus = S.String;
export interface PendingProductionVariantSummary {
  VariantName?: string;
  DeployedImages?: DeployedImage[];
  CurrentWeight?: number;
  DesiredWeight?: number;
  CurrentInstanceCount?: number;
  DesiredInstanceCount?: number;
  InstanceType?: ProductionVariantInstanceType;
  AcceleratorType?: ProductionVariantAcceleratorType;
  VariantStatus?: ProductionVariantStatus[];
  CurrentServerlessConfig?: ProductionVariantServerlessConfig;
  DesiredServerlessConfig?: ProductionVariantServerlessConfig;
  ManagedInstanceScaling?: ProductionVariantManagedInstanceScaling;
  RoutingConfig?: ProductionVariantRoutingConfig;
}
export const PendingProductionVariantSummary = S.suspend(() =>
  S.Struct({
    VariantName: S.optional(S.String),
    DeployedImages: S.optional(DeployedImages),
    CurrentWeight: S.optional(S.Number),
    DesiredWeight: S.optional(S.Number),
    CurrentInstanceCount: S.optional(S.Number),
    DesiredInstanceCount: S.optional(S.Number),
    InstanceType: S.optional(ProductionVariantInstanceType),
    AcceleratorType: S.optional(ProductionVariantAcceleratorType),
    VariantStatus: S.optional(ProductionVariantStatusList),
    CurrentServerlessConfig: S.optional(ProductionVariantServerlessConfig),
    DesiredServerlessConfig: S.optional(ProductionVariantServerlessConfig),
    ManagedInstanceScaling: S.optional(ProductionVariantManagedInstanceScaling),
    RoutingConfig: S.optional(ProductionVariantRoutingConfig),
  }),
).annotate({
  identifier: "PendingProductionVariantSummary",
}) as any as S.Schema<PendingProductionVariantSummary>;
export type PendingProductionVariantSummaryList =
  PendingProductionVariantSummary[];
export const PendingProductionVariantSummaryList = S.Array(
  PendingProductionVariantSummary,
);
export interface PendingDeploymentSummary {
  EndpointConfigName?: string;
  ProductionVariants?: PendingProductionVariantSummary[];
  StartTime?: Date;
  ShadowProductionVariants?: PendingProductionVariantSummary[];
}
export const PendingDeploymentSummary = S.suspend(() =>
  S.Struct({
    EndpointConfigName: S.optional(S.String),
    ProductionVariants: S.optional(PendingProductionVariantSummaryList),
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ShadowProductionVariants: S.optional(PendingProductionVariantSummaryList),
  }),
).annotate({
  identifier: "PendingDeploymentSummary",
}) as any as S.Schema<PendingDeploymentSummary>;
export interface DescribeEndpointOutput {
  EndpointName: string;
  EndpointArn: string;
  EndpointConfigName?: string;
  ProductionVariants?: (ProductionVariantSummary & {
    VariantName: VariantName;
    VariantStatus: (ProductionVariantStatus & { Status: VariantStatus })[];
    CurrentServerlessConfig: ProductionVariantServerlessConfig & {
      MemorySizeInMB: ServerlessMemorySizeInMB;
      MaxConcurrency: ServerlessMaxConcurrency;
    };
    DesiredServerlessConfig: ProductionVariantServerlessConfig & {
      MemorySizeInMB: ServerlessMemorySizeInMB;
      MaxConcurrency: ServerlessMaxConcurrency;
    };
    RoutingConfig: ProductionVariantRoutingConfig & {
      RoutingStrategy: RoutingStrategy;
    };
  })[];
  DataCaptureConfig?: DataCaptureConfigSummary & {
    EnableCapture: EnableCapture;
    CaptureStatus: CaptureStatus;
    CurrentSamplingPercentage: SamplingPercentage;
    DestinationS3Uri: DestinationS3Uri;
    KmsKeyId: KmsKeyId;
  };
  EndpointStatus: EndpointStatus;
  FailureReason?: string;
  CreationTime: Date;
  LastModifiedTime: Date;
  LastDeploymentConfig?: DeploymentConfig & {
    BlueGreenUpdatePolicy: BlueGreenUpdatePolicy & {
      TrafficRoutingConfiguration: TrafficRoutingConfig & {
        Type: TrafficRoutingConfigType;
        WaitIntervalInSeconds: WaitIntervalInSeconds;
        CanarySize: CapacitySize & {
          Type: CapacitySizeType;
          Value: CapacitySizeValue;
        };
        LinearStepSize: CapacitySize & {
          Type: CapacitySizeType;
          Value: CapacitySizeValue;
        };
      };
    };
    RollingUpdatePolicy: RollingUpdatePolicy & {
      MaximumBatchSize: CapacitySize & {
        Type: CapacitySizeType;
        Value: CapacitySizeValue;
      };
      WaitIntervalInSeconds: WaitIntervalInSeconds;
      RollbackMaximumBatchSize: CapacitySize & {
        Type: CapacitySizeType;
        Value: CapacitySizeValue;
      };
    };
  };
  AsyncInferenceConfig?: AsyncInferenceConfig & {
    OutputConfig: AsyncInferenceOutputConfig;
  };
  PendingDeploymentSummary?: PendingDeploymentSummary & {
    EndpointConfigName: EndpointConfigName;
    ProductionVariants: (PendingProductionVariantSummary & {
      VariantName: VariantName;
      VariantStatus: (ProductionVariantStatus & { Status: VariantStatus })[];
      CurrentServerlessConfig: ProductionVariantServerlessConfig & {
        MemorySizeInMB: ServerlessMemorySizeInMB;
        MaxConcurrency: ServerlessMaxConcurrency;
      };
      DesiredServerlessConfig: ProductionVariantServerlessConfig & {
        MemorySizeInMB: ServerlessMemorySizeInMB;
        MaxConcurrency: ServerlessMaxConcurrency;
      };
      RoutingConfig: ProductionVariantRoutingConfig & {
        RoutingStrategy: RoutingStrategy;
      };
    })[];
    ShadowProductionVariants: (PendingProductionVariantSummary & {
      VariantName: VariantName;
      VariantStatus: (ProductionVariantStatus & { Status: VariantStatus })[];
      CurrentServerlessConfig: ProductionVariantServerlessConfig & {
        MemorySizeInMB: ServerlessMemorySizeInMB;
        MaxConcurrency: ServerlessMaxConcurrency;
      };
      DesiredServerlessConfig: ProductionVariantServerlessConfig & {
        MemorySizeInMB: ServerlessMemorySizeInMB;
        MaxConcurrency: ServerlessMaxConcurrency;
      };
      RoutingConfig: ProductionVariantRoutingConfig & {
        RoutingStrategy: RoutingStrategy;
      };
    })[];
  };
  ExplainerConfig?: ExplainerConfig & {
    ClarifyExplainerConfig: ClarifyExplainerConfig & {
      ShapConfig: ClarifyShapConfig & {
        ShapBaselineConfig: ClarifyShapBaselineConfig;
        TextConfig: ClarifyTextConfig & {
          Language: ClarifyTextLanguage;
          Granularity: ClarifyTextGranularity;
        };
      };
    };
  };
  ShadowProductionVariants?: (ProductionVariantSummary & {
    VariantName: VariantName;
    VariantStatus: (ProductionVariantStatus & { Status: VariantStatus })[];
    CurrentServerlessConfig: ProductionVariantServerlessConfig & {
      MemorySizeInMB: ServerlessMemorySizeInMB;
      MaxConcurrency: ServerlessMaxConcurrency;
    };
    DesiredServerlessConfig: ProductionVariantServerlessConfig & {
      MemorySizeInMB: ServerlessMemorySizeInMB;
      MaxConcurrency: ServerlessMaxConcurrency;
    };
    RoutingConfig: ProductionVariantRoutingConfig & {
      RoutingStrategy: RoutingStrategy;
    };
  })[];
  MetricsConfig?: MetricsConfig;
}
export const DescribeEndpointOutput = S.suspend(() =>
  S.Struct({
    EndpointName: S.optional(S.String),
    EndpointArn: S.optional(S.String),
    EndpointConfigName: S.optional(S.String),
    ProductionVariants: S.optional(ProductionVariantSummaryList),
    DataCaptureConfig: S.optional(DataCaptureConfigSummary),
    EndpointStatus: S.optional(EndpointStatus),
    FailureReason: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastDeploymentConfig: S.optional(DeploymentConfig),
    AsyncInferenceConfig: S.optional(AsyncInferenceConfig),
    PendingDeploymentSummary: S.optional(PendingDeploymentSummary),
    ExplainerConfig: S.optional(ExplainerConfig),
    ShadowProductionVariants: S.optional(ProductionVariantSummaryList),
    MetricsConfig: S.optional(MetricsConfig),
  }).pipe(ns),
).annotate({
  identifier: "DescribeEndpointOutput",
}) as any as S.Schema<DescribeEndpointOutput>;
export interface DescribeEndpointConfigInput {
  EndpointConfigName?: string;
}
export const DescribeEndpointConfigInput = S.suspend(() =>
  S.Struct({ EndpointConfigName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeEndpointConfigInput",
}) as any as S.Schema<DescribeEndpointConfigInput>;
export interface DescribeEndpointConfigOutput {
  EndpointConfigName: string;
  EndpointConfigArn: string;
  ProductionVariants: (ProductionVariant & {
    VariantName: VariantName;
    CoreDumpConfig: ProductionVariantCoreDumpConfig & {
      DestinationS3Uri: DestinationS3Uri;
    };
    ServerlessConfig: ProductionVariantServerlessConfig & {
      MemorySizeInMB: ServerlessMemorySizeInMB;
      MaxConcurrency: ServerlessMaxConcurrency;
    };
    RoutingConfig: ProductionVariantRoutingConfig & {
      RoutingStrategy: RoutingStrategy;
    };
  })[];
  DataCaptureConfig?: DataCaptureConfig & {
    InitialSamplingPercentage: SamplingPercentage;
    DestinationS3Uri: DestinationS3Uri;
    CaptureOptions: (CaptureOption & { CaptureMode: CaptureMode })[];
  };
  KmsKeyId?: string;
  CreationTime: Date;
  AsyncInferenceConfig?: AsyncInferenceConfig & {
    OutputConfig: AsyncInferenceOutputConfig;
  };
  ExplainerConfig?: ExplainerConfig & {
    ClarifyExplainerConfig: ClarifyExplainerConfig & {
      ShapConfig: ClarifyShapConfig & {
        ShapBaselineConfig: ClarifyShapBaselineConfig;
        TextConfig: ClarifyTextConfig & {
          Language: ClarifyTextLanguage;
          Granularity: ClarifyTextGranularity;
        };
      };
    };
  };
  ShadowProductionVariants?: (ProductionVariant & {
    VariantName: VariantName;
    CoreDumpConfig: ProductionVariantCoreDumpConfig & {
      DestinationS3Uri: DestinationS3Uri;
    };
    ServerlessConfig: ProductionVariantServerlessConfig & {
      MemorySizeInMB: ServerlessMemorySizeInMB;
      MaxConcurrency: ServerlessMaxConcurrency;
    };
    RoutingConfig: ProductionVariantRoutingConfig & {
      RoutingStrategy: RoutingStrategy;
    };
  })[];
  ExecutionRoleArn?: string;
  VpcConfig?: VpcConfig & {
    SecurityGroupIds: VpcSecurityGroupIds;
    Subnets: Subnets;
  };
  EnableNetworkIsolation?: boolean;
  MetricsConfig?: MetricsConfig;
}
export const DescribeEndpointConfigOutput = S.suspend(() =>
  S.Struct({
    EndpointConfigName: S.optional(S.String),
    EndpointConfigArn: S.optional(S.String),
    ProductionVariants: S.optional(ProductionVariantList),
    DataCaptureConfig: S.optional(DataCaptureConfig),
    KmsKeyId: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    AsyncInferenceConfig: S.optional(AsyncInferenceConfig),
    ExplainerConfig: S.optional(ExplainerConfig),
    ShadowProductionVariants: S.optional(ProductionVariantList),
    ExecutionRoleArn: S.optional(S.String),
    VpcConfig: S.optional(VpcConfig),
    EnableNetworkIsolation: S.optional(S.Boolean),
    MetricsConfig: S.optional(MetricsConfig),
  }).pipe(ns),
).annotate({
  identifier: "DescribeEndpointConfigOutput",
}) as any as S.Schema<DescribeEndpointConfigOutput>;
export interface DescribeExperimentRequest {
  ExperimentName?: string;
}
export const DescribeExperimentRequest = S.suspend(() =>
  S.Struct({ ExperimentName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeExperimentRequest",
}) as any as S.Schema<DescribeExperimentRequest>;
export interface ExperimentSource {
  SourceArn?: string;
  SourceType?: string;
}
export const ExperimentSource = S.suspend(() =>
  S.Struct({
    SourceArn: S.optional(S.String),
    SourceType: S.optional(S.String),
  }),
).annotate({
  identifier: "ExperimentSource",
}) as any as S.Schema<ExperimentSource>;
export interface DescribeExperimentResponse {
  ExperimentName?: string;
  ExperimentArn?: string;
  DisplayName?: string;
  Source?: ExperimentSource & { SourceArn: ExperimentSourceArn };
  Description?: string;
  CreationTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
}
export const DescribeExperimentResponse = S.suspend(() =>
  S.Struct({
    ExperimentName: S.optional(S.String),
    ExperimentArn: S.optional(S.String),
    DisplayName: S.optional(S.String),
    Source: S.optional(ExperimentSource),
    Description: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
  }).pipe(ns),
).annotate({
  identifier: "DescribeExperimentResponse",
}) as any as S.Schema<DescribeExperimentResponse>;
export interface DescribeFeatureGroupRequest {
  FeatureGroupName?: string;
  NextToken?: string;
}
export const DescribeFeatureGroupRequest = S.suspend(() =>
  S.Struct({
    FeatureGroupName: S.optional(S.String),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeFeatureGroupRequest",
}) as any as S.Schema<DescribeFeatureGroupRequest>;
export interface ThroughputConfigDescription {
  ThroughputMode?: ThroughputMode;
  ProvisionedReadCapacityUnits?: number;
  ProvisionedWriteCapacityUnits?: number;
}
export const ThroughputConfigDescription = S.suspend(() =>
  S.Struct({
    ThroughputMode: S.optional(ThroughputMode),
    ProvisionedReadCapacityUnits: S.optional(S.Number),
    ProvisionedWriteCapacityUnits: S.optional(S.Number),
  }),
).annotate({
  identifier: "ThroughputConfigDescription",
}) as any as S.Schema<ThroughputConfigDescription>;
export type FeatureGroupStatus =
  | "Creating"
  | "Created"
  | "CreateFailed"
  | "Deleting"
  | "DeleteFailed"
  | (string & {});
export const FeatureGroupStatus = S.String;
export type OfflineStoreStatusValue =
  | "Active"
  | "Blocked"
  | "Disabled"
  | (string & {});
export const OfflineStoreStatusValue = S.String;
export interface OfflineStoreStatus {
  Status?: OfflineStoreStatusValue;
  BlockedReason?: string;
}
export const OfflineStoreStatus = S.suspend(() =>
  S.Struct({
    Status: S.optional(OfflineStoreStatusValue),
    BlockedReason: S.optional(S.String),
  }),
).annotate({
  identifier: "OfflineStoreStatus",
}) as any as S.Schema<OfflineStoreStatus>;
export type LastUpdateStatusValue =
  | "Successful"
  | "Failed"
  | "InProgress"
  | (string & {});
export const LastUpdateStatusValue = S.String;
export interface LastUpdateStatus {
  Status?: LastUpdateStatusValue;
  FailureReason?: string;
}
export const LastUpdateStatus = S.suspend(() =>
  S.Struct({
    Status: S.optional(LastUpdateStatusValue),
    FailureReason: S.optional(S.String),
  }),
).annotate({
  identifier: "LastUpdateStatus",
}) as any as S.Schema<LastUpdateStatus>;
export interface DescribeFeatureGroupResponse {
  FeatureGroupArn: string;
  FeatureGroupName: string;
  RecordIdentifierFeatureName: string;
  EventTimeFeatureName: string;
  FeatureDefinitions: (FeatureDefinition & {
    FeatureName: FeatureName;
    FeatureType: FeatureType;
  })[];
  CreationTime: Date;
  LastModifiedTime?: Date;
  OnlineStoreConfig?: OnlineStoreConfig;
  OfflineStoreConfig?: OfflineStoreConfig & {
    S3StorageConfig: S3StorageConfig & { S3Uri: S3Uri };
    DataCatalogConfig: DataCatalogConfig & {
      TableName: TableName;
      Catalog: Catalog;
      Database: Database;
    };
  };
  ThroughputConfig?: ThroughputConfigDescription & {
    ThroughputMode: ThroughputMode;
  };
  RoleArn?: string;
  FeatureGroupStatus?: FeatureGroupStatus;
  OfflineStoreStatus?: OfflineStoreStatus & { Status: OfflineStoreStatusValue };
  LastUpdateStatus?: LastUpdateStatus & { Status: LastUpdateStatusValue };
  FailureReason?: string;
  Description?: string;
  NextToken: string;
  OnlineStoreTotalSizeBytes?: number;
}
export const DescribeFeatureGroupResponse = S.suspend(() =>
  S.Struct({
    FeatureGroupArn: S.optional(S.String),
    FeatureGroupName: S.optional(S.String),
    RecordIdentifierFeatureName: S.optional(S.String),
    EventTimeFeatureName: S.optional(S.String),
    FeatureDefinitions: S.optional(FeatureDefinitions),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    OnlineStoreConfig: S.optional(OnlineStoreConfig),
    OfflineStoreConfig: S.optional(OfflineStoreConfig),
    ThroughputConfig: S.optional(ThroughputConfigDescription),
    RoleArn: S.optional(S.String),
    FeatureGroupStatus: S.optional(FeatureGroupStatus),
    OfflineStoreStatus: S.optional(OfflineStoreStatus),
    LastUpdateStatus: S.optional(LastUpdateStatus),
    FailureReason: S.optional(S.String),
    Description: S.optional(S.String),
    NextToken: S.optional(S.String),
    OnlineStoreTotalSizeBytes: S.optional(S.Number),
  }).pipe(ns),
).annotate({
  identifier: "DescribeFeatureGroupResponse",
}) as any as S.Schema<DescribeFeatureGroupResponse>;
export interface DescribeFeatureMetadataRequest {
  FeatureGroupName?: string;
  FeatureName?: string;
}
export const DescribeFeatureMetadataRequest = S.suspend(() =>
  S.Struct({
    FeatureGroupName: S.optional(S.String),
    FeatureName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeFeatureMetadataRequest",
}) as any as S.Schema<DescribeFeatureMetadataRequest>;
export interface FeatureParameter {
  Key?: string;
  Value?: string;
}
export const FeatureParameter = S.suspend(() =>
  S.Struct({ Key: S.optional(S.String), Value: S.optional(S.String) }),
).annotate({
  identifier: "FeatureParameter",
}) as any as S.Schema<FeatureParameter>;
export type FeatureParameters = FeatureParameter[];
export const FeatureParameters = S.Array(FeatureParameter);
export interface DescribeFeatureMetadataResponse {
  FeatureGroupArn: string;
  FeatureGroupName: string;
  FeatureName: string;
  FeatureType: FeatureType;
  CreationTime: Date;
  LastModifiedTime: Date;
  Description?: string;
  Parameters?: FeatureParameter[];
}
export const DescribeFeatureMetadataResponse = S.suspend(() =>
  S.Struct({
    FeatureGroupArn: S.optional(S.String),
    FeatureGroupName: S.optional(S.String),
    FeatureName: S.optional(S.String),
    FeatureType: S.optional(FeatureType),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    Description: S.optional(S.String),
    Parameters: S.optional(FeatureParameters),
  }).pipe(ns),
).annotate({
  identifier: "DescribeFeatureMetadataResponse",
}) as any as S.Schema<DescribeFeatureMetadataResponse>;
export interface DescribeFlowDefinitionRequest {
  FlowDefinitionName?: string;
}
export const DescribeFlowDefinitionRequest = S.suspend(() =>
  S.Struct({ FlowDefinitionName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeFlowDefinitionRequest",
}) as any as S.Schema<DescribeFlowDefinitionRequest>;
export type FlowDefinitionStatus =
  | "Initializing"
  | "Active"
  | "Failed"
  | "Deleting"
  | (string & {});
export const FlowDefinitionStatus = S.String;
export interface DescribeFlowDefinitionResponse {
  FlowDefinitionArn: string;
  FlowDefinitionName: string;
  FlowDefinitionStatus: FlowDefinitionStatus;
  CreationTime: Date;
  HumanLoopRequestSource?: HumanLoopRequestSource & {
    AwsManagedHumanLoopRequestSource: AwsManagedHumanLoopRequestSource;
  };
  HumanLoopActivationConfig?: HumanLoopActivationConfig & {
    HumanLoopActivationConditionsConfig: HumanLoopActivationConditionsConfig & {
      HumanLoopActivationConditions: HumanLoopActivationConditions;
    };
  };
  HumanLoopConfig?: HumanLoopConfig & {
    WorkteamArn: WorkteamArn;
    HumanTaskUiArn: HumanTaskUiArn;
    TaskTitle: FlowDefinitionTaskTitle;
    TaskDescription: FlowDefinitionTaskDescription;
    TaskCount: FlowDefinitionTaskCount;
  };
  OutputConfig: FlowDefinitionOutputConfig & { S3OutputPath: S3Uri };
  RoleArn: string;
  FailureReason?: string;
}
export const DescribeFlowDefinitionResponse = S.suspend(() =>
  S.Struct({
    FlowDefinitionArn: S.optional(S.String),
    FlowDefinitionName: S.optional(S.String),
    FlowDefinitionStatus: S.optional(FlowDefinitionStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    HumanLoopRequestSource: S.optional(HumanLoopRequestSource),
    HumanLoopActivationConfig: S.optional(HumanLoopActivationConfig),
    HumanLoopConfig: S.optional(HumanLoopConfig),
    OutputConfig: S.optional(FlowDefinitionOutputConfig),
    RoleArn: S.optional(S.String),
    FailureReason: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "DescribeFlowDefinitionResponse",
}) as any as S.Schema<DescribeFlowDefinitionResponse>;
export interface DescribeHubRequest {
  HubName?: string;
}
export const DescribeHubRequest = S.suspend(() =>
  S.Struct({ HubName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeHubRequest",
}) as any as S.Schema<DescribeHubRequest>;
export type HubStatus =
  | "InService"
  | "Creating"
  | "Updating"
  | "Deleting"
  | "CreateFailed"
  | "UpdateFailed"
  | "DeleteFailed"
  | (string & {});
export const HubStatus = S.String;
export interface DescribeHubResponse {
  HubName: string;
  HubArn: string;
  HubDisplayName?: string;
  HubDescription?: string;
  HubSearchKeywords?: string[];
  S3StorageConfig?: HubS3StorageConfig;
  HubStatus: HubStatus;
  FailureReason?: string;
  CreationTime: Date;
  LastModifiedTime: Date;
}
export const DescribeHubResponse = S.suspend(() =>
  S.Struct({
    HubName: S.optional(S.String),
    HubArn: S.optional(S.String),
    HubDisplayName: S.optional(S.String),
    HubDescription: S.optional(S.String),
    HubSearchKeywords: S.optional(HubSearchKeywordList),
    S3StorageConfig: S.optional(HubS3StorageConfig),
    HubStatus: S.optional(HubStatus),
    FailureReason: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeHubResponse",
}) as any as S.Schema<DescribeHubResponse>;
export interface DescribeHubContentRequest {
  HubName?: string;
  HubContentType?: HubContentType;
  HubContentName?: string;
  HubContentVersion?: string;
}
export const DescribeHubContentRequest = S.suspend(() =>
  S.Struct({
    HubName: S.optional(S.String),
    HubContentType: S.optional(HubContentType),
    HubContentName: S.optional(S.String),
    HubContentVersion: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeHubContentRequest",
}) as any as S.Schema<DescribeHubContentRequest>;
export type HubContentSupportStatus =
  | "Supported"
  | "Deprecated"
  | "Restricted"
  | (string & {});
export const HubContentSupportStatus = S.String;
export type HubContentSearchKeywordList = string[];
export const HubContentSearchKeywordList = S.Array(S.String);
export interface HubContentDependency {
  DependencyOriginPath?: string;
  DependencyCopyPath?: string;
}
export const HubContentDependency = S.suspend(() =>
  S.Struct({
    DependencyOriginPath: S.optional(S.String),
    DependencyCopyPath: S.optional(S.String),
  }),
).annotate({
  identifier: "HubContentDependency",
}) as any as S.Schema<HubContentDependency>;
export type HubContentDependencyList = HubContentDependency[];
export const HubContentDependencyList = S.Array(HubContentDependency);
export type HubContentStatus =
  | "Available"
  | "Importing"
  | "Deleting"
  | "ImportFailed"
  | "DeleteFailed"
  | "PendingImport"
  | "PendingDelete"
  | (string & {});
export const HubContentStatus = S.String;
export interface DescribeHubContentResponse {
  HubContentName: string;
  HubContentArn: string;
  HubContentVersion: string;
  HubContentType: HubContentType;
  DocumentSchemaVersion: string;
  HubName: string;
  HubArn: string;
  HubContentDisplayName?: string;
  HubContentDescription?: string;
  HubContentMarkdown?: string;
  HubContentDocument: string;
  SageMakerPublicHubContentArn?: string;
  ReferenceMinVersion?: string;
  SupportStatus?: HubContentSupportStatus;
  HubContentSearchKeywords?: string[];
  HubContentDependencies?: HubContentDependency[];
  HubContentStatus: HubContentStatus;
  FailureReason?: string;
  CreationTime: Date;
  LastModifiedTime?: Date;
}
export const DescribeHubContentResponse = S.suspend(() =>
  S.Struct({
    HubContentName: S.optional(S.String),
    HubContentArn: S.optional(S.String),
    HubContentVersion: S.optional(S.String),
    HubContentType: S.optional(HubContentType),
    DocumentSchemaVersion: S.optional(S.String),
    HubName: S.optional(S.String),
    HubArn: S.optional(S.String),
    HubContentDisplayName: S.optional(S.String),
    HubContentDescription: S.optional(S.String),
    HubContentMarkdown: S.optional(S.String),
    HubContentDocument: S.optional(S.String),
    SageMakerPublicHubContentArn: S.optional(S.String),
    ReferenceMinVersion: S.optional(S.String),
    SupportStatus: S.optional(HubContentSupportStatus),
    HubContentSearchKeywords: S.optional(HubContentSearchKeywordList),
    HubContentDependencies: S.optional(HubContentDependencyList),
    HubContentStatus: S.optional(HubContentStatus),
    FailureReason: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeHubContentResponse",
}) as any as S.Schema<DescribeHubContentResponse>;
export interface DescribeHumanTaskUiRequest {
  HumanTaskUiName?: string;
}
export const DescribeHumanTaskUiRequest = S.suspend(() =>
  S.Struct({ HumanTaskUiName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeHumanTaskUiRequest",
}) as any as S.Schema<DescribeHumanTaskUiRequest>;
export type HumanTaskUiStatus = "Active" | "Deleting" | (string & {});
export const HumanTaskUiStatus = S.String;
export interface UiTemplateInfo {
  Url?: string;
  ContentSha256?: string;
}
export const UiTemplateInfo = S.suspend(() =>
  S.Struct({ Url: S.optional(S.String), ContentSha256: S.optional(S.String) }),
).annotate({ identifier: "UiTemplateInfo" }) as any as S.Schema<UiTemplateInfo>;
export interface DescribeHumanTaskUiResponse {
  HumanTaskUiArn: string;
  HumanTaskUiName: string;
  HumanTaskUiStatus?: HumanTaskUiStatus;
  CreationTime: Date;
  UiTemplate: UiTemplateInfo;
}
export const DescribeHumanTaskUiResponse = S.suspend(() =>
  S.Struct({
    HumanTaskUiArn: S.optional(S.String),
    HumanTaskUiName: S.optional(S.String),
    HumanTaskUiStatus: S.optional(HumanTaskUiStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    UiTemplate: S.optional(UiTemplateInfo),
  }).pipe(ns),
).annotate({
  identifier: "DescribeHumanTaskUiResponse",
}) as any as S.Schema<DescribeHumanTaskUiResponse>;
export interface DescribeHyperParameterTuningJobRequest {
  HyperParameterTuningJobName?: string;
}
export const DescribeHyperParameterTuningJobRequest = S.suspend(() =>
  S.Struct({ HyperParameterTuningJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeHyperParameterTuningJobRequest",
}) as any as S.Schema<DescribeHyperParameterTuningJobRequest>;
export type HyperParameterTuningJobStatus =
  | "Completed"
  | "InProgress"
  | "Failed"
  | "Stopped"
  | "Stopping"
  | "Deleting"
  | "DeleteFailed"
  | (string & {});
export const HyperParameterTuningJobStatus = S.String;
export interface TrainingJobStatusCounters {
  Completed?: number;
  InProgress?: number;
  RetryableError?: number;
  NonRetryableError?: number;
  Stopped?: number;
}
export const TrainingJobStatusCounters = S.suspend(() =>
  S.Struct({
    Completed: S.optional(S.Number),
    InProgress: S.optional(S.Number),
    RetryableError: S.optional(S.Number),
    NonRetryableError: S.optional(S.Number),
    Stopped: S.optional(S.Number),
  }),
).annotate({
  identifier: "TrainingJobStatusCounters",
}) as any as S.Schema<TrainingJobStatusCounters>;
export interface ObjectiveStatusCounters {
  Succeeded?: number;
  Pending?: number;
  Failed?: number;
}
export const ObjectiveStatusCounters = S.suspend(() =>
  S.Struct({
    Succeeded: S.optional(S.Number),
    Pending: S.optional(S.Number),
    Failed: S.optional(S.Number),
  }),
).annotate({
  identifier: "ObjectiveStatusCounters",
}) as any as S.Schema<ObjectiveStatusCounters>;
export type TrainingJobStatus =
  | "InProgress"
  | "Completed"
  | "Failed"
  | "Stopping"
  | "Stopped"
  | "Deleting"
  | (string & {});
export const TrainingJobStatus = S.String;
export interface FinalHyperParameterTuningJobObjectiveMetric {
  Type?: HyperParameterTuningJobObjectiveType;
  MetricName?: string;
  Value?: number;
}
export const FinalHyperParameterTuningJobObjectiveMetric = S.suspend(() =>
  S.Struct({
    Type: S.optional(HyperParameterTuningJobObjectiveType),
    MetricName: S.optional(S.String),
    Value: S.optional(S.Number),
  }),
).annotate({
  identifier: "FinalHyperParameterTuningJobObjectiveMetric",
}) as any as S.Schema<FinalHyperParameterTuningJobObjectiveMetric>;
export interface HyperParameterTrainingJobSummary {
  TrainingJobDefinitionName?: string;
  TrainingJobName?: string;
  TrainingJobArn?: string;
  TuningJobName?: string;
  CreationTime?: Date;
  TrainingStartTime?: Date;
  TrainingEndTime?: Date;
  TrainingJobStatus?: TrainingJobStatus;
  TunedHyperParameters?: { [key: string]: string | undefined };
  FailureReason?: string;
  FinalHyperParameterTuningJobObjectiveMetric?: FinalHyperParameterTuningJobObjectiveMetric;
  ObjectiveStatus?: ObjectiveStatus;
}
export const HyperParameterTrainingJobSummary = S.suspend(() =>
  S.Struct({
    TrainingJobDefinitionName: S.optional(S.String),
    TrainingJobName: S.optional(S.String),
    TrainingJobArn: S.optional(S.String),
    TuningJobName: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    TrainingStartTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    TrainingEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    TrainingJobStatus: S.optional(TrainingJobStatus),
    TunedHyperParameters: S.optional(HyperParameters),
    FailureReason: S.optional(S.String),
    FinalHyperParameterTuningJobObjectiveMetric: S.optional(
      FinalHyperParameterTuningJobObjectiveMetric,
    ),
    ObjectiveStatus: S.optional(ObjectiveStatus),
  }),
).annotate({
  identifier: "HyperParameterTrainingJobSummary",
}) as any as S.Schema<HyperParameterTrainingJobSummary>;
export interface HyperParameterTuningJobCompletionDetails {
  NumberOfTrainingJobsObjectiveNotImproving?: number;
  ConvergenceDetectedTime?: Date;
}
export const HyperParameterTuningJobCompletionDetails = S.suspend(() =>
  S.Struct({
    NumberOfTrainingJobsObjectiveNotImproving: S.optional(S.Number),
    ConvergenceDetectedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "HyperParameterTuningJobCompletionDetails",
}) as any as S.Schema<HyperParameterTuningJobCompletionDetails>;
export interface HyperParameterTuningJobConsumedResources {
  RuntimeInSeconds?: number;
}
export const HyperParameterTuningJobConsumedResources = S.suspend(() =>
  S.Struct({ RuntimeInSeconds: S.optional(S.Number) }),
).annotate({
  identifier: "HyperParameterTuningJobConsumedResources",
}) as any as S.Schema<HyperParameterTuningJobConsumedResources>;
export interface DescribeHyperParameterTuningJobResponse {
  HyperParameterTuningJobName: string;
  HyperParameterTuningJobArn: string;
  HyperParameterTuningJobConfig: HyperParameterTuningJobConfig & {
    Strategy: HyperParameterTuningJobStrategyType;
    ResourceLimits: ResourceLimits & {
      MaxParallelTrainingJobs: MaxParallelTrainingJobs;
    };
    HyperParameterTuningJobObjective: HyperParameterTuningJobObjective & {
      Type: HyperParameterTuningJobObjectiveType;
      MetricName: MetricName;
    };
    ParameterRanges: ParameterRanges & {
      IntegerParameterRanges: (IntegerParameterRange & {
        Name: ParameterKey;
        MinValue: ParameterValue;
        MaxValue: ParameterValue;
      })[];
      ContinuousParameterRanges: (ContinuousParameterRange & {
        Name: ParameterKey;
        MinValue: ParameterValue;
        MaxValue: ParameterValue;
      })[];
      CategoricalParameterRanges: (CategoricalParameterRange & {
        Name: ParameterKey;
        Values: ParameterValues;
      })[];
      AutoParameters: (AutoParameter & {
        Name: ParameterKey;
        ValueHint: ParameterValue;
      })[];
    };
  };
  TrainingJobDefinition?: HyperParameterTrainingJobDefinition & {
    AlgorithmSpecification: HyperParameterAlgorithmSpecification & {
      TrainingInputMode: TrainingInputMode;
      MetricDefinitions: (MetricDefinition & {
        Name: MetricName;
        Regex: MetricRegex;
      })[];
    };
    RoleArn: RoleArn;
    OutputDataConfig: OutputDataConfig & { S3OutputPath: S3Uri };
    StoppingCondition: StoppingCondition;
    TuningObjective: HyperParameterTuningJobObjective & {
      Type: HyperParameterTuningJobObjectiveType;
      MetricName: MetricName;
    };
    HyperParameterRanges: ParameterRanges & {
      IntegerParameterRanges: (IntegerParameterRange & {
        Name: ParameterKey;
        MinValue: ParameterValue;
        MaxValue: ParameterValue;
      })[];
      ContinuousParameterRanges: (ContinuousParameterRange & {
        Name: ParameterKey;
        MinValue: ParameterValue;
        MaxValue: ParameterValue;
      })[];
      CategoricalParameterRanges: (CategoricalParameterRange & {
        Name: ParameterKey;
        Values: ParameterValues;
      })[];
      AutoParameters: (AutoParameter & {
        Name: ParameterKey;
        ValueHint: ParameterValue;
      })[];
    };
    InputDataConfig: (Channel & {
      ChannelName: ChannelName;
      DataSource: DataSource & {
        S3DataSource: S3DataSource & {
          S3DataType: S3DataType;
          S3Uri: S3Uri;
          ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
          HubAccessConfig: HubAccessConfig & { HubContentArn: HubContentArn };
        };
        FileSystemDataSource: FileSystemDataSource & {
          FileSystemId: FileSystemId;
          FileSystemAccessMode: FileSystemAccessMode;
          FileSystemType: FileSystemType;
          DirectoryPath: DirectoryPath;
        };
      };
      ShuffleConfig: ShuffleConfig & { Seed: Seed };
    })[];
    VpcConfig: VpcConfig & {
      SecurityGroupIds: VpcSecurityGroupIds;
      Subnets: Subnets;
    };
    ResourceConfig: ResourceConfig & {
      InstanceGroups: (InstanceGroup & {
        InstanceType: TrainingInstanceType;
        InstanceCount: TrainingInstanceCount;
        InstanceGroupName: InstanceGroupName;
      })[];
      InstancePlacementConfig: InstancePlacementConfig & {
        PlacementSpecifications: (PlacementSpecification & {
          InstanceCount: TrainingInstanceCount;
        })[];
      };
    };
    HyperParameterTuningResourceConfig: HyperParameterTuningResourceConfig & {
      InstanceConfigs: (HyperParameterTuningInstanceConfig & {
        InstanceType: TrainingInstanceType;
        InstanceCount: TrainingInstanceCount;
        VolumeSizeInGB: VolumeSizeInGB;
      })[];
    };
    CheckpointConfig: CheckpointConfig & { S3Uri: S3Uri };
    RetryStrategy: RetryStrategy & {
      MaximumRetryAttempts: MaximumRetryAttempts;
    };
  };
  TrainingJobDefinitions?: (HyperParameterTrainingJobDefinition & {
    AlgorithmSpecification: HyperParameterAlgorithmSpecification & {
      TrainingInputMode: TrainingInputMode;
      MetricDefinitions: (MetricDefinition & {
        Name: MetricName;
        Regex: MetricRegex;
      })[];
    };
    RoleArn: RoleArn;
    OutputDataConfig: OutputDataConfig & { S3OutputPath: S3Uri };
    StoppingCondition: StoppingCondition;
    TuningObjective: HyperParameterTuningJobObjective & {
      Type: HyperParameterTuningJobObjectiveType;
      MetricName: MetricName;
    };
    HyperParameterRanges: ParameterRanges & {
      IntegerParameterRanges: (IntegerParameterRange & {
        Name: ParameterKey;
        MinValue: ParameterValue;
        MaxValue: ParameterValue;
      })[];
      ContinuousParameterRanges: (ContinuousParameterRange & {
        Name: ParameterKey;
        MinValue: ParameterValue;
        MaxValue: ParameterValue;
      })[];
      CategoricalParameterRanges: (CategoricalParameterRange & {
        Name: ParameterKey;
        Values: ParameterValues;
      })[];
      AutoParameters: (AutoParameter & {
        Name: ParameterKey;
        ValueHint: ParameterValue;
      })[];
    };
    InputDataConfig: (Channel & {
      ChannelName: ChannelName;
      DataSource: DataSource & {
        S3DataSource: S3DataSource & {
          S3DataType: S3DataType;
          S3Uri: S3Uri;
          ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
          HubAccessConfig: HubAccessConfig & { HubContentArn: HubContentArn };
        };
        FileSystemDataSource: FileSystemDataSource & {
          FileSystemId: FileSystemId;
          FileSystemAccessMode: FileSystemAccessMode;
          FileSystemType: FileSystemType;
          DirectoryPath: DirectoryPath;
        };
      };
      ShuffleConfig: ShuffleConfig & { Seed: Seed };
    })[];
    VpcConfig: VpcConfig & {
      SecurityGroupIds: VpcSecurityGroupIds;
      Subnets: Subnets;
    };
    ResourceConfig: ResourceConfig & {
      InstanceGroups: (InstanceGroup & {
        InstanceType: TrainingInstanceType;
        InstanceCount: TrainingInstanceCount;
        InstanceGroupName: InstanceGroupName;
      })[];
      InstancePlacementConfig: InstancePlacementConfig & {
        PlacementSpecifications: (PlacementSpecification & {
          InstanceCount: TrainingInstanceCount;
        })[];
      };
    };
    HyperParameterTuningResourceConfig: HyperParameterTuningResourceConfig & {
      InstanceConfigs: (HyperParameterTuningInstanceConfig & {
        InstanceType: TrainingInstanceType;
        InstanceCount: TrainingInstanceCount;
        VolumeSizeInGB: VolumeSizeInGB;
      })[];
    };
    CheckpointConfig: CheckpointConfig & { S3Uri: S3Uri };
    RetryStrategy: RetryStrategy & {
      MaximumRetryAttempts: MaximumRetryAttempts;
    };
  })[];
  HyperParameterTuningJobStatus: HyperParameterTuningJobStatus;
  CreationTime: Date;
  HyperParameterTuningEndTime?: Date;
  LastModifiedTime?: Date;
  TrainingJobStatusCounters: TrainingJobStatusCounters;
  ObjectiveStatusCounters: ObjectiveStatusCounters;
  BestTrainingJob?: HyperParameterTrainingJobSummary & {
    TrainingJobName: TrainingJobName;
    TrainingJobArn: TrainingJobArn;
    CreationTime: Date;
    TrainingJobStatus: TrainingJobStatus;
    TunedHyperParameters: HyperParameters;
    FinalHyperParameterTuningJobObjectiveMetric: FinalHyperParameterTuningJobObjectiveMetric & {
      MetricName: MetricName;
      Value: MetricValue;
    };
  };
  OverallBestTrainingJob?: HyperParameterTrainingJobSummary & {
    TrainingJobName: TrainingJobName;
    TrainingJobArn: TrainingJobArn;
    CreationTime: Date;
    TrainingJobStatus: TrainingJobStatus;
    TunedHyperParameters: HyperParameters;
    FinalHyperParameterTuningJobObjectiveMetric: FinalHyperParameterTuningJobObjectiveMetric & {
      MetricName: MetricName;
      Value: MetricValue;
    };
  };
  WarmStartConfig?: HyperParameterTuningJobWarmStartConfig & {
    ParentHyperParameterTuningJobs: ParentHyperParameterTuningJobs;
    WarmStartType: HyperParameterTuningJobWarmStartType;
  };
  Autotune?: Autotune & { Mode: AutotuneMode };
  FailureReason?: string;
  TuningJobCompletionDetails?: HyperParameterTuningJobCompletionDetails;
  ConsumedResources?: HyperParameterTuningJobConsumedResources;
}
export const DescribeHyperParameterTuningJobResponse = S.suspend(() =>
  S.Struct({
    HyperParameterTuningJobName: S.optional(S.String),
    HyperParameterTuningJobArn: S.optional(S.String),
    HyperParameterTuningJobConfig: S.optional(HyperParameterTuningJobConfig),
    TrainingJobDefinition: S.optional(HyperParameterTrainingJobDefinition),
    TrainingJobDefinitions: S.optional(HyperParameterTrainingJobDefinitions),
    HyperParameterTuningJobStatus: S.optional(HyperParameterTuningJobStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    HyperParameterTuningEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    TrainingJobStatusCounters: S.optional(TrainingJobStatusCounters),
    ObjectiveStatusCounters: S.optional(ObjectiveStatusCounters),
    BestTrainingJob: S.optional(HyperParameterTrainingJobSummary),
    OverallBestTrainingJob: S.optional(HyperParameterTrainingJobSummary),
    WarmStartConfig: S.optional(HyperParameterTuningJobWarmStartConfig),
    Autotune: S.optional(Autotune),
    FailureReason: S.optional(S.String),
    TuningJobCompletionDetails: S.optional(
      HyperParameterTuningJobCompletionDetails,
    ),
    ConsumedResources: S.optional(HyperParameterTuningJobConsumedResources),
  }).pipe(ns),
).annotate({
  identifier: "DescribeHyperParameterTuningJobResponse",
}) as any as S.Schema<DescribeHyperParameterTuningJobResponse>;
export interface DescribeImageRequest {
  ImageName?: string;
}
export const DescribeImageRequest = S.suspend(() =>
  S.Struct({ ImageName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeImageRequest",
}) as any as S.Schema<DescribeImageRequest>;
export type ImageStatus =
  | "CREATING"
  | "CREATED"
  | "CREATE_FAILED"
  | "UPDATING"
  | "UPDATE_FAILED"
  | "DELETING"
  | "DELETE_FAILED"
  | (string & {});
export const ImageStatus = S.String;
export interface DescribeImageResponse {
  CreationTime?: Date;
  Description?: string;
  DisplayName?: string;
  FailureReason?: string;
  ImageArn?: string;
  ImageName?: string;
  ImageStatus?: ImageStatus;
  LastModifiedTime?: Date;
  RoleArn?: string;
}
export const DescribeImageResponse = S.suspend(() =>
  S.Struct({
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Description: S.optional(S.String),
    DisplayName: S.optional(S.String),
    FailureReason: S.optional(S.String),
    ImageArn: S.optional(S.String),
    ImageName: S.optional(S.String),
    ImageStatus: S.optional(ImageStatus),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    RoleArn: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "DescribeImageResponse",
}) as any as S.Schema<DescribeImageResponse>;
export interface DescribeImageVersionRequest {
  ImageName?: string;
  Version?: number;
  Alias?: string;
}
export const DescribeImageVersionRequest = S.suspend(() =>
  S.Struct({
    ImageName: S.optional(S.String),
    Version: S.optional(S.Number),
    Alias: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeImageVersionRequest",
}) as any as S.Schema<DescribeImageVersionRequest>;
export type ImageVersionStatus =
  | "CREATING"
  | "CREATED"
  | "CREATE_FAILED"
  | "DELETING"
  | "DELETE_FAILED"
  | (string & {});
export const ImageVersionStatus = S.String;
export interface DescribeImageVersionResponse {
  BaseImage?: string;
  ContainerImage?: string;
  CreationTime?: Date;
  FailureReason?: string;
  ImageArn?: string;
  ImageVersionArn?: string;
  ImageVersionStatus?: ImageVersionStatus;
  LastModifiedTime?: Date;
  Version?: number;
  VendorGuidance?: VendorGuidance;
  JobType?: JobType;
  MLFramework?: string;
  ProgrammingLang?: string;
  Processor?: Processor;
  Horovod?: boolean;
  ReleaseNotes?: string;
}
export const DescribeImageVersionResponse = S.suspend(() =>
  S.Struct({
    BaseImage: S.optional(S.String),
    ContainerImage: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    FailureReason: S.optional(S.String),
    ImageArn: S.optional(S.String),
    ImageVersionArn: S.optional(S.String),
    ImageVersionStatus: S.optional(ImageVersionStatus),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    Version: S.optional(S.Number),
    VendorGuidance: S.optional(VendorGuidance),
    JobType: S.optional(JobType),
    MLFramework: S.optional(S.String),
    ProgrammingLang: S.optional(S.String),
    Processor: S.optional(Processor),
    Horovod: S.optional(S.Boolean),
    ReleaseNotes: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "DescribeImageVersionResponse",
}) as any as S.Schema<DescribeImageVersionResponse>;
export interface DescribeInferenceComponentInput {
  InferenceComponentName?: string;
}
export const DescribeInferenceComponentInput = S.suspend(() =>
  S.Struct({ InferenceComponentName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInferenceComponentInput",
}) as any as S.Schema<DescribeInferenceComponentInput>;
export interface InferenceComponentContainerSpecificationSummary {
  DeployedImage?: DeployedImage;
  ArtifactUrl?: string;
  Environment?: { [key: string]: string | undefined };
}
export const InferenceComponentContainerSpecificationSummary = S.suspend(() =>
  S.Struct({
    DeployedImage: S.optional(DeployedImage),
    ArtifactUrl: S.optional(S.String),
    Environment: S.optional(EnvironmentMap),
  }),
).annotate({
  identifier: "InferenceComponentContainerSpecificationSummary",
}) as any as S.Schema<InferenceComponentContainerSpecificationSummary>;
export interface InferenceComponentDataCacheConfigSummary {
  EnableCaching?: boolean;
}
export const InferenceComponentDataCacheConfigSummary = S.suspend(() =>
  S.Struct({ EnableCaching: S.optional(S.Boolean) }),
).annotate({
  identifier: "InferenceComponentDataCacheConfigSummary",
}) as any as S.Schema<InferenceComponentDataCacheConfigSummary>;
export interface InferenceComponentSpecificationSummary {
  ModelName?: string;
  Container?: InferenceComponentContainerSpecificationSummary;
  StartupParameters?: InferenceComponentStartupParameters;
  ComputeResourceRequirements?: InferenceComponentComputeResourceRequirements;
  BaseInferenceComponentName?: string;
  DataCacheConfig?: InferenceComponentDataCacheConfigSummary;
}
export const InferenceComponentSpecificationSummary = S.suspend(() =>
  S.Struct({
    ModelName: S.optional(S.String),
    Container: S.optional(InferenceComponentContainerSpecificationSummary),
    StartupParameters: S.optional(InferenceComponentStartupParameters),
    ComputeResourceRequirements: S.optional(
      InferenceComponentComputeResourceRequirements,
    ),
    BaseInferenceComponentName: S.optional(S.String),
    DataCacheConfig: S.optional(InferenceComponentDataCacheConfigSummary),
  }),
).annotate({
  identifier: "InferenceComponentSpecificationSummary",
}) as any as S.Schema<InferenceComponentSpecificationSummary>;
export interface InferenceComponentRuntimeConfigSummary {
  DesiredCopyCount?: number;
  CurrentCopyCount?: number;
}
export const InferenceComponentRuntimeConfigSummary = S.suspend(() =>
  S.Struct({
    DesiredCopyCount: S.optional(S.Number),
    CurrentCopyCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "InferenceComponentRuntimeConfigSummary",
}) as any as S.Schema<InferenceComponentRuntimeConfigSummary>;
export type InferenceComponentStatus =
  | "InService"
  | "Creating"
  | "Updating"
  | "Failed"
  | "Deleting"
  | (string & {});
export const InferenceComponentStatus = S.String;
export type InferenceComponentCapacitySizeType =
  | "COPY_COUNT"
  | "CAPACITY_PERCENT"
  | (string & {});
export const InferenceComponentCapacitySizeType = S.String;
export interface InferenceComponentCapacitySize {
  Type?: InferenceComponentCapacitySizeType;
  Value?: number;
}
export const InferenceComponentCapacitySize = S.suspend(() =>
  S.Struct({
    Type: S.optional(InferenceComponentCapacitySizeType),
    Value: S.optional(S.Number),
  }),
).annotate({
  identifier: "InferenceComponentCapacitySize",
}) as any as S.Schema<InferenceComponentCapacitySize>;
export interface InferenceComponentRollingUpdatePolicy {
  MaximumBatchSize?: InferenceComponentCapacitySize;
  WaitIntervalInSeconds?: number;
  MaximumExecutionTimeoutInSeconds?: number;
  RollbackMaximumBatchSize?: InferenceComponentCapacitySize;
}
export const InferenceComponentRollingUpdatePolicy = S.suspend(() =>
  S.Struct({
    MaximumBatchSize: S.optional(InferenceComponentCapacitySize),
    WaitIntervalInSeconds: S.optional(S.Number),
    MaximumExecutionTimeoutInSeconds: S.optional(S.Number),
    RollbackMaximumBatchSize: S.optional(InferenceComponentCapacitySize),
  }),
).annotate({
  identifier: "InferenceComponentRollingUpdatePolicy",
}) as any as S.Schema<InferenceComponentRollingUpdatePolicy>;
export interface InferenceComponentDeploymentConfig {
  RollingUpdatePolicy?: InferenceComponentRollingUpdatePolicy;
  AutoRollbackConfiguration?: AutoRollbackConfig;
}
export const InferenceComponentDeploymentConfig = S.suspend(() =>
  S.Struct({
    RollingUpdatePolicy: S.optional(InferenceComponentRollingUpdatePolicy),
    AutoRollbackConfiguration: S.optional(AutoRollbackConfig),
  }),
).annotate({
  identifier: "InferenceComponentDeploymentConfig",
}) as any as S.Schema<InferenceComponentDeploymentConfig>;
export interface DescribeInferenceComponentOutput {
  InferenceComponentName: string;
  InferenceComponentArn: string;
  EndpointName: string;
  EndpointArn: string;
  VariantName?: string;
  FailureReason?: string;
  Specification?: InferenceComponentSpecificationSummary & {
    ComputeResourceRequirements: InferenceComponentComputeResourceRequirements & {
      MinMemoryRequiredInMb: MemoryInMb;
    };
    DataCacheConfig: InferenceComponentDataCacheConfigSummary & {
      EnableCaching: EnableCaching;
    };
  };
  RuntimeConfig?: InferenceComponentRuntimeConfigSummary;
  CreationTime: Date;
  LastModifiedTime: Date;
  InferenceComponentStatus?: InferenceComponentStatus;
  LastDeploymentConfig?: InferenceComponentDeploymentConfig & {
    RollingUpdatePolicy: InferenceComponentRollingUpdatePolicy & {
      MaximumBatchSize: InferenceComponentCapacitySize & {
        Type: InferenceComponentCapacitySizeType;
        Value: CapacitySizeValue;
      };
      WaitIntervalInSeconds: WaitIntervalInSeconds;
      RollbackMaximumBatchSize: InferenceComponentCapacitySize & {
        Type: InferenceComponentCapacitySizeType;
        Value: CapacitySizeValue;
      };
    };
  };
}
export const DescribeInferenceComponentOutput = S.suspend(() =>
  S.Struct({
    InferenceComponentName: S.optional(S.String),
    InferenceComponentArn: S.optional(S.String),
    EndpointName: S.optional(S.String),
    EndpointArn: S.optional(S.String),
    VariantName: S.optional(S.String),
    FailureReason: S.optional(S.String),
    Specification: S.optional(InferenceComponentSpecificationSummary),
    RuntimeConfig: S.optional(InferenceComponentRuntimeConfigSummary),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    InferenceComponentStatus: S.optional(InferenceComponentStatus),
    LastDeploymentConfig: S.optional(InferenceComponentDeploymentConfig),
  }).pipe(ns),
).annotate({
  identifier: "DescribeInferenceComponentOutput",
}) as any as S.Schema<DescribeInferenceComponentOutput>;
export interface DescribeInferenceExperimentRequest {
  Name?: string;
}
export const DescribeInferenceExperimentRequest = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInferenceExperimentRequest",
}) as any as S.Schema<DescribeInferenceExperimentRequest>;
export type InferenceExperimentStatus =
  | "Creating"
  | "Created"
  | "Updating"
  | "Running"
  | "Starting"
  | "Stopping"
  | "Completed"
  | "Cancelled"
  | (string & {});
export const InferenceExperimentStatus = S.String;
export interface EndpointMetadata {
  EndpointName?: string;
  EndpointConfigName?: string;
  EndpointStatus?: EndpointStatus;
  FailureReason?: string;
}
export const EndpointMetadata = S.suspend(() =>
  S.Struct({
    EndpointName: S.optional(S.String),
    EndpointConfigName: S.optional(S.String),
    EndpointStatus: S.optional(EndpointStatus),
    FailureReason: S.optional(S.String),
  }),
).annotate({
  identifier: "EndpointMetadata",
}) as any as S.Schema<EndpointMetadata>;
export type ModelVariantStatus =
  | "Creating"
  | "Updating"
  | "InService"
  | "Deleting"
  | "Deleted"
  | (string & {});
export const ModelVariantStatus = S.String;
export interface ModelVariantConfigSummary {
  ModelName?: string;
  VariantName?: string;
  InfrastructureConfig?: ModelInfrastructureConfig;
  Status?: ModelVariantStatus;
}
export const ModelVariantConfigSummary = S.suspend(() =>
  S.Struct({
    ModelName: S.optional(S.String),
    VariantName: S.optional(S.String),
    InfrastructureConfig: S.optional(ModelInfrastructureConfig),
    Status: S.optional(ModelVariantStatus),
  }),
).annotate({
  identifier: "ModelVariantConfigSummary",
}) as any as S.Schema<ModelVariantConfigSummary>;
export type ModelVariantConfigSummaryList = ModelVariantConfigSummary[];
export const ModelVariantConfigSummaryList = S.Array(ModelVariantConfigSummary);
export interface DescribeInferenceExperimentResponse {
  Arn: string;
  Name: string;
  Type: InferenceExperimentType;
  Schedule?: InferenceExperimentSchedule;
  Status: InferenceExperimentStatus;
  StatusReason?: string;
  Description?: string;
  CreationTime?: Date;
  CompletionTime?: Date;
  LastModifiedTime?: Date;
  RoleArn?: string;
  EndpointMetadata: EndpointMetadata & { EndpointName: EndpointName };
  ModelVariants: (ModelVariantConfigSummary & {
    ModelName: ModelName;
    VariantName: ModelVariantName;
    InfrastructureConfig: ModelInfrastructureConfig & {
      InfrastructureType: ModelInfrastructureType;
      RealTimeInferenceConfig: RealTimeInferenceConfig & {
        InstanceType: InstanceType;
        InstanceCount: TaskCount;
      };
    };
    Status: ModelVariantStatus;
  })[];
  DataStorageConfig?: InferenceExperimentDataStorageConfig & {
    Destination: DestinationS3Uri;
  };
  ShadowModeConfig?: ShadowModeConfig & {
    SourceModelVariantName: ModelVariantName;
    ShadowModelVariants: (ShadowModelVariantConfig & {
      ShadowModelVariantName: ModelVariantName;
      SamplingPercentage: Percentage;
    })[];
  };
  KmsKey?: string;
}
export const DescribeInferenceExperimentResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    Type: S.optional(InferenceExperimentType),
    Schedule: S.optional(InferenceExperimentSchedule),
    Status: S.optional(InferenceExperimentStatus),
    StatusReason: S.optional(S.String),
    Description: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CompletionTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    RoleArn: S.optional(S.String),
    EndpointMetadata: S.optional(EndpointMetadata),
    ModelVariants: S.optional(ModelVariantConfigSummaryList),
    DataStorageConfig: S.optional(InferenceExperimentDataStorageConfig),
    ShadowModeConfig: S.optional(ShadowModeConfig),
    KmsKey: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "DescribeInferenceExperimentResponse",
}) as any as S.Schema<DescribeInferenceExperimentResponse>;
export interface DescribeInferenceRecommendationsJobRequest {
  JobName?: string;
}
export const DescribeInferenceRecommendationsJobRequest = S.suspend(() =>
  S.Struct({ JobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInferenceRecommendationsJobRequest",
}) as any as S.Schema<DescribeInferenceRecommendationsJobRequest>;
export type RecommendationJobStatus =
  | "PENDING"
  | "IN_PROGRESS"
  | "COMPLETED"
  | "FAILED"
  | "STOPPING"
  | "STOPPED"
  | "DELETING"
  | "DELETED"
  | (string & {});
export const RecommendationJobStatus = S.String;
export interface RecommendationMetrics {
  CostPerHour?: number;
  CostPerInference?: number;
  MaxInvocations?: number;
  ModelLatency?: number;
  CpuUtilization?: number;
  MemoryUtilization?: number;
  ModelSetupTime?: number;
}
export const RecommendationMetrics = S.suspend(() =>
  S.Struct({
    CostPerHour: S.optional(S.Number),
    CostPerInference: S.optional(S.Number),
    MaxInvocations: S.optional(S.Number),
    ModelLatency: S.optional(S.Number),
    CpuUtilization: S.optional(S.Number),
    MemoryUtilization: S.optional(S.Number),
    ModelSetupTime: S.optional(S.Number),
  }),
).annotate({
  identifier: "RecommendationMetrics",
}) as any as S.Schema<RecommendationMetrics>;
export interface EndpointOutputConfiguration {
  EndpointName?: string;
  VariantName?: string;
  InstanceType?: ProductionVariantInstanceType;
  InitialInstanceCount?: number;
  ServerlessConfig?: ProductionVariantServerlessConfig;
}
export const EndpointOutputConfiguration = S.suspend(() =>
  S.Struct({
    EndpointName: S.optional(S.String),
    VariantName: S.optional(S.String),
    InstanceType: S.optional(ProductionVariantInstanceType),
    InitialInstanceCount: S.optional(S.Number),
    ServerlessConfig: S.optional(ProductionVariantServerlessConfig),
  }),
).annotate({
  identifier: "EndpointOutputConfiguration",
}) as any as S.Schema<EndpointOutputConfiguration>;
export interface EnvironmentParameter {
  Key?: string;
  ValueType?: string;
  Value?: string;
}
export const EnvironmentParameter = S.suspend(() =>
  S.Struct({
    Key: S.optional(S.String),
    ValueType: S.optional(S.String),
    Value: S.optional(S.String),
  }),
).annotate({
  identifier: "EnvironmentParameter",
}) as any as S.Schema<EnvironmentParameter>;
export type EnvironmentParameters = EnvironmentParameter[];
export const EnvironmentParameters = S.Array(EnvironmentParameter);
export interface ModelConfiguration {
  InferenceSpecificationName?: string;
  EnvironmentParameters?: EnvironmentParameter[];
  CompilationJobName?: string;
}
export const ModelConfiguration = S.suspend(() =>
  S.Struct({
    InferenceSpecificationName: S.optional(S.String),
    EnvironmentParameters: S.optional(EnvironmentParameters),
    CompilationJobName: S.optional(S.String),
  }),
).annotate({
  identifier: "ModelConfiguration",
}) as any as S.Schema<ModelConfiguration>;
export interface InferenceRecommendation {
  RecommendationId?: string;
  Metrics?: RecommendationMetrics;
  EndpointConfiguration?: EndpointOutputConfiguration;
  ModelConfiguration?: ModelConfiguration;
  InvocationEndTime?: Date;
  InvocationStartTime?: Date;
}
export const InferenceRecommendation = S.suspend(() =>
  S.Struct({
    RecommendationId: S.optional(S.String),
    Metrics: S.optional(RecommendationMetrics),
    EndpointConfiguration: S.optional(EndpointOutputConfiguration),
    ModelConfiguration: S.optional(ModelConfiguration),
    InvocationEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    InvocationStartTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "InferenceRecommendation",
}) as any as S.Schema<InferenceRecommendation>;
export type InferenceRecommendations = InferenceRecommendation[];
export const InferenceRecommendations = S.Array(InferenceRecommendation);
export interface InferenceMetrics {
  MaxInvocations?: number;
  ModelLatency?: number;
}
export const InferenceMetrics = S.suspend(() =>
  S.Struct({
    MaxInvocations: S.optional(S.Number),
    ModelLatency: S.optional(S.Number),
  }),
).annotate({
  identifier: "InferenceMetrics",
}) as any as S.Schema<InferenceMetrics>;
export interface EndpointPerformance {
  Metrics?: InferenceMetrics;
  EndpointInfo?: EndpointInfo;
}
export const EndpointPerformance = S.suspend(() =>
  S.Struct({
    Metrics: S.optional(InferenceMetrics),
    EndpointInfo: S.optional(EndpointInfo),
  }),
).annotate({
  identifier: "EndpointPerformance",
}) as any as S.Schema<EndpointPerformance>;
export type EndpointPerformances = EndpointPerformance[];
export const EndpointPerformances = S.Array(EndpointPerformance);
export interface DescribeInferenceRecommendationsJobResponse {
  JobName: string;
  JobDescription?: string;
  JobType: RecommendationJobType;
  JobArn: string;
  RoleArn: string;
  Status: RecommendationJobStatus;
  CreationTime: Date;
  CompletionTime?: Date;
  LastModifiedTime: Date;
  FailureReason?: string;
  InputConfig: RecommendationJobInputConfig & {
    EndpointConfigurations: (EndpointInputConfiguration & {
      ServerlessConfig: ProductionVariantServerlessConfig & {
        MemorySizeInMB: ServerlessMemorySizeInMB;
        MaxConcurrency: ServerlessMaxConcurrency;
      };
      EnvironmentParameterRanges: EnvironmentParameterRanges & {
        CategoricalParameterRanges: (CategoricalParameter & {
          Name: String64;
          Value: CategoricalParameterRangeValues;
        })[];
      };
    })[];
    VpcConfig: RecommendationJobVpcConfig & {
      SecurityGroupIds: RecommendationJobVpcSecurityGroupIds;
      Subnets: RecommendationJobVpcSubnets;
    };
  };
  StoppingConditions?: RecommendationJobStoppingConditions;
  InferenceRecommendations?: (InferenceRecommendation & {
    EndpointConfiguration: EndpointOutputConfiguration & {
      EndpointName: string;
      VariantName: string;
      ServerlessConfig: ProductionVariantServerlessConfig & {
        MemorySizeInMB: ServerlessMemorySizeInMB;
        MaxConcurrency: ServerlessMaxConcurrency;
      };
    };
    ModelConfiguration: ModelConfiguration & {
      EnvironmentParameters: (EnvironmentParameter & {
        Key: string;
        ValueType: string;
        Value: string;
      })[];
    };
  })[];
  EndpointPerformances?: (EndpointPerformance & {
    Metrics: InferenceMetrics & {
      MaxInvocations: number;
      ModelLatency: number;
    };
    EndpointInfo: EndpointInfo;
  })[];
}
export const DescribeInferenceRecommendationsJobResponse = S.suspend(() =>
  S.Struct({
    JobName: S.optional(S.String),
    JobDescription: S.optional(S.String),
    JobType: S.optional(RecommendationJobType),
    JobArn: S.optional(S.String),
    RoleArn: S.optional(S.String),
    Status: S.optional(RecommendationJobStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CompletionTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    FailureReason: S.optional(S.String),
    InputConfig: S.optional(RecommendationJobInputConfig),
    StoppingConditions: S.optional(RecommendationJobStoppingConditions),
    InferenceRecommendations: S.optional(InferenceRecommendations),
    EndpointPerformances: S.optional(EndpointPerformances),
  }).pipe(ns),
).annotate({
  identifier: "DescribeInferenceRecommendationsJobResponse",
}) as any as S.Schema<DescribeInferenceRecommendationsJobResponse>;
export interface DescribeLabelingJobRequest {
  LabelingJobName?: string;
}
export const DescribeLabelingJobRequest = S.suspend(() =>
  S.Struct({ LabelingJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeLabelingJobRequest",
}) as any as S.Schema<DescribeLabelingJobRequest>;
export type LabelingJobStatus =
  | "Initializing"
  | "InProgress"
  | "Completed"
  | "Failed"
  | "Stopping"
  | "Stopped"
  | (string & {});
export const LabelingJobStatus = S.String;
export interface LabelCounters {
  TotalLabeled?: number;
  HumanLabeled?: number;
  MachineLabeled?: number;
  FailedNonRetryableError?: number;
  Unlabeled?: number;
}
export const LabelCounters = S.suspend(() =>
  S.Struct({
    TotalLabeled: S.optional(S.Number),
    HumanLabeled: S.optional(S.Number),
    MachineLabeled: S.optional(S.Number),
    FailedNonRetryableError: S.optional(S.Number),
    Unlabeled: S.optional(S.Number),
  }),
).annotate({ identifier: "LabelCounters" }) as any as S.Schema<LabelCounters>;
export interface LabelingJobOutput {
  OutputDatasetS3Uri?: string;
  FinalActiveLearningModelArn?: string;
}
export const LabelingJobOutput = S.suspend(() =>
  S.Struct({
    OutputDatasetS3Uri: S.optional(S.String),
    FinalActiveLearningModelArn: S.optional(S.String),
  }),
).annotate({
  identifier: "LabelingJobOutput",
}) as any as S.Schema<LabelingJobOutput>;
export interface DescribeLabelingJobResponse {
  LabelingJobStatus: LabelingJobStatus;
  LabelCounters: LabelCounters;
  FailureReason?: string;
  CreationTime: Date;
  LastModifiedTime: Date;
  JobReferenceCode: string;
  LabelingJobName: string;
  LabelingJobArn: string;
  LabelAttributeName?: string;
  InputConfig: LabelingJobInputConfig & {
    DataSource: LabelingJobDataSource & {
      S3DataSource: LabelingJobS3DataSource & { ManifestS3Uri: S3Uri };
      SnsDataSource: LabelingJobSnsDataSource & { SnsTopicArn: SnsTopicArn };
    };
  };
  OutputConfig: LabelingJobOutputConfig & { S3OutputPath: S3Uri };
  RoleArn: string;
  LabelCategoryConfigS3Uri?: string;
  StoppingConditions?: LabelingJobStoppingConditions;
  LabelingJobAlgorithmsConfig?: LabelingJobAlgorithmsConfig & {
    LabelingJobAlgorithmSpecificationArn: LabelingJobAlgorithmSpecificationArn;
    LabelingJobResourceConfig: LabelingJobResourceConfig & {
      VpcConfig: VpcConfig & {
        SecurityGroupIds: VpcSecurityGroupIds;
        Subnets: Subnets;
      };
    };
  };
  HumanTaskConfig: HumanTaskConfig & {
    WorkteamArn: WorkteamArn;
    UiConfig: UiConfig;
    TaskTitle: TaskTitle;
    TaskDescription: TaskDescription;
    NumberOfHumanWorkersPerDataObject: NumberOfHumanWorkersPerDataObject;
    TaskTimeLimitInSeconds: TaskTimeLimitInSeconds;
    AnnotationConsolidationConfig: AnnotationConsolidationConfig & {
      AnnotationConsolidationLambdaArn: LambdaFunctionArn;
    };
  };
  Tags?: (Tag & { Key: TagKey; Value: TagValue })[];
  LabelingJobOutput?: LabelingJobOutput & { OutputDatasetS3Uri: S3Uri };
}
export const DescribeLabelingJobResponse = S.suspend(() =>
  S.Struct({
    LabelingJobStatus: S.optional(LabelingJobStatus),
    LabelCounters: S.optional(LabelCounters),
    FailureReason: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    JobReferenceCode: S.optional(S.String),
    LabelingJobName: S.optional(S.String),
    LabelingJobArn: S.optional(S.String),
    LabelAttributeName: S.optional(S.String),
    InputConfig: S.optional(LabelingJobInputConfig),
    OutputConfig: S.optional(LabelingJobOutputConfig),
    RoleArn: S.optional(S.String),
    LabelCategoryConfigS3Uri: S.optional(S.String),
    StoppingConditions: S.optional(LabelingJobStoppingConditions),
    LabelingJobAlgorithmsConfig: S.optional(LabelingJobAlgorithmsConfig),
    HumanTaskConfig: S.optional(HumanTaskConfig),
    Tags: S.optional(TagList),
    LabelingJobOutput: S.optional(LabelingJobOutput),
  }).pipe(ns),
).annotate({
  identifier: "DescribeLabelingJobResponse",
}) as any as S.Schema<DescribeLabelingJobResponse>;
export interface DescribeLineageGroupRequest {
  LineageGroupName?: string;
}
export const DescribeLineageGroupRequest = S.suspend(() =>
  S.Struct({ LineageGroupName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeLineageGroupRequest",
}) as any as S.Schema<DescribeLineageGroupRequest>;
export interface DescribeLineageGroupResponse {
  LineageGroupName?: string;
  LineageGroupArn?: string;
  DisplayName?: string;
  Description?: string;
  CreationTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
}
export const DescribeLineageGroupResponse = S.suspend(() =>
  S.Struct({
    LineageGroupName: S.optional(S.String),
    LineageGroupArn: S.optional(S.String),
    DisplayName: S.optional(S.String),
    Description: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
  }).pipe(ns),
).annotate({
  identifier: "DescribeLineageGroupResponse",
}) as any as S.Schema<DescribeLineageGroupResponse>;
export interface DescribeMlflowAppRequest {
  Arn?: string;
}
export const DescribeMlflowAppRequest = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeMlflowAppRequest",
}) as any as S.Schema<DescribeMlflowAppRequest>;
export type MlflowAppStatus =
  | "Creating"
  | "Created"
  | "CreateFailed"
  | "Updating"
  | "Updated"
  | "UpdateFailed"
  | "Deleting"
  | "DeleteFailed"
  | "Deleted"
  | (string & {});
export const MlflowAppStatus = S.String;
export type MaintenanceStatus =
  | "MaintenanceInProgress"
  | "MaintenanceComplete"
  | "MaintenanceFailed"
  | (string & {});
export const MaintenanceStatus = S.String;
export interface DescribeMlflowAppResponse {
  Arn?: string;
  Name?: string;
  ArtifactStoreUri?: string;
  MlflowVersion?: string;
  RoleArn?: string;
  Status?: MlflowAppStatus;
  ModelRegistrationMode?: ModelRegistrationMode;
  AccountDefaultStatus?: AccountDefaultStatus;
  DefaultDomainIdList?: string[];
  CreationTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
  WeeklyMaintenanceWindowStart?: string;
  MaintenanceStatus?: MaintenanceStatus;
}
export const DescribeMlflowAppResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    ArtifactStoreUri: S.optional(S.String),
    MlflowVersion: S.optional(S.String),
    RoleArn: S.optional(S.String),
    Status: S.optional(MlflowAppStatus),
    ModelRegistrationMode: S.optional(ModelRegistrationMode),
    AccountDefaultStatus: S.optional(AccountDefaultStatus),
    DefaultDomainIdList: S.optional(DefaultDomainIdList),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
    WeeklyMaintenanceWindowStart: S.optional(S.String),
    MaintenanceStatus: S.optional(MaintenanceStatus),
  }).pipe(ns),
).annotate({
  identifier: "DescribeMlflowAppResponse",
}) as any as S.Schema<DescribeMlflowAppResponse>;
export interface DescribeMlflowTrackingServerRequest {
  TrackingServerName?: string;
}
export const DescribeMlflowTrackingServerRequest = S.suspend(() =>
  S.Struct({ TrackingServerName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeMlflowTrackingServerRequest",
}) as any as S.Schema<DescribeMlflowTrackingServerRequest>;
export type TrackingServerStatus =
  | "Creating"
  | "Created"
  | "CreateFailed"
  | "Updating"
  | "Updated"
  | "UpdateFailed"
  | "Deleting"
  | "DeleteFailed"
  | "Stopping"
  | "Stopped"
  | "StopFailed"
  | "Starting"
  | "Started"
  | "StartFailed"
  | "MaintenanceInProgress"
  | "MaintenanceComplete"
  | "MaintenanceFailed"
  | (string & {});
export const TrackingServerStatus = S.String;
export type TrackingServerMaintenanceStatus =
  | "MaintenanceInProgress"
  | "MaintenanceComplete"
  | "MaintenanceFailed"
  | (string & {});
export const TrackingServerMaintenanceStatus = S.String;
export type IsTrackingServerActive = "Active" | "Inactive" | (string & {});
export const IsTrackingServerActive = S.String;
export interface DescribeMlflowTrackingServerResponse {
  TrackingServerArn?: string;
  TrackingServerName?: string;
  ArtifactStoreUri?: string;
  TrackingServerSize?: TrackingServerSize;
  MlflowVersion?: string;
  RoleArn?: string;
  TrackingServerStatus?: TrackingServerStatus;
  TrackingServerMaintenanceStatus?: TrackingServerMaintenanceStatus;
  IsActive?: IsTrackingServerActive;
  TrackingServerUrl?: string;
  WeeklyMaintenanceWindowStart?: string;
  AutomaticModelRegistration?: boolean;
  CreationTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
}
export const DescribeMlflowTrackingServerResponse = S.suspend(() =>
  S.Struct({
    TrackingServerArn: S.optional(S.String),
    TrackingServerName: S.optional(S.String),
    ArtifactStoreUri: S.optional(S.String),
    TrackingServerSize: S.optional(TrackingServerSize),
    MlflowVersion: S.optional(S.String),
    RoleArn: S.optional(S.String),
    TrackingServerStatus: S.optional(TrackingServerStatus),
    TrackingServerMaintenanceStatus: S.optional(
      TrackingServerMaintenanceStatus,
    ),
    IsActive: S.optional(IsTrackingServerActive),
    TrackingServerUrl: S.optional(S.String),
    WeeklyMaintenanceWindowStart: S.optional(S.String),
    AutomaticModelRegistration: S.optional(S.Boolean),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
  }).pipe(ns),
).annotate({
  identifier: "DescribeMlflowTrackingServerResponse",
}) as any as S.Schema<DescribeMlflowTrackingServerResponse>;
export interface DescribeModelInput {
  ModelName?: string;
}
export const DescribeModelInput = S.suspend(() =>
  S.Struct({ ModelName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeModelInput",
}) as any as S.Schema<DescribeModelInput>;
export type RecommendationStatus =
  | "IN_PROGRESS"
  | "COMPLETED"
  | "FAILED"
  | "NOT_APPLICABLE"
  | (string & {});
export const RecommendationStatus = S.String;
export interface RealTimeInferenceRecommendation {
  RecommendationId?: string;
  InstanceType?: ProductionVariantInstanceType;
  Environment?: { [key: string]: string | undefined };
}
export const RealTimeInferenceRecommendation = S.suspend(() =>
  S.Struct({
    RecommendationId: S.optional(S.String),
    InstanceType: S.optional(ProductionVariantInstanceType),
    Environment: S.optional(EnvironmentMap),
  }),
).annotate({
  identifier: "RealTimeInferenceRecommendation",
}) as any as S.Schema<RealTimeInferenceRecommendation>;
export type RealTimeInferenceRecommendations =
  RealTimeInferenceRecommendation[];
export const RealTimeInferenceRecommendations = S.Array(
  RealTimeInferenceRecommendation,
);
export interface DeploymentRecommendation {
  RecommendationStatus?: RecommendationStatus;
  RealTimeInferenceRecommendations?: RealTimeInferenceRecommendation[];
}
export const DeploymentRecommendation = S.suspend(() =>
  S.Struct({
    RecommendationStatus: S.optional(RecommendationStatus),
    RealTimeInferenceRecommendations: S.optional(
      RealTimeInferenceRecommendations,
    ),
  }),
).annotate({
  identifier: "DeploymentRecommendation",
}) as any as S.Schema<DeploymentRecommendation>;
export interface DescribeModelOutput {
  ModelName: string;
  PrimaryContainer?: ContainerDefinition & {
    ImageConfig: ImageConfig & {
      RepositoryAccessMode: RepositoryAccessMode;
      RepositoryAuthConfig: RepositoryAuthConfig & {
        RepositoryCredentialsProviderArn: RepositoryCredentialsProviderArn;
      };
    };
    ModelDataSource: ModelDataSource & {
      S3DataSource: S3ModelDataSource & {
        S3Uri: S3ModelUri;
        S3DataType: S3ModelDataType;
        CompressionType: ModelCompressionType;
        ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
        HubAccessConfig: InferenceHubAccessConfig & {
          HubContentArn: HubContentArn;
        };
      };
    };
    AdditionalModelDataSources: (AdditionalModelDataSource & {
      ChannelName: AdditionalModelChannelName;
      S3DataSource: S3ModelDataSource & {
        S3Uri: S3ModelUri;
        S3DataType: S3ModelDataType;
        CompressionType: ModelCompressionType;
        ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
        HubAccessConfig: InferenceHubAccessConfig & {
          HubContentArn: HubContentArn;
        };
      };
    })[];
  };
  Containers?: (ContainerDefinition & {
    ImageConfig: ImageConfig & {
      RepositoryAccessMode: RepositoryAccessMode;
      RepositoryAuthConfig: RepositoryAuthConfig & {
        RepositoryCredentialsProviderArn: RepositoryCredentialsProviderArn;
      };
    };
    ModelDataSource: ModelDataSource & {
      S3DataSource: S3ModelDataSource & {
        S3Uri: S3ModelUri;
        S3DataType: S3ModelDataType;
        CompressionType: ModelCompressionType;
        ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
        HubAccessConfig: InferenceHubAccessConfig & {
          HubContentArn: HubContentArn;
        };
      };
    };
    AdditionalModelDataSources: (AdditionalModelDataSource & {
      ChannelName: AdditionalModelChannelName;
      S3DataSource: S3ModelDataSource & {
        S3Uri: S3ModelUri;
        S3DataType: S3ModelDataType;
        CompressionType: ModelCompressionType;
        ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
        HubAccessConfig: InferenceHubAccessConfig & {
          HubContentArn: HubContentArn;
        };
      };
    })[];
  })[];
  InferenceExecutionConfig?: InferenceExecutionConfig & {
    Mode: InferenceExecutionMode;
  };
  ExecutionRoleArn?: string;
  VpcConfig?: VpcConfig & {
    SecurityGroupIds: VpcSecurityGroupIds;
    Subnets: Subnets;
  };
  CreationTime: Date;
  ModelArn: string;
  EnableNetworkIsolation?: boolean;
  DeploymentRecommendation?: DeploymentRecommendation & {
    RecommendationStatus: RecommendationStatus;
    RealTimeInferenceRecommendations: (RealTimeInferenceRecommendation & {
      RecommendationId: string;
      InstanceType: ProductionVariantInstanceType;
    })[];
  };
}
export const DescribeModelOutput = S.suspend(() =>
  S.Struct({
    ModelName: S.optional(S.String),
    PrimaryContainer: S.optional(ContainerDefinition),
    Containers: S.optional(ContainerDefinitionList),
    InferenceExecutionConfig: S.optional(InferenceExecutionConfig),
    ExecutionRoleArn: S.optional(S.String),
    VpcConfig: S.optional(VpcConfig),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ModelArn: S.optional(S.String),
    EnableNetworkIsolation: S.optional(S.Boolean),
    DeploymentRecommendation: S.optional(DeploymentRecommendation),
  }).pipe(ns),
).annotate({
  identifier: "DescribeModelOutput",
}) as any as S.Schema<DescribeModelOutput>;
export interface DescribeModelBiasJobDefinitionRequest {
  JobDefinitionName?: string;
}
export const DescribeModelBiasJobDefinitionRequest = S.suspend(() =>
  S.Struct({ JobDefinitionName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeModelBiasJobDefinitionRequest",
}) as any as S.Schema<DescribeModelBiasJobDefinitionRequest>;
export interface DescribeModelBiasJobDefinitionResponse {
  JobDefinitionArn: string;
  JobDefinitionName: string;
  CreationTime: Date;
  ModelBiasBaselineConfig?: ModelBiasBaselineConfig;
  ModelBiasAppSpecification: ModelBiasAppSpecification & {
    ImageUri: ImageUri;
    ConfigUri: S3Uri;
  };
  ModelBiasJobInput: ModelBiasJobInput & {
    GroundTruthS3Input: MonitoringGroundTruthS3Input;
    EndpointInput: EndpointInput & {
      EndpointName: EndpointName;
      LocalPath: ProcessingLocalPath;
    };
    BatchTransformInput: BatchTransformInput & {
      DataCapturedDestinationS3Uri: DestinationS3Uri;
      DatasetFormat: MonitoringDatasetFormat;
      LocalPath: ProcessingLocalPath;
    };
  };
  ModelBiasJobOutputConfig: MonitoringOutputConfig & {
    MonitoringOutputs: (MonitoringOutput & {
      S3Output: MonitoringS3Output & {
        S3Uri: MonitoringS3Uri;
        LocalPath: ProcessingLocalPath;
      };
    })[];
  };
  JobResources: MonitoringResources & {
    ClusterConfig: MonitoringClusterConfig & {
      InstanceCount: ProcessingInstanceCount;
      InstanceType: ProcessingInstanceType;
      VolumeSizeInGB: ProcessingVolumeSizeInGB;
    };
  };
  NetworkConfig?: MonitoringNetworkConfig & {
    VpcConfig: VpcConfig & {
      SecurityGroupIds: VpcSecurityGroupIds;
      Subnets: Subnets;
    };
  };
  RoleArn: string;
  StoppingCondition?: MonitoringStoppingCondition & {
    MaxRuntimeInSeconds: MonitoringMaxRuntimeInSeconds;
  };
}
export const DescribeModelBiasJobDefinitionResponse = S.suspend(() =>
  S.Struct({
    JobDefinitionArn: S.optional(S.String),
    JobDefinitionName: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ModelBiasBaselineConfig: S.optional(ModelBiasBaselineConfig),
    ModelBiasAppSpecification: S.optional(ModelBiasAppSpecification),
    ModelBiasJobInput: S.optional(ModelBiasJobInput),
    ModelBiasJobOutputConfig: S.optional(MonitoringOutputConfig),
    JobResources: S.optional(MonitoringResources),
    NetworkConfig: S.optional(MonitoringNetworkConfig),
    RoleArn: S.optional(S.String),
    StoppingCondition: S.optional(MonitoringStoppingCondition),
  }).pipe(ns),
).annotate({
  identifier: "DescribeModelBiasJobDefinitionResponse",
}) as any as S.Schema<DescribeModelBiasJobDefinitionResponse>;
export interface DescribeModelCardRequest {
  ModelCardName?: string;
  ModelCardVersion?: number;
}
export const DescribeModelCardRequest = S.suspend(() =>
  S.Struct({
    ModelCardName: S.optional(S.String),
    ModelCardVersion: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeModelCardRequest",
}) as any as S.Schema<DescribeModelCardRequest>;
export type ModelCardProcessingStatus =
  | "DeleteInProgress"
  | "DeletePending"
  | "ContentDeleted"
  | "ExportJobsDeleted"
  | "DeleteCompleted"
  | "DeleteFailed"
  | (string & {});
export const ModelCardProcessingStatus = S.String;
export interface DescribeModelCardResponse {
  ModelCardArn: string;
  ModelCardName: string;
  ModelCardVersion: number;
  Content: string | redacted.Redacted<string>;
  ModelCardStatus: ModelCardStatus;
  SecurityConfig?: ModelCardSecurityConfig;
  CreationTime: Date;
  CreatedBy: UserContext;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
  ModelCardProcessingStatus?: ModelCardProcessingStatus;
}
export const DescribeModelCardResponse = S.suspend(() =>
  S.Struct({
    ModelCardArn: S.optional(S.String),
    ModelCardName: S.optional(S.String),
    ModelCardVersion: S.optional(S.Number),
    Content: S.optional(SensitiveString),
    ModelCardStatus: S.optional(ModelCardStatus),
    SecurityConfig: S.optional(ModelCardSecurityConfig),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
    ModelCardProcessingStatus: S.optional(ModelCardProcessingStatus),
  }).pipe(ns),
).annotate({
  identifier: "DescribeModelCardResponse",
}) as any as S.Schema<DescribeModelCardResponse>;
export interface DescribeModelCardExportJobRequest {
  ModelCardExportJobArn?: string;
}
export const DescribeModelCardExportJobRequest = S.suspend(() =>
  S.Struct({ ModelCardExportJobArn: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeModelCardExportJobRequest",
}) as any as S.Schema<DescribeModelCardExportJobRequest>;
export type ModelCardExportJobStatus =
  | "InProgress"
  | "Completed"
  | "Failed"
  | (string & {});
export const ModelCardExportJobStatus = S.String;
export interface ModelCardExportArtifacts {
  S3ExportArtifacts?: string;
}
export const ModelCardExportArtifacts = S.suspend(() =>
  S.Struct({ S3ExportArtifacts: S.optional(S.String) }),
).annotate({
  identifier: "ModelCardExportArtifacts",
}) as any as S.Schema<ModelCardExportArtifacts>;
export interface DescribeModelCardExportJobResponse {
  ModelCardExportJobName: string;
  ModelCardExportJobArn: string;
  Status: ModelCardExportJobStatus;
  ModelCardName: string;
  ModelCardVersion: number;
  OutputConfig: ModelCardExportOutputConfig & { S3OutputPath: S3Uri };
  CreatedAt: Date;
  LastModifiedAt: Date;
  FailureReason?: string;
  ExportArtifacts?: ModelCardExportArtifacts & { S3ExportArtifacts: S3Uri };
}
export const DescribeModelCardExportJobResponse = S.suspend(() =>
  S.Struct({
    ModelCardExportJobName: S.optional(S.String),
    ModelCardExportJobArn: S.optional(S.String),
    Status: S.optional(ModelCardExportJobStatus),
    ModelCardName: S.optional(S.String),
    ModelCardVersion: S.optional(S.Number),
    OutputConfig: S.optional(ModelCardExportOutputConfig),
    CreatedAt: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedAt: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    FailureReason: S.optional(S.String),
    ExportArtifacts: S.optional(ModelCardExportArtifacts),
  }).pipe(ns),
).annotate({
  identifier: "DescribeModelCardExportJobResponse",
}) as any as S.Schema<DescribeModelCardExportJobResponse>;
export interface DescribeModelExplainabilityJobDefinitionRequest {
  JobDefinitionName?: string;
}
export const DescribeModelExplainabilityJobDefinitionRequest = S.suspend(() =>
  S.Struct({ JobDefinitionName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeModelExplainabilityJobDefinitionRequest",
}) as any as S.Schema<DescribeModelExplainabilityJobDefinitionRequest>;
export interface DescribeModelExplainabilityJobDefinitionResponse {
  JobDefinitionArn: string;
  JobDefinitionName: string;
  CreationTime: Date;
  ModelExplainabilityBaselineConfig?: ModelExplainabilityBaselineConfig;
  ModelExplainabilityAppSpecification: ModelExplainabilityAppSpecification & {
    ImageUri: ImageUri;
    ConfigUri: S3Uri;
  };
  ModelExplainabilityJobInput: ModelExplainabilityJobInput & {
    EndpointInput: EndpointInput & {
      EndpointName: EndpointName;
      LocalPath: ProcessingLocalPath;
    };
    BatchTransformInput: BatchTransformInput & {
      DataCapturedDestinationS3Uri: DestinationS3Uri;
      DatasetFormat: MonitoringDatasetFormat;
      LocalPath: ProcessingLocalPath;
    };
  };
  ModelExplainabilityJobOutputConfig: MonitoringOutputConfig & {
    MonitoringOutputs: (MonitoringOutput & {
      S3Output: MonitoringS3Output & {
        S3Uri: MonitoringS3Uri;
        LocalPath: ProcessingLocalPath;
      };
    })[];
  };
  JobResources: MonitoringResources & {
    ClusterConfig: MonitoringClusterConfig & {
      InstanceCount: ProcessingInstanceCount;
      InstanceType: ProcessingInstanceType;
      VolumeSizeInGB: ProcessingVolumeSizeInGB;
    };
  };
  NetworkConfig?: MonitoringNetworkConfig & {
    VpcConfig: VpcConfig & {
      SecurityGroupIds: VpcSecurityGroupIds;
      Subnets: Subnets;
    };
  };
  RoleArn: string;
  StoppingCondition?: MonitoringStoppingCondition & {
    MaxRuntimeInSeconds: MonitoringMaxRuntimeInSeconds;
  };
}
export const DescribeModelExplainabilityJobDefinitionResponse = S.suspend(() =>
  S.Struct({
    JobDefinitionArn: S.optional(S.String),
    JobDefinitionName: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ModelExplainabilityBaselineConfig: S.optional(
      ModelExplainabilityBaselineConfig,
    ),
    ModelExplainabilityAppSpecification: S.optional(
      ModelExplainabilityAppSpecification,
    ),
    ModelExplainabilityJobInput: S.optional(ModelExplainabilityJobInput),
    ModelExplainabilityJobOutputConfig: S.optional(MonitoringOutputConfig),
    JobResources: S.optional(MonitoringResources),
    NetworkConfig: S.optional(MonitoringNetworkConfig),
    RoleArn: S.optional(S.String),
    StoppingCondition: S.optional(MonitoringStoppingCondition),
  }).pipe(ns),
).annotate({
  identifier: "DescribeModelExplainabilityJobDefinitionResponse",
}) as any as S.Schema<DescribeModelExplainabilityJobDefinitionResponse>;
export interface DescribeModelPackageInput {
  ModelPackageName?: string;
}
export const DescribeModelPackageInput = S.suspend(() =>
  S.Struct({ ModelPackageName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeModelPackageInput",
}) as any as S.Schema<DescribeModelPackageInput>;
export type DetailedModelPackageStatus =
  | "NotStarted"
  | "InProgress"
  | "Completed"
  | "Failed"
  | (string & {});
export const DetailedModelPackageStatus = S.String;
export interface ModelPackageStatusItem {
  Name?: string;
  Status?: DetailedModelPackageStatus;
  FailureReason?: string;
}
export const ModelPackageStatusItem = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Status: S.optional(DetailedModelPackageStatus),
    FailureReason: S.optional(S.String),
  }),
).annotate({
  identifier: "ModelPackageStatusItem",
}) as any as S.Schema<ModelPackageStatusItem>;
export type ModelPackageStatusItemList = ModelPackageStatusItem[];
export const ModelPackageStatusItemList = S.Array(ModelPackageStatusItem);
export interface ModelPackageStatusDetails {
  ValidationStatuses?: ModelPackageStatusItem[];
  ImageScanStatuses?: ModelPackageStatusItem[];
}
export const ModelPackageStatusDetails = S.suspend(() =>
  S.Struct({
    ValidationStatuses: S.optional(ModelPackageStatusItemList),
    ImageScanStatuses: S.optional(ModelPackageStatusItemList),
  }),
).annotate({
  identifier: "ModelPackageStatusDetails",
}) as any as S.Schema<ModelPackageStatusDetails>;
export interface DescribeModelPackageOutput {
  ModelPackageName: string;
  ModelPackageGroupName?: string;
  ModelPackageVersion?: number;
  ModelPackageRegistrationType?: ModelPackageRegistrationType;
  ModelPackageArn: string;
  ModelPackageDescription?: string;
  CreationTime: Date;
  InferenceSpecification?: InferenceSpecification & {
    Containers: (ModelPackageContainerDefinition & {
      ModelDataSource: ModelDataSource & {
        S3DataSource: S3ModelDataSource & {
          S3Uri: S3ModelUri;
          S3DataType: S3ModelDataType;
          CompressionType: ModelCompressionType;
          ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
          HubAccessConfig: InferenceHubAccessConfig & {
            HubContentArn: HubContentArn;
          };
        };
      };
      ModelInput: ModelInput & { DataInputConfig: DataInputConfig };
      AdditionalS3DataSource: AdditionalS3DataSource & {
        S3DataType: AdditionalS3DataSourceDataType;
        S3Uri: S3Uri;
      };
    })[];
  };
  SourceAlgorithmSpecification?: SourceAlgorithmSpecification & {
    SourceAlgorithms: (SourceAlgorithm & {
      AlgorithmName: ArnOrName;
      ModelDataSource: ModelDataSource & {
        S3DataSource: S3ModelDataSource & {
          S3Uri: S3ModelUri;
          S3DataType: S3ModelDataType;
          CompressionType: ModelCompressionType;
          ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
          HubAccessConfig: InferenceHubAccessConfig & {
            HubContentArn: HubContentArn;
          };
        };
      };
    })[];
  };
  ValidationSpecification?: ModelPackageValidationSpecification & {
    ValidationRole: RoleArn;
    ValidationProfiles: (ModelPackageValidationProfile & {
      ProfileName: EntityName;
      TransformJobDefinition: TransformJobDefinition & {
        TransformInput: TransformInput & {
          DataSource: TransformDataSource & {
            S3DataSource: TransformS3DataSource & {
              S3DataType: S3DataType;
              S3Uri: S3Uri;
            };
          };
        };
        TransformOutput: TransformOutput & { S3OutputPath: S3Uri };
        TransformResources: TransformResources & {
          InstanceType: TransformInstanceType;
          InstanceCount: TransformInstanceCount;
        };
      };
    })[];
  };
  ModelPackageStatus: ModelPackageStatus;
  ModelPackageStatusDetails: ModelPackageStatusDetails & {
    ValidationStatuses: (ModelPackageStatusItem & {
      Name: EntityName;
      Status: DetailedModelPackageStatus;
    })[];
    ImageScanStatuses: (ModelPackageStatusItem & {
      Name: EntityName;
      Status: DetailedModelPackageStatus;
    })[];
  };
  CertifyForMarketplace?: boolean;
  ModelApprovalStatus?: ModelApprovalStatus;
  CreatedBy?: UserContext;
  MetadataProperties?: MetadataProperties;
  ModelMetrics?: ModelMetrics & {
    ModelQuality: ModelQuality & {
      Statistics: MetricsSource & { ContentType: ContentType; S3Uri: S3Uri };
      Constraints: MetricsSource & { ContentType: ContentType; S3Uri: S3Uri };
    };
    ModelDataQuality: ModelDataQuality & {
      Statistics: MetricsSource & { ContentType: ContentType; S3Uri: S3Uri };
      Constraints: MetricsSource & { ContentType: ContentType; S3Uri: S3Uri };
    };
    Bias: Bias & {
      Report: MetricsSource & { ContentType: ContentType; S3Uri: S3Uri };
      PreTrainingReport: MetricsSource & {
        ContentType: ContentType;
        S3Uri: S3Uri;
      };
      PostTrainingReport: MetricsSource & {
        ContentType: ContentType;
        S3Uri: S3Uri;
      };
    };
    Explainability: Explainability & {
      Report: MetricsSource & { ContentType: ContentType; S3Uri: S3Uri };
    };
  };
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
  ApprovalDescription?: string;
  Domain?: string;
  Task?: string;
  SamplePayloadUrl?: string;
  CustomerMetadataProperties?: { [key: string]: string | undefined };
  DriftCheckBaselines?: DriftCheckBaselines & {
    Bias: DriftCheckBias & {
      ConfigFile: FileSource & { S3Uri: S3Uri };
      PreTrainingConstraints: MetricsSource & {
        ContentType: ContentType;
        S3Uri: S3Uri;
      };
      PostTrainingConstraints: MetricsSource & {
        ContentType: ContentType;
        S3Uri: S3Uri;
      };
    };
    Explainability: DriftCheckExplainability & {
      Constraints: MetricsSource & { ContentType: ContentType; S3Uri: S3Uri };
      ConfigFile: FileSource & { S3Uri: S3Uri };
    };
    ModelQuality: DriftCheckModelQuality & {
      Statistics: MetricsSource & { ContentType: ContentType; S3Uri: S3Uri };
      Constraints: MetricsSource & { ContentType: ContentType; S3Uri: S3Uri };
    };
    ModelDataQuality: DriftCheckModelDataQuality & {
      Statistics: MetricsSource & { ContentType: ContentType; S3Uri: S3Uri };
      Constraints: MetricsSource & { ContentType: ContentType; S3Uri: S3Uri };
    };
  };
  AdditionalInferenceSpecifications?: (AdditionalInferenceSpecificationDefinition & {
    Name: EntityName;
    Containers: (ModelPackageContainerDefinition & {
      ModelDataSource: ModelDataSource & {
        S3DataSource: S3ModelDataSource & {
          S3Uri: S3ModelUri;
          S3DataType: S3ModelDataType;
          CompressionType: ModelCompressionType;
          ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
          HubAccessConfig: InferenceHubAccessConfig & {
            HubContentArn: HubContentArn;
          };
        };
      };
      ModelInput: ModelInput & { DataInputConfig: DataInputConfig };
      AdditionalS3DataSource: AdditionalS3DataSource & {
        S3DataType: AdditionalS3DataSourceDataType;
        S3Uri: S3Uri;
      };
    })[];
  })[];
  SkipModelValidation?: SkipModelValidation;
  SourceUri?: string;
  SecurityConfig?: ModelPackageSecurityConfig & { KmsKeyId: KmsKeyId };
  ModelCard?: ModelPackageModelCard;
  ModelLifeCycle?: ModelLifeCycle & {
    Stage: EntityName;
    StageStatus: EntityName;
  };
}
export const DescribeModelPackageOutput = S.suspend(() =>
  S.Struct({
    ModelPackageName: S.optional(S.String),
    ModelPackageGroupName: S.optional(S.String),
    ModelPackageVersion: S.optional(S.Number),
    ModelPackageRegistrationType: S.optional(ModelPackageRegistrationType),
    ModelPackageArn: S.optional(S.String),
    ModelPackageDescription: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    InferenceSpecification: S.optional(InferenceSpecification),
    SourceAlgorithmSpecification: S.optional(SourceAlgorithmSpecification),
    ValidationSpecification: S.optional(ModelPackageValidationSpecification),
    ModelPackageStatus: S.optional(ModelPackageStatus),
    ModelPackageStatusDetails: S.optional(ModelPackageStatusDetails),
    CertifyForMarketplace: S.optional(S.Boolean),
    ModelApprovalStatus: S.optional(ModelApprovalStatus),
    CreatedBy: S.optional(UserContext),
    MetadataProperties: S.optional(MetadataProperties),
    ModelMetrics: S.optional(ModelMetrics),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
    ApprovalDescription: S.optional(S.String),
    Domain: S.optional(S.String),
    Task: S.optional(S.String),
    SamplePayloadUrl: S.optional(S.String),
    CustomerMetadataProperties: S.optional(CustomerMetadataMap),
    DriftCheckBaselines: S.optional(DriftCheckBaselines),
    AdditionalInferenceSpecifications: S.optional(
      AdditionalInferenceSpecifications,
    ),
    SkipModelValidation: S.optional(SkipModelValidation),
    SourceUri: S.optional(S.String),
    SecurityConfig: S.optional(ModelPackageSecurityConfig),
    ModelCard: S.optional(ModelPackageModelCard),
    ModelLifeCycle: S.optional(ModelLifeCycle),
  }).pipe(ns),
).annotate({
  identifier: "DescribeModelPackageOutput",
}) as any as S.Schema<DescribeModelPackageOutput>;
export interface DescribeModelPackageGroupInput {
  ModelPackageGroupName?: string;
}
export const DescribeModelPackageGroupInput = S.suspend(() =>
  S.Struct({ ModelPackageGroupName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeModelPackageGroupInput",
}) as any as S.Schema<DescribeModelPackageGroupInput>;
export type ModelPackageGroupStatus =
  | "Pending"
  | "InProgress"
  | "Completed"
  | "Failed"
  | "Deleting"
  | "DeleteFailed"
  | (string & {});
export const ModelPackageGroupStatus = S.String;
export interface DescribeModelPackageGroupOutput {
  ModelPackageGroupName: string;
  ModelPackageGroupArn: string;
  ModelPackageGroupDescription?: string;
  CreationTime: Date;
  CreatedBy: UserContext;
  ModelPackageGroupStatus: ModelPackageGroupStatus;
}
export const DescribeModelPackageGroupOutput = S.suspend(() =>
  S.Struct({
    ModelPackageGroupName: S.optional(S.String),
    ModelPackageGroupArn: S.optional(S.String),
    ModelPackageGroupDescription: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    ModelPackageGroupStatus: S.optional(ModelPackageGroupStatus),
  }).pipe(ns),
).annotate({
  identifier: "DescribeModelPackageGroupOutput",
}) as any as S.Schema<DescribeModelPackageGroupOutput>;
export interface DescribeModelQualityJobDefinitionRequest {
  JobDefinitionName?: string;
}
export const DescribeModelQualityJobDefinitionRequest = S.suspend(() =>
  S.Struct({ JobDefinitionName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeModelQualityJobDefinitionRequest",
}) as any as S.Schema<DescribeModelQualityJobDefinitionRequest>;
export interface DescribeModelQualityJobDefinitionResponse {
  JobDefinitionArn: string;
  JobDefinitionName: string;
  CreationTime: Date;
  ModelQualityBaselineConfig?: ModelQualityBaselineConfig;
  ModelQualityAppSpecification: ModelQualityAppSpecification & {
    ImageUri: ImageUri;
  };
  ModelQualityJobInput: ModelQualityJobInput & {
    GroundTruthS3Input: MonitoringGroundTruthS3Input;
    EndpointInput: EndpointInput & {
      EndpointName: EndpointName;
      LocalPath: ProcessingLocalPath;
    };
    BatchTransformInput: BatchTransformInput & {
      DataCapturedDestinationS3Uri: DestinationS3Uri;
      DatasetFormat: MonitoringDatasetFormat;
      LocalPath: ProcessingLocalPath;
    };
  };
  ModelQualityJobOutputConfig: MonitoringOutputConfig & {
    MonitoringOutputs: (MonitoringOutput & {
      S3Output: MonitoringS3Output & {
        S3Uri: MonitoringS3Uri;
        LocalPath: ProcessingLocalPath;
      };
    })[];
  };
  JobResources: MonitoringResources & {
    ClusterConfig: MonitoringClusterConfig & {
      InstanceCount: ProcessingInstanceCount;
      InstanceType: ProcessingInstanceType;
      VolumeSizeInGB: ProcessingVolumeSizeInGB;
    };
  };
  NetworkConfig?: MonitoringNetworkConfig & {
    VpcConfig: VpcConfig & {
      SecurityGroupIds: VpcSecurityGroupIds;
      Subnets: Subnets;
    };
  };
  RoleArn: string;
  StoppingCondition?: MonitoringStoppingCondition & {
    MaxRuntimeInSeconds: MonitoringMaxRuntimeInSeconds;
  };
}
export const DescribeModelQualityJobDefinitionResponse = S.suspend(() =>
  S.Struct({
    JobDefinitionArn: S.optional(S.String),
    JobDefinitionName: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ModelQualityBaselineConfig: S.optional(ModelQualityBaselineConfig),
    ModelQualityAppSpecification: S.optional(ModelQualityAppSpecification),
    ModelQualityJobInput: S.optional(ModelQualityJobInput),
    ModelQualityJobOutputConfig: S.optional(MonitoringOutputConfig),
    JobResources: S.optional(MonitoringResources),
    NetworkConfig: S.optional(MonitoringNetworkConfig),
    RoleArn: S.optional(S.String),
    StoppingCondition: S.optional(MonitoringStoppingCondition),
  }).pipe(ns),
).annotate({
  identifier: "DescribeModelQualityJobDefinitionResponse",
}) as any as S.Schema<DescribeModelQualityJobDefinitionResponse>;
export interface DescribeMonitoringScheduleRequest {
  MonitoringScheduleName?: string;
}
export const DescribeMonitoringScheduleRequest = S.suspend(() =>
  S.Struct({ MonitoringScheduleName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeMonitoringScheduleRequest",
}) as any as S.Schema<DescribeMonitoringScheduleRequest>;
export type ScheduleStatus =
  | "Pending"
  | "Failed"
  | "Scheduled"
  | "Stopped"
  | (string & {});
export const ScheduleStatus = S.String;
export type ExecutionStatus =
  | "Pending"
  | "Completed"
  | "CompletedWithViolations"
  | "InProgress"
  | "Failed"
  | "Stopping"
  | "Stopped"
  | (string & {});
export const ExecutionStatus = S.String;
export interface MonitoringExecutionSummary {
  MonitoringScheduleName?: string;
  ScheduledTime?: Date;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  MonitoringExecutionStatus?: ExecutionStatus;
  ProcessingJobArn?: string;
  EndpointName?: string;
  FailureReason?: string;
  MonitoringJobDefinitionName?: string;
  MonitoringType?: MonitoringType;
}
export const MonitoringExecutionSummary = S.suspend(() =>
  S.Struct({
    MonitoringScheduleName: S.optional(S.String),
    ScheduledTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    MonitoringExecutionStatus: S.optional(ExecutionStatus),
    ProcessingJobArn: S.optional(S.String),
    EndpointName: S.optional(S.String),
    FailureReason: S.optional(S.String),
    MonitoringJobDefinitionName: S.optional(S.String),
    MonitoringType: S.optional(MonitoringType),
  }),
).annotate({
  identifier: "MonitoringExecutionSummary",
}) as any as S.Schema<MonitoringExecutionSummary>;
export interface DescribeMonitoringScheduleResponse {
  MonitoringScheduleArn: string;
  MonitoringScheduleName: string;
  MonitoringScheduleStatus: ScheduleStatus;
  MonitoringType?: MonitoringType;
  FailureReason?: string;
  CreationTime: Date;
  LastModifiedTime: Date;
  MonitoringScheduleConfig: MonitoringScheduleConfig & {
    ScheduleConfig: ScheduleConfig & { ScheduleExpression: ScheduleExpression };
    MonitoringJobDefinition: MonitoringJobDefinition & {
      MonitoringInputs: (MonitoringInput & {
        EndpointInput: EndpointInput & {
          EndpointName: EndpointName;
          LocalPath: ProcessingLocalPath;
        };
        BatchTransformInput: BatchTransformInput & {
          DataCapturedDestinationS3Uri: DestinationS3Uri;
          DatasetFormat: MonitoringDatasetFormat;
          LocalPath: ProcessingLocalPath;
        };
      })[];
      MonitoringOutputConfig: MonitoringOutputConfig & {
        MonitoringOutputs: (MonitoringOutput & {
          S3Output: MonitoringS3Output & {
            S3Uri: MonitoringS3Uri;
            LocalPath: ProcessingLocalPath;
          };
        })[];
      };
      MonitoringResources: MonitoringResources & {
        ClusterConfig: MonitoringClusterConfig & {
          InstanceCount: ProcessingInstanceCount;
          InstanceType: ProcessingInstanceType;
          VolumeSizeInGB: ProcessingVolumeSizeInGB;
        };
      };
      MonitoringAppSpecification: MonitoringAppSpecification & {
        ImageUri: ImageUri;
      };
      RoleArn: RoleArn;
      StoppingCondition: MonitoringStoppingCondition & {
        MaxRuntimeInSeconds: MonitoringMaxRuntimeInSeconds;
      };
      NetworkConfig: NetworkConfig & {
        VpcConfig: VpcConfig & {
          SecurityGroupIds: VpcSecurityGroupIds;
          Subnets: Subnets;
        };
      };
    };
  };
  EndpointName?: string;
  LastMonitoringExecutionSummary?: MonitoringExecutionSummary & {
    MonitoringScheduleName: MonitoringScheduleName;
    ScheduledTime: Date;
    CreationTime: Date;
    LastModifiedTime: Date;
    MonitoringExecutionStatus: ExecutionStatus;
  };
}
export const DescribeMonitoringScheduleResponse = S.suspend(() =>
  S.Struct({
    MonitoringScheduleArn: S.optional(S.String),
    MonitoringScheduleName: S.optional(S.String),
    MonitoringScheduleStatus: S.optional(ScheduleStatus),
    MonitoringType: S.optional(MonitoringType),
    FailureReason: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    MonitoringScheduleConfig: S.optional(MonitoringScheduleConfig),
    EndpointName: S.optional(S.String),
    LastMonitoringExecutionSummary: S.optional(MonitoringExecutionSummary),
  }).pipe(ns),
).annotate({
  identifier: "DescribeMonitoringScheduleResponse",
}) as any as S.Schema<DescribeMonitoringScheduleResponse>;
export interface DescribeNotebookInstanceInput {
  NotebookInstanceName?: string;
}
export const DescribeNotebookInstanceInput = S.suspend(() =>
  S.Struct({ NotebookInstanceName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeNotebookInstanceInput",
}) as any as S.Schema<DescribeNotebookInstanceInput>;
export type NotebookInstanceStatus =
  | "Pending"
  | "InService"
  | "Stopping"
  | "Stopped"
  | "Failed"
  | "Deleting"
  | "Updating"
  | (string & {});
export const NotebookInstanceStatus = S.String;
export interface DescribeNotebookInstanceOutput {
  NotebookInstanceArn?: string;
  NotebookInstanceName?: string;
  NotebookInstanceStatus?: NotebookInstanceStatus;
  FailureReason?: string;
  Url?: string;
  InstanceType?: InstanceType;
  IpAddressType?: IPAddressType;
  SubnetId?: string;
  SecurityGroups?: string[];
  RoleArn?: string;
  KmsKeyId?: string;
  NetworkInterfaceId?: string;
  LastModifiedTime?: Date;
  CreationTime?: Date;
  NotebookInstanceLifecycleConfigName?: string;
  DirectInternetAccess?: DirectInternetAccess;
  VolumeSizeInGB?: number;
  AcceleratorTypes?: NotebookInstanceAcceleratorType[];
  DefaultCodeRepository?: string;
  AdditionalCodeRepositories?: string[];
  RootAccess?: RootAccess;
  PlatformIdentifier?: string;
  InstanceMetadataServiceConfiguration?: InstanceMetadataServiceConfiguration & {
    MinimumInstanceMetadataServiceVersion: MinimumInstanceMetadataServiceVersion;
  };
}
export const DescribeNotebookInstanceOutput = S.suspend(() =>
  S.Struct({
    NotebookInstanceArn: S.optional(S.String),
    NotebookInstanceName: S.optional(S.String),
    NotebookInstanceStatus: S.optional(NotebookInstanceStatus),
    FailureReason: S.optional(S.String),
    Url: S.optional(S.String),
    InstanceType: S.optional(InstanceType),
    IpAddressType: S.optional(IPAddressType),
    SubnetId: S.optional(S.String),
    SecurityGroups: S.optional(SecurityGroupIds),
    RoleArn: S.optional(S.String),
    KmsKeyId: S.optional(S.String),
    NetworkInterfaceId: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    NotebookInstanceLifecycleConfigName: S.optional(S.String),
    DirectInternetAccess: S.optional(DirectInternetAccess),
    VolumeSizeInGB: S.optional(S.Number),
    AcceleratorTypes: S.optional(NotebookInstanceAcceleratorTypes),
    DefaultCodeRepository: S.optional(S.String),
    AdditionalCodeRepositories: S.optional(AdditionalCodeRepositoryNamesOrUrls),
    RootAccess: S.optional(RootAccess),
    PlatformIdentifier: S.optional(S.String),
    InstanceMetadataServiceConfiguration: S.optional(
      InstanceMetadataServiceConfiguration,
    ),
  }).pipe(ns),
).annotate({
  identifier: "DescribeNotebookInstanceOutput",
}) as any as S.Schema<DescribeNotebookInstanceOutput>;
export interface DescribeNotebookInstanceLifecycleConfigInput {
  NotebookInstanceLifecycleConfigName?: string;
}
export const DescribeNotebookInstanceLifecycleConfigInput = S.suspend(() =>
  S.Struct({ NotebookInstanceLifecycleConfigName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeNotebookInstanceLifecycleConfigInput",
}) as any as S.Schema<DescribeNotebookInstanceLifecycleConfigInput>;
export interface DescribeNotebookInstanceLifecycleConfigOutput {
  NotebookInstanceLifecycleConfigArn?: string;
  NotebookInstanceLifecycleConfigName?: string;
  OnCreate?: NotebookInstanceLifecycleHook[];
  OnStart?: NotebookInstanceLifecycleHook[];
  LastModifiedTime?: Date;
  CreationTime?: Date;
}
export const DescribeNotebookInstanceLifecycleConfigOutput = S.suspend(() =>
  S.Struct({
    NotebookInstanceLifecycleConfigArn: S.optional(S.String),
    NotebookInstanceLifecycleConfigName: S.optional(S.String),
    OnCreate: S.optional(NotebookInstanceLifecycleConfigList),
    OnStart: S.optional(NotebookInstanceLifecycleConfigList),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }).pipe(ns),
).annotate({
  identifier: "DescribeNotebookInstanceLifecycleConfigOutput",
}) as any as S.Schema<DescribeNotebookInstanceLifecycleConfigOutput>;
export interface DescribeOptimizationJobRequest {
  OptimizationJobName?: string;
}
export const DescribeOptimizationJobRequest = S.suspend(() =>
  S.Struct({ OptimizationJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeOptimizationJobRequest",
}) as any as S.Schema<DescribeOptimizationJobRequest>;
export type OptimizationJobStatus =
  | "INPROGRESS"
  | "COMPLETED"
  | "FAILED"
  | "STARTING"
  | "STOPPING"
  | "STOPPED"
  | (string & {});
export const OptimizationJobStatus = S.String;
export interface OptimizationOutput {
  RecommendedInferenceImage?: string;
}
export const OptimizationOutput = S.suspend(() =>
  S.Struct({ RecommendedInferenceImage: S.optional(S.String) }),
).annotate({
  identifier: "OptimizationOutput",
}) as any as S.Schema<OptimizationOutput>;
export interface DescribeOptimizationJobResponse {
  OptimizationJobArn: string;
  OptimizationJobStatus: OptimizationJobStatus;
  OptimizationStartTime?: Date;
  OptimizationEndTime?: Date;
  CreationTime: Date;
  LastModifiedTime: Date;
  FailureReason?: string;
  OptimizationJobName: string;
  ModelSource: OptimizationJobModelSource & {
    S3: OptimizationJobModelSourceS3 & {
      ModelAccessConfig: OptimizationModelAccessConfig & {
        AcceptEula: OptimizationModelAcceptEula;
      };
    };
  };
  OptimizationEnvironment?: { [key: string]: string | undefined };
  DeploymentInstanceType: OptimizationJobDeploymentInstanceType;
  MaxInstanceCount?: number;
  OptimizationConfigs: OptimizationConfig[];
  OutputConfig: OptimizationJobOutputConfig & { S3OutputLocation: S3Uri };
  OptimizationOutput?: OptimizationOutput;
  RoleArn: string;
  StoppingCondition: StoppingCondition;
  VpcConfig?: OptimizationVpcConfig & {
    SecurityGroupIds: OptimizationVpcSecurityGroupIds;
    Subnets: OptimizationVpcSubnets;
  };
}
export const DescribeOptimizationJobResponse = S.suspend(() =>
  S.Struct({
    OptimizationJobArn: S.optional(S.String),
    OptimizationJobStatus: S.optional(OptimizationJobStatus),
    OptimizationStartTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    OptimizationEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    FailureReason: S.optional(S.String),
    OptimizationJobName: S.optional(S.String),
    ModelSource: S.optional(OptimizationJobModelSource),
    OptimizationEnvironment: S.optional(OptimizationJobEnvironmentVariables),
    DeploymentInstanceType: S.optional(OptimizationJobDeploymentInstanceType),
    MaxInstanceCount: S.optional(S.Number),
    OptimizationConfigs: S.optional(OptimizationConfigs),
    OutputConfig: S.optional(OptimizationJobOutputConfig),
    OptimizationOutput: S.optional(OptimizationOutput),
    RoleArn: S.optional(S.String),
    StoppingCondition: S.optional(StoppingCondition),
    VpcConfig: S.optional(OptimizationVpcConfig),
  }).pipe(ns),
).annotate({
  identifier: "DescribeOptimizationJobResponse",
}) as any as S.Schema<DescribeOptimizationJobResponse>;
export interface DescribePartnerAppRequest {
  Arn?: string;
  IncludeAvailableUpgrade?: boolean;
}
export const DescribePartnerAppRequest = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    IncludeAvailableUpgrade: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribePartnerAppRequest",
}) as any as S.Schema<DescribePartnerAppRequest>;
export type PartnerAppStatus =
  | "Creating"
  | "Updating"
  | "Deleting"
  | "Available"
  | "Failed"
  | "UpdateFailed"
  | "Deleted"
  | (string & {});
export const PartnerAppStatus = S.String;
export interface ErrorInfo {
  Code?: string;
  Reason?: string;
}
export const ErrorInfo = S.suspend(() =>
  S.Struct({ Code: S.optional(S.String), Reason: S.optional(S.String) }),
).annotate({ identifier: "ErrorInfo" }) as any as S.Schema<ErrorInfo>;
export type ReleaseNotesList = string[];
export const ReleaseNotesList = S.Array(S.String);
export interface AvailableUpgrade {
  Version?: string;
  ReleaseNotes?: string[];
}
export const AvailableUpgrade = S.suspend(() =>
  S.Struct({
    Version: S.optional(S.String),
    ReleaseNotes: S.optional(ReleaseNotesList),
  }),
).annotate({
  identifier: "AvailableUpgrade",
}) as any as S.Schema<AvailableUpgrade>;
export interface DescribePartnerAppResponse {
  Arn?: string;
  Name?: string;
  Type?: PartnerAppType;
  Status?: PartnerAppStatus;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  ExecutionRoleArn?: string;
  KmsKeyId?: string;
  BaseUrl?: string;
  MaintenanceConfig?: PartnerAppMaintenanceConfig;
  Tier?: string;
  Version?: string;
  ApplicationConfig?: PartnerAppConfig;
  AuthType?: PartnerAppAuthType;
  EnableIamSessionBasedIdentity?: boolean;
  Error?: ErrorInfo;
  EnableAutoMinorVersionUpgrade?: boolean;
  CurrentVersionEolDate?: Date;
  AvailableUpgrade?: AvailableUpgrade;
}
export const DescribePartnerAppResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    Type: S.optional(PartnerAppType),
    Status: S.optional(PartnerAppStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ExecutionRoleArn: S.optional(S.String),
    KmsKeyId: S.optional(S.String),
    BaseUrl: S.optional(S.String),
    MaintenanceConfig: S.optional(PartnerAppMaintenanceConfig),
    Tier: S.optional(S.String),
    Version: S.optional(S.String),
    ApplicationConfig: S.optional(PartnerAppConfig),
    AuthType: S.optional(PartnerAppAuthType),
    EnableIamSessionBasedIdentity: S.optional(S.Boolean),
    Error: S.optional(ErrorInfo),
    EnableAutoMinorVersionUpgrade: S.optional(S.Boolean),
    CurrentVersionEolDate: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    AvailableUpgrade: S.optional(AvailableUpgrade),
  }).pipe(ns),
).annotate({
  identifier: "DescribePartnerAppResponse",
}) as any as S.Schema<DescribePartnerAppResponse>;
export interface DescribePipelineRequest {
  PipelineName?: string;
  PipelineVersionId?: number;
}
export const DescribePipelineRequest = S.suspend(() =>
  S.Struct({
    PipelineName: S.optional(S.String),
    PipelineVersionId: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribePipelineRequest",
}) as any as S.Schema<DescribePipelineRequest>;
export type PipelineStatus = "Active" | "Deleting" | (string & {});
export const PipelineStatus = S.String;
export interface DescribePipelineResponse {
  PipelineArn?: string;
  PipelineName?: string;
  PipelineDisplayName?: string;
  PipelineDefinition?: string;
  PipelineDescription?: string;
  RoleArn?: string;
  PipelineStatus?: PipelineStatus;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  LastRunTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedBy?: UserContext;
  ParallelismConfiguration?: ParallelismConfiguration & {
    MaxParallelExecutionSteps: MaxParallelExecutionSteps;
  };
  PipelineVersionDisplayName?: string;
  PipelineVersionDescription?: string;
}
export const DescribePipelineResponse = S.suspend(() =>
  S.Struct({
    PipelineArn: S.optional(S.String),
    PipelineName: S.optional(S.String),
    PipelineDisplayName: S.optional(S.String),
    PipelineDefinition: S.optional(S.String),
    PipelineDescription: S.optional(S.String),
    RoleArn: S.optional(S.String),
    PipelineStatus: S.optional(PipelineStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastRunTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedBy: S.optional(UserContext),
    ParallelismConfiguration: S.optional(ParallelismConfiguration),
    PipelineVersionDisplayName: S.optional(S.String),
    PipelineVersionDescription: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "DescribePipelineResponse",
}) as any as S.Schema<DescribePipelineResponse>;
export interface DescribePipelineDefinitionForExecutionRequest {
  PipelineExecutionArn?: string;
}
export const DescribePipelineDefinitionForExecutionRequest = S.suspend(() =>
  S.Struct({ PipelineExecutionArn: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribePipelineDefinitionForExecutionRequest",
}) as any as S.Schema<DescribePipelineDefinitionForExecutionRequest>;
export interface DescribePipelineDefinitionForExecutionResponse {
  PipelineDefinition?: string;
  CreationTime?: Date;
}
export const DescribePipelineDefinitionForExecutionResponse = S.suspend(() =>
  S.Struct({
    PipelineDefinition: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }).pipe(ns),
).annotate({
  identifier: "DescribePipelineDefinitionForExecutionResponse",
}) as any as S.Schema<DescribePipelineDefinitionForExecutionResponse>;
export interface DescribePipelineExecutionRequest {
  PipelineExecutionArn?: string;
}
export const DescribePipelineExecutionRequest = S.suspend(() =>
  S.Struct({ PipelineExecutionArn: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribePipelineExecutionRequest",
}) as any as S.Schema<DescribePipelineExecutionRequest>;
export type PipelineExecutionStatus =
  | "Executing"
  | "Stopping"
  | "Stopped"
  | "Failed"
  | "Succeeded"
  | (string & {});
export const PipelineExecutionStatus = S.String;
export interface PipelineExperimentConfig {
  ExperimentName?: string;
  TrialName?: string;
}
export const PipelineExperimentConfig = S.suspend(() =>
  S.Struct({
    ExperimentName: S.optional(S.String),
    TrialName: S.optional(S.String),
  }),
).annotate({
  identifier: "PipelineExperimentConfig",
}) as any as S.Schema<PipelineExperimentConfig>;
export interface SelectedStep {
  StepName?: string;
}
export const SelectedStep = S.suspend(() =>
  S.Struct({ StepName: S.optional(S.String) }),
).annotate({ identifier: "SelectedStep" }) as any as S.Schema<SelectedStep>;
export type SelectedStepList = SelectedStep[];
export const SelectedStepList = S.Array(SelectedStep);
export interface SelectiveExecutionConfig {
  SourcePipelineExecutionArn?: string;
  SelectedSteps?: SelectedStep[];
}
export const SelectiveExecutionConfig = S.suspend(() =>
  S.Struct({
    SourcePipelineExecutionArn: S.optional(S.String),
    SelectedSteps: S.optional(SelectedStepList),
  }),
).annotate({
  identifier: "SelectiveExecutionConfig",
}) as any as S.Schema<SelectiveExecutionConfig>;
export interface MLflowConfiguration {
  MlflowResourceArn?: string;
  MlflowExperimentName?: string;
}
export const MLflowConfiguration = S.suspend(() =>
  S.Struct({
    MlflowResourceArn: S.optional(S.String),
    MlflowExperimentName: S.optional(S.String),
  }),
).annotate({
  identifier: "MLflowConfiguration",
}) as any as S.Schema<MLflowConfiguration>;
export interface DescribePipelineExecutionResponse {
  PipelineArn?: string;
  PipelineExecutionArn?: string;
  PipelineExecutionDisplayName?: string;
  PipelineExecutionStatus?: PipelineExecutionStatus;
  PipelineExecutionDescription?: string;
  PipelineExperimentConfig?: PipelineExperimentConfig;
  FailureReason?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedBy?: UserContext;
  ParallelismConfiguration?: ParallelismConfiguration & {
    MaxParallelExecutionSteps: MaxParallelExecutionSteps;
  };
  SelectiveExecutionConfig?: SelectiveExecutionConfig & {
    SelectedSteps: (SelectedStep & { StepName: String256 })[];
  };
  PipelineVersionId?: number;
  MLflowConfig?: MLflowConfiguration;
}
export const DescribePipelineExecutionResponse = S.suspend(() =>
  S.Struct({
    PipelineArn: S.optional(S.String),
    PipelineExecutionArn: S.optional(S.String),
    PipelineExecutionDisplayName: S.optional(S.String),
    PipelineExecutionStatus: S.optional(PipelineExecutionStatus),
    PipelineExecutionDescription: S.optional(S.String),
    PipelineExperimentConfig: S.optional(PipelineExperimentConfig),
    FailureReason: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreatedBy: S.optional(UserContext),
    LastModifiedBy: S.optional(UserContext),
    ParallelismConfiguration: S.optional(ParallelismConfiguration),
    SelectiveExecutionConfig: S.optional(SelectiveExecutionConfig),
    PipelineVersionId: S.optional(S.Number),
    MLflowConfig: S.optional(MLflowConfiguration),
  }).pipe(ns),
).annotate({
  identifier: "DescribePipelineExecutionResponse",
}) as any as S.Schema<DescribePipelineExecutionResponse>;
export interface DescribeProcessingJobRequest {
  ProcessingJobName?: string;
}
export const DescribeProcessingJobRequest = S.suspend(() =>
  S.Struct({ ProcessingJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeProcessingJobRequest",
}) as any as S.Schema<DescribeProcessingJobRequest>;
export type ProcessingJobStatus =
  | "InProgress"
  | "Completed"
  | "Failed"
  | "Stopping"
  | "Stopped"
  | (string & {});
export const ProcessingJobStatus = S.String;
export interface DescribeProcessingJobResponse {
  ProcessingInputs?: (ProcessingInput & {
    InputName: string;
    S3Input: ProcessingS3Input & {
      S3Uri: S3Uri;
      S3DataType: ProcessingS3DataType;
    };
    DatasetDefinition: DatasetDefinition & {
      AthenaDatasetDefinition: AthenaDatasetDefinition & {
        Catalog: AthenaCatalog;
        Database: AthenaDatabase;
        QueryString: AthenaQueryString;
        OutputS3Uri: S3Uri;
        OutputFormat: AthenaResultFormat;
      };
      RedshiftDatasetDefinition: RedshiftDatasetDefinition & {
        ClusterId: RedshiftClusterId;
        Database: RedshiftDatabase;
        DbUser: RedshiftUserName;
        QueryString: RedshiftQueryString;
        ClusterRoleArn: RoleArn;
        OutputS3Uri: S3Uri;
        OutputFormat: RedshiftResultFormat;
      };
    };
  })[];
  ProcessingOutputConfig?: ProcessingOutputConfig & {
    Outputs: (ProcessingOutput & {
      OutputName: string;
      S3Output: ProcessingS3Output & {
        S3Uri: S3Uri;
        S3UploadMode: ProcessingS3UploadMode;
      };
      FeatureStoreOutput: ProcessingFeatureStoreOutput & {
        FeatureGroupName: FeatureGroupName;
      };
    })[];
  };
  ProcessingJobName: string;
  ProcessingResources: ProcessingResources & {
    ClusterConfig: ProcessingClusterConfig & {
      InstanceCount: ProcessingInstanceCount;
      InstanceType: ProcessingInstanceType;
      VolumeSizeInGB: ProcessingVolumeSizeInGB;
    };
  };
  StoppingCondition?: ProcessingStoppingCondition & {
    MaxRuntimeInSeconds: ProcessingMaxRuntimeInSeconds;
  };
  AppSpecification: AppSpecification & { ImageUri: ImageUri };
  Environment?: { [key: string]: string | undefined };
  NetworkConfig?: NetworkConfig & {
    VpcConfig: VpcConfig & {
      SecurityGroupIds: VpcSecurityGroupIds;
      Subnets: Subnets;
    };
  };
  RoleArn?: string;
  ExperimentConfig?: ExperimentConfig;
  ProcessingJobArn: string;
  ProcessingJobStatus: ProcessingJobStatus;
  ExitMessage?: string;
  FailureReason?: string;
  ProcessingEndTime?: Date;
  ProcessingStartTime?: Date;
  LastModifiedTime?: Date;
  CreationTime: Date;
  MonitoringScheduleArn?: string;
  AutoMLJobArn?: string;
  TrainingJobArn?: string;
}
export const DescribeProcessingJobResponse = S.suspend(() =>
  S.Struct({
    ProcessingInputs: S.optional(ProcessingInputs),
    ProcessingOutputConfig: S.optional(ProcessingOutputConfig),
    ProcessingJobName: S.optional(S.String),
    ProcessingResources: S.optional(ProcessingResources),
    StoppingCondition: S.optional(ProcessingStoppingCondition),
    AppSpecification: S.optional(AppSpecification),
    Environment: S.optional(ProcessingEnvironmentMap),
    NetworkConfig: S.optional(NetworkConfig),
    RoleArn: S.optional(S.String),
    ExperimentConfig: S.optional(ExperimentConfig),
    ProcessingJobArn: S.optional(S.String),
    ProcessingJobStatus: S.optional(ProcessingJobStatus),
    ExitMessage: S.optional(S.String),
    FailureReason: S.optional(S.String),
    ProcessingEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ProcessingStartTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    MonitoringScheduleArn: S.optional(S.String),
    AutoMLJobArn: S.optional(S.String),
    TrainingJobArn: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "DescribeProcessingJobResponse",
}) as any as S.Schema<DescribeProcessingJobResponse>;
export interface DescribeProjectInput {
  ProjectName?: string;
}
export const DescribeProjectInput = S.suspend(() =>
  S.Struct({ ProjectName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeProjectInput",
}) as any as S.Schema<DescribeProjectInput>;
export interface ServiceCatalogProvisionedProductDetails {
  ProvisionedProductId?: string;
  ProvisionedProductStatusMessage?: string;
}
export const ServiceCatalogProvisionedProductDetails = S.suspend(() =>
  S.Struct({
    ProvisionedProductId: S.optional(S.String),
    ProvisionedProductStatusMessage: S.optional(S.String),
  }),
).annotate({
  identifier: "ServiceCatalogProvisionedProductDetails",
}) as any as S.Schema<ServiceCatalogProvisionedProductDetails>;
export type ProjectStatus =
  | "Pending"
  | "CreateInProgress"
  | "CreateCompleted"
  | "CreateFailed"
  | "DeleteInProgress"
  | "DeleteFailed"
  | "DeleteCompleted"
  | "UpdateInProgress"
  | "UpdateCompleted"
  | "UpdateFailed"
  | (string & {});
export const ProjectStatus = S.String;
export interface CfnStackParameter {
  Key?: string;
  Value?: string;
}
export const CfnStackParameter = S.suspend(() =>
  S.Struct({ Key: S.optional(S.String), Value: S.optional(S.String) }),
).annotate({
  identifier: "CfnStackParameter",
}) as any as S.Schema<CfnStackParameter>;
export type CfnStackParameters = CfnStackParameter[];
export const CfnStackParameters = S.Array(CfnStackParameter);
export interface CfnStackDetail {
  Name?: string;
  Id?: string;
  StatusMessage?: string;
}
export const CfnStackDetail = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Id: S.optional(S.String),
    StatusMessage: S.optional(S.String),
  }),
).annotate({ identifier: "CfnStackDetail" }) as any as S.Schema<CfnStackDetail>;
export interface CfnTemplateProviderDetail {
  TemplateName?: string;
  TemplateURL?: string;
  RoleARN?: string;
  Parameters?: CfnStackParameter[];
  StackDetail?: CfnStackDetail;
}
export const CfnTemplateProviderDetail = S.suspend(() =>
  S.Struct({
    TemplateName: S.optional(S.String),
    TemplateURL: S.optional(S.String),
    RoleARN: S.optional(S.String),
    Parameters: S.optional(CfnStackParameters),
    StackDetail: S.optional(CfnStackDetail),
  }),
).annotate({
  identifier: "CfnTemplateProviderDetail",
}) as any as S.Schema<CfnTemplateProviderDetail>;
export interface TemplateProviderDetail {
  CfnTemplateProviderDetail?: CfnTemplateProviderDetail;
}
export const TemplateProviderDetail = S.suspend(() =>
  S.Struct({
    CfnTemplateProviderDetail: S.optional(CfnTemplateProviderDetail),
  }),
).annotate({
  identifier: "TemplateProviderDetail",
}) as any as S.Schema<TemplateProviderDetail>;
export type TemplateProviderDetailList = TemplateProviderDetail[];
export const TemplateProviderDetailList = S.Array(TemplateProviderDetail);
export interface DescribeProjectOutput {
  ProjectArn: string;
  ProjectName: string;
  ProjectId: string;
  ProjectDescription?: string;
  ServiceCatalogProvisioningDetails?: ServiceCatalogProvisioningDetails & {
    ProductId: ServiceCatalogEntityId;
  };
  ServiceCatalogProvisionedProductDetails?: ServiceCatalogProvisionedProductDetails;
  ProjectStatus: ProjectStatus;
  TemplateProviderDetails?: (TemplateProviderDetail & {
    CfnTemplateProviderDetail: CfnTemplateProviderDetail & {
      TemplateName: CfnTemplateName;
      TemplateURL: CfnTemplateURL;
      Parameters: (CfnStackParameter & { Key: CfnStackParameterKey })[];
      StackDetail: CfnStackDetail & { StatusMessage: CfnStackStatusMessage };
    };
  })[];
  CreatedBy?: UserContext;
  CreationTime: Date;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
}
export const DescribeProjectOutput = S.suspend(() =>
  S.Struct({
    ProjectArn: S.optional(S.String),
    ProjectName: S.optional(S.String),
    ProjectId: S.optional(S.String),
    ProjectDescription: S.optional(S.String),
    ServiceCatalogProvisioningDetails: S.optional(
      ServiceCatalogProvisioningDetails,
    ),
    ServiceCatalogProvisionedProductDetails: S.optional(
      ServiceCatalogProvisionedProductDetails,
    ),
    ProjectStatus: S.optional(ProjectStatus),
    TemplateProviderDetails: S.optional(TemplateProviderDetailList),
    CreatedBy: S.optional(UserContext),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
  }).pipe(ns),
).annotate({
  identifier: "DescribeProjectOutput",
}) as any as S.Schema<DescribeProjectOutput>;
export interface DescribeReservedCapacityRequest {
  ReservedCapacityArn?: string;
}
export const DescribeReservedCapacityRequest = S.suspend(() =>
  S.Struct({ ReservedCapacityArn: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeReservedCapacityRequest",
}) as any as S.Schema<DescribeReservedCapacityRequest>;
export type ReservedCapacityType = "UltraServer" | "Instance" | (string & {});
export const ReservedCapacityType = S.String;
export type ReservedCapacityStatus =
  | "Pending"
  | "Active"
  | "Scheduled"
  | "Expired"
  | "Failed"
  | (string & {});
export const ReservedCapacityStatus = S.String;
export type ReservedCapacityInstanceType =
  | "ml.p4d.24xlarge"
  | "ml.p5.48xlarge"
  | "ml.p5e.48xlarge"
  | "ml.p5en.48xlarge"
  | "ml.trn1.32xlarge"
  | "ml.trn2.48xlarge"
  | "ml.p6-b200.48xlarge"
  | "ml.p4de.24xlarge"
  | "ml.p6e-gb200.36xlarge"
  | "ml.p5.4xlarge"
  | "ml.p6-b300.48xlarge"
  | (string & {});
export const ReservedCapacityInstanceType = S.String;
export interface UltraServerSummary {
  UltraServerType?: string;
  InstanceType?: ReservedCapacityInstanceType;
  UltraServerCount?: number;
  AvailableSpareInstanceCount?: number;
  UnhealthyInstanceCount?: number;
}
export const UltraServerSummary = S.suspend(() =>
  S.Struct({
    UltraServerType: S.optional(S.String),
    InstanceType: S.optional(ReservedCapacityInstanceType),
    UltraServerCount: S.optional(S.Number),
    AvailableSpareInstanceCount: S.optional(S.Number),
    UnhealthyInstanceCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "UltraServerSummary",
}) as any as S.Schema<UltraServerSummary>;
export interface DescribeReservedCapacityResponse {
  ReservedCapacityArn: string;
  ReservedCapacityType?: ReservedCapacityType;
  Status?: ReservedCapacityStatus;
  AvailabilityZone?: string;
  DurationHours?: number;
  DurationMinutes?: number;
  StartTime?: Date;
  EndTime?: Date;
  InstanceType: ReservedCapacityInstanceType;
  TotalInstanceCount: number;
  AvailableInstanceCount?: number;
  InUseInstanceCount?: number;
  UltraServerSummary?: UltraServerSummary & {
    UltraServerType: UltraServerType;
    InstanceType: ReservedCapacityInstanceType;
  };
}
export const DescribeReservedCapacityResponse = S.suspend(() =>
  S.Struct({
    ReservedCapacityArn: S.optional(S.String),
    ReservedCapacityType: S.optional(ReservedCapacityType),
    Status: S.optional(ReservedCapacityStatus),
    AvailabilityZone: S.optional(S.String),
    DurationHours: S.optional(S.Number),
    DurationMinutes: S.optional(S.Number),
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    InstanceType: S.optional(ReservedCapacityInstanceType),
    TotalInstanceCount: S.optional(S.Number),
    AvailableInstanceCount: S.optional(S.Number),
    InUseInstanceCount: S.optional(S.Number),
    UltraServerSummary: S.optional(UltraServerSummary),
  }).pipe(ns),
).annotate({
  identifier: "DescribeReservedCapacityResponse",
}) as any as S.Schema<DescribeReservedCapacityResponse>;
export interface DescribeSpaceRequest {
  DomainId?: string;
  SpaceName?: string;
}
export const DescribeSpaceRequest = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    SpaceName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSpaceRequest",
}) as any as S.Schema<DescribeSpaceRequest>;
export type SpaceStatus =
  | "Deleting"
  | "Failed"
  | "InService"
  | "Pending"
  | "Updating"
  | "Update_Failed"
  | "Delete_Failed"
  | (string & {});
export const SpaceStatus = S.String;
export interface DescribeSpaceResponse {
  DomainId?: string;
  SpaceArn?: string;
  SpaceName?: string;
  HomeEfsFileSystemUid?: string;
  Status?: SpaceStatus;
  LastModifiedTime?: Date;
  CreationTime?: Date;
  FailureReason?: string;
  SpaceSettings?: SpaceSettings & {
    JupyterServerAppSettings: JupyterServerAppSettings & {
      CodeRepositories: (CodeRepository & { RepositoryUrl: RepositoryUrl })[];
    };
    KernelGatewayAppSettings: KernelGatewayAppSettings & {
      CustomImages: (CustomImage & {
        ImageName: ImageName;
        AppImageConfigName: AppImageConfigName;
      })[];
    };
    JupyterLabAppSettings: SpaceJupyterLabAppSettings & {
      CodeRepositories: (CodeRepository & { RepositoryUrl: RepositoryUrl })[];
    };
    SpaceStorageSettings: SpaceStorageSettings & {
      EbsStorageSettings: EbsStorageSettings & {
        EbsVolumeSizeInGb: SpaceEbsVolumeSizeInGb;
      };
    };
  };
  OwnershipSettings?: OwnershipSettings & {
    OwnerUserProfileName: UserProfileName;
  };
  SpaceSharingSettings?: SpaceSharingSettings & { SharingType: SharingType };
  SpaceDisplayName?: string;
  Url?: string;
}
export const DescribeSpaceResponse = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    SpaceArn: S.optional(S.String),
    SpaceName: S.optional(S.String),
    HomeEfsFileSystemUid: S.optional(S.String),
    Status: S.optional(SpaceStatus),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    FailureReason: S.optional(S.String),
    SpaceSettings: S.optional(SpaceSettings),
    OwnershipSettings: S.optional(OwnershipSettings),
    SpaceSharingSettings: S.optional(SpaceSharingSettings),
    SpaceDisplayName: S.optional(S.String),
    Url: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "DescribeSpaceResponse",
}) as any as S.Schema<DescribeSpaceResponse>;
export interface DescribeStudioLifecycleConfigRequest {
  StudioLifecycleConfigName?: string;
}
export const DescribeStudioLifecycleConfigRequest = S.suspend(() =>
  S.Struct({ StudioLifecycleConfigName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeStudioLifecycleConfigRequest",
}) as any as S.Schema<DescribeStudioLifecycleConfigRequest>;
export interface DescribeStudioLifecycleConfigResponse {
  StudioLifecycleConfigArn?: string;
  StudioLifecycleConfigName?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  StudioLifecycleConfigContent?: string;
  StudioLifecycleConfigAppType?: StudioLifecycleConfigAppType;
}
export const DescribeStudioLifecycleConfigResponse = S.suspend(() =>
  S.Struct({
    StudioLifecycleConfigArn: S.optional(S.String),
    StudioLifecycleConfigName: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    StudioLifecycleConfigContent: S.optional(S.String),
    StudioLifecycleConfigAppType: S.optional(StudioLifecycleConfigAppType),
  }).pipe(ns),
).annotate({
  identifier: "DescribeStudioLifecycleConfigResponse",
}) as any as S.Schema<DescribeStudioLifecycleConfigResponse>;
export interface DescribeSubscribedWorkteamRequest {
  WorkteamArn?: string;
}
export const DescribeSubscribedWorkteamRequest = S.suspend(() =>
  S.Struct({ WorkteamArn: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSubscribedWorkteamRequest",
}) as any as S.Schema<DescribeSubscribedWorkteamRequest>;
export interface SubscribedWorkteam {
  WorkteamArn?: string;
  MarketplaceTitle?: string;
  SellerName?: string;
  MarketplaceDescription?: string;
  ListingId?: string;
}
export const SubscribedWorkteam = S.suspend(() =>
  S.Struct({
    WorkteamArn: S.optional(S.String),
    MarketplaceTitle: S.optional(S.String),
    SellerName: S.optional(S.String),
    MarketplaceDescription: S.optional(S.String),
    ListingId: S.optional(S.String),
  }),
).annotate({
  identifier: "SubscribedWorkteam",
}) as any as S.Schema<SubscribedWorkteam>;
export interface DescribeSubscribedWorkteamResponse {
  SubscribedWorkteam: SubscribedWorkteam & { WorkteamArn: WorkteamArn };
}
export const DescribeSubscribedWorkteamResponse = S.suspend(() =>
  S.Struct({ SubscribedWorkteam: S.optional(SubscribedWorkteam) }).pipe(ns),
).annotate({
  identifier: "DescribeSubscribedWorkteamResponse",
}) as any as S.Schema<DescribeSubscribedWorkteamResponse>;
export interface DescribeTrainingJobRequest {
  TrainingJobName?: string;
}
export const DescribeTrainingJobRequest = S.suspend(() =>
  S.Struct({ TrainingJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTrainingJobRequest",
}) as any as S.Schema<DescribeTrainingJobRequest>;
export type SecondaryStatus =
  | "Starting"
  | "LaunchingMLInstances"
  | "PreparingTrainingStack"
  | "Downloading"
  | "DownloadingTrainingImage"
  | "Training"
  | "Uploading"
  | "Stopping"
  | "Stopped"
  | "MaxRuntimeExceeded"
  | "Completed"
  | "Failed"
  | "Interrupted"
  | "MaxWaitTimeExceeded"
  | "Updating"
  | "Restarting"
  | "Pending"
  | (string & {});
export const SecondaryStatus = S.String;
export type WarmPoolResourceStatus =
  | "Available"
  | "Terminated"
  | "Reused"
  | "InUse"
  | (string & {});
export const WarmPoolResourceStatus = S.String;
export interface WarmPoolStatus {
  Status?: WarmPoolResourceStatus;
  ResourceRetainedBillableTimeInSeconds?: number;
  ReusedByJob?: string;
}
export const WarmPoolStatus = S.suspend(() =>
  S.Struct({
    Status: S.optional(WarmPoolResourceStatus),
    ResourceRetainedBillableTimeInSeconds: S.optional(S.Number),
    ReusedByJob: S.optional(S.String),
  }),
).annotate({ identifier: "WarmPoolStatus" }) as any as S.Schema<WarmPoolStatus>;
export interface SecondaryStatusTransition {
  Status?: SecondaryStatus;
  StartTime?: Date;
  EndTime?: Date;
  StatusMessage?: string;
}
export const SecondaryStatusTransition = S.suspend(() =>
  S.Struct({
    Status: S.optional(SecondaryStatus),
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    StatusMessage: S.optional(S.String),
  }),
).annotate({
  identifier: "SecondaryStatusTransition",
}) as any as S.Schema<SecondaryStatusTransition>;
export type SecondaryStatusTransitions = SecondaryStatusTransition[];
export const SecondaryStatusTransitions = S.Array(SecondaryStatusTransition);
export interface MetricData {
  MetricName?: string;
  Value?: number;
  Timestamp?: Date;
}
export const MetricData = S.suspend(() =>
  S.Struct({
    MetricName: S.optional(S.String),
    Value: S.optional(S.Number),
    Timestamp: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotate({ identifier: "MetricData" }) as any as S.Schema<MetricData>;
export type FinalMetricDataList = MetricData[];
export const FinalMetricDataList = S.Array(MetricData);
export type RuleEvaluationStatus =
  | "InProgress"
  | "NoIssuesFound"
  | "IssuesFound"
  | "Error"
  | "Stopping"
  | "Stopped"
  | (string & {});
export const RuleEvaluationStatus = S.String;
export interface DebugRuleEvaluationStatus {
  RuleConfigurationName?: string;
  RuleEvaluationJobArn?: string;
  RuleEvaluationStatus?: RuleEvaluationStatus;
  StatusDetails?: string;
  LastModifiedTime?: Date;
}
export const DebugRuleEvaluationStatus = S.suspend(() =>
  S.Struct({
    RuleConfigurationName: S.optional(S.String),
    RuleEvaluationJobArn: S.optional(S.String),
    RuleEvaluationStatus: S.optional(RuleEvaluationStatus),
    StatusDetails: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "DebugRuleEvaluationStatus",
}) as any as S.Schema<DebugRuleEvaluationStatus>;
export type DebugRuleEvaluationStatuses = DebugRuleEvaluationStatus[];
export const DebugRuleEvaluationStatuses = S.Array(DebugRuleEvaluationStatus);
export interface ProfilerRuleEvaluationStatus {
  RuleConfigurationName?: string;
  RuleEvaluationJobArn?: string;
  RuleEvaluationStatus?: RuleEvaluationStatus;
  StatusDetails?: string;
  LastModifiedTime?: Date;
}
export const ProfilerRuleEvaluationStatus = S.suspend(() =>
  S.Struct({
    RuleConfigurationName: S.optional(S.String),
    RuleEvaluationJobArn: S.optional(S.String),
    RuleEvaluationStatus: S.optional(RuleEvaluationStatus),
    StatusDetails: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "ProfilerRuleEvaluationStatus",
}) as any as S.Schema<ProfilerRuleEvaluationStatus>;
export type ProfilerRuleEvaluationStatuses = ProfilerRuleEvaluationStatus[];
export const ProfilerRuleEvaluationStatuses = S.Array(
  ProfilerRuleEvaluationStatus,
);
export type ProfilingStatus = "Enabled" | "Disabled" | (string & {});
export const ProfilingStatus = S.String;
export interface MlflowDetails {
  MlflowExperimentId?: string;
  MlflowRunId?: string;
}
export const MlflowDetails = S.suspend(() =>
  S.Struct({
    MlflowExperimentId: S.optional(S.String),
    MlflowRunId: S.optional(S.String),
  }),
).annotate({ identifier: "MlflowDetails" }) as any as S.Schema<MlflowDetails>;
export interface TrainingProgressInfo {
  TotalStepCountPerEpoch?: number;
  CurrentStep?: number;
  CurrentEpoch?: number;
  MaxEpoch?: number;
}
export const TrainingProgressInfo = S.suspend(() =>
  S.Struct({
    TotalStepCountPerEpoch: S.optional(S.Number),
    CurrentStep: S.optional(S.Number),
    CurrentEpoch: S.optional(S.Number),
    MaxEpoch: S.optional(S.Number),
  }),
).annotate({
  identifier: "TrainingProgressInfo",
}) as any as S.Schema<TrainingProgressInfo>;
export interface DescribeTrainingJobResponse {
  TrainingJobName: string;
  TrainingJobArn: string;
  TuningJobArn?: string;
  LabelingJobArn?: string;
  AutoMLJobArn?: string;
  ModelArtifacts: ModelArtifacts & { S3ModelArtifacts: S3Uri };
  TrainingJobStatus: TrainingJobStatus;
  SecondaryStatus: SecondaryStatus;
  FailureReason?: string;
  HyperParameters?: { [key: string]: string | undefined };
  AlgorithmSpecification?: AlgorithmSpecification & {
    TrainingInputMode: TrainingInputMode;
    MetricDefinitions: (MetricDefinition & {
      Name: MetricName;
      Regex: MetricRegex;
    })[];
    TrainingImageConfig: TrainingImageConfig & {
      TrainingRepositoryAccessMode: TrainingRepositoryAccessMode;
      TrainingRepositoryAuthConfig: TrainingRepositoryAuthConfig & {
        TrainingRepositoryCredentialsProviderArn: TrainingRepositoryCredentialsProviderArn;
      };
    };
  };
  RoleArn?: string;
  InputDataConfig?: (Channel & {
    ChannelName: ChannelName;
    DataSource: DataSource & {
      S3DataSource: S3DataSource & {
        S3DataType: S3DataType;
        S3Uri: S3Uri;
        ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
        HubAccessConfig: HubAccessConfig & { HubContentArn: HubContentArn };
      };
      FileSystemDataSource: FileSystemDataSource & {
        FileSystemId: FileSystemId;
        FileSystemAccessMode: FileSystemAccessMode;
        FileSystemType: FileSystemType;
        DirectoryPath: DirectoryPath;
      };
    };
    ShuffleConfig: ShuffleConfig & { Seed: Seed };
  })[];
  OutputDataConfig?: OutputDataConfig & { S3OutputPath: S3Uri };
  ResourceConfig?: ResourceConfig & {
    InstanceGroups: (InstanceGroup & {
      InstanceType: TrainingInstanceType;
      InstanceCount: TrainingInstanceCount;
      InstanceGroupName: InstanceGroupName;
    })[];
    InstancePlacementConfig: InstancePlacementConfig & {
      PlacementSpecifications: (PlacementSpecification & {
        InstanceCount: TrainingInstanceCount;
      })[];
    };
  };
  WarmPoolStatus?: WarmPoolStatus & { Status: WarmPoolResourceStatus };
  VpcConfig?: VpcConfig & {
    SecurityGroupIds: VpcSecurityGroupIds;
    Subnets: Subnets;
  };
  StoppingCondition: StoppingCondition;
  CreationTime: Date;
  TrainingStartTime?: Date;
  TrainingEndTime?: Date;
  LastModifiedTime?: Date;
  SecondaryStatusTransitions?: (SecondaryStatusTransition & {
    Status: SecondaryStatus;
    StartTime: Date;
  })[];
  FinalMetricDataList?: MetricData[];
  EnableNetworkIsolation?: boolean;
  EnableInterContainerTrafficEncryption?: boolean;
  EnableManagedSpotTraining?: boolean;
  CheckpointConfig?: CheckpointConfig & { S3Uri: S3Uri };
  TrainingTimeInSeconds?: number;
  BillableTimeInSeconds?: number;
  BillableTokenCount?: number;
  DebugHookConfig?: DebugHookConfig & { S3OutputPath: S3Uri };
  ExperimentConfig?: ExperimentConfig;
  DebugRuleConfigurations?: (DebugRuleConfiguration & {
    RuleConfigurationName: RuleConfigurationName;
    RuleEvaluatorImage: AlgorithmImage;
  })[];
  TensorBoardOutputConfig?: TensorBoardOutputConfig & { S3OutputPath: S3Uri };
  DebugRuleEvaluationStatuses?: DebugRuleEvaluationStatus[];
  ProfilerConfig?: ProfilerConfig;
  ProfilerRuleConfigurations?: (ProfilerRuleConfiguration & {
    RuleConfigurationName: RuleConfigurationName;
    RuleEvaluatorImage: AlgorithmImage;
  })[];
  ProfilerRuleEvaluationStatuses?: ProfilerRuleEvaluationStatus[];
  ProfilingStatus?: ProfilingStatus;
  Environment?: { [key: string]: string | undefined };
  RetryStrategy?: RetryStrategy & {
    MaximumRetryAttempts: MaximumRetryAttempts;
  };
  RemoteDebugConfig?: RemoteDebugConfig;
  InfraCheckConfig?: InfraCheckConfig;
  ServerlessJobConfig?: ServerlessJobConfig;
  MlflowConfig?: MlflowConfig;
  ModelPackageConfig?: ModelPackageConfig;
  MlflowDetails?: MlflowDetails;
  ProgressInfo?: TrainingProgressInfo;
  OutputModelPackageArn?: string;
}
export const DescribeTrainingJobResponse = S.suspend(() =>
  S.Struct({
    TrainingJobName: S.optional(S.String),
    TrainingJobArn: S.optional(S.String),
    TuningJobArn: S.optional(S.String),
    LabelingJobArn: S.optional(S.String),
    AutoMLJobArn: S.optional(S.String),
    ModelArtifacts: S.optional(ModelArtifacts),
    TrainingJobStatus: S.optional(TrainingJobStatus),
    SecondaryStatus: S.optional(SecondaryStatus),
    FailureReason: S.optional(S.String),
    HyperParameters: S.optional(HyperParameters),
    AlgorithmSpecification: S.optional(AlgorithmSpecification),
    RoleArn: S.optional(S.String),
    InputDataConfig: S.optional(InputDataConfig),
    OutputDataConfig: S.optional(OutputDataConfig),
    ResourceConfig: S.optional(ResourceConfig),
    WarmPoolStatus: S.optional(WarmPoolStatus),
    VpcConfig: S.optional(VpcConfig),
    StoppingCondition: S.optional(StoppingCondition),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    TrainingStartTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    TrainingEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SecondaryStatusTransitions: S.optional(SecondaryStatusTransitions),
    FinalMetricDataList: S.optional(FinalMetricDataList),
    EnableNetworkIsolation: S.optional(S.Boolean),
    EnableInterContainerTrafficEncryption: S.optional(S.Boolean),
    EnableManagedSpotTraining: S.optional(S.Boolean),
    CheckpointConfig: S.optional(CheckpointConfig),
    TrainingTimeInSeconds: S.optional(S.Number),
    BillableTimeInSeconds: S.optional(S.Number),
    BillableTokenCount: S.optional(S.Number),
    DebugHookConfig: S.optional(DebugHookConfig),
    ExperimentConfig: S.optional(ExperimentConfig),
    DebugRuleConfigurations: S.optional(DebugRuleConfigurations),
    TensorBoardOutputConfig: S.optional(TensorBoardOutputConfig),
    DebugRuleEvaluationStatuses: S.optional(DebugRuleEvaluationStatuses),
    ProfilerConfig: S.optional(ProfilerConfig),
    ProfilerRuleConfigurations: S.optional(ProfilerRuleConfigurations),
    ProfilerRuleEvaluationStatuses: S.optional(ProfilerRuleEvaluationStatuses),
    ProfilingStatus: S.optional(ProfilingStatus),
    Environment: S.optional(TrainingEnvironmentMap),
    RetryStrategy: S.optional(RetryStrategy),
    RemoteDebugConfig: S.optional(RemoteDebugConfig),
    InfraCheckConfig: S.optional(InfraCheckConfig),
    ServerlessJobConfig: S.optional(ServerlessJobConfig),
    MlflowConfig: S.optional(MlflowConfig),
    ModelPackageConfig: S.optional(ModelPackageConfig),
    MlflowDetails: S.optional(MlflowDetails),
    ProgressInfo: S.optional(TrainingProgressInfo),
    OutputModelPackageArn: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTrainingJobResponse",
}) as any as S.Schema<DescribeTrainingJobResponse>;
export interface DescribeTrainingPlanRequest {
  TrainingPlanName?: string;
}
export const DescribeTrainingPlanRequest = S.suspend(() =>
  S.Struct({ TrainingPlanName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTrainingPlanRequest",
}) as any as S.Schema<DescribeTrainingPlanRequest>;
export type TrainingPlanStatus =
  | "Pending"
  | "Active"
  | "Scheduled"
  | "Expired"
  | "Failed"
  | (string & {});
export const TrainingPlanStatus = S.String;
export type SageMakerResourceName =
  | "training-job"
  | "hyperpod-cluster"
  | "endpoint"
  | (string & {});
export const SageMakerResourceName = S.String;
export type SageMakerResourceNames = SageMakerResourceName[];
export const SageMakerResourceNames = S.Array(SageMakerResourceName);
export interface ReservedCapacitySummary {
  ReservedCapacityArn?: string;
  ReservedCapacityType?: ReservedCapacityType;
  UltraServerType?: string;
  UltraServerCount?: number;
  InstanceType?: ReservedCapacityInstanceType;
  TotalInstanceCount?: number;
  Status?: ReservedCapacityStatus;
  AvailabilityZone?: string;
  DurationHours?: number;
  DurationMinutes?: number;
  StartTime?: Date;
  EndTime?: Date;
}
export const ReservedCapacitySummary = S.suspend(() =>
  S.Struct({
    ReservedCapacityArn: S.optional(S.String),
    ReservedCapacityType: S.optional(ReservedCapacityType),
    UltraServerType: S.optional(S.String),
    UltraServerCount: S.optional(S.Number),
    InstanceType: S.optional(ReservedCapacityInstanceType),
    TotalInstanceCount: S.optional(S.Number),
    Status: S.optional(ReservedCapacityStatus),
    AvailabilityZone: S.optional(S.String),
    DurationHours: S.optional(S.Number),
    DurationMinutes: S.optional(S.Number),
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotate({
  identifier: "ReservedCapacitySummary",
}) as any as S.Schema<ReservedCapacitySummary>;
export type ReservedCapacitySummaries = ReservedCapacitySummary[];
export const ReservedCapacitySummaries = S.Array(ReservedCapacitySummary);
export interface DescribeTrainingPlanResponse {
  TrainingPlanArn: string;
  TrainingPlanName: string;
  Status: TrainingPlanStatus;
  StatusMessage?: string;
  DurationHours?: number;
  DurationMinutes?: number;
  StartTime?: Date;
  EndTime?: Date;
  UpfrontFee?: string;
  CurrencyCode?: string;
  TotalInstanceCount?: number;
  AvailableInstanceCount?: number;
  InUseInstanceCount?: number;
  UnhealthyInstanceCount?: number;
  AvailableSpareInstanceCount?: number;
  TotalUltraServerCount?: number;
  TargetResources?: SageMakerResourceName[];
  ReservedCapacitySummaries?: (ReservedCapacitySummary & {
    ReservedCapacityArn: ReservedCapacityArn;
    InstanceType: ReservedCapacityInstanceType;
    TotalInstanceCount: TotalInstanceCount;
    Status: ReservedCapacityStatus;
  })[];
}
export const DescribeTrainingPlanResponse = S.suspend(() =>
  S.Struct({
    TrainingPlanArn: S.optional(S.String),
    TrainingPlanName: S.optional(S.String),
    Status: S.optional(TrainingPlanStatus),
    StatusMessage: S.optional(S.String),
    DurationHours: S.optional(S.Number),
    DurationMinutes: S.optional(S.Number),
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    UpfrontFee: S.optional(S.String),
    CurrencyCode: S.optional(S.String),
    TotalInstanceCount: S.optional(S.Number),
    AvailableInstanceCount: S.optional(S.Number),
    InUseInstanceCount: S.optional(S.Number),
    UnhealthyInstanceCount: S.optional(S.Number),
    AvailableSpareInstanceCount: S.optional(S.Number),
    TotalUltraServerCount: S.optional(S.Number),
    TargetResources: S.optional(SageMakerResourceNames),
    ReservedCapacitySummaries: S.optional(ReservedCapacitySummaries),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTrainingPlanResponse",
}) as any as S.Schema<DescribeTrainingPlanResponse>;
export interface DescribeTransformJobRequest {
  TransformJobName?: string;
}
export const DescribeTransformJobRequest = S.suspend(() =>
  S.Struct({ TransformJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTransformJobRequest",
}) as any as S.Schema<DescribeTransformJobRequest>;
export type TransformJobStatus =
  | "InProgress"
  | "Completed"
  | "Failed"
  | "Stopping"
  | "Stopped"
  | (string & {});
export const TransformJobStatus = S.String;
export interface DescribeTransformJobResponse {
  TransformJobName: string;
  TransformJobArn: string;
  TransformJobStatus: TransformJobStatus;
  FailureReason?: string;
  ModelName: string;
  MaxConcurrentTransforms?: number;
  ModelClientConfig?: ModelClientConfig;
  MaxPayloadInMB?: number;
  BatchStrategy?: BatchStrategy;
  Environment?: { [key: string]: string | undefined };
  TransformInput: TransformInput & {
    DataSource: TransformDataSource & {
      S3DataSource: TransformS3DataSource & {
        S3DataType: S3DataType;
        S3Uri: S3Uri;
      };
    };
  };
  TransformOutput?: TransformOutput & { S3OutputPath: S3Uri };
  DataCaptureConfig?: BatchDataCaptureConfig & { DestinationS3Uri: S3Uri };
  TransformResources: TransformResources & {
    InstanceType: TransformInstanceType;
    InstanceCount: TransformInstanceCount;
  };
  CreationTime: Date;
  TransformStartTime?: Date;
  TransformEndTime?: Date;
  LabelingJobArn?: string;
  AutoMLJobArn?: string;
  DataProcessing?: DataProcessing;
  ExperimentConfig?: ExperimentConfig;
}
export const DescribeTransformJobResponse = S.suspend(() =>
  S.Struct({
    TransformJobName: S.optional(S.String),
    TransformJobArn: S.optional(S.String),
    TransformJobStatus: S.optional(TransformJobStatus),
    FailureReason: S.optional(S.String),
    ModelName: S.optional(S.String),
    MaxConcurrentTransforms: S.optional(S.Number),
    ModelClientConfig: S.optional(ModelClientConfig),
    MaxPayloadInMB: S.optional(S.Number),
    BatchStrategy: S.optional(BatchStrategy),
    Environment: S.optional(TransformEnvironmentMap),
    TransformInput: S.optional(TransformInput),
    TransformOutput: S.optional(TransformOutput),
    DataCaptureConfig: S.optional(BatchDataCaptureConfig),
    TransformResources: S.optional(TransformResources),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    TransformStartTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    TransformEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LabelingJobArn: S.optional(S.String),
    AutoMLJobArn: S.optional(S.String),
    DataProcessing: S.optional(DataProcessing),
    ExperimentConfig: S.optional(ExperimentConfig),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTransformJobResponse",
}) as any as S.Schema<DescribeTransformJobResponse>;
export interface DescribeTrialRequest {
  TrialName?: string;
}
export const DescribeTrialRequest = S.suspend(() =>
  S.Struct({ TrialName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTrialRequest",
}) as any as S.Schema<DescribeTrialRequest>;
export interface TrialSource {
  SourceArn?: string;
  SourceType?: string;
}
export const TrialSource = S.suspend(() =>
  S.Struct({
    SourceArn: S.optional(S.String),
    SourceType: S.optional(S.String),
  }),
).annotate({ identifier: "TrialSource" }) as any as S.Schema<TrialSource>;
export interface DescribeTrialResponse {
  TrialName?: string;
  TrialArn?: string;
  DisplayName?: string;
  ExperimentName?: string;
  Source?: TrialSource & { SourceArn: TrialSourceArn };
  CreationTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
  MetadataProperties?: MetadataProperties;
}
export const DescribeTrialResponse = S.suspend(() =>
  S.Struct({
    TrialName: S.optional(S.String),
    TrialArn: S.optional(S.String),
    DisplayName: S.optional(S.String),
    ExperimentName: S.optional(S.String),
    Source: S.optional(TrialSource),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
    MetadataProperties: S.optional(MetadataProperties),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTrialResponse",
}) as any as S.Schema<DescribeTrialResponse>;
export interface DescribeTrialComponentRequest {
  TrialComponentName?: string;
}
export const DescribeTrialComponentRequest = S.suspend(() =>
  S.Struct({ TrialComponentName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTrialComponentRequest",
}) as any as S.Schema<DescribeTrialComponentRequest>;
export interface TrialComponentSource {
  SourceArn?: string;
  SourceType?: string;
}
export const TrialComponentSource = S.suspend(() =>
  S.Struct({
    SourceArn: S.optional(S.String),
    SourceType: S.optional(S.String),
  }),
).annotate({
  identifier: "TrialComponentSource",
}) as any as S.Schema<TrialComponentSource>;
export interface TrialComponentMetricSummary {
  MetricName?: string;
  SourceArn?: string;
  TimeStamp?: Date;
  Max?: number;
  Min?: number;
  Last?: number;
  Count?: number;
  Avg?: number;
  StdDev?: number;
}
export const TrialComponentMetricSummary = S.suspend(() =>
  S.Struct({
    MetricName: S.optional(S.String),
    SourceArn: S.optional(S.String),
    TimeStamp: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Max: S.optional(S.Number),
    Min: S.optional(S.Number),
    Last: S.optional(S.Number),
    Count: S.optional(S.Number),
    Avg: S.optional(S.Number),
    StdDev: S.optional(S.Number),
  }),
).annotate({
  identifier: "TrialComponentMetricSummary",
}) as any as S.Schema<TrialComponentMetricSummary>;
export type TrialComponentMetricSummaries = TrialComponentMetricSummary[];
export const TrialComponentMetricSummaries = S.Array(
  TrialComponentMetricSummary,
);
export type TrialComponentSources = TrialComponentSource[];
export const TrialComponentSources = S.Array(TrialComponentSource);
export interface DescribeTrialComponentResponse {
  TrialComponentName?: string;
  TrialComponentArn?: string;
  DisplayName?: string;
  Source?: TrialComponentSource & { SourceArn: TrialComponentSourceArn };
  Status?: TrialComponentStatus;
  StartTime?: Date;
  EndTime?: Date;
  CreationTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
  Parameters?: { [key: string]: TrialComponentParameterValue | undefined };
  InputArtifacts?: {
    [key: string]:
      | (TrialComponentArtifact & { Value: TrialComponentArtifactValue })
      | undefined;
  };
  OutputArtifacts?: {
    [key: string]:
      | (TrialComponentArtifact & { Value: TrialComponentArtifactValue })
      | undefined;
  };
  MetadataProperties?: MetadataProperties;
  Metrics?: TrialComponentMetricSummary[];
  LineageGroupArn?: string;
  Sources?: (TrialComponentSource & { SourceArn: TrialComponentSourceArn })[];
}
export const DescribeTrialComponentResponse = S.suspend(() =>
  S.Struct({
    TrialComponentName: S.optional(S.String),
    TrialComponentArn: S.optional(S.String),
    DisplayName: S.optional(S.String),
    Source: S.optional(TrialComponentSource),
    Status: S.optional(TrialComponentStatus),
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
    Parameters: S.optional(TrialComponentParameters),
    InputArtifacts: S.optional(TrialComponentArtifacts),
    OutputArtifacts: S.optional(TrialComponentArtifacts),
    MetadataProperties: S.optional(MetadataProperties),
    Metrics: S.optional(TrialComponentMetricSummaries),
    LineageGroupArn: S.optional(S.String),
    Sources: S.optional(TrialComponentSources),
  }).pipe(ns),
).annotate({
  identifier: "DescribeTrialComponentResponse",
}) as any as S.Schema<DescribeTrialComponentResponse>;
export interface DescribeUserProfileRequest {
  DomainId?: string;
  UserProfileName?: string;
}
export const DescribeUserProfileRequest = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    UserProfileName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeUserProfileRequest",
}) as any as S.Schema<DescribeUserProfileRequest>;
export type UserProfileStatus =
  | "Deleting"
  | "Failed"
  | "InService"
  | "Pending"
  | "Updating"
  | "Update_Failed"
  | "Delete_Failed"
  | (string & {});
export const UserProfileStatus = S.String;
export interface DescribeUserProfileResponse {
  DomainId?: string;
  UserProfileArn?: string;
  UserProfileName?: string;
  HomeEfsFileSystemUid?: string;
  Status?: UserProfileStatus;
  LastModifiedTime?: Date;
  CreationTime?: Date;
  FailureReason?: string;
  SingleSignOnUserIdentifier?: string;
  SingleSignOnUserValue?: string;
  UserSettings?: UserSettings & {
    JupyterServerAppSettings: JupyterServerAppSettings & {
      CodeRepositories: (CodeRepository & { RepositoryUrl: RepositoryUrl })[];
    };
    KernelGatewayAppSettings: KernelGatewayAppSettings & {
      CustomImages: (CustomImage & {
        ImageName: ImageName;
        AppImageConfigName: AppImageConfigName;
      })[];
    };
    RSessionAppSettings: RSessionAppSettings & {
      CustomImages: (CustomImage & {
        ImageName: ImageName;
        AppImageConfigName: AppImageConfigName;
      })[];
    };
    CodeEditorAppSettings: CodeEditorAppSettings & {
      CustomImages: (CustomImage & {
        ImageName: ImageName;
        AppImageConfigName: AppImageConfigName;
      })[];
    };
    JupyterLabAppSettings: JupyterLabAppSettings & {
      CustomImages: (CustomImage & {
        ImageName: ImageName;
        AppImageConfigName: AppImageConfigName;
      })[];
      CodeRepositories: (CodeRepository & { RepositoryUrl: RepositoryUrl })[];
    };
    SpaceStorageSettings: DefaultSpaceStorageSettings & {
      DefaultEbsStorageSettings: DefaultEbsStorageSettings & {
        DefaultEbsVolumeSizeInGb: SpaceEbsVolumeSizeInGb;
        MaximumEbsVolumeSizeInGb: SpaceEbsVolumeSizeInGb;
      };
    };
    CustomPosixUserConfig: CustomPosixUserConfig & { Uid: Uid; Gid: Gid };
  };
}
export const DescribeUserProfileResponse = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    UserProfileArn: S.optional(S.String),
    UserProfileName: S.optional(S.String),
    HomeEfsFileSystemUid: S.optional(S.String),
    Status: S.optional(UserProfileStatus),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    FailureReason: S.optional(S.String),
    SingleSignOnUserIdentifier: S.optional(S.String),
    SingleSignOnUserValue: S.optional(S.String),
    UserSettings: S.optional(UserSettings),
  }).pipe(ns),
).annotate({
  identifier: "DescribeUserProfileResponse",
}) as any as S.Schema<DescribeUserProfileResponse>;
export interface DescribeWorkforceRequest {
  WorkforceName?: string;
}
export const DescribeWorkforceRequest = S.suspend(() =>
  S.Struct({ WorkforceName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeWorkforceRequest",
}) as any as S.Schema<DescribeWorkforceRequest>;
export interface OidcConfigForResponse {
  ClientId?: string;
  Issuer?: string;
  AuthorizationEndpoint?: string;
  TokenEndpoint?: string;
  UserInfoEndpoint?: string;
  LogoutEndpoint?: string;
  JwksUri?: string;
  Scope?: string;
  AuthenticationRequestExtraParams?: { [key: string]: string | undefined };
}
export const OidcConfigForResponse = S.suspend(() =>
  S.Struct({
    ClientId: S.optional(S.String),
    Issuer: S.optional(S.String),
    AuthorizationEndpoint: S.optional(S.String),
    TokenEndpoint: S.optional(S.String),
    UserInfoEndpoint: S.optional(S.String),
    LogoutEndpoint: S.optional(S.String),
    JwksUri: S.optional(S.String),
    Scope: S.optional(S.String),
    AuthenticationRequestExtraParams: S.optional(
      AuthenticationRequestExtraParams,
    ),
  }),
).annotate({
  identifier: "OidcConfigForResponse",
}) as any as S.Schema<OidcConfigForResponse>;
export interface WorkforceVpcConfigResponse {
  VpcId?: string;
  SecurityGroupIds?: string[];
  Subnets?: string[];
  VpcEndpointId?: string;
}
export const WorkforceVpcConfigResponse = S.suspend(() =>
  S.Struct({
    VpcId: S.optional(S.String),
    SecurityGroupIds: S.optional(WorkforceSecurityGroupIds),
    Subnets: S.optional(WorkforceSubnets),
    VpcEndpointId: S.optional(S.String),
  }),
).annotate({
  identifier: "WorkforceVpcConfigResponse",
}) as any as S.Schema<WorkforceVpcConfigResponse>;
export type WorkforceStatus =
  | "Initializing"
  | "Updating"
  | "Deleting"
  | "Failed"
  | "Active"
  | (string & {});
export const WorkforceStatus = S.String;
export interface Workforce {
  WorkforceName?: string;
  WorkforceArn?: string;
  LastUpdatedDate?: Date;
  SourceIpConfig?: SourceIpConfig;
  SubDomain?: string;
  CognitoConfig?: CognitoConfig;
  OidcConfig?: OidcConfigForResponse;
  CreateDate?: Date;
  WorkforceVpcConfig?: WorkforceVpcConfigResponse;
  Status?: WorkforceStatus;
  FailureReason?: string;
  IpAddressType?: WorkforceIpAddressType;
}
export const Workforce = S.suspend(() =>
  S.Struct({
    WorkforceName: S.optional(S.String),
    WorkforceArn: S.optional(S.String),
    LastUpdatedDate: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SourceIpConfig: S.optional(SourceIpConfig),
    SubDomain: S.optional(S.String),
    CognitoConfig: S.optional(CognitoConfig),
    OidcConfig: S.optional(OidcConfigForResponse),
    CreateDate: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    WorkforceVpcConfig: S.optional(WorkforceVpcConfigResponse),
    Status: S.optional(WorkforceStatus),
    FailureReason: S.optional(S.String),
    IpAddressType: S.optional(WorkforceIpAddressType),
  }),
).annotate({ identifier: "Workforce" }) as any as S.Schema<Workforce>;
export interface DescribeWorkforceResponse {
  Workforce: Workforce & {
    WorkforceName: WorkforceName;
    WorkforceArn: WorkforceArn;
    SourceIpConfig: SourceIpConfig & { Cidrs: Cidrs };
    CognitoConfig: CognitoConfig & {
      UserPool: CognitoUserPool;
      ClientId: ClientId;
    };
    WorkforceVpcConfig: WorkforceVpcConfigResponse & {
      VpcId: WorkforceVpcId;
      SecurityGroupIds: WorkforceSecurityGroupIds;
      Subnets: WorkforceSubnets;
    };
  };
}
export const DescribeWorkforceResponse = S.suspend(() =>
  S.Struct({ Workforce: S.optional(Workforce) }).pipe(ns),
).annotate({
  identifier: "DescribeWorkforceResponse",
}) as any as S.Schema<DescribeWorkforceResponse>;
export interface DescribeWorkteamRequest {
  WorkteamName?: string;
}
export const DescribeWorkteamRequest = S.suspend(() =>
  S.Struct({ WorkteamName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeWorkteamRequest",
}) as any as S.Schema<DescribeWorkteamRequest>;
export type ProductListings = string[];
export const ProductListings = S.Array(S.String);
export interface Workteam {
  WorkteamName?: string;
  MemberDefinitions?: MemberDefinition[];
  WorkteamArn?: string;
  WorkforceArn?: string;
  ProductListingIds?: string[];
  Description?: string;
  SubDomain?: string;
  CreateDate?: Date;
  LastUpdatedDate?: Date;
  NotificationConfiguration?: NotificationConfiguration;
  WorkerAccessConfiguration?: WorkerAccessConfiguration;
}
export const Workteam = S.suspend(() =>
  S.Struct({
    WorkteamName: S.optional(S.String),
    MemberDefinitions: S.optional(MemberDefinitions),
    WorkteamArn: S.optional(S.String),
    WorkforceArn: S.optional(S.String),
    ProductListingIds: S.optional(ProductListings),
    Description: S.optional(S.String),
    SubDomain: S.optional(S.String),
    CreateDate: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedDate: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    NotificationConfiguration: S.optional(NotificationConfiguration),
    WorkerAccessConfiguration: S.optional(WorkerAccessConfiguration),
  }),
).annotate({ identifier: "Workteam" }) as any as S.Schema<Workteam>;
export interface DescribeWorkteamResponse {
  Workteam: Workteam & {
    WorkteamName: WorkteamName;
    MemberDefinitions: (MemberDefinition & {
      CognitoMemberDefinition: CognitoMemberDefinition & {
        UserPool: CognitoUserPool;
        UserGroup: CognitoUserGroup;
        ClientId: ClientId;
      };
    })[];
    WorkteamArn: WorkteamArn;
    Description: String200;
  };
}
export const DescribeWorkteamResponse = S.suspend(() =>
  S.Struct({ Workteam: S.optional(Workteam) }).pipe(ns),
).annotate({
  identifier: "DescribeWorkteamResponse",
}) as any as S.Schema<DescribeWorkteamResponse>;
export interface DetachClusterNodeVolumeRequest {
  ClusterArn?: string;
  NodeId?: string;
  VolumeId?: string;
}
export const DetachClusterNodeVolumeRequest = S.suspend(() =>
  S.Struct({
    ClusterArn: S.optional(S.String),
    NodeId: S.optional(S.String),
    VolumeId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DetachClusterNodeVolumeRequest",
}) as any as S.Schema<DetachClusterNodeVolumeRequest>;
export interface DetachClusterNodeVolumeResponse {
  ClusterArn: string;
  NodeId: string;
  VolumeId: string;
  AttachTime: Date;
  Status: VolumeAttachmentStatus;
  DeviceName: string;
}
export const DetachClusterNodeVolumeResponse = S.suspend(() =>
  S.Struct({
    ClusterArn: S.optional(S.String),
    NodeId: S.optional(S.String),
    VolumeId: S.optional(S.String),
    AttachTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Status: S.optional(VolumeAttachmentStatus),
    DeviceName: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "DetachClusterNodeVolumeResponse",
}) as any as S.Schema<DetachClusterNodeVolumeResponse>;
export interface DisableSagemakerServicecatalogPortfolioInput {}
export const DisableSagemakerServicecatalogPortfolioInput = S.suspend(() =>
  S.Struct({}).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisableSagemakerServicecatalogPortfolioInput",
}) as any as S.Schema<DisableSagemakerServicecatalogPortfolioInput>;
export interface DisableSagemakerServicecatalogPortfolioOutput {}
export const DisableSagemakerServicecatalogPortfolioOutput = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "DisableSagemakerServicecatalogPortfolioOutput",
}) as any as S.Schema<DisableSagemakerServicecatalogPortfolioOutput>;
export interface DisassociateTrialComponentRequest {
  TrialComponentName?: string;
  TrialName?: string;
}
export const DisassociateTrialComponentRequest = S.suspend(() =>
  S.Struct({
    TrialComponentName: S.optional(S.String),
    TrialName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateTrialComponentRequest",
}) as any as S.Schema<DisassociateTrialComponentRequest>;
export interface DisassociateTrialComponentResponse {
  TrialComponentArn?: string;
  TrialArn?: string;
}
export const DisassociateTrialComponentResponse = S.suspend(() =>
  S.Struct({
    TrialComponentArn: S.optional(S.String),
    TrialArn: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "DisassociateTrialComponentResponse",
}) as any as S.Schema<DisassociateTrialComponentResponse>;
export interface EnableSagemakerServicecatalogPortfolioInput {}
export const EnableSagemakerServicecatalogPortfolioInput = S.suspend(() =>
  S.Struct({}).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EnableSagemakerServicecatalogPortfolioInput",
}) as any as S.Schema<EnableSagemakerServicecatalogPortfolioInput>;
export interface EnableSagemakerServicecatalogPortfolioOutput {}
export const EnableSagemakerServicecatalogPortfolioOutput = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "EnableSagemakerServicecatalogPortfolioOutput",
}) as any as S.Schema<EnableSagemakerServicecatalogPortfolioOutput>;
export interface GetDeviceFleetReportRequest {
  DeviceFleetName?: string;
}
export const GetDeviceFleetReportRequest = S.suspend(() =>
  S.Struct({ DeviceFleetName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetDeviceFleetReportRequest",
}) as any as S.Schema<GetDeviceFleetReportRequest>;
export interface DeviceStats {
  ConnectedDeviceCount?: number;
  RegisteredDeviceCount?: number;
}
export const DeviceStats = S.suspend(() =>
  S.Struct({
    ConnectedDeviceCount: S.optional(S.Number),
    RegisteredDeviceCount: S.optional(S.Number),
  }),
).annotate({ identifier: "DeviceStats" }) as any as S.Schema<DeviceStats>;
export interface AgentVersion {
  Version?: string;
  AgentCount?: number;
}
export const AgentVersion = S.suspend(() =>
  S.Struct({ Version: S.optional(S.String), AgentCount: S.optional(S.Number) }),
).annotate({ identifier: "AgentVersion" }) as any as S.Schema<AgentVersion>;
export type AgentVersions = AgentVersion[];
export const AgentVersions = S.Array(AgentVersion);
export interface EdgeModelStat {
  ModelName?: string;
  ModelVersion?: string;
  OfflineDeviceCount?: number;
  ConnectedDeviceCount?: number;
  ActiveDeviceCount?: number;
  SamplingDeviceCount?: number;
}
export const EdgeModelStat = S.suspend(() =>
  S.Struct({
    ModelName: S.optional(S.String),
    ModelVersion: S.optional(S.String),
    OfflineDeviceCount: S.optional(S.Number),
    ConnectedDeviceCount: S.optional(S.Number),
    ActiveDeviceCount: S.optional(S.Number),
    SamplingDeviceCount: S.optional(S.Number),
  }),
).annotate({ identifier: "EdgeModelStat" }) as any as S.Schema<EdgeModelStat>;
export type EdgeModelStats = EdgeModelStat[];
export const EdgeModelStats = S.Array(EdgeModelStat);
export interface GetDeviceFleetReportResponse {
  DeviceFleetArn: string;
  DeviceFleetName: string;
  OutputConfig?: EdgeOutputConfig & { S3OutputLocation: S3Uri };
  Description?: string;
  ReportGenerated?: Date;
  DeviceStats?: DeviceStats & {
    ConnectedDeviceCount: number;
    RegisteredDeviceCount: number;
  };
  AgentVersions?: (AgentVersion & {
    Version: EdgeVersion;
    AgentCount: number;
  })[];
  ModelStats?: (EdgeModelStat & {
    ModelName: EntityName;
    ModelVersion: EdgeVersion;
    OfflineDeviceCount: number;
    ConnectedDeviceCount: number;
    ActiveDeviceCount: number;
    SamplingDeviceCount: number;
  })[];
}
export const GetDeviceFleetReportResponse = S.suspend(() =>
  S.Struct({
    DeviceFleetArn: S.optional(S.String),
    DeviceFleetName: S.optional(S.String),
    OutputConfig: S.optional(EdgeOutputConfig),
    Description: S.optional(S.String),
    ReportGenerated: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    DeviceStats: S.optional(DeviceStats),
    AgentVersions: S.optional(AgentVersions),
    ModelStats: S.optional(EdgeModelStats),
  }).pipe(ns),
).annotate({
  identifier: "GetDeviceFleetReportResponse",
}) as any as S.Schema<GetDeviceFleetReportResponse>;
export interface GetLineageGroupPolicyRequest {
  LineageGroupName?: string;
}
export const GetLineageGroupPolicyRequest = S.suspend(() =>
  S.Struct({ LineageGroupName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetLineageGroupPolicyRequest",
}) as any as S.Schema<GetLineageGroupPolicyRequest>;
export interface GetLineageGroupPolicyResponse {
  LineageGroupArn?: string;
  ResourcePolicy?: string;
}
export const GetLineageGroupPolicyResponse = S.suspend(() =>
  S.Struct({
    LineageGroupArn: S.optional(S.String),
    ResourcePolicy: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "GetLineageGroupPolicyResponse",
}) as any as S.Schema<GetLineageGroupPolicyResponse>;
export interface GetModelPackageGroupPolicyInput {
  ModelPackageGroupName?: string;
}
export const GetModelPackageGroupPolicyInput = S.suspend(() =>
  S.Struct({ ModelPackageGroupName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetModelPackageGroupPolicyInput",
}) as any as S.Schema<GetModelPackageGroupPolicyInput>;
export interface GetModelPackageGroupPolicyOutput {
  ResourcePolicy: string;
}
export const GetModelPackageGroupPolicyOutput = S.suspend(() =>
  S.Struct({ ResourcePolicy: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "GetModelPackageGroupPolicyOutput",
}) as any as S.Schema<GetModelPackageGroupPolicyOutput>;
export interface GetSagemakerServicecatalogPortfolioStatusInput {}
export const GetSagemakerServicecatalogPortfolioStatusInput = S.suspend(() =>
  S.Struct({}).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetSagemakerServicecatalogPortfolioStatusInput",
}) as any as S.Schema<GetSagemakerServicecatalogPortfolioStatusInput>;
export type SagemakerServicecatalogStatus =
  | "Enabled"
  | "Disabled"
  | (string & {});
export const SagemakerServicecatalogStatus = S.String;
export interface GetSagemakerServicecatalogPortfolioStatusOutput {
  Status?: SagemakerServicecatalogStatus;
}
export const GetSagemakerServicecatalogPortfolioStatusOutput = S.suspend(() =>
  S.Struct({ Status: S.optional(SagemakerServicecatalogStatus) }).pipe(ns),
).annotate({
  identifier: "GetSagemakerServicecatalogPortfolioStatusOutput",
}) as any as S.Schema<GetSagemakerServicecatalogPortfolioStatusOutput>;
export interface ScalingPolicyObjective {
  MinInvocationsPerMinute?: number;
  MaxInvocationsPerMinute?: number;
}
export const ScalingPolicyObjective = S.suspend(() =>
  S.Struct({
    MinInvocationsPerMinute: S.optional(S.Number),
    MaxInvocationsPerMinute: S.optional(S.Number),
  }),
).annotate({
  identifier: "ScalingPolicyObjective",
}) as any as S.Schema<ScalingPolicyObjective>;
export interface GetScalingConfigurationRecommendationRequest {
  InferenceRecommendationsJobName?: string;
  RecommendationId?: string;
  EndpointName?: string;
  TargetCpuUtilizationPerCore?: number;
  ScalingPolicyObjective?: ScalingPolicyObjective;
}
export const GetScalingConfigurationRecommendationRequest = S.suspend(() =>
  S.Struct({
    InferenceRecommendationsJobName: S.optional(S.String),
    RecommendationId: S.optional(S.String),
    EndpointName: S.optional(S.String),
    TargetCpuUtilizationPerCore: S.optional(S.Number),
    ScalingPolicyObjective: S.optional(ScalingPolicyObjective),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetScalingConfigurationRecommendationRequest",
}) as any as S.Schema<GetScalingConfigurationRecommendationRequest>;
export interface ScalingPolicyMetric {
  InvocationsPerInstance?: number;
  ModelLatency?: number;
}
export const ScalingPolicyMetric = S.suspend(() =>
  S.Struct({
    InvocationsPerInstance: S.optional(S.Number),
    ModelLatency: S.optional(S.Number),
  }),
).annotate({
  identifier: "ScalingPolicyMetric",
}) as any as S.Schema<ScalingPolicyMetric>;
export interface PredefinedMetricSpecification {
  PredefinedMetricType?: string;
}
export const PredefinedMetricSpecification = S.suspend(() =>
  S.Struct({ PredefinedMetricType: S.optional(S.String) }),
).annotate({
  identifier: "PredefinedMetricSpecification",
}) as any as S.Schema<PredefinedMetricSpecification>;
export type Statistic =
  | "Average"
  | "Minimum"
  | "Maximum"
  | "SampleCount"
  | "Sum"
  | (string & {});
export const Statistic = S.String;
export interface CustomizedMetricSpecification {
  MetricName?: string;
  Namespace?: string;
  Statistic?: Statistic;
}
export const CustomizedMetricSpecification = S.suspend(() =>
  S.Struct({
    MetricName: S.optional(S.String),
    Namespace: S.optional(S.String),
    Statistic: S.optional(Statistic),
  }),
).annotate({
  identifier: "CustomizedMetricSpecification",
}) as any as S.Schema<CustomizedMetricSpecification>;
export type MetricSpecification =
  | { Predefined: PredefinedMetricSpecification; Customized?: never }
  | { Predefined?: never; Customized: CustomizedMetricSpecification };
export const MetricSpecification = S.Union([
  S.Struct({ Predefined: PredefinedMetricSpecification }),
  S.Struct({ Customized: CustomizedMetricSpecification }),
]);
export interface TargetTrackingScalingPolicyConfiguration {
  MetricSpecification?: MetricSpecification;
  TargetValue?: number;
}
export const TargetTrackingScalingPolicyConfiguration = S.suspend(() =>
  S.Struct({
    MetricSpecification: S.optional(MetricSpecification),
    TargetValue: S.optional(S.Number),
  }),
).annotate({
  identifier: "TargetTrackingScalingPolicyConfiguration",
}) as any as S.Schema<TargetTrackingScalingPolicyConfiguration>;
export type ScalingPolicy = {
  TargetTracking: TargetTrackingScalingPolicyConfiguration;
};
export const ScalingPolicy = S.Union([
  S.Struct({ TargetTracking: TargetTrackingScalingPolicyConfiguration }),
]);
export type ScalingPolicies = ScalingPolicy[];
export const ScalingPolicies = S.Array(ScalingPolicy);
export interface DynamicScalingConfiguration {
  MinCapacity?: number;
  MaxCapacity?: number;
  ScaleInCooldown?: number;
  ScaleOutCooldown?: number;
  ScalingPolicies?: ScalingPolicy[];
}
export const DynamicScalingConfiguration = S.suspend(() =>
  S.Struct({
    MinCapacity: S.optional(S.Number),
    MaxCapacity: S.optional(S.Number),
    ScaleInCooldown: S.optional(S.Number),
    ScaleOutCooldown: S.optional(S.Number),
    ScalingPolicies: S.optional(ScalingPolicies),
  }),
).annotate({
  identifier: "DynamicScalingConfiguration",
}) as any as S.Schema<DynamicScalingConfiguration>;
export interface GetScalingConfigurationRecommendationResponse {
  InferenceRecommendationsJobName?: string;
  RecommendationId?: string;
  EndpointName?: string;
  TargetCpuUtilizationPerCore?: number;
  ScalingPolicyObjective?: ScalingPolicyObjective;
  Metric?: ScalingPolicyMetric;
  DynamicScalingConfiguration?: DynamicScalingConfiguration;
}
export const GetScalingConfigurationRecommendationResponse = S.suspend(() =>
  S.Struct({
    InferenceRecommendationsJobName: S.optional(S.String),
    RecommendationId: S.optional(S.String),
    EndpointName: S.optional(S.String),
    TargetCpuUtilizationPerCore: S.optional(S.Number),
    ScalingPolicyObjective: S.optional(ScalingPolicyObjective),
    Metric: S.optional(ScalingPolicyMetric),
    DynamicScalingConfiguration: S.optional(DynamicScalingConfiguration),
  }).pipe(ns),
).annotate({
  identifier: "GetScalingConfigurationRecommendationResponse",
}) as any as S.Schema<GetScalingConfigurationRecommendationResponse>;
export type ResourceType =
  | "TrainingJob"
  | "Experiment"
  | "ExperimentTrial"
  | "ExperimentTrialComponent"
  | "Endpoint"
  | "Model"
  | "ModelPackage"
  | "ModelPackageGroup"
  | "Pipeline"
  | "PipelineExecution"
  | "FeatureGroup"
  | "FeatureMetadata"
  | "Image"
  | "ImageVersion"
  | "Project"
  | "HyperParameterTuningJob"
  | "ModelCard"
  | "PipelineVersion"
  | (string & {});
export const ResourceType = S.String;
export interface PropertyNameQuery {
  PropertyNameHint?: string;
}
export const PropertyNameQuery = S.suspend(() =>
  S.Struct({ PropertyNameHint: S.optional(S.String) }),
).annotate({
  identifier: "PropertyNameQuery",
}) as any as S.Schema<PropertyNameQuery>;
export interface SuggestionQuery {
  PropertyNameQuery?: PropertyNameQuery;
}
export const SuggestionQuery = S.suspend(() =>
  S.Struct({ PropertyNameQuery: S.optional(PropertyNameQuery) }),
).annotate({
  identifier: "SuggestionQuery",
}) as any as S.Schema<SuggestionQuery>;
export interface GetSearchSuggestionsRequest {
  Resource?: ResourceType;
  SuggestionQuery?: SuggestionQuery;
}
export const GetSearchSuggestionsRequest = S.suspend(() =>
  S.Struct({
    Resource: S.optional(ResourceType),
    SuggestionQuery: S.optional(SuggestionQuery),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetSearchSuggestionsRequest",
}) as any as S.Schema<GetSearchSuggestionsRequest>;
export interface PropertyNameSuggestion {
  PropertyName?: string;
}
export const PropertyNameSuggestion = S.suspend(() =>
  S.Struct({ PropertyName: S.optional(S.String) }),
).annotate({
  identifier: "PropertyNameSuggestion",
}) as any as S.Schema<PropertyNameSuggestion>;
export type PropertyNameSuggestionList = PropertyNameSuggestion[];
export const PropertyNameSuggestionList = S.Array(PropertyNameSuggestion);
export interface GetSearchSuggestionsResponse {
  PropertyNameSuggestions?: PropertyNameSuggestion[];
}
export const GetSearchSuggestionsResponse = S.suspend(() =>
  S.Struct({
    PropertyNameSuggestions: S.optional(PropertyNameSuggestionList),
  }).pipe(ns),
).annotate({
  identifier: "GetSearchSuggestionsResponse",
}) as any as S.Schema<GetSearchSuggestionsResponse>;
export interface ImportHubContentRequest {
  HubContentName?: string;
  HubContentVersion?: string;
  HubContentType?: HubContentType;
  DocumentSchemaVersion?: string;
  HubName?: string;
  HubContentDisplayName?: string;
  HubContentDescription?: string;
  HubContentMarkdown?: string;
  HubContentDocument?: string;
  SupportStatus?: HubContentSupportStatus;
  HubContentSearchKeywords?: string[];
  Tags?: Tag[];
}
export const ImportHubContentRequest = S.suspend(() =>
  S.Struct({
    HubContentName: S.optional(S.String),
    HubContentVersion: S.optional(S.String),
    HubContentType: S.optional(HubContentType),
    DocumentSchemaVersion: S.optional(S.String),
    HubName: S.optional(S.String),
    HubContentDisplayName: S.optional(S.String),
    HubContentDescription: S.optional(S.String),
    HubContentMarkdown: S.optional(S.String),
    HubContentDocument: S.optional(S.String),
    SupportStatus: S.optional(HubContentSupportStatus),
    HubContentSearchKeywords: S.optional(HubContentSearchKeywordList),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ImportHubContentRequest",
}) as any as S.Schema<ImportHubContentRequest>;
export interface ImportHubContentResponse {
  HubArn: string;
  HubContentArn: string;
}
export const ImportHubContentResponse = S.suspend(() =>
  S.Struct({
    HubArn: S.optional(S.String),
    HubContentArn: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ImportHubContentResponse",
}) as any as S.Schema<ImportHubContentResponse>;
export type SortActionsBy = "Name" | "CreationTime" | (string & {});
export const SortActionsBy = S.String;
export type SortOrder = "Ascending" | "Descending" | (string & {});
export const SortOrder = S.String;
export interface ListActionsRequest {
  SourceUri?: string;
  ActionType?: string;
  CreatedAfter?: Date;
  CreatedBefore?: Date;
  SortBy?: SortActionsBy;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListActionsRequest = S.suspend(() =>
  S.Struct({
    SourceUri: S.optional(S.String),
    ActionType: S.optional(S.String),
    CreatedAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBefore: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    SortBy: S.optional(SortActionsBy),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListActionsRequest",
}) as any as S.Schema<ListActionsRequest>;
export interface ActionSummary {
  ActionArn?: string;
  ActionName?: string;
  Source?: ActionSource;
  ActionType?: string;
  Status?: ActionStatus;
  CreationTime?: Date;
  LastModifiedTime?: Date;
}
export const ActionSummary = S.suspend(() =>
  S.Struct({
    ActionArn: S.optional(S.String),
    ActionName: S.optional(S.String),
    Source: S.optional(ActionSource),
    ActionType: S.optional(S.String),
    Status: S.optional(ActionStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({ identifier: "ActionSummary" }) as any as S.Schema<ActionSummary>;
export type ActionSummaries = ActionSummary[];
export const ActionSummaries = S.Array(ActionSummary);
export interface ListActionsResponse {
  ActionSummaries?: (ActionSummary & {
    Source: ActionSource & { SourceUri: SourceUri };
  })[];
  NextToken?: string;
}
export const ListActionsResponse = S.suspend(() =>
  S.Struct({
    ActionSummaries: S.optional(ActionSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListActionsResponse",
}) as any as S.Schema<ListActionsResponse>;
export type AlgorithmSortBy = "Name" | "CreationTime" | (string & {});
export const AlgorithmSortBy = S.String;
export interface ListAlgorithmsInput {
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  MaxResults?: number;
  NameContains?: string;
  NextToken?: string;
  SortBy?: AlgorithmSortBy;
  SortOrder?: SortOrder;
}
export const ListAlgorithmsInput = S.suspend(() =>
  S.Struct({
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    MaxResults: S.optional(S.Number),
    NameContains: S.optional(S.String),
    NextToken: S.optional(S.String),
    SortBy: S.optional(AlgorithmSortBy),
    SortOrder: S.optional(SortOrder),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListAlgorithmsInput",
}) as any as S.Schema<ListAlgorithmsInput>;
export interface AlgorithmSummary {
  AlgorithmName?: string;
  AlgorithmArn?: string;
  AlgorithmDescription?: string;
  CreationTime?: Date;
  AlgorithmStatus?: AlgorithmStatus;
}
export const AlgorithmSummary = S.suspend(() =>
  S.Struct({
    AlgorithmName: S.optional(S.String),
    AlgorithmArn: S.optional(S.String),
    AlgorithmDescription: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    AlgorithmStatus: S.optional(AlgorithmStatus),
  }),
).annotate({
  identifier: "AlgorithmSummary",
}) as any as S.Schema<AlgorithmSummary>;
export type AlgorithmSummaryList = AlgorithmSummary[];
export const AlgorithmSummaryList = S.Array(AlgorithmSummary);
export interface ListAlgorithmsOutput {
  AlgorithmSummaryList: (AlgorithmSummary & {
    AlgorithmName: EntityName;
    AlgorithmArn: AlgorithmArn;
    CreationTime: CreationTime;
    AlgorithmStatus: AlgorithmStatus;
  })[];
  NextToken?: string;
}
export const ListAlgorithmsOutput = S.suspend(() =>
  S.Struct({
    AlgorithmSummaryList: S.optional(AlgorithmSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListAlgorithmsOutput",
}) as any as S.Schema<ListAlgorithmsOutput>;
export interface ListAliasesRequest {
  ImageName?: string;
  Alias?: string;
  Version?: number;
  MaxResults?: number;
  NextToken?: string;
}
export const ListAliasesRequest = S.suspend(() =>
  S.Struct({
    ImageName: S.optional(S.String),
    Alias: S.optional(S.String),
    Version: S.optional(S.Number),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListAliasesRequest",
}) as any as S.Schema<ListAliasesRequest>;
export interface ListAliasesResponse {
  SageMakerImageVersionAliases?: string[];
  NextToken?: string;
}
export const ListAliasesResponse = S.suspend(() =>
  S.Struct({
    SageMakerImageVersionAliases: S.optional(SageMakerImageVersionAliases),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListAliasesResponse",
}) as any as S.Schema<ListAliasesResponse>;
export type AppImageConfigSortKey =
  | "CreationTime"
  | "LastModifiedTime"
  | "Name"
  | (string & {});
export const AppImageConfigSortKey = S.String;
export interface ListAppImageConfigsRequest {
  MaxResults?: number;
  NextToken?: string;
  NameContains?: string;
  CreationTimeBefore?: Date;
  CreationTimeAfter?: Date;
  ModifiedTimeBefore?: Date;
  ModifiedTimeAfter?: Date;
  SortBy?: AppImageConfigSortKey;
  SortOrder?: SortOrder;
}
export const ListAppImageConfigsRequest = S.suspend(() =>
  S.Struct({
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    NameContains: S.optional(S.String),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SortBy: S.optional(AppImageConfigSortKey),
    SortOrder: S.optional(SortOrder),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListAppImageConfigsRequest",
}) as any as S.Schema<ListAppImageConfigsRequest>;
export interface AppImageConfigDetails {
  AppImageConfigArn?: string;
  AppImageConfigName?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  KernelGatewayImageConfig?: KernelGatewayImageConfig;
  JupyterLabAppImageConfig?: JupyterLabAppImageConfig;
  CodeEditorAppImageConfig?: CodeEditorAppImageConfig;
}
export const AppImageConfigDetails = S.suspend(() =>
  S.Struct({
    AppImageConfigArn: S.optional(S.String),
    AppImageConfigName: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    KernelGatewayImageConfig: S.optional(KernelGatewayImageConfig),
    JupyterLabAppImageConfig: S.optional(JupyterLabAppImageConfig),
    CodeEditorAppImageConfig: S.optional(CodeEditorAppImageConfig),
  }),
).annotate({
  identifier: "AppImageConfigDetails",
}) as any as S.Schema<AppImageConfigDetails>;
export type AppImageConfigList = AppImageConfigDetails[];
export const AppImageConfigList = S.Array(AppImageConfigDetails);
export interface ListAppImageConfigsResponse {
  NextToken?: string;
  AppImageConfigs?: (AppImageConfigDetails & {
    KernelGatewayImageConfig: KernelGatewayImageConfig & {
      KernelSpecs: (KernelSpec & { Name: KernelName })[];
    };
  })[];
}
export const ListAppImageConfigsResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    AppImageConfigs: S.optional(AppImageConfigList),
  }).pipe(ns),
).annotate({
  identifier: "ListAppImageConfigsResponse",
}) as any as S.Schema<ListAppImageConfigsResponse>;
export type AppSortKey = "CreationTime" | (string & {});
export const AppSortKey = S.String;
export interface ListAppsRequest {
  NextToken?: string;
  MaxResults?: number;
  SortOrder?: SortOrder;
  SortBy?: AppSortKey;
  DomainIdEquals?: string;
  UserProfileNameEquals?: string;
  SpaceNameEquals?: string;
}
export const ListAppsRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SortOrder: S.optional(SortOrder),
    SortBy: S.optional(AppSortKey),
    DomainIdEquals: S.optional(S.String),
    UserProfileNameEquals: S.optional(S.String),
    SpaceNameEquals: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListAppsRequest",
}) as any as S.Schema<ListAppsRequest>;
export interface AppDetails {
  DomainId?: string;
  UserProfileName?: string;
  SpaceName?: string;
  AppType?: AppType;
  AppName?: string;
  Status?: AppStatus;
  CreationTime?: Date;
  ResourceSpec?: ResourceSpec;
}
export const AppDetails = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    UserProfileName: S.optional(S.String),
    SpaceName: S.optional(S.String),
    AppType: S.optional(AppType),
    AppName: S.optional(S.String),
    Status: S.optional(AppStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ResourceSpec: S.optional(ResourceSpec),
  }),
).annotate({ identifier: "AppDetails" }) as any as S.Schema<AppDetails>;
export type AppList = AppDetails[];
export const AppList = S.Array(AppDetails);
export interface ListAppsResponse {
  Apps?: AppDetails[];
  NextToken?: string;
}
export const ListAppsResponse = S.suspend(() =>
  S.Struct({ Apps: S.optional(AppList), NextToken: S.optional(S.String) }).pipe(
    ns,
  ),
).annotate({
  identifier: "ListAppsResponse",
}) as any as S.Schema<ListAppsResponse>;
export type SortArtifactsBy = "CreationTime" | (string & {});
export const SortArtifactsBy = S.String;
export interface ListArtifactsRequest {
  SourceUri?: string;
  ArtifactType?: string;
  CreatedAfter?: Date;
  CreatedBefore?: Date;
  SortBy?: SortArtifactsBy;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListArtifactsRequest = S.suspend(() =>
  S.Struct({
    SourceUri: S.optional(S.String),
    ArtifactType: S.optional(S.String),
    CreatedAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBefore: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    SortBy: S.optional(SortArtifactsBy),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListArtifactsRequest",
}) as any as S.Schema<ListArtifactsRequest>;
export interface ArtifactSummary {
  ArtifactArn?: string;
  ArtifactName?: string;
  Source?: ArtifactSource;
  ArtifactType?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
}
export const ArtifactSummary = S.suspend(() =>
  S.Struct({
    ArtifactArn: S.optional(S.String),
    ArtifactName: S.optional(S.String),
    Source: S.optional(ArtifactSource),
    ArtifactType: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "ArtifactSummary",
}) as any as S.Schema<ArtifactSummary>;
export type ArtifactSummaries = ArtifactSummary[];
export const ArtifactSummaries = S.Array(ArtifactSummary);
export interface ListArtifactsResponse {
  ArtifactSummaries?: (ArtifactSummary & {
    Source: ArtifactSource & {
      SourceUri: SourceUri;
      SourceTypes: (ArtifactSourceType & {
        SourceIdType: ArtifactSourceIdType;
        Value: String256;
      })[];
    };
  })[];
  NextToken?: string;
}
export const ListArtifactsResponse = S.suspend(() =>
  S.Struct({
    ArtifactSummaries: S.optional(ArtifactSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListArtifactsResponse",
}) as any as S.Schema<ListArtifactsResponse>;
export type SortAssociationsBy =
  | "SourceArn"
  | "DestinationArn"
  | "SourceType"
  | "DestinationType"
  | "CreationTime"
  | (string & {});
export const SortAssociationsBy = S.String;
export interface ListAssociationsRequest {
  SourceArn?: string;
  DestinationArn?: string;
  SourceType?: string;
  DestinationType?: string;
  AssociationType?: AssociationEdgeType;
  CreatedAfter?: Date;
  CreatedBefore?: Date;
  SortBy?: SortAssociationsBy;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListAssociationsRequest = S.suspend(() =>
  S.Struct({
    SourceArn: S.optional(S.String),
    DestinationArn: S.optional(S.String),
    SourceType: S.optional(S.String),
    DestinationType: S.optional(S.String),
    AssociationType: S.optional(AssociationEdgeType),
    CreatedAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBefore: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    SortBy: S.optional(SortAssociationsBy),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListAssociationsRequest",
}) as any as S.Schema<ListAssociationsRequest>;
export interface AssociationSummary {
  SourceArn?: string;
  DestinationArn?: string;
  SourceType?: string;
  DestinationType?: string;
  AssociationType?: AssociationEdgeType;
  SourceName?: string;
  DestinationName?: string;
  CreationTime?: Date;
  CreatedBy?: UserContext;
}
export const AssociationSummary = S.suspend(() =>
  S.Struct({
    SourceArn: S.optional(S.String),
    DestinationArn: S.optional(S.String),
    SourceType: S.optional(S.String),
    DestinationType: S.optional(S.String),
    AssociationType: S.optional(AssociationEdgeType),
    SourceName: S.optional(S.String),
    DestinationName: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
  }),
).annotate({
  identifier: "AssociationSummary",
}) as any as S.Schema<AssociationSummary>;
export type AssociationSummaries = AssociationSummary[];
export const AssociationSummaries = S.Array(AssociationSummary);
export interface ListAssociationsResponse {
  AssociationSummaries?: AssociationSummary[];
  NextToken?: string;
}
export const ListAssociationsResponse = S.suspend(() =>
  S.Struct({
    AssociationSummaries: S.optional(AssociationSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListAssociationsResponse",
}) as any as S.Schema<ListAssociationsResponse>;
export type AutoMLSortOrder = "Ascending" | "Descending" | (string & {});
export const AutoMLSortOrder = S.String;
export type AutoMLSortBy = "Name" | "CreationTime" | "Status" | (string & {});
export const AutoMLSortBy = S.String;
export interface ListAutoMLJobsRequest {
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  NameContains?: string;
  StatusEquals?: AutoMLJobStatus;
  SortOrder?: AutoMLSortOrder;
  SortBy?: AutoMLSortBy;
  MaxResults?: number;
  NextToken?: string;
}
export const ListAutoMLJobsRequest = S.suspend(() =>
  S.Struct({
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    NameContains: S.optional(S.String),
    StatusEquals: S.optional(AutoMLJobStatus),
    SortOrder: S.optional(AutoMLSortOrder),
    SortBy: S.optional(AutoMLSortBy),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListAutoMLJobsRequest",
}) as any as S.Schema<ListAutoMLJobsRequest>;
export interface AutoMLJobSummary {
  AutoMLJobName?: string;
  AutoMLJobArn?: string;
  AutoMLJobStatus?: AutoMLJobStatus;
  AutoMLJobSecondaryStatus?: AutoMLJobSecondaryStatus;
  CreationTime?: Date;
  EndTime?: Date;
  LastModifiedTime?: Date;
  FailureReason?: string;
  PartialFailureReasons?: AutoMLPartialFailureReason[];
}
export const AutoMLJobSummary = S.suspend(() =>
  S.Struct({
    AutoMLJobName: S.optional(S.String),
    AutoMLJobArn: S.optional(S.String),
    AutoMLJobStatus: S.optional(AutoMLJobStatus),
    AutoMLJobSecondaryStatus: S.optional(AutoMLJobSecondaryStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    FailureReason: S.optional(S.String),
    PartialFailureReasons: S.optional(AutoMLPartialFailureReasons),
  }),
).annotate({
  identifier: "AutoMLJobSummary",
}) as any as S.Schema<AutoMLJobSummary>;
export type AutoMLJobSummaries = AutoMLJobSummary[];
export const AutoMLJobSummaries = S.Array(AutoMLJobSummary);
export interface ListAutoMLJobsResponse {
  AutoMLJobSummaries: (AutoMLJobSummary & {
    AutoMLJobName: AutoMLJobName;
    AutoMLJobArn: AutoMLJobArn;
    AutoMLJobStatus: AutoMLJobStatus;
    AutoMLJobSecondaryStatus: AutoMLJobSecondaryStatus;
    CreationTime: Date;
    LastModifiedTime: Date;
  })[];
  NextToken?: string;
}
export const ListAutoMLJobsResponse = S.suspend(() =>
  S.Struct({
    AutoMLJobSummaries: S.optional(AutoMLJobSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListAutoMLJobsResponse",
}) as any as S.Schema<ListAutoMLJobsResponse>;
export type CandidateSortBy =
  | "CreationTime"
  | "Status"
  | "FinalObjectiveMetricValue"
  | (string & {});
export const CandidateSortBy = S.String;
export interface ListCandidatesForAutoMLJobRequest {
  AutoMLJobName?: string;
  StatusEquals?: CandidateStatus;
  CandidateNameEquals?: string;
  SortOrder?: AutoMLSortOrder;
  SortBy?: CandidateSortBy;
  MaxResults?: number;
  NextToken?: string;
}
export const ListCandidatesForAutoMLJobRequest = S.suspend(() =>
  S.Struct({
    AutoMLJobName: S.optional(S.String),
    StatusEquals: S.optional(CandidateStatus),
    CandidateNameEquals: S.optional(S.String),
    SortOrder: S.optional(AutoMLSortOrder),
    SortBy: S.optional(CandidateSortBy),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListCandidatesForAutoMLJobRequest",
}) as any as S.Schema<ListCandidatesForAutoMLJobRequest>;
export type AutoMLCandidates = AutoMLCandidate[];
export const AutoMLCandidates = S.Array(AutoMLCandidate);
export interface ListCandidatesForAutoMLJobResponse {
  Candidates: (AutoMLCandidate & {
    CandidateName: CandidateName;
    ObjectiveStatus: ObjectiveStatus;
    CandidateSteps: (AutoMLCandidateStep & {
      CandidateStepType: CandidateStepType;
      CandidateStepArn: CandidateStepArn;
      CandidateStepName: CandidateStepName;
    })[];
    CandidateStatus: CandidateStatus;
    CreationTime: Date;
    LastModifiedTime: Date;
    FinalAutoMLJobObjectiveMetric: FinalAutoMLJobObjectiveMetric & {
      MetricName: AutoMLMetricEnum;
      Value: MetricValue;
    };
    InferenceContainers: (AutoMLContainerDefinition & {
      Image: ContainerImage;
      ModelDataUrl: Url;
    })[];
    CandidateProperties: CandidateProperties & {
      CandidateArtifactLocations: CandidateArtifactLocations & {
        Explainability: ExplainabilityLocation;
      };
    };
    InferenceContainerDefinitions: {
      [key: string]:
        | (AutoMLContainerDefinition & {
            Image: ContainerImage;
            ModelDataUrl: Url;
          })[]
        | undefined;
    };
  })[];
  NextToken?: string;
}
export const ListCandidatesForAutoMLJobResponse = S.suspend(() =>
  S.Struct({
    Candidates: S.optional(AutoMLCandidates),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListCandidatesForAutoMLJobResponse",
}) as any as S.Schema<ListCandidatesForAutoMLJobResponse>;
export type EventSortBy = "EventTime" | (string & {});
export const EventSortBy = S.String;
export interface ListClusterEventsRequest {
  ClusterName?: string;
  InstanceGroupName?: string;
  NodeId?: string;
  EventTimeAfter?: Date;
  EventTimeBefore?: Date;
  SortBy?: EventSortBy;
  SortOrder?: SortOrder;
  ResourceType?: ClusterEventResourceType;
  MaxResults?: number;
  NextToken?: string;
}
export const ListClusterEventsRequest = S.suspend(() =>
  S.Struct({
    ClusterName: S.optional(S.String),
    InstanceGroupName: S.optional(S.String),
    NodeId: S.optional(S.String),
    EventTimeAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EventTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SortBy: S.optional(EventSortBy),
    SortOrder: S.optional(SortOrder),
    ResourceType: S.optional(ClusterEventResourceType),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListClusterEventsRequest",
}) as any as S.Schema<ListClusterEventsRequest>;
export interface ClusterEventSummary {
  EventId?: string;
  ClusterArn?: string;
  ClusterName?: string;
  InstanceGroupName?: string;
  InstanceId?: string;
  ResourceType?: ClusterEventResourceType;
  EventTime?: Date;
  Description?: string;
}
export const ClusterEventSummary = S.suspend(() =>
  S.Struct({
    EventId: S.optional(S.String),
    ClusterArn: S.optional(S.String),
    ClusterName: S.optional(S.String),
    InstanceGroupName: S.optional(S.String),
    InstanceId: S.optional(S.String),
    ResourceType: S.optional(ClusterEventResourceType),
    EventTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Description: S.optional(S.String),
  }),
).annotate({
  identifier: "ClusterEventSummary",
}) as any as S.Schema<ClusterEventSummary>;
export type ClusterEventSummaries = ClusterEventSummary[];
export const ClusterEventSummaries = S.Array(ClusterEventSummary);
export interface ListClusterEventsResponse {
  NextToken?: string;
  Events?: (ClusterEventSummary & {
    EventId: EventId;
    ClusterArn: ClusterArn;
    ClusterName: ClusterName;
    ResourceType: ClusterEventResourceType;
    EventTime: Date;
  })[];
}
export const ListClusterEventsResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    Events: S.optional(ClusterEventSummaries),
  }).pipe(ns),
).annotate({
  identifier: "ListClusterEventsResponse",
}) as any as S.Schema<ListClusterEventsResponse>;
export type ClusterSortBy = "CREATION_TIME" | "NAME" | (string & {});
export const ClusterSortBy = S.String;
export interface ListClusterNodesRequest {
  ClusterName?: string;
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  InstanceGroupNameContains?: string;
  MaxResults?: number;
  NextToken?: string;
  SortBy?: ClusterSortBy;
  SortOrder?: SortOrder;
  IncludeNodeLogicalIds?: boolean;
}
export const ListClusterNodesRequest = S.suspend(() =>
  S.Struct({
    ClusterName: S.optional(S.String),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    InstanceGroupNameContains: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    SortBy: S.optional(ClusterSortBy),
    SortOrder: S.optional(SortOrder),
    IncludeNodeLogicalIds: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListClusterNodesRequest",
}) as any as S.Schema<ListClusterNodesRequest>;
export interface ClusterNodeSummary {
  InstanceGroupName?: string;
  InstanceId?: string;
  NodeLogicalId?: string;
  InstanceType?: ClusterInstanceType;
  LaunchTime?: Date;
  LastSoftwareUpdateTime?: Date;
  InstanceStatus?: ClusterInstanceStatusDetails;
  UltraServerInfo?: UltraServerInfo;
  PrivateDnsHostname?: string;
}
export const ClusterNodeSummary = S.suspend(() =>
  S.Struct({
    InstanceGroupName: S.optional(S.String),
    InstanceId: S.optional(S.String),
    NodeLogicalId: S.optional(S.String),
    InstanceType: S.optional(ClusterInstanceType),
    LaunchTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastSoftwareUpdateTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    InstanceStatus: S.optional(ClusterInstanceStatusDetails),
    UltraServerInfo: S.optional(UltraServerInfo),
    PrivateDnsHostname: S.optional(S.String),
  }),
).annotate({
  identifier: "ClusterNodeSummary",
}) as any as S.Schema<ClusterNodeSummary>;
export type ClusterNodeSummaries = ClusterNodeSummary[];
export const ClusterNodeSummaries = S.Array(ClusterNodeSummary);
export interface ListClusterNodesResponse {
  NextToken?: string;
  ClusterNodeSummaries: (ClusterNodeSummary & {
    InstanceGroupName: ClusterInstanceGroupName;
    InstanceId: string;
    InstanceType: ClusterInstanceType;
    LaunchTime: Date;
    InstanceStatus: ClusterInstanceStatusDetails & {
      Status: ClusterInstanceStatus;
    };
  })[];
}
export const ListClusterNodesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    ClusterNodeSummaries: S.optional(ClusterNodeSummaries),
  }).pipe(ns),
).annotate({
  identifier: "ListClusterNodesResponse",
}) as any as S.Schema<ListClusterNodesResponse>;
export interface ListClustersRequest {
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  MaxResults?: number;
  NameContains?: string;
  NextToken?: string;
  SortBy?: ClusterSortBy;
  SortOrder?: SortOrder;
  TrainingPlanArn?: string;
}
export const ListClustersRequest = S.suspend(() =>
  S.Struct({
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    MaxResults: S.optional(S.Number),
    NameContains: S.optional(S.String),
    NextToken: S.optional(S.String),
    SortBy: S.optional(ClusterSortBy),
    SortOrder: S.optional(SortOrder),
    TrainingPlanArn: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListClustersRequest",
}) as any as S.Schema<ListClustersRequest>;
export type TrainingPlanArns = string[];
export const TrainingPlanArns = S.Array(S.String);
export interface ClusterSummary {
  ClusterArn?: string;
  ClusterName?: string;
  CreationTime?: Date;
  ClusterStatus?: ClusterStatus;
  TrainingPlanArns?: string[];
}
export const ClusterSummary = S.suspend(() =>
  S.Struct({
    ClusterArn: S.optional(S.String),
    ClusterName: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ClusterStatus: S.optional(ClusterStatus),
    TrainingPlanArns: S.optional(TrainingPlanArns),
  }),
).annotate({ identifier: "ClusterSummary" }) as any as S.Schema<ClusterSummary>;
export type ClusterSummaries = ClusterSummary[];
export const ClusterSummaries = S.Array(ClusterSummary);
export interface ListClustersResponse {
  NextToken?: string;
  ClusterSummaries: (ClusterSummary & {
    ClusterArn: ClusterArn;
    ClusterName: ClusterName;
    CreationTime: Date;
    ClusterStatus: ClusterStatus;
  })[];
}
export const ListClustersResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    ClusterSummaries: S.optional(ClusterSummaries),
  }).pipe(ns),
).annotate({
  identifier: "ListClustersResponse",
}) as any as S.Schema<ListClustersResponse>;
export type SortClusterSchedulerConfigBy =
  | "Name"
  | "CreationTime"
  | "Status"
  | (string & {});
export const SortClusterSchedulerConfigBy = S.String;
export interface ListClusterSchedulerConfigsRequest {
  CreatedAfter?: Date;
  CreatedBefore?: Date;
  NameContains?: string;
  ClusterArn?: string;
  Status?: SchedulerResourceStatus;
  SortBy?: SortClusterSchedulerConfigBy;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListClusterSchedulerConfigsRequest = S.suspend(() =>
  S.Struct({
    CreatedAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBefore: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    NameContains: S.optional(S.String),
    ClusterArn: S.optional(S.String),
    Status: S.optional(SchedulerResourceStatus),
    SortBy: S.optional(SortClusterSchedulerConfigBy),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListClusterSchedulerConfigsRequest",
}) as any as S.Schema<ListClusterSchedulerConfigsRequest>;
export interface ClusterSchedulerConfigSummary {
  ClusterSchedulerConfigArn?: string;
  ClusterSchedulerConfigId?: string;
  ClusterSchedulerConfigVersion?: number;
  Name?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  Status?: SchedulerResourceStatus;
  ClusterArn?: string;
}
export const ClusterSchedulerConfigSummary = S.suspend(() =>
  S.Struct({
    ClusterSchedulerConfigArn: S.optional(S.String),
    ClusterSchedulerConfigId: S.optional(S.String),
    ClusterSchedulerConfigVersion: S.optional(S.Number),
    Name: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    Status: S.optional(SchedulerResourceStatus),
    ClusterArn: S.optional(S.String),
  }),
).annotate({
  identifier: "ClusterSchedulerConfigSummary",
}) as any as S.Schema<ClusterSchedulerConfigSummary>;
export type ClusterSchedulerConfigSummaryList = ClusterSchedulerConfigSummary[];
export const ClusterSchedulerConfigSummaryList = S.Array(
  ClusterSchedulerConfigSummary,
);
export interface ListClusterSchedulerConfigsResponse {
  ClusterSchedulerConfigSummaries?: (ClusterSchedulerConfigSummary & {
    ClusterSchedulerConfigArn: ClusterSchedulerConfigArn;
    ClusterSchedulerConfigId: ClusterSchedulerConfigId;
    Name: EntityName;
    CreationTime: Date;
    Status: SchedulerResourceStatus;
  })[];
  NextToken?: string;
}
export const ListClusterSchedulerConfigsResponse = S.suspend(() =>
  S.Struct({
    ClusterSchedulerConfigSummaries: S.optional(
      ClusterSchedulerConfigSummaryList,
    ),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListClusterSchedulerConfigsResponse",
}) as any as S.Schema<ListClusterSchedulerConfigsResponse>;
export type CodeRepositorySortBy =
  | "Name"
  | "CreationTime"
  | "LastModifiedTime"
  | (string & {});
export const CodeRepositorySortBy = S.String;
export type CodeRepositorySortOrder =
  | "Ascending"
  | "Descending"
  | (string & {});
export const CodeRepositorySortOrder = S.String;
export interface ListCodeRepositoriesInput {
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  MaxResults?: number;
  NameContains?: string;
  NextToken?: string;
  SortBy?: CodeRepositorySortBy;
  SortOrder?: CodeRepositorySortOrder;
}
export const ListCodeRepositoriesInput = S.suspend(() =>
  S.Struct({
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    MaxResults: S.optional(S.Number),
    NameContains: S.optional(S.String),
    NextToken: S.optional(S.String),
    SortBy: S.optional(CodeRepositorySortBy),
    SortOrder: S.optional(CodeRepositorySortOrder),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListCodeRepositoriesInput",
}) as any as S.Schema<ListCodeRepositoriesInput>;
export interface CodeRepositorySummary {
  CodeRepositoryName?: string;
  CodeRepositoryArn?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  GitConfig?: GitConfig;
}
export const CodeRepositorySummary = S.suspend(() =>
  S.Struct({
    CodeRepositoryName: S.optional(S.String),
    CodeRepositoryArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    GitConfig: S.optional(GitConfig),
  }),
).annotate({
  identifier: "CodeRepositorySummary",
}) as any as S.Schema<CodeRepositorySummary>;
export type CodeRepositorySummaryList = CodeRepositorySummary[];
export const CodeRepositorySummaryList = S.Array(CodeRepositorySummary);
export interface ListCodeRepositoriesOutput {
  CodeRepositorySummaryList: (CodeRepositorySummary & {
    CodeRepositoryName: EntityName;
    CodeRepositoryArn: CodeRepositoryArn;
    CreationTime: CreationTime;
    LastModifiedTime: LastModifiedTime;
    GitConfig: GitConfig & { RepositoryUrl: GitConfigUrl };
  })[];
  NextToken?: string;
}
export const ListCodeRepositoriesOutput = S.suspend(() =>
  S.Struct({
    CodeRepositorySummaryList: S.optional(CodeRepositorySummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListCodeRepositoriesOutput",
}) as any as S.Schema<ListCodeRepositoriesOutput>;
export type ListCompilationJobsSortBy =
  | "Name"
  | "CreationTime"
  | "Status"
  | (string & {});
export const ListCompilationJobsSortBy = S.String;
export interface ListCompilationJobsRequest {
  NextToken?: string;
  MaxResults?: number;
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  NameContains?: string;
  StatusEquals?: CompilationJobStatus;
  SortBy?: ListCompilationJobsSortBy;
  SortOrder?: SortOrder;
}
export const ListCompilationJobsRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    NameContains: S.optional(S.String),
    StatusEquals: S.optional(CompilationJobStatus),
    SortBy: S.optional(ListCompilationJobsSortBy),
    SortOrder: S.optional(SortOrder),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListCompilationJobsRequest",
}) as any as S.Schema<ListCompilationJobsRequest>;
export interface CompilationJobSummary {
  CompilationJobName?: string;
  CompilationJobArn?: string;
  CreationTime?: Date;
  CompilationStartTime?: Date;
  CompilationEndTime?: Date;
  CompilationTargetDevice?: TargetDevice;
  CompilationTargetPlatformOs?: TargetPlatformOs;
  CompilationTargetPlatformArch?: TargetPlatformArch;
  CompilationTargetPlatformAccelerator?: TargetPlatformAccelerator;
  LastModifiedTime?: Date;
  CompilationJobStatus?: CompilationJobStatus;
}
export const CompilationJobSummary = S.suspend(() =>
  S.Struct({
    CompilationJobName: S.optional(S.String),
    CompilationJobArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CompilationStartTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CompilationEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CompilationTargetDevice: S.optional(TargetDevice),
    CompilationTargetPlatformOs: S.optional(TargetPlatformOs),
    CompilationTargetPlatformArch: S.optional(TargetPlatformArch),
    CompilationTargetPlatformAccelerator: S.optional(TargetPlatformAccelerator),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CompilationJobStatus: S.optional(CompilationJobStatus),
  }),
).annotate({
  identifier: "CompilationJobSummary",
}) as any as S.Schema<CompilationJobSummary>;
export type CompilationJobSummaries = CompilationJobSummary[];
export const CompilationJobSummaries = S.Array(CompilationJobSummary);
export interface ListCompilationJobsResponse {
  CompilationJobSummaries: (CompilationJobSummary & {
    CompilationJobName: EntityName;
    CompilationJobArn: CompilationJobArn;
    CreationTime: CreationTime;
    CompilationJobStatus: CompilationJobStatus;
  })[];
  NextToken?: string;
}
export const ListCompilationJobsResponse = S.suspend(() =>
  S.Struct({
    CompilationJobSummaries: S.optional(CompilationJobSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListCompilationJobsResponse",
}) as any as S.Schema<ListCompilationJobsResponse>;
export type SortQuotaBy =
  | "Name"
  | "CreationTime"
  | "Status"
  | "ClusterArn"
  | (string & {});
export const SortQuotaBy = S.String;
export interface ListComputeQuotasRequest {
  CreatedAfter?: Date;
  CreatedBefore?: Date;
  NameContains?: string;
  Status?: SchedulerResourceStatus;
  ClusterArn?: string;
  SortBy?: SortQuotaBy;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListComputeQuotasRequest = S.suspend(() =>
  S.Struct({
    CreatedAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBefore: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    NameContains: S.optional(S.String),
    Status: S.optional(SchedulerResourceStatus),
    ClusterArn: S.optional(S.String),
    SortBy: S.optional(SortQuotaBy),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListComputeQuotasRequest",
}) as any as S.Schema<ListComputeQuotasRequest>;
export interface ComputeQuotaSummary {
  ComputeQuotaArn?: string;
  ComputeQuotaId?: string;
  Name?: string;
  ComputeQuotaVersion?: number;
  Status?: SchedulerResourceStatus;
  ClusterArn?: string;
  ComputeQuotaConfig?: ComputeQuotaConfig;
  ComputeQuotaTarget?: ComputeQuotaTarget;
  ActivationState?: ActivationState;
  CreationTime?: Date;
  LastModifiedTime?: Date;
}
export const ComputeQuotaSummary = S.suspend(() =>
  S.Struct({
    ComputeQuotaArn: S.optional(S.String),
    ComputeQuotaId: S.optional(S.String),
    Name: S.optional(S.String),
    ComputeQuotaVersion: S.optional(S.Number),
    Status: S.optional(SchedulerResourceStatus),
    ClusterArn: S.optional(S.String),
    ComputeQuotaConfig: S.optional(ComputeQuotaConfig),
    ComputeQuotaTarget: S.optional(ComputeQuotaTarget),
    ActivationState: S.optional(ActivationState),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "ComputeQuotaSummary",
}) as any as S.Schema<ComputeQuotaSummary>;
export type ComputeQuotaSummaryList = ComputeQuotaSummary[];
export const ComputeQuotaSummaryList = S.Array(ComputeQuotaSummary);
export interface ListComputeQuotasResponse {
  ComputeQuotaSummaries?: (ComputeQuotaSummary & {
    ComputeQuotaArn: ComputeQuotaArn;
    ComputeQuotaId: ComputeQuotaId;
    Name: EntityName;
    Status: SchedulerResourceStatus;
    ComputeQuotaTarget: ComputeQuotaTarget & {
      TeamName: ComputeQuotaTargetTeamName;
    };
    CreationTime: Date;
    ComputeQuotaConfig: ComputeQuotaConfig & {
      ComputeQuotaResources: (ComputeQuotaResourceConfig & {
        InstanceType: ClusterInstanceType;
        AcceleratorPartition: AcceleratorPartitionConfig & {
          Type: MIGProfileType;
          Count: number;
        };
      })[];
      ResourceSharingConfig: ResourceSharingConfig & {
        Strategy: ResourceSharingStrategy;
      };
    };
  })[];
  NextToken?: string;
}
export const ListComputeQuotasResponse = S.suspend(() =>
  S.Struct({
    ComputeQuotaSummaries: S.optional(ComputeQuotaSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListComputeQuotasResponse",
}) as any as S.Schema<ListComputeQuotasResponse>;
export type SortContextsBy = "Name" | "CreationTime" | (string & {});
export const SortContextsBy = S.String;
export interface ListContextsRequest {
  SourceUri?: string;
  ContextType?: string;
  CreatedAfter?: Date;
  CreatedBefore?: Date;
  SortBy?: SortContextsBy;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListContextsRequest = S.suspend(() =>
  S.Struct({
    SourceUri: S.optional(S.String),
    ContextType: S.optional(S.String),
    CreatedAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBefore: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    SortBy: S.optional(SortContextsBy),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListContextsRequest",
}) as any as S.Schema<ListContextsRequest>;
export interface ContextSummary {
  ContextArn?: string;
  ContextName?: string;
  Source?: ContextSource;
  ContextType?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
}
export const ContextSummary = S.suspend(() =>
  S.Struct({
    ContextArn: S.optional(S.String),
    ContextName: S.optional(S.String),
    Source: S.optional(ContextSource),
    ContextType: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({ identifier: "ContextSummary" }) as any as S.Schema<ContextSummary>;
export type ContextSummaries = ContextSummary[];
export const ContextSummaries = S.Array(ContextSummary);
export interface ListContextsResponse {
  ContextSummaries?: (ContextSummary & {
    Source: ContextSource & { SourceUri: SourceUri };
  })[];
  NextToken?: string;
}
export const ListContextsResponse = S.suspend(() =>
  S.Struct({
    ContextSummaries: S.optional(ContextSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListContextsResponse",
}) as any as S.Schema<ListContextsResponse>;
export type MonitoringJobDefinitionSortKey =
  | "Name"
  | "CreationTime"
  | (string & {});
export const MonitoringJobDefinitionSortKey = S.String;
export interface ListDataQualityJobDefinitionsRequest {
  EndpointName?: string;
  SortBy?: MonitoringJobDefinitionSortKey;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
  NameContains?: string;
  CreationTimeBefore?: Date;
  CreationTimeAfter?: Date;
}
export const ListDataQualityJobDefinitionsRequest = S.suspend(() =>
  S.Struct({
    EndpointName: S.optional(S.String),
    SortBy: S.optional(MonitoringJobDefinitionSortKey),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NameContains: S.optional(S.String),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListDataQualityJobDefinitionsRequest",
}) as any as S.Schema<ListDataQualityJobDefinitionsRequest>;
export interface MonitoringJobDefinitionSummary {
  MonitoringJobDefinitionName?: string;
  MonitoringJobDefinitionArn?: string;
  CreationTime?: Date;
  EndpointName?: string;
}
export const MonitoringJobDefinitionSummary = S.suspend(() =>
  S.Struct({
    MonitoringJobDefinitionName: S.optional(S.String),
    MonitoringJobDefinitionArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndpointName: S.optional(S.String),
  }),
).annotate({
  identifier: "MonitoringJobDefinitionSummary",
}) as any as S.Schema<MonitoringJobDefinitionSummary>;
export type MonitoringJobDefinitionSummaryList =
  MonitoringJobDefinitionSummary[];
export const MonitoringJobDefinitionSummaryList = S.Array(
  MonitoringJobDefinitionSummary,
);
export interface ListDataQualityJobDefinitionsResponse {
  JobDefinitionSummaries: (MonitoringJobDefinitionSummary & {
    MonitoringJobDefinitionName: MonitoringJobDefinitionName;
    MonitoringJobDefinitionArn: MonitoringJobDefinitionArn;
    CreationTime: Date;
    EndpointName: EndpointName;
  })[];
  NextToken?: string;
}
export const ListDataQualityJobDefinitionsResponse = S.suspend(() =>
  S.Struct({
    JobDefinitionSummaries: S.optional(MonitoringJobDefinitionSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListDataQualityJobDefinitionsResponse",
}) as any as S.Schema<ListDataQualityJobDefinitionsResponse>;
export type ListDeviceFleetsSortBy =
  | "NAME"
  | "CREATION_TIME"
  | "LAST_MODIFIED_TIME"
  | (string & {});
export const ListDeviceFleetsSortBy = S.String;
export interface ListDeviceFleetsRequest {
  NextToken?: string;
  MaxResults?: number;
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  NameContains?: string;
  SortBy?: ListDeviceFleetsSortBy;
  SortOrder?: SortOrder;
}
export const ListDeviceFleetsRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    NameContains: S.optional(S.String),
    SortBy: S.optional(ListDeviceFleetsSortBy),
    SortOrder: S.optional(SortOrder),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListDeviceFleetsRequest",
}) as any as S.Schema<ListDeviceFleetsRequest>;
export interface DeviceFleetSummary {
  DeviceFleetArn?: string;
  DeviceFleetName?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
}
export const DeviceFleetSummary = S.suspend(() =>
  S.Struct({
    DeviceFleetArn: S.optional(S.String),
    DeviceFleetName: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "DeviceFleetSummary",
}) as any as S.Schema<DeviceFleetSummary>;
export type DeviceFleetSummaries = DeviceFleetSummary[];
export const DeviceFleetSummaries = S.Array(DeviceFleetSummary);
export interface ListDeviceFleetsResponse {
  DeviceFleetSummaries: (DeviceFleetSummary & {
    DeviceFleetArn: DeviceFleetArn;
    DeviceFleetName: EntityName;
  })[];
  NextToken?: string;
}
export const ListDeviceFleetsResponse = S.suspend(() =>
  S.Struct({
    DeviceFleetSummaries: S.optional(DeviceFleetSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListDeviceFleetsResponse",
}) as any as S.Schema<ListDeviceFleetsResponse>;
export interface ListDevicesRequest {
  NextToken?: string;
  MaxResults?: number;
  LatestHeartbeatAfter?: Date;
  ModelName?: string;
  DeviceFleetName?: string;
}
export const ListDevicesRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    LatestHeartbeatAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ModelName: S.optional(S.String),
    DeviceFleetName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListDevicesRequest",
}) as any as S.Schema<ListDevicesRequest>;
export interface EdgeModelSummary {
  ModelName?: string;
  ModelVersion?: string;
}
export const EdgeModelSummary = S.suspend(() =>
  S.Struct({
    ModelName: S.optional(S.String),
    ModelVersion: S.optional(S.String),
  }),
).annotate({
  identifier: "EdgeModelSummary",
}) as any as S.Schema<EdgeModelSummary>;
export type EdgeModelSummaries = EdgeModelSummary[];
export const EdgeModelSummaries = S.Array(EdgeModelSummary);
export interface DeviceSummary {
  DeviceName?: string;
  DeviceArn?: string;
  Description?: string;
  DeviceFleetName?: string;
  IotThingName?: string;
  RegistrationTime?: Date;
  LatestHeartbeat?: Date;
  Models?: EdgeModelSummary[];
  AgentVersion?: string;
}
export const DeviceSummary = S.suspend(() =>
  S.Struct({
    DeviceName: S.optional(S.String),
    DeviceArn: S.optional(S.String),
    Description: S.optional(S.String),
    DeviceFleetName: S.optional(S.String),
    IotThingName: S.optional(S.String),
    RegistrationTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LatestHeartbeat: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    Models: S.optional(EdgeModelSummaries),
    AgentVersion: S.optional(S.String),
  }),
).annotate({ identifier: "DeviceSummary" }) as any as S.Schema<DeviceSummary>;
export type DeviceSummaries = DeviceSummary[];
export const DeviceSummaries = S.Array(DeviceSummary);
export interface ListDevicesResponse {
  DeviceSummaries: (DeviceSummary & {
    DeviceName: EntityName;
    DeviceArn: DeviceArn;
    Models: (EdgeModelSummary & {
      ModelName: EntityName;
      ModelVersion: EdgeVersion;
    })[];
  })[];
  NextToken?: string;
}
export const ListDevicesResponse = S.suspend(() =>
  S.Struct({
    DeviceSummaries: S.optional(DeviceSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListDevicesResponse",
}) as any as S.Schema<ListDevicesResponse>;
export interface ListDomainsRequest {
  NextToken?: string;
  MaxResults?: number;
}
export const ListDomainsRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListDomainsRequest",
}) as any as S.Schema<ListDomainsRequest>;
export interface DomainDetails {
  DomainArn?: string;
  DomainId?: string;
  DomainName?: string;
  Status?: DomainStatus;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  Url?: string;
}
export const DomainDetails = S.suspend(() =>
  S.Struct({
    DomainArn: S.optional(S.String),
    DomainId: S.optional(S.String),
    DomainName: S.optional(S.String),
    Status: S.optional(DomainStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    Url: S.optional(S.String),
  }),
).annotate({ identifier: "DomainDetails" }) as any as S.Schema<DomainDetails>;
export type DomainList = DomainDetails[];
export const DomainList = S.Array(DomainDetails);
export interface ListDomainsResponse {
  Domains?: DomainDetails[];
  NextToken?: string;
}
export const ListDomainsResponse = S.suspend(() =>
  S.Struct({
    Domains: S.optional(DomainList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListDomainsResponse",
}) as any as S.Schema<ListDomainsResponse>;
export type ListEdgeDeploymentPlansSortBy =
  | "NAME"
  | "DEVICE_FLEET_NAME"
  | "CREATION_TIME"
  | "LAST_MODIFIED_TIME"
  | (string & {});
export const ListEdgeDeploymentPlansSortBy = S.String;
export interface ListEdgeDeploymentPlansRequest {
  NextToken?: string;
  MaxResults?: number;
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  NameContains?: string;
  DeviceFleetNameContains?: string;
  SortBy?: ListEdgeDeploymentPlansSortBy;
  SortOrder?: SortOrder;
}
export const ListEdgeDeploymentPlansRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    NameContains: S.optional(S.String),
    DeviceFleetNameContains: S.optional(S.String),
    SortBy: S.optional(ListEdgeDeploymentPlansSortBy),
    SortOrder: S.optional(SortOrder),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListEdgeDeploymentPlansRequest",
}) as any as S.Schema<ListEdgeDeploymentPlansRequest>;
export interface EdgeDeploymentPlanSummary {
  EdgeDeploymentPlanArn?: string;
  EdgeDeploymentPlanName?: string;
  DeviceFleetName?: string;
  EdgeDeploymentSuccess?: number;
  EdgeDeploymentPending?: number;
  EdgeDeploymentFailed?: number;
  CreationTime?: Date;
  LastModifiedTime?: Date;
}
export const EdgeDeploymentPlanSummary = S.suspend(() =>
  S.Struct({
    EdgeDeploymentPlanArn: S.optional(S.String),
    EdgeDeploymentPlanName: S.optional(S.String),
    DeviceFleetName: S.optional(S.String),
    EdgeDeploymentSuccess: S.optional(S.Number),
    EdgeDeploymentPending: S.optional(S.Number),
    EdgeDeploymentFailed: S.optional(S.Number),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "EdgeDeploymentPlanSummary",
}) as any as S.Schema<EdgeDeploymentPlanSummary>;
export type EdgeDeploymentPlanSummaries = EdgeDeploymentPlanSummary[];
export const EdgeDeploymentPlanSummaries = S.Array(EdgeDeploymentPlanSummary);
export interface ListEdgeDeploymentPlansResponse {
  EdgeDeploymentPlanSummaries: (EdgeDeploymentPlanSummary & {
    EdgeDeploymentPlanArn: EdgeDeploymentPlanArn;
    EdgeDeploymentPlanName: EntityName;
    DeviceFleetName: EntityName;
    EdgeDeploymentSuccess: number;
    EdgeDeploymentPending: number;
    EdgeDeploymentFailed: number;
  })[];
  NextToken?: string;
}
export const ListEdgeDeploymentPlansResponse = S.suspend(() =>
  S.Struct({
    EdgeDeploymentPlanSummaries: S.optional(EdgeDeploymentPlanSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListEdgeDeploymentPlansResponse",
}) as any as S.Schema<ListEdgeDeploymentPlansResponse>;
export type ListEdgePackagingJobsSortBy =
  | "NAME"
  | "MODEL_NAME"
  | "CREATION_TIME"
  | "LAST_MODIFIED_TIME"
  | "STATUS"
  | (string & {});
export const ListEdgePackagingJobsSortBy = S.String;
export interface ListEdgePackagingJobsRequest {
  NextToken?: string;
  MaxResults?: number;
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  NameContains?: string;
  ModelNameContains?: string;
  StatusEquals?: EdgePackagingJobStatus;
  SortBy?: ListEdgePackagingJobsSortBy;
  SortOrder?: SortOrder;
}
export const ListEdgePackagingJobsRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    NameContains: S.optional(S.String),
    ModelNameContains: S.optional(S.String),
    StatusEquals: S.optional(EdgePackagingJobStatus),
    SortBy: S.optional(ListEdgePackagingJobsSortBy),
    SortOrder: S.optional(SortOrder),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListEdgePackagingJobsRequest",
}) as any as S.Schema<ListEdgePackagingJobsRequest>;
export interface EdgePackagingJobSummary {
  EdgePackagingJobArn?: string;
  EdgePackagingJobName?: string;
  EdgePackagingJobStatus?: EdgePackagingJobStatus;
  CompilationJobName?: string;
  ModelName?: string;
  ModelVersion?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
}
export const EdgePackagingJobSummary = S.suspend(() =>
  S.Struct({
    EdgePackagingJobArn: S.optional(S.String),
    EdgePackagingJobName: S.optional(S.String),
    EdgePackagingJobStatus: S.optional(EdgePackagingJobStatus),
    CompilationJobName: S.optional(S.String),
    ModelName: S.optional(S.String),
    ModelVersion: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "EdgePackagingJobSummary",
}) as any as S.Schema<EdgePackagingJobSummary>;
export type EdgePackagingJobSummaries = EdgePackagingJobSummary[];
export const EdgePackagingJobSummaries = S.Array(EdgePackagingJobSummary);
export interface ListEdgePackagingJobsResponse {
  EdgePackagingJobSummaries: (EdgePackagingJobSummary & {
    EdgePackagingJobArn: EdgePackagingJobArn;
    EdgePackagingJobName: EntityName;
    EdgePackagingJobStatus: EdgePackagingJobStatus;
  })[];
  NextToken?: string;
}
export const ListEdgePackagingJobsResponse = S.suspend(() =>
  S.Struct({
    EdgePackagingJobSummaries: S.optional(EdgePackagingJobSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListEdgePackagingJobsResponse",
}) as any as S.Schema<ListEdgePackagingJobsResponse>;
export type EndpointConfigSortKey = "Name" | "CreationTime" | (string & {});
export const EndpointConfigSortKey = S.String;
export type OrderKey = "Ascending" | "Descending" | (string & {});
export const OrderKey = S.String;
export interface ListEndpointConfigsInput {
  SortBy?: EndpointConfigSortKey;
  SortOrder?: OrderKey;
  NextToken?: string;
  MaxResults?: number;
  NameContains?: string;
  CreationTimeBefore?: Date;
  CreationTimeAfter?: Date;
}
export const ListEndpointConfigsInput = S.suspend(() =>
  S.Struct({
    SortBy: S.optional(EndpointConfigSortKey),
    SortOrder: S.optional(OrderKey),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NameContains: S.optional(S.String),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListEndpointConfigsInput",
}) as any as S.Schema<ListEndpointConfigsInput>;
export interface EndpointConfigSummary {
  EndpointConfigName?: string;
  EndpointConfigArn?: string;
  CreationTime?: Date;
}
export const EndpointConfigSummary = S.suspend(() =>
  S.Struct({
    EndpointConfigName: S.optional(S.String),
    EndpointConfigArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotate({
  identifier: "EndpointConfigSummary",
}) as any as S.Schema<EndpointConfigSummary>;
export type EndpointConfigSummaryList = EndpointConfigSummary[];
export const EndpointConfigSummaryList = S.Array(EndpointConfigSummary);
export interface ListEndpointConfigsOutput {
  EndpointConfigs: (EndpointConfigSummary & {
    EndpointConfigName: EndpointConfigName;
    EndpointConfigArn: EndpointConfigArn;
    CreationTime: Date;
  })[];
  NextToken?: string;
}
export const ListEndpointConfigsOutput = S.suspend(() =>
  S.Struct({
    EndpointConfigs: S.optional(EndpointConfigSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListEndpointConfigsOutput",
}) as any as S.Schema<ListEndpointConfigsOutput>;
export type EndpointSortKey =
  | "Name"
  | "CreationTime"
  | "Status"
  | (string & {});
export const EndpointSortKey = S.String;
export interface ListEndpointsInput {
  SortBy?: EndpointSortKey;
  SortOrder?: OrderKey;
  NextToken?: string;
  MaxResults?: number;
  NameContains?: string;
  CreationTimeBefore?: Date;
  CreationTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  StatusEquals?: EndpointStatus;
}
export const ListEndpointsInput = S.suspend(() =>
  S.Struct({
    SortBy: S.optional(EndpointSortKey),
    SortOrder: S.optional(OrderKey),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NameContains: S.optional(S.String),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    StatusEquals: S.optional(EndpointStatus),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListEndpointsInput",
}) as any as S.Schema<ListEndpointsInput>;
export interface EndpointSummary {
  EndpointName?: string;
  EndpointArn?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  EndpointStatus?: EndpointStatus;
}
export const EndpointSummary = S.suspend(() =>
  S.Struct({
    EndpointName: S.optional(S.String),
    EndpointArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    EndpointStatus: S.optional(EndpointStatus),
  }),
).annotate({
  identifier: "EndpointSummary",
}) as any as S.Schema<EndpointSummary>;
export type EndpointSummaryList = EndpointSummary[];
export const EndpointSummaryList = S.Array(EndpointSummary);
export interface ListEndpointsOutput {
  Endpoints: (EndpointSummary & {
    EndpointName: EndpointName;
    EndpointArn: EndpointArn;
    CreationTime: Date;
    LastModifiedTime: Date;
    EndpointStatus: EndpointStatus;
  })[];
  NextToken?: string;
}
export const ListEndpointsOutput = S.suspend(() =>
  S.Struct({
    Endpoints: S.optional(EndpointSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListEndpointsOutput",
}) as any as S.Schema<ListEndpointsOutput>;
export type SortExperimentsBy = "Name" | "CreationTime" | (string & {});
export const SortExperimentsBy = S.String;
export interface ListExperimentsRequest {
  CreatedAfter?: Date;
  CreatedBefore?: Date;
  SortBy?: SortExperimentsBy;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListExperimentsRequest = S.suspend(() =>
  S.Struct({
    CreatedAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBefore: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    SortBy: S.optional(SortExperimentsBy),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListExperimentsRequest",
}) as any as S.Schema<ListExperimentsRequest>;
export interface ExperimentSummary {
  ExperimentArn?: string;
  ExperimentName?: string;
  DisplayName?: string;
  ExperimentSource?: ExperimentSource;
  CreationTime?: Date;
  LastModifiedTime?: Date;
}
export const ExperimentSummary = S.suspend(() =>
  S.Struct({
    ExperimentArn: S.optional(S.String),
    ExperimentName: S.optional(S.String),
    DisplayName: S.optional(S.String),
    ExperimentSource: S.optional(ExperimentSource),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "ExperimentSummary",
}) as any as S.Schema<ExperimentSummary>;
export type ExperimentSummaries = ExperimentSummary[];
export const ExperimentSummaries = S.Array(ExperimentSummary);
export interface ListExperimentsResponse {
  ExperimentSummaries?: (ExperimentSummary & {
    ExperimentSource: ExperimentSource & { SourceArn: ExperimentSourceArn };
  })[];
  NextToken?: string;
}
export const ListExperimentsResponse = S.suspend(() =>
  S.Struct({
    ExperimentSummaries: S.optional(ExperimentSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListExperimentsResponse",
}) as any as S.Schema<ListExperimentsResponse>;
export type FeatureGroupSortOrder = "Ascending" | "Descending" | (string & {});
export const FeatureGroupSortOrder = S.String;
export type FeatureGroupSortBy =
  | "Name"
  | "FeatureGroupStatus"
  | "OfflineStoreStatus"
  | "CreationTime"
  | (string & {});
export const FeatureGroupSortBy = S.String;
export interface ListFeatureGroupsRequest {
  NameContains?: string;
  FeatureGroupStatusEquals?: FeatureGroupStatus;
  OfflineStoreStatusEquals?: OfflineStoreStatusValue;
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  SortOrder?: FeatureGroupSortOrder;
  SortBy?: FeatureGroupSortBy;
  MaxResults?: number;
  NextToken?: string;
}
export const ListFeatureGroupsRequest = S.suspend(() =>
  S.Struct({
    NameContains: S.optional(S.String),
    FeatureGroupStatusEquals: S.optional(FeatureGroupStatus),
    OfflineStoreStatusEquals: S.optional(OfflineStoreStatusValue),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SortOrder: S.optional(FeatureGroupSortOrder),
    SortBy: S.optional(FeatureGroupSortBy),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListFeatureGroupsRequest",
}) as any as S.Schema<ListFeatureGroupsRequest>;
export interface FeatureGroupSummary {
  FeatureGroupName?: string;
  FeatureGroupArn?: string;
  CreationTime?: Date;
  FeatureGroupStatus?: FeatureGroupStatus;
  OfflineStoreStatus?: OfflineStoreStatus;
}
export const FeatureGroupSummary = S.suspend(() =>
  S.Struct({
    FeatureGroupName: S.optional(S.String),
    FeatureGroupArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    FeatureGroupStatus: S.optional(FeatureGroupStatus),
    OfflineStoreStatus: S.optional(OfflineStoreStatus),
  }),
).annotate({
  identifier: "FeatureGroupSummary",
}) as any as S.Schema<FeatureGroupSummary>;
export type FeatureGroupSummaries = FeatureGroupSummary[];
export const FeatureGroupSummaries = S.Array(FeatureGroupSummary);
export interface ListFeatureGroupsResponse {
  FeatureGroupSummaries: (FeatureGroupSummary & {
    FeatureGroupName: FeatureGroupName;
    FeatureGroupArn: FeatureGroupArn;
    CreationTime: Date;
    OfflineStoreStatus: OfflineStoreStatus & {
      Status: OfflineStoreStatusValue;
    };
  })[];
  NextToken?: string;
}
export const ListFeatureGroupsResponse = S.suspend(() =>
  S.Struct({
    FeatureGroupSummaries: S.optional(FeatureGroupSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListFeatureGroupsResponse",
}) as any as S.Schema<ListFeatureGroupsResponse>;
export interface ListFlowDefinitionsRequest {
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListFlowDefinitionsRequest = S.suspend(() =>
  S.Struct({
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListFlowDefinitionsRequest",
}) as any as S.Schema<ListFlowDefinitionsRequest>;
export interface FlowDefinitionSummary {
  FlowDefinitionName?: string;
  FlowDefinitionArn?: string;
  FlowDefinitionStatus?: FlowDefinitionStatus;
  CreationTime?: Date;
  FailureReason?: string;
}
export const FlowDefinitionSummary = S.suspend(() =>
  S.Struct({
    FlowDefinitionName: S.optional(S.String),
    FlowDefinitionArn: S.optional(S.String),
    FlowDefinitionStatus: S.optional(FlowDefinitionStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    FailureReason: S.optional(S.String),
  }),
).annotate({
  identifier: "FlowDefinitionSummary",
}) as any as S.Schema<FlowDefinitionSummary>;
export type FlowDefinitionSummaries = FlowDefinitionSummary[];
export const FlowDefinitionSummaries = S.Array(FlowDefinitionSummary);
export interface ListFlowDefinitionsResponse {
  FlowDefinitionSummaries: (FlowDefinitionSummary & {
    FlowDefinitionName: FlowDefinitionName;
    FlowDefinitionArn: FlowDefinitionArn;
    FlowDefinitionStatus: FlowDefinitionStatus;
    CreationTime: Date;
  })[];
  NextToken?: string;
}
export const ListFlowDefinitionsResponse = S.suspend(() =>
  S.Struct({
    FlowDefinitionSummaries: S.optional(FlowDefinitionSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListFlowDefinitionsResponse",
}) as any as S.Schema<ListFlowDefinitionsResponse>;
export type HubContentSortBy =
  | "HubContentName"
  | "CreationTime"
  | "HubContentStatus"
  | (string & {});
export const HubContentSortBy = S.String;
export interface ListHubContentsRequest {
  HubName?: string;
  HubContentType?: HubContentType;
  NameContains?: string;
  MaxSchemaVersion?: string;
  CreationTimeBefore?: Date;
  CreationTimeAfter?: Date;
  SortBy?: HubContentSortBy;
  SortOrder?: SortOrder;
  MaxResults?: number;
  NextToken?: string;
}
export const ListHubContentsRequest = S.suspend(() =>
  S.Struct({
    HubName: S.optional(S.String),
    HubContentType: S.optional(HubContentType),
    NameContains: S.optional(S.String),
    MaxSchemaVersion: S.optional(S.String),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SortBy: S.optional(HubContentSortBy),
    SortOrder: S.optional(SortOrder),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListHubContentsRequest",
}) as any as S.Schema<ListHubContentsRequest>;
export interface HubContentInfo {
  HubContentName?: string;
  HubContentArn?: string;
  SageMakerPublicHubContentArn?: string;
  HubContentVersion?: string;
  HubContentType?: HubContentType;
  DocumentSchemaVersion?: string;
  HubContentDisplayName?: string;
  HubContentDescription?: string;
  SupportStatus?: HubContentSupportStatus;
  HubContentSearchKeywords?: string[];
  HubContentStatus?: HubContentStatus;
  CreationTime?: Date;
  OriginalCreationTime?: Date;
}
export const HubContentInfo = S.suspend(() =>
  S.Struct({
    HubContentName: S.optional(S.String),
    HubContentArn: S.optional(S.String),
    SageMakerPublicHubContentArn: S.optional(S.String),
    HubContentVersion: S.optional(S.String),
    HubContentType: S.optional(HubContentType),
    DocumentSchemaVersion: S.optional(S.String),
    HubContentDisplayName: S.optional(S.String),
    HubContentDescription: S.optional(S.String),
    SupportStatus: S.optional(HubContentSupportStatus),
    HubContentSearchKeywords: S.optional(HubContentSearchKeywordList),
    HubContentStatus: S.optional(HubContentStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    OriginalCreationTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({ identifier: "HubContentInfo" }) as any as S.Schema<HubContentInfo>;
export type HubContentInfoList = HubContentInfo[];
export const HubContentInfoList = S.Array(HubContentInfo);
export interface ListHubContentsResponse {
  HubContentSummaries: (HubContentInfo & {
    HubContentName: HubContentName;
    HubContentArn: HubContentArn;
    HubContentVersion: HubContentVersion;
    HubContentType: HubContentType;
    DocumentSchemaVersion: DocumentSchemaVersion;
    HubContentStatus: HubContentStatus;
    CreationTime: Date;
  })[];
  NextToken?: string;
}
export const ListHubContentsResponse = S.suspend(() =>
  S.Struct({
    HubContentSummaries: S.optional(HubContentInfoList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListHubContentsResponse",
}) as any as S.Schema<ListHubContentsResponse>;
export interface ListHubContentVersionsRequest {
  HubName?: string;
  HubContentType?: HubContentType;
  HubContentName?: string;
  MinVersion?: string;
  MaxSchemaVersion?: string;
  CreationTimeBefore?: Date;
  CreationTimeAfter?: Date;
  SortBy?: HubContentSortBy;
  SortOrder?: SortOrder;
  MaxResults?: number;
  NextToken?: string;
}
export const ListHubContentVersionsRequest = S.suspend(() =>
  S.Struct({
    HubName: S.optional(S.String),
    HubContentType: S.optional(HubContentType),
    HubContentName: S.optional(S.String),
    MinVersion: S.optional(S.String),
    MaxSchemaVersion: S.optional(S.String),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SortBy: S.optional(HubContentSortBy),
    SortOrder: S.optional(SortOrder),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListHubContentVersionsRequest",
}) as any as S.Schema<ListHubContentVersionsRequest>;
export interface ListHubContentVersionsResponse {
  HubContentSummaries: (HubContentInfo & {
    HubContentName: HubContentName;
    HubContentArn: HubContentArn;
    HubContentVersion: HubContentVersion;
    HubContentType: HubContentType;
    DocumentSchemaVersion: DocumentSchemaVersion;
    HubContentStatus: HubContentStatus;
    CreationTime: Date;
  })[];
  NextToken?: string;
}
export const ListHubContentVersionsResponse = S.suspend(() =>
  S.Struct({
    HubContentSummaries: S.optional(HubContentInfoList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListHubContentVersionsResponse",
}) as any as S.Schema<ListHubContentVersionsResponse>;
export type HubSortBy =
  | "HubName"
  | "CreationTime"
  | "HubStatus"
  | "AccountIdOwner"
  | (string & {});
export const HubSortBy = S.String;
export interface ListHubsRequest {
  NameContains?: string;
  CreationTimeBefore?: Date;
  CreationTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  SortBy?: HubSortBy;
  SortOrder?: SortOrder;
  MaxResults?: number;
  NextToken?: string;
}
export const ListHubsRequest = S.suspend(() =>
  S.Struct({
    NameContains: S.optional(S.String),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SortBy: S.optional(HubSortBy),
    SortOrder: S.optional(SortOrder),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListHubsRequest",
}) as any as S.Schema<ListHubsRequest>;
export interface HubInfo {
  HubName?: string;
  HubArn?: string;
  HubDisplayName?: string;
  HubDescription?: string;
  HubSearchKeywords?: string[];
  HubStatus?: HubStatus;
  CreationTime?: Date;
  LastModifiedTime?: Date;
}
export const HubInfo = S.suspend(() =>
  S.Struct({
    HubName: S.optional(S.String),
    HubArn: S.optional(S.String),
    HubDisplayName: S.optional(S.String),
    HubDescription: S.optional(S.String),
    HubSearchKeywords: S.optional(HubSearchKeywordList),
    HubStatus: S.optional(HubStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({ identifier: "HubInfo" }) as any as S.Schema<HubInfo>;
export type HubInfoList = HubInfo[];
export const HubInfoList = S.Array(HubInfo);
export interface ListHubsResponse {
  HubSummaries: (HubInfo & {
    HubName: HubName;
    HubArn: HubArn;
    HubStatus: HubStatus;
    CreationTime: Date;
    LastModifiedTime: Date;
  })[];
  NextToken?: string;
}
export const ListHubsResponse = S.suspend(() =>
  S.Struct({
    HubSummaries: S.optional(HubInfoList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListHubsResponse",
}) as any as S.Schema<ListHubsResponse>;
export interface ListHumanTaskUisRequest {
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListHumanTaskUisRequest = S.suspend(() =>
  S.Struct({
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListHumanTaskUisRequest",
}) as any as S.Schema<ListHumanTaskUisRequest>;
export interface HumanTaskUiSummary {
  HumanTaskUiName?: string;
  HumanTaskUiArn?: string;
  CreationTime?: Date;
}
export const HumanTaskUiSummary = S.suspend(() =>
  S.Struct({
    HumanTaskUiName: S.optional(S.String),
    HumanTaskUiArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotate({
  identifier: "HumanTaskUiSummary",
}) as any as S.Schema<HumanTaskUiSummary>;
export type HumanTaskUiSummaries = HumanTaskUiSummary[];
export const HumanTaskUiSummaries = S.Array(HumanTaskUiSummary);
export interface ListHumanTaskUisResponse {
  HumanTaskUiSummaries: (HumanTaskUiSummary & {
    HumanTaskUiName: HumanTaskUiName;
    HumanTaskUiArn: HumanTaskUiArn;
    CreationTime: Date;
  })[];
  NextToken?: string;
}
export const ListHumanTaskUisResponse = S.suspend(() =>
  S.Struct({
    HumanTaskUiSummaries: S.optional(HumanTaskUiSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListHumanTaskUisResponse",
}) as any as S.Schema<ListHumanTaskUisResponse>;
export type HyperParameterTuningJobSortByOptions =
  | "Name"
  | "Status"
  | "CreationTime"
  | (string & {});
export const HyperParameterTuningJobSortByOptions = S.String;
export interface ListHyperParameterTuningJobsRequest {
  NextToken?: string;
  MaxResults?: number;
  SortBy?: HyperParameterTuningJobSortByOptions;
  SortOrder?: SortOrder;
  NameContains?: string;
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  StatusEquals?: HyperParameterTuningJobStatus;
}
export const ListHyperParameterTuningJobsRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SortBy: S.optional(HyperParameterTuningJobSortByOptions),
    SortOrder: S.optional(SortOrder),
    NameContains: S.optional(S.String),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    StatusEquals: S.optional(HyperParameterTuningJobStatus),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListHyperParameterTuningJobsRequest",
}) as any as S.Schema<ListHyperParameterTuningJobsRequest>;
export interface HyperParameterTuningJobSummary {
  HyperParameterTuningJobName?: string;
  HyperParameterTuningJobArn?: string;
  HyperParameterTuningJobStatus?: HyperParameterTuningJobStatus;
  Strategy?: HyperParameterTuningJobStrategyType;
  CreationTime?: Date;
  HyperParameterTuningEndTime?: Date;
  LastModifiedTime?: Date;
  TrainingJobStatusCounters?: TrainingJobStatusCounters;
  ObjectiveStatusCounters?: ObjectiveStatusCounters;
  ResourceLimits?: ResourceLimits;
}
export const HyperParameterTuningJobSummary = S.suspend(() =>
  S.Struct({
    HyperParameterTuningJobName: S.optional(S.String),
    HyperParameterTuningJobArn: S.optional(S.String),
    HyperParameterTuningJobStatus: S.optional(HyperParameterTuningJobStatus),
    Strategy: S.optional(HyperParameterTuningJobStrategyType),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    HyperParameterTuningEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    TrainingJobStatusCounters: S.optional(TrainingJobStatusCounters),
    ObjectiveStatusCounters: S.optional(ObjectiveStatusCounters),
    ResourceLimits: S.optional(ResourceLimits),
  }),
).annotate({
  identifier: "HyperParameterTuningJobSummary",
}) as any as S.Schema<HyperParameterTuningJobSummary>;
export type HyperParameterTuningJobSummaries = HyperParameterTuningJobSummary[];
export const HyperParameterTuningJobSummaries = S.Array(
  HyperParameterTuningJobSummary,
);
export interface ListHyperParameterTuningJobsResponse {
  HyperParameterTuningJobSummaries: (HyperParameterTuningJobSummary & {
    HyperParameterTuningJobName: HyperParameterTuningJobName;
    HyperParameterTuningJobArn: HyperParameterTuningJobArn;
    HyperParameterTuningJobStatus: HyperParameterTuningJobStatus;
    Strategy: HyperParameterTuningJobStrategyType;
    CreationTime: Date;
    TrainingJobStatusCounters: TrainingJobStatusCounters;
    ObjectiveStatusCounters: ObjectiveStatusCounters;
    ResourceLimits: ResourceLimits & {
      MaxParallelTrainingJobs: MaxParallelTrainingJobs;
    };
  })[];
  NextToken?: string;
}
export const ListHyperParameterTuningJobsResponse = S.suspend(() =>
  S.Struct({
    HyperParameterTuningJobSummaries: S.optional(
      HyperParameterTuningJobSummaries,
    ),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListHyperParameterTuningJobsResponse",
}) as any as S.Schema<ListHyperParameterTuningJobsResponse>;
export type ImageSortBy =
  | "CREATION_TIME"
  | "LAST_MODIFIED_TIME"
  | "IMAGE_NAME"
  | (string & {});
export const ImageSortBy = S.String;
export type ImageSortOrder = "ASCENDING" | "DESCENDING" | (string & {});
export const ImageSortOrder = S.String;
export interface ListImagesRequest {
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  MaxResults?: number;
  NameContains?: string;
  NextToken?: string;
  SortBy?: ImageSortBy;
  SortOrder?: ImageSortOrder;
}
export const ListImagesRequest = S.suspend(() =>
  S.Struct({
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    MaxResults: S.optional(S.Number),
    NameContains: S.optional(S.String),
    NextToken: S.optional(S.String),
    SortBy: S.optional(ImageSortBy),
    SortOrder: S.optional(ImageSortOrder),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListImagesRequest",
}) as any as S.Schema<ListImagesRequest>;
export interface Image {
  CreationTime?: Date;
  Description?: string;
  DisplayName?: string;
  FailureReason?: string;
  ImageArn?: string;
  ImageName?: string;
  ImageStatus?: ImageStatus;
  LastModifiedTime?: Date;
}
export const Image = S.suspend(() =>
  S.Struct({
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Description: S.optional(S.String),
    DisplayName: S.optional(S.String),
    FailureReason: S.optional(S.String),
    ImageArn: S.optional(S.String),
    ImageName: S.optional(S.String),
    ImageStatus: S.optional(ImageStatus),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({ identifier: "Image" }) as any as S.Schema<Image>;
export type Images = Image[];
export const Images = S.Array(Image);
export interface ListImagesResponse {
  Images?: (Image & {
    CreationTime: Date;
    ImageArn: ImageArn;
    ImageName: ImageName;
    ImageStatus: ImageStatus;
    LastModifiedTime: Date;
  })[];
  NextToken?: string;
}
export const ListImagesResponse = S.suspend(() =>
  S.Struct({
    Images: S.optional(Images),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListImagesResponse",
}) as any as S.Schema<ListImagesResponse>;
export type ImageVersionSortBy =
  | "CREATION_TIME"
  | "LAST_MODIFIED_TIME"
  | "VERSION"
  | (string & {});
export const ImageVersionSortBy = S.String;
export type ImageVersionSortOrder = "ASCENDING" | "DESCENDING" | (string & {});
export const ImageVersionSortOrder = S.String;
export interface ListImageVersionsRequest {
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  ImageName?: string;
  LastModifiedTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  MaxResults?: number;
  NextToken?: string;
  SortBy?: ImageVersionSortBy;
  SortOrder?: ImageVersionSortOrder;
}
export const ListImageVersionsRequest = S.suspend(() =>
  S.Struct({
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ImageName: S.optional(S.String),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    SortBy: S.optional(ImageVersionSortBy),
    SortOrder: S.optional(ImageVersionSortOrder),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListImageVersionsRequest",
}) as any as S.Schema<ListImageVersionsRequest>;
export interface ImageVersion {
  CreationTime?: Date;
  FailureReason?: string;
  ImageArn?: string;
  ImageVersionArn?: string;
  ImageVersionStatus?: ImageVersionStatus;
  LastModifiedTime?: Date;
  Version?: number;
}
export const ImageVersion = S.suspend(() =>
  S.Struct({
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    FailureReason: S.optional(S.String),
    ImageArn: S.optional(S.String),
    ImageVersionArn: S.optional(S.String),
    ImageVersionStatus: S.optional(ImageVersionStatus),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    Version: S.optional(S.Number),
  }),
).annotate({ identifier: "ImageVersion" }) as any as S.Schema<ImageVersion>;
export type ImageVersions = ImageVersion[];
export const ImageVersions = S.Array(ImageVersion);
export interface ListImageVersionsResponse {
  ImageVersions?: (ImageVersion & {
    CreationTime: Date;
    ImageArn: ImageArn;
    ImageVersionArn: ImageVersionArn;
    ImageVersionStatus: ImageVersionStatus;
    LastModifiedTime: Date;
    Version: ImageVersionNumber;
  })[];
  NextToken?: string;
}
export const ListImageVersionsResponse = S.suspend(() =>
  S.Struct({
    ImageVersions: S.optional(ImageVersions),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListImageVersionsResponse",
}) as any as S.Schema<ListImageVersionsResponse>;
export type InferenceComponentSortKey =
  | "Name"
  | "CreationTime"
  | "Status"
  | (string & {});
export const InferenceComponentSortKey = S.String;
export interface ListInferenceComponentsInput {
  SortBy?: InferenceComponentSortKey;
  SortOrder?: OrderKey;
  NextToken?: string;
  MaxResults?: number;
  NameContains?: string;
  CreationTimeBefore?: Date;
  CreationTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  StatusEquals?: InferenceComponentStatus;
  EndpointNameEquals?: string;
  VariantNameEquals?: string;
}
export const ListInferenceComponentsInput = S.suspend(() =>
  S.Struct({
    SortBy: S.optional(InferenceComponentSortKey),
    SortOrder: S.optional(OrderKey),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NameContains: S.optional(S.String),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    StatusEquals: S.optional(InferenceComponentStatus),
    EndpointNameEquals: S.optional(S.String),
    VariantNameEquals: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListInferenceComponentsInput",
}) as any as S.Schema<ListInferenceComponentsInput>;
export interface InferenceComponentSummary {
  CreationTime?: Date;
  InferenceComponentArn?: string;
  InferenceComponentName?: string;
  EndpointArn?: string;
  EndpointName?: string;
  VariantName?: string;
  InferenceComponentStatus?: InferenceComponentStatus;
  LastModifiedTime?: Date;
}
export const InferenceComponentSummary = S.suspend(() =>
  S.Struct({
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    InferenceComponentArn: S.optional(S.String),
    InferenceComponentName: S.optional(S.String),
    EndpointArn: S.optional(S.String),
    EndpointName: S.optional(S.String),
    VariantName: S.optional(S.String),
    InferenceComponentStatus: S.optional(InferenceComponentStatus),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "InferenceComponentSummary",
}) as any as S.Schema<InferenceComponentSummary>;
export type InferenceComponentSummaryList = InferenceComponentSummary[];
export const InferenceComponentSummaryList = S.Array(InferenceComponentSummary);
export interface ListInferenceComponentsOutput {
  InferenceComponents: (InferenceComponentSummary & {
    CreationTime: Date;
    InferenceComponentArn: InferenceComponentArn;
    InferenceComponentName: InferenceComponentName;
    EndpointArn: EndpointArn;
    EndpointName: EndpointName;
    VariantName: VariantName;
    LastModifiedTime: Date;
  })[];
  NextToken?: string;
}
export const ListInferenceComponentsOutput = S.suspend(() =>
  S.Struct({
    InferenceComponents: S.optional(InferenceComponentSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListInferenceComponentsOutput",
}) as any as S.Schema<ListInferenceComponentsOutput>;
export type SortInferenceExperimentsBy =
  | "Name"
  | "CreationTime"
  | "Status"
  | (string & {});
export const SortInferenceExperimentsBy = S.String;
export interface ListInferenceExperimentsRequest {
  NameContains?: string;
  Type?: InferenceExperimentType;
  StatusEquals?: InferenceExperimentStatus;
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  SortBy?: SortInferenceExperimentsBy;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListInferenceExperimentsRequest = S.suspend(() =>
  S.Struct({
    NameContains: S.optional(S.String),
    Type: S.optional(InferenceExperimentType),
    StatusEquals: S.optional(InferenceExperimentStatus),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SortBy: S.optional(SortInferenceExperimentsBy),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListInferenceExperimentsRequest",
}) as any as S.Schema<ListInferenceExperimentsRequest>;
export interface InferenceExperimentSummary {
  Name?: string;
  Type?: InferenceExperimentType;
  Schedule?: InferenceExperimentSchedule;
  Status?: InferenceExperimentStatus;
  StatusReason?: string;
  Description?: string;
  CreationTime?: Date;
  CompletionTime?: Date;
  LastModifiedTime?: Date;
  RoleArn?: string;
}
export const InferenceExperimentSummary = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Type: S.optional(InferenceExperimentType),
    Schedule: S.optional(InferenceExperimentSchedule),
    Status: S.optional(InferenceExperimentStatus),
    StatusReason: S.optional(S.String),
    Description: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CompletionTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    RoleArn: S.optional(S.String),
  }),
).annotate({
  identifier: "InferenceExperimentSummary",
}) as any as S.Schema<InferenceExperimentSummary>;
export type InferenceExperimentList = InferenceExperimentSummary[];
export const InferenceExperimentList = S.Array(InferenceExperimentSummary);
export interface ListInferenceExperimentsResponse {
  InferenceExperiments?: (InferenceExperimentSummary & {
    Name: InferenceExperimentName;
    Type: InferenceExperimentType;
    Status: InferenceExperimentStatus;
    CreationTime: Date;
    LastModifiedTime: Date;
  })[];
  NextToken?: string;
}
export const ListInferenceExperimentsResponse = S.suspend(() =>
  S.Struct({
    InferenceExperiments: S.optional(InferenceExperimentList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListInferenceExperimentsResponse",
}) as any as S.Schema<ListInferenceExperimentsResponse>;
export type ListInferenceRecommendationsJobsSortBy =
  | "Name"
  | "CreationTime"
  | "Status"
  | (string & {});
export const ListInferenceRecommendationsJobsSortBy = S.String;
export interface ListInferenceRecommendationsJobsRequest {
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  NameContains?: string;
  StatusEquals?: RecommendationJobStatus;
  SortBy?: ListInferenceRecommendationsJobsSortBy;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
  ModelNameEquals?: string;
  ModelPackageVersionArnEquals?: string;
}
export const ListInferenceRecommendationsJobsRequest = S.suspend(() =>
  S.Struct({
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    NameContains: S.optional(S.String),
    StatusEquals: S.optional(RecommendationJobStatus),
    SortBy: S.optional(ListInferenceRecommendationsJobsSortBy),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    ModelNameEquals: S.optional(S.String),
    ModelPackageVersionArnEquals: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListInferenceRecommendationsJobsRequest",
}) as any as S.Schema<ListInferenceRecommendationsJobsRequest>;
export interface InferenceRecommendationsJob {
  JobName?: string;
  JobDescription?: string;
  JobType?: RecommendationJobType;
  JobArn?: string;
  Status?: RecommendationJobStatus;
  CreationTime?: Date;
  CompletionTime?: Date;
  RoleArn?: string;
  LastModifiedTime?: Date;
  FailureReason?: string;
  ModelName?: string;
  SamplePayloadUrl?: string;
  ModelPackageVersionArn?: string;
}
export const InferenceRecommendationsJob = S.suspend(() =>
  S.Struct({
    JobName: S.optional(S.String),
    JobDescription: S.optional(S.String),
    JobType: S.optional(RecommendationJobType),
    JobArn: S.optional(S.String),
    Status: S.optional(RecommendationJobStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CompletionTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    RoleArn: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    FailureReason: S.optional(S.String),
    ModelName: S.optional(S.String),
    SamplePayloadUrl: S.optional(S.String),
    ModelPackageVersionArn: S.optional(S.String),
  }),
).annotate({
  identifier: "InferenceRecommendationsJob",
}) as any as S.Schema<InferenceRecommendationsJob>;
export type InferenceRecommendationsJobs = InferenceRecommendationsJob[];
export const InferenceRecommendationsJobs = S.Array(
  InferenceRecommendationsJob,
);
export interface ListInferenceRecommendationsJobsResponse {
  InferenceRecommendationsJobs: (InferenceRecommendationsJob & {
    JobName: RecommendationJobName;
    JobDescription: RecommendationJobDescription;
    JobType: RecommendationJobType;
    JobArn: RecommendationJobArn;
    Status: RecommendationJobStatus;
    CreationTime: CreationTime;
    RoleArn: RoleArn;
    LastModifiedTime: LastModifiedTime;
  })[];
  NextToken?: string;
}
export const ListInferenceRecommendationsJobsResponse = S.suspend(() =>
  S.Struct({
    InferenceRecommendationsJobs: S.optional(InferenceRecommendationsJobs),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListInferenceRecommendationsJobsResponse",
}) as any as S.Schema<ListInferenceRecommendationsJobsResponse>;
export type RecommendationStepType = "BENCHMARK" | (string & {});
export const RecommendationStepType = S.String;
export interface ListInferenceRecommendationsJobStepsRequest {
  JobName?: string;
  Status?: RecommendationJobStatus;
  StepType?: RecommendationStepType;
  MaxResults?: number;
  NextToken?: string;
}
export const ListInferenceRecommendationsJobStepsRequest = S.suspend(() =>
  S.Struct({
    JobName: S.optional(S.String),
    Status: S.optional(RecommendationJobStatus),
    StepType: S.optional(RecommendationStepType),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListInferenceRecommendationsJobStepsRequest",
}) as any as S.Schema<ListInferenceRecommendationsJobStepsRequest>;
export interface RecommendationJobInferenceBenchmark {
  Metrics?: RecommendationMetrics;
  EndpointMetrics?: InferenceMetrics;
  EndpointConfiguration?: EndpointOutputConfiguration;
  ModelConfiguration?: ModelConfiguration;
  FailureReason?: string;
  InvocationEndTime?: Date;
  InvocationStartTime?: Date;
}
export const RecommendationJobInferenceBenchmark = S.suspend(() =>
  S.Struct({
    Metrics: S.optional(RecommendationMetrics),
    EndpointMetrics: S.optional(InferenceMetrics),
    EndpointConfiguration: S.optional(EndpointOutputConfiguration),
    ModelConfiguration: S.optional(ModelConfiguration),
    FailureReason: S.optional(S.String),
    InvocationEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    InvocationStartTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "RecommendationJobInferenceBenchmark",
}) as any as S.Schema<RecommendationJobInferenceBenchmark>;
export interface InferenceRecommendationsJobStep {
  StepType?: RecommendationStepType;
  JobName?: string;
  Status?: RecommendationJobStatus;
  InferenceBenchmark?: RecommendationJobInferenceBenchmark;
}
export const InferenceRecommendationsJobStep = S.suspend(() =>
  S.Struct({
    StepType: S.optional(RecommendationStepType),
    JobName: S.optional(S.String),
    Status: S.optional(RecommendationJobStatus),
    InferenceBenchmark: S.optional(RecommendationJobInferenceBenchmark),
  }),
).annotate({
  identifier: "InferenceRecommendationsJobStep",
}) as any as S.Schema<InferenceRecommendationsJobStep>;
export type InferenceRecommendationsJobSteps =
  InferenceRecommendationsJobStep[];
export const InferenceRecommendationsJobSteps = S.Array(
  InferenceRecommendationsJobStep,
);
export interface ListInferenceRecommendationsJobStepsResponse {
  Steps?: (InferenceRecommendationsJobStep & {
    StepType: RecommendationStepType;
    JobName: RecommendationJobName;
    Status: RecommendationJobStatus;
    InferenceBenchmark: RecommendationJobInferenceBenchmark & {
      ModelConfiguration: ModelConfiguration & {
        EnvironmentParameters: (EnvironmentParameter & {
          Key: string;
          ValueType: string;
          Value: string;
        })[];
      };
      EndpointMetrics: InferenceMetrics & {
        MaxInvocations: number;
        ModelLatency: number;
      };
      EndpointConfiguration: EndpointOutputConfiguration & {
        EndpointName: string;
        VariantName: string;
        ServerlessConfig: ProductionVariantServerlessConfig & {
          MemorySizeInMB: ServerlessMemorySizeInMB;
          MaxConcurrency: ServerlessMaxConcurrency;
        };
      };
    };
  })[];
  NextToken?: string;
}
export const ListInferenceRecommendationsJobStepsResponse = S.suspend(() =>
  S.Struct({
    Steps: S.optional(InferenceRecommendationsJobSteps),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListInferenceRecommendationsJobStepsResponse",
}) as any as S.Schema<ListInferenceRecommendationsJobStepsResponse>;
export type SortBy = "Name" | "CreationTime" | "Status" | (string & {});
export const SortBy = S.String;
export interface ListLabelingJobsRequest {
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  MaxResults?: number;
  NextToken?: string;
  NameContains?: string;
  SortBy?: SortBy;
  SortOrder?: SortOrder;
  StatusEquals?: LabelingJobStatus;
}
export const ListLabelingJobsRequest = S.suspend(() =>
  S.Struct({
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    NameContains: S.optional(S.String),
    SortBy: S.optional(SortBy),
    SortOrder: S.optional(SortOrder),
    StatusEquals: S.optional(LabelingJobStatus),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListLabelingJobsRequest",
}) as any as S.Schema<ListLabelingJobsRequest>;
export interface LabelingJobSummary {
  LabelingJobName?: string;
  LabelingJobArn?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  LabelingJobStatus?: LabelingJobStatus;
  LabelCounters?: LabelCounters;
  WorkteamArn?: string;
  PreHumanTaskLambdaArn?: string;
  AnnotationConsolidationLambdaArn?: string;
  FailureReason?: string;
  LabelingJobOutput?: LabelingJobOutput;
  InputConfig?: LabelingJobInputConfig;
}
export const LabelingJobSummary = S.suspend(() =>
  S.Struct({
    LabelingJobName: S.optional(S.String),
    LabelingJobArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LabelingJobStatus: S.optional(LabelingJobStatus),
    LabelCounters: S.optional(LabelCounters),
    WorkteamArn: S.optional(S.String),
    PreHumanTaskLambdaArn: S.optional(S.String),
    AnnotationConsolidationLambdaArn: S.optional(S.String),
    FailureReason: S.optional(S.String),
    LabelingJobOutput: S.optional(LabelingJobOutput),
    InputConfig: S.optional(LabelingJobInputConfig),
  }),
).annotate({
  identifier: "LabelingJobSummary",
}) as any as S.Schema<LabelingJobSummary>;
export type LabelingJobSummaryList = LabelingJobSummary[];
export const LabelingJobSummaryList = S.Array(LabelingJobSummary);
export interface ListLabelingJobsResponse {
  LabelingJobSummaryList?: (LabelingJobSummary & {
    LabelingJobName: LabelingJobName;
    LabelingJobArn: LabelingJobArn;
    CreationTime: Date;
    LastModifiedTime: Date;
    LabelingJobStatus: LabelingJobStatus;
    LabelCounters: LabelCounters;
    WorkteamArn: WorkteamArn;
    LabelingJobOutput: LabelingJobOutput & { OutputDatasetS3Uri: S3Uri };
    InputConfig: LabelingJobInputConfig & {
      DataSource: LabelingJobDataSource & {
        S3DataSource: LabelingJobS3DataSource & { ManifestS3Uri: S3Uri };
        SnsDataSource: LabelingJobSnsDataSource & { SnsTopicArn: SnsTopicArn };
      };
    };
  })[];
  NextToken?: string;
}
export const ListLabelingJobsResponse = S.suspend(() =>
  S.Struct({
    LabelingJobSummaryList: S.optional(LabelingJobSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListLabelingJobsResponse",
}) as any as S.Schema<ListLabelingJobsResponse>;
export type ListLabelingJobsForWorkteamSortByOptions =
  | "CreationTime"
  | (string & {});
export const ListLabelingJobsForWorkteamSortByOptions = S.String;
export interface ListLabelingJobsForWorkteamRequest {
  WorkteamArn?: string;
  MaxResults?: number;
  NextToken?: string;
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  JobReferenceCodeContains?: string;
  SortBy?: ListLabelingJobsForWorkteamSortByOptions;
  SortOrder?: SortOrder;
}
export const ListLabelingJobsForWorkteamRequest = S.suspend(() =>
  S.Struct({
    WorkteamArn: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    JobReferenceCodeContains: S.optional(S.String),
    SortBy: S.optional(ListLabelingJobsForWorkteamSortByOptions),
    SortOrder: S.optional(SortOrder),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListLabelingJobsForWorkteamRequest",
}) as any as S.Schema<ListLabelingJobsForWorkteamRequest>;
export interface LabelCountersForWorkteam {
  HumanLabeled?: number;
  PendingHuman?: number;
  Total?: number;
}
export const LabelCountersForWorkteam = S.suspend(() =>
  S.Struct({
    HumanLabeled: S.optional(S.Number),
    PendingHuman: S.optional(S.Number),
    Total: S.optional(S.Number),
  }),
).annotate({
  identifier: "LabelCountersForWorkteam",
}) as any as S.Schema<LabelCountersForWorkteam>;
export interface LabelingJobForWorkteamSummary {
  LabelingJobName?: string;
  JobReferenceCode?: string;
  WorkRequesterAccountId?: string;
  CreationTime?: Date;
  LabelCounters?: LabelCountersForWorkteam;
  NumberOfHumanWorkersPerDataObject?: number;
}
export const LabelingJobForWorkteamSummary = S.suspend(() =>
  S.Struct({
    LabelingJobName: S.optional(S.String),
    JobReferenceCode: S.optional(S.String),
    WorkRequesterAccountId: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LabelCounters: S.optional(LabelCountersForWorkteam),
    NumberOfHumanWorkersPerDataObject: S.optional(S.Number),
  }),
).annotate({
  identifier: "LabelingJobForWorkteamSummary",
}) as any as S.Schema<LabelingJobForWorkteamSummary>;
export type LabelingJobForWorkteamSummaryList = LabelingJobForWorkteamSummary[];
export const LabelingJobForWorkteamSummaryList = S.Array(
  LabelingJobForWorkteamSummary,
);
export interface ListLabelingJobsForWorkteamResponse {
  LabelingJobSummaryList: (LabelingJobForWorkteamSummary & {
    JobReferenceCode: JobReferenceCode;
    WorkRequesterAccountId: AccountId;
    CreationTime: Date;
  })[];
  NextToken?: string;
}
export const ListLabelingJobsForWorkteamResponse = S.suspend(() =>
  S.Struct({
    LabelingJobSummaryList: S.optional(LabelingJobForWorkteamSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListLabelingJobsForWorkteamResponse",
}) as any as S.Schema<ListLabelingJobsForWorkteamResponse>;
export type SortLineageGroupsBy = "Name" | "CreationTime" | (string & {});
export const SortLineageGroupsBy = S.String;
export interface ListLineageGroupsRequest {
  CreatedAfter?: Date;
  CreatedBefore?: Date;
  SortBy?: SortLineageGroupsBy;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListLineageGroupsRequest = S.suspend(() =>
  S.Struct({
    CreatedAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBefore: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    SortBy: S.optional(SortLineageGroupsBy),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListLineageGroupsRequest",
}) as any as S.Schema<ListLineageGroupsRequest>;
export interface LineageGroupSummary {
  LineageGroupArn?: string;
  LineageGroupName?: string;
  DisplayName?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
}
export const LineageGroupSummary = S.suspend(() =>
  S.Struct({
    LineageGroupArn: S.optional(S.String),
    LineageGroupName: S.optional(S.String),
    DisplayName: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "LineageGroupSummary",
}) as any as S.Schema<LineageGroupSummary>;
export type LineageGroupSummaries = LineageGroupSummary[];
export const LineageGroupSummaries = S.Array(LineageGroupSummary);
export interface ListLineageGroupsResponse {
  LineageGroupSummaries?: LineageGroupSummary[];
  NextToken?: string;
}
export const ListLineageGroupsResponse = S.suspend(() =>
  S.Struct({
    LineageGroupSummaries: S.optional(LineageGroupSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListLineageGroupsResponse",
}) as any as S.Schema<ListLineageGroupsResponse>;
export type SortMlflowAppBy =
  | "Name"
  | "CreationTime"
  | "Status"
  | (string & {});
export const SortMlflowAppBy = S.String;
export interface ListMlflowAppsRequest {
  CreatedAfter?: Date;
  CreatedBefore?: Date;
  Status?: MlflowAppStatus;
  MlflowVersion?: string;
  DefaultForDomainId?: string;
  AccountDefaultStatus?: AccountDefaultStatus;
  SortBy?: SortMlflowAppBy;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListMlflowAppsRequest = S.suspend(() =>
  S.Struct({
    CreatedAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBefore: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Status: S.optional(MlflowAppStatus),
    MlflowVersion: S.optional(S.String),
    DefaultForDomainId: S.optional(S.String),
    AccountDefaultStatus: S.optional(AccountDefaultStatus),
    SortBy: S.optional(SortMlflowAppBy),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListMlflowAppsRequest",
}) as any as S.Schema<ListMlflowAppsRequest>;
export interface MlflowAppSummary {
  Arn?: string;
  Name?: string;
  Status?: MlflowAppStatus;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  MlflowVersion?: string;
}
export const MlflowAppSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    Status: S.optional(MlflowAppStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    MlflowVersion: S.optional(S.String),
  }),
).annotate({
  identifier: "MlflowAppSummary",
}) as any as S.Schema<MlflowAppSummary>;
export type MlflowAppSummaries = MlflowAppSummary[];
export const MlflowAppSummaries = S.Array(MlflowAppSummary);
export interface ListMlflowAppsResponse {
  Summaries?: MlflowAppSummary[];
  NextToken?: string;
}
export const ListMlflowAppsResponse = S.suspend(() =>
  S.Struct({
    Summaries: S.optional(MlflowAppSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListMlflowAppsResponse",
}) as any as S.Schema<ListMlflowAppsResponse>;
export type SortTrackingServerBy =
  | "Name"
  | "CreationTime"
  | "Status"
  | (string & {});
export const SortTrackingServerBy = S.String;
export interface ListMlflowTrackingServersRequest {
  CreatedAfter?: Date;
  CreatedBefore?: Date;
  TrackingServerStatus?: TrackingServerStatus;
  MlflowVersion?: string;
  SortBy?: SortTrackingServerBy;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListMlflowTrackingServersRequest = S.suspend(() =>
  S.Struct({
    CreatedAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBefore: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    TrackingServerStatus: S.optional(TrackingServerStatus),
    MlflowVersion: S.optional(S.String),
    SortBy: S.optional(SortTrackingServerBy),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListMlflowTrackingServersRequest",
}) as any as S.Schema<ListMlflowTrackingServersRequest>;
export interface TrackingServerSummary {
  TrackingServerArn?: string;
  TrackingServerName?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  TrackingServerStatus?: TrackingServerStatus;
  IsActive?: IsTrackingServerActive;
  MlflowVersion?: string;
}
export const TrackingServerSummary = S.suspend(() =>
  S.Struct({
    TrackingServerArn: S.optional(S.String),
    TrackingServerName: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    TrackingServerStatus: S.optional(TrackingServerStatus),
    IsActive: S.optional(IsTrackingServerActive),
    MlflowVersion: S.optional(S.String),
  }),
).annotate({
  identifier: "TrackingServerSummary",
}) as any as S.Schema<TrackingServerSummary>;
export type TrackingServerSummaryList = TrackingServerSummary[];
export const TrackingServerSummaryList = S.Array(TrackingServerSummary);
export interface ListMlflowTrackingServersResponse {
  TrackingServerSummaries?: TrackingServerSummary[];
  NextToken?: string;
}
export const ListMlflowTrackingServersResponse = S.suspend(() =>
  S.Struct({
    TrackingServerSummaries: S.optional(TrackingServerSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListMlflowTrackingServersResponse",
}) as any as S.Schema<ListMlflowTrackingServersResponse>;
export interface ListModelBiasJobDefinitionsRequest {
  EndpointName?: string;
  SortBy?: MonitoringJobDefinitionSortKey;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
  NameContains?: string;
  CreationTimeBefore?: Date;
  CreationTimeAfter?: Date;
}
export const ListModelBiasJobDefinitionsRequest = S.suspend(() =>
  S.Struct({
    EndpointName: S.optional(S.String),
    SortBy: S.optional(MonitoringJobDefinitionSortKey),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NameContains: S.optional(S.String),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListModelBiasJobDefinitionsRequest",
}) as any as S.Schema<ListModelBiasJobDefinitionsRequest>;
export interface ListModelBiasJobDefinitionsResponse {
  JobDefinitionSummaries: (MonitoringJobDefinitionSummary & {
    MonitoringJobDefinitionName: MonitoringJobDefinitionName;
    MonitoringJobDefinitionArn: MonitoringJobDefinitionArn;
    CreationTime: Date;
    EndpointName: EndpointName;
  })[];
  NextToken?: string;
}
export const ListModelBiasJobDefinitionsResponse = S.suspend(() =>
  S.Struct({
    JobDefinitionSummaries: S.optional(MonitoringJobDefinitionSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListModelBiasJobDefinitionsResponse",
}) as any as S.Schema<ListModelBiasJobDefinitionsResponse>;
export type ModelCardExportJobSortBy =
  | "Name"
  | "CreationTime"
  | "Status"
  | (string & {});
export const ModelCardExportJobSortBy = S.String;
export type ModelCardExportJobSortOrder =
  | "Ascending"
  | "Descending"
  | (string & {});
export const ModelCardExportJobSortOrder = S.String;
export interface ListModelCardExportJobsRequest {
  ModelCardName?: string;
  ModelCardVersion?: number;
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  ModelCardExportJobNameContains?: string;
  StatusEquals?: ModelCardExportJobStatus;
  SortBy?: ModelCardExportJobSortBy;
  SortOrder?: ModelCardExportJobSortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListModelCardExportJobsRequest = S.suspend(() =>
  S.Struct({
    ModelCardName: S.optional(S.String),
    ModelCardVersion: S.optional(S.Number),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ModelCardExportJobNameContains: S.optional(S.String),
    StatusEquals: S.optional(ModelCardExportJobStatus),
    SortBy: S.optional(ModelCardExportJobSortBy),
    SortOrder: S.optional(ModelCardExportJobSortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListModelCardExportJobsRequest",
}) as any as S.Schema<ListModelCardExportJobsRequest>;
export interface ModelCardExportJobSummary {
  ModelCardExportJobName?: string;
  ModelCardExportJobArn?: string;
  Status?: ModelCardExportJobStatus;
  ModelCardName?: string;
  ModelCardVersion?: number;
  CreatedAt?: Date;
  LastModifiedAt?: Date;
}
export const ModelCardExportJobSummary = S.suspend(() =>
  S.Struct({
    ModelCardExportJobName: S.optional(S.String),
    ModelCardExportJobArn: S.optional(S.String),
    Status: S.optional(ModelCardExportJobStatus),
    ModelCardName: S.optional(S.String),
    ModelCardVersion: S.optional(S.Number),
    CreatedAt: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedAt: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotate({
  identifier: "ModelCardExportJobSummary",
}) as any as S.Schema<ModelCardExportJobSummary>;
export type ModelCardExportJobSummaryList = ModelCardExportJobSummary[];
export const ModelCardExportJobSummaryList = S.Array(ModelCardExportJobSummary);
export interface ListModelCardExportJobsResponse {
  ModelCardExportJobSummaries: (ModelCardExportJobSummary & {
    ModelCardExportJobName: EntityName;
    ModelCardExportJobArn: ModelCardExportJobArn;
    Status: ModelCardExportJobStatus;
    ModelCardName: EntityName;
    ModelCardVersion: number;
    CreatedAt: Date;
    LastModifiedAt: Date;
  })[];
  NextToken?: string;
}
export const ListModelCardExportJobsResponse = S.suspend(() =>
  S.Struct({
    ModelCardExportJobSummaries: S.optional(ModelCardExportJobSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListModelCardExportJobsResponse",
}) as any as S.Schema<ListModelCardExportJobsResponse>;
export type ModelCardSortBy = "Name" | "CreationTime" | (string & {});
export const ModelCardSortBy = S.String;
export type ModelCardSortOrder = "Ascending" | "Descending" | (string & {});
export const ModelCardSortOrder = S.String;
export interface ListModelCardsRequest {
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  MaxResults?: number;
  NameContains?: string;
  ModelCardStatus?: ModelCardStatus;
  NextToken?: string;
  SortBy?: ModelCardSortBy;
  SortOrder?: ModelCardSortOrder;
}
export const ListModelCardsRequest = S.suspend(() =>
  S.Struct({
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    MaxResults: S.optional(S.Number),
    NameContains: S.optional(S.String),
    ModelCardStatus: S.optional(ModelCardStatus),
    NextToken: S.optional(S.String),
    SortBy: S.optional(ModelCardSortBy),
    SortOrder: S.optional(ModelCardSortOrder),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListModelCardsRequest",
}) as any as S.Schema<ListModelCardsRequest>;
export interface ModelCardSummary {
  ModelCardName?: string;
  ModelCardArn?: string;
  ModelCardStatus?: ModelCardStatus;
  CreationTime?: Date;
  LastModifiedTime?: Date;
}
export const ModelCardSummary = S.suspend(() =>
  S.Struct({
    ModelCardName: S.optional(S.String),
    ModelCardArn: S.optional(S.String),
    ModelCardStatus: S.optional(ModelCardStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "ModelCardSummary",
}) as any as S.Schema<ModelCardSummary>;
export type ModelCardSummaryList = ModelCardSummary[];
export const ModelCardSummaryList = S.Array(ModelCardSummary);
export interface ListModelCardsResponse {
  ModelCardSummaries: (ModelCardSummary & {
    ModelCardName: EntityName;
    ModelCardArn: ModelCardArn;
    ModelCardStatus: ModelCardStatus;
    CreationTime: Date;
  })[];
  NextToken?: string;
}
export const ListModelCardsResponse = S.suspend(() =>
  S.Struct({
    ModelCardSummaries: S.optional(ModelCardSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListModelCardsResponse",
}) as any as S.Schema<ListModelCardsResponse>;
export type ModelCardVersionSortBy = "Version" | (string & {});
export const ModelCardVersionSortBy = S.String;
export interface ListModelCardVersionsRequest {
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  MaxResults?: number;
  ModelCardName?: string;
  ModelCardStatus?: ModelCardStatus;
  NextToken?: string;
  SortBy?: ModelCardVersionSortBy;
  SortOrder?: ModelCardSortOrder;
}
export const ListModelCardVersionsRequest = S.suspend(() =>
  S.Struct({
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    MaxResults: S.optional(S.Number),
    ModelCardName: S.optional(S.String),
    ModelCardStatus: S.optional(ModelCardStatus),
    NextToken: S.optional(S.String),
    SortBy: S.optional(ModelCardVersionSortBy),
    SortOrder: S.optional(ModelCardSortOrder),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListModelCardVersionsRequest",
}) as any as S.Schema<ListModelCardVersionsRequest>;
export interface ModelCardVersionSummary {
  ModelCardName?: string;
  ModelCardArn?: string;
  ModelCardStatus?: ModelCardStatus;
  ModelCardVersion?: number;
  CreationTime?: Date;
  LastModifiedTime?: Date;
}
export const ModelCardVersionSummary = S.suspend(() =>
  S.Struct({
    ModelCardName: S.optional(S.String),
    ModelCardArn: S.optional(S.String),
    ModelCardStatus: S.optional(ModelCardStatus),
    ModelCardVersion: S.optional(S.Number),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "ModelCardVersionSummary",
}) as any as S.Schema<ModelCardVersionSummary>;
export type ModelCardVersionSummaryList = ModelCardVersionSummary[];
export const ModelCardVersionSummaryList = S.Array(ModelCardVersionSummary);
export interface ListModelCardVersionsResponse {
  ModelCardVersionSummaryList: (ModelCardVersionSummary & {
    ModelCardName: EntityName;
    ModelCardArn: ModelCardArn;
    ModelCardStatus: ModelCardStatus;
    ModelCardVersion: number;
    CreationTime: Date;
  })[];
  NextToken?: string;
}
export const ListModelCardVersionsResponse = S.suspend(() =>
  S.Struct({
    ModelCardVersionSummaryList: S.optional(ModelCardVersionSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListModelCardVersionsResponse",
}) as any as S.Schema<ListModelCardVersionsResponse>;
export interface ListModelExplainabilityJobDefinitionsRequest {
  EndpointName?: string;
  SortBy?: MonitoringJobDefinitionSortKey;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
  NameContains?: string;
  CreationTimeBefore?: Date;
  CreationTimeAfter?: Date;
}
export const ListModelExplainabilityJobDefinitionsRequest = S.suspend(() =>
  S.Struct({
    EndpointName: S.optional(S.String),
    SortBy: S.optional(MonitoringJobDefinitionSortKey),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NameContains: S.optional(S.String),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListModelExplainabilityJobDefinitionsRequest",
}) as any as S.Schema<ListModelExplainabilityJobDefinitionsRequest>;
export interface ListModelExplainabilityJobDefinitionsResponse {
  JobDefinitionSummaries: (MonitoringJobDefinitionSummary & {
    MonitoringJobDefinitionName: MonitoringJobDefinitionName;
    MonitoringJobDefinitionArn: MonitoringJobDefinitionArn;
    CreationTime: Date;
    EndpointName: EndpointName;
  })[];
  NextToken?: string;
}
export const ListModelExplainabilityJobDefinitionsResponse = S.suspend(() =>
  S.Struct({
    JobDefinitionSummaries: S.optional(MonitoringJobDefinitionSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListModelExplainabilityJobDefinitionsResponse",
}) as any as S.Schema<ListModelExplainabilityJobDefinitionsResponse>;
export type ModelMetadataFilterType =
  | "Domain"
  | "Framework"
  | "Task"
  | "FrameworkVersion"
  | (string & {});
export const ModelMetadataFilterType = S.String;
export interface ModelMetadataFilter {
  Name?: ModelMetadataFilterType;
  Value?: string;
}
export const ModelMetadataFilter = S.suspend(() =>
  S.Struct({
    Name: S.optional(ModelMetadataFilterType),
    Value: S.optional(S.String),
  }),
).annotate({
  identifier: "ModelMetadataFilter",
}) as any as S.Schema<ModelMetadataFilter>;
export type ModelMetadataFilters = ModelMetadataFilter[];
export const ModelMetadataFilters = S.Array(ModelMetadataFilter);
export interface ModelMetadataSearchExpression {
  Filters?: ModelMetadataFilter[];
}
export const ModelMetadataSearchExpression = S.suspend(() =>
  S.Struct({ Filters: S.optional(ModelMetadataFilters) }),
).annotate({
  identifier: "ModelMetadataSearchExpression",
}) as any as S.Schema<ModelMetadataSearchExpression>;
export interface ListModelMetadataRequest {
  SearchExpression?: ModelMetadataSearchExpression;
  NextToken?: string;
  MaxResults?: number;
}
export const ListModelMetadataRequest = S.suspend(() =>
  S.Struct({
    SearchExpression: S.optional(ModelMetadataSearchExpression),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListModelMetadataRequest",
}) as any as S.Schema<ListModelMetadataRequest>;
export interface ModelMetadataSummary {
  Domain?: string;
  Framework?: string;
  Task?: string;
  Model?: string;
  FrameworkVersion?: string;
}
export const ModelMetadataSummary = S.suspend(() =>
  S.Struct({
    Domain: S.optional(S.String),
    Framework: S.optional(S.String),
    Task: S.optional(S.String),
    Model: S.optional(S.String),
    FrameworkVersion: S.optional(S.String),
  }),
).annotate({
  identifier: "ModelMetadataSummary",
}) as any as S.Schema<ModelMetadataSummary>;
export type ModelMetadataSummaries = ModelMetadataSummary[];
export const ModelMetadataSummaries = S.Array(ModelMetadataSummary);
export interface ListModelMetadataResponse {
  ModelMetadataSummaries: (ModelMetadataSummary & {
    Domain: string;
    Framework: string;
    Task: string;
    Model: string;
    FrameworkVersion: string;
  })[];
  NextToken?: string;
}
export const ListModelMetadataResponse = S.suspend(() =>
  S.Struct({
    ModelMetadataSummaries: S.optional(ModelMetadataSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListModelMetadataResponse",
}) as any as S.Schema<ListModelMetadataResponse>;
export type ModelPackageGroupSortBy = "Name" | "CreationTime" | (string & {});
export const ModelPackageGroupSortBy = S.String;
export type CrossAccountFilterOption =
  | "SameAccount"
  | "CrossAccount"
  | (string & {});
export const CrossAccountFilterOption = S.String;
export interface ListModelPackageGroupsInput {
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  MaxResults?: number;
  NameContains?: string;
  NextToken?: string;
  SortBy?: ModelPackageGroupSortBy;
  SortOrder?: SortOrder;
  CrossAccountFilterOption?: CrossAccountFilterOption;
}
export const ListModelPackageGroupsInput = S.suspend(() =>
  S.Struct({
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    MaxResults: S.optional(S.Number),
    NameContains: S.optional(S.String),
    NextToken: S.optional(S.String),
    SortBy: S.optional(ModelPackageGroupSortBy),
    SortOrder: S.optional(SortOrder),
    CrossAccountFilterOption: S.optional(CrossAccountFilterOption),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListModelPackageGroupsInput",
}) as any as S.Schema<ListModelPackageGroupsInput>;
export interface ModelPackageGroupSummary {
  ModelPackageGroupName?: string;
  ModelPackageGroupArn?: string;
  ModelPackageGroupDescription?: string;
  CreationTime?: Date;
  ModelPackageGroupStatus?: ModelPackageGroupStatus;
}
export const ModelPackageGroupSummary = S.suspend(() =>
  S.Struct({
    ModelPackageGroupName: S.optional(S.String),
    ModelPackageGroupArn: S.optional(S.String),
    ModelPackageGroupDescription: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ModelPackageGroupStatus: S.optional(ModelPackageGroupStatus),
  }),
).annotate({
  identifier: "ModelPackageGroupSummary",
}) as any as S.Schema<ModelPackageGroupSummary>;
export type ModelPackageGroupSummaryList = ModelPackageGroupSummary[];
export const ModelPackageGroupSummaryList = S.Array(ModelPackageGroupSummary);
export interface ListModelPackageGroupsOutput {
  ModelPackageGroupSummaryList: (ModelPackageGroupSummary & {
    ModelPackageGroupName: EntityName;
    ModelPackageGroupArn: ModelPackageGroupArn;
    CreationTime: CreationTime;
    ModelPackageGroupStatus: ModelPackageGroupStatus;
  })[];
  NextToken?: string;
}
export const ListModelPackageGroupsOutput = S.suspend(() =>
  S.Struct({
    ModelPackageGroupSummaryList: S.optional(ModelPackageGroupSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListModelPackageGroupsOutput",
}) as any as S.Schema<ListModelPackageGroupsOutput>;
export type ModelPackageType =
  | "Versioned"
  | "Unversioned"
  | "Both"
  | (string & {});
export const ModelPackageType = S.String;
export type ModelPackageSortBy = "Name" | "CreationTime" | (string & {});
export const ModelPackageSortBy = S.String;
export interface ListModelPackagesInput {
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  MaxResults?: number;
  NameContains?: string;
  ModelApprovalStatus?: ModelApprovalStatus;
  ModelPackageGroupName?: string;
  ModelPackageType?: ModelPackageType;
  NextToken?: string;
  SortBy?: ModelPackageSortBy;
  SortOrder?: SortOrder;
}
export const ListModelPackagesInput = S.suspend(() =>
  S.Struct({
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    MaxResults: S.optional(S.Number),
    NameContains: S.optional(S.String),
    ModelApprovalStatus: S.optional(ModelApprovalStatus),
    ModelPackageGroupName: S.optional(S.String),
    ModelPackageType: S.optional(ModelPackageType),
    NextToken: S.optional(S.String),
    SortBy: S.optional(ModelPackageSortBy),
    SortOrder: S.optional(SortOrder),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListModelPackagesInput",
}) as any as S.Schema<ListModelPackagesInput>;
export interface ModelPackageSummary {
  ModelPackageName?: string;
  ModelPackageGroupName?: string;
  ModelPackageVersion?: number;
  ModelPackageArn?: string;
  ModelPackageDescription?: string;
  CreationTime?: Date;
  ModelPackageStatus?: ModelPackageStatus;
  ModelApprovalStatus?: ModelApprovalStatus;
  ModelLifeCycle?: ModelLifeCycle;
  ModelPackageRegistrationType?: ModelPackageRegistrationType;
}
export const ModelPackageSummary = S.suspend(() =>
  S.Struct({
    ModelPackageName: S.optional(S.String),
    ModelPackageGroupName: S.optional(S.String),
    ModelPackageVersion: S.optional(S.Number),
    ModelPackageArn: S.optional(S.String),
    ModelPackageDescription: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ModelPackageStatus: S.optional(ModelPackageStatus),
    ModelApprovalStatus: S.optional(ModelApprovalStatus),
    ModelLifeCycle: S.optional(ModelLifeCycle),
    ModelPackageRegistrationType: S.optional(ModelPackageRegistrationType),
  }),
).annotate({
  identifier: "ModelPackageSummary",
}) as any as S.Schema<ModelPackageSummary>;
export type ModelPackageSummaryList = ModelPackageSummary[];
export const ModelPackageSummaryList = S.Array(ModelPackageSummary);
export interface ListModelPackagesOutput {
  ModelPackageSummaryList: (ModelPackageSummary & {
    ModelPackageArn: ModelPackageArn;
    CreationTime: CreationTime;
    ModelPackageStatus: ModelPackageStatus;
    ModelLifeCycle: ModelLifeCycle & {
      Stage: EntityName;
      StageStatus: EntityName;
    };
  })[];
  NextToken?: string;
}
export const ListModelPackagesOutput = S.suspend(() =>
  S.Struct({
    ModelPackageSummaryList: S.optional(ModelPackageSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListModelPackagesOutput",
}) as any as S.Schema<ListModelPackagesOutput>;
export interface ListModelQualityJobDefinitionsRequest {
  EndpointName?: string;
  SortBy?: MonitoringJobDefinitionSortKey;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
  NameContains?: string;
  CreationTimeBefore?: Date;
  CreationTimeAfter?: Date;
}
export const ListModelQualityJobDefinitionsRequest = S.suspend(() =>
  S.Struct({
    EndpointName: S.optional(S.String),
    SortBy: S.optional(MonitoringJobDefinitionSortKey),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NameContains: S.optional(S.String),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListModelQualityJobDefinitionsRequest",
}) as any as S.Schema<ListModelQualityJobDefinitionsRequest>;
export interface ListModelQualityJobDefinitionsResponse {
  JobDefinitionSummaries: (MonitoringJobDefinitionSummary & {
    MonitoringJobDefinitionName: MonitoringJobDefinitionName;
    MonitoringJobDefinitionArn: MonitoringJobDefinitionArn;
    CreationTime: Date;
    EndpointName: EndpointName;
  })[];
  NextToken?: string;
}
export const ListModelQualityJobDefinitionsResponse = S.suspend(() =>
  S.Struct({
    JobDefinitionSummaries: S.optional(MonitoringJobDefinitionSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListModelQualityJobDefinitionsResponse",
}) as any as S.Schema<ListModelQualityJobDefinitionsResponse>;
export type ModelSortKey = "Name" | "CreationTime" | (string & {});
export const ModelSortKey = S.String;
export interface ListModelsInput {
  SortBy?: ModelSortKey;
  SortOrder?: OrderKey;
  NextToken?: string;
  MaxResults?: number;
  NameContains?: string;
  CreationTimeBefore?: Date;
  CreationTimeAfter?: Date;
}
export const ListModelsInput = S.suspend(() =>
  S.Struct({
    SortBy: S.optional(ModelSortKey),
    SortOrder: S.optional(OrderKey),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NameContains: S.optional(S.String),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListModelsInput",
}) as any as S.Schema<ListModelsInput>;
export interface ModelSummary {
  ModelName?: string;
  ModelArn?: string;
  CreationTime?: Date;
}
export const ModelSummary = S.suspend(() =>
  S.Struct({
    ModelName: S.optional(S.String),
    ModelArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotate({ identifier: "ModelSummary" }) as any as S.Schema<ModelSummary>;
export type ModelSummaryList = ModelSummary[];
export const ModelSummaryList = S.Array(ModelSummary);
export interface ListModelsOutput {
  Models: (ModelSummary & {
    ModelName: ModelName;
    ModelArn: ModelArn;
    CreationTime: Date;
  })[];
  NextToken?: string;
}
export const ListModelsOutput = S.suspend(() =>
  S.Struct({
    Models: S.optional(ModelSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListModelsOutput",
}) as any as S.Schema<ListModelsOutput>;
export type MonitoringAlertHistorySortKey =
  | "CreationTime"
  | "Status"
  | (string & {});
export const MonitoringAlertHistorySortKey = S.String;
export type MonitoringAlertStatus = "InAlert" | "OK" | (string & {});
export const MonitoringAlertStatus = S.String;
export interface ListMonitoringAlertHistoryRequest {
  MonitoringScheduleName?: string;
  MonitoringAlertName?: string;
  SortBy?: MonitoringAlertHistorySortKey;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
  CreationTimeBefore?: Date;
  CreationTimeAfter?: Date;
  StatusEquals?: MonitoringAlertStatus;
}
export const ListMonitoringAlertHistoryRequest = S.suspend(() =>
  S.Struct({
    MonitoringScheduleName: S.optional(S.String),
    MonitoringAlertName: S.optional(S.String),
    SortBy: S.optional(MonitoringAlertHistorySortKey),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    StatusEquals: S.optional(MonitoringAlertStatus),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListMonitoringAlertHistoryRequest",
}) as any as S.Schema<ListMonitoringAlertHistoryRequest>;
export interface MonitoringAlertHistorySummary {
  MonitoringScheduleName?: string;
  MonitoringAlertName?: string;
  CreationTime?: Date;
  AlertStatus?: MonitoringAlertStatus;
}
export const MonitoringAlertHistorySummary = S.suspend(() =>
  S.Struct({
    MonitoringScheduleName: S.optional(S.String),
    MonitoringAlertName: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    AlertStatus: S.optional(MonitoringAlertStatus),
  }),
).annotate({
  identifier: "MonitoringAlertHistorySummary",
}) as any as S.Schema<MonitoringAlertHistorySummary>;
export type MonitoringAlertHistoryList = MonitoringAlertHistorySummary[];
export const MonitoringAlertHistoryList = S.Array(
  MonitoringAlertHistorySummary,
);
export interface ListMonitoringAlertHistoryResponse {
  MonitoringAlertHistory?: (MonitoringAlertHistorySummary & {
    MonitoringScheduleName: MonitoringScheduleName;
    MonitoringAlertName: MonitoringAlertName;
    CreationTime: Date;
    AlertStatus: MonitoringAlertStatus;
  })[];
  NextToken?: string;
}
export const ListMonitoringAlertHistoryResponse = S.suspend(() =>
  S.Struct({
    MonitoringAlertHistory: S.optional(MonitoringAlertHistoryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListMonitoringAlertHistoryResponse",
}) as any as S.Schema<ListMonitoringAlertHistoryResponse>;
export interface ListMonitoringAlertsRequest {
  MonitoringScheduleName?: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListMonitoringAlertsRequest = S.suspend(() =>
  S.Struct({
    MonitoringScheduleName: S.optional(S.String),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListMonitoringAlertsRequest",
}) as any as S.Schema<ListMonitoringAlertsRequest>;
export interface ModelDashboardIndicatorAction {
  Enabled?: boolean;
}
export const ModelDashboardIndicatorAction = S.suspend(() =>
  S.Struct({ Enabled: S.optional(S.Boolean) }),
).annotate({
  identifier: "ModelDashboardIndicatorAction",
}) as any as S.Schema<ModelDashboardIndicatorAction>;
export interface MonitoringAlertActions {
  ModelDashboardIndicator?: ModelDashboardIndicatorAction;
}
export const MonitoringAlertActions = S.suspend(() =>
  S.Struct({
    ModelDashboardIndicator: S.optional(ModelDashboardIndicatorAction),
  }),
).annotate({
  identifier: "MonitoringAlertActions",
}) as any as S.Schema<MonitoringAlertActions>;
export interface MonitoringAlertSummary {
  MonitoringAlertName?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  AlertStatus?: MonitoringAlertStatus;
  DatapointsToAlert?: number;
  EvaluationPeriod?: number;
  Actions?: MonitoringAlertActions;
}
export const MonitoringAlertSummary = S.suspend(() =>
  S.Struct({
    MonitoringAlertName: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    AlertStatus: S.optional(MonitoringAlertStatus),
    DatapointsToAlert: S.optional(S.Number),
    EvaluationPeriod: S.optional(S.Number),
    Actions: S.optional(MonitoringAlertActions),
  }),
).annotate({
  identifier: "MonitoringAlertSummary",
}) as any as S.Schema<MonitoringAlertSummary>;
export type MonitoringAlertSummaryList = MonitoringAlertSummary[];
export const MonitoringAlertSummaryList = S.Array(MonitoringAlertSummary);
export interface ListMonitoringAlertsResponse {
  MonitoringAlertSummaries?: (MonitoringAlertSummary & {
    MonitoringAlertName: MonitoringAlertName;
    CreationTime: Date;
    LastModifiedTime: Date;
    AlertStatus: MonitoringAlertStatus;
    DatapointsToAlert: MonitoringDatapointsToAlert;
    EvaluationPeriod: MonitoringEvaluationPeriod;
    Actions: MonitoringAlertActions;
  })[];
  NextToken?: string;
}
export const ListMonitoringAlertsResponse = S.suspend(() =>
  S.Struct({
    MonitoringAlertSummaries: S.optional(MonitoringAlertSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListMonitoringAlertsResponse",
}) as any as S.Schema<ListMonitoringAlertsResponse>;
export type MonitoringExecutionSortKey =
  | "CreationTime"
  | "ScheduledTime"
  | "Status"
  | (string & {});
export const MonitoringExecutionSortKey = S.String;
export interface ListMonitoringExecutionsRequest {
  MonitoringScheduleName?: string;
  EndpointName?: string;
  SortBy?: MonitoringExecutionSortKey;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
  ScheduledTimeBefore?: Date;
  ScheduledTimeAfter?: Date;
  CreationTimeBefore?: Date;
  CreationTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  StatusEquals?: ExecutionStatus;
  MonitoringJobDefinitionName?: string;
  MonitoringTypeEquals?: MonitoringType;
}
export const ListMonitoringExecutionsRequest = S.suspend(() =>
  S.Struct({
    MonitoringScheduleName: S.optional(S.String),
    EndpointName: S.optional(S.String),
    SortBy: S.optional(MonitoringExecutionSortKey),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    ScheduledTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ScheduledTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    StatusEquals: S.optional(ExecutionStatus),
    MonitoringJobDefinitionName: S.optional(S.String),
    MonitoringTypeEquals: S.optional(MonitoringType),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListMonitoringExecutionsRequest",
}) as any as S.Schema<ListMonitoringExecutionsRequest>;
export type MonitoringExecutionSummaryList = MonitoringExecutionSummary[];
export const MonitoringExecutionSummaryList = S.Array(
  MonitoringExecutionSummary,
);
export interface ListMonitoringExecutionsResponse {
  MonitoringExecutionSummaries: (MonitoringExecutionSummary & {
    MonitoringScheduleName: MonitoringScheduleName;
    ScheduledTime: Date;
    CreationTime: Date;
    LastModifiedTime: Date;
    MonitoringExecutionStatus: ExecutionStatus;
  })[];
  NextToken?: string;
}
export const ListMonitoringExecutionsResponse = S.suspend(() =>
  S.Struct({
    MonitoringExecutionSummaries: S.optional(MonitoringExecutionSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListMonitoringExecutionsResponse",
}) as any as S.Schema<ListMonitoringExecutionsResponse>;
export type MonitoringScheduleSortKey =
  | "Name"
  | "CreationTime"
  | "Status"
  | (string & {});
export const MonitoringScheduleSortKey = S.String;
export interface ListMonitoringSchedulesRequest {
  EndpointName?: string;
  SortBy?: MonitoringScheduleSortKey;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
  NameContains?: string;
  CreationTimeBefore?: Date;
  CreationTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  StatusEquals?: ScheduleStatus;
  MonitoringJobDefinitionName?: string;
  MonitoringTypeEquals?: MonitoringType;
}
export const ListMonitoringSchedulesRequest = S.suspend(() =>
  S.Struct({
    EndpointName: S.optional(S.String),
    SortBy: S.optional(MonitoringScheduleSortKey),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NameContains: S.optional(S.String),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    StatusEquals: S.optional(ScheduleStatus),
    MonitoringJobDefinitionName: S.optional(S.String),
    MonitoringTypeEquals: S.optional(MonitoringType),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListMonitoringSchedulesRequest",
}) as any as S.Schema<ListMonitoringSchedulesRequest>;
export interface MonitoringScheduleSummary {
  MonitoringScheduleName?: string;
  MonitoringScheduleArn?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  MonitoringScheduleStatus?: ScheduleStatus;
  EndpointName?: string;
  MonitoringJobDefinitionName?: string;
  MonitoringType?: MonitoringType;
}
export const MonitoringScheduleSummary = S.suspend(() =>
  S.Struct({
    MonitoringScheduleName: S.optional(S.String),
    MonitoringScheduleArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    MonitoringScheduleStatus: S.optional(ScheduleStatus),
    EndpointName: S.optional(S.String),
    MonitoringJobDefinitionName: S.optional(S.String),
    MonitoringType: S.optional(MonitoringType),
  }),
).annotate({
  identifier: "MonitoringScheduleSummary",
}) as any as S.Schema<MonitoringScheduleSummary>;
export type MonitoringScheduleSummaryList = MonitoringScheduleSummary[];
export const MonitoringScheduleSummaryList = S.Array(MonitoringScheduleSummary);
export interface ListMonitoringSchedulesResponse {
  MonitoringScheduleSummaries: (MonitoringScheduleSummary & {
    MonitoringScheduleName: MonitoringScheduleName;
    MonitoringScheduleArn: MonitoringScheduleArn;
    CreationTime: Date;
    LastModifiedTime: Date;
    MonitoringScheduleStatus: ScheduleStatus;
  })[];
  NextToken?: string;
}
export const ListMonitoringSchedulesResponse = S.suspend(() =>
  S.Struct({
    MonitoringScheduleSummaries: S.optional(MonitoringScheduleSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListMonitoringSchedulesResponse",
}) as any as S.Schema<ListMonitoringSchedulesResponse>;
export type NotebookInstanceLifecycleConfigSortKey =
  | "Name"
  | "CreationTime"
  | "LastModifiedTime"
  | (string & {});
export const NotebookInstanceLifecycleConfigSortKey = S.String;
export type NotebookInstanceLifecycleConfigSortOrder =
  | "Ascending"
  | "Descending"
  | (string & {});
export const NotebookInstanceLifecycleConfigSortOrder = S.String;
export interface ListNotebookInstanceLifecycleConfigsInput {
  NextToken?: string;
  MaxResults?: number;
  SortBy?: NotebookInstanceLifecycleConfigSortKey;
  SortOrder?: NotebookInstanceLifecycleConfigSortOrder;
  NameContains?: string;
  CreationTimeBefore?: Date;
  CreationTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
}
export const ListNotebookInstanceLifecycleConfigsInput = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SortBy: S.optional(NotebookInstanceLifecycleConfigSortKey),
    SortOrder: S.optional(NotebookInstanceLifecycleConfigSortOrder),
    NameContains: S.optional(S.String),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListNotebookInstanceLifecycleConfigsInput",
}) as any as S.Schema<ListNotebookInstanceLifecycleConfigsInput>;
export interface NotebookInstanceLifecycleConfigSummary {
  NotebookInstanceLifecycleConfigName?: string;
  NotebookInstanceLifecycleConfigArn?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
}
export const NotebookInstanceLifecycleConfigSummary = S.suspend(() =>
  S.Struct({
    NotebookInstanceLifecycleConfigName: S.optional(S.String),
    NotebookInstanceLifecycleConfigArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "NotebookInstanceLifecycleConfigSummary",
}) as any as S.Schema<NotebookInstanceLifecycleConfigSummary>;
export type NotebookInstanceLifecycleConfigSummaryList =
  NotebookInstanceLifecycleConfigSummary[];
export const NotebookInstanceLifecycleConfigSummaryList = S.Array(
  NotebookInstanceLifecycleConfigSummary,
);
export interface ListNotebookInstanceLifecycleConfigsOutput {
  NextToken?: string;
  NotebookInstanceLifecycleConfigs?: (NotebookInstanceLifecycleConfigSummary & {
    NotebookInstanceLifecycleConfigName: NotebookInstanceLifecycleConfigName;
    NotebookInstanceLifecycleConfigArn: NotebookInstanceLifecycleConfigArn;
  })[];
}
export const ListNotebookInstanceLifecycleConfigsOutput = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    NotebookInstanceLifecycleConfigs: S.optional(
      NotebookInstanceLifecycleConfigSummaryList,
    ),
  }).pipe(ns),
).annotate({
  identifier: "ListNotebookInstanceLifecycleConfigsOutput",
}) as any as S.Schema<ListNotebookInstanceLifecycleConfigsOutput>;
export type NotebookInstanceSortKey =
  | "Name"
  | "CreationTime"
  | "Status"
  | (string & {});
export const NotebookInstanceSortKey = S.String;
export type NotebookInstanceSortOrder =
  | "Ascending"
  | "Descending"
  | (string & {});
export const NotebookInstanceSortOrder = S.String;
export interface ListNotebookInstancesInput {
  NextToken?: string;
  MaxResults?: number;
  SortBy?: NotebookInstanceSortKey;
  SortOrder?: NotebookInstanceSortOrder;
  NameContains?: string;
  CreationTimeBefore?: Date;
  CreationTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  StatusEquals?: NotebookInstanceStatus;
  NotebookInstanceLifecycleConfigNameContains?: string;
  DefaultCodeRepositoryContains?: string;
  AdditionalCodeRepositoryEquals?: string;
}
export const ListNotebookInstancesInput = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SortBy: S.optional(NotebookInstanceSortKey),
    SortOrder: S.optional(NotebookInstanceSortOrder),
    NameContains: S.optional(S.String),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    StatusEquals: S.optional(NotebookInstanceStatus),
    NotebookInstanceLifecycleConfigNameContains: S.optional(S.String),
    DefaultCodeRepositoryContains: S.optional(S.String),
    AdditionalCodeRepositoryEquals: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListNotebookInstancesInput",
}) as any as S.Schema<ListNotebookInstancesInput>;
export interface NotebookInstanceSummary {
  NotebookInstanceName?: string;
  NotebookInstanceArn?: string;
  NotebookInstanceStatus?: NotebookInstanceStatus;
  Url?: string;
  InstanceType?: InstanceType;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  NotebookInstanceLifecycleConfigName?: string;
  DefaultCodeRepository?: string;
  AdditionalCodeRepositories?: string[];
}
export const NotebookInstanceSummary = S.suspend(() =>
  S.Struct({
    NotebookInstanceName: S.optional(S.String),
    NotebookInstanceArn: S.optional(S.String),
    NotebookInstanceStatus: S.optional(NotebookInstanceStatus),
    Url: S.optional(S.String),
    InstanceType: S.optional(InstanceType),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    NotebookInstanceLifecycleConfigName: S.optional(S.String),
    DefaultCodeRepository: S.optional(S.String),
    AdditionalCodeRepositories: S.optional(AdditionalCodeRepositoryNamesOrUrls),
  }),
).annotate({
  identifier: "NotebookInstanceSummary",
}) as any as S.Schema<NotebookInstanceSummary>;
export type NotebookInstanceSummaryList = NotebookInstanceSummary[];
export const NotebookInstanceSummaryList = S.Array(NotebookInstanceSummary);
export interface ListNotebookInstancesOutput {
  NextToken?: string;
  NotebookInstances?: (NotebookInstanceSummary & {
    NotebookInstanceName: NotebookInstanceName;
    NotebookInstanceArn: NotebookInstanceArn;
  })[];
}
export const ListNotebookInstancesOutput = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    NotebookInstances: S.optional(NotebookInstanceSummaryList),
  }).pipe(ns),
).annotate({
  identifier: "ListNotebookInstancesOutput",
}) as any as S.Schema<ListNotebookInstancesOutput>;
export type ListOptimizationJobsSortBy =
  | "Name"
  | "CreationTime"
  | "Status"
  | (string & {});
export const ListOptimizationJobsSortBy = S.String;
export interface ListOptimizationJobsRequest {
  NextToken?: string;
  MaxResults?: number;
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  OptimizationContains?: string;
  NameContains?: string;
  StatusEquals?: OptimizationJobStatus;
  SortBy?: ListOptimizationJobsSortBy;
  SortOrder?: SortOrder;
}
export const ListOptimizationJobsRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    OptimizationContains: S.optional(S.String),
    NameContains: S.optional(S.String),
    StatusEquals: S.optional(OptimizationJobStatus),
    SortBy: S.optional(ListOptimizationJobsSortBy),
    SortOrder: S.optional(SortOrder),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListOptimizationJobsRequest",
}) as any as S.Schema<ListOptimizationJobsRequest>;
export type OptimizationTypes = string[];
export const OptimizationTypes = S.Array(S.String);
export interface OptimizationJobSummary {
  OptimizationJobName?: string;
  OptimizationJobArn?: string;
  CreationTime?: Date;
  OptimizationJobStatus?: OptimizationJobStatus;
  OptimizationStartTime?: Date;
  OptimizationEndTime?: Date;
  LastModifiedTime?: Date;
  DeploymentInstanceType?: OptimizationJobDeploymentInstanceType;
  MaxInstanceCount?: number;
  OptimizationTypes?: string[];
}
export const OptimizationJobSummary = S.suspend(() =>
  S.Struct({
    OptimizationJobName: S.optional(S.String),
    OptimizationJobArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    OptimizationJobStatus: S.optional(OptimizationJobStatus),
    OptimizationStartTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    OptimizationEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    DeploymentInstanceType: S.optional(OptimizationJobDeploymentInstanceType),
    MaxInstanceCount: S.optional(S.Number),
    OptimizationTypes: S.optional(OptimizationTypes),
  }),
).annotate({
  identifier: "OptimizationJobSummary",
}) as any as S.Schema<OptimizationJobSummary>;
export type OptimizationJobSummaries = OptimizationJobSummary[];
export const OptimizationJobSummaries = S.Array(OptimizationJobSummary);
export interface ListOptimizationJobsResponse {
  OptimizationJobSummaries: (OptimizationJobSummary & {
    OptimizationJobName: EntityName;
    OptimizationJobArn: OptimizationJobArn;
    CreationTime: CreationTime;
    OptimizationJobStatus: OptimizationJobStatus;
    DeploymentInstanceType: OptimizationJobDeploymentInstanceType;
    OptimizationTypes: OptimizationTypes;
  })[];
  NextToken?: string;
}
export const ListOptimizationJobsResponse = S.suspend(() =>
  S.Struct({
    OptimizationJobSummaries: S.optional(OptimizationJobSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListOptimizationJobsResponse",
}) as any as S.Schema<ListOptimizationJobsResponse>;
export interface ListPartnerAppsRequest {
  MaxResults?: number;
  NextToken?: string;
}
export const ListPartnerAppsRequest = S.suspend(() =>
  S.Struct({
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListPartnerAppsRequest",
}) as any as S.Schema<ListPartnerAppsRequest>;
export interface PartnerAppSummary {
  Arn?: string;
  Name?: string;
  Type?: PartnerAppType;
  Status?: PartnerAppStatus;
  CreationTime?: Date;
}
export const PartnerAppSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    Type: S.optional(PartnerAppType),
    Status: S.optional(PartnerAppStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotate({
  identifier: "PartnerAppSummary",
}) as any as S.Schema<PartnerAppSummary>;
export type PartnerAppSummaries = PartnerAppSummary[];
export const PartnerAppSummaries = S.Array(PartnerAppSummary);
export interface ListPartnerAppsResponse {
  Summaries?: PartnerAppSummary[];
  NextToken?: string;
}
export const ListPartnerAppsResponse = S.suspend(() =>
  S.Struct({
    Summaries: S.optional(PartnerAppSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListPartnerAppsResponse",
}) as any as S.Schema<ListPartnerAppsResponse>;
export type SortPipelineExecutionsBy =
  | "CreationTime"
  | "PipelineExecutionArn"
  | (string & {});
export const SortPipelineExecutionsBy = S.String;
export interface ListPipelineExecutionsRequest {
  PipelineName?: string;
  CreatedAfter?: Date;
  CreatedBefore?: Date;
  SortBy?: SortPipelineExecutionsBy;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListPipelineExecutionsRequest = S.suspend(() =>
  S.Struct({
    PipelineName: S.optional(S.String),
    CreatedAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBefore: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    SortBy: S.optional(SortPipelineExecutionsBy),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListPipelineExecutionsRequest",
}) as any as S.Schema<ListPipelineExecutionsRequest>;
export interface PipelineExecutionSummary {
  PipelineExecutionArn?: string;
  StartTime?: Date;
  PipelineExecutionStatus?: PipelineExecutionStatus;
  PipelineExecutionDescription?: string;
  PipelineExecutionDisplayName?: string;
  PipelineExecutionFailureReason?: string;
}
export const PipelineExecutionSummary = S.suspend(() =>
  S.Struct({
    PipelineExecutionArn: S.optional(S.String),
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    PipelineExecutionStatus: S.optional(PipelineExecutionStatus),
    PipelineExecutionDescription: S.optional(S.String),
    PipelineExecutionDisplayName: S.optional(S.String),
    PipelineExecutionFailureReason: S.optional(S.String),
  }),
).annotate({
  identifier: "PipelineExecutionSummary",
}) as any as S.Schema<PipelineExecutionSummary>;
export type PipelineExecutionSummaryList = PipelineExecutionSummary[];
export const PipelineExecutionSummaryList = S.Array(PipelineExecutionSummary);
export interface ListPipelineExecutionsResponse {
  PipelineExecutionSummaries?: PipelineExecutionSummary[];
  NextToken?: string;
}
export const ListPipelineExecutionsResponse = S.suspend(() =>
  S.Struct({
    PipelineExecutionSummaries: S.optional(PipelineExecutionSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListPipelineExecutionsResponse",
}) as any as S.Schema<ListPipelineExecutionsResponse>;
export interface ListPipelineExecutionStepsRequest {
  PipelineExecutionArn?: string;
  NextToken?: string;
  MaxResults?: number;
  SortOrder?: SortOrder;
}
export const ListPipelineExecutionStepsRequest = S.suspend(() =>
  S.Struct({
    PipelineExecutionArn: S.optional(S.String),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SortOrder: S.optional(SortOrder),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListPipelineExecutionStepsRequest",
}) as any as S.Schema<ListPipelineExecutionStepsRequest>;
export type StepStatus =
  | "Starting"
  | "Executing"
  | "Stopping"
  | "Stopped"
  | "Failed"
  | "Succeeded"
  | (string & {});
export const StepStatus = S.String;
export interface CacheHitResult {
  SourcePipelineExecutionArn?: string;
}
export const CacheHitResult = S.suspend(() =>
  S.Struct({ SourcePipelineExecutionArn: S.optional(S.String) }),
).annotate({ identifier: "CacheHitResult" }) as any as S.Schema<CacheHitResult>;
export interface TrainingJobStepMetadata {
  Arn?: string;
}
export const TrainingJobStepMetadata = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }),
).annotate({
  identifier: "TrainingJobStepMetadata",
}) as any as S.Schema<TrainingJobStepMetadata>;
export interface ProcessingJobStepMetadata {
  Arn?: string;
}
export const ProcessingJobStepMetadata = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }),
).annotate({
  identifier: "ProcessingJobStepMetadata",
}) as any as S.Schema<ProcessingJobStepMetadata>;
export interface TransformJobStepMetadata {
  Arn?: string;
}
export const TransformJobStepMetadata = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }),
).annotate({
  identifier: "TransformJobStepMetadata",
}) as any as S.Schema<TransformJobStepMetadata>;
export interface TuningJobStepMetaData {
  Arn?: string;
}
export const TuningJobStepMetaData = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }),
).annotate({
  identifier: "TuningJobStepMetaData",
}) as any as S.Schema<TuningJobStepMetaData>;
export interface ModelStepMetadata {
  Arn?: string;
}
export const ModelStepMetadata = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }),
).annotate({
  identifier: "ModelStepMetadata",
}) as any as S.Schema<ModelStepMetadata>;
export interface RegisterModelStepMetadata {
  Arn?: string;
}
export const RegisterModelStepMetadata = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }),
).annotate({
  identifier: "RegisterModelStepMetadata",
}) as any as S.Schema<RegisterModelStepMetadata>;
export type ConditionOutcome = "True" | "False" | (string & {});
export const ConditionOutcome = S.String;
export interface ConditionStepMetadata {
  Outcome?: ConditionOutcome;
}
export const ConditionStepMetadata = S.suspend(() =>
  S.Struct({ Outcome: S.optional(ConditionOutcome) }),
).annotate({
  identifier: "ConditionStepMetadata",
}) as any as S.Schema<ConditionStepMetadata>;
export interface OutputParameter {
  Name?: string;
  Value?: string;
}
export const OutputParameter = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Value: S.optional(S.String) }),
).annotate({
  identifier: "OutputParameter",
}) as any as S.Schema<OutputParameter>;
export type OutputParameterList = OutputParameter[];
export const OutputParameterList = S.Array(OutputParameter);
export interface CallbackStepMetadata {
  CallbackToken?: string;
  SqsQueueUrl?: string;
  OutputParameters?: OutputParameter[];
}
export const CallbackStepMetadata = S.suspend(() =>
  S.Struct({
    CallbackToken: S.optional(S.String),
    SqsQueueUrl: S.optional(S.String),
    OutputParameters: S.optional(OutputParameterList),
  }),
).annotate({
  identifier: "CallbackStepMetadata",
}) as any as S.Schema<CallbackStepMetadata>;
export interface LambdaStepMetadata {
  Arn?: string;
  OutputParameters?: OutputParameter[];
}
export const LambdaStepMetadata = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    OutputParameters: S.optional(OutputParameterList),
  }),
).annotate({
  identifier: "LambdaStepMetadata",
}) as any as S.Schema<LambdaStepMetadata>;
export interface EMRStepMetadata {
  ClusterId?: string;
  StepId?: string;
  StepName?: string;
  LogFilePath?: string;
}
export const EMRStepMetadata = S.suspend(() =>
  S.Struct({
    ClusterId: S.optional(S.String),
    StepId: S.optional(S.String),
    StepName: S.optional(S.String),
    LogFilePath: S.optional(S.String),
  }),
).annotate({
  identifier: "EMRStepMetadata",
}) as any as S.Schema<EMRStepMetadata>;
export interface QualityCheckStepMetadata {
  CheckType?: string;
  BaselineUsedForDriftCheckStatistics?: string;
  BaselineUsedForDriftCheckConstraints?: string;
  CalculatedBaselineStatistics?: string;
  CalculatedBaselineConstraints?: string;
  ModelPackageGroupName?: string;
  ViolationReport?: string;
  CheckJobArn?: string;
  SkipCheck?: boolean;
  RegisterNewBaseline?: boolean;
}
export const QualityCheckStepMetadata = S.suspend(() =>
  S.Struct({
    CheckType: S.optional(S.String),
    BaselineUsedForDriftCheckStatistics: S.optional(S.String),
    BaselineUsedForDriftCheckConstraints: S.optional(S.String),
    CalculatedBaselineStatistics: S.optional(S.String),
    CalculatedBaselineConstraints: S.optional(S.String),
    ModelPackageGroupName: S.optional(S.String),
    ViolationReport: S.optional(S.String),
    CheckJobArn: S.optional(S.String),
    SkipCheck: S.optional(S.Boolean),
    RegisterNewBaseline: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "QualityCheckStepMetadata",
}) as any as S.Schema<QualityCheckStepMetadata>;
export interface ClarifyCheckStepMetadata {
  CheckType?: string;
  BaselineUsedForDriftCheckConstraints?: string;
  CalculatedBaselineConstraints?: string;
  ModelPackageGroupName?: string;
  ViolationReport?: string;
  CheckJobArn?: string;
  SkipCheck?: boolean;
  RegisterNewBaseline?: boolean;
}
export const ClarifyCheckStepMetadata = S.suspend(() =>
  S.Struct({
    CheckType: S.optional(S.String),
    BaselineUsedForDriftCheckConstraints: S.optional(S.String),
    CalculatedBaselineConstraints: S.optional(S.String),
    ModelPackageGroupName: S.optional(S.String),
    ViolationReport: S.optional(S.String),
    CheckJobArn: S.optional(S.String),
    SkipCheck: S.optional(S.Boolean),
    RegisterNewBaseline: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "ClarifyCheckStepMetadata",
}) as any as S.Schema<ClarifyCheckStepMetadata>;
export interface FailStepMetadata {
  ErrorMessage?: string;
}
export const FailStepMetadata = S.suspend(() =>
  S.Struct({ ErrorMessage: S.optional(S.String) }),
).annotate({
  identifier: "FailStepMetadata",
}) as any as S.Schema<FailStepMetadata>;
export interface AutoMLJobStepMetadata {
  Arn?: string;
}
export const AutoMLJobStepMetadata = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }),
).annotate({
  identifier: "AutoMLJobStepMetadata",
}) as any as S.Schema<AutoMLJobStepMetadata>;
export interface EndpointStepMetadata {
  Arn?: string;
}
export const EndpointStepMetadata = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }),
).annotate({
  identifier: "EndpointStepMetadata",
}) as any as S.Schema<EndpointStepMetadata>;
export interface EndpointConfigStepMetadata {
  Arn?: string;
}
export const EndpointConfigStepMetadata = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }),
).annotate({
  identifier: "EndpointConfigStepMetadata",
}) as any as S.Schema<EndpointConfigStepMetadata>;
export interface BedrockCustomModelMetadata {
  Arn?: string;
}
export const BedrockCustomModelMetadata = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }),
).annotate({
  identifier: "BedrockCustomModelMetadata",
}) as any as S.Schema<BedrockCustomModelMetadata>;
export interface BedrockCustomModelDeploymentMetadata {
  Arn?: string;
}
export const BedrockCustomModelDeploymentMetadata = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }),
).annotate({
  identifier: "BedrockCustomModelDeploymentMetadata",
}) as any as S.Schema<BedrockCustomModelDeploymentMetadata>;
export interface BedrockProvisionedModelThroughputMetadata {
  Arn?: string;
}
export const BedrockProvisionedModelThroughputMetadata = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }),
).annotate({
  identifier: "BedrockProvisionedModelThroughputMetadata",
}) as any as S.Schema<BedrockProvisionedModelThroughputMetadata>;
export interface BedrockModelImportMetadata {
  Arn?: string;
}
export const BedrockModelImportMetadata = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }),
).annotate({
  identifier: "BedrockModelImportMetadata",
}) as any as S.Schema<BedrockModelImportMetadata>;
export interface InferenceComponentMetadata {
  Arn?: string;
}
export const InferenceComponentMetadata = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }),
).annotate({
  identifier: "InferenceComponentMetadata",
}) as any as S.Schema<InferenceComponentMetadata>;
export type MapString2048 = { [key: string]: string | undefined };
export const MapString2048 = S.Record(S.String, S.String.pipe(S.optional));
export interface AssociationInfo {
  SourceArn?: string;
  DestinationArn?: string;
}
export const AssociationInfo = S.suspend(() =>
  S.Struct({
    SourceArn: S.optional(S.String),
    DestinationArn: S.optional(S.String),
  }),
).annotate({
  identifier: "AssociationInfo",
}) as any as S.Schema<AssociationInfo>;
export type AssociationInfoList = AssociationInfo[];
export const AssociationInfoList = S.Array(AssociationInfo);
export interface LineageMetadata {
  ActionArns?: { [key: string]: string | undefined };
  ArtifactArns?: { [key: string]: string | undefined };
  ContextArns?: { [key: string]: string | undefined };
  Associations?: AssociationInfo[];
}
export const LineageMetadata = S.suspend(() =>
  S.Struct({
    ActionArns: S.optional(MapString2048),
    ArtifactArns: S.optional(MapString2048),
    ContextArns: S.optional(MapString2048),
    Associations: S.optional(AssociationInfoList),
  }),
).annotate({
  identifier: "LineageMetadata",
}) as any as S.Schema<LineageMetadata>;
export interface PipelineExecutionStepMetadata {
  TrainingJob?: TrainingJobStepMetadata;
  ProcessingJob?: ProcessingJobStepMetadata;
  TransformJob?: TransformJobStepMetadata;
  TuningJob?: TuningJobStepMetaData;
  Model?: ModelStepMetadata;
  RegisterModel?: RegisterModelStepMetadata;
  Condition?: ConditionStepMetadata;
  Callback?: CallbackStepMetadata;
  Lambda?: LambdaStepMetadata;
  EMR?: EMRStepMetadata;
  QualityCheck?: QualityCheckStepMetadata;
  ClarifyCheck?: ClarifyCheckStepMetadata;
  Fail?: FailStepMetadata;
  AutoMLJob?: AutoMLJobStepMetadata;
  Endpoint?: EndpointStepMetadata;
  EndpointConfig?: EndpointConfigStepMetadata;
  BedrockCustomModel?: BedrockCustomModelMetadata;
  BedrockCustomModelDeployment?: BedrockCustomModelDeploymentMetadata;
  BedrockProvisionedModelThroughput?: BedrockProvisionedModelThroughputMetadata;
  BedrockModelImport?: BedrockModelImportMetadata;
  InferenceComponent?: InferenceComponentMetadata;
  Lineage?: LineageMetadata;
}
export const PipelineExecutionStepMetadata = S.suspend(() =>
  S.Struct({
    TrainingJob: S.optional(TrainingJobStepMetadata),
    ProcessingJob: S.optional(ProcessingJobStepMetadata),
    TransformJob: S.optional(TransformJobStepMetadata),
    TuningJob: S.optional(TuningJobStepMetaData),
    Model: S.optional(ModelStepMetadata),
    RegisterModel: S.optional(RegisterModelStepMetadata),
    Condition: S.optional(ConditionStepMetadata),
    Callback: S.optional(CallbackStepMetadata),
    Lambda: S.optional(LambdaStepMetadata),
    EMR: S.optional(EMRStepMetadata),
    QualityCheck: S.optional(QualityCheckStepMetadata),
    ClarifyCheck: S.optional(ClarifyCheckStepMetadata),
    Fail: S.optional(FailStepMetadata),
    AutoMLJob: S.optional(AutoMLJobStepMetadata),
    Endpoint: S.optional(EndpointStepMetadata),
    EndpointConfig: S.optional(EndpointConfigStepMetadata),
    BedrockCustomModel: S.optional(BedrockCustomModelMetadata),
    BedrockCustomModelDeployment: S.optional(
      BedrockCustomModelDeploymentMetadata,
    ),
    BedrockProvisionedModelThroughput: S.optional(
      BedrockProvisionedModelThroughputMetadata,
    ),
    BedrockModelImport: S.optional(BedrockModelImportMetadata),
    InferenceComponent: S.optional(InferenceComponentMetadata),
    Lineage: S.optional(LineageMetadata),
  }),
).annotate({
  identifier: "PipelineExecutionStepMetadata",
}) as any as S.Schema<PipelineExecutionStepMetadata>;
export interface SelectiveExecutionResult {
  SourcePipelineExecutionArn?: string;
}
export const SelectiveExecutionResult = S.suspend(() =>
  S.Struct({ SourcePipelineExecutionArn: S.optional(S.String) }),
).annotate({
  identifier: "SelectiveExecutionResult",
}) as any as S.Schema<SelectiveExecutionResult>;
export interface PipelineExecutionStep {
  StepName?: string;
  StepDisplayName?: string;
  StepDescription?: string;
  StartTime?: Date;
  EndTime?: Date;
  StepStatus?: StepStatus;
  CacheHitResult?: CacheHitResult;
  FailureReason?: string;
  Metadata?: PipelineExecutionStepMetadata;
  AttemptCount?: number;
  SelectiveExecutionResult?: SelectiveExecutionResult;
}
export const PipelineExecutionStep = S.suspend(() =>
  S.Struct({
    StepName: S.optional(S.String),
    StepDisplayName: S.optional(S.String),
    StepDescription: S.optional(S.String),
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    StepStatus: S.optional(StepStatus),
    CacheHitResult: S.optional(CacheHitResult),
    FailureReason: S.optional(S.String),
    Metadata: S.optional(PipelineExecutionStepMetadata),
    AttemptCount: S.optional(S.Number),
    SelectiveExecutionResult: S.optional(SelectiveExecutionResult),
  }),
).annotate({
  identifier: "PipelineExecutionStep",
}) as any as S.Schema<PipelineExecutionStep>;
export type PipelineExecutionStepList = PipelineExecutionStep[];
export const PipelineExecutionStepList = S.Array(PipelineExecutionStep);
export interface ListPipelineExecutionStepsResponse {
  PipelineExecutionSteps?: (PipelineExecutionStep & {
    Metadata: PipelineExecutionStepMetadata & {
      Callback: CallbackStepMetadata & {
        OutputParameters: (OutputParameter & {
          Name: String256;
          Value: String1024;
        })[];
      };
      Lambda: LambdaStepMetadata & {
        OutputParameters: (OutputParameter & {
          Name: String256;
          Value: String1024;
        })[];
      };
      Lineage: LineageMetadata & {
        Associations: (AssociationInfo & {
          SourceArn: String2048;
          DestinationArn: String2048;
        })[];
      };
    };
  })[];
  NextToken?: string;
}
export const ListPipelineExecutionStepsResponse = S.suspend(() =>
  S.Struct({
    PipelineExecutionSteps: S.optional(PipelineExecutionStepList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListPipelineExecutionStepsResponse",
}) as any as S.Schema<ListPipelineExecutionStepsResponse>;
export interface ListPipelineParametersForExecutionRequest {
  PipelineExecutionArn?: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListPipelineParametersForExecutionRequest = S.suspend(() =>
  S.Struct({
    PipelineExecutionArn: S.optional(S.String),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListPipelineParametersForExecutionRequest",
}) as any as S.Schema<ListPipelineParametersForExecutionRequest>;
export interface Parameter {
  Name?: string;
  Value?: string;
}
export const Parameter = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Value: S.optional(S.String) }),
).annotate({ identifier: "Parameter" }) as any as S.Schema<Parameter>;
export type ParameterList = Parameter[];
export const ParameterList = S.Array(Parameter);
export interface ListPipelineParametersForExecutionResponse {
  PipelineParameters?: (Parameter & {
    Name: PipelineParameterName;
    Value: String1024;
  })[];
  NextToken?: string;
}
export const ListPipelineParametersForExecutionResponse = S.suspend(() =>
  S.Struct({
    PipelineParameters: S.optional(ParameterList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListPipelineParametersForExecutionResponse",
}) as any as S.Schema<ListPipelineParametersForExecutionResponse>;
export type SortPipelinesBy = "Name" | "CreationTime" | (string & {});
export const SortPipelinesBy = S.String;
export interface ListPipelinesRequest {
  PipelineNamePrefix?: string;
  CreatedAfter?: Date;
  CreatedBefore?: Date;
  SortBy?: SortPipelinesBy;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListPipelinesRequest = S.suspend(() =>
  S.Struct({
    PipelineNamePrefix: S.optional(S.String),
    CreatedAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBefore: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    SortBy: S.optional(SortPipelinesBy),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListPipelinesRequest",
}) as any as S.Schema<ListPipelinesRequest>;
export interface PipelineSummary {
  PipelineArn?: string;
  PipelineName?: string;
  PipelineDisplayName?: string;
  PipelineDescription?: string;
  RoleArn?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  LastExecutionTime?: Date;
}
export const PipelineSummary = S.suspend(() =>
  S.Struct({
    PipelineArn: S.optional(S.String),
    PipelineName: S.optional(S.String),
    PipelineDisplayName: S.optional(S.String),
    PipelineDescription: S.optional(S.String),
    RoleArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastExecutionTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "PipelineSummary",
}) as any as S.Schema<PipelineSummary>;
export type PipelineSummaryList = PipelineSummary[];
export const PipelineSummaryList = S.Array(PipelineSummary);
export interface ListPipelinesResponse {
  PipelineSummaries?: PipelineSummary[];
  NextToken?: string;
}
export const ListPipelinesResponse = S.suspend(() =>
  S.Struct({
    PipelineSummaries: S.optional(PipelineSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListPipelinesResponse",
}) as any as S.Schema<ListPipelinesResponse>;
export interface ListPipelineVersionsRequest {
  PipelineName?: string;
  CreatedAfter?: Date;
  CreatedBefore?: Date;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListPipelineVersionsRequest = S.suspend(() =>
  S.Struct({
    PipelineName: S.optional(S.String),
    CreatedAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBefore: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListPipelineVersionsRequest",
}) as any as S.Schema<ListPipelineVersionsRequest>;
export interface PipelineVersionSummary {
  PipelineArn?: string;
  PipelineVersionId?: number;
  CreationTime?: Date;
  PipelineVersionDescription?: string;
  PipelineVersionDisplayName?: string;
  LastExecutionPipelineExecutionArn?: string;
}
export const PipelineVersionSummary = S.suspend(() =>
  S.Struct({
    PipelineArn: S.optional(S.String),
    PipelineVersionId: S.optional(S.Number),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    PipelineVersionDescription: S.optional(S.String),
    PipelineVersionDisplayName: S.optional(S.String),
    LastExecutionPipelineExecutionArn: S.optional(S.String),
  }),
).annotate({
  identifier: "PipelineVersionSummary",
}) as any as S.Schema<PipelineVersionSummary>;
export type PipelineVersionSummaryList = PipelineVersionSummary[];
export const PipelineVersionSummaryList = S.Array(PipelineVersionSummary);
export interface ListPipelineVersionsResponse {
  PipelineVersionSummaries?: PipelineVersionSummary[];
  NextToken?: string;
}
export const ListPipelineVersionsResponse = S.suspend(() =>
  S.Struct({
    PipelineVersionSummaries: S.optional(PipelineVersionSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListPipelineVersionsResponse",
}) as any as S.Schema<ListPipelineVersionsResponse>;
export interface ListProcessingJobsRequest {
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  NameContains?: string;
  StatusEquals?: ProcessingJobStatus;
  SortBy?: SortBy;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListProcessingJobsRequest = S.suspend(() =>
  S.Struct({
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    NameContains: S.optional(S.String),
    StatusEquals: S.optional(ProcessingJobStatus),
    SortBy: S.optional(SortBy),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListProcessingJobsRequest",
}) as any as S.Schema<ListProcessingJobsRequest>;
export interface ProcessingJobSummary {
  ProcessingJobName?: string;
  ProcessingJobArn?: string;
  CreationTime?: Date;
  ProcessingEndTime?: Date;
  LastModifiedTime?: Date;
  ProcessingJobStatus?: ProcessingJobStatus;
  FailureReason?: string;
  ExitMessage?: string;
}
export const ProcessingJobSummary = S.suspend(() =>
  S.Struct({
    ProcessingJobName: S.optional(S.String),
    ProcessingJobArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ProcessingEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ProcessingJobStatus: S.optional(ProcessingJobStatus),
    FailureReason: S.optional(S.String),
    ExitMessage: S.optional(S.String),
  }),
).annotate({
  identifier: "ProcessingJobSummary",
}) as any as S.Schema<ProcessingJobSummary>;
export type ProcessingJobSummaries = ProcessingJobSummary[];
export const ProcessingJobSummaries = S.Array(ProcessingJobSummary);
export interface ListProcessingJobsResponse {
  ProcessingJobSummaries: (ProcessingJobSummary & {
    ProcessingJobName: ProcessingJobName;
    ProcessingJobArn: ProcessingJobArn;
    CreationTime: Date;
    ProcessingJobStatus: ProcessingJobStatus;
  })[];
  NextToken?: string;
}
export const ListProcessingJobsResponse = S.suspend(() =>
  S.Struct({
    ProcessingJobSummaries: S.optional(ProcessingJobSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListProcessingJobsResponse",
}) as any as S.Schema<ListProcessingJobsResponse>;
export type ProjectSortBy = "Name" | "CreationTime" | (string & {});
export const ProjectSortBy = S.String;
export type ProjectSortOrder = "Ascending" | "Descending" | (string & {});
export const ProjectSortOrder = S.String;
export interface ListProjectsInput {
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  MaxResults?: number;
  NameContains?: string;
  NextToken?: string;
  SortBy?: ProjectSortBy;
  SortOrder?: ProjectSortOrder;
}
export const ListProjectsInput = S.suspend(() =>
  S.Struct({
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    MaxResults: S.optional(S.Number),
    NameContains: S.optional(S.String),
    NextToken: S.optional(S.String),
    SortBy: S.optional(ProjectSortBy),
    SortOrder: S.optional(ProjectSortOrder),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListProjectsInput",
}) as any as S.Schema<ListProjectsInput>;
export interface ProjectSummary {
  ProjectName?: string;
  ProjectDescription?: string;
  ProjectArn?: string;
  ProjectId?: string;
  CreationTime?: Date;
  ProjectStatus?: ProjectStatus;
}
export const ProjectSummary = S.suspend(() =>
  S.Struct({
    ProjectName: S.optional(S.String),
    ProjectDescription: S.optional(S.String),
    ProjectArn: S.optional(S.String),
    ProjectId: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ProjectStatus: S.optional(ProjectStatus),
  }),
).annotate({ identifier: "ProjectSummary" }) as any as S.Schema<ProjectSummary>;
export type ProjectSummaryList = ProjectSummary[];
export const ProjectSummaryList = S.Array(ProjectSummary);
export interface ListProjectsOutput {
  ProjectSummaryList: (ProjectSummary & {
    ProjectName: ProjectEntityName;
    ProjectArn: ProjectArn;
    ProjectId: ProjectId;
    CreationTime: Date;
    ProjectStatus: ProjectStatus;
  })[];
  NextToken?: string;
}
export const ListProjectsOutput = S.suspend(() =>
  S.Struct({
    ProjectSummaryList: S.optional(ProjectSummaryList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListProjectsOutput",
}) as any as S.Schema<ListProjectsOutput>;
export type ResourceCatalogSortOrder =
  | "Ascending"
  | "Descending"
  | (string & {});
export const ResourceCatalogSortOrder = S.String;
export type ResourceCatalogSortBy = "CreationTime" | (string & {});
export const ResourceCatalogSortBy = S.String;
export interface ListResourceCatalogsRequest {
  NameContains?: string;
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  SortOrder?: ResourceCatalogSortOrder;
  SortBy?: ResourceCatalogSortBy;
  MaxResults?: number;
  NextToken?: string;
}
export const ListResourceCatalogsRequest = S.suspend(() =>
  S.Struct({
    NameContains: S.optional(S.String),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SortOrder: S.optional(ResourceCatalogSortOrder),
    SortBy: S.optional(ResourceCatalogSortBy),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListResourceCatalogsRequest",
}) as any as S.Schema<ListResourceCatalogsRequest>;
export interface ResourceCatalog {
  ResourceCatalogArn?: string;
  ResourceCatalogName?: string;
  Description?: string;
  CreationTime?: Date;
}
export const ResourceCatalog = S.suspend(() =>
  S.Struct({
    ResourceCatalogArn: S.optional(S.String),
    ResourceCatalogName: S.optional(S.String),
    Description: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotate({
  identifier: "ResourceCatalog",
}) as any as S.Schema<ResourceCatalog>;
export type ResourceCatalogList = ResourceCatalog[];
export const ResourceCatalogList = S.Array(ResourceCatalog);
export interface ListResourceCatalogsResponse {
  ResourceCatalogs?: (ResourceCatalog & {
    ResourceCatalogArn: ResourceCatalogArn;
    ResourceCatalogName: ResourceCatalogName;
    Description: ResourceCatalogDescription;
    CreationTime: Date;
  })[];
  NextToken?: string;
}
export const ListResourceCatalogsResponse = S.suspend(() =>
  S.Struct({
    ResourceCatalogs: S.optional(ResourceCatalogList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListResourceCatalogsResponse",
}) as any as S.Schema<ListResourceCatalogsResponse>;
export type SpaceSortKey = "CreationTime" | "LastModifiedTime" | (string & {});
export const SpaceSortKey = S.String;
export interface ListSpacesRequest {
  NextToken?: string;
  MaxResults?: number;
  SortOrder?: SortOrder;
  SortBy?: SpaceSortKey;
  DomainIdEquals?: string;
  SpaceNameContains?: string;
}
export const ListSpacesRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SortOrder: S.optional(SortOrder),
    SortBy: S.optional(SpaceSortKey),
    DomainIdEquals: S.optional(S.String),
    SpaceNameContains: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListSpacesRequest",
}) as any as S.Schema<ListSpacesRequest>;
export interface SpaceSettingsSummary {
  AppType?: AppType;
  RemoteAccess?: FeatureStatus;
  SpaceStorageSettings?: SpaceStorageSettings;
}
export const SpaceSettingsSummary = S.suspend(() =>
  S.Struct({
    AppType: S.optional(AppType),
    RemoteAccess: S.optional(FeatureStatus),
    SpaceStorageSettings: S.optional(SpaceStorageSettings),
  }),
).annotate({
  identifier: "SpaceSettingsSummary",
}) as any as S.Schema<SpaceSettingsSummary>;
export interface SpaceSharingSettingsSummary {
  SharingType?: SharingType;
}
export const SpaceSharingSettingsSummary = S.suspend(() =>
  S.Struct({ SharingType: S.optional(SharingType) }),
).annotate({
  identifier: "SpaceSharingSettingsSummary",
}) as any as S.Schema<SpaceSharingSettingsSummary>;
export interface OwnershipSettingsSummary {
  OwnerUserProfileName?: string;
}
export const OwnershipSettingsSummary = S.suspend(() =>
  S.Struct({ OwnerUserProfileName: S.optional(S.String) }),
).annotate({
  identifier: "OwnershipSettingsSummary",
}) as any as S.Schema<OwnershipSettingsSummary>;
export interface SpaceDetails {
  DomainId?: string;
  SpaceName?: string;
  Status?: SpaceStatus;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  SpaceSettingsSummary?: SpaceSettingsSummary;
  SpaceSharingSettingsSummary?: SpaceSharingSettingsSummary;
  OwnershipSettingsSummary?: OwnershipSettingsSummary;
  SpaceDisplayName?: string;
}
export const SpaceDetails = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    SpaceName: S.optional(S.String),
    Status: S.optional(SpaceStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SpaceSettingsSummary: S.optional(SpaceSettingsSummary),
    SpaceSharingSettingsSummary: S.optional(SpaceSharingSettingsSummary),
    OwnershipSettingsSummary: S.optional(OwnershipSettingsSummary),
    SpaceDisplayName: S.optional(S.String),
  }),
).annotate({ identifier: "SpaceDetails" }) as any as S.Schema<SpaceDetails>;
export type SpaceList = SpaceDetails[];
export const SpaceList = S.Array(SpaceDetails);
export interface ListSpacesResponse {
  Spaces?: (SpaceDetails & {
    SpaceSettingsSummary: SpaceSettingsSummary & {
      SpaceStorageSettings: SpaceStorageSettings & {
        EbsStorageSettings: EbsStorageSettings & {
          EbsVolumeSizeInGb: SpaceEbsVolumeSizeInGb;
        };
      };
    };
  })[];
  NextToken?: string;
}
export const ListSpacesResponse = S.suspend(() =>
  S.Struct({
    Spaces: S.optional(SpaceList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListSpacesResponse",
}) as any as S.Schema<ListSpacesResponse>;
export interface ListStageDevicesRequest {
  NextToken?: string;
  MaxResults?: number;
  EdgeDeploymentPlanName?: string;
  ExcludeDevicesDeployedInOtherStage?: boolean;
  StageName?: string;
}
export const ListStageDevicesRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    EdgeDeploymentPlanName: S.optional(S.String),
    ExcludeDevicesDeployedInOtherStage: S.optional(S.Boolean),
    StageName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListStageDevicesRequest",
}) as any as S.Schema<ListStageDevicesRequest>;
export type DeviceDeploymentStatus =
  | "READYTODEPLOY"
  | "INPROGRESS"
  | "DEPLOYED"
  | "FAILED"
  | "STOPPING"
  | "STOPPED"
  | (string & {});
export const DeviceDeploymentStatus = S.String;
export interface DeviceDeploymentSummary {
  EdgeDeploymentPlanArn?: string;
  EdgeDeploymentPlanName?: string;
  StageName?: string;
  DeployedStageName?: string;
  DeviceFleetName?: string;
  DeviceName?: string;
  DeviceArn?: string;
  DeviceDeploymentStatus?: DeviceDeploymentStatus;
  DeviceDeploymentStatusMessage?: string;
  Description?: string;
  DeploymentStartTime?: Date;
}
export const DeviceDeploymentSummary = S.suspend(() =>
  S.Struct({
    EdgeDeploymentPlanArn: S.optional(S.String),
    EdgeDeploymentPlanName: S.optional(S.String),
    StageName: S.optional(S.String),
    DeployedStageName: S.optional(S.String),
    DeviceFleetName: S.optional(S.String),
    DeviceName: S.optional(S.String),
    DeviceArn: S.optional(S.String),
    DeviceDeploymentStatus: S.optional(DeviceDeploymentStatus),
    DeviceDeploymentStatusMessage: S.optional(S.String),
    Description: S.optional(S.String),
    DeploymentStartTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "DeviceDeploymentSummary",
}) as any as S.Schema<DeviceDeploymentSummary>;
export type DeviceDeploymentSummaries = DeviceDeploymentSummary[];
export const DeviceDeploymentSummaries = S.Array(DeviceDeploymentSummary);
export interface ListStageDevicesResponse {
  DeviceDeploymentSummaries: (DeviceDeploymentSummary & {
    EdgeDeploymentPlanArn: EdgeDeploymentPlanArn;
    EdgeDeploymentPlanName: EntityName;
    StageName: EntityName;
    DeviceName: DeviceName;
    DeviceArn: DeviceArn;
  })[];
  NextToken?: string;
}
export const ListStageDevicesResponse = S.suspend(() =>
  S.Struct({
    DeviceDeploymentSummaries: S.optional(DeviceDeploymentSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListStageDevicesResponse",
}) as any as S.Schema<ListStageDevicesResponse>;
export type StudioLifecycleConfigSortKey =
  | "CreationTime"
  | "LastModifiedTime"
  | "Name"
  | (string & {});
export const StudioLifecycleConfigSortKey = S.String;
export interface ListStudioLifecycleConfigsRequest {
  MaxResults?: number;
  NextToken?: string;
  NameContains?: string;
  AppTypeEquals?: StudioLifecycleConfigAppType;
  CreationTimeBefore?: Date;
  CreationTimeAfter?: Date;
  ModifiedTimeBefore?: Date;
  ModifiedTimeAfter?: Date;
  SortBy?: StudioLifecycleConfigSortKey;
  SortOrder?: SortOrder;
}
export const ListStudioLifecycleConfigsRequest = S.suspend(() =>
  S.Struct({
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    NameContains: S.optional(S.String),
    AppTypeEquals: S.optional(StudioLifecycleConfigAppType),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SortBy: S.optional(StudioLifecycleConfigSortKey),
    SortOrder: S.optional(SortOrder),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListStudioLifecycleConfigsRequest",
}) as any as S.Schema<ListStudioLifecycleConfigsRequest>;
export interface StudioLifecycleConfigDetails {
  StudioLifecycleConfigArn?: string;
  StudioLifecycleConfigName?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  StudioLifecycleConfigAppType?: StudioLifecycleConfigAppType;
}
export const StudioLifecycleConfigDetails = S.suspend(() =>
  S.Struct({
    StudioLifecycleConfigArn: S.optional(S.String),
    StudioLifecycleConfigName: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    StudioLifecycleConfigAppType: S.optional(StudioLifecycleConfigAppType),
  }),
).annotate({
  identifier: "StudioLifecycleConfigDetails",
}) as any as S.Schema<StudioLifecycleConfigDetails>;
export type StudioLifecycleConfigsList = StudioLifecycleConfigDetails[];
export const StudioLifecycleConfigsList = S.Array(StudioLifecycleConfigDetails);
export interface ListStudioLifecycleConfigsResponse {
  NextToken?: string;
  StudioLifecycleConfigs?: StudioLifecycleConfigDetails[];
}
export const ListStudioLifecycleConfigsResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    StudioLifecycleConfigs: S.optional(StudioLifecycleConfigsList),
  }).pipe(ns),
).annotate({
  identifier: "ListStudioLifecycleConfigsResponse",
}) as any as S.Schema<ListStudioLifecycleConfigsResponse>;
export interface ListSubscribedWorkteamsRequest {
  NameContains?: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListSubscribedWorkteamsRequest = S.suspend(() =>
  S.Struct({
    NameContains: S.optional(S.String),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListSubscribedWorkteamsRequest",
}) as any as S.Schema<ListSubscribedWorkteamsRequest>;
export type SubscribedWorkteams = SubscribedWorkteam[];
export const SubscribedWorkteams = S.Array(SubscribedWorkteam);
export interface ListSubscribedWorkteamsResponse {
  SubscribedWorkteams: (SubscribedWorkteam & { WorkteamArn: WorkteamArn })[];
  NextToken?: string;
}
export const ListSubscribedWorkteamsResponse = S.suspend(() =>
  S.Struct({
    SubscribedWorkteams: S.optional(SubscribedWorkteams),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListSubscribedWorkteamsResponse",
}) as any as S.Schema<ListSubscribedWorkteamsResponse>;
export interface ListTagsInput {
  ResourceArn?: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListTagsInput = S.suspend(() =>
  S.Struct({
    ResourceArn: S.optional(S.String),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({ identifier: "ListTagsInput" }) as any as S.Schema<ListTagsInput>;
export interface ListTagsOutput {
  Tags?: (Tag & { Key: TagKey; Value: TagValue })[];
  NextToken?: string;
}
export const ListTagsOutput = S.suspend(() =>
  S.Struct({ Tags: S.optional(TagList), NextToken: S.optional(S.String) }).pipe(
    ns,
  ),
).annotate({ identifier: "ListTagsOutput" }) as any as S.Schema<ListTagsOutput>;
export interface ListTrainingJobsRequest {
  NextToken?: string;
  MaxResults?: number;
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  NameContains?: string;
  StatusEquals?: TrainingJobStatus;
  SortBy?: SortBy;
  SortOrder?: SortOrder;
  WarmPoolStatusEquals?: WarmPoolResourceStatus;
  TrainingPlanArnEquals?: string;
}
export const ListTrainingJobsRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    NameContains: S.optional(S.String),
    StatusEquals: S.optional(TrainingJobStatus),
    SortBy: S.optional(SortBy),
    SortOrder: S.optional(SortOrder),
    WarmPoolStatusEquals: S.optional(WarmPoolResourceStatus),
    TrainingPlanArnEquals: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListTrainingJobsRequest",
}) as any as S.Schema<ListTrainingJobsRequest>;
export interface TrainingJobSummary {
  TrainingJobName?: string;
  TrainingJobArn?: string;
  CreationTime?: Date;
  TrainingEndTime?: Date;
  LastModifiedTime?: Date;
  TrainingJobStatus?: TrainingJobStatus;
  SecondaryStatus?: SecondaryStatus;
  WarmPoolStatus?: WarmPoolStatus;
  TrainingPlanArn?: string;
}
export const TrainingJobSummary = S.suspend(() =>
  S.Struct({
    TrainingJobName: S.optional(S.String),
    TrainingJobArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    TrainingEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    TrainingJobStatus: S.optional(TrainingJobStatus),
    SecondaryStatus: S.optional(SecondaryStatus),
    WarmPoolStatus: S.optional(WarmPoolStatus),
    TrainingPlanArn: S.optional(S.String),
  }),
).annotate({
  identifier: "TrainingJobSummary",
}) as any as S.Schema<TrainingJobSummary>;
export type TrainingJobSummaries = TrainingJobSummary[];
export const TrainingJobSummaries = S.Array(TrainingJobSummary);
export interface ListTrainingJobsResponse {
  TrainingJobSummaries: (TrainingJobSummary & {
    TrainingJobName: TrainingJobName;
    TrainingJobArn: TrainingJobArn;
    CreationTime: Date;
    TrainingJobStatus: TrainingJobStatus;
    WarmPoolStatus: WarmPoolStatus & { Status: WarmPoolResourceStatus };
  })[];
  NextToken?: string;
}
export const ListTrainingJobsResponse = S.suspend(() =>
  S.Struct({
    TrainingJobSummaries: S.optional(TrainingJobSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListTrainingJobsResponse",
}) as any as S.Schema<ListTrainingJobsResponse>;
export type TrainingJobSortByOptions =
  | "Name"
  | "CreationTime"
  | "Status"
  | "FinalObjectiveMetricValue"
  | (string & {});
export const TrainingJobSortByOptions = S.String;
export interface ListTrainingJobsForHyperParameterTuningJobRequest {
  HyperParameterTuningJobName?: string;
  NextToken?: string;
  MaxResults?: number;
  StatusEquals?: TrainingJobStatus;
  SortBy?: TrainingJobSortByOptions;
  SortOrder?: SortOrder;
}
export const ListTrainingJobsForHyperParameterTuningJobRequest = S.suspend(() =>
  S.Struct({
    HyperParameterTuningJobName: S.optional(S.String),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    StatusEquals: S.optional(TrainingJobStatus),
    SortBy: S.optional(TrainingJobSortByOptions),
    SortOrder: S.optional(SortOrder),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListTrainingJobsForHyperParameterTuningJobRequest",
}) as any as S.Schema<ListTrainingJobsForHyperParameterTuningJobRequest>;
export type HyperParameterTrainingJobSummaries =
  HyperParameterTrainingJobSummary[];
export const HyperParameterTrainingJobSummaries = S.Array(
  HyperParameterTrainingJobSummary,
);
export interface ListTrainingJobsForHyperParameterTuningJobResponse {
  TrainingJobSummaries: (HyperParameterTrainingJobSummary & {
    TrainingJobName: TrainingJobName;
    TrainingJobArn: TrainingJobArn;
    CreationTime: Date;
    TrainingJobStatus: TrainingJobStatus;
    TunedHyperParameters: HyperParameters;
    FinalHyperParameterTuningJobObjectiveMetric: FinalHyperParameterTuningJobObjectiveMetric & {
      MetricName: MetricName;
      Value: MetricValue;
    };
  })[];
  NextToken?: string;
}
export const ListTrainingJobsForHyperParameterTuningJobResponse = S.suspend(
  () =>
    S.Struct({
      TrainingJobSummaries: S.optional(HyperParameterTrainingJobSummaries),
      NextToken: S.optional(S.String),
    }).pipe(ns),
).annotate({
  identifier: "ListTrainingJobsForHyperParameterTuningJobResponse",
}) as any as S.Schema<ListTrainingJobsForHyperParameterTuningJobResponse>;
export type TrainingPlanSortBy =
  | "TrainingPlanName"
  | "StartTime"
  | "Status"
  | (string & {});
export const TrainingPlanSortBy = S.String;
export type TrainingPlanSortOrder = "Ascending" | "Descending" | (string & {});
export const TrainingPlanSortOrder = S.String;
export type TrainingPlanFilterName = "Status" | (string & {});
export const TrainingPlanFilterName = S.String;
export interface TrainingPlanFilter {
  Name?: TrainingPlanFilterName;
  Value?: string;
}
export const TrainingPlanFilter = S.suspend(() =>
  S.Struct({
    Name: S.optional(TrainingPlanFilterName),
    Value: S.optional(S.String),
  }),
).annotate({
  identifier: "TrainingPlanFilter",
}) as any as S.Schema<TrainingPlanFilter>;
export type TrainingPlanFilters = TrainingPlanFilter[];
export const TrainingPlanFilters = S.Array(TrainingPlanFilter);
export interface ListTrainingPlansRequest {
  NextToken?: string;
  MaxResults?: number;
  StartTimeAfter?: Date;
  StartTimeBefore?: Date;
  SortBy?: TrainingPlanSortBy;
  SortOrder?: TrainingPlanSortOrder;
  Filters?: TrainingPlanFilter[];
}
export const ListTrainingPlansRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    StartTimeAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    StartTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SortBy: S.optional(TrainingPlanSortBy),
    SortOrder: S.optional(TrainingPlanSortOrder),
    Filters: S.optional(TrainingPlanFilters),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListTrainingPlansRequest",
}) as any as S.Schema<ListTrainingPlansRequest>;
export interface TrainingPlanSummary {
  TrainingPlanArn?: string;
  TrainingPlanName?: string;
  Status?: TrainingPlanStatus;
  StatusMessage?: string;
  DurationHours?: number;
  DurationMinutes?: number;
  StartTime?: Date;
  EndTime?: Date;
  UpfrontFee?: string;
  CurrencyCode?: string;
  TotalInstanceCount?: number;
  AvailableInstanceCount?: number;
  InUseInstanceCount?: number;
  TotalUltraServerCount?: number;
  TargetResources?: SageMakerResourceName[];
  ReservedCapacitySummaries?: ReservedCapacitySummary[];
}
export const TrainingPlanSummary = S.suspend(() =>
  S.Struct({
    TrainingPlanArn: S.optional(S.String),
    TrainingPlanName: S.optional(S.String),
    Status: S.optional(TrainingPlanStatus),
    StatusMessage: S.optional(S.String),
    DurationHours: S.optional(S.Number),
    DurationMinutes: S.optional(S.Number),
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    UpfrontFee: S.optional(S.String),
    CurrencyCode: S.optional(S.String),
    TotalInstanceCount: S.optional(S.Number),
    AvailableInstanceCount: S.optional(S.Number),
    InUseInstanceCount: S.optional(S.Number),
    TotalUltraServerCount: S.optional(S.Number),
    TargetResources: S.optional(SageMakerResourceNames),
    ReservedCapacitySummaries: S.optional(ReservedCapacitySummaries),
  }),
).annotate({
  identifier: "TrainingPlanSummary",
}) as any as S.Schema<TrainingPlanSummary>;
export type TrainingPlanSummaries = TrainingPlanSummary[];
export const TrainingPlanSummaries = S.Array(TrainingPlanSummary);
export interface ListTrainingPlansResponse {
  NextToken?: string;
  TrainingPlanSummaries: (TrainingPlanSummary & {
    TrainingPlanArn: TrainingPlanArn;
    TrainingPlanName: TrainingPlanName;
    Status: TrainingPlanStatus;
    ReservedCapacitySummaries: (ReservedCapacitySummary & {
      ReservedCapacityArn: ReservedCapacityArn;
      InstanceType: ReservedCapacityInstanceType;
      TotalInstanceCount: TotalInstanceCount;
      Status: ReservedCapacityStatus;
    })[];
  })[];
}
export const ListTrainingPlansResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    TrainingPlanSummaries: S.optional(TrainingPlanSummaries),
  }).pipe(ns),
).annotate({
  identifier: "ListTrainingPlansResponse",
}) as any as S.Schema<ListTrainingPlansResponse>;
export interface ListTransformJobsRequest {
  CreationTimeAfter?: Date;
  CreationTimeBefore?: Date;
  LastModifiedTimeAfter?: Date;
  LastModifiedTimeBefore?: Date;
  NameContains?: string;
  StatusEquals?: TransformJobStatus;
  SortBy?: SortBy;
  SortOrder?: SortOrder;
  NextToken?: string;
  MaxResults?: number;
}
export const ListTransformJobsRequest = S.suspend(() =>
  S.Struct({
    CreationTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    NameContains: S.optional(S.String),
    StatusEquals: S.optional(TransformJobStatus),
    SortBy: S.optional(SortBy),
    SortOrder: S.optional(SortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListTransformJobsRequest",
}) as any as S.Schema<ListTransformJobsRequest>;
export interface TransformJobSummary {
  TransformJobName?: string;
  TransformJobArn?: string;
  CreationTime?: Date;
  TransformEndTime?: Date;
  LastModifiedTime?: Date;
  TransformJobStatus?: TransformJobStatus;
  FailureReason?: string;
}
export const TransformJobSummary = S.suspend(() =>
  S.Struct({
    TransformJobName: S.optional(S.String),
    TransformJobArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    TransformEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    TransformJobStatus: S.optional(TransformJobStatus),
    FailureReason: S.optional(S.String),
  }),
).annotate({
  identifier: "TransformJobSummary",
}) as any as S.Schema<TransformJobSummary>;
export type TransformJobSummaries = TransformJobSummary[];
export const TransformJobSummaries = S.Array(TransformJobSummary);
export interface ListTransformJobsResponse {
  TransformJobSummaries: (TransformJobSummary & {
    TransformJobName: TransformJobName;
    TransformJobArn: TransformJobArn;
    CreationTime: Date;
    TransformJobStatus: TransformJobStatus;
  })[];
  NextToken?: string;
}
export const ListTransformJobsResponse = S.suspend(() =>
  S.Struct({
    TransformJobSummaries: S.optional(TransformJobSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListTransformJobsResponse",
}) as any as S.Schema<ListTransformJobsResponse>;
export type SortTrialComponentsBy = "Name" | "CreationTime" | (string & {});
export const SortTrialComponentsBy = S.String;
export interface ListTrialComponentsRequest {
  ExperimentName?: string;
  TrialName?: string;
  SourceArn?: string;
  CreatedAfter?: Date;
  CreatedBefore?: Date;
  SortBy?: SortTrialComponentsBy;
  SortOrder?: SortOrder;
  MaxResults?: number;
  NextToken?: string;
}
export const ListTrialComponentsRequest = S.suspend(() =>
  S.Struct({
    ExperimentName: S.optional(S.String),
    TrialName: S.optional(S.String),
    SourceArn: S.optional(S.String),
    CreatedAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBefore: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    SortBy: S.optional(SortTrialComponentsBy),
    SortOrder: S.optional(SortOrder),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListTrialComponentsRequest",
}) as any as S.Schema<ListTrialComponentsRequest>;
export interface TrialComponentSummary {
  TrialComponentName?: string;
  TrialComponentArn?: string;
  DisplayName?: string;
  TrialComponentSource?: TrialComponentSource;
  Status?: TrialComponentStatus;
  StartTime?: Date;
  EndTime?: Date;
  CreationTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
}
export const TrialComponentSummary = S.suspend(() =>
  S.Struct({
    TrialComponentName: S.optional(S.String),
    TrialComponentArn: S.optional(S.String),
    DisplayName: S.optional(S.String),
    TrialComponentSource: S.optional(TrialComponentSource),
    Status: S.optional(TrialComponentStatus),
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
  }),
).annotate({
  identifier: "TrialComponentSummary",
}) as any as S.Schema<TrialComponentSummary>;
export type TrialComponentSummaries = TrialComponentSummary[];
export const TrialComponentSummaries = S.Array(TrialComponentSummary);
export interface ListTrialComponentsResponse {
  TrialComponentSummaries?: (TrialComponentSummary & {
    TrialComponentSource: TrialComponentSource & {
      SourceArn: TrialComponentSourceArn;
    };
  })[];
  NextToken?: string;
}
export const ListTrialComponentsResponse = S.suspend(() =>
  S.Struct({
    TrialComponentSummaries: S.optional(TrialComponentSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListTrialComponentsResponse",
}) as any as S.Schema<ListTrialComponentsResponse>;
export type SortTrialsBy = "Name" | "CreationTime" | (string & {});
export const SortTrialsBy = S.String;
export interface ListTrialsRequest {
  ExperimentName?: string;
  TrialComponentName?: string;
  CreatedAfter?: Date;
  CreatedBefore?: Date;
  SortBy?: SortTrialsBy;
  SortOrder?: SortOrder;
  MaxResults?: number;
  NextToken?: string;
}
export const ListTrialsRequest = S.suspend(() =>
  S.Struct({
    ExperimentName: S.optional(S.String),
    TrialComponentName: S.optional(S.String),
    CreatedAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBefore: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    SortBy: S.optional(SortTrialsBy),
    SortOrder: S.optional(SortOrder),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListTrialsRequest",
}) as any as S.Schema<ListTrialsRequest>;
export interface TrialSummary {
  TrialArn?: string;
  TrialName?: string;
  DisplayName?: string;
  TrialSource?: TrialSource;
  CreationTime?: Date;
  LastModifiedTime?: Date;
}
export const TrialSummary = S.suspend(() =>
  S.Struct({
    TrialArn: S.optional(S.String),
    TrialName: S.optional(S.String),
    DisplayName: S.optional(S.String),
    TrialSource: S.optional(TrialSource),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({ identifier: "TrialSummary" }) as any as S.Schema<TrialSummary>;
export type TrialSummaries = TrialSummary[];
export const TrialSummaries = S.Array(TrialSummary);
export interface ListTrialsResponse {
  TrialSummaries?: (TrialSummary & {
    TrialSource: TrialSource & { SourceArn: TrialSourceArn };
  })[];
  NextToken?: string;
}
export const ListTrialsResponse = S.suspend(() =>
  S.Struct({
    TrialSummaries: S.optional(TrialSummaries),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListTrialsResponse",
}) as any as S.Schema<ListTrialsResponse>;
export interface ListUltraServersByReservedCapacityRequest {
  ReservedCapacityArn?: string;
  MaxResults?: number;
  NextToken?: string;
}
export const ListUltraServersByReservedCapacityRequest = S.suspend(() =>
  S.Struct({
    ReservedCapacityArn: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListUltraServersByReservedCapacityRequest",
}) as any as S.Schema<ListUltraServersByReservedCapacityRequest>;
export type UltraServerHealthStatus =
  | "OK"
  | "Impaired"
  | "Insufficient-Data"
  | (string & {});
export const UltraServerHealthStatus = S.String;
export interface UltraServer {
  UltraServerId?: string;
  UltraServerType?: string;
  AvailabilityZone?: string;
  InstanceType?: ReservedCapacityInstanceType;
  TotalInstanceCount?: number;
  ConfiguredSpareInstanceCount?: number;
  AvailableInstanceCount?: number;
  InUseInstanceCount?: number;
  AvailableSpareInstanceCount?: number;
  UnhealthyInstanceCount?: number;
  HealthStatus?: UltraServerHealthStatus;
}
export const UltraServer = S.suspend(() =>
  S.Struct({
    UltraServerId: S.optional(S.String),
    UltraServerType: S.optional(S.String),
    AvailabilityZone: S.optional(S.String),
    InstanceType: S.optional(ReservedCapacityInstanceType),
    TotalInstanceCount: S.optional(S.Number),
    ConfiguredSpareInstanceCount: S.optional(S.Number),
    AvailableInstanceCount: S.optional(S.Number),
    InUseInstanceCount: S.optional(S.Number),
    AvailableSpareInstanceCount: S.optional(S.Number),
    UnhealthyInstanceCount: S.optional(S.Number),
    HealthStatus: S.optional(UltraServerHealthStatus),
  }),
).annotate({ identifier: "UltraServer" }) as any as S.Schema<UltraServer>;
export type UltraServers = UltraServer[];
export const UltraServers = S.Array(UltraServer);
export interface ListUltraServersByReservedCapacityResponse {
  NextToken?: string;
  UltraServers: (UltraServer & {
    UltraServerId: NonEmptyString256;
    UltraServerType: UltraServerType;
    AvailabilityZone: AvailabilityZone;
    InstanceType: ReservedCapacityInstanceType;
    TotalInstanceCount: TotalInstanceCount;
  })[];
}
export const ListUltraServersByReservedCapacityResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    UltraServers: S.optional(UltraServers),
  }).pipe(ns),
).annotate({
  identifier: "ListUltraServersByReservedCapacityResponse",
}) as any as S.Schema<ListUltraServersByReservedCapacityResponse>;
export type UserProfileSortKey =
  | "CreationTime"
  | "LastModifiedTime"
  | (string & {});
export const UserProfileSortKey = S.String;
export interface ListUserProfilesRequest {
  NextToken?: string;
  MaxResults?: number;
  SortOrder?: SortOrder;
  SortBy?: UserProfileSortKey;
  DomainIdEquals?: string;
  UserProfileNameContains?: string;
}
export const ListUserProfilesRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SortOrder: S.optional(SortOrder),
    SortBy: S.optional(UserProfileSortKey),
    DomainIdEquals: S.optional(S.String),
    UserProfileNameContains: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListUserProfilesRequest",
}) as any as S.Schema<ListUserProfilesRequest>;
export interface UserProfileDetails {
  DomainId?: string;
  UserProfileName?: string;
  Status?: UserProfileStatus;
  CreationTime?: Date;
  LastModifiedTime?: Date;
}
export const UserProfileDetails = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    UserProfileName: S.optional(S.String),
    Status: S.optional(UserProfileStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "UserProfileDetails",
}) as any as S.Schema<UserProfileDetails>;
export type UserProfileList = UserProfileDetails[];
export const UserProfileList = S.Array(UserProfileDetails);
export interface ListUserProfilesResponse {
  UserProfiles?: UserProfileDetails[];
  NextToken?: string;
}
export const ListUserProfilesResponse = S.suspend(() =>
  S.Struct({
    UserProfiles: S.optional(UserProfileList),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListUserProfilesResponse",
}) as any as S.Schema<ListUserProfilesResponse>;
export type ListWorkforcesSortByOptions = "Name" | "CreateDate" | (string & {});
export const ListWorkforcesSortByOptions = S.String;
export interface ListWorkforcesRequest {
  SortBy?: ListWorkforcesSortByOptions;
  SortOrder?: SortOrder;
  NameContains?: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListWorkforcesRequest = S.suspend(() =>
  S.Struct({
    SortBy: S.optional(ListWorkforcesSortByOptions),
    SortOrder: S.optional(SortOrder),
    NameContains: S.optional(S.String),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListWorkforcesRequest",
}) as any as S.Schema<ListWorkforcesRequest>;
export type Workforces = Workforce[];
export const Workforces = S.Array(Workforce);
export interface ListWorkforcesResponse {
  Workforces: (Workforce & {
    WorkforceName: WorkforceName;
    WorkforceArn: WorkforceArn;
    SourceIpConfig: SourceIpConfig & { Cidrs: Cidrs };
    CognitoConfig: CognitoConfig & {
      UserPool: CognitoUserPool;
      ClientId: ClientId;
    };
    WorkforceVpcConfig: WorkforceVpcConfigResponse & {
      VpcId: WorkforceVpcId;
      SecurityGroupIds: WorkforceSecurityGroupIds;
      Subnets: WorkforceSubnets;
    };
  })[];
  NextToken?: string;
}
export const ListWorkforcesResponse = S.suspend(() =>
  S.Struct({
    Workforces: S.optional(Workforces),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListWorkforcesResponse",
}) as any as S.Schema<ListWorkforcesResponse>;
export type ListWorkteamsSortByOptions = "Name" | "CreateDate" | (string & {});
export const ListWorkteamsSortByOptions = S.String;
export interface ListWorkteamsRequest {
  SortBy?: ListWorkteamsSortByOptions;
  SortOrder?: SortOrder;
  NameContains?: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListWorkteamsRequest = S.suspend(() =>
  S.Struct({
    SortBy: S.optional(ListWorkteamsSortByOptions),
    SortOrder: S.optional(SortOrder),
    NameContains: S.optional(S.String),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListWorkteamsRequest",
}) as any as S.Schema<ListWorkteamsRequest>;
export type Workteams = Workteam[];
export const Workteams = S.Array(Workteam);
export interface ListWorkteamsResponse {
  Workteams: (Workteam & {
    WorkteamName: WorkteamName;
    MemberDefinitions: (MemberDefinition & {
      CognitoMemberDefinition: CognitoMemberDefinition & {
        UserPool: CognitoUserPool;
        UserGroup: CognitoUserGroup;
        ClientId: ClientId;
      };
    })[];
    WorkteamArn: WorkteamArn;
    Description: String200;
  })[];
  NextToken?: string;
}
export const ListWorkteamsResponse = S.suspend(() =>
  S.Struct({
    Workteams: S.optional(Workteams),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "ListWorkteamsResponse",
}) as any as S.Schema<ListWorkteamsResponse>;
export interface PutModelPackageGroupPolicyInput {
  ModelPackageGroupName?: string;
  ResourcePolicy?: string;
}
export const PutModelPackageGroupPolicyInput = S.suspend(() =>
  S.Struct({
    ModelPackageGroupName: S.optional(S.String),
    ResourcePolicy: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "PutModelPackageGroupPolicyInput",
}) as any as S.Schema<PutModelPackageGroupPolicyInput>;
export interface PutModelPackageGroupPolicyOutput {
  ModelPackageGroupArn: string;
}
export const PutModelPackageGroupPolicyOutput = S.suspend(() =>
  S.Struct({ ModelPackageGroupArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "PutModelPackageGroupPolicyOutput",
}) as any as S.Schema<PutModelPackageGroupPolicyOutput>;
export type QueryLineageStartArns = string[];
export const QueryLineageStartArns = S.Array(S.String);
export type Direction = "Both" | "Ascendants" | "Descendants" | (string & {});
export const Direction = S.String;
export type QueryTypes = string[];
export const QueryTypes = S.Array(S.String);
export type LineageType =
  | "TrialComponent"
  | "Artifact"
  | "Context"
  | "Action"
  | (string & {});
export const LineageType = S.String;
export type QueryLineageTypes = LineageType[];
export const QueryLineageTypes = S.Array(LineageType);
export type QueryProperties = { [key: string]: string | undefined };
export const QueryProperties = S.Record(S.String, S.String.pipe(S.optional));
export interface QueryFilters {
  Types?: string[];
  LineageTypes?: LineageType[];
  CreatedBefore?: Date;
  CreatedAfter?: Date;
  ModifiedBefore?: Date;
  ModifiedAfter?: Date;
  Properties?: { [key: string]: string | undefined };
}
export const QueryFilters = S.suspend(() =>
  S.Struct({
    Types: S.optional(QueryTypes),
    LineageTypes: S.optional(QueryLineageTypes),
    CreatedBefore: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ModifiedBefore: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ModifiedAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Properties: S.optional(QueryProperties),
  }),
).annotate({ identifier: "QueryFilters" }) as any as S.Schema<QueryFilters>;
export interface QueryLineageRequest {
  StartArns?: string[];
  Direction?: Direction;
  IncludeEdges?: boolean;
  Filters?: QueryFilters;
  MaxDepth?: number;
  MaxResults?: number;
  NextToken?: string;
}
export const QueryLineageRequest = S.suspend(() =>
  S.Struct({
    StartArns: S.optional(QueryLineageStartArns),
    Direction: S.optional(Direction),
    IncludeEdges: S.optional(S.Boolean),
    Filters: S.optional(QueryFilters),
    MaxDepth: S.optional(S.Number),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "QueryLineageRequest",
}) as any as S.Schema<QueryLineageRequest>;
export interface Vertex {
  Arn?: string;
  Type?: string;
  LineageType?: LineageType;
}
export const Vertex = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Type: S.optional(S.String),
    LineageType: S.optional(LineageType),
  }),
).annotate({ identifier: "Vertex" }) as any as S.Schema<Vertex>;
export type Vertices = Vertex[];
export const Vertices = S.Array(Vertex);
export interface Edge {
  SourceArn?: string;
  DestinationArn?: string;
  AssociationType?: AssociationEdgeType;
}
export const Edge = S.suspend(() =>
  S.Struct({
    SourceArn: S.optional(S.String),
    DestinationArn: S.optional(S.String),
    AssociationType: S.optional(AssociationEdgeType),
  }),
).annotate({ identifier: "Edge" }) as any as S.Schema<Edge>;
export type Edges = Edge[];
export const Edges = S.Array(Edge);
export interface QueryLineageResponse {
  Vertices?: Vertex[];
  Edges?: Edge[];
  NextToken?: string;
}
export const QueryLineageResponse = S.suspend(() =>
  S.Struct({
    Vertices: S.optional(Vertices),
    Edges: S.optional(Edges),
    NextToken: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "QueryLineageResponse",
}) as any as S.Schema<QueryLineageResponse>;
export interface Device {
  DeviceName?: string;
  Description?: string;
  IotThingName?: string;
}
export const Device = S.suspend(() =>
  S.Struct({
    DeviceName: S.optional(S.String),
    Description: S.optional(S.String),
    IotThingName: S.optional(S.String),
  }),
).annotate({ identifier: "Device" }) as any as S.Schema<Device>;
export type Devices = Device[];
export const Devices = S.Array(Device);
export interface RegisterDevicesRequest {
  DeviceFleetName?: string;
  Devices?: Device[];
  Tags?: Tag[];
}
export const RegisterDevicesRequest = S.suspend(() =>
  S.Struct({
    DeviceFleetName: S.optional(S.String),
    Devices: S.optional(Devices),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RegisterDevicesRequest",
}) as any as S.Schema<RegisterDevicesRequest>;
export interface RegisterDevicesResponse {}
export const RegisterDevicesResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "RegisterDevicesResponse",
}) as any as S.Schema<RegisterDevicesResponse>;
export interface RenderableTask {
  Input?: string;
}
export const RenderableTask = S.suspend(() =>
  S.Struct({ Input: S.optional(S.String) }),
).annotate({ identifier: "RenderableTask" }) as any as S.Schema<RenderableTask>;
export interface RenderUiTemplateRequest {
  UiTemplate?: UiTemplate;
  Task?: RenderableTask;
  RoleArn?: string;
  HumanTaskUiArn?: string;
}
export const RenderUiTemplateRequest = S.suspend(() =>
  S.Struct({
    UiTemplate: S.optional(UiTemplate),
    Task: S.optional(RenderableTask),
    RoleArn: S.optional(S.String),
    HumanTaskUiArn: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RenderUiTemplateRequest",
}) as any as S.Schema<RenderUiTemplateRequest>;
export interface RenderingError {
  Code?: string;
  Message?: string;
}
export const RenderingError = S.suspend(() =>
  S.Struct({ Code: S.optional(S.String), Message: S.optional(S.String) }),
).annotate({ identifier: "RenderingError" }) as any as S.Schema<RenderingError>;
export type RenderingErrorList = RenderingError[];
export const RenderingErrorList = S.Array(RenderingError);
export interface RenderUiTemplateResponse {
  RenderedContent: string;
  Errors: (RenderingError & { Code: string; Message: string })[];
}
export const RenderUiTemplateResponse = S.suspend(() =>
  S.Struct({
    RenderedContent: S.optional(S.String),
    Errors: S.optional(RenderingErrorList),
  }).pipe(ns),
).annotate({
  identifier: "RenderUiTemplateResponse",
}) as any as S.Schema<RenderUiTemplateResponse>;
export interface RetryPipelineExecutionRequest {
  PipelineExecutionArn?: string;
  ClientRequestToken?: string;
  ParallelismConfiguration?: ParallelismConfiguration;
}
export const RetryPipelineExecutionRequest = S.suspend(() =>
  S.Struct({
    PipelineExecutionArn: S.optional(S.String),
    ClientRequestToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    ParallelismConfiguration: S.optional(ParallelismConfiguration),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "RetryPipelineExecutionRequest",
}) as any as S.Schema<RetryPipelineExecutionRequest>;
export interface RetryPipelineExecutionResponse {
  PipelineExecutionArn?: string;
}
export const RetryPipelineExecutionResponse = S.suspend(() =>
  S.Struct({ PipelineExecutionArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "RetryPipelineExecutionResponse",
}) as any as S.Schema<RetryPipelineExecutionResponse>;
export type Operator =
  | "Equals"
  | "NotEquals"
  | "GreaterThan"
  | "GreaterThanOrEqualTo"
  | "LessThan"
  | "LessThanOrEqualTo"
  | "Contains"
  | "Exists"
  | "NotExists"
  | "In"
  | (string & {});
export const Operator = S.String;
export interface Filter {
  Name?: string;
  Operator?: Operator;
  Value?: string;
}
export const Filter = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Operator: S.optional(Operator),
    Value: S.optional(S.String),
  }),
).annotate({ identifier: "Filter" }) as any as S.Schema<Filter>;
export type FilterList = Filter[];
export const FilterList = S.Array(Filter);
export interface NestedFilters {
  NestedPropertyName?: string;
  Filters?: Filter[];
}
export const NestedFilters = S.suspend(() =>
  S.Struct({
    NestedPropertyName: S.optional(S.String),
    Filters: S.optional(FilterList),
  }),
).annotate({ identifier: "NestedFilters" }) as any as S.Schema<NestedFilters>;
export type NestedFiltersList = NestedFilters[];
export const NestedFiltersList = S.Array(NestedFilters);
export type SearchExpressionList = SearchExpression[];
export const SearchExpressionList = S.Array(
  S.suspend((): S.Schema<SearchExpression> => SearchExpression).annotate({
    identifier: "SearchExpression",
  }),
) as any as S.Schema<SearchExpressionList>;
export type BooleanOperator = "And" | "Or" | (string & {});
export const BooleanOperator = S.String;
export interface SearchExpression {
  Filters?: Filter[];
  NestedFilters?: NestedFilters[];
  SubExpressions?: SearchExpression[];
  Operator?: BooleanOperator;
}
export const SearchExpression = S.suspend(() =>
  S.Struct({
    Filters: S.optional(FilterList),
    NestedFilters: S.optional(NestedFiltersList),
    SubExpressions: S.optional(
      S.suspend(() => SearchExpressionList).annotate({
        identifier: "SearchExpressionList",
      }),
    ),
    Operator: S.optional(BooleanOperator),
  }),
).annotate({
  identifier: "SearchExpression",
}) as any as S.Schema<SearchExpression>;
export type SearchSortOrder = "Ascending" | "Descending" | (string & {});
export const SearchSortOrder = S.String;
export interface VisibilityConditions {
  Key?: string;
  Value?: string;
}
export const VisibilityConditions = S.suspend(() =>
  S.Struct({ Key: S.optional(S.String), Value: S.optional(S.String) }),
).annotate({
  identifier: "VisibilityConditions",
}) as any as S.Schema<VisibilityConditions>;
export type VisibilityConditionsList = VisibilityConditions[];
export const VisibilityConditionsList = S.Array(VisibilityConditions);
export interface SearchRequest {
  Resource?: ResourceType;
  SearchExpression?: SearchExpression;
  SortBy?: string;
  SortOrder?: SearchSortOrder;
  NextToken?: string;
  MaxResults?: number;
  CrossAccountFilterOption?: CrossAccountFilterOption;
  VisibilityConditions?: VisibilityConditions[];
}
export const SearchRequest = S.suspend(() =>
  S.Struct({
    Resource: S.optional(ResourceType),
    SearchExpression: S.optional(SearchExpression),
    SortBy: S.optional(S.String),
    SortOrder: S.optional(SearchSortOrder),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    CrossAccountFilterOption: S.optional(CrossAccountFilterOption),
    VisibilityConditions: S.optional(VisibilityConditionsList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({ identifier: "SearchRequest" }) as any as S.Schema<SearchRequest>;
export interface TrainingJob {
  TrainingJobName?: string;
  TrainingJobArn?: string;
  TuningJobArn?: string;
  LabelingJobArn?: string;
  AutoMLJobArn?: string;
  ModelArtifacts?: ModelArtifacts;
  TrainingJobStatus?: TrainingJobStatus;
  SecondaryStatus?: SecondaryStatus;
  FailureReason?: string;
  HyperParameters?: { [key: string]: string | undefined };
  AlgorithmSpecification?: AlgorithmSpecification;
  RoleArn?: string;
  InputDataConfig?: Channel[];
  OutputDataConfig?: OutputDataConfig;
  ResourceConfig?: ResourceConfig;
  VpcConfig?: VpcConfig;
  StoppingCondition?: StoppingCondition;
  CreationTime?: Date;
  TrainingStartTime?: Date;
  TrainingEndTime?: Date;
  LastModifiedTime?: Date;
  SecondaryStatusTransitions?: SecondaryStatusTransition[];
  FinalMetricDataList?: MetricData[];
  EnableNetworkIsolation?: boolean;
  EnableInterContainerTrafficEncryption?: boolean;
  EnableManagedSpotTraining?: boolean;
  CheckpointConfig?: CheckpointConfig;
  TrainingTimeInSeconds?: number;
  BillableTimeInSeconds?: number;
  DebugHookConfig?: DebugHookConfig;
  ExperimentConfig?: ExperimentConfig;
  DebugRuleConfigurations?: DebugRuleConfiguration[];
  TensorBoardOutputConfig?: TensorBoardOutputConfig;
  DebugRuleEvaluationStatuses?: DebugRuleEvaluationStatus[];
  OutputModelPackageArn?: string;
  ModelPackageConfig?: ModelPackageConfig;
  ProfilerConfig?: ProfilerConfig;
  Environment?: { [key: string]: string | undefined };
  RetryStrategy?: RetryStrategy;
  Tags?: Tag[];
}
export const TrainingJob = S.suspend(() =>
  S.Struct({
    TrainingJobName: S.optional(S.String),
    TrainingJobArn: S.optional(S.String),
    TuningJobArn: S.optional(S.String),
    LabelingJobArn: S.optional(S.String),
    AutoMLJobArn: S.optional(S.String),
    ModelArtifacts: S.optional(ModelArtifacts),
    TrainingJobStatus: S.optional(TrainingJobStatus),
    SecondaryStatus: S.optional(SecondaryStatus),
    FailureReason: S.optional(S.String),
    HyperParameters: S.optional(HyperParameters),
    AlgorithmSpecification: S.optional(AlgorithmSpecification),
    RoleArn: S.optional(S.String),
    InputDataConfig: S.optional(InputDataConfig),
    OutputDataConfig: S.optional(OutputDataConfig),
    ResourceConfig: S.optional(ResourceConfig),
    VpcConfig: S.optional(VpcConfig),
    StoppingCondition: S.optional(StoppingCondition),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    TrainingStartTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    TrainingEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SecondaryStatusTransitions: S.optional(SecondaryStatusTransitions),
    FinalMetricDataList: S.optional(FinalMetricDataList),
    EnableNetworkIsolation: S.optional(S.Boolean),
    EnableInterContainerTrafficEncryption: S.optional(S.Boolean),
    EnableManagedSpotTraining: S.optional(S.Boolean),
    CheckpointConfig: S.optional(CheckpointConfig),
    TrainingTimeInSeconds: S.optional(S.Number),
    BillableTimeInSeconds: S.optional(S.Number),
    DebugHookConfig: S.optional(DebugHookConfig),
    ExperimentConfig: S.optional(ExperimentConfig),
    DebugRuleConfigurations: S.optional(DebugRuleConfigurations),
    TensorBoardOutputConfig: S.optional(TensorBoardOutputConfig),
    DebugRuleEvaluationStatuses: S.optional(DebugRuleEvaluationStatuses),
    OutputModelPackageArn: S.optional(S.String),
    ModelPackageConfig: S.optional(ModelPackageConfig),
    ProfilerConfig: S.optional(ProfilerConfig),
    Environment: S.optional(TrainingEnvironmentMap),
    RetryStrategy: S.optional(RetryStrategy),
    Tags: S.optional(TagList),
  }),
).annotate({ identifier: "TrainingJob" }) as any as S.Schema<TrainingJob>;
export interface Experiment {
  ExperimentName?: string;
  ExperimentArn?: string;
  DisplayName?: string;
  Source?: ExperimentSource;
  Description?: string;
  CreationTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
  Tags?: Tag[];
}
export const Experiment = S.suspend(() =>
  S.Struct({
    ExperimentName: S.optional(S.String),
    ExperimentArn: S.optional(S.String),
    DisplayName: S.optional(S.String),
    Source: S.optional(ExperimentSource),
    Description: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
    Tags: S.optional(TagList),
  }),
).annotate({ identifier: "Experiment" }) as any as S.Schema<Experiment>;
export interface TrialComponentSimpleSummary {
  TrialComponentName?: string;
  TrialComponentArn?: string;
  TrialComponentSource?: TrialComponentSource;
  CreationTime?: Date;
  CreatedBy?: UserContext;
}
export const TrialComponentSimpleSummary = S.suspend(() =>
  S.Struct({
    TrialComponentName: S.optional(S.String),
    TrialComponentArn: S.optional(S.String),
    TrialComponentSource: S.optional(TrialComponentSource),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
  }),
).annotate({
  identifier: "TrialComponentSimpleSummary",
}) as any as S.Schema<TrialComponentSimpleSummary>;
export type TrialComponentSimpleSummaries = TrialComponentSimpleSummary[];
export const TrialComponentSimpleSummaries = S.Array(
  TrialComponentSimpleSummary,
);
export interface Trial {
  TrialName?: string;
  TrialArn?: string;
  DisplayName?: string;
  ExperimentName?: string;
  Source?: TrialSource;
  CreationTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
  MetadataProperties?: MetadataProperties;
  Tags?: Tag[];
  TrialComponentSummaries?: TrialComponentSimpleSummary[];
}
export const Trial = S.suspend(() =>
  S.Struct({
    TrialName: S.optional(S.String),
    TrialArn: S.optional(S.String),
    DisplayName: S.optional(S.String),
    ExperimentName: S.optional(S.String),
    Source: S.optional(TrialSource),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
    MetadataProperties: S.optional(MetadataProperties),
    Tags: S.optional(TagList),
    TrialComponentSummaries: S.optional(TrialComponentSimpleSummaries),
  }),
).annotate({ identifier: "Trial" }) as any as S.Schema<Trial>;
export interface ProcessingJob {
  ProcessingInputs?: ProcessingInput[];
  ProcessingOutputConfig?: ProcessingOutputConfig;
  ProcessingJobName?: string;
  ProcessingResources?: ProcessingResources;
  StoppingCondition?: ProcessingStoppingCondition;
  AppSpecification?: AppSpecification;
  Environment?: { [key: string]: string | undefined };
  NetworkConfig?: NetworkConfig;
  RoleArn?: string;
  ExperimentConfig?: ExperimentConfig;
  ProcessingJobArn?: string;
  ProcessingJobStatus?: ProcessingJobStatus;
  ExitMessage?: string;
  FailureReason?: string;
  ProcessingEndTime?: Date;
  ProcessingStartTime?: Date;
  LastModifiedTime?: Date;
  CreationTime?: Date;
  MonitoringScheduleArn?: string;
  AutoMLJobArn?: string;
  TrainingJobArn?: string;
  Tags?: Tag[];
}
export const ProcessingJob = S.suspend(() =>
  S.Struct({
    ProcessingInputs: S.optional(ProcessingInputs),
    ProcessingOutputConfig: S.optional(ProcessingOutputConfig),
    ProcessingJobName: S.optional(S.String),
    ProcessingResources: S.optional(ProcessingResources),
    StoppingCondition: S.optional(ProcessingStoppingCondition),
    AppSpecification: S.optional(AppSpecification),
    Environment: S.optional(ProcessingEnvironmentMap),
    NetworkConfig: S.optional(NetworkConfig),
    RoleArn: S.optional(S.String),
    ExperimentConfig: S.optional(ExperimentConfig),
    ProcessingJobArn: S.optional(S.String),
    ProcessingJobStatus: S.optional(ProcessingJobStatus),
    ExitMessage: S.optional(S.String),
    FailureReason: S.optional(S.String),
    ProcessingEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ProcessingStartTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    MonitoringScheduleArn: S.optional(S.String),
    AutoMLJobArn: S.optional(S.String),
    TrainingJobArn: S.optional(S.String),
    Tags: S.optional(TagList),
  }),
).annotate({ identifier: "ProcessingJob" }) as any as S.Schema<ProcessingJob>;
export interface TransformJob {
  TransformJobName?: string;
  TransformJobArn?: string;
  TransformJobStatus?: TransformJobStatus;
  FailureReason?: string;
  ModelName?: string;
  MaxConcurrentTransforms?: number;
  ModelClientConfig?: ModelClientConfig;
  MaxPayloadInMB?: number;
  BatchStrategy?: BatchStrategy;
  Environment?: { [key: string]: string | undefined };
  TransformInput?: TransformInput;
  TransformOutput?: TransformOutput;
  DataCaptureConfig?: BatchDataCaptureConfig;
  TransformResources?: TransformResources;
  CreationTime?: Date;
  TransformStartTime?: Date;
  TransformEndTime?: Date;
  LabelingJobArn?: string;
  AutoMLJobArn?: string;
  DataProcessing?: DataProcessing;
  ExperimentConfig?: ExperimentConfig;
  Tags?: Tag[];
}
export const TransformJob = S.suspend(() =>
  S.Struct({
    TransformJobName: S.optional(S.String),
    TransformJobArn: S.optional(S.String),
    TransformJobStatus: S.optional(TransformJobStatus),
    FailureReason: S.optional(S.String),
    ModelName: S.optional(S.String),
    MaxConcurrentTransforms: S.optional(S.Number),
    ModelClientConfig: S.optional(ModelClientConfig),
    MaxPayloadInMB: S.optional(S.Number),
    BatchStrategy: S.optional(BatchStrategy),
    Environment: S.optional(TransformEnvironmentMap),
    TransformInput: S.optional(TransformInput),
    TransformOutput: S.optional(TransformOutput),
    DataCaptureConfig: S.optional(BatchDataCaptureConfig),
    TransformResources: S.optional(TransformResources),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    TransformStartTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    TransformEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LabelingJobArn: S.optional(S.String),
    AutoMLJobArn: S.optional(S.String),
    DataProcessing: S.optional(DataProcessing),
    ExperimentConfig: S.optional(ExperimentConfig),
    Tags: S.optional(TagList),
  }),
).annotate({ identifier: "TransformJob" }) as any as S.Schema<TransformJob>;
export interface TrialComponentSourceDetail {
  SourceArn?: string;
  TrainingJob?: TrainingJob;
  ProcessingJob?: ProcessingJob;
  TransformJob?: TransformJob;
}
export const TrialComponentSourceDetail = S.suspend(() =>
  S.Struct({
    SourceArn: S.optional(S.String),
    TrainingJob: S.optional(TrainingJob),
    ProcessingJob: S.optional(ProcessingJob),
    TransformJob: S.optional(TransformJob),
  }),
).annotate({
  identifier: "TrialComponentSourceDetail",
}) as any as S.Schema<TrialComponentSourceDetail>;
export interface Parent {
  TrialName?: string;
  ExperimentName?: string;
}
export const Parent = S.suspend(() =>
  S.Struct({
    TrialName: S.optional(S.String),
    ExperimentName: S.optional(S.String),
  }),
).annotate({ identifier: "Parent" }) as any as S.Schema<Parent>;
export type Parents = Parent[];
export const Parents = S.Array(Parent);
export interface TrialComponent {
  TrialComponentName?: string;
  DisplayName?: string;
  TrialComponentArn?: string;
  Source?: TrialComponentSource;
  Status?: TrialComponentStatus;
  StartTime?: Date;
  EndTime?: Date;
  CreationTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
  Parameters?: { [key: string]: TrialComponentParameterValue | undefined };
  InputArtifacts?: { [key: string]: TrialComponentArtifact | undefined };
  OutputArtifacts?: { [key: string]: TrialComponentArtifact | undefined };
  Metrics?: TrialComponentMetricSummary[];
  MetadataProperties?: MetadataProperties;
  SourceDetail?: TrialComponentSourceDetail;
  LineageGroupArn?: string;
  Tags?: Tag[];
  Parents?: Parent[];
  RunName?: string;
}
export const TrialComponent = S.suspend(() =>
  S.Struct({
    TrialComponentName: S.optional(S.String),
    DisplayName: S.optional(S.String),
    TrialComponentArn: S.optional(S.String),
    Source: S.optional(TrialComponentSource),
    Status: S.optional(TrialComponentStatus),
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
    Parameters: S.optional(TrialComponentParameters),
    InputArtifacts: S.optional(TrialComponentArtifacts),
    OutputArtifacts: S.optional(TrialComponentArtifacts),
    Metrics: S.optional(TrialComponentMetricSummaries),
    MetadataProperties: S.optional(MetadataProperties),
    SourceDetail: S.optional(TrialComponentSourceDetail),
    LineageGroupArn: S.optional(S.String),
    Tags: S.optional(TagList),
    Parents: S.optional(Parents),
    RunName: S.optional(S.String),
  }),
).annotate({ identifier: "TrialComponent" }) as any as S.Schema<TrialComponent>;
export interface MonitoringSchedule {
  MonitoringScheduleArn?: string;
  MonitoringScheduleName?: string;
  MonitoringScheduleStatus?: ScheduleStatus;
  MonitoringType?: MonitoringType;
  FailureReason?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  MonitoringScheduleConfig?: MonitoringScheduleConfig;
  EndpointName?: string;
  LastMonitoringExecutionSummary?: MonitoringExecutionSummary;
  Tags?: Tag[];
}
export const MonitoringSchedule = S.suspend(() =>
  S.Struct({
    MonitoringScheduleArn: S.optional(S.String),
    MonitoringScheduleName: S.optional(S.String),
    MonitoringScheduleStatus: S.optional(ScheduleStatus),
    MonitoringType: S.optional(MonitoringType),
    FailureReason: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    MonitoringScheduleConfig: S.optional(MonitoringScheduleConfig),
    EndpointName: S.optional(S.String),
    LastMonitoringExecutionSummary: S.optional(MonitoringExecutionSummary),
    Tags: S.optional(TagList),
  }),
).annotate({
  identifier: "MonitoringSchedule",
}) as any as S.Schema<MonitoringSchedule>;
export type MonitoringScheduleList = MonitoringSchedule[];
export const MonitoringScheduleList = S.Array(MonitoringSchedule);
export interface Endpoint {
  EndpointName?: string;
  EndpointArn?: string;
  EndpointConfigName?: string;
  ProductionVariants?: ProductionVariantSummary[];
  DataCaptureConfig?: DataCaptureConfigSummary;
  EndpointStatus?: EndpointStatus;
  FailureReason?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  MonitoringSchedules?: MonitoringSchedule[];
  Tags?: Tag[];
  ShadowProductionVariants?: ProductionVariantSummary[];
}
export const Endpoint = S.suspend(() =>
  S.Struct({
    EndpointName: S.optional(S.String),
    EndpointArn: S.optional(S.String),
    EndpointConfigName: S.optional(S.String),
    ProductionVariants: S.optional(ProductionVariantSummaryList),
    DataCaptureConfig: S.optional(DataCaptureConfigSummary),
    EndpointStatus: S.optional(EndpointStatus),
    FailureReason: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    MonitoringSchedules: S.optional(MonitoringScheduleList),
    Tags: S.optional(TagList),
    ShadowProductionVariants: S.optional(ProductionVariantSummaryList),
  }),
).annotate({ identifier: "Endpoint" }) as any as S.Schema<Endpoint>;
export interface ModelPackage {
  ModelPackageName?: string;
  ModelPackageGroupName?: string;
  ModelPackageVersion?: number;
  ModelPackageRegistrationType?: ModelPackageRegistrationType;
  ModelPackageArn?: string;
  ModelPackageDescription?: string;
  CreationTime?: Date;
  InferenceSpecification?: InferenceSpecification;
  SourceAlgorithmSpecification?: SourceAlgorithmSpecification;
  ValidationSpecification?: ModelPackageValidationSpecification;
  ModelPackageStatus?: ModelPackageStatus;
  ModelPackageStatusDetails?: ModelPackageStatusDetails;
  CertifyForMarketplace?: boolean;
  ModelApprovalStatus?: ModelApprovalStatus;
  CreatedBy?: UserContext;
  MetadataProperties?: MetadataProperties;
  ModelMetrics?: ModelMetrics;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
  ApprovalDescription?: string;
  Domain?: string;
  Task?: string;
  SamplePayloadUrl?: string;
  AdditionalInferenceSpecifications?: AdditionalInferenceSpecificationDefinition[];
  SourceUri?: string;
  SecurityConfig?: ModelPackageSecurityConfig;
  ModelCard?: ModelPackageModelCard;
  ModelLifeCycle?: ModelLifeCycle;
  Tags?: Tag[];
  CustomerMetadataProperties?: { [key: string]: string | undefined };
  DriftCheckBaselines?: DriftCheckBaselines;
  SkipModelValidation?: SkipModelValidation;
}
export const ModelPackage = S.suspend(() =>
  S.Struct({
    ModelPackageName: S.optional(S.String),
    ModelPackageGroupName: S.optional(S.String),
    ModelPackageVersion: S.optional(S.Number),
    ModelPackageRegistrationType: S.optional(ModelPackageRegistrationType),
    ModelPackageArn: S.optional(S.String),
    ModelPackageDescription: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    InferenceSpecification: S.optional(InferenceSpecification),
    SourceAlgorithmSpecification: S.optional(SourceAlgorithmSpecification),
    ValidationSpecification: S.optional(ModelPackageValidationSpecification),
    ModelPackageStatus: S.optional(ModelPackageStatus),
    ModelPackageStatusDetails: S.optional(ModelPackageStatusDetails),
    CertifyForMarketplace: S.optional(S.Boolean),
    ModelApprovalStatus: S.optional(ModelApprovalStatus),
    CreatedBy: S.optional(UserContext),
    MetadataProperties: S.optional(MetadataProperties),
    ModelMetrics: S.optional(ModelMetrics),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
    ApprovalDescription: S.optional(S.String),
    Domain: S.optional(S.String),
    Task: S.optional(S.String),
    SamplePayloadUrl: S.optional(S.String),
    AdditionalInferenceSpecifications: S.optional(
      AdditionalInferenceSpecifications,
    ),
    SourceUri: S.optional(S.String),
    SecurityConfig: S.optional(ModelPackageSecurityConfig),
    ModelCard: S.optional(ModelPackageModelCard),
    ModelLifeCycle: S.optional(ModelLifeCycle),
    Tags: S.optional(TagList),
    CustomerMetadataProperties: S.optional(CustomerMetadataMap),
    DriftCheckBaselines: S.optional(DriftCheckBaselines),
    SkipModelValidation: S.optional(SkipModelValidation),
  }),
).annotate({ identifier: "ModelPackage" }) as any as S.Schema<ModelPackage>;
export interface ModelPackageGroup {
  ModelPackageGroupName?: string;
  ModelPackageGroupArn?: string;
  ModelPackageGroupDescription?: string;
  CreationTime?: Date;
  CreatedBy?: UserContext;
  ModelPackageGroupStatus?: ModelPackageGroupStatus;
  Tags?: Tag[];
}
export const ModelPackageGroup = S.suspend(() =>
  S.Struct({
    ModelPackageGroupName: S.optional(S.String),
    ModelPackageGroupArn: S.optional(S.String),
    ModelPackageGroupDescription: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    ModelPackageGroupStatus: S.optional(ModelPackageGroupStatus),
    Tags: S.optional(TagList),
  }),
).annotate({
  identifier: "ModelPackageGroup",
}) as any as S.Schema<ModelPackageGroup>;
export interface Pipeline {
  PipelineArn?: string;
  PipelineName?: string;
  PipelineDisplayName?: string;
  PipelineDescription?: string;
  RoleArn?: string;
  PipelineStatus?: PipelineStatus;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  LastRunTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedBy?: UserContext;
  ParallelismConfiguration?: ParallelismConfiguration;
  Tags?: Tag[];
}
export const Pipeline = S.suspend(() =>
  S.Struct({
    PipelineArn: S.optional(S.String),
    PipelineName: S.optional(S.String),
    PipelineDisplayName: S.optional(S.String),
    PipelineDescription: S.optional(S.String),
    RoleArn: S.optional(S.String),
    PipelineStatus: S.optional(PipelineStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastRunTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedBy: S.optional(UserContext),
    ParallelismConfiguration: S.optional(ParallelismConfiguration),
    Tags: S.optional(TagList),
  }),
).annotate({ identifier: "Pipeline" }) as any as S.Schema<Pipeline>;
export interface PipelineExecution {
  PipelineArn?: string;
  PipelineExecutionArn?: string;
  PipelineExecutionDisplayName?: string;
  PipelineExecutionStatus?: PipelineExecutionStatus;
  PipelineExecutionDescription?: string;
  PipelineExperimentConfig?: PipelineExperimentConfig;
  FailureReason?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedBy?: UserContext;
  ParallelismConfiguration?: ParallelismConfiguration;
  SelectiveExecutionConfig?: SelectiveExecutionConfig;
  PipelineParameters?: Parameter[];
  PipelineVersionId?: number;
  PipelineVersionDisplayName?: string;
}
export const PipelineExecution = S.suspend(() =>
  S.Struct({
    PipelineArn: S.optional(S.String),
    PipelineExecutionArn: S.optional(S.String),
    PipelineExecutionDisplayName: S.optional(S.String),
    PipelineExecutionStatus: S.optional(PipelineExecutionStatus),
    PipelineExecutionDescription: S.optional(S.String),
    PipelineExperimentConfig: S.optional(PipelineExperimentConfig),
    FailureReason: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreatedBy: S.optional(UserContext),
    LastModifiedBy: S.optional(UserContext),
    ParallelismConfiguration: S.optional(ParallelismConfiguration),
    SelectiveExecutionConfig: S.optional(SelectiveExecutionConfig),
    PipelineParameters: S.optional(ParameterList),
    PipelineVersionId: S.optional(S.Number),
    PipelineVersionDisplayName: S.optional(S.String),
  }),
).annotate({
  identifier: "PipelineExecution",
}) as any as S.Schema<PipelineExecution>;
export interface PipelineVersion {
  PipelineArn?: string;
  PipelineVersionId?: number;
  PipelineVersionDisplayName?: string;
  PipelineVersionDescription?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedBy?: UserContext;
  LastExecutedPipelineExecutionArn?: string;
  LastExecutedPipelineExecutionDisplayName?: string;
  LastExecutedPipelineExecutionStatus?: PipelineExecutionStatus;
}
export const PipelineVersion = S.suspend(() =>
  S.Struct({
    PipelineArn: S.optional(S.String),
    PipelineVersionId: S.optional(S.Number),
    PipelineVersionDisplayName: S.optional(S.String),
    PipelineVersionDescription: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreatedBy: S.optional(UserContext),
    LastModifiedBy: S.optional(UserContext),
    LastExecutedPipelineExecutionArn: S.optional(S.String),
    LastExecutedPipelineExecutionDisplayName: S.optional(S.String),
    LastExecutedPipelineExecutionStatus: S.optional(PipelineExecutionStatus),
  }),
).annotate({
  identifier: "PipelineVersion",
}) as any as S.Schema<PipelineVersion>;
export interface FeatureGroup {
  FeatureGroupArn?: string;
  FeatureGroupName?: string;
  RecordIdentifierFeatureName?: string;
  EventTimeFeatureName?: string;
  FeatureDefinitions?: FeatureDefinition[];
  CreationTime?: Date;
  LastModifiedTime?: Date;
  OnlineStoreConfig?: OnlineStoreConfig;
  OfflineStoreConfig?: OfflineStoreConfig;
  RoleArn?: string;
  FeatureGroupStatus?: FeatureGroupStatus;
  OfflineStoreStatus?: OfflineStoreStatus;
  LastUpdateStatus?: LastUpdateStatus;
  FailureReason?: string;
  Description?: string;
  Tags?: Tag[];
}
export const FeatureGroup = S.suspend(() =>
  S.Struct({
    FeatureGroupArn: S.optional(S.String),
    FeatureGroupName: S.optional(S.String),
    RecordIdentifierFeatureName: S.optional(S.String),
    EventTimeFeatureName: S.optional(S.String),
    FeatureDefinitions: S.optional(FeatureDefinitions),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    OnlineStoreConfig: S.optional(OnlineStoreConfig),
    OfflineStoreConfig: S.optional(OfflineStoreConfig),
    RoleArn: S.optional(S.String),
    FeatureGroupStatus: S.optional(FeatureGroupStatus),
    OfflineStoreStatus: S.optional(OfflineStoreStatus),
    LastUpdateStatus: S.optional(LastUpdateStatus),
    FailureReason: S.optional(S.String),
    Description: S.optional(S.String),
    Tags: S.optional(TagList),
  }),
).annotate({ identifier: "FeatureGroup" }) as any as S.Schema<FeatureGroup>;
export interface FeatureMetadata {
  FeatureGroupArn?: string;
  FeatureGroupName?: string;
  FeatureName?: string;
  FeatureType?: FeatureType;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  Description?: string;
  Parameters?: FeatureParameter[];
}
export const FeatureMetadata = S.suspend(() =>
  S.Struct({
    FeatureGroupArn: S.optional(S.String),
    FeatureGroupName: S.optional(S.String),
    FeatureName: S.optional(S.String),
    FeatureType: S.optional(FeatureType),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    Description: S.optional(S.String),
    Parameters: S.optional(FeatureParameters),
  }),
).annotate({
  identifier: "FeatureMetadata",
}) as any as S.Schema<FeatureMetadata>;
export interface Project {
  ProjectArn?: string;
  ProjectName?: string;
  ProjectId?: string;
  ProjectDescription?: string;
  ServiceCatalogProvisioningDetails?: ServiceCatalogProvisioningDetails;
  ServiceCatalogProvisionedProductDetails?: ServiceCatalogProvisionedProductDetails;
  ProjectStatus?: ProjectStatus;
  CreatedBy?: UserContext;
  CreationTime?: Date;
  TemplateProviderDetails?: TemplateProviderDetail[];
  Tags?: Tag[];
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
}
export const Project = S.suspend(() =>
  S.Struct({
    ProjectArn: S.optional(S.String),
    ProjectName: S.optional(S.String),
    ProjectId: S.optional(S.String),
    ProjectDescription: S.optional(S.String),
    ServiceCatalogProvisioningDetails: S.optional(
      ServiceCatalogProvisioningDetails,
    ),
    ServiceCatalogProvisionedProductDetails: S.optional(
      ServiceCatalogProvisionedProductDetails,
    ),
    ProjectStatus: S.optional(ProjectStatus),
    CreatedBy: S.optional(UserContext),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    TemplateProviderDetails: S.optional(TemplateProviderDetailList),
    Tags: S.optional(TagList),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
  }),
).annotate({ identifier: "Project" }) as any as S.Schema<Project>;
export interface HyperParameterTuningJobSearchEntity {
  HyperParameterTuningJobName?: string;
  HyperParameterTuningJobArn?: string;
  HyperParameterTuningJobConfig?: HyperParameterTuningJobConfig;
  TrainingJobDefinition?: HyperParameterTrainingJobDefinition;
  TrainingJobDefinitions?: HyperParameterTrainingJobDefinition[];
  HyperParameterTuningJobStatus?: HyperParameterTuningJobStatus;
  CreationTime?: Date;
  HyperParameterTuningEndTime?: Date;
  LastModifiedTime?: Date;
  TrainingJobStatusCounters?: TrainingJobStatusCounters;
  ObjectiveStatusCounters?: ObjectiveStatusCounters;
  BestTrainingJob?: HyperParameterTrainingJobSummary;
  OverallBestTrainingJob?: HyperParameterTrainingJobSummary;
  WarmStartConfig?: HyperParameterTuningJobWarmStartConfig;
  FailureReason?: string;
  TuningJobCompletionDetails?: HyperParameterTuningJobCompletionDetails;
  ConsumedResources?: HyperParameterTuningJobConsumedResources;
  Tags?: Tag[];
}
export const HyperParameterTuningJobSearchEntity = S.suspend(() =>
  S.Struct({
    HyperParameterTuningJobName: S.optional(S.String),
    HyperParameterTuningJobArn: S.optional(S.String),
    HyperParameterTuningJobConfig: S.optional(HyperParameterTuningJobConfig),
    TrainingJobDefinition: S.optional(HyperParameterTrainingJobDefinition),
    TrainingJobDefinitions: S.optional(HyperParameterTrainingJobDefinitions),
    HyperParameterTuningJobStatus: S.optional(HyperParameterTuningJobStatus),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    HyperParameterTuningEndTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    TrainingJobStatusCounters: S.optional(TrainingJobStatusCounters),
    ObjectiveStatusCounters: S.optional(ObjectiveStatusCounters),
    BestTrainingJob: S.optional(HyperParameterTrainingJobSummary),
    OverallBestTrainingJob: S.optional(HyperParameterTrainingJobSummary),
    WarmStartConfig: S.optional(HyperParameterTuningJobWarmStartConfig),
    FailureReason: S.optional(S.String),
    TuningJobCompletionDetails: S.optional(
      HyperParameterTuningJobCompletionDetails,
    ),
    ConsumedResources: S.optional(HyperParameterTuningJobConsumedResources),
    Tags: S.optional(TagList),
  }),
).annotate({
  identifier: "HyperParameterTuningJobSearchEntity",
}) as any as S.Schema<HyperParameterTuningJobSearchEntity>;
export interface ModelCard {
  ModelCardArn?: string;
  ModelCardName?: string;
  ModelCardVersion?: number;
  Content?: string | redacted.Redacted<string>;
  ModelCardStatus?: ModelCardStatus;
  SecurityConfig?: ModelCardSecurityConfig;
  CreationTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
  Tags?: Tag[];
  ModelId?: string;
  RiskRating?: string;
  ModelPackageGroupName?: string;
}
export const ModelCard = S.suspend(() =>
  S.Struct({
    ModelCardArn: S.optional(S.String),
    ModelCardName: S.optional(S.String),
    ModelCardVersion: S.optional(S.Number),
    Content: S.optional(SensitiveString),
    ModelCardStatus: S.optional(ModelCardStatus),
    SecurityConfig: S.optional(ModelCardSecurityConfig),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
    Tags: S.optional(TagList),
    ModelId: S.optional(S.String),
    RiskRating: S.optional(S.String),
    ModelPackageGroupName: S.optional(S.String),
  }),
).annotate({ identifier: "ModelCard" }) as any as S.Schema<ModelCard>;
export interface Model {
  ModelName?: string;
  PrimaryContainer?: ContainerDefinition;
  Containers?: ContainerDefinition[];
  InferenceExecutionConfig?: InferenceExecutionConfig;
  ExecutionRoleArn?: string;
  VpcConfig?: VpcConfig;
  CreationTime?: Date;
  ModelArn?: string;
  EnableNetworkIsolation?: boolean;
  Tags?: Tag[];
  DeploymentRecommendation?: DeploymentRecommendation;
}
export const Model = S.suspend(() =>
  S.Struct({
    ModelName: S.optional(S.String),
    PrimaryContainer: S.optional(ContainerDefinition),
    Containers: S.optional(ContainerDefinitionList),
    InferenceExecutionConfig: S.optional(InferenceExecutionConfig),
    ExecutionRoleArn: S.optional(S.String),
    VpcConfig: S.optional(VpcConfig),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ModelArn: S.optional(S.String),
    EnableNetworkIsolation: S.optional(S.Boolean),
    Tags: S.optional(TagList),
    DeploymentRecommendation: S.optional(DeploymentRecommendation),
  }),
).annotate({ identifier: "Model" }) as any as S.Schema<Model>;
export interface ModelDashboardEndpoint {
  EndpointName?: string;
  EndpointArn?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  EndpointStatus?: EndpointStatus;
}
export const ModelDashboardEndpoint = S.suspend(() =>
  S.Struct({
    EndpointName: S.optional(S.String),
    EndpointArn: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    EndpointStatus: S.optional(EndpointStatus),
  }),
).annotate({
  identifier: "ModelDashboardEndpoint",
}) as any as S.Schema<ModelDashboardEndpoint>;
export type ModelDashboardEndpoints = ModelDashboardEndpoint[];
export const ModelDashboardEndpoints = S.Array(ModelDashboardEndpoint);
export interface ModelDashboardMonitoringSchedule {
  MonitoringScheduleArn?: string;
  MonitoringScheduleName?: string;
  MonitoringScheduleStatus?: ScheduleStatus;
  MonitoringType?: MonitoringType;
  FailureReason?: string;
  CreationTime?: Date;
  LastModifiedTime?: Date;
  MonitoringScheduleConfig?: MonitoringScheduleConfig;
  EndpointName?: string;
  MonitoringAlertSummaries?: MonitoringAlertSummary[];
  LastMonitoringExecutionSummary?: MonitoringExecutionSummary;
  BatchTransformInput?: BatchTransformInput;
}
export const ModelDashboardMonitoringSchedule = S.suspend(() =>
  S.Struct({
    MonitoringScheduleArn: S.optional(S.String),
    MonitoringScheduleName: S.optional(S.String),
    MonitoringScheduleStatus: S.optional(ScheduleStatus),
    MonitoringType: S.optional(MonitoringType),
    FailureReason: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    MonitoringScheduleConfig: S.optional(MonitoringScheduleConfig),
    EndpointName: S.optional(S.String),
    MonitoringAlertSummaries: S.optional(MonitoringAlertSummaryList),
    LastMonitoringExecutionSummary: S.optional(MonitoringExecutionSummary),
    BatchTransformInput: S.optional(BatchTransformInput),
  }),
).annotate({
  identifier: "ModelDashboardMonitoringSchedule",
}) as any as S.Schema<ModelDashboardMonitoringSchedule>;
export type ModelDashboardMonitoringSchedules =
  ModelDashboardMonitoringSchedule[];
export const ModelDashboardMonitoringSchedules = S.Array(
  ModelDashboardMonitoringSchedule,
);
export interface ModelDashboardModelCard {
  ModelCardArn?: string;
  ModelCardName?: string;
  ModelCardVersion?: number;
  ModelCardStatus?: ModelCardStatus;
  SecurityConfig?: ModelCardSecurityConfig;
  CreationTime?: Date;
  CreatedBy?: UserContext;
  LastModifiedTime?: Date;
  LastModifiedBy?: UserContext;
  Tags?: Tag[];
  ModelId?: string;
  RiskRating?: string;
}
export const ModelDashboardModelCard = S.suspend(() =>
  S.Struct({
    ModelCardArn: S.optional(S.String),
    ModelCardName: S.optional(S.String),
    ModelCardVersion: S.optional(S.Number),
    ModelCardStatus: S.optional(ModelCardStatus),
    SecurityConfig: S.optional(ModelCardSecurityConfig),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(UserContext),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedBy: S.optional(UserContext),
    Tags: S.optional(TagList),
    ModelId: S.optional(S.String),
    RiskRating: S.optional(S.String),
  }),
).annotate({
  identifier: "ModelDashboardModelCard",
}) as any as S.Schema<ModelDashboardModelCard>;
export interface ModelDashboardModel {
  Model?: Model;
  Endpoints?: ModelDashboardEndpoint[];
  LastBatchTransformJob?: TransformJob;
  MonitoringSchedules?: ModelDashboardMonitoringSchedule[];
  ModelCard?: ModelDashboardModelCard;
}
export const ModelDashboardModel = S.suspend(() =>
  S.Struct({
    Model: S.optional(Model),
    Endpoints: S.optional(ModelDashboardEndpoints),
    LastBatchTransformJob: S.optional(TransformJob),
    MonitoringSchedules: S.optional(ModelDashboardMonitoringSchedules),
    ModelCard: S.optional(ModelDashboardModelCard),
  }),
).annotate({
  identifier: "ModelDashboardModel",
}) as any as S.Schema<ModelDashboardModel>;
export interface SearchRecord {
  TrainingJob?: TrainingJob;
  Experiment?: Experiment;
  Trial?: Trial;
  TrialComponent?: TrialComponent;
  Endpoint?: Endpoint;
  ModelPackage?: ModelPackage;
  ModelPackageGroup?: ModelPackageGroup;
  Pipeline?: Pipeline;
  PipelineExecution?: PipelineExecution;
  PipelineVersion?: PipelineVersion;
  FeatureGroup?: FeatureGroup;
  FeatureMetadata?: FeatureMetadata;
  Project?: Project;
  HyperParameterTuningJob?: HyperParameterTuningJobSearchEntity;
  ModelCard?: ModelCard;
  Model?: ModelDashboardModel;
}
export const SearchRecord = S.suspend(() =>
  S.Struct({
    TrainingJob: S.optional(TrainingJob),
    Experiment: S.optional(Experiment),
    Trial: S.optional(Trial),
    TrialComponent: S.optional(TrialComponent),
    Endpoint: S.optional(Endpoint),
    ModelPackage: S.optional(ModelPackage),
    ModelPackageGroup: S.optional(ModelPackageGroup),
    Pipeline: S.optional(Pipeline),
    PipelineExecution: S.optional(PipelineExecution),
    PipelineVersion: S.optional(PipelineVersion),
    FeatureGroup: S.optional(FeatureGroup),
    FeatureMetadata: S.optional(FeatureMetadata),
    Project: S.optional(Project),
    HyperParameterTuningJob: S.optional(HyperParameterTuningJobSearchEntity),
    ModelCard: S.optional(ModelCard),
    Model: S.optional(ModelDashboardModel),
  }),
).annotate({ identifier: "SearchRecord" }) as any as S.Schema<SearchRecord>;
export type SearchResultsList = SearchRecord[];
export const SearchResultsList = S.Array(SearchRecord);
export type Relation = "EqualTo" | "GreaterThanOrEqualTo" | (string & {});
export const Relation = S.String;
export interface TotalHits {
  Value?: number;
  Relation?: Relation;
}
export const TotalHits = S.suspend(() =>
  S.Struct({ Value: S.optional(S.Number), Relation: S.optional(Relation) }),
).annotate({ identifier: "TotalHits" }) as any as S.Schema<TotalHits>;
export interface SearchResponse {
  Results?: (SearchRecord & {
    TrainingJob: TrainingJob & {
      ModelArtifacts: ModelArtifacts & { S3ModelArtifacts: S3Uri };
      AlgorithmSpecification: AlgorithmSpecification & {
        TrainingInputMode: TrainingInputMode;
        MetricDefinitions: (MetricDefinition & {
          Name: MetricName;
          Regex: MetricRegex;
        })[];
        TrainingImageConfig: TrainingImageConfig & {
          TrainingRepositoryAccessMode: TrainingRepositoryAccessMode;
          TrainingRepositoryAuthConfig: TrainingRepositoryAuthConfig & {
            TrainingRepositoryCredentialsProviderArn: TrainingRepositoryCredentialsProviderArn;
          };
        };
      };
      InputDataConfig: (Channel & {
        ChannelName: ChannelName;
        DataSource: DataSource & {
          S3DataSource: S3DataSource & {
            S3DataType: S3DataType;
            S3Uri: S3Uri;
            ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
            HubAccessConfig: HubAccessConfig & { HubContentArn: HubContentArn };
          };
          FileSystemDataSource: FileSystemDataSource & {
            FileSystemId: FileSystemId;
            FileSystemAccessMode: FileSystemAccessMode;
            FileSystemType: FileSystemType;
            DirectoryPath: DirectoryPath;
          };
        };
        ShuffleConfig: ShuffleConfig & { Seed: Seed };
      })[];
      OutputDataConfig: OutputDataConfig & { S3OutputPath: S3Uri };
      ResourceConfig: ResourceConfig & {
        InstanceGroups: (InstanceGroup & {
          InstanceType: TrainingInstanceType;
          InstanceCount: TrainingInstanceCount;
          InstanceGroupName: InstanceGroupName;
        })[];
        InstancePlacementConfig: InstancePlacementConfig & {
          PlacementSpecifications: (PlacementSpecification & {
            InstanceCount: TrainingInstanceCount;
          })[];
        };
      };
      VpcConfig: VpcConfig & {
        SecurityGroupIds: VpcSecurityGroupIds;
        Subnets: Subnets;
      };
      SecondaryStatusTransitions: (SecondaryStatusTransition & {
        Status: SecondaryStatus;
        StartTime: Date;
      })[];
      CheckpointConfig: CheckpointConfig & { S3Uri: S3Uri };
      DebugHookConfig: DebugHookConfig & { S3OutputPath: S3Uri };
      DebugRuleConfigurations: (DebugRuleConfiguration & {
        RuleConfigurationName: RuleConfigurationName;
        RuleEvaluatorImage: AlgorithmImage;
      })[];
      TensorBoardOutputConfig: TensorBoardOutputConfig & {
        S3OutputPath: S3Uri;
      };
      RetryStrategy: RetryStrategy & {
        MaximumRetryAttempts: MaximumRetryAttempts;
      };
      Tags: (Tag & { Key: TagKey; Value: TagValue })[];
    };
    Experiment: Experiment & {
      Source: ExperimentSource & { SourceArn: ExperimentSourceArn };
      Tags: (Tag & { Key: TagKey; Value: TagValue })[];
    };
    Trial: Trial & {
      Source: TrialSource & { SourceArn: TrialSourceArn };
      Tags: (Tag & { Key: TagKey; Value: TagValue })[];
      TrialComponentSummaries: (TrialComponentSimpleSummary & {
        TrialComponentSource: TrialComponentSource & {
          SourceArn: TrialComponentSourceArn;
        };
      })[];
    };
    TrialComponent: TrialComponent & {
      Source: TrialComponentSource & { SourceArn: TrialComponentSourceArn };
      InputArtifacts: {
        [key: string]:
          | (TrialComponentArtifact & { Value: TrialComponentArtifactValue })
          | undefined;
      };
      OutputArtifacts: {
        [key: string]:
          | (TrialComponentArtifact & { Value: TrialComponentArtifactValue })
          | undefined;
      };
      SourceDetail: TrialComponentSourceDetail & {
        TrainingJob: TrainingJob & {
          ModelArtifacts: ModelArtifacts & { S3ModelArtifacts: S3Uri };
          AlgorithmSpecification: AlgorithmSpecification & {
            TrainingInputMode: TrainingInputMode;
            MetricDefinitions: (MetricDefinition & {
              Name: MetricName;
              Regex: MetricRegex;
            })[];
            TrainingImageConfig: TrainingImageConfig & {
              TrainingRepositoryAccessMode: TrainingRepositoryAccessMode;
              TrainingRepositoryAuthConfig: TrainingRepositoryAuthConfig & {
                TrainingRepositoryCredentialsProviderArn: TrainingRepositoryCredentialsProviderArn;
              };
            };
          };
          InputDataConfig: (Channel & {
            ChannelName: ChannelName;
            DataSource: DataSource & {
              S3DataSource: S3DataSource & {
                S3DataType: S3DataType;
                S3Uri: S3Uri;
                ModelAccessConfig: ModelAccessConfig & {
                  AcceptEula: AcceptEula;
                };
                HubAccessConfig: HubAccessConfig & {
                  HubContentArn: HubContentArn;
                };
              };
              FileSystemDataSource: FileSystemDataSource & {
                FileSystemId: FileSystemId;
                FileSystemAccessMode: FileSystemAccessMode;
                FileSystemType: FileSystemType;
                DirectoryPath: DirectoryPath;
              };
            };
            ShuffleConfig: ShuffleConfig & { Seed: Seed };
          })[];
          OutputDataConfig: OutputDataConfig & { S3OutputPath: S3Uri };
          ResourceConfig: ResourceConfig & {
            InstanceGroups: (InstanceGroup & {
              InstanceType: TrainingInstanceType;
              InstanceCount: TrainingInstanceCount;
              InstanceGroupName: InstanceGroupName;
            })[];
            InstancePlacementConfig: InstancePlacementConfig & {
              PlacementSpecifications: (PlacementSpecification & {
                InstanceCount: TrainingInstanceCount;
              })[];
            };
          };
          VpcConfig: VpcConfig & {
            SecurityGroupIds: VpcSecurityGroupIds;
            Subnets: Subnets;
          };
          SecondaryStatusTransitions: (SecondaryStatusTransition & {
            Status: SecondaryStatus;
            StartTime: Date;
          })[];
          CheckpointConfig: CheckpointConfig & { S3Uri: S3Uri };
          DebugHookConfig: DebugHookConfig & { S3OutputPath: S3Uri };
          DebugRuleConfigurations: (DebugRuleConfiguration & {
            RuleConfigurationName: RuleConfigurationName;
            RuleEvaluatorImage: AlgorithmImage;
          })[];
          TensorBoardOutputConfig: TensorBoardOutputConfig & {
            S3OutputPath: S3Uri;
          };
          RetryStrategy: RetryStrategy & {
            MaximumRetryAttempts: MaximumRetryAttempts;
          };
          Tags: (Tag & { Key: TagKey; Value: TagValue })[];
        };
        ProcessingJob: ProcessingJob & {
          ProcessingInputs: (ProcessingInput & {
            InputName: string;
            S3Input: ProcessingS3Input & {
              S3Uri: S3Uri;
              S3DataType: ProcessingS3DataType;
            };
            DatasetDefinition: DatasetDefinition & {
              AthenaDatasetDefinition: AthenaDatasetDefinition & {
                Catalog: AthenaCatalog;
                Database: AthenaDatabase;
                QueryString: AthenaQueryString;
                OutputS3Uri: S3Uri;
                OutputFormat: AthenaResultFormat;
              };
              RedshiftDatasetDefinition: RedshiftDatasetDefinition & {
                ClusterId: RedshiftClusterId;
                Database: RedshiftDatabase;
                DbUser: RedshiftUserName;
                QueryString: RedshiftQueryString;
                ClusterRoleArn: RoleArn;
                OutputS3Uri: S3Uri;
                OutputFormat: RedshiftResultFormat;
              };
            };
          })[];
          ProcessingOutputConfig: ProcessingOutputConfig & {
            Outputs: (ProcessingOutput & {
              OutputName: string;
              S3Output: ProcessingS3Output & {
                S3Uri: S3Uri;
                S3UploadMode: ProcessingS3UploadMode;
              };
              FeatureStoreOutput: ProcessingFeatureStoreOutput & {
                FeatureGroupName: FeatureGroupName;
              };
            })[];
          };
          ProcessingResources: ProcessingResources & {
            ClusterConfig: ProcessingClusterConfig & {
              InstanceCount: ProcessingInstanceCount;
              InstanceType: ProcessingInstanceType;
              VolumeSizeInGB: ProcessingVolumeSizeInGB;
            };
          };
          StoppingCondition: ProcessingStoppingCondition & {
            MaxRuntimeInSeconds: ProcessingMaxRuntimeInSeconds;
          };
          AppSpecification: AppSpecification & { ImageUri: ImageUri };
          NetworkConfig: NetworkConfig & {
            VpcConfig: VpcConfig & {
              SecurityGroupIds: VpcSecurityGroupIds;
              Subnets: Subnets;
            };
          };
          Tags: (Tag & { Key: TagKey; Value: TagValue })[];
        };
        TransformJob: TransformJob & {
          TransformInput: TransformInput & {
            DataSource: TransformDataSource & {
              S3DataSource: TransformS3DataSource & {
                S3DataType: S3DataType;
                S3Uri: S3Uri;
              };
            };
          };
          TransformOutput: TransformOutput & { S3OutputPath: S3Uri };
          DataCaptureConfig: BatchDataCaptureConfig & {
            DestinationS3Uri: S3Uri;
          };
          TransformResources: TransformResources & {
            InstanceType: TransformInstanceType;
            InstanceCount: TransformInstanceCount;
          };
          Tags: (Tag & { Key: TagKey; Value: TagValue })[];
        };
      };
      Tags: (Tag & { Key: TagKey; Value: TagValue })[];
    };
    Endpoint: Endpoint & {
      EndpointName: EndpointName;
      EndpointArn: EndpointArn;
      EndpointConfigName: EndpointConfigName;
      EndpointStatus: EndpointStatus;
      CreationTime: Date;
      LastModifiedTime: Date;
      ProductionVariants: (ProductionVariantSummary & {
        VariantName: VariantName;
        VariantStatus: (ProductionVariantStatus & { Status: VariantStatus })[];
        CurrentServerlessConfig: ProductionVariantServerlessConfig & {
          MemorySizeInMB: ServerlessMemorySizeInMB;
          MaxConcurrency: ServerlessMaxConcurrency;
        };
        DesiredServerlessConfig: ProductionVariantServerlessConfig & {
          MemorySizeInMB: ServerlessMemorySizeInMB;
          MaxConcurrency: ServerlessMaxConcurrency;
        };
        RoutingConfig: ProductionVariantRoutingConfig & {
          RoutingStrategy: RoutingStrategy;
        };
      })[];
      DataCaptureConfig: DataCaptureConfigSummary & {
        EnableCapture: EnableCapture;
        CaptureStatus: CaptureStatus;
        CurrentSamplingPercentage: SamplingPercentage;
        DestinationS3Uri: DestinationS3Uri;
        KmsKeyId: KmsKeyId;
      };
      MonitoringSchedules: (MonitoringSchedule & {
        MonitoringScheduleConfig: MonitoringScheduleConfig & {
          ScheduleConfig: ScheduleConfig & {
            ScheduleExpression: ScheduleExpression;
          };
          MonitoringJobDefinition: MonitoringJobDefinition & {
            MonitoringInputs: (MonitoringInput & {
              EndpointInput: EndpointInput & {
                EndpointName: EndpointName;
                LocalPath: ProcessingLocalPath;
              };
              BatchTransformInput: BatchTransformInput & {
                DataCapturedDestinationS3Uri: DestinationS3Uri;
                DatasetFormat: MonitoringDatasetFormat;
                LocalPath: ProcessingLocalPath;
              };
            })[];
            MonitoringOutputConfig: MonitoringOutputConfig & {
              MonitoringOutputs: (MonitoringOutput & {
                S3Output: MonitoringS3Output & {
                  S3Uri: MonitoringS3Uri;
                  LocalPath: ProcessingLocalPath;
                };
              })[];
            };
            MonitoringResources: MonitoringResources & {
              ClusterConfig: MonitoringClusterConfig & {
                InstanceCount: ProcessingInstanceCount;
                InstanceType: ProcessingInstanceType;
                VolumeSizeInGB: ProcessingVolumeSizeInGB;
              };
            };
            MonitoringAppSpecification: MonitoringAppSpecification & {
              ImageUri: ImageUri;
            };
            RoleArn: RoleArn;
            StoppingCondition: MonitoringStoppingCondition & {
              MaxRuntimeInSeconds: MonitoringMaxRuntimeInSeconds;
            };
            NetworkConfig: NetworkConfig & {
              VpcConfig: VpcConfig & {
                SecurityGroupIds: VpcSecurityGroupIds;
                Subnets: Subnets;
              };
            };
          };
        };
        LastMonitoringExecutionSummary: MonitoringExecutionSummary & {
          MonitoringScheduleName: MonitoringScheduleName;
          ScheduledTime: Date;
          CreationTime: Date;
          LastModifiedTime: Date;
          MonitoringExecutionStatus: ExecutionStatus;
        };
        Tags: (Tag & { Key: TagKey; Value: TagValue })[];
      })[];
      Tags: (Tag & { Key: TagKey; Value: TagValue })[];
      ShadowProductionVariants: (ProductionVariantSummary & {
        VariantName: VariantName;
        VariantStatus: (ProductionVariantStatus & { Status: VariantStatus })[];
        CurrentServerlessConfig: ProductionVariantServerlessConfig & {
          MemorySizeInMB: ServerlessMemorySizeInMB;
          MaxConcurrency: ServerlessMaxConcurrency;
        };
        DesiredServerlessConfig: ProductionVariantServerlessConfig & {
          MemorySizeInMB: ServerlessMemorySizeInMB;
          MaxConcurrency: ServerlessMaxConcurrency;
        };
        RoutingConfig: ProductionVariantRoutingConfig & {
          RoutingStrategy: RoutingStrategy;
        };
      })[];
    };
    ModelPackage: ModelPackage & {
      InferenceSpecification: InferenceSpecification & {
        Containers: (ModelPackageContainerDefinition & {
          ModelDataSource: ModelDataSource & {
            S3DataSource: S3ModelDataSource & {
              S3Uri: S3ModelUri;
              S3DataType: S3ModelDataType;
              CompressionType: ModelCompressionType;
              ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
              HubAccessConfig: InferenceHubAccessConfig & {
                HubContentArn: HubContentArn;
              };
            };
          };
          ModelInput: ModelInput & { DataInputConfig: DataInputConfig };
          AdditionalS3DataSource: AdditionalS3DataSource & {
            S3DataType: AdditionalS3DataSourceDataType;
            S3Uri: S3Uri;
          };
        })[];
      };
      SourceAlgorithmSpecification: SourceAlgorithmSpecification & {
        SourceAlgorithms: (SourceAlgorithm & {
          AlgorithmName: ArnOrName;
          ModelDataSource: ModelDataSource & {
            S3DataSource: S3ModelDataSource & {
              S3Uri: S3ModelUri;
              S3DataType: S3ModelDataType;
              CompressionType: ModelCompressionType;
              ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
              HubAccessConfig: InferenceHubAccessConfig & {
                HubContentArn: HubContentArn;
              };
            };
          };
        })[];
      };
      ValidationSpecification: ModelPackageValidationSpecification & {
        ValidationRole: RoleArn;
        ValidationProfiles: (ModelPackageValidationProfile & {
          ProfileName: EntityName;
          TransformJobDefinition: TransformJobDefinition & {
            TransformInput: TransformInput & {
              DataSource: TransformDataSource & {
                S3DataSource: TransformS3DataSource & {
                  S3DataType: S3DataType;
                  S3Uri: S3Uri;
                };
              };
            };
            TransformOutput: TransformOutput & { S3OutputPath: S3Uri };
            TransformResources: TransformResources & {
              InstanceType: TransformInstanceType;
              InstanceCount: TransformInstanceCount;
            };
          };
        })[];
      };
      ModelPackageStatusDetails: ModelPackageStatusDetails & {
        ValidationStatuses: (ModelPackageStatusItem & {
          Name: EntityName;
          Status: DetailedModelPackageStatus;
        })[];
        ImageScanStatuses: (ModelPackageStatusItem & {
          Name: EntityName;
          Status: DetailedModelPackageStatus;
        })[];
      };
      ModelMetrics: ModelMetrics & {
        ModelQuality: ModelQuality & {
          Statistics: MetricsSource & {
            ContentType: ContentType;
            S3Uri: S3Uri;
          };
          Constraints: MetricsSource & {
            ContentType: ContentType;
            S3Uri: S3Uri;
          };
        };
        ModelDataQuality: ModelDataQuality & {
          Statistics: MetricsSource & {
            ContentType: ContentType;
            S3Uri: S3Uri;
          };
          Constraints: MetricsSource & {
            ContentType: ContentType;
            S3Uri: S3Uri;
          };
        };
        Bias: Bias & {
          Report: MetricsSource & { ContentType: ContentType; S3Uri: S3Uri };
          PreTrainingReport: MetricsSource & {
            ContentType: ContentType;
            S3Uri: S3Uri;
          };
          PostTrainingReport: MetricsSource & {
            ContentType: ContentType;
            S3Uri: S3Uri;
          };
        };
        Explainability: Explainability & {
          Report: MetricsSource & { ContentType: ContentType; S3Uri: S3Uri };
        };
      };
      AdditionalInferenceSpecifications: (AdditionalInferenceSpecificationDefinition & {
        Name: EntityName;
        Containers: (ModelPackageContainerDefinition & {
          ModelDataSource: ModelDataSource & {
            S3DataSource: S3ModelDataSource & {
              S3Uri: S3ModelUri;
              S3DataType: S3ModelDataType;
              CompressionType: ModelCompressionType;
              ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
              HubAccessConfig: InferenceHubAccessConfig & {
                HubContentArn: HubContentArn;
              };
            };
          };
          ModelInput: ModelInput & { DataInputConfig: DataInputConfig };
          AdditionalS3DataSource: AdditionalS3DataSource & {
            S3DataType: AdditionalS3DataSourceDataType;
            S3Uri: S3Uri;
          };
        })[];
      })[];
      SecurityConfig: ModelPackageSecurityConfig & { KmsKeyId: KmsKeyId };
      ModelLifeCycle: ModelLifeCycle & {
        Stage: EntityName;
        StageStatus: EntityName;
      };
      Tags: (Tag & { Key: TagKey; Value: TagValue })[];
      DriftCheckBaselines: DriftCheckBaselines & {
        Bias: DriftCheckBias & {
          ConfigFile: FileSource & { S3Uri: S3Uri };
          PreTrainingConstraints: MetricsSource & {
            ContentType: ContentType;
            S3Uri: S3Uri;
          };
          PostTrainingConstraints: MetricsSource & {
            ContentType: ContentType;
            S3Uri: S3Uri;
          };
        };
        Explainability: DriftCheckExplainability & {
          Constraints: MetricsSource & {
            ContentType: ContentType;
            S3Uri: S3Uri;
          };
          ConfigFile: FileSource & { S3Uri: S3Uri };
        };
        ModelQuality: DriftCheckModelQuality & {
          Statistics: MetricsSource & {
            ContentType: ContentType;
            S3Uri: S3Uri;
          };
          Constraints: MetricsSource & {
            ContentType: ContentType;
            S3Uri: S3Uri;
          };
        };
        ModelDataQuality: DriftCheckModelDataQuality & {
          Statistics: MetricsSource & {
            ContentType: ContentType;
            S3Uri: S3Uri;
          };
          Constraints: MetricsSource & {
            ContentType: ContentType;
            S3Uri: S3Uri;
          };
        };
      };
    };
    ModelPackageGroup: ModelPackageGroup & {
      Tags: (Tag & { Key: TagKey; Value: TagValue })[];
    };
    Pipeline: Pipeline & {
      ParallelismConfiguration: ParallelismConfiguration & {
        MaxParallelExecutionSteps: MaxParallelExecutionSteps;
      };
      Tags: (Tag & { Key: TagKey; Value: TagValue })[];
    };
    PipelineExecution: PipelineExecution & {
      ParallelismConfiguration: ParallelismConfiguration & {
        MaxParallelExecutionSteps: MaxParallelExecutionSteps;
      };
      SelectiveExecutionConfig: SelectiveExecutionConfig & {
        SelectedSteps: (SelectedStep & { StepName: String256 })[];
      };
      PipelineParameters: (Parameter & {
        Name: PipelineParameterName;
        Value: String1024;
      })[];
    };
    FeatureGroup: FeatureGroup & {
      FeatureDefinitions: (FeatureDefinition & {
        FeatureName: FeatureName;
        FeatureType: FeatureType;
      })[];
      OfflineStoreConfig: OfflineStoreConfig & {
        S3StorageConfig: S3StorageConfig & { S3Uri: S3Uri };
        DataCatalogConfig: DataCatalogConfig & {
          TableName: TableName;
          Catalog: Catalog;
          Database: Database;
        };
      };
      OfflineStoreStatus: OfflineStoreStatus & {
        Status: OfflineStoreStatusValue;
      };
      LastUpdateStatus: LastUpdateStatus & { Status: LastUpdateStatusValue };
      Tags: (Tag & { Key: TagKey; Value: TagValue })[];
    };
    Project: Project & {
      ServiceCatalogProvisioningDetails: ServiceCatalogProvisioningDetails & {
        ProductId: ServiceCatalogEntityId;
      };
      TemplateProviderDetails: (TemplateProviderDetail & {
        CfnTemplateProviderDetail: CfnTemplateProviderDetail & {
          TemplateName: CfnTemplateName;
          TemplateURL: CfnTemplateURL;
          Parameters: (CfnStackParameter & { Key: CfnStackParameterKey })[];
          StackDetail: CfnStackDetail & {
            StatusMessage: CfnStackStatusMessage;
          };
        };
      })[];
      Tags: (Tag & { Key: TagKey; Value: TagValue })[];
    };
    HyperParameterTuningJob: HyperParameterTuningJobSearchEntity & {
      HyperParameterTuningJobConfig: HyperParameterTuningJobConfig & {
        Strategy: HyperParameterTuningJobStrategyType;
        ResourceLimits: ResourceLimits & {
          MaxParallelTrainingJobs: MaxParallelTrainingJobs;
        };
        HyperParameterTuningJobObjective: HyperParameterTuningJobObjective & {
          Type: HyperParameterTuningJobObjectiveType;
          MetricName: MetricName;
        };
        ParameterRanges: ParameterRanges & {
          IntegerParameterRanges: (IntegerParameterRange & {
            Name: ParameterKey;
            MinValue: ParameterValue;
            MaxValue: ParameterValue;
          })[];
          ContinuousParameterRanges: (ContinuousParameterRange & {
            Name: ParameterKey;
            MinValue: ParameterValue;
            MaxValue: ParameterValue;
          })[];
          CategoricalParameterRanges: (CategoricalParameterRange & {
            Name: ParameterKey;
            Values: ParameterValues;
          })[];
          AutoParameters: (AutoParameter & {
            Name: ParameterKey;
            ValueHint: ParameterValue;
          })[];
        };
      };
      TrainingJobDefinition: HyperParameterTrainingJobDefinition & {
        AlgorithmSpecification: HyperParameterAlgorithmSpecification & {
          TrainingInputMode: TrainingInputMode;
          MetricDefinitions: (MetricDefinition & {
            Name: MetricName;
            Regex: MetricRegex;
          })[];
        };
        RoleArn: RoleArn;
        OutputDataConfig: OutputDataConfig & { S3OutputPath: S3Uri };
        StoppingCondition: StoppingCondition;
        TuningObjective: HyperParameterTuningJobObjective & {
          Type: HyperParameterTuningJobObjectiveType;
          MetricName: MetricName;
        };
        HyperParameterRanges: ParameterRanges & {
          IntegerParameterRanges: (IntegerParameterRange & {
            Name: ParameterKey;
            MinValue: ParameterValue;
            MaxValue: ParameterValue;
          })[];
          ContinuousParameterRanges: (ContinuousParameterRange & {
            Name: ParameterKey;
            MinValue: ParameterValue;
            MaxValue: ParameterValue;
          })[];
          CategoricalParameterRanges: (CategoricalParameterRange & {
            Name: ParameterKey;
            Values: ParameterValues;
          })[];
          AutoParameters: (AutoParameter & {
            Name: ParameterKey;
            ValueHint: ParameterValue;
          })[];
        };
        InputDataConfig: (Channel & {
          ChannelName: ChannelName;
          DataSource: DataSource & {
            S3DataSource: S3DataSource & {
              S3DataType: S3DataType;
              S3Uri: S3Uri;
              ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
              HubAccessConfig: HubAccessConfig & {
                HubContentArn: HubContentArn;
              };
            };
            FileSystemDataSource: FileSystemDataSource & {
              FileSystemId: FileSystemId;
              FileSystemAccessMode: FileSystemAccessMode;
              FileSystemType: FileSystemType;
              DirectoryPath: DirectoryPath;
            };
          };
          ShuffleConfig: ShuffleConfig & { Seed: Seed };
        })[];
        VpcConfig: VpcConfig & {
          SecurityGroupIds: VpcSecurityGroupIds;
          Subnets: Subnets;
        };
        ResourceConfig: ResourceConfig & {
          InstanceGroups: (InstanceGroup & {
            InstanceType: TrainingInstanceType;
            InstanceCount: TrainingInstanceCount;
            InstanceGroupName: InstanceGroupName;
          })[];
          InstancePlacementConfig: InstancePlacementConfig & {
            PlacementSpecifications: (PlacementSpecification & {
              InstanceCount: TrainingInstanceCount;
            })[];
          };
        };
        HyperParameterTuningResourceConfig: HyperParameterTuningResourceConfig & {
          InstanceConfigs: (HyperParameterTuningInstanceConfig & {
            InstanceType: TrainingInstanceType;
            InstanceCount: TrainingInstanceCount;
            VolumeSizeInGB: VolumeSizeInGB;
          })[];
        };
        CheckpointConfig: CheckpointConfig & { S3Uri: S3Uri };
        RetryStrategy: RetryStrategy & {
          MaximumRetryAttempts: MaximumRetryAttempts;
        };
      };
      TrainingJobDefinitions: (HyperParameterTrainingJobDefinition & {
        AlgorithmSpecification: HyperParameterAlgorithmSpecification & {
          TrainingInputMode: TrainingInputMode;
          MetricDefinitions: (MetricDefinition & {
            Name: MetricName;
            Regex: MetricRegex;
          })[];
        };
        RoleArn: RoleArn;
        OutputDataConfig: OutputDataConfig & { S3OutputPath: S3Uri };
        StoppingCondition: StoppingCondition;
        TuningObjective: HyperParameterTuningJobObjective & {
          Type: HyperParameterTuningJobObjectiveType;
          MetricName: MetricName;
        };
        HyperParameterRanges: ParameterRanges & {
          IntegerParameterRanges: (IntegerParameterRange & {
            Name: ParameterKey;
            MinValue: ParameterValue;
            MaxValue: ParameterValue;
          })[];
          ContinuousParameterRanges: (ContinuousParameterRange & {
            Name: ParameterKey;
            MinValue: ParameterValue;
            MaxValue: ParameterValue;
          })[];
          CategoricalParameterRanges: (CategoricalParameterRange & {
            Name: ParameterKey;
            Values: ParameterValues;
          })[];
          AutoParameters: (AutoParameter & {
            Name: ParameterKey;
            ValueHint: ParameterValue;
          })[];
        };
        InputDataConfig: (Channel & {
          ChannelName: ChannelName;
          DataSource: DataSource & {
            S3DataSource: S3DataSource & {
              S3DataType: S3DataType;
              S3Uri: S3Uri;
              ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
              HubAccessConfig: HubAccessConfig & {
                HubContentArn: HubContentArn;
              };
            };
            FileSystemDataSource: FileSystemDataSource & {
              FileSystemId: FileSystemId;
              FileSystemAccessMode: FileSystemAccessMode;
              FileSystemType: FileSystemType;
              DirectoryPath: DirectoryPath;
            };
          };
          ShuffleConfig: ShuffleConfig & { Seed: Seed };
        })[];
        VpcConfig: VpcConfig & {
          SecurityGroupIds: VpcSecurityGroupIds;
          Subnets: Subnets;
        };
        ResourceConfig: ResourceConfig & {
          InstanceGroups: (InstanceGroup & {
            InstanceType: TrainingInstanceType;
            InstanceCount: TrainingInstanceCount;
            InstanceGroupName: InstanceGroupName;
          })[];
          InstancePlacementConfig: InstancePlacementConfig & {
            PlacementSpecifications: (PlacementSpecification & {
              InstanceCount: TrainingInstanceCount;
            })[];
          };
        };
        HyperParameterTuningResourceConfig: HyperParameterTuningResourceConfig & {
          InstanceConfigs: (HyperParameterTuningInstanceConfig & {
            InstanceType: TrainingInstanceType;
            InstanceCount: TrainingInstanceCount;
            VolumeSizeInGB: VolumeSizeInGB;
          })[];
        };
        CheckpointConfig: CheckpointConfig & { S3Uri: S3Uri };
        RetryStrategy: RetryStrategy & {
          MaximumRetryAttempts: MaximumRetryAttempts;
        };
      })[];
      BestTrainingJob: HyperParameterTrainingJobSummary & {
        TrainingJobName: TrainingJobName;
        TrainingJobArn: TrainingJobArn;
        CreationTime: Date;
        TrainingJobStatus: TrainingJobStatus;
        TunedHyperParameters: HyperParameters;
        FinalHyperParameterTuningJobObjectiveMetric: FinalHyperParameterTuningJobObjectiveMetric & {
          MetricName: MetricName;
          Value: MetricValue;
        };
      };
      OverallBestTrainingJob: HyperParameterTrainingJobSummary & {
        TrainingJobName: TrainingJobName;
        TrainingJobArn: TrainingJobArn;
        CreationTime: Date;
        TrainingJobStatus: TrainingJobStatus;
        TunedHyperParameters: HyperParameters;
        FinalHyperParameterTuningJobObjectiveMetric: FinalHyperParameterTuningJobObjectiveMetric & {
          MetricName: MetricName;
          Value: MetricValue;
        };
      };
      WarmStartConfig: HyperParameterTuningJobWarmStartConfig & {
        ParentHyperParameterTuningJobs: ParentHyperParameterTuningJobs;
        WarmStartType: HyperParameterTuningJobWarmStartType;
      };
      Tags: (Tag & { Key: TagKey; Value: TagValue })[];
    };
    ModelCard: ModelCard & { Tags: (Tag & { Key: TagKey; Value: TagValue })[] };
    Model: ModelDashboardModel & {
      Model: Model & {
        PrimaryContainer: ContainerDefinition & {
          ImageConfig: ImageConfig & {
            RepositoryAccessMode: RepositoryAccessMode;
            RepositoryAuthConfig: RepositoryAuthConfig & {
              RepositoryCredentialsProviderArn: RepositoryCredentialsProviderArn;
            };
          };
          ModelDataSource: ModelDataSource & {
            S3DataSource: S3ModelDataSource & {
              S3Uri: S3ModelUri;
              S3DataType: S3ModelDataType;
              CompressionType: ModelCompressionType;
              ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
              HubAccessConfig: InferenceHubAccessConfig & {
                HubContentArn: HubContentArn;
              };
            };
          };
          AdditionalModelDataSources: (AdditionalModelDataSource & {
            ChannelName: AdditionalModelChannelName;
            S3DataSource: S3ModelDataSource & {
              S3Uri: S3ModelUri;
              S3DataType: S3ModelDataType;
              CompressionType: ModelCompressionType;
              ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
              HubAccessConfig: InferenceHubAccessConfig & {
                HubContentArn: HubContentArn;
              };
            };
          })[];
        };
        Containers: (ContainerDefinition & {
          ImageConfig: ImageConfig & {
            RepositoryAccessMode: RepositoryAccessMode;
            RepositoryAuthConfig: RepositoryAuthConfig & {
              RepositoryCredentialsProviderArn: RepositoryCredentialsProviderArn;
            };
          };
          ModelDataSource: ModelDataSource & {
            S3DataSource: S3ModelDataSource & {
              S3Uri: S3ModelUri;
              S3DataType: S3ModelDataType;
              CompressionType: ModelCompressionType;
              ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
              HubAccessConfig: InferenceHubAccessConfig & {
                HubContentArn: HubContentArn;
              };
            };
          };
          AdditionalModelDataSources: (AdditionalModelDataSource & {
            ChannelName: AdditionalModelChannelName;
            S3DataSource: S3ModelDataSource & {
              S3Uri: S3ModelUri;
              S3DataType: S3ModelDataType;
              CompressionType: ModelCompressionType;
              ModelAccessConfig: ModelAccessConfig & { AcceptEula: AcceptEula };
              HubAccessConfig: InferenceHubAccessConfig & {
                HubContentArn: HubContentArn;
              };
            };
          })[];
        })[];
        InferenceExecutionConfig: InferenceExecutionConfig & {
          Mode: InferenceExecutionMode;
        };
        VpcConfig: VpcConfig & {
          SecurityGroupIds: VpcSecurityGroupIds;
          Subnets: Subnets;
        };
        Tags: (Tag & { Key: TagKey; Value: TagValue })[];
        DeploymentRecommendation: DeploymentRecommendation & {
          RecommendationStatus: RecommendationStatus;
          RealTimeInferenceRecommendations: (RealTimeInferenceRecommendation & {
            RecommendationId: string;
            InstanceType: ProductionVariantInstanceType;
          })[];
        };
      };
      Endpoints: (ModelDashboardEndpoint & {
        EndpointName: EndpointName;
        EndpointArn: EndpointArn;
        CreationTime: Date;
        LastModifiedTime: Date;
        EndpointStatus: EndpointStatus;
      })[];
      LastBatchTransformJob: TransformJob & {
        TransformInput: TransformInput & {
          DataSource: TransformDataSource & {
            S3DataSource: TransformS3DataSource & {
              S3DataType: S3DataType;
              S3Uri: S3Uri;
            };
          };
        };
        TransformOutput: TransformOutput & { S3OutputPath: S3Uri };
        DataCaptureConfig: BatchDataCaptureConfig & { DestinationS3Uri: S3Uri };
        TransformResources: TransformResources & {
          InstanceType: TransformInstanceType;
          InstanceCount: TransformInstanceCount;
        };
        Tags: (Tag & { Key: TagKey; Value: TagValue })[];
      };
      MonitoringSchedules: (ModelDashboardMonitoringSchedule & {
        MonitoringScheduleConfig: MonitoringScheduleConfig & {
          ScheduleConfig: ScheduleConfig & {
            ScheduleExpression: ScheduleExpression;
          };
          MonitoringJobDefinition: MonitoringJobDefinition & {
            MonitoringInputs: (MonitoringInput & {
              EndpointInput: EndpointInput & {
                EndpointName: EndpointName;
                LocalPath: ProcessingLocalPath;
              };
              BatchTransformInput: BatchTransformInput & {
                DataCapturedDestinationS3Uri: DestinationS3Uri;
                DatasetFormat: MonitoringDatasetFormat;
                LocalPath: ProcessingLocalPath;
              };
            })[];
            MonitoringOutputConfig: MonitoringOutputConfig & {
              MonitoringOutputs: (MonitoringOutput & {
                S3Output: MonitoringS3Output & {
                  S3Uri: MonitoringS3Uri;
                  LocalPath: ProcessingLocalPath;
                };
              })[];
            };
            MonitoringResources: MonitoringResources & {
              ClusterConfig: MonitoringClusterConfig & {
                InstanceCount: ProcessingInstanceCount;
                InstanceType: ProcessingInstanceType;
                VolumeSizeInGB: ProcessingVolumeSizeInGB;
              };
            };
            MonitoringAppSpecification: MonitoringAppSpecification & {
              ImageUri: ImageUri;
            };
            RoleArn: RoleArn;
            StoppingCondition: MonitoringStoppingCondition & {
              MaxRuntimeInSeconds: MonitoringMaxRuntimeInSeconds;
            };
            NetworkConfig: NetworkConfig & {
              VpcConfig: VpcConfig & {
                SecurityGroupIds: VpcSecurityGroupIds;
                Subnets: Subnets;
              };
            };
          };
        };
        MonitoringAlertSummaries: (MonitoringAlertSummary & {
          MonitoringAlertName: MonitoringAlertName;
          CreationTime: Date;
          LastModifiedTime: Date;
          AlertStatus: MonitoringAlertStatus;
          DatapointsToAlert: MonitoringDatapointsToAlert;
          EvaluationPeriod: MonitoringEvaluationPeriod;
          Actions: MonitoringAlertActions;
        })[];
        LastMonitoringExecutionSummary: MonitoringExecutionSummary & {
          MonitoringScheduleName: MonitoringScheduleName;
          ScheduledTime: Date;
          CreationTime: Date;
          LastModifiedTime: Date;
          MonitoringExecutionStatus: ExecutionStatus;
        };
        BatchTransformInput: BatchTransformInput & {
          DataCapturedDestinationS3Uri: DestinationS3Uri;
          DatasetFormat: MonitoringDatasetFormat;
          LocalPath: ProcessingLocalPath;
        };
      })[];
      ModelCard: ModelDashboardModelCard & {
        Tags: (Tag & { Key: TagKey; Value: TagValue })[];
      };
    };
  })[];
  NextToken?: string;
  TotalHits?: TotalHits;
}
export const SearchResponse = S.suspend(() =>
  S.Struct({
    Results: S.optional(SearchResultsList),
    NextToken: S.optional(S.String),
    TotalHits: S.optional(TotalHits),
  }).pipe(ns),
).annotate({ identifier: "SearchResponse" }) as any as S.Schema<SearchResponse>;
export interface SearchTrainingPlanOfferingsRequest {
  InstanceType?: ReservedCapacityInstanceType;
  InstanceCount?: number;
  UltraServerType?: string;
  UltraServerCount?: number;
  StartTimeAfter?: Date;
  EndTimeBefore?: Date;
  DurationHours?: number;
  TargetResources?: SageMakerResourceName[];
}
export const SearchTrainingPlanOfferingsRequest = S.suspend(() =>
  S.Struct({
    InstanceType: S.optional(ReservedCapacityInstanceType),
    InstanceCount: S.optional(S.Number),
    UltraServerType: S.optional(S.String),
    UltraServerCount: S.optional(S.Number),
    StartTimeAfter: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTimeBefore: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    DurationHours: S.optional(S.Number),
    TargetResources: S.optional(SageMakerResourceNames),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchTrainingPlanOfferingsRequest",
}) as any as S.Schema<SearchTrainingPlanOfferingsRequest>;
export interface ReservedCapacityOffering {
  ReservedCapacityType?: ReservedCapacityType;
  UltraServerType?: string;
  UltraServerCount?: number;
  InstanceType?: ReservedCapacityInstanceType;
  InstanceCount?: number;
  AvailabilityZone?: string;
  DurationHours?: number;
  DurationMinutes?: number;
  StartTime?: Date;
  EndTime?: Date;
}
export const ReservedCapacityOffering = S.suspend(() =>
  S.Struct({
    ReservedCapacityType: S.optional(ReservedCapacityType),
    UltraServerType: S.optional(S.String),
    UltraServerCount: S.optional(S.Number),
    InstanceType: S.optional(ReservedCapacityInstanceType),
    InstanceCount: S.optional(S.Number),
    AvailabilityZone: S.optional(S.String),
    DurationHours: S.optional(S.Number),
    DurationMinutes: S.optional(S.Number),
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotate({
  identifier: "ReservedCapacityOffering",
}) as any as S.Schema<ReservedCapacityOffering>;
export type ReservedCapacityOfferings = ReservedCapacityOffering[];
export const ReservedCapacityOfferings = S.Array(ReservedCapacityOffering);
export interface TrainingPlanOffering {
  TrainingPlanOfferingId?: string;
  TargetResources?: SageMakerResourceName[];
  RequestedStartTimeAfter?: Date;
  RequestedEndTimeBefore?: Date;
  DurationHours?: number;
  DurationMinutes?: number;
  UpfrontFee?: string;
  CurrencyCode?: string;
  ReservedCapacityOfferings?: ReservedCapacityOffering[];
}
export const TrainingPlanOffering = S.suspend(() =>
  S.Struct({
    TrainingPlanOfferingId: S.optional(S.String),
    TargetResources: S.optional(SageMakerResourceNames),
    RequestedStartTimeAfter: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    RequestedEndTimeBefore: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    DurationHours: S.optional(S.Number),
    DurationMinutes: S.optional(S.Number),
    UpfrontFee: S.optional(S.String),
    CurrencyCode: S.optional(S.String),
    ReservedCapacityOfferings: S.optional(ReservedCapacityOfferings),
  }),
).annotate({
  identifier: "TrainingPlanOffering",
}) as any as S.Schema<TrainingPlanOffering>;
export type TrainingPlanOfferings = TrainingPlanOffering[];
export const TrainingPlanOfferings = S.Array(TrainingPlanOffering);
export interface SearchTrainingPlanOfferingsResponse {
  TrainingPlanOfferings: (TrainingPlanOffering & {
    TrainingPlanOfferingId: TrainingPlanOfferingId;
    TargetResources: SageMakerResourceNames;
    ReservedCapacityOfferings: (ReservedCapacityOffering & {
      InstanceType: ReservedCapacityInstanceType;
      InstanceCount: ReservedCapacityInstanceCount;
    })[];
  })[];
}
export const SearchTrainingPlanOfferingsResponse = S.suspend(() =>
  S.Struct({ TrainingPlanOfferings: S.optional(TrainingPlanOfferings) }).pipe(
    ns,
  ),
).annotate({
  identifier: "SearchTrainingPlanOfferingsResponse",
}) as any as S.Schema<SearchTrainingPlanOfferingsResponse>;
export interface SendPipelineExecutionStepFailureRequest {
  CallbackToken?: string;
  FailureReason?: string;
  ClientRequestToken?: string;
}
export const SendPipelineExecutionStepFailureRequest = S.suspend(() =>
  S.Struct({
    CallbackToken: S.optional(S.String),
    FailureReason: S.optional(S.String),
    ClientRequestToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SendPipelineExecutionStepFailureRequest",
}) as any as S.Schema<SendPipelineExecutionStepFailureRequest>;
export interface SendPipelineExecutionStepFailureResponse {
  PipelineExecutionArn?: string;
}
export const SendPipelineExecutionStepFailureResponse = S.suspend(() =>
  S.Struct({ PipelineExecutionArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "SendPipelineExecutionStepFailureResponse",
}) as any as S.Schema<SendPipelineExecutionStepFailureResponse>;
export interface SendPipelineExecutionStepSuccessRequest {
  CallbackToken?: string;
  OutputParameters?: OutputParameter[];
  ClientRequestToken?: string;
}
export const SendPipelineExecutionStepSuccessRequest = S.suspend(() =>
  S.Struct({
    CallbackToken: S.optional(S.String),
    OutputParameters: S.optional(OutputParameterList),
    ClientRequestToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SendPipelineExecutionStepSuccessRequest",
}) as any as S.Schema<SendPipelineExecutionStepSuccessRequest>;
export interface SendPipelineExecutionStepSuccessResponse {
  PipelineExecutionArn?: string;
}
export const SendPipelineExecutionStepSuccessResponse = S.suspend(() =>
  S.Struct({ PipelineExecutionArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "SendPipelineExecutionStepSuccessResponse",
}) as any as S.Schema<SendPipelineExecutionStepSuccessResponse>;
export interface StartEdgeDeploymentStageRequest {
  EdgeDeploymentPlanName?: string;
  StageName?: string;
}
export const StartEdgeDeploymentStageRequest = S.suspend(() =>
  S.Struct({
    EdgeDeploymentPlanName: S.optional(S.String),
    StageName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartEdgeDeploymentStageRequest",
}) as any as S.Schema<StartEdgeDeploymentStageRequest>;
export interface StartEdgeDeploymentStageResponse {}
export const StartEdgeDeploymentStageResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "StartEdgeDeploymentStageResponse",
}) as any as S.Schema<StartEdgeDeploymentStageResponse>;
export interface StartInferenceExperimentRequest {
  Name?: string;
}
export const StartInferenceExperimentRequest = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartInferenceExperimentRequest",
}) as any as S.Schema<StartInferenceExperimentRequest>;
export interface StartInferenceExperimentResponse {
  InferenceExperimentArn: string;
}
export const StartInferenceExperimentResponse = S.suspend(() =>
  S.Struct({ InferenceExperimentArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "StartInferenceExperimentResponse",
}) as any as S.Schema<StartInferenceExperimentResponse>;
export interface StartMlflowTrackingServerRequest {
  TrackingServerName?: string;
}
export const StartMlflowTrackingServerRequest = S.suspend(() =>
  S.Struct({ TrackingServerName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartMlflowTrackingServerRequest",
}) as any as S.Schema<StartMlflowTrackingServerRequest>;
export interface StartMlflowTrackingServerResponse {
  TrackingServerArn?: string;
}
export const StartMlflowTrackingServerResponse = S.suspend(() =>
  S.Struct({ TrackingServerArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "StartMlflowTrackingServerResponse",
}) as any as S.Schema<StartMlflowTrackingServerResponse>;
export interface StartMonitoringScheduleRequest {
  MonitoringScheduleName?: string;
}
export const StartMonitoringScheduleRequest = S.suspend(() =>
  S.Struct({ MonitoringScheduleName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartMonitoringScheduleRequest",
}) as any as S.Schema<StartMonitoringScheduleRequest>;
export interface StartMonitoringScheduleResponse {}
export const StartMonitoringScheduleResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "StartMonitoringScheduleResponse",
}) as any as S.Schema<StartMonitoringScheduleResponse>;
export interface StartNotebookInstanceInput {
  NotebookInstanceName?: string;
}
export const StartNotebookInstanceInput = S.suspend(() =>
  S.Struct({ NotebookInstanceName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartNotebookInstanceInput",
}) as any as S.Schema<StartNotebookInstanceInput>;
export interface StartNotebookInstanceResponse {}
export const StartNotebookInstanceResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "StartNotebookInstanceResponse",
}) as any as S.Schema<StartNotebookInstanceResponse>;
export interface StartPipelineExecutionRequest {
  PipelineName?: string;
  PipelineExecutionDisplayName?: string;
  PipelineParameters?: Parameter[];
  PipelineExecutionDescription?: string;
  ClientRequestToken?: string;
  ParallelismConfiguration?: ParallelismConfiguration;
  SelectiveExecutionConfig?: SelectiveExecutionConfig;
  PipelineVersionId?: number;
  MlflowExperimentName?: string;
}
export const StartPipelineExecutionRequest = S.suspend(() =>
  S.Struct({
    PipelineName: S.optional(S.String),
    PipelineExecutionDisplayName: S.optional(S.String),
    PipelineParameters: S.optional(ParameterList),
    PipelineExecutionDescription: S.optional(S.String),
    ClientRequestToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    ParallelismConfiguration: S.optional(ParallelismConfiguration),
    SelectiveExecutionConfig: S.optional(SelectiveExecutionConfig),
    PipelineVersionId: S.optional(S.Number),
    MlflowExperimentName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartPipelineExecutionRequest",
}) as any as S.Schema<StartPipelineExecutionRequest>;
export interface StartPipelineExecutionResponse {
  PipelineExecutionArn?: string;
}
export const StartPipelineExecutionResponse = S.suspend(() =>
  S.Struct({ PipelineExecutionArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "StartPipelineExecutionResponse",
}) as any as S.Schema<StartPipelineExecutionResponse>;
export interface StartSessionRequest {
  ResourceIdentifier?: string;
}
export const StartSessionRequest = S.suspend(() =>
  S.Struct({ ResourceIdentifier: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartSessionRequest",
}) as any as S.Schema<StartSessionRequest>;
export interface StartSessionResponse {
  SessionId?: string;
  StreamUrl?: string;
  TokenValue?: string;
}
export const StartSessionResponse = S.suspend(() =>
  S.Struct({
    SessionId: S.optional(S.String),
    StreamUrl: S.optional(S.String),
    TokenValue: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "StartSessionResponse",
}) as any as S.Schema<StartSessionResponse>;
export interface StopAutoMLJobRequest {
  AutoMLJobName?: string;
}
export const StopAutoMLJobRequest = S.suspend(() =>
  S.Struct({ AutoMLJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopAutoMLJobRequest",
}) as any as S.Schema<StopAutoMLJobRequest>;
export interface StopAutoMLJobResponse {}
export const StopAutoMLJobResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "StopAutoMLJobResponse",
}) as any as S.Schema<StopAutoMLJobResponse>;
export interface StopCompilationJobRequest {
  CompilationJobName?: string;
}
export const StopCompilationJobRequest = S.suspend(() =>
  S.Struct({ CompilationJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopCompilationJobRequest",
}) as any as S.Schema<StopCompilationJobRequest>;
export interface StopCompilationJobResponse {}
export const StopCompilationJobResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "StopCompilationJobResponse",
}) as any as S.Schema<StopCompilationJobResponse>;
export interface StopEdgeDeploymentStageRequest {
  EdgeDeploymentPlanName?: string;
  StageName?: string;
}
export const StopEdgeDeploymentStageRequest = S.suspend(() =>
  S.Struct({
    EdgeDeploymentPlanName: S.optional(S.String),
    StageName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopEdgeDeploymentStageRequest",
}) as any as S.Schema<StopEdgeDeploymentStageRequest>;
export interface StopEdgeDeploymentStageResponse {}
export const StopEdgeDeploymentStageResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "StopEdgeDeploymentStageResponse",
}) as any as S.Schema<StopEdgeDeploymentStageResponse>;
export interface StopEdgePackagingJobRequest {
  EdgePackagingJobName?: string;
}
export const StopEdgePackagingJobRequest = S.suspend(() =>
  S.Struct({ EdgePackagingJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopEdgePackagingJobRequest",
}) as any as S.Schema<StopEdgePackagingJobRequest>;
export interface StopEdgePackagingJobResponse {}
export const StopEdgePackagingJobResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "StopEdgePackagingJobResponse",
}) as any as S.Schema<StopEdgePackagingJobResponse>;
export interface StopHyperParameterTuningJobRequest {
  HyperParameterTuningJobName?: string;
}
export const StopHyperParameterTuningJobRequest = S.suspend(() =>
  S.Struct({ HyperParameterTuningJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopHyperParameterTuningJobRequest",
}) as any as S.Schema<StopHyperParameterTuningJobRequest>;
export interface StopHyperParameterTuningJobResponse {}
export const StopHyperParameterTuningJobResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "StopHyperParameterTuningJobResponse",
}) as any as S.Schema<StopHyperParameterTuningJobResponse>;
export type ModelVariantAction =
  | "Retain"
  | "Remove"
  | "Promote"
  | (string & {});
export const ModelVariantAction = S.String;
export type ModelVariantActionMap = {
  [key: string]: ModelVariantAction | undefined;
};
export const ModelVariantActionMap = S.Record(
  S.String,
  ModelVariantAction.pipe(S.optional),
);
export type InferenceExperimentStopDesiredState =
  | "Completed"
  | "Cancelled"
  | (string & {});
export const InferenceExperimentStopDesiredState = S.String;
export interface StopInferenceExperimentRequest {
  Name?: string;
  ModelVariantActions?: { [key: string]: ModelVariantAction | undefined };
  DesiredModelVariants?: ModelVariantConfig[];
  DesiredState?: InferenceExperimentStopDesiredState;
  Reason?: string;
}
export const StopInferenceExperimentRequest = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    ModelVariantActions: S.optional(ModelVariantActionMap),
    DesiredModelVariants: S.optional(ModelVariantConfigList),
    DesiredState: S.optional(InferenceExperimentStopDesiredState),
    Reason: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopInferenceExperimentRequest",
}) as any as S.Schema<StopInferenceExperimentRequest>;
export interface StopInferenceExperimentResponse {
  InferenceExperimentArn: string;
}
export const StopInferenceExperimentResponse = S.suspend(() =>
  S.Struct({ InferenceExperimentArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "StopInferenceExperimentResponse",
}) as any as S.Schema<StopInferenceExperimentResponse>;
export interface StopInferenceRecommendationsJobRequest {
  JobName?: string;
}
export const StopInferenceRecommendationsJobRequest = S.suspend(() =>
  S.Struct({ JobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopInferenceRecommendationsJobRequest",
}) as any as S.Schema<StopInferenceRecommendationsJobRequest>;
export interface StopInferenceRecommendationsJobResponse {}
export const StopInferenceRecommendationsJobResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "StopInferenceRecommendationsJobResponse",
}) as any as S.Schema<StopInferenceRecommendationsJobResponse>;
export interface StopLabelingJobRequest {
  LabelingJobName?: string;
}
export const StopLabelingJobRequest = S.suspend(() =>
  S.Struct({ LabelingJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopLabelingJobRequest",
}) as any as S.Schema<StopLabelingJobRequest>;
export interface StopLabelingJobResponse {}
export const StopLabelingJobResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "StopLabelingJobResponse",
}) as any as S.Schema<StopLabelingJobResponse>;
export interface StopMlflowTrackingServerRequest {
  TrackingServerName?: string;
}
export const StopMlflowTrackingServerRequest = S.suspend(() =>
  S.Struct({ TrackingServerName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopMlflowTrackingServerRequest",
}) as any as S.Schema<StopMlflowTrackingServerRequest>;
export interface StopMlflowTrackingServerResponse {
  TrackingServerArn?: string;
}
export const StopMlflowTrackingServerResponse = S.suspend(() =>
  S.Struct({ TrackingServerArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "StopMlflowTrackingServerResponse",
}) as any as S.Schema<StopMlflowTrackingServerResponse>;
export interface StopMonitoringScheduleRequest {
  MonitoringScheduleName?: string;
}
export const StopMonitoringScheduleRequest = S.suspend(() =>
  S.Struct({ MonitoringScheduleName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopMonitoringScheduleRequest",
}) as any as S.Schema<StopMonitoringScheduleRequest>;
export interface StopMonitoringScheduleResponse {}
export const StopMonitoringScheduleResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "StopMonitoringScheduleResponse",
}) as any as S.Schema<StopMonitoringScheduleResponse>;
export interface StopNotebookInstanceInput {
  NotebookInstanceName?: string;
}
export const StopNotebookInstanceInput = S.suspend(() =>
  S.Struct({ NotebookInstanceName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopNotebookInstanceInput",
}) as any as S.Schema<StopNotebookInstanceInput>;
export interface StopNotebookInstanceResponse {}
export const StopNotebookInstanceResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "StopNotebookInstanceResponse",
}) as any as S.Schema<StopNotebookInstanceResponse>;
export interface StopOptimizationJobRequest {
  OptimizationJobName?: string;
}
export const StopOptimizationJobRequest = S.suspend(() =>
  S.Struct({ OptimizationJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopOptimizationJobRequest",
}) as any as S.Schema<StopOptimizationJobRequest>;
export interface StopOptimizationJobResponse {}
export const StopOptimizationJobResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "StopOptimizationJobResponse",
}) as any as S.Schema<StopOptimizationJobResponse>;
export interface StopPipelineExecutionRequest {
  PipelineExecutionArn?: string;
  ClientRequestToken?: string;
}
export const StopPipelineExecutionRequest = S.suspend(() =>
  S.Struct({
    PipelineExecutionArn: S.optional(S.String),
    ClientRequestToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopPipelineExecutionRequest",
}) as any as S.Schema<StopPipelineExecutionRequest>;
export interface StopPipelineExecutionResponse {
  PipelineExecutionArn?: string;
}
export const StopPipelineExecutionResponse = S.suspend(() =>
  S.Struct({ PipelineExecutionArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "StopPipelineExecutionResponse",
}) as any as S.Schema<StopPipelineExecutionResponse>;
export interface StopProcessingJobRequest {
  ProcessingJobName?: string;
}
export const StopProcessingJobRequest = S.suspend(() =>
  S.Struct({ ProcessingJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopProcessingJobRequest",
}) as any as S.Schema<StopProcessingJobRequest>;
export interface StopProcessingJobResponse {}
export const StopProcessingJobResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "StopProcessingJobResponse",
}) as any as S.Schema<StopProcessingJobResponse>;
export interface StopTrainingJobRequest {
  TrainingJobName?: string;
}
export const StopTrainingJobRequest = S.suspend(() =>
  S.Struct({ TrainingJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopTrainingJobRequest",
}) as any as S.Schema<StopTrainingJobRequest>;
export interface StopTrainingJobResponse {}
export const StopTrainingJobResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "StopTrainingJobResponse",
}) as any as S.Schema<StopTrainingJobResponse>;
export interface StopTransformJobRequest {
  TransformJobName?: string;
}
export const StopTransformJobRequest = S.suspend(() =>
  S.Struct({ TransformJobName: S.optional(S.String) }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopTransformJobRequest",
}) as any as S.Schema<StopTransformJobRequest>;
export interface StopTransformJobResponse {}
export const StopTransformJobResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "StopTransformJobResponse",
}) as any as S.Schema<StopTransformJobResponse>;
export type ListLineageEntityParameterKey = string[];
export const ListLineageEntityParameterKey = S.Array(S.String);
export interface UpdateActionRequest {
  ActionName?: string;
  Description?: string;
  Status?: ActionStatus;
  Properties?: { [key: string]: string | undefined };
  PropertiesToRemove?: string[];
}
export const UpdateActionRequest = S.suspend(() =>
  S.Struct({
    ActionName: S.optional(S.String),
    Description: S.optional(S.String),
    Status: S.optional(ActionStatus),
    Properties: S.optional(LineageEntityParameters),
    PropertiesToRemove: S.optional(ListLineageEntityParameterKey),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateActionRequest",
}) as any as S.Schema<UpdateActionRequest>;
export interface UpdateActionResponse {
  ActionArn?: string;
}
export const UpdateActionResponse = S.suspend(() =>
  S.Struct({ ActionArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateActionResponse",
}) as any as S.Schema<UpdateActionResponse>;
export interface UpdateAppImageConfigRequest {
  AppImageConfigName?: string;
  KernelGatewayImageConfig?: KernelGatewayImageConfig;
  JupyterLabAppImageConfig?: JupyterLabAppImageConfig;
  CodeEditorAppImageConfig?: CodeEditorAppImageConfig;
}
export const UpdateAppImageConfigRequest = S.suspend(() =>
  S.Struct({
    AppImageConfigName: S.optional(S.String),
    KernelGatewayImageConfig: S.optional(KernelGatewayImageConfig),
    JupyterLabAppImageConfig: S.optional(JupyterLabAppImageConfig),
    CodeEditorAppImageConfig: S.optional(CodeEditorAppImageConfig),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateAppImageConfigRequest",
}) as any as S.Schema<UpdateAppImageConfigRequest>;
export interface UpdateAppImageConfigResponse {
  AppImageConfigArn?: string;
}
export const UpdateAppImageConfigResponse = S.suspend(() =>
  S.Struct({ AppImageConfigArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateAppImageConfigResponse",
}) as any as S.Schema<UpdateAppImageConfigResponse>;
export interface UpdateArtifactRequest {
  ArtifactArn?: string;
  ArtifactName?: string;
  Properties?: { [key: string]: string | undefined };
  PropertiesToRemove?: string[];
}
export const UpdateArtifactRequest = S.suspend(() =>
  S.Struct({
    ArtifactArn: S.optional(S.String),
    ArtifactName: S.optional(S.String),
    Properties: S.optional(ArtifactProperties),
    PropertiesToRemove: S.optional(ListLineageEntityParameterKey),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateArtifactRequest",
}) as any as S.Schema<UpdateArtifactRequest>;
export interface UpdateArtifactResponse {
  ArtifactArn?: string;
}
export const UpdateArtifactResponse = S.suspend(() =>
  S.Struct({ ArtifactArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateArtifactResponse",
}) as any as S.Schema<UpdateArtifactResponse>;
export type ClusterInstanceGroupsToDelete = string[];
export const ClusterInstanceGroupsToDelete = S.Array(S.String);
export interface UpdateClusterRequest {
  ClusterName?: string;
  InstanceGroups?: ClusterInstanceGroupSpecification[];
  RestrictedInstanceGroups?: ClusterRestrictedInstanceGroupSpecification[];
  TieredStorageConfig?: ClusterTieredStorageConfig;
  NodeRecovery?: ClusterNodeRecovery;
  InstanceGroupsToDelete?: string[];
  NodeProvisioningMode?: ClusterNodeProvisioningMode;
  ClusterRole?: string;
  AutoScaling?: ClusterAutoScalingConfig;
}
export const UpdateClusterRequest = S.suspend(() =>
  S.Struct({
    ClusterName: S.optional(S.String),
    InstanceGroups: S.optional(ClusterInstanceGroupSpecifications),
    RestrictedInstanceGroups: S.optional(
      ClusterRestrictedInstanceGroupSpecifications,
    ),
    TieredStorageConfig: S.optional(ClusterTieredStorageConfig),
    NodeRecovery: S.optional(ClusterNodeRecovery),
    InstanceGroupsToDelete: S.optional(ClusterInstanceGroupsToDelete),
    NodeProvisioningMode: S.optional(ClusterNodeProvisioningMode),
    ClusterRole: S.optional(S.String),
    AutoScaling: S.optional(ClusterAutoScalingConfig),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateClusterRequest",
}) as any as S.Schema<UpdateClusterRequest>;
export interface UpdateClusterResponse {
  ClusterArn: string;
}
export const UpdateClusterResponse = S.suspend(() =>
  S.Struct({ ClusterArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateClusterResponse",
}) as any as S.Schema<UpdateClusterResponse>;
export interface UpdateClusterSchedulerConfigRequest {
  ClusterSchedulerConfigId?: string;
  TargetVersion?: number;
  SchedulerConfig?: SchedulerConfig;
  Description?: string;
}
export const UpdateClusterSchedulerConfigRequest = S.suspend(() =>
  S.Struct({
    ClusterSchedulerConfigId: S.optional(S.String),
    TargetVersion: S.optional(S.Number),
    SchedulerConfig: S.optional(SchedulerConfig),
    Description: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateClusterSchedulerConfigRequest",
}) as any as S.Schema<UpdateClusterSchedulerConfigRequest>;
export interface UpdateClusterSchedulerConfigResponse {
  ClusterSchedulerConfigArn: string;
  ClusterSchedulerConfigVersion: number;
}
export const UpdateClusterSchedulerConfigResponse = S.suspend(() =>
  S.Struct({
    ClusterSchedulerConfigArn: S.optional(S.String),
    ClusterSchedulerConfigVersion: S.optional(S.Number),
  }).pipe(ns),
).annotate({
  identifier: "UpdateClusterSchedulerConfigResponse",
}) as any as S.Schema<UpdateClusterSchedulerConfigResponse>;
export interface UpdateClusterSoftwareInstanceGroupSpecification {
  InstanceGroupName?: string;
}
export const UpdateClusterSoftwareInstanceGroupSpecification = S.suspend(() =>
  S.Struct({ InstanceGroupName: S.optional(S.String) }),
).annotate({
  identifier: "UpdateClusterSoftwareInstanceGroupSpecification",
}) as any as S.Schema<UpdateClusterSoftwareInstanceGroupSpecification>;
export type UpdateClusterSoftwareInstanceGroups =
  UpdateClusterSoftwareInstanceGroupSpecification[];
export const UpdateClusterSoftwareInstanceGroups = S.Array(
  UpdateClusterSoftwareInstanceGroupSpecification,
);
export interface UpdateClusterSoftwareRequest {
  ClusterName?: string;
  InstanceGroups?: UpdateClusterSoftwareInstanceGroupSpecification[];
  DeploymentConfig?: DeploymentConfiguration;
  ImageId?: string;
}
export const UpdateClusterSoftwareRequest = S.suspend(() =>
  S.Struct({
    ClusterName: S.optional(S.String),
    InstanceGroups: S.optional(UpdateClusterSoftwareInstanceGroups),
    DeploymentConfig: S.optional(DeploymentConfiguration),
    ImageId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateClusterSoftwareRequest",
}) as any as S.Schema<UpdateClusterSoftwareRequest>;
export interface UpdateClusterSoftwareResponse {
  ClusterArn: string;
}
export const UpdateClusterSoftwareResponse = S.suspend(() =>
  S.Struct({ ClusterArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateClusterSoftwareResponse",
}) as any as S.Schema<UpdateClusterSoftwareResponse>;
export interface GitConfigForUpdate {
  SecretArn?: string;
}
export const GitConfigForUpdate = S.suspend(() =>
  S.Struct({ SecretArn: S.optional(S.String) }),
).annotate({
  identifier: "GitConfigForUpdate",
}) as any as S.Schema<GitConfigForUpdate>;
export interface UpdateCodeRepositoryInput {
  CodeRepositoryName?: string;
  GitConfig?: GitConfigForUpdate;
}
export const UpdateCodeRepositoryInput = S.suspend(() =>
  S.Struct({
    CodeRepositoryName: S.optional(S.String),
    GitConfig: S.optional(GitConfigForUpdate),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateCodeRepositoryInput",
}) as any as S.Schema<UpdateCodeRepositoryInput>;
export interface UpdateCodeRepositoryOutput {
  CodeRepositoryArn: string;
}
export const UpdateCodeRepositoryOutput = S.suspend(() =>
  S.Struct({ CodeRepositoryArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateCodeRepositoryOutput",
}) as any as S.Schema<UpdateCodeRepositoryOutput>;
export interface UpdateComputeQuotaRequest {
  ComputeQuotaId?: string;
  TargetVersion?: number;
  ComputeQuotaConfig?: ComputeQuotaConfig;
  ComputeQuotaTarget?: ComputeQuotaTarget;
  ActivationState?: ActivationState;
  Description?: string;
}
export const UpdateComputeQuotaRequest = S.suspend(() =>
  S.Struct({
    ComputeQuotaId: S.optional(S.String),
    TargetVersion: S.optional(S.Number),
    ComputeQuotaConfig: S.optional(ComputeQuotaConfig),
    ComputeQuotaTarget: S.optional(ComputeQuotaTarget),
    ActivationState: S.optional(ActivationState),
    Description: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateComputeQuotaRequest",
}) as any as S.Schema<UpdateComputeQuotaRequest>;
export interface UpdateComputeQuotaResponse {
  ComputeQuotaArn: string;
  ComputeQuotaVersion: number;
}
export const UpdateComputeQuotaResponse = S.suspend(() =>
  S.Struct({
    ComputeQuotaArn: S.optional(S.String),
    ComputeQuotaVersion: S.optional(S.Number),
  }).pipe(ns),
).annotate({
  identifier: "UpdateComputeQuotaResponse",
}) as any as S.Schema<UpdateComputeQuotaResponse>;
export interface UpdateContextRequest {
  ContextName?: string;
  Description?: string;
  Properties?: { [key: string]: string | undefined };
  PropertiesToRemove?: string[];
}
export const UpdateContextRequest = S.suspend(() =>
  S.Struct({
    ContextName: S.optional(S.String),
    Description: S.optional(S.String),
    Properties: S.optional(LineageEntityParameters),
    PropertiesToRemove: S.optional(ListLineageEntityParameterKey),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateContextRequest",
}) as any as S.Schema<UpdateContextRequest>;
export interface UpdateContextResponse {
  ContextArn?: string;
}
export const UpdateContextResponse = S.suspend(() =>
  S.Struct({ ContextArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateContextResponse",
}) as any as S.Schema<UpdateContextResponse>;
export interface UpdateDeviceFleetRequest {
  DeviceFleetName?: string;
  RoleArn?: string;
  Description?: string;
  OutputConfig?: EdgeOutputConfig;
  EnableIotRoleAlias?: boolean;
}
export const UpdateDeviceFleetRequest = S.suspend(() =>
  S.Struct({
    DeviceFleetName: S.optional(S.String),
    RoleArn: S.optional(S.String),
    Description: S.optional(S.String),
    OutputConfig: S.optional(EdgeOutputConfig),
    EnableIotRoleAlias: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateDeviceFleetRequest",
}) as any as S.Schema<UpdateDeviceFleetRequest>;
export interface UpdateDeviceFleetResponse {}
export const UpdateDeviceFleetResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "UpdateDeviceFleetResponse",
}) as any as S.Schema<UpdateDeviceFleetResponse>;
export interface UpdateDevicesRequest {
  DeviceFleetName?: string;
  Devices?: Device[];
}
export const UpdateDevicesRequest = S.suspend(() =>
  S.Struct({
    DeviceFleetName: S.optional(S.String),
    Devices: S.optional(Devices),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateDevicesRequest",
}) as any as S.Schema<UpdateDevicesRequest>;
export interface UpdateDevicesResponse {}
export const UpdateDevicesResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "UpdateDevicesResponse",
}) as any as S.Schema<UpdateDevicesResponse>;
export interface RStudioServerProDomainSettingsForUpdate {
  DomainExecutionRoleArn?: string;
  DefaultResourceSpec?: ResourceSpec;
  RStudioConnectUrl?: string;
  RStudioPackageManagerUrl?: string;
}
export const RStudioServerProDomainSettingsForUpdate = S.suspend(() =>
  S.Struct({
    DomainExecutionRoleArn: S.optional(S.String),
    DefaultResourceSpec: S.optional(ResourceSpec),
    RStudioConnectUrl: S.optional(S.String),
    RStudioPackageManagerUrl: S.optional(S.String),
  }),
).annotate({
  identifier: "RStudioServerProDomainSettingsForUpdate",
}) as any as S.Schema<RStudioServerProDomainSettingsForUpdate>;
export interface DomainSettingsForUpdate {
  RStudioServerProDomainSettingsForUpdate?: RStudioServerProDomainSettingsForUpdate;
  ExecutionRoleIdentityConfig?: ExecutionRoleIdentityConfig;
  SecurityGroupIds?: string[];
  TrustedIdentityPropagationSettings?: TrustedIdentityPropagationSettings;
  DockerSettings?: DockerSettings;
  AmazonQSettings?: AmazonQSettings;
  UnifiedStudioSettings?: UnifiedStudioSettings;
  IpAddressType?: IPAddressType;
}
export const DomainSettingsForUpdate = S.suspend(() =>
  S.Struct({
    RStudioServerProDomainSettingsForUpdate: S.optional(
      RStudioServerProDomainSettingsForUpdate,
    ),
    ExecutionRoleIdentityConfig: S.optional(ExecutionRoleIdentityConfig),
    SecurityGroupIds: S.optional(DomainSecurityGroupIds),
    TrustedIdentityPropagationSettings: S.optional(
      TrustedIdentityPropagationSettings,
    ),
    DockerSettings: S.optional(DockerSettings),
    AmazonQSettings: S.optional(AmazonQSettings),
    UnifiedStudioSettings: S.optional(UnifiedStudioSettings),
    IpAddressType: S.optional(IPAddressType),
  }),
).annotate({
  identifier: "DomainSettingsForUpdate",
}) as any as S.Schema<DomainSettingsForUpdate>;
export interface UpdateDomainRequest {
  DomainId?: string;
  DefaultUserSettings?: UserSettings;
  DomainSettingsForUpdate?: DomainSettingsForUpdate;
  AppSecurityGroupManagement?: AppSecurityGroupManagement;
  DefaultSpaceSettings?: DefaultSpaceSettings;
  SubnetIds?: string[];
  AppNetworkAccessType?: AppNetworkAccessType;
  TagPropagation?: TagPropagation;
  VpcId?: string;
}
export const UpdateDomainRequest = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    DefaultUserSettings: S.optional(UserSettings),
    DomainSettingsForUpdate: S.optional(DomainSettingsForUpdate),
    AppSecurityGroupManagement: S.optional(AppSecurityGroupManagement),
    DefaultSpaceSettings: S.optional(DefaultSpaceSettings),
    SubnetIds: S.optional(Subnets),
    AppNetworkAccessType: S.optional(AppNetworkAccessType),
    TagPropagation: S.optional(TagPropagation),
    VpcId: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateDomainRequest",
}) as any as S.Schema<UpdateDomainRequest>;
export interface UpdateDomainResponse {
  DomainArn?: string;
}
export const UpdateDomainResponse = S.suspend(() =>
  S.Struct({ DomainArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateDomainResponse",
}) as any as S.Schema<UpdateDomainResponse>;
export type VariantPropertyType =
  | "DesiredInstanceCount"
  | "DesiredWeight"
  | "DataCaptureConfig"
  | (string & {});
export const VariantPropertyType = S.String;
export interface VariantProperty {
  VariantPropertyType?: VariantPropertyType;
}
export const VariantProperty = S.suspend(() =>
  S.Struct({ VariantPropertyType: S.optional(VariantPropertyType) }),
).annotate({
  identifier: "VariantProperty",
}) as any as S.Schema<VariantProperty>;
export type VariantPropertyList = VariantProperty[];
export const VariantPropertyList = S.Array(VariantProperty);
export interface UpdateEndpointInput {
  EndpointName?: string;
  EndpointConfigName?: string;
  RetainAllVariantProperties?: boolean;
  ExcludeRetainedVariantProperties?: VariantProperty[];
  DeploymentConfig?: DeploymentConfig;
  RetainDeploymentConfig?: boolean;
}
export const UpdateEndpointInput = S.suspend(() =>
  S.Struct({
    EndpointName: S.optional(S.String),
    EndpointConfigName: S.optional(S.String),
    RetainAllVariantProperties: S.optional(S.Boolean),
    ExcludeRetainedVariantProperties: S.optional(VariantPropertyList),
    DeploymentConfig: S.optional(DeploymentConfig),
    RetainDeploymentConfig: S.optional(S.Boolean),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateEndpointInput",
}) as any as S.Schema<UpdateEndpointInput>;
export interface UpdateEndpointOutput {
  EndpointArn: string;
}
export const UpdateEndpointOutput = S.suspend(() =>
  S.Struct({ EndpointArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateEndpointOutput",
}) as any as S.Schema<UpdateEndpointOutput>;
export interface ProductionVariantServerlessUpdateConfig {
  MaxConcurrency?: number;
  ProvisionedConcurrency?: number;
}
export const ProductionVariantServerlessUpdateConfig = S.suspend(() =>
  S.Struct({
    MaxConcurrency: S.optional(S.Number),
    ProvisionedConcurrency: S.optional(S.Number),
  }),
).annotate({
  identifier: "ProductionVariantServerlessUpdateConfig",
}) as any as S.Schema<ProductionVariantServerlessUpdateConfig>;
export interface DesiredWeightAndCapacity {
  VariantName?: string;
  DesiredWeight?: number;
  DesiredInstanceCount?: number;
  ServerlessUpdateConfig?: ProductionVariantServerlessUpdateConfig;
}
export const DesiredWeightAndCapacity = S.suspend(() =>
  S.Struct({
    VariantName: S.optional(S.String),
    DesiredWeight: S.optional(S.Number),
    DesiredInstanceCount: S.optional(S.Number),
    ServerlessUpdateConfig: S.optional(ProductionVariantServerlessUpdateConfig),
  }),
).annotate({
  identifier: "DesiredWeightAndCapacity",
}) as any as S.Schema<DesiredWeightAndCapacity>;
export type DesiredWeightAndCapacityList = DesiredWeightAndCapacity[];
export const DesiredWeightAndCapacityList = S.Array(DesiredWeightAndCapacity);
export interface UpdateEndpointWeightsAndCapacitiesInput {
  EndpointName?: string;
  DesiredWeightsAndCapacities?: DesiredWeightAndCapacity[];
}
export const UpdateEndpointWeightsAndCapacitiesInput = S.suspend(() =>
  S.Struct({
    EndpointName: S.optional(S.String),
    DesiredWeightsAndCapacities: S.optional(DesiredWeightAndCapacityList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateEndpointWeightsAndCapacitiesInput",
}) as any as S.Schema<UpdateEndpointWeightsAndCapacitiesInput>;
export interface UpdateEndpointWeightsAndCapacitiesOutput {
  EndpointArn: string;
}
export const UpdateEndpointWeightsAndCapacitiesOutput = S.suspend(() =>
  S.Struct({ EndpointArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateEndpointWeightsAndCapacitiesOutput",
}) as any as S.Schema<UpdateEndpointWeightsAndCapacitiesOutput>;
export interface UpdateExperimentRequest {
  ExperimentName?: string;
  DisplayName?: string;
  Description?: string;
}
export const UpdateExperimentRequest = S.suspend(() =>
  S.Struct({
    ExperimentName: S.optional(S.String),
    DisplayName: S.optional(S.String),
    Description: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateExperimentRequest",
}) as any as S.Schema<UpdateExperimentRequest>;
export interface UpdateExperimentResponse {
  ExperimentArn?: string;
}
export const UpdateExperimentResponse = S.suspend(() =>
  S.Struct({ ExperimentArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateExperimentResponse",
}) as any as S.Schema<UpdateExperimentResponse>;
export type FeatureAdditions = FeatureDefinition[];
export const FeatureAdditions = S.Array(FeatureDefinition);
export interface OnlineStoreConfigUpdate {
  TtlDuration?: TtlDuration;
}
export const OnlineStoreConfigUpdate = S.suspend(() =>
  S.Struct({ TtlDuration: S.optional(TtlDuration) }),
).annotate({
  identifier: "OnlineStoreConfigUpdate",
}) as any as S.Schema<OnlineStoreConfigUpdate>;
export interface ThroughputConfigUpdate {
  ThroughputMode?: ThroughputMode;
  ProvisionedReadCapacityUnits?: number;
  ProvisionedWriteCapacityUnits?: number;
}
export const ThroughputConfigUpdate = S.suspend(() =>
  S.Struct({
    ThroughputMode: S.optional(ThroughputMode),
    ProvisionedReadCapacityUnits: S.optional(S.Number),
    ProvisionedWriteCapacityUnits: S.optional(S.Number),
  }),
).annotate({
  identifier: "ThroughputConfigUpdate",
}) as any as S.Schema<ThroughputConfigUpdate>;
export interface UpdateFeatureGroupRequest {
  FeatureGroupName?: string;
  FeatureAdditions?: FeatureDefinition[];
  OnlineStoreConfig?: OnlineStoreConfigUpdate;
  ThroughputConfig?: ThroughputConfigUpdate;
}
export const UpdateFeatureGroupRequest = S.suspend(() =>
  S.Struct({
    FeatureGroupName: S.optional(S.String),
    FeatureAdditions: S.optional(FeatureAdditions),
    OnlineStoreConfig: S.optional(OnlineStoreConfigUpdate),
    ThroughputConfig: S.optional(ThroughputConfigUpdate),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateFeatureGroupRequest",
}) as any as S.Schema<UpdateFeatureGroupRequest>;
export interface UpdateFeatureGroupResponse {
  FeatureGroupArn: string;
}
export const UpdateFeatureGroupResponse = S.suspend(() =>
  S.Struct({ FeatureGroupArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateFeatureGroupResponse",
}) as any as S.Schema<UpdateFeatureGroupResponse>;
export type FeatureParameterAdditions = FeatureParameter[];
export const FeatureParameterAdditions = S.Array(FeatureParameter);
export type FeatureParameterRemovals = string[];
export const FeatureParameterRemovals = S.Array(S.String);
export interface UpdateFeatureMetadataRequest {
  FeatureGroupName?: string;
  FeatureName?: string;
  Description?: string;
  ParameterAdditions?: FeatureParameter[];
  ParameterRemovals?: string[];
}
export const UpdateFeatureMetadataRequest = S.suspend(() =>
  S.Struct({
    FeatureGroupName: S.optional(S.String),
    FeatureName: S.optional(S.String),
    Description: S.optional(S.String),
    ParameterAdditions: S.optional(FeatureParameterAdditions),
    ParameterRemovals: S.optional(FeatureParameterRemovals),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateFeatureMetadataRequest",
}) as any as S.Schema<UpdateFeatureMetadataRequest>;
export interface UpdateFeatureMetadataResponse {}
export const UpdateFeatureMetadataResponse = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "UpdateFeatureMetadataResponse",
}) as any as S.Schema<UpdateFeatureMetadataResponse>;
export interface UpdateHubRequest {
  HubName?: string;
  HubDescription?: string;
  HubDisplayName?: string;
  HubSearchKeywords?: string[];
}
export const UpdateHubRequest = S.suspend(() =>
  S.Struct({
    HubName: S.optional(S.String),
    HubDescription: S.optional(S.String),
    HubDisplayName: S.optional(S.String),
    HubSearchKeywords: S.optional(HubSearchKeywordList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateHubRequest",
}) as any as S.Schema<UpdateHubRequest>;
export interface UpdateHubResponse {
  HubArn: string;
}
export const UpdateHubResponse = S.suspend(() =>
  S.Struct({ HubArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateHubResponse",
}) as any as S.Schema<UpdateHubResponse>;
export interface UpdateHubContentRequest {
  HubName?: string;
  HubContentName?: string;
  HubContentType?: HubContentType;
  HubContentVersion?: string;
  HubContentDisplayName?: string;
  HubContentDescription?: string;
  HubContentMarkdown?: string;
  HubContentSearchKeywords?: string[];
  SupportStatus?: HubContentSupportStatus;
}
export const UpdateHubContentRequest = S.suspend(() =>
  S.Struct({
    HubName: S.optional(S.String),
    HubContentName: S.optional(S.String),
    HubContentType: S.optional(HubContentType),
    HubContentVersion: S.optional(S.String),
    HubContentDisplayName: S.optional(S.String),
    HubContentDescription: S.optional(S.String),
    HubContentMarkdown: S.optional(S.String),
    HubContentSearchKeywords: S.optional(HubContentSearchKeywordList),
    SupportStatus: S.optional(HubContentSupportStatus),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateHubContentRequest",
}) as any as S.Schema<UpdateHubContentRequest>;
export interface UpdateHubContentResponse {
  HubArn: string;
  HubContentArn: string;
}
export const UpdateHubContentResponse = S.suspend(() =>
  S.Struct({
    HubArn: S.optional(S.String),
    HubContentArn: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "UpdateHubContentResponse",
}) as any as S.Schema<UpdateHubContentResponse>;
export interface UpdateHubContentReferenceRequest {
  HubName?: string;
  HubContentName?: string;
  HubContentType?: HubContentType;
  MinVersion?: string;
}
export const UpdateHubContentReferenceRequest = S.suspend(() =>
  S.Struct({
    HubName: S.optional(S.String),
    HubContentName: S.optional(S.String),
    HubContentType: S.optional(HubContentType),
    MinVersion: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateHubContentReferenceRequest",
}) as any as S.Schema<UpdateHubContentReferenceRequest>;
export interface UpdateHubContentReferenceResponse {
  HubArn: string;
  HubContentArn: string;
}
export const UpdateHubContentReferenceResponse = S.suspend(() =>
  S.Struct({
    HubArn: S.optional(S.String),
    HubContentArn: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "UpdateHubContentReferenceResponse",
}) as any as S.Schema<UpdateHubContentReferenceResponse>;
export type ImageDeletePropertyList = string[];
export const ImageDeletePropertyList = S.Array(S.String);
export interface UpdateImageRequest {
  DeleteProperties?: string[];
  Description?: string;
  DisplayName?: string;
  ImageName?: string;
  RoleArn?: string;
}
export const UpdateImageRequest = S.suspend(() =>
  S.Struct({
    DeleteProperties: S.optional(ImageDeletePropertyList),
    Description: S.optional(S.String),
    DisplayName: S.optional(S.String),
    ImageName: S.optional(S.String),
    RoleArn: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateImageRequest",
}) as any as S.Schema<UpdateImageRequest>;
export interface UpdateImageResponse {
  ImageArn?: string;
}
export const UpdateImageResponse = S.suspend(() =>
  S.Struct({ ImageArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateImageResponse",
}) as any as S.Schema<UpdateImageResponse>;
export interface UpdateImageVersionRequest {
  ImageName?: string;
  Alias?: string;
  Version?: number;
  AliasesToAdd?: string[];
  AliasesToDelete?: string[];
  VendorGuidance?: VendorGuidance;
  JobType?: JobType;
  MLFramework?: string;
  ProgrammingLang?: string;
  Processor?: Processor;
  Horovod?: boolean;
  ReleaseNotes?: string;
}
export const UpdateImageVersionRequest = S.suspend(() =>
  S.Struct({
    ImageName: S.optional(S.String),
    Alias: S.optional(S.String),
    Version: S.optional(S.Number),
    AliasesToAdd: S.optional(SageMakerImageVersionAliases),
    AliasesToDelete: S.optional(SageMakerImageVersionAliases),
    VendorGuidance: S.optional(VendorGuidance),
    JobType: S.optional(JobType),
    MLFramework: S.optional(S.String),
    ProgrammingLang: S.optional(S.String),
    Processor: S.optional(Processor),
    Horovod: S.optional(S.Boolean),
    ReleaseNotes: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateImageVersionRequest",
}) as any as S.Schema<UpdateImageVersionRequest>;
export interface UpdateImageVersionResponse {
  ImageVersionArn?: string;
}
export const UpdateImageVersionResponse = S.suspend(() =>
  S.Struct({ ImageVersionArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateImageVersionResponse",
}) as any as S.Schema<UpdateImageVersionResponse>;
export interface UpdateInferenceComponentInput {
  InferenceComponentName?: string;
  Specification?: InferenceComponentSpecification;
  RuntimeConfig?: InferenceComponentRuntimeConfig;
  DeploymentConfig?: InferenceComponentDeploymentConfig;
}
export const UpdateInferenceComponentInput = S.suspend(() =>
  S.Struct({
    InferenceComponentName: S.optional(S.String),
    Specification: S.optional(InferenceComponentSpecification),
    RuntimeConfig: S.optional(InferenceComponentRuntimeConfig),
    DeploymentConfig: S.optional(InferenceComponentDeploymentConfig),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateInferenceComponentInput",
}) as any as S.Schema<UpdateInferenceComponentInput>;
export interface UpdateInferenceComponentOutput {
  InferenceComponentArn: string;
}
export const UpdateInferenceComponentOutput = S.suspend(() =>
  S.Struct({ InferenceComponentArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateInferenceComponentOutput",
}) as any as S.Schema<UpdateInferenceComponentOutput>;
export interface UpdateInferenceComponentRuntimeConfigInput {
  InferenceComponentName?: string;
  DesiredRuntimeConfig?: InferenceComponentRuntimeConfig;
}
export const UpdateInferenceComponentRuntimeConfigInput = S.suspend(() =>
  S.Struct({
    InferenceComponentName: S.optional(S.String),
    DesiredRuntimeConfig: S.optional(InferenceComponentRuntimeConfig),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateInferenceComponentRuntimeConfigInput",
}) as any as S.Schema<UpdateInferenceComponentRuntimeConfigInput>;
export interface UpdateInferenceComponentRuntimeConfigOutput {
  InferenceComponentArn: string;
}
export const UpdateInferenceComponentRuntimeConfigOutput = S.suspend(() =>
  S.Struct({ InferenceComponentArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateInferenceComponentRuntimeConfigOutput",
}) as any as S.Schema<UpdateInferenceComponentRuntimeConfigOutput>;
export interface UpdateInferenceExperimentRequest {
  Name?: string;
  Schedule?: InferenceExperimentSchedule;
  Description?: string;
  ModelVariants?: ModelVariantConfig[];
  DataStorageConfig?: InferenceExperimentDataStorageConfig;
  ShadowModeConfig?: ShadowModeConfig;
}
export const UpdateInferenceExperimentRequest = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Schedule: S.optional(InferenceExperimentSchedule),
    Description: S.optional(S.String),
    ModelVariants: S.optional(ModelVariantConfigList),
    DataStorageConfig: S.optional(InferenceExperimentDataStorageConfig),
    ShadowModeConfig: S.optional(ShadowModeConfig),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateInferenceExperimentRequest",
}) as any as S.Schema<UpdateInferenceExperimentRequest>;
export interface UpdateInferenceExperimentResponse {
  InferenceExperimentArn: string;
}
export const UpdateInferenceExperimentResponse = S.suspend(() =>
  S.Struct({ InferenceExperimentArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateInferenceExperimentResponse",
}) as any as S.Schema<UpdateInferenceExperimentResponse>;
export interface UpdateMlflowAppRequest {
  Arn?: string;
  Name?: string;
  ArtifactStoreUri?: string;
  ModelRegistrationMode?: ModelRegistrationMode;
  WeeklyMaintenanceWindowStart?: string;
  DefaultDomainIdList?: string[];
  AccountDefaultStatus?: AccountDefaultStatus;
}
export const UpdateMlflowAppRequest = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    ArtifactStoreUri: S.optional(S.String),
    ModelRegistrationMode: S.optional(ModelRegistrationMode),
    WeeklyMaintenanceWindowStart: S.optional(S.String),
    DefaultDomainIdList: S.optional(DefaultDomainIdList),
    AccountDefaultStatus: S.optional(AccountDefaultStatus),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateMlflowAppRequest",
}) as any as S.Schema<UpdateMlflowAppRequest>;
export interface UpdateMlflowAppResponse {
  Arn?: string;
}
export const UpdateMlflowAppResponse = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateMlflowAppResponse",
}) as any as S.Schema<UpdateMlflowAppResponse>;
export interface UpdateMlflowTrackingServerRequest {
  TrackingServerName?: string;
  ArtifactStoreUri?: string;
  TrackingServerSize?: TrackingServerSize;
  AutomaticModelRegistration?: boolean;
  WeeklyMaintenanceWindowStart?: string;
}
export const UpdateMlflowTrackingServerRequest = S.suspend(() =>
  S.Struct({
    TrackingServerName: S.optional(S.String),
    ArtifactStoreUri: S.optional(S.String),
    TrackingServerSize: S.optional(TrackingServerSize),
    AutomaticModelRegistration: S.optional(S.Boolean),
    WeeklyMaintenanceWindowStart: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateMlflowTrackingServerRequest",
}) as any as S.Schema<UpdateMlflowTrackingServerRequest>;
export interface UpdateMlflowTrackingServerResponse {
  TrackingServerArn?: string;
}
export const UpdateMlflowTrackingServerResponse = S.suspend(() =>
  S.Struct({ TrackingServerArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateMlflowTrackingServerResponse",
}) as any as S.Schema<UpdateMlflowTrackingServerResponse>;
export interface UpdateModelCardRequest {
  ModelCardName?: string;
  Content?: string | redacted.Redacted<string>;
  ModelCardStatus?: ModelCardStatus;
}
export const UpdateModelCardRequest = S.suspend(() =>
  S.Struct({
    ModelCardName: S.optional(S.String),
    Content: S.optional(SensitiveString),
    ModelCardStatus: S.optional(ModelCardStatus),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateModelCardRequest",
}) as any as S.Schema<UpdateModelCardRequest>;
export interface UpdateModelCardResponse {
  ModelCardArn: string;
}
export const UpdateModelCardResponse = S.suspend(() =>
  S.Struct({ ModelCardArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateModelCardResponse",
}) as any as S.Schema<UpdateModelCardResponse>;
export type CustomerMetadataKeyList = string[];
export const CustomerMetadataKeyList = S.Array(S.String);
export interface UpdateModelPackageInput {
  ModelPackageArn?: string;
  ModelApprovalStatus?: ModelApprovalStatus;
  ModelPackageRegistrationType?: ModelPackageRegistrationType;
  ApprovalDescription?: string;
  CustomerMetadataProperties?: { [key: string]: string | undefined };
  CustomerMetadataPropertiesToRemove?: string[];
  AdditionalInferenceSpecificationsToAdd?: AdditionalInferenceSpecificationDefinition[];
  InferenceSpecification?: InferenceSpecification;
  SourceUri?: string;
  ModelCard?: ModelPackageModelCard;
  ModelLifeCycle?: ModelLifeCycle;
  ClientToken?: string;
}
export const UpdateModelPackageInput = S.suspend(() =>
  S.Struct({
    ModelPackageArn: S.optional(S.String),
    ModelApprovalStatus: S.optional(ModelApprovalStatus),
    ModelPackageRegistrationType: S.optional(ModelPackageRegistrationType),
    ApprovalDescription: S.optional(S.String),
    CustomerMetadataProperties: S.optional(CustomerMetadataMap),
    CustomerMetadataPropertiesToRemove: S.optional(CustomerMetadataKeyList),
    AdditionalInferenceSpecificationsToAdd: S.optional(
      AdditionalInferenceSpecifications,
    ),
    InferenceSpecification: S.optional(InferenceSpecification),
    SourceUri: S.optional(S.String),
    ModelCard: S.optional(ModelPackageModelCard),
    ModelLifeCycle: S.optional(ModelLifeCycle),
    ClientToken: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateModelPackageInput",
}) as any as S.Schema<UpdateModelPackageInput>;
export interface UpdateModelPackageOutput {
  ModelPackageArn: string;
}
export const UpdateModelPackageOutput = S.suspend(() =>
  S.Struct({ ModelPackageArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateModelPackageOutput",
}) as any as S.Schema<UpdateModelPackageOutput>;
export interface UpdateMonitoringAlertRequest {
  MonitoringScheduleName?: string;
  MonitoringAlertName?: string;
  DatapointsToAlert?: number;
  EvaluationPeriod?: number;
}
export const UpdateMonitoringAlertRequest = S.suspend(() =>
  S.Struct({
    MonitoringScheduleName: S.optional(S.String),
    MonitoringAlertName: S.optional(S.String),
    DatapointsToAlert: S.optional(S.Number),
    EvaluationPeriod: S.optional(S.Number),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateMonitoringAlertRequest",
}) as any as S.Schema<UpdateMonitoringAlertRequest>;
export interface UpdateMonitoringAlertResponse {
  MonitoringScheduleArn: string;
  MonitoringAlertName?: string;
}
export const UpdateMonitoringAlertResponse = S.suspend(() =>
  S.Struct({
    MonitoringScheduleArn: S.optional(S.String),
    MonitoringAlertName: S.optional(S.String),
  }).pipe(ns),
).annotate({
  identifier: "UpdateMonitoringAlertResponse",
}) as any as S.Schema<UpdateMonitoringAlertResponse>;
export interface UpdateMonitoringScheduleRequest {
  MonitoringScheduleName?: string;
  MonitoringScheduleConfig?: MonitoringScheduleConfig;
}
export const UpdateMonitoringScheduleRequest = S.suspend(() =>
  S.Struct({
    MonitoringScheduleName: S.optional(S.String),
    MonitoringScheduleConfig: S.optional(MonitoringScheduleConfig),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateMonitoringScheduleRequest",
}) as any as S.Schema<UpdateMonitoringScheduleRequest>;
export interface UpdateMonitoringScheduleResponse {
  MonitoringScheduleArn: string;
}
export const UpdateMonitoringScheduleResponse = S.suspend(() =>
  S.Struct({ MonitoringScheduleArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateMonitoringScheduleResponse",
}) as any as S.Schema<UpdateMonitoringScheduleResponse>;
export interface UpdateNotebookInstanceInput {
  NotebookInstanceName?: string;
  InstanceType?: InstanceType;
  IpAddressType?: IPAddressType;
  PlatformIdentifier?: string;
  RoleArn?: string;
  LifecycleConfigName?: string;
  DisassociateLifecycleConfig?: boolean;
  VolumeSizeInGB?: number;
  DefaultCodeRepository?: string;
  AdditionalCodeRepositories?: string[];
  AcceleratorTypes?: NotebookInstanceAcceleratorType[];
  DisassociateAcceleratorTypes?: boolean;
  DisassociateDefaultCodeRepository?: boolean;
  DisassociateAdditionalCodeRepositories?: boolean;
  RootAccess?: RootAccess;
  InstanceMetadataServiceConfiguration?: InstanceMetadataServiceConfiguration;
}
export const UpdateNotebookInstanceInput = S.suspend(() =>
  S.Struct({
    NotebookInstanceName: S.optional(S.String),
    InstanceType: S.optional(InstanceType),
    IpAddressType: S.optional(IPAddressType),
    PlatformIdentifier: S.optional(S.String),
    RoleArn: S.optional(S.String),
    LifecycleConfigName: S.optional(S.String),
    DisassociateLifecycleConfig: S.optional(S.Boolean),
    VolumeSizeInGB: S.optional(S.Number),
    DefaultCodeRepository: S.optional(S.String),
    AdditionalCodeRepositories: S.optional(AdditionalCodeRepositoryNamesOrUrls),
    AcceleratorTypes: S.optional(NotebookInstanceAcceleratorTypes),
    DisassociateAcceleratorTypes: S.optional(S.Boolean),
    DisassociateDefaultCodeRepository: S.optional(S.Boolean),
    DisassociateAdditionalCodeRepositories: S.optional(S.Boolean),
    RootAccess: S.optional(RootAccess),
    InstanceMetadataServiceConfiguration: S.optional(
      InstanceMetadataServiceConfiguration,
    ),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateNotebookInstanceInput",
}) as any as S.Schema<UpdateNotebookInstanceInput>;
export interface UpdateNotebookInstanceOutput {}
export const UpdateNotebookInstanceOutput = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "UpdateNotebookInstanceOutput",
}) as any as S.Schema<UpdateNotebookInstanceOutput>;
export interface UpdateNotebookInstanceLifecycleConfigInput {
  NotebookInstanceLifecycleConfigName?: string;
  OnCreate?: NotebookInstanceLifecycleHook[];
  OnStart?: NotebookInstanceLifecycleHook[];
}
export const UpdateNotebookInstanceLifecycleConfigInput = S.suspend(() =>
  S.Struct({
    NotebookInstanceLifecycleConfigName: S.optional(S.String),
    OnCreate: S.optional(NotebookInstanceLifecycleConfigList),
    OnStart: S.optional(NotebookInstanceLifecycleConfigList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateNotebookInstanceLifecycleConfigInput",
}) as any as S.Schema<UpdateNotebookInstanceLifecycleConfigInput>;
export interface UpdateNotebookInstanceLifecycleConfigOutput {}
export const UpdateNotebookInstanceLifecycleConfigOutput = S.suspend(() =>
  S.Struct({}).pipe(ns),
).annotate({
  identifier: "UpdateNotebookInstanceLifecycleConfigOutput",
}) as any as S.Schema<UpdateNotebookInstanceLifecycleConfigOutput>;
export interface UpdatePartnerAppRequest {
  Arn?: string;
  MaintenanceConfig?: PartnerAppMaintenanceConfig;
  Tier?: string;
  ApplicationConfig?: PartnerAppConfig;
  EnableIamSessionBasedIdentity?: boolean;
  EnableAutoMinorVersionUpgrade?: boolean;
  AppVersion?: string;
  ClientToken?: string;
  Tags?: Tag[];
}
export const UpdatePartnerAppRequest = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    MaintenanceConfig: S.optional(PartnerAppMaintenanceConfig),
    Tier: S.optional(S.String),
    ApplicationConfig: S.optional(PartnerAppConfig),
    EnableIamSessionBasedIdentity: S.optional(S.Boolean),
    EnableAutoMinorVersionUpgrade: S.optional(S.Boolean),
    AppVersion: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdatePartnerAppRequest",
}) as any as S.Schema<UpdatePartnerAppRequest>;
export interface UpdatePartnerAppResponse {
  Arn?: string;
}
export const UpdatePartnerAppResponse = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdatePartnerAppResponse",
}) as any as S.Schema<UpdatePartnerAppResponse>;
export interface UpdatePipelineRequest {
  PipelineName?: string;
  PipelineDisplayName?: string;
  PipelineDefinition?: string;
  PipelineDefinitionS3Location?: PipelineDefinitionS3Location;
  PipelineDescription?: string;
  RoleArn?: string;
  ParallelismConfiguration?: ParallelismConfiguration;
}
export const UpdatePipelineRequest = S.suspend(() =>
  S.Struct({
    PipelineName: S.optional(S.String),
    PipelineDisplayName: S.optional(S.String),
    PipelineDefinition: S.optional(S.String),
    PipelineDefinitionS3Location: S.optional(PipelineDefinitionS3Location),
    PipelineDescription: S.optional(S.String),
    RoleArn: S.optional(S.String),
    ParallelismConfiguration: S.optional(ParallelismConfiguration),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdatePipelineRequest",
}) as any as S.Schema<UpdatePipelineRequest>;
export interface UpdatePipelineResponse {
  PipelineArn?: string;
  PipelineVersionId?: number;
}
export const UpdatePipelineResponse = S.suspend(() =>
  S.Struct({
    PipelineArn: S.optional(S.String),
    PipelineVersionId: S.optional(S.Number),
  }).pipe(ns),
).annotate({
  identifier: "UpdatePipelineResponse",
}) as any as S.Schema<UpdatePipelineResponse>;
export interface UpdatePipelineExecutionRequest {
  PipelineExecutionArn?: string;
  PipelineExecutionDescription?: string;
  PipelineExecutionDisplayName?: string;
  ParallelismConfiguration?: ParallelismConfiguration;
}
export const UpdatePipelineExecutionRequest = S.suspend(() =>
  S.Struct({
    PipelineExecutionArn: S.optional(S.String),
    PipelineExecutionDescription: S.optional(S.String),
    PipelineExecutionDisplayName: S.optional(S.String),
    ParallelismConfiguration: S.optional(ParallelismConfiguration),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdatePipelineExecutionRequest",
}) as any as S.Schema<UpdatePipelineExecutionRequest>;
export interface UpdatePipelineExecutionResponse {
  PipelineExecutionArn?: string;
}
export const UpdatePipelineExecutionResponse = S.suspend(() =>
  S.Struct({ PipelineExecutionArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdatePipelineExecutionResponse",
}) as any as S.Schema<UpdatePipelineExecutionResponse>;
export interface UpdatePipelineVersionRequest {
  PipelineArn?: string;
  PipelineVersionId?: number;
  PipelineVersionDisplayName?: string;
  PipelineVersionDescription?: string;
}
export const UpdatePipelineVersionRequest = S.suspend(() =>
  S.Struct({
    PipelineArn: S.optional(S.String),
    PipelineVersionId: S.optional(S.Number),
    PipelineVersionDisplayName: S.optional(S.String),
    PipelineVersionDescription: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdatePipelineVersionRequest",
}) as any as S.Schema<UpdatePipelineVersionRequest>;
export interface UpdatePipelineVersionResponse {
  PipelineArn?: string;
  PipelineVersionId?: number;
}
export const UpdatePipelineVersionResponse = S.suspend(() =>
  S.Struct({
    PipelineArn: S.optional(S.String),
    PipelineVersionId: S.optional(S.Number),
  }).pipe(ns),
).annotate({
  identifier: "UpdatePipelineVersionResponse",
}) as any as S.Schema<UpdatePipelineVersionResponse>;
export interface ServiceCatalogProvisioningUpdateDetails {
  ProvisioningArtifactId?: string;
  ProvisioningParameters?: ProvisioningParameter[];
}
export const ServiceCatalogProvisioningUpdateDetails = S.suspend(() =>
  S.Struct({
    ProvisioningArtifactId: S.optional(S.String),
    ProvisioningParameters: S.optional(ProvisioningParameters),
  }),
).annotate({
  identifier: "ServiceCatalogProvisioningUpdateDetails",
}) as any as S.Schema<ServiceCatalogProvisioningUpdateDetails>;
export interface CfnStackUpdateParameter {
  Key?: string;
  Value?: string;
}
export const CfnStackUpdateParameter = S.suspend(() =>
  S.Struct({ Key: S.optional(S.String), Value: S.optional(S.String) }),
).annotate({
  identifier: "CfnStackUpdateParameter",
}) as any as S.Schema<CfnStackUpdateParameter>;
export type CfnStackUpdateParameters = CfnStackUpdateParameter[];
export const CfnStackUpdateParameters = S.Array(CfnStackUpdateParameter);
export interface CfnUpdateTemplateProvider {
  TemplateName?: string;
  TemplateURL?: string;
  Parameters?: CfnStackUpdateParameter[];
}
export const CfnUpdateTemplateProvider = S.suspend(() =>
  S.Struct({
    TemplateName: S.optional(S.String),
    TemplateURL: S.optional(S.String),
    Parameters: S.optional(CfnStackUpdateParameters),
  }),
).annotate({
  identifier: "CfnUpdateTemplateProvider",
}) as any as S.Schema<CfnUpdateTemplateProvider>;
export interface UpdateTemplateProvider {
  CfnTemplateProvider?: CfnUpdateTemplateProvider;
}
export const UpdateTemplateProvider = S.suspend(() =>
  S.Struct({ CfnTemplateProvider: S.optional(CfnUpdateTemplateProvider) }),
).annotate({
  identifier: "UpdateTemplateProvider",
}) as any as S.Schema<UpdateTemplateProvider>;
export type UpdateTemplateProviderList = UpdateTemplateProvider[];
export const UpdateTemplateProviderList = S.Array(UpdateTemplateProvider);
export interface UpdateProjectInput {
  ProjectName?: string;
  ProjectDescription?: string;
  ServiceCatalogProvisioningUpdateDetails?: ServiceCatalogProvisioningUpdateDetails;
  Tags?: Tag[];
  TemplateProvidersToUpdate?: UpdateTemplateProvider[];
}
export const UpdateProjectInput = S.suspend(() =>
  S.Struct({
    ProjectName: S.optional(S.String),
    ProjectDescription: S.optional(S.String),
    ServiceCatalogProvisioningUpdateDetails: S.optional(
      ServiceCatalogProvisioningUpdateDetails,
    ),
    Tags: S.optional(TagList),
    TemplateProvidersToUpdate: S.optional(UpdateTemplateProviderList),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateProjectInput",
}) as any as S.Schema<UpdateProjectInput>;
export interface UpdateProjectOutput {
  ProjectArn: string;
}
export const UpdateProjectOutput = S.suspend(() =>
  S.Struct({ ProjectArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateProjectOutput",
}) as any as S.Schema<UpdateProjectOutput>;
export interface UpdateSpaceRequest {
  DomainId?: string;
  SpaceName?: string;
  SpaceSettings?: SpaceSettings;
  SpaceDisplayName?: string;
}
export const UpdateSpaceRequest = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    SpaceName: S.optional(S.String),
    SpaceSettings: S.optional(SpaceSettings),
    SpaceDisplayName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateSpaceRequest",
}) as any as S.Schema<UpdateSpaceRequest>;
export interface UpdateSpaceResponse {
  SpaceArn?: string;
}
export const UpdateSpaceResponse = S.suspend(() =>
  S.Struct({ SpaceArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateSpaceResponse",
}) as any as S.Schema<UpdateSpaceResponse>;
export interface ProfilerConfigForUpdate {
  S3OutputPath?: string;
  ProfilingIntervalInMilliseconds?: number;
  ProfilingParameters?: { [key: string]: string | undefined };
  DisableProfiler?: boolean;
}
export const ProfilerConfigForUpdate = S.suspend(() =>
  S.Struct({
    S3OutputPath: S.optional(S.String),
    ProfilingIntervalInMilliseconds: S.optional(S.Number),
    ProfilingParameters: S.optional(ProfilingParameters),
    DisableProfiler: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "ProfilerConfigForUpdate",
}) as any as S.Schema<ProfilerConfigForUpdate>;
export interface ResourceConfigForUpdate {
  KeepAlivePeriodInSeconds?: number;
}
export const ResourceConfigForUpdate = S.suspend(() =>
  S.Struct({ KeepAlivePeriodInSeconds: S.optional(S.Number) }),
).annotate({
  identifier: "ResourceConfigForUpdate",
}) as any as S.Schema<ResourceConfigForUpdate>;
export interface RemoteDebugConfigForUpdate {
  EnableRemoteDebug?: boolean;
}
export const RemoteDebugConfigForUpdate = S.suspend(() =>
  S.Struct({ EnableRemoteDebug: S.optional(S.Boolean) }),
).annotate({
  identifier: "RemoteDebugConfigForUpdate",
}) as any as S.Schema<RemoteDebugConfigForUpdate>;
export interface UpdateTrainingJobRequest {
  TrainingJobName?: string;
  ProfilerConfig?: ProfilerConfigForUpdate;
  ProfilerRuleConfigurations?: ProfilerRuleConfiguration[];
  ResourceConfig?: ResourceConfigForUpdate;
  RemoteDebugConfig?: RemoteDebugConfigForUpdate;
}
export const UpdateTrainingJobRequest = S.suspend(() =>
  S.Struct({
    TrainingJobName: S.optional(S.String),
    ProfilerConfig: S.optional(ProfilerConfigForUpdate),
    ProfilerRuleConfigurations: S.optional(ProfilerRuleConfigurations),
    ResourceConfig: S.optional(ResourceConfigForUpdate),
    RemoteDebugConfig: S.optional(RemoteDebugConfigForUpdate),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateTrainingJobRequest",
}) as any as S.Schema<UpdateTrainingJobRequest>;
export interface UpdateTrainingJobResponse {
  TrainingJobArn: string;
}
export const UpdateTrainingJobResponse = S.suspend(() =>
  S.Struct({ TrainingJobArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateTrainingJobResponse",
}) as any as S.Schema<UpdateTrainingJobResponse>;
export interface UpdateTrialRequest {
  TrialName?: string;
  DisplayName?: string;
}
export const UpdateTrialRequest = S.suspend(() =>
  S.Struct({
    TrialName: S.optional(S.String),
    DisplayName: S.optional(S.String),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateTrialRequest",
}) as any as S.Schema<UpdateTrialRequest>;
export interface UpdateTrialResponse {
  TrialArn?: string;
}
export const UpdateTrialResponse = S.suspend(() =>
  S.Struct({ TrialArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateTrialResponse",
}) as any as S.Schema<UpdateTrialResponse>;
export type ListTrialComponentKey256 = string[];
export const ListTrialComponentKey256 = S.Array(S.String);
export interface UpdateTrialComponentRequest {
  TrialComponentName?: string;
  DisplayName?: string;
  Status?: TrialComponentStatus;
  StartTime?: Date;
  EndTime?: Date;
  Parameters?: { [key: string]: TrialComponentParameterValue | undefined };
  ParametersToRemove?: string[];
  InputArtifacts?: { [key: string]: TrialComponentArtifact | undefined };
  InputArtifactsToRemove?: string[];
  OutputArtifacts?: { [key: string]: TrialComponentArtifact | undefined };
  OutputArtifactsToRemove?: string[];
}
export const UpdateTrialComponentRequest = S.suspend(() =>
  S.Struct({
    TrialComponentName: S.optional(S.String),
    DisplayName: S.optional(S.String),
    Status: S.optional(TrialComponentStatus),
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Parameters: S.optional(TrialComponentParameters),
    ParametersToRemove: S.optional(ListTrialComponentKey256),
    InputArtifacts: S.optional(TrialComponentArtifacts),
    InputArtifactsToRemove: S.optional(ListTrialComponentKey256),
    OutputArtifacts: S.optional(TrialComponentArtifacts),
    OutputArtifactsToRemove: S.optional(ListTrialComponentKey256),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateTrialComponentRequest",
}) as any as S.Schema<UpdateTrialComponentRequest>;
export interface UpdateTrialComponentResponse {
  TrialComponentArn?: string;
}
export const UpdateTrialComponentResponse = S.suspend(() =>
  S.Struct({ TrialComponentArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateTrialComponentResponse",
}) as any as S.Schema<UpdateTrialComponentResponse>;
export interface UpdateUserProfileRequest {
  DomainId?: string;
  UserProfileName?: string;
  UserSettings?: UserSettings;
}
export const UpdateUserProfileRequest = S.suspend(() =>
  S.Struct({
    DomainId: S.optional(S.String),
    UserProfileName: S.optional(S.String),
    UserSettings: S.optional(UserSettings),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateUserProfileRequest",
}) as any as S.Schema<UpdateUserProfileRequest>;
export interface UpdateUserProfileResponse {
  UserProfileArn?: string;
}
export const UpdateUserProfileResponse = S.suspend(() =>
  S.Struct({ UserProfileArn: S.optional(S.String) }).pipe(ns),
).annotate({
  identifier: "UpdateUserProfileResponse",
}) as any as S.Schema<UpdateUserProfileResponse>;
export interface UpdateWorkforceRequest {
  WorkforceName?: string;
  SourceIpConfig?: SourceIpConfig;
  OidcConfig?: OidcConfig;
  WorkforceVpcConfig?: WorkforceVpcConfigRequest;
  IpAddressType?: WorkforceIpAddressType;
}
export const UpdateWorkforceRequest = S.suspend(() =>
  S.Struct({
    WorkforceName: S.optional(S.String),
    SourceIpConfig: S.optional(SourceIpConfig),
    OidcConfig: S.optional(OidcConfig),
    WorkforceVpcConfig: S.optional(WorkforceVpcConfigRequest),
    IpAddressType: S.optional(WorkforceIpAddressType),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateWorkforceRequest",
}) as any as S.Schema<UpdateWorkforceRequest>;
export interface UpdateWorkforceResponse {
  Workforce: Workforce & {
    WorkforceName: WorkforceName;
    WorkforceArn: WorkforceArn;
    SourceIpConfig: SourceIpConfig & { Cidrs: Cidrs };
    CognitoConfig: CognitoConfig & {
      UserPool: CognitoUserPool;
      ClientId: ClientId;
    };
    WorkforceVpcConfig: WorkforceVpcConfigResponse & {
      VpcId: WorkforceVpcId;
      SecurityGroupIds: WorkforceSecurityGroupIds;
      Subnets: WorkforceSubnets;
    };
  };
}
export const UpdateWorkforceResponse = S.suspend(() =>
  S.Struct({ Workforce: S.optional(Workforce) }).pipe(ns),
).annotate({
  identifier: "UpdateWorkforceResponse",
}) as any as S.Schema<UpdateWorkforceResponse>;
export interface UpdateWorkteamRequest {
  WorkteamName?: string;
  MemberDefinitions?: MemberDefinition[];
  Description?: string;
  NotificationConfiguration?: NotificationConfiguration;
  WorkerAccessConfiguration?: WorkerAccessConfiguration;
}
export const UpdateWorkteamRequest = S.suspend(() =>
  S.Struct({
    WorkteamName: S.optional(S.String),
    MemberDefinitions: S.optional(MemberDefinitions),
    Description: S.optional(S.String),
    NotificationConfiguration: S.optional(NotificationConfiguration),
    WorkerAccessConfiguration: S.optional(WorkerAccessConfiguration),
  }).pipe(
    T.all(
      ns,
      T.Http({ method: "POST", uri: "/" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateWorkteamRequest",
}) as any as S.Schema<UpdateWorkteamRequest>;
export interface UpdateWorkteamResponse {
  Workteam: Workteam & {
    WorkteamName: WorkteamName;
    MemberDefinitions: (MemberDefinition & {
      CognitoMemberDefinition: CognitoMemberDefinition & {
        UserPool: CognitoUserPool;
        UserGroup: CognitoUserGroup;
        ClientId: ClientId;
      };
    })[];
    WorkteamArn: WorkteamArn;
    Description: String200;
  };
}
export const UpdateWorkteamResponse = S.suspend(() =>
  S.Struct({ Workteam: S.optional(Workteam) }).pipe(ns),
).annotate({
  identifier: "UpdateWorkteamResponse",
}) as any as S.Schema<UpdateWorkteamResponse>;

//# Errors
export class ResourceLimitExceeded extends S.TaggedErrorClass<ResourceLimitExceeded>()(
  "ResourceLimitExceeded",
  { Message: S.optional(S.String) },
).pipe(C.withThrottlingError) {}
export class ResourceNotFound extends S.TaggedErrorClass<ResourceNotFound>()(
  "ResourceNotFound",
  { Message: S.optional(S.String) },
) {}
export class ResourceInUse extends S.TaggedErrorClass<ResourceInUse>()(
  "ResourceInUse",
  { Message: S.optional(S.String) },
).pipe(C.withDependencyViolationError) {}
export class ConflictException extends S.TaggedErrorClass<ConflictException>()(
  "ConflictException",
  { Message: S.optional(S.String) },
) {}

//# Operations
/**
 * Creates an *association* between the source and the destination. A source can be associated with multiple destinations, and a destination can be associated with multiple sources. An association is a lineage tracking entity. For more information, see Amazon SageMaker ML Lineage Tracking.
 */
export const addAssociation: (
  input: AddAssociationRequest,
) => effect.Effect<
  AddAssociationResponse,
  ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AddAssociationRequest,
  output: AddAssociationResponse,
  errors: [ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Adds or overwrites one or more tags for the specified SageMaker resource. You can add tags to notebook instances, training jobs, hyperparameter tuning jobs, batch transform jobs, models, labeling jobs, work teams, endpoint configurations, and endpoints.
 *
 * Each tag consists of a key and an optional value. Tag keys must be unique per resource. For more information about tags, see For more information, see Amazon Web Services Tagging Strategies.
 *
 * Tags that you add to a hyperparameter tuning job by calling this API are also added to any training jobs that the hyperparameter tuning job launches after you call this API, but not to training jobs that the hyperparameter tuning job launched before you called this API. To make sure that the tags associated with a hyperparameter tuning job are also added to all training jobs that the hyperparameter tuning job launches, add the tags when you first create the tuning job by specifying them in the `Tags` parameter of CreateHyperParameterTuningJob
 *
 * Tags that you add to a SageMaker Domain or User Profile by calling this API are also added to any Apps that the Domain or User Profile launches after you call this API, but not to Apps that the Domain or User Profile launched before you called this API. To make sure that the tags associated with a Domain or User Profile are also added to all Apps that the Domain or User Profile launches, add the tags when you first create the Domain or User Profile by specifying them in the `Tags` parameter of CreateDomain or CreateUserProfile.
 */
export const addTags: (
  input: AddTagsInput,
) => effect.Effect<
  AddTagsOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AddTagsInput,
  output: AddTagsOutput,
  errors: [],
}));
/**
 * Associates a trial component with a trial. A trial component can be associated with multiple trials. To disassociate a trial component from a trial, call the DisassociateTrialComponent API.
 */
export const associateTrialComponent: (
  input: AssociateTrialComponentRequest,
) => effect.Effect<
  AssociateTrialComponentResponse,
  ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateTrialComponentRequest,
  output: AssociateTrialComponentResponse,
  errors: [ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Attaches your Amazon Elastic Block Store (Amazon EBS) volume to a node in your EKS orchestrated HyperPod cluster.
 *
 * This API works with the Amazon Elastic Block Store (Amazon EBS) Container Storage Interface (CSI) driver to manage the lifecycle of persistent storage in your HyperPod EKS clusters.
 */
export const attachClusterNodeVolume: (
  input: AttachClusterNodeVolumeRequest,
) => effect.Effect<
  AttachClusterNodeVolumeResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AttachClusterNodeVolumeRequest,
  output: AttachClusterNodeVolumeResponse,
  errors: [ResourceNotFound],
}));
/**
 * Adds nodes to a HyperPod cluster by incrementing the target count for one or more instance groups. This operation returns a unique `NodeLogicalId` for each node being added, which can be used to track the provisioning status of the node. This API provides a safer alternative to `UpdateCluster` for scaling operations by avoiding unintended configuration changes.
 *
 * This API is only supported for clusters using `Continuous` as the `NodeProvisioningMode`.
 */
export const batchAddClusterNodes: (
  input: BatchAddClusterNodesRequest,
) => effect.Effect<
  BatchAddClusterNodesResponse,
  ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchAddClusterNodesRequest,
  output: BatchAddClusterNodesResponse,
  errors: [ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Deletes specific nodes within a SageMaker HyperPod cluster. `BatchDeleteClusterNodes` accepts a cluster name and a list of node IDs.
 *
 * - To safeguard your work, back up your data to Amazon S3 or an FSx for Lustre file system before invoking the API on a worker node group. This will help prevent any potential data loss from the instance root volume. For more information about backup, see Use the backup script provided by SageMaker HyperPod.
 *
 * - If you want to invoke this API on an existing cluster, you'll first need to patch the cluster by running the UpdateClusterSoftware API. For more information about patching a cluster, see Update the SageMaker HyperPod platform software of a cluster.
 */
export const batchDeleteClusterNodes: (
  input: BatchDeleteClusterNodesRequest,
) => effect.Effect<
  BatchDeleteClusterNodesResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchDeleteClusterNodesRequest,
  output: BatchDeleteClusterNodesResponse,
  errors: [ResourceNotFound],
}));
/**
 * This action batch describes a list of versioned model packages
 */
export const batchDescribeModelPackage: (
  input: BatchDescribeModelPackageInput,
) => effect.Effect<
  BatchDescribeModelPackageOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchDescribeModelPackageInput,
  output: BatchDescribeModelPackageOutput,
  errors: [],
}));
/**
 * Reboots specific nodes within a SageMaker HyperPod cluster using a soft recovery mechanism. `BatchRebootClusterNodes` performs a graceful reboot of the specified nodes by calling the Amazon Elastic Compute Cloud `RebootInstances` API, which attempts to cleanly shut down the operating system before restarting the instance.
 *
 * This operation is useful for recovering from transient issues or applying certain configuration changes that require a restart.
 *
 * - Rebooting a node may cause temporary service interruption for workloads running on that node. Ensure your workloads can handle node restarts or use appropriate scheduling to minimize impact.
 *
 * - You can reboot up to 25 nodes in a single request.
 *
 * - For SageMaker HyperPod clusters using the Slurm workload manager, ensure rebooting nodes will not disrupt critical cluster operations.
 */
export const batchRebootClusterNodes: (
  input: BatchRebootClusterNodesRequest,
) => effect.Effect<
  BatchRebootClusterNodesResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchRebootClusterNodesRequest,
  output: BatchRebootClusterNodesResponse,
  errors: [ResourceNotFound],
}));
/**
 * Replaces specific nodes within a SageMaker HyperPod cluster with new hardware. `BatchReplaceClusterNodes` terminates the specified instances and provisions new replacement instances with the same configuration but fresh hardware. The Amazon Machine Image (AMI) and instance configuration remain the same.
 *
 * This operation is useful for recovering from hardware failures or persistent issues that cannot be resolved through a reboot.
 *
 * - **Data Loss Warning:** Replacing nodes destroys all instance volumes, including both root and secondary volumes. All data stored on these volumes will be permanently lost and cannot be recovered.
 *
 * - To safeguard your work, back up your data to Amazon S3 or an FSx for Lustre file system before invoking the API on a worker node group. This will help prevent any potential data loss from the instance root volume. For more information about backup, see Use the backup script provided by SageMaker HyperPod.
 *
 * - If you want to invoke this API on an existing cluster, you'll first need to patch the cluster by running the UpdateClusterSoftware API. For more information about patching a cluster, see Update the SageMaker HyperPod platform software of a cluster.
 *
 * - You can replace up to 25 nodes in a single request.
 */
export const batchReplaceClusterNodes: (
  input: BatchReplaceClusterNodesRequest,
) => effect.Effect<
  BatchReplaceClusterNodesResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchReplaceClusterNodesRequest,
  output: BatchReplaceClusterNodesResponse,
  errors: [ResourceNotFound],
}));
/**
 * Creates an *action*. An action is a lineage tracking entity that represents an action or activity. For example, a model deployment or an HPO job. Generally, an action involves at least one input or output artifact. For more information, see Amazon SageMaker ML Lineage Tracking.
 */
export const createAction: (
  input: CreateActionRequest,
) => effect.Effect<
  CreateActionResponse,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateActionRequest,
  output: CreateActionResponse,
  errors: [ResourceLimitExceeded],
}));
/**
 * Create a machine learning algorithm that you can use in SageMaker and list in the Amazon Web Services Marketplace.
 */
export const createAlgorithm: (
  input: CreateAlgorithmInput,
) => effect.Effect<
  CreateAlgorithmOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateAlgorithmInput,
  output: CreateAlgorithmOutput,
  errors: [],
}));
/**
 * Creates a running app for the specified UserProfile. This operation is automatically invoked by Amazon SageMaker AI upon access to the associated Domain, and when new kernel configurations are selected by the user. A user may have multiple Apps active simultaneously.
 */
export const createApp: (
  input: CreateAppRequest,
) => effect.Effect<
  CreateAppResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateAppRequest,
  output: CreateAppResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Creates a configuration for running a SageMaker AI image as a KernelGateway app. The configuration specifies the Amazon Elastic File System storage volume on the image, and a list of the kernels in the image.
 */
export const createAppImageConfig: (
  input: CreateAppImageConfigRequest,
) => effect.Effect<
  CreateAppImageConfigResponse,
  ResourceInUse | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateAppImageConfigRequest,
  output: CreateAppImageConfigResponse,
  errors: [ResourceInUse],
}));
/**
 * Creates an *artifact*. An artifact is a lineage tracking entity that represents a URI addressable object or data. Some examples are the S3 URI of a dataset and the ECR registry path of an image. For more information, see Amazon SageMaker ML Lineage Tracking.
 */
export const createArtifact: (
  input: CreateArtifactRequest,
) => effect.Effect<
  CreateArtifactResponse,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateArtifactRequest,
  output: CreateArtifactResponse,
  errors: [ResourceLimitExceeded],
}));
/**
 * Creates an Autopilot job also referred to as Autopilot experiment or AutoML job.
 *
 * An AutoML job in SageMaker AI is a fully automated process that allows you to build machine learning models with minimal effort and machine learning expertise. When initiating an AutoML job, you provide your data and optionally specify parameters tailored to your use case. SageMaker AI then automates the entire model development lifecycle, including data preprocessing, model training, tuning, and evaluation. AutoML jobs are designed to simplify and accelerate the model building process by automating various tasks and exploring different combinations of machine learning algorithms, data preprocessing techniques, and hyperparameter values. The output of an AutoML job comprises one or more trained models ready for deployment and inference. Additionally, SageMaker AI AutoML jobs generate a candidate model leaderboard, allowing you to select the best-performing model for deployment.
 *
 * For more information about AutoML jobs, see https://docs.aws.amazon.com/sagemaker/latest/dg/autopilot-automate-model-development.html in the SageMaker AI developer guide.
 *
 * We recommend using the new versions CreateAutoMLJobV2 and DescribeAutoMLJobV2, which offer backward compatibility.
 *
 * `CreateAutoMLJobV2` can manage tabular problem types identical to those of its previous version `CreateAutoMLJob`, as well as time-series forecasting, non-tabular problem types such as image or text classification, and text generation (LLMs fine-tuning).
 *
 * Find guidelines about how to migrate a `CreateAutoMLJob` to `CreateAutoMLJobV2` in Migrate a CreateAutoMLJob to CreateAutoMLJobV2.
 *
 * You can find the best-performing model after you run an AutoML job by calling DescribeAutoMLJobV2 (recommended) or DescribeAutoMLJob.
 */
export const createAutoMLJob: (
  input: CreateAutoMLJobRequest,
) => effect.Effect<
  CreateAutoMLJobResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateAutoMLJobRequest,
  output: CreateAutoMLJobResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Creates an Autopilot job also referred to as Autopilot experiment or AutoML job V2.
 *
 * An AutoML job in SageMaker AI is a fully automated process that allows you to build machine learning models with minimal effort and machine learning expertise. When initiating an AutoML job, you provide your data and optionally specify parameters tailored to your use case. SageMaker AI then automates the entire model development lifecycle, including data preprocessing, model training, tuning, and evaluation. AutoML jobs are designed to simplify and accelerate the model building process by automating various tasks and exploring different combinations of machine learning algorithms, data preprocessing techniques, and hyperparameter values. The output of an AutoML job comprises one or more trained models ready for deployment and inference. Additionally, SageMaker AI AutoML jobs generate a candidate model leaderboard, allowing you to select the best-performing model for deployment.
 *
 * For more information about AutoML jobs, see https://docs.aws.amazon.com/sagemaker/latest/dg/autopilot-automate-model-development.html in the SageMaker AI developer guide.
 *
 * AutoML jobs V2 support various problem types such as regression, binary, and multiclass classification with tabular data, text and image classification, time-series forecasting, and fine-tuning of large language models (LLMs) for text generation.
 *
 * CreateAutoMLJobV2 and DescribeAutoMLJobV2 are new versions of CreateAutoMLJob and DescribeAutoMLJob which offer backward compatibility.
 *
 * `CreateAutoMLJobV2` can manage tabular problem types identical to those of its previous version `CreateAutoMLJob`, as well as time-series forecasting, non-tabular problem types such as image or text classification, and text generation (LLMs fine-tuning).
 *
 * Find guidelines about how to migrate a `CreateAutoMLJob` to `CreateAutoMLJobV2` in Migrate a CreateAutoMLJob to CreateAutoMLJobV2.
 *
 * For the list of available problem types supported by `CreateAutoMLJobV2`, see AutoMLProblemTypeConfig.
 *
 * You can find the best-performing model after you run an AutoML job V2 by calling DescribeAutoMLJobV2.
 */
export const createAutoMLJobV2: (
  input: CreateAutoMLJobV2Request,
) => effect.Effect<
  CreateAutoMLJobV2Response,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateAutoMLJobV2Request,
  output: CreateAutoMLJobV2Response,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Creates an Amazon SageMaker HyperPod cluster. SageMaker HyperPod is a capability of SageMaker for creating and managing persistent clusters for developing large machine learning models, such as large language models (LLMs) and diffusion models. To learn more, see Amazon SageMaker HyperPod in the *Amazon SageMaker Developer Guide*.
 */
export const createCluster: (
  input: CreateClusterRequest,
) => effect.Effect<
  CreateClusterResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateClusterRequest,
  output: CreateClusterResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Create cluster policy configuration. This policy is used for task prioritization and fair-share allocation of idle compute. This helps prioritize critical workloads and distributes idle compute across entities.
 */
export const createClusterSchedulerConfig: (
  input: CreateClusterSchedulerConfigRequest,
) => effect.Effect<
  CreateClusterSchedulerConfigResponse,
  ConflictException | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateClusterSchedulerConfigRequest,
  output: CreateClusterSchedulerConfigResponse,
  errors: [ConflictException, ResourceLimitExceeded],
}));
/**
 * Creates a Git repository as a resource in your SageMaker AI account. You can associate the repository with notebook instances so that you can use Git source control for the notebooks you create. The Git repository is a resource in your SageMaker AI account, so it can be associated with more than one notebook instance, and it persists independently from the lifecycle of any notebook instances it is associated with.
 *
 * The repository can be hosted either in Amazon Web Services CodeCommit or in any other Git repository.
 */
export const createCodeRepository: (
  input: CreateCodeRepositoryInput,
) => effect.Effect<
  CreateCodeRepositoryOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateCodeRepositoryInput,
  output: CreateCodeRepositoryOutput,
  errors: [],
}));
/**
 * Starts a model compilation job. After the model has been compiled, Amazon SageMaker AI saves the resulting model artifacts to an Amazon Simple Storage Service (Amazon S3) bucket that you specify.
 *
 * If you choose to host your model using Amazon SageMaker AI hosting services, you can use the resulting model artifacts as part of the model. You can also use the artifacts with Amazon Web Services IoT Greengrass. In that case, deploy them as an ML resource.
 *
 * In the request body, you provide the following:
 *
 * - A name for the compilation job
 *
 * - Information about the input model artifacts
 *
 * - The output location for the compiled model and the device (target) that the model runs on
 *
 * - The Amazon Resource Name (ARN) of the IAM role that Amazon SageMaker AI assumes to perform the model compilation job.
 *
 * You can also provide a `Tag` to track the model compilation job's resource use and costs. The response body contains the `CompilationJobArn` for the compiled job.
 *
 * To stop a model compilation job, use StopCompilationJob. To get information about a particular model compilation job, use DescribeCompilationJob. To get information about multiple model compilation jobs, use ListCompilationJobs.
 */
export const createCompilationJob: (
  input: CreateCompilationJobRequest,
) => effect.Effect<
  CreateCompilationJobResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateCompilationJobRequest,
  output: CreateCompilationJobResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Create compute allocation definition. This defines how compute is allocated, shared, and borrowed for specified entities. Specifically, how to lend and borrow idle compute and assign a fair-share weight to the specified entities.
 */
export const createComputeQuota: (
  input: CreateComputeQuotaRequest,
) => effect.Effect<
  CreateComputeQuotaResponse,
  ConflictException | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateComputeQuotaRequest,
  output: CreateComputeQuotaResponse,
  errors: [ConflictException, ResourceLimitExceeded],
}));
/**
 * Creates a *context*. A context is a lineage tracking entity that represents a logical grouping of other tracking or experiment entities. Some examples are an endpoint and a model package. For more information, see Amazon SageMaker ML Lineage Tracking.
 */
export const createContext: (
  input: CreateContextRequest,
) => effect.Effect<
  CreateContextResponse,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateContextRequest,
  output: CreateContextResponse,
  errors: [ResourceLimitExceeded],
}));
/**
 * Creates a definition for a job that monitors data quality and drift. For information about model monitor, see Amazon SageMaker AI Model Monitor.
 */
export const createDataQualityJobDefinition: (
  input: CreateDataQualityJobDefinitionRequest,
) => effect.Effect<
  CreateDataQualityJobDefinitionResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateDataQualityJobDefinitionRequest,
  output: CreateDataQualityJobDefinitionResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Creates a device fleet.
 */
export const createDeviceFleet: (
  input: CreateDeviceFleetRequest,
) => effect.Effect<
  CreateDeviceFleetResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateDeviceFleetRequest,
  output: CreateDeviceFleetResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Creates a `Domain`. A domain consists of an associated Amazon Elastic File System volume, a list of authorized users, and a variety of security, application, policy, and Amazon Virtual Private Cloud (VPC) configurations. Users within a domain can share notebook files and other artifacts with each other.
 *
 * **EFS storage**
 *
 * When a domain is created, an EFS volume is created for use by all of the users within the domain. Each user receives a private home directory within the EFS volume for notebooks, Git repositories, and data files.
 *
 * SageMaker AI uses the Amazon Web Services Key Management Service (Amazon Web Services KMS) to encrypt the EFS volume attached to the domain with an Amazon Web Services managed key by default. For more control, you can specify a customer managed key. For more information, see Protect Data at Rest Using Encryption.
 *
 * **VPC configuration**
 *
 * All traffic between the domain and the Amazon EFS volume is through the specified VPC and subnets. For other traffic, you can specify the `AppNetworkAccessType` parameter. `AppNetworkAccessType` corresponds to the network access type that you choose when you onboard to the domain. The following options are available:
 *
 * - `PublicInternetOnly` - Non-EFS traffic goes through a VPC managed by Amazon SageMaker AI, which allows internet access. This is the default value.
 *
 * - `VpcOnly` - All traffic is through the specified VPC and subnets. Internet access is disabled by default. To allow internet access, you must specify a NAT gateway.
 *
 * When internet access is disabled, you won't be able to run a Amazon SageMaker AI Studio notebook or to train or host models unless your VPC has an interface endpoint to the SageMaker AI API and runtime or a NAT gateway and your security groups allow outbound connections.
 *
 * NFS traffic over TCP on port 2049 needs to be allowed in both inbound and outbound rules in order to launch a Amazon SageMaker AI Studio app successfully.
 *
 * For more information, see Connect Amazon SageMaker AI Studio Notebooks to Resources in a VPC.
 */
export const createDomain: (
  input: CreateDomainRequest,
) => effect.Effect<
  CreateDomainResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateDomainRequest,
  output: CreateDomainResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Creates an edge deployment plan, consisting of multiple stages. Each stage may have a different deployment configuration and devices.
 */
export const createEdgeDeploymentPlan: (
  input: CreateEdgeDeploymentPlanRequest,
) => effect.Effect<
  CreateEdgeDeploymentPlanResponse,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateEdgeDeploymentPlanRequest,
  output: CreateEdgeDeploymentPlanResponse,
  errors: [ResourceLimitExceeded],
}));
/**
 * Creates a new stage in an existing edge deployment plan.
 */
export const createEdgeDeploymentStage: (
  input: CreateEdgeDeploymentStageRequest,
) => effect.Effect<
  CreateEdgeDeploymentStageResponse,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateEdgeDeploymentStageRequest,
  output: CreateEdgeDeploymentStageResponse,
  errors: [ResourceLimitExceeded],
}));
/**
 * Starts a SageMaker Edge Manager model packaging job. Edge Manager will use the model artifacts from the Amazon Simple Storage Service bucket that you specify. After the model has been packaged, Amazon SageMaker saves the resulting artifacts to an S3 bucket that you specify.
 */
export const createEdgePackagingJob: (
  input: CreateEdgePackagingJobRequest,
) => effect.Effect<
  CreateEdgePackagingJobResponse,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateEdgePackagingJobRequest,
  output: CreateEdgePackagingJobResponse,
  errors: [ResourceLimitExceeded],
}));
/**
 * Creates an endpoint using the endpoint configuration specified in the request. SageMaker uses the endpoint to provision resources and deploy models. You create the endpoint configuration with the CreateEndpointConfig API.
 *
 * Use this API to deploy models using SageMaker hosting services.
 *
 * You must not delete an `EndpointConfig` that is in use by an endpoint that is live or while the `UpdateEndpoint` or `CreateEndpoint` operations are being performed on the endpoint. To update an endpoint, you must create a new `EndpointConfig`.
 *
 * The endpoint name must be unique within an Amazon Web Services Region in your Amazon Web Services account.
 *
 * When it receives the request, SageMaker creates the endpoint, launches the resources (ML compute instances), and deploys the model(s) on them.
 *
 * When you call CreateEndpoint, a load call is made to DynamoDB to verify that your endpoint configuration exists. When you read data from a DynamoDB table supporting `Eventually Consistent Reads` , the response might not reflect the results of a recently completed write operation. The response might include some stale data. If the dependent entities are not yet in DynamoDB, this causes a validation error. If you repeat your read request after a short time, the response should return the latest data. So retry logic is recommended to handle these possible issues. We also recommend that customers call DescribeEndpointConfig before calling CreateEndpoint to minimize the potential impact of a DynamoDB eventually consistent read.
 *
 * When SageMaker receives the request, it sets the endpoint status to `Creating`. After it creates the endpoint, it sets the status to `InService`. SageMaker can then process incoming requests for inferences. To check the status of an endpoint, use the DescribeEndpoint API.
 *
 * If any of the models hosted at this endpoint get model data from an Amazon S3 location, SageMaker uses Amazon Web Services Security Token Service to download model artifacts from the S3 path you provided. Amazon Web Services STS is activated in your Amazon Web Services account by default. If you previously deactivated Amazon Web Services STS for a region, you need to reactivate Amazon Web Services STS for that region. For more information, see Activating and Deactivating Amazon Web Services STS in an Amazon Web Services Region in the *Amazon Web Services Identity and Access Management User Guide*.
 *
 * To add the IAM role policies for using this API operation, go to the IAM console, and choose Roles in the left navigation pane. Search the IAM role that you want to grant access to use the CreateEndpoint and CreateEndpointConfig API operations, add the following policies to the role.
 *
 * - Option 1: For a full SageMaker access, search and attach the `AmazonSageMakerFullAccess` policy.
 *
 * - Option 2: For granting a limited access to an IAM role, paste the following Action elements manually into the JSON file of the IAM role:
 *
 * `"Action": ["sagemaker:CreateEndpoint", "sagemaker:CreateEndpointConfig"]`
 *
 * `"Resource": [`
 *
 * `"arn:aws:sagemaker:region:account-id:endpoint/endpointName"`
 *
 * `"arn:aws:sagemaker:region:account-id:endpoint-config/endpointConfigName"`
 *
 * `]`
 *
 * For more information, see SageMaker API Permissions: Actions, Permissions, and Resources Reference.
 */
export const createEndpoint: (
  input: CreateEndpointInput,
) => effect.Effect<
  CreateEndpointOutput,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateEndpointInput,
  output: CreateEndpointOutput,
  errors: [ResourceLimitExceeded],
}));
/**
 * Creates an endpoint configuration that SageMaker hosting services uses to deploy models. In the configuration, you identify one or more models, created using the `CreateModel` API, to deploy and the resources that you want SageMaker to provision. Then you call the CreateEndpoint API.
 *
 * Use this API if you want to use SageMaker hosting services to deploy models into production.
 *
 * In the request, you define a `ProductionVariant`, for each model that you want to deploy. Each `ProductionVariant` parameter also describes the resources that you want SageMaker to provision. This includes the number and type of ML compute instances to deploy.
 *
 * If you are hosting multiple models, you also assign a `VariantWeight` to specify how much traffic you want to allocate to each model. For example, suppose that you want to host two models, A and B, and you assign traffic weight 2 for model A and 1 for model B. SageMaker distributes two-thirds of the traffic to Model A, and one-third to model B.
 *
 * When you call CreateEndpoint, a load call is made to DynamoDB to verify that your endpoint configuration exists. When you read data from a DynamoDB table supporting `Eventually Consistent Reads` , the response might not reflect the results of a recently completed write operation. The response might include some stale data. If the dependent entities are not yet in DynamoDB, this causes a validation error. If you repeat your read request after a short time, the response should return the latest data. So retry logic is recommended to handle these possible issues. We also recommend that customers call DescribeEndpointConfig before calling CreateEndpoint to minimize the potential impact of a DynamoDB eventually consistent read.
 */
export const createEndpointConfig: (
  input: CreateEndpointConfigInput,
) => effect.Effect<
  CreateEndpointConfigOutput,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateEndpointConfigInput,
  output: CreateEndpointConfigOutput,
  errors: [ResourceLimitExceeded],
}));
/**
 * Creates a SageMaker *experiment*. An experiment is a collection of *trials* that are observed, compared and evaluated as a group. A trial is a set of steps, called *trial components*, that produce a machine learning model.
 *
 * In the Studio UI, trials are referred to as *run groups* and trial components are referred to as *runs*.
 *
 * The goal of an experiment is to determine the components that produce the best model. Multiple trials are performed, each one isolating and measuring the impact of a change to one or more inputs, while keeping the remaining inputs constant.
 *
 * When you use SageMaker Studio or the SageMaker Python SDK, all experiments, trials, and trial components are automatically tracked, logged, and indexed. When you use the Amazon Web Services SDK for Python (Boto), you must use the logging APIs provided by the SDK.
 *
 * You can add tags to experiments, trials, trial components and then use the Search API to search for the tags.
 *
 * To add a description to an experiment, specify the optional `Description` parameter. To add a description later, or to change the description, call the UpdateExperiment API.
 *
 * To get a list of all your experiments, call the ListExperiments API. To view an experiment's properties, call the DescribeExperiment API. To get a list of all the trials associated with an experiment, call the ListTrials API. To create a trial call the CreateTrial API.
 */
export const createExperiment: (
  input: CreateExperimentRequest,
) => effect.Effect<
  CreateExperimentResponse,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateExperimentRequest,
  output: CreateExperimentResponse,
  errors: [ResourceLimitExceeded],
}));
/**
 * Create a new `FeatureGroup`. A `FeatureGroup` is a group of `Features` defined in the `FeatureStore` to describe a `Record`.
 *
 * The `FeatureGroup` defines the schema and features contained in the `FeatureGroup`. A `FeatureGroup` definition is composed of a list of `Features`, a `RecordIdentifierFeatureName`, an `EventTimeFeatureName` and configurations for its `OnlineStore` and `OfflineStore`. Check Amazon Web Services service quotas to see the `FeatureGroup`s quota for your Amazon Web Services account.
 *
 * Note that it can take approximately 10-15 minutes to provision an `OnlineStore` `FeatureGroup` with the `InMemory` `StorageType`.
 *
 * You must include at least one of `OnlineStoreConfig` and `OfflineStoreConfig` to create a `FeatureGroup`.
 */
export const createFeatureGroup: (
  input: CreateFeatureGroupRequest,
) => effect.Effect<
  CreateFeatureGroupResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateFeatureGroupRequest,
  output: CreateFeatureGroupResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Creates a flow definition.
 */
export const createFlowDefinition: (
  input: CreateFlowDefinitionRequest,
) => effect.Effect<
  CreateFlowDefinitionResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateFlowDefinitionRequest,
  output: CreateFlowDefinitionResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Create a hub.
 */
export const createHub: (
  input: CreateHubRequest,
) => effect.Effect<
  CreateHubResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateHubRequest,
  output: CreateHubResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Creates presigned URLs for accessing hub content artifacts. This operation generates time-limited, secure URLs that allow direct download of model artifacts and associated files from Amazon SageMaker hub content, including gated models that require end-user license agreement acceptance.
 */
export const createHubContentPresignedUrls: {
  (
    input: CreateHubContentPresignedUrlsRequest,
  ): effect.Effect<
    CreateHubContentPresignedUrlsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: CreateHubContentPresignedUrlsRequest,
  ) => stream.Stream<
    CreateHubContentPresignedUrlsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: CreateHubContentPresignedUrlsRequest,
  ) => stream.Stream<
    AuthorizedUrl,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: CreateHubContentPresignedUrlsRequest,
  output: CreateHubContentPresignedUrlsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AuthorizedUrlConfigs",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Create a hub content reference in order to add a model in the JumpStart public hub to a private hub.
 */
export const createHubContentReference: (
  input: CreateHubContentReferenceRequest,
) => effect.Effect<
  CreateHubContentReferenceResponse,
  ResourceInUse | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateHubContentReferenceRequest,
  output: CreateHubContentReferenceResponse,
  errors: [ResourceInUse, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Defines the settings you will use for the human review workflow user interface. Reviewers will see a three-panel interface with an instruction area, the item to review, and an input area.
 */
export const createHumanTaskUi: (
  input: CreateHumanTaskUiRequest,
) => effect.Effect<
  CreateHumanTaskUiResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateHumanTaskUiRequest,
  output: CreateHumanTaskUiResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Starts a hyperparameter tuning job. A hyperparameter tuning job finds the best version of a model by running many training jobs on your dataset using the algorithm you choose and values for hyperparameters within ranges that you specify. It then chooses the hyperparameter values that result in a model that performs the best, as measured by an objective metric that you choose.
 *
 * A hyperparameter tuning job automatically creates Amazon SageMaker experiments, trials, and trial components for each training job that it runs. You can view these entities in Amazon SageMaker Studio. For more information, see View Experiments, Trials, and Trial Components.
 *
 * Do not include any security-sensitive information including account access IDs, secrets, or tokens in any hyperparameter fields. As part of the shared responsibility model, you are responsible for any potential exposure, unauthorized access, or compromise of your sensitive data if caused by any security-sensitive information included in the request hyperparameter variable or plain text fields..
 */
export const createHyperParameterTuningJob: (
  input: CreateHyperParameterTuningJobRequest,
) => effect.Effect<
  CreateHyperParameterTuningJobResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateHyperParameterTuningJobRequest,
  output: CreateHyperParameterTuningJobResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Creates a custom SageMaker AI image. A SageMaker AI image is a set of image versions. Each image version represents a container image stored in Amazon ECR. For more information, see Bring your own SageMaker AI image.
 */
export const createImage: (
  input: CreateImageRequest,
) => effect.Effect<
  CreateImageResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateImageRequest,
  output: CreateImageResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Creates a version of the SageMaker AI image specified by `ImageName`. The version represents the Amazon ECR container image specified by `BaseImage`.
 */
export const createImageVersion: (
  input: CreateImageVersionRequest,
) => effect.Effect<
  CreateImageVersionResponse,
  ResourceInUse | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateImageVersionRequest,
  output: CreateImageVersionResponse,
  errors: [ResourceInUse, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Creates an inference component, which is a SageMaker AI hosting object that you can use to deploy a model to an endpoint. In the inference component settings, you specify the model, the endpoint, and how the model utilizes the resources that the endpoint hosts. You can optimize resource utilization by tailoring how the required CPU cores, accelerators, and memory are allocated. You can deploy multiple inference components to an endpoint, where each inference component contains one model and the resource utilization needs for that individual model. After you deploy an inference component, you can directly invoke the associated model when you use the InvokeEndpoint API action.
 */
export const createInferenceComponent: (
  input: CreateInferenceComponentInput,
) => effect.Effect<
  CreateInferenceComponentOutput,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateInferenceComponentInput,
  output: CreateInferenceComponentOutput,
  errors: [ResourceLimitExceeded],
}));
/**
 * Creates an inference experiment using the configurations specified in the request.
 *
 * Use this API to setup and schedule an experiment to compare model variants on a Amazon SageMaker inference endpoint. For more information about inference experiments, see Shadow tests.
 *
 * Amazon SageMaker begins your experiment at the scheduled time and routes traffic to your endpoint's model variants based on your specified configuration.
 *
 * While the experiment is in progress or after it has concluded, you can view metrics that compare your model variants. For more information, see View, monitor, and edit shadow tests.
 */
export const createInferenceExperiment: (
  input: CreateInferenceExperimentRequest,
) => effect.Effect<
  CreateInferenceExperimentResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateInferenceExperimentRequest,
  output: CreateInferenceExperimentResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Starts a recommendation job. You can create either an instance recommendation or load test job.
 */
export const createInferenceRecommendationsJob: (
  input: CreateInferenceRecommendationsJobRequest,
) => effect.Effect<
  CreateInferenceRecommendationsJobResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateInferenceRecommendationsJobRequest,
  output: CreateInferenceRecommendationsJobResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Creates a job that uses workers to label the data objects in your input dataset. You can use the labeled data to train machine learning models.
 *
 * You can select your workforce from one of three providers:
 *
 * - A private workforce that you create. It can include employees, contractors, and outside experts. Use a private workforce when want the data to stay within your organization or when a specific set of skills is required.
 *
 * - One or more vendors that you select from the Amazon Web Services Marketplace. Vendors provide expertise in specific areas.
 *
 * - The Amazon Mechanical Turk workforce. This is the largest workforce, but it should only be used for public data or data that has been stripped of any personally identifiable information.
 *
 * You can also use *automated data labeling* to reduce the number of data objects that need to be labeled by a human. Automated data labeling uses *active learning* to determine if a data object can be labeled by machine or if it needs to be sent to a human worker. For more information, see Using Automated Data Labeling.
 *
 * The data objects to be labeled are contained in an Amazon S3 bucket. You create a *manifest file* that describes the location of each object. For more information, see Using Input and Output Data.
 *
 * The output can be used as the manifest file for another labeling job or as training data for your machine learning models.
 *
 * You can use this operation to create a static labeling job or a streaming labeling job. A static labeling job stops if all data objects in the input manifest file identified in `ManifestS3Uri` have been labeled. A streaming labeling job runs perpetually until it is manually stopped, or remains idle for 10 days. You can send new data objects to an active (`InProgress`) streaming labeling job in real time. To learn how to create a static labeling job, see Create a Labeling Job (API) in the Amazon SageMaker Developer Guide. To learn how to create a streaming labeling job, see Create a Streaming Labeling Job.
 */
export const createLabelingJob: (
  input: CreateLabelingJobRequest,
) => effect.Effect<
  CreateLabelingJobResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateLabelingJobRequest,
  output: CreateLabelingJobResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Creates an MLflow Tracking Server using a general purpose Amazon S3 bucket as the artifact store.
 */
export const createMlflowApp: (
  input: CreateMlflowAppRequest,
) => effect.Effect<
  CreateMlflowAppResponse,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateMlflowAppRequest,
  output: CreateMlflowAppResponse,
  errors: [ResourceLimitExceeded],
}));
/**
 * Creates an MLflow Tracking Server using a general purpose Amazon S3 bucket as the artifact store. For more information, see Create an MLflow Tracking Server.
 */
export const createMlflowTrackingServer: (
  input: CreateMlflowTrackingServerRequest,
) => effect.Effect<
  CreateMlflowTrackingServerResponse,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateMlflowTrackingServerRequest,
  output: CreateMlflowTrackingServerResponse,
  errors: [ResourceLimitExceeded],
}));
/**
 * Creates a model in SageMaker. In the request, you name the model and describe a primary container. For the primary container, you specify the Docker image that contains inference code, artifacts (from prior training), and a custom environment map that the inference code uses when you deploy the model for predictions.
 *
 * Use this API to create a model if you want to use SageMaker hosting services or run a batch transform job.
 *
 * To host your model, you create an endpoint configuration with the `CreateEndpointConfig` API, and then create an endpoint with the `CreateEndpoint` API. SageMaker then deploys all of the containers that you defined for the model in the hosting environment.
 *
 * To run a batch transform using your model, you start a job with the `CreateTransformJob` API. SageMaker uses your model and your dataset to get inferences which are then saved to a specified S3 location.
 *
 * In the request, you also provide an IAM role that SageMaker can assume to access model artifacts and docker image for deployment on ML compute hosting instances or for batch transform jobs. In addition, you also use the IAM role to manage permissions the inference code needs. For example, if the inference code access any other Amazon Web Services resources, you grant necessary permissions via this role.
 */
export const createModel: (
  input: CreateModelInput,
) => effect.Effect<
  CreateModelOutput,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateModelInput,
  output: CreateModelOutput,
  errors: [ResourceLimitExceeded],
}));
/**
 * Creates the definition for a model bias job.
 */
export const createModelBiasJobDefinition: (
  input: CreateModelBiasJobDefinitionRequest,
) => effect.Effect<
  CreateModelBiasJobDefinitionResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateModelBiasJobDefinitionRequest,
  output: CreateModelBiasJobDefinitionResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Creates an Amazon SageMaker Model Card.
 *
 * For information about how to use model cards, see Amazon SageMaker Model Card.
 */
export const createModelCard: (
  input: CreateModelCardRequest,
) => effect.Effect<
  CreateModelCardResponse,
  ConflictException | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateModelCardRequest,
  output: CreateModelCardResponse,
  errors: [ConflictException, ResourceLimitExceeded],
}));
/**
 * Creates an Amazon SageMaker Model Card export job.
 */
export const createModelCardExportJob: (
  input: CreateModelCardExportJobRequest,
) => effect.Effect<
  CreateModelCardExportJobResponse,
  ConflictException | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateModelCardExportJobRequest,
  output: CreateModelCardExportJobResponse,
  errors: [ConflictException, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Creates the definition for a model explainability job.
 */
export const createModelExplainabilityJobDefinition: (
  input: CreateModelExplainabilityJobDefinitionRequest,
) => effect.Effect<
  CreateModelExplainabilityJobDefinitionResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateModelExplainabilityJobDefinitionRequest,
  output: CreateModelExplainabilityJobDefinitionResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Creates a model package that you can use to create SageMaker models or list on Amazon Web Services Marketplace, or a versioned model that is part of a model group. Buyers can subscribe to model packages listed on Amazon Web Services Marketplace to create models in SageMaker.
 *
 * To create a model package by specifying a Docker container that contains your inference code and the Amazon S3 location of your model artifacts, provide values for `InferenceSpecification`. To create a model from an algorithm resource that you created or subscribed to in Amazon Web Services Marketplace, provide a value for `SourceAlgorithmSpecification`.
 *
 * There are two types of model packages:
 *
 * - Versioned - a model that is part of a model group in the model registry.
 *
 * - Unversioned - a model package that is not part of a model group.
 */
export const createModelPackage: (
  input: CreateModelPackageInput,
) => effect.Effect<
  CreateModelPackageOutput,
  ConflictException | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateModelPackageInput,
  output: CreateModelPackageOutput,
  errors: [ConflictException, ResourceLimitExceeded],
}));
/**
 * Creates a model group. A model group contains a group of model versions.
 */
export const createModelPackageGroup: (
  input: CreateModelPackageGroupInput,
) => effect.Effect<
  CreateModelPackageGroupOutput,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateModelPackageGroupInput,
  output: CreateModelPackageGroupOutput,
  errors: [ResourceLimitExceeded],
}));
/**
 * Creates a definition for a job that monitors model quality and drift. For information about model monitor, see Amazon SageMaker AI Model Monitor.
 */
export const createModelQualityJobDefinition: (
  input: CreateModelQualityJobDefinitionRequest,
) => effect.Effect<
  CreateModelQualityJobDefinitionResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateModelQualityJobDefinitionRequest,
  output: CreateModelQualityJobDefinitionResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Creates a schedule that regularly starts Amazon SageMaker AI Processing Jobs to monitor the data captured for an Amazon SageMaker AI Endpoint.
 */
export const createMonitoringSchedule: (
  input: CreateMonitoringScheduleRequest,
) => effect.Effect<
  CreateMonitoringScheduleResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateMonitoringScheduleRequest,
  output: CreateMonitoringScheduleResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Creates an SageMaker AI notebook instance. A notebook instance is a machine learning (ML) compute instance running on a Jupyter notebook.
 *
 * In a `CreateNotebookInstance` request, specify the type of ML compute instance that you want to run. SageMaker AI launches the instance, installs common libraries that you can use to explore datasets for model training, and attaches an ML storage volume to the notebook instance.
 *
 * SageMaker AI also provides a set of example notebooks. Each notebook demonstrates how to use SageMaker AI with a specific algorithm or with a machine learning framework.
 *
 * After receiving the request, SageMaker AI does the following:
 *
 * - Creates a network interface in the SageMaker AI VPC.
 *
 * - (Option) If you specified `SubnetId`, SageMaker AI creates a network interface in your own VPC, which is inferred from the subnet ID that you provide in the input. When creating this network interface, SageMaker AI attaches the security group that you specified in the request to the network interface that it creates in your VPC.
 *
 * - Launches an EC2 instance of the type specified in the request in the SageMaker AI VPC. If you specified `SubnetId` of your VPC, SageMaker AI specifies both network interfaces when launching this instance. This enables inbound traffic from your own VPC to the notebook instance, assuming that the security groups allow it.
 *
 * After creating the notebook instance, SageMaker AI returns its Amazon Resource Name (ARN). You can't change the name of a notebook instance after you create it.
 *
 * After SageMaker AI creates the notebook instance, you can connect to the Jupyter server and work in Jupyter notebooks. For example, you can write code to explore a dataset that you can use for model training, train a model, host models by creating SageMaker AI endpoints, and validate hosted models.
 *
 * For more information, see How It Works.
 */
export const createNotebookInstance: (
  input: CreateNotebookInstanceInput,
) => effect.Effect<
  CreateNotebookInstanceOutput,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateNotebookInstanceInput,
  output: CreateNotebookInstanceOutput,
  errors: [ResourceLimitExceeded],
}));
/**
 * Creates a lifecycle configuration that you can associate with a notebook instance. A *lifecycle configuration* is a collection of shell scripts that run when you create or start a notebook instance.
 *
 * Each lifecycle configuration script has a limit of 16384 characters.
 *
 * The value of the `$PATH` environment variable that is available to both scripts is `/sbin:bin:/usr/sbin:/usr/bin`.
 *
 * View Amazon CloudWatch Logs for notebook instance lifecycle configurations in log group `/aws/sagemaker/NotebookInstances` in log stream `[notebook-instance-name]/[LifecycleConfigHook]`.
 *
 * Lifecycle configuration scripts cannot run for longer than 5 minutes. If a script runs for longer than 5 minutes, it fails and the notebook instance is not created or started.
 *
 * For information about notebook instance lifestyle configurations, see Step 2.1: (Optional) Customize a Notebook Instance.
 */
export const createNotebookInstanceLifecycleConfig: (
  input: CreateNotebookInstanceLifecycleConfigInput,
) => effect.Effect<
  CreateNotebookInstanceLifecycleConfigOutput,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateNotebookInstanceLifecycleConfigInput,
  output: CreateNotebookInstanceLifecycleConfigOutput,
  errors: [ResourceLimitExceeded],
}));
/**
 * Creates a job that optimizes a model for inference performance. To create the job, you provide the location of a source model, and you provide the settings for the optimization techniques that you want the job to apply. When the job completes successfully, SageMaker uploads the new optimized model to the output destination that you specify.
 *
 * For more information about how to use this action, and about the supported optimization techniques, see Optimize model inference with Amazon SageMaker.
 */
export const createOptimizationJob: (
  input: CreateOptimizationJobRequest,
) => effect.Effect<
  CreateOptimizationJobResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateOptimizationJobRequest,
  output: CreateOptimizationJobResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Creates an Amazon SageMaker Partner AI App.
 */
export const createPartnerApp: (
  input: CreatePartnerAppRequest,
) => effect.Effect<
  CreatePartnerAppResponse,
  ConflictException | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreatePartnerAppRequest,
  output: CreatePartnerAppResponse,
  errors: [ConflictException, ResourceLimitExceeded],
}));
/**
 * Creates a presigned URL to access an Amazon SageMaker Partner AI App.
 */
export const createPartnerAppPresignedUrl: (
  input: CreatePartnerAppPresignedUrlRequest,
) => effect.Effect<
  CreatePartnerAppPresignedUrlResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreatePartnerAppPresignedUrlRequest,
  output: CreatePartnerAppPresignedUrlResponse,
  errors: [ResourceNotFound],
}));
/**
 * Creates a pipeline using a JSON pipeline definition.
 */
export const createPipeline: (
  input: CreatePipelineRequest,
) => effect.Effect<
  CreatePipelineResponse,
  ConflictException | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreatePipelineRequest,
  output: CreatePipelineResponse,
  errors: [ConflictException, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Creates a URL for a specified UserProfile in a Domain. When accessed in a web browser, the user will be automatically signed in to the domain, and granted access to all of the Apps and files associated with the Domain's Amazon Elastic File System volume. This operation can only be called when the authentication mode equals IAM.
 *
 * The IAM role or user passed to this API defines the permissions to access the app. Once the presigned URL is created, no additional permission is required to access this URL. IAM authorization policies for this API are also enforced for every HTTP request and WebSocket frame that attempts to connect to the app.
 *
 * You can restrict access to this API and to the URL that it returns to a list of IP addresses, Amazon VPCs or Amazon VPC Endpoints that you specify. For more information, see Connect to Amazon SageMaker AI Studio Through an Interface VPC Endpoint .
 *
 * - The URL that you get from a call to `CreatePresignedDomainUrl` has a default timeout of 5 minutes. You can configure this value using `ExpiresInSeconds`. If you try to use the URL after the timeout limit expires, you are directed to the Amazon Web Services console sign-in page.
 *
 * - The JupyterLab session default expiration time is 12 hours. You can configure this value using SessionExpirationDurationInSeconds.
 */
export const createPresignedDomainUrl: (
  input: CreatePresignedDomainUrlRequest,
) => effect.Effect<
  CreatePresignedDomainUrlResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreatePresignedDomainUrlRequest,
  output: CreatePresignedDomainUrlResponse,
  errors: [ResourceNotFound],
}));
/**
 * Returns a presigned URL that you can use to connect to the MLflow UI attached to your MLflow App. For more information, see Launch the MLflow UI using a presigned URL.
 */
export const createPresignedMlflowAppUrl: (
  input: CreatePresignedMlflowAppUrlRequest,
) => effect.Effect<
  CreatePresignedMlflowAppUrlResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreatePresignedMlflowAppUrlRequest,
  output: CreatePresignedMlflowAppUrlResponse,
  errors: [ResourceNotFound],
}));
/**
 * Returns a presigned URL that you can use to connect to the MLflow UI attached to your tracking server. For more information, see Launch the MLflow UI using a presigned URL.
 */
export const createPresignedMlflowTrackingServerUrl: (
  input: CreatePresignedMlflowTrackingServerUrlRequest,
) => effect.Effect<
  CreatePresignedMlflowTrackingServerUrlResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreatePresignedMlflowTrackingServerUrlRequest,
  output: CreatePresignedMlflowTrackingServerUrlResponse,
  errors: [ResourceNotFound],
}));
/**
 * Returns a URL that you can use to connect to the Jupyter server from a notebook instance. In the SageMaker AI console, when you choose `Open` next to a notebook instance, SageMaker AI opens a new tab showing the Jupyter server home page from the notebook instance. The console uses this API to get the URL and show the page.
 *
 * The IAM role or user used to call this API defines the permissions to access the notebook instance. Once the presigned URL is created, no additional permission is required to access this URL. IAM authorization policies for this API are also enforced for every HTTP request and WebSocket frame that attempts to connect to the notebook instance.
 *
 * You can restrict access to this API and to the URL that it returns to a list of IP addresses that you specify. Use the `NotIpAddress` condition operator and the `aws:SourceIP` condition context key to specify the list of IP addresses that you want to have access to the notebook instance. For more information, see Limit Access to a Notebook Instance by IP Address.
 *
 * The URL that you get from a call to CreatePresignedNotebookInstanceUrl is valid only for 5 minutes. If you try to use the URL after the 5-minute limit expires, you are directed to the Amazon Web Services console sign-in page.
 */
export const createPresignedNotebookInstanceUrl: (
  input: CreatePresignedNotebookInstanceUrlInput,
) => effect.Effect<
  CreatePresignedNotebookInstanceUrlOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreatePresignedNotebookInstanceUrlInput,
  output: CreatePresignedNotebookInstanceUrlOutput,
  errors: [],
}));
/**
 * Creates a processing job.
 */
export const createProcessingJob: (
  input: CreateProcessingJobRequest,
) => effect.Effect<
  CreateProcessingJobResponse,
  ResourceInUse | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateProcessingJobRequest,
  output: CreateProcessingJobResponse,
  errors: [ResourceInUse, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Creates a machine learning (ML) project that can contain one or more templates that set up an ML pipeline from training to deploying an approved model.
 */
export const createProject: (
  input: CreateProjectInput,
) => effect.Effect<
  CreateProjectOutput,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateProjectInput,
  output: CreateProjectOutput,
  errors: [ResourceLimitExceeded],
}));
/**
 * Creates a private space or a space used for real time collaboration in a domain.
 */
export const createSpace: (
  input: CreateSpaceRequest,
) => effect.Effect<
  CreateSpaceResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateSpaceRequest,
  output: CreateSpaceResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Creates a new Amazon SageMaker AI Studio Lifecycle Configuration.
 */
export const createStudioLifecycleConfig: (
  input: CreateStudioLifecycleConfigRequest,
) => effect.Effect<
  CreateStudioLifecycleConfigResponse,
  ResourceInUse | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateStudioLifecycleConfigRequest,
  output: CreateStudioLifecycleConfigResponse,
  errors: [ResourceInUse],
}));
/**
 * Starts a model training job. After training completes, SageMaker saves the resulting model artifacts to an Amazon S3 location that you specify.
 *
 * If you choose to host your model using SageMaker hosting services, you can use the resulting model artifacts as part of the model. You can also use the artifacts in a machine learning service other than SageMaker, provided that you know how to use them for inference.
 *
 * In the request body, you provide the following:
 *
 * - `AlgorithmSpecification` - Identifies the training algorithm to use.
 *
 * - `HyperParameters` - Specify these algorithm-specific parameters to enable the estimation of model parameters during training. Hyperparameters can be tuned to optimize this learning process. For a list of hyperparameters for each training algorithm provided by SageMaker, see Algorithms.
 *
 * Do not include any security-sensitive information including account access IDs, secrets, or tokens in any hyperparameter fields. As part of the shared responsibility model, you are responsible for any potential exposure, unauthorized access, or compromise of your sensitive data if caused by security-sensitive information included in the request hyperparameter variable or plain text fields.
 *
 * - `InputDataConfig` - Describes the input required by the training job and the Amazon S3, EFS, or FSx location where it is stored.
 *
 * - `OutputDataConfig` - Identifies the Amazon S3 bucket where you want SageMaker to save the results of model training.
 *
 * - `ResourceConfig` - Identifies the resources, ML compute instances, and ML storage volumes to deploy for model training. In distributed training, you specify more than one instance.
 *
 * - `EnableManagedSpotTraining` - Optimize the cost of training machine learning models by up to 80% by using Amazon EC2 Spot instances. For more information, see Managed Spot Training.
 *
 * - `RoleArn` - The Amazon Resource Name (ARN) that SageMaker assumes to perform tasks on your behalf during model training. You must grant this role the necessary permissions so that SageMaker can successfully complete model training.
 *
 * - `StoppingCondition` - To help cap training costs, use `MaxRuntimeInSeconds` to set a time limit for training. Use `MaxWaitTimeInSeconds` to specify how long a managed spot training job has to complete.
 *
 * - `Environment` - The environment variables to set in the Docker container.
 *
 * Do not include any security-sensitive information including account access IDs, secrets, or tokens in any environment fields. As part of the shared responsibility model, you are responsible for any potential exposure, unauthorized access, or compromise of your sensitive data if caused by security-sensitive information included in the request environment variable or plain text fields.
 *
 * - `RetryStrategy` - The number of times to retry the job when the job fails due to an `InternalServerError`.
 *
 * For more information about SageMaker, see How It Works.
 */
export const createTrainingJob: (
  input: CreateTrainingJobRequest,
) => effect.Effect<
  CreateTrainingJobResponse,
  ResourceInUse | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTrainingJobRequest,
  output: CreateTrainingJobResponse,
  errors: [ResourceInUse, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Creates a new training plan in SageMaker to reserve compute capacity.
 *
 * Amazon SageMaker Training Plan is a capability within SageMaker that allows customers to reserve and manage GPU capacity for large-scale AI model training. It provides a way to secure predictable access to computational resources within specific timelines and budgets, without the need to manage underlying infrastructure.
 *
 * **How it works**
 *
 * Plans can be created for specific resources such as SageMaker Training Jobs or SageMaker HyperPod clusters, automatically provisioning resources, setting up infrastructure, executing workloads, and handling infrastructure failures.
 *
 * **Plan creation workflow**
 *
 * - Users search for available plan offerings based on their requirements (e.g., instance type, count, start time, duration) using the ` SearchTrainingPlanOfferings ` API operation.
 *
 * - They create a plan that best matches their needs using the ID of the plan offering they want to use.
 *
 * - After successful upfront payment, the plan's status becomes `Scheduled`.
 *
 * - The plan can be used to:
 *
 * - Queue training jobs.
 *
 * - Allocate to an instance group of a SageMaker HyperPod cluster.
 *
 * - When the plan start date arrives, it becomes `Active`. Based on available reserved capacity:
 *
 * - Training jobs are launched.
 *
 * - Instance groups are provisioned.
 *
 * **Plan composition**
 *
 * A plan can consist of one or more Reserved Capacities, each defined by a specific instance type, quantity, Availability Zone, duration, and start and end times. For more information about Reserved Capacity, see ` ReservedCapacitySummary `.
 */
export const createTrainingPlan: (
  input: CreateTrainingPlanRequest,
) => effect.Effect<
  CreateTrainingPlanResponse,
  ResourceInUse | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTrainingPlanRequest,
  output: CreateTrainingPlanResponse,
  errors: [ResourceInUse, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Starts a transform job. A transform job uses a trained model to get inferences on a dataset and saves these results to an Amazon S3 location that you specify.
 *
 * To perform batch transformations, you create a transform job and use the data that you have readily available.
 *
 * In the request body, you provide the following:
 *
 * - `TransformJobName` - Identifies the transform job. The name must be unique within an Amazon Web Services Region in an Amazon Web Services account.
 *
 * - `ModelName` - Identifies the model to use. `ModelName` must be the name of an existing Amazon SageMaker model in the same Amazon Web Services Region and Amazon Web Services account. For information on creating a model, see CreateModel.
 *
 * - `TransformInput` - Describes the dataset to be transformed and the Amazon S3 location where it is stored.
 *
 * - `TransformOutput` - Identifies the Amazon S3 location where you want Amazon SageMaker to save the results from the transform job.
 *
 * - `TransformResources` - Identifies the ML compute instances and AMI image versions for the transform job.
 *
 * For more information about how batch transformation works, see Batch Transform.
 */
export const createTransformJob: (
  input: CreateTransformJobRequest,
) => effect.Effect<
  CreateTransformJobResponse,
  ResourceInUse | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTransformJobRequest,
  output: CreateTransformJobResponse,
  errors: [ResourceInUse, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Creates an SageMaker *trial*. A trial is a set of steps called *trial components* that produce a machine learning model. A trial is part of a single SageMaker *experiment*.
 *
 * When you use SageMaker Studio or the SageMaker Python SDK, all experiments, trials, and trial components are automatically tracked, logged, and indexed. When you use the Amazon Web Services SDK for Python (Boto), you must use the logging APIs provided by the SDK.
 *
 * You can add tags to a trial and then use the Search API to search for the tags.
 *
 * To get a list of all your trials, call the ListTrials API. To view a trial's properties, call the DescribeTrial API. To create a trial component, call the CreateTrialComponent API.
 */
export const createTrial: (
  input: CreateTrialRequest,
) => effect.Effect<
  CreateTrialResponse,
  ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTrialRequest,
  output: CreateTrialResponse,
  errors: [ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Creates a *trial component*, which is a stage of a machine learning *trial*. A trial is composed of one or more trial components. A trial component can be used in multiple trials.
 *
 * Trial components include pre-processing jobs, training jobs, and batch transform jobs.
 *
 * When you use SageMaker Studio or the SageMaker Python SDK, all experiments, trials, and trial components are automatically tracked, logged, and indexed. When you use the Amazon Web Services SDK for Python (Boto), you must use the logging APIs provided by the SDK.
 *
 * You can add tags to a trial component and then use the Search API to search for the tags.
 */
export const createTrialComponent: (
  input: CreateTrialComponentRequest,
) => effect.Effect<
  CreateTrialComponentResponse,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTrialComponentRequest,
  output: CreateTrialComponentResponse,
  errors: [ResourceLimitExceeded],
}));
/**
 * Creates a user profile. A user profile represents a single user within a domain, and is the main way to reference a "person" for the purposes of sharing, reporting, and other user-oriented features. This entity is created when a user onboards to a domain. If an administrator invites a person by email or imports them from IAM Identity Center, a user profile is automatically created. A user profile is the primary holder of settings for an individual user and has a reference to the user's private Amazon Elastic File System home directory.
 */
export const createUserProfile: (
  input: CreateUserProfileRequest,
) => effect.Effect<
  CreateUserProfileResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateUserProfileRequest,
  output: CreateUserProfileResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Use this operation to create a workforce. This operation will return an error if a workforce already exists in the Amazon Web Services Region that you specify. You can only create one workforce in each Amazon Web Services Region per Amazon Web Services account.
 *
 * If you want to create a new workforce in an Amazon Web Services Region where a workforce already exists, use the DeleteWorkforce API operation to delete the existing workforce and then use `CreateWorkforce` to create a new workforce.
 *
 * To create a private workforce using Amazon Cognito, you must specify a Cognito user pool in `CognitoConfig`. You can also create an Amazon Cognito workforce using the Amazon SageMaker console. For more information, see Create a Private Workforce (Amazon Cognito).
 *
 * To create a private workforce using your own OIDC Identity Provider (IdP), specify your IdP configuration in `OidcConfig`. Your OIDC IdP must support *groups* because groups are used by Ground Truth and Amazon A2I to create work teams. For more information, see Create a Private Workforce (OIDC IdP).
 */
export const createWorkforce: (
  input: CreateWorkforceRequest,
) => effect.Effect<
  CreateWorkforceResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateWorkforceRequest,
  output: CreateWorkforceResponse,
  errors: [],
}));
/**
 * Creates a new work team for labeling your data. A work team is defined by one or more Amazon Cognito user pools. You must first create the user pools before you can create a work team.
 *
 * You cannot create more than 25 work teams in an account and region.
 */
export const createWorkteam: (
  input: CreateWorkteamRequest,
) => effect.Effect<
  CreateWorkteamResponse,
  ResourceInUse | ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateWorkteamRequest,
  output: CreateWorkteamResponse,
  errors: [ResourceInUse, ResourceLimitExceeded],
}));
/**
 * Deletes an action.
 */
export const deleteAction: (
  input: DeleteActionRequest,
) => effect.Effect<
  DeleteActionResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteActionRequest,
  output: DeleteActionResponse,
  errors: [ResourceNotFound],
}));
/**
 * Removes the specified algorithm from your account.
 */
export const deleteAlgorithm: (
  input: DeleteAlgorithmInput,
) => effect.Effect<
  DeleteAlgorithmResponse,
  ConflictException | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteAlgorithmInput,
  output: DeleteAlgorithmResponse,
  errors: [ConflictException],
}));
/**
 * Used to stop and delete an app.
 */
export const deleteApp: (
  input: DeleteAppRequest,
) => effect.Effect<
  DeleteAppResponse,
  ResourceInUse | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteAppRequest,
  output: DeleteAppResponse,
  errors: [ResourceInUse, ResourceNotFound],
}));
/**
 * Deletes an AppImageConfig.
 */
export const deleteAppImageConfig: (
  input: DeleteAppImageConfigRequest,
) => effect.Effect<
  DeleteAppImageConfigResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteAppImageConfigRequest,
  output: DeleteAppImageConfigResponse,
  errors: [ResourceNotFound],
}));
/**
 * Deletes an artifact. Either `ArtifactArn` or `Source` must be specified.
 */
export const deleteArtifact: (
  input: DeleteArtifactRequest,
) => effect.Effect<
  DeleteArtifactResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteArtifactRequest,
  output: DeleteArtifactResponse,
  errors: [ResourceNotFound],
}));
/**
 * Deletes an association.
 */
export const deleteAssociation: (
  input: DeleteAssociationRequest,
) => effect.Effect<
  DeleteAssociationResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteAssociationRequest,
  output: DeleteAssociationResponse,
  errors: [ResourceNotFound],
}));
/**
 * Delete a SageMaker HyperPod cluster.
 */
export const deleteCluster: (
  input: DeleteClusterRequest,
) => effect.Effect<
  DeleteClusterResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteClusterRequest,
  output: DeleteClusterResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Deletes the cluster policy of the cluster.
 */
export const deleteClusterSchedulerConfig: (
  input: DeleteClusterSchedulerConfigRequest,
) => effect.Effect<
  DeleteClusterSchedulerConfigResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteClusterSchedulerConfigRequest,
  output: DeleteClusterSchedulerConfigResponse,
  errors: [ResourceNotFound],
}));
/**
 * Deletes the specified Git repository from your account.
 */
export const deleteCodeRepository: (
  input: DeleteCodeRepositoryInput,
) => effect.Effect<
  DeleteCodeRepositoryResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteCodeRepositoryInput,
  output: DeleteCodeRepositoryResponse,
  errors: [],
}));
/**
 * Deletes the specified compilation job. This action deletes only the compilation job resource in Amazon SageMaker AI. It doesn't delete other resources that are related to that job, such as the model artifacts that the job creates, the compilation logs in CloudWatch, the compiled model, or the IAM role.
 *
 * You can delete a compilation job only if its current status is `COMPLETED`, `FAILED`, or `STOPPED`. If the job status is `STARTING` or `INPROGRESS`, stop the job, and then delete it after its status becomes `STOPPED`.
 */
export const deleteCompilationJob: (
  input: DeleteCompilationJobRequest,
) => effect.Effect<
  DeleteCompilationJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteCompilationJobRequest,
  output: DeleteCompilationJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Deletes the compute allocation from the cluster.
 */
export const deleteComputeQuota: (
  input: DeleteComputeQuotaRequest,
) => effect.Effect<
  DeleteComputeQuotaResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteComputeQuotaRequest,
  output: DeleteComputeQuotaResponse,
  errors: [ResourceNotFound],
}));
/**
 * Deletes an context.
 */
export const deleteContext: (
  input: DeleteContextRequest,
) => effect.Effect<
  DeleteContextResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteContextRequest,
  output: DeleteContextResponse,
  errors: [ResourceNotFound],
}));
/**
 * Deletes a data quality monitoring job definition.
 */
export const deleteDataQualityJobDefinition: (
  input: DeleteDataQualityJobDefinitionRequest,
) => effect.Effect<
  DeleteDataQualityJobDefinitionResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteDataQualityJobDefinitionRequest,
  output: DeleteDataQualityJobDefinitionResponse,
  errors: [ResourceNotFound],
}));
/**
 * Deletes a fleet.
 */
export const deleteDeviceFleet: (
  input: DeleteDeviceFleetRequest,
) => effect.Effect<
  DeleteDeviceFleetResponse,
  ResourceInUse | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteDeviceFleetRequest,
  output: DeleteDeviceFleetResponse,
  errors: [ResourceInUse],
}));
/**
 * Used to delete a domain. If you onboarded with IAM mode, you will need to delete your domain to onboard again using IAM Identity Center. Use with caution. All of the members of the domain will lose access to their EFS volume, including data, notebooks, and other artifacts.
 */
export const deleteDomain: (
  input: DeleteDomainRequest,
) => effect.Effect<
  DeleteDomainResponse,
  ResourceInUse | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteDomainRequest,
  output: DeleteDomainResponse,
  errors: [ResourceInUse, ResourceNotFound],
}));
/**
 * Deletes an edge deployment plan if (and only if) all the stages in the plan are inactive or there are no stages in the plan.
 */
export const deleteEdgeDeploymentPlan: (
  input: DeleteEdgeDeploymentPlanRequest,
) => effect.Effect<
  DeleteEdgeDeploymentPlanResponse,
  ResourceInUse | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteEdgeDeploymentPlanRequest,
  output: DeleteEdgeDeploymentPlanResponse,
  errors: [ResourceInUse],
}));
/**
 * Delete a stage in an edge deployment plan if (and only if) the stage is inactive.
 */
export const deleteEdgeDeploymentStage: (
  input: DeleteEdgeDeploymentStageRequest,
) => effect.Effect<
  DeleteEdgeDeploymentStageResponse,
  ResourceInUse | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteEdgeDeploymentStageRequest,
  output: DeleteEdgeDeploymentStageResponse,
  errors: [ResourceInUse],
}));
/**
 * Deletes an endpoint. SageMaker frees up all of the resources that were deployed when the endpoint was created.
 *
 * SageMaker retires any custom KMS key grants associated with the endpoint, meaning you don't need to use the RevokeGrant API call.
 *
 * When you delete your endpoint, SageMaker asynchronously deletes associated endpoint resources such as KMS key grants. You might still see these resources in your account for a few minutes after deleting your endpoint. Do not delete or revoke the permissions for your ` ExecutionRoleArn `, otherwise SageMaker cannot delete these resources.
 */
export const deleteEndpoint: (
  input: DeleteEndpointInput,
) => effect.Effect<
  DeleteEndpointResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteEndpointInput,
  output: DeleteEndpointResponse,
  errors: [],
}));
/**
 * Deletes an endpoint configuration. The `DeleteEndpointConfig` API deletes only the specified configuration. It does not delete endpoints created using the configuration.
 *
 * You must not delete an `EndpointConfig` in use by an endpoint that is live or while the `UpdateEndpoint` or `CreateEndpoint` operations are being performed on the endpoint. If you delete the `EndpointConfig` of an endpoint that is active or being created or updated you may lose visibility into the instance type the endpoint is using. The endpoint must be deleted in order to stop incurring charges.
 */
export const deleteEndpointConfig: (
  input: DeleteEndpointConfigInput,
) => effect.Effect<
  DeleteEndpointConfigResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteEndpointConfigInput,
  output: DeleteEndpointConfigResponse,
  errors: [],
}));
/**
 * Deletes an SageMaker experiment. All trials associated with the experiment must be deleted first. Use the ListTrials API to get a list of the trials associated with the experiment.
 */
export const deleteExperiment: (
  input: DeleteExperimentRequest,
) => effect.Effect<
  DeleteExperimentResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteExperimentRequest,
  output: DeleteExperimentResponse,
  errors: [ResourceNotFound],
}));
/**
 * Delete the `FeatureGroup` and any data that was written to the `OnlineStore` of the `FeatureGroup`. Data cannot be accessed from the `OnlineStore` immediately after `DeleteFeatureGroup` is called.
 *
 * Data written into the `OfflineStore` will not be deleted. The Amazon Web Services Glue database and tables that are automatically created for your `OfflineStore` are not deleted.
 *
 * Note that it can take approximately 10-15 minutes to delete an `OnlineStore` `FeatureGroup` with the `InMemory` `StorageType`.
 */
export const deleteFeatureGroup: (
  input: DeleteFeatureGroupRequest,
) => effect.Effect<
  DeleteFeatureGroupResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteFeatureGroupRequest,
  output: DeleteFeatureGroupResponse,
  errors: [ResourceNotFound],
}));
/**
 * Deletes the specified flow definition.
 */
export const deleteFlowDefinition: (
  input: DeleteFlowDefinitionRequest,
) => effect.Effect<
  DeleteFlowDefinitionResponse,
  ResourceInUse | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteFlowDefinitionRequest,
  output: DeleteFlowDefinitionResponse,
  errors: [ResourceInUse, ResourceNotFound],
}));
/**
 * Delete a hub.
 */
export const deleteHub: (
  input: DeleteHubRequest,
) => effect.Effect<
  DeleteHubResponse,
  ResourceInUse | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteHubRequest,
  output: DeleteHubResponse,
  errors: [ResourceInUse, ResourceNotFound],
}));
/**
 * Delete the contents of a hub.
 */
export const deleteHubContent: (
  input: DeleteHubContentRequest,
) => effect.Effect<
  DeleteHubContentResponse,
  ResourceInUse | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteHubContentRequest,
  output: DeleteHubContentResponse,
  errors: [ResourceInUse, ResourceNotFound],
}));
/**
 * Delete a hub content reference in order to remove a model from a private hub.
 */
export const deleteHubContentReference: (
  input: DeleteHubContentReferenceRequest,
) => effect.Effect<
  DeleteHubContentReferenceResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteHubContentReferenceRequest,
  output: DeleteHubContentReferenceResponse,
  errors: [ResourceNotFound],
}));
/**
 * Use this operation to delete a human task user interface (worker task template).
 *
 * To see a list of human task user interfaces (work task templates) in your account, use ListHumanTaskUis. When you delete a worker task template, it no longer appears when you call `ListHumanTaskUis`.
 */
export const deleteHumanTaskUi: (
  input: DeleteHumanTaskUiRequest,
) => effect.Effect<
  DeleteHumanTaskUiResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteHumanTaskUiRequest,
  output: DeleteHumanTaskUiResponse,
  errors: [ResourceNotFound],
}));
/**
 * Deletes a hyperparameter tuning job. The `DeleteHyperParameterTuningJob` API deletes only the tuning job entry that was created in SageMaker when you called the `CreateHyperParameterTuningJob` API. It does not delete training jobs, artifacts, or the IAM role that you specified when creating the model.
 */
export const deleteHyperParameterTuningJob: (
  input: DeleteHyperParameterTuningJobRequest,
) => effect.Effect<
  DeleteHyperParameterTuningJobResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteHyperParameterTuningJobRequest,
  output: DeleteHyperParameterTuningJobResponse,
  errors: [],
}));
/**
 * Deletes a SageMaker AI image and all versions of the image. The container images aren't deleted.
 */
export const deleteImage: (
  input: DeleteImageRequest,
) => effect.Effect<
  DeleteImageResponse,
  ResourceInUse | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteImageRequest,
  output: DeleteImageResponse,
  errors: [ResourceInUse, ResourceNotFound],
}));
/**
 * Deletes a version of a SageMaker AI image. The container image the version represents isn't deleted.
 */
export const deleteImageVersion: (
  input: DeleteImageVersionRequest,
) => effect.Effect<
  DeleteImageVersionResponse,
  ResourceInUse | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteImageVersionRequest,
  output: DeleteImageVersionResponse,
  errors: [ResourceInUse, ResourceNotFound],
}));
/**
 * Deletes an inference component.
 */
export const deleteInferenceComponent: (
  input: DeleteInferenceComponentInput,
) => effect.Effect<
  DeleteInferenceComponentResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteInferenceComponentInput,
  output: DeleteInferenceComponentResponse,
  errors: [],
}));
/**
 * Deletes an inference experiment.
 *
 * This operation does not delete your endpoint, variants, or any underlying resources. This operation only deletes the metadata of your experiment.
 */
export const deleteInferenceExperiment: (
  input: DeleteInferenceExperimentRequest,
) => effect.Effect<
  DeleteInferenceExperimentResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteInferenceExperimentRequest,
  output: DeleteInferenceExperimentResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Deletes an MLflow App.
 */
export const deleteMlflowApp: (
  input: DeleteMlflowAppRequest,
) => effect.Effect<
  DeleteMlflowAppResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteMlflowAppRequest,
  output: DeleteMlflowAppResponse,
  errors: [ResourceNotFound],
}));
/**
 * Deletes an MLflow Tracking Server. For more information, see Clean up MLflow resources.
 */
export const deleteMlflowTrackingServer: (
  input: DeleteMlflowTrackingServerRequest,
) => effect.Effect<
  DeleteMlflowTrackingServerResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteMlflowTrackingServerRequest,
  output: DeleteMlflowTrackingServerResponse,
  errors: [ResourceNotFound],
}));
/**
 * Deletes a model. The `DeleteModel` API deletes only the model entry that was created in SageMaker when you called the `CreateModel` API. It does not delete model artifacts, inference code, or the IAM role that you specified when creating the model.
 */
export const deleteModel: (
  input: DeleteModelInput,
) => effect.Effect<
  DeleteModelResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteModelInput,
  output: DeleteModelResponse,
  errors: [],
}));
/**
 * Deletes an Amazon SageMaker AI model bias job definition.
 */
export const deleteModelBiasJobDefinition: (
  input: DeleteModelBiasJobDefinitionRequest,
) => effect.Effect<
  DeleteModelBiasJobDefinitionResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteModelBiasJobDefinitionRequest,
  output: DeleteModelBiasJobDefinitionResponse,
  errors: [ResourceNotFound],
}));
/**
 * Deletes an Amazon SageMaker Model Card.
 */
export const deleteModelCard: (
  input: DeleteModelCardRequest,
) => effect.Effect<
  DeleteModelCardResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteModelCardRequest,
  output: DeleteModelCardResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Deletes an Amazon SageMaker AI model explainability job definition.
 */
export const deleteModelExplainabilityJobDefinition: (
  input: DeleteModelExplainabilityJobDefinitionRequest,
) => effect.Effect<
  DeleteModelExplainabilityJobDefinitionResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteModelExplainabilityJobDefinitionRequest,
  output: DeleteModelExplainabilityJobDefinitionResponse,
  errors: [ResourceNotFound],
}));
/**
 * Deletes a model package.
 *
 * A model package is used to create SageMaker models or list on Amazon Web Services Marketplace. Buyers can subscribe to model packages listed on Amazon Web Services Marketplace to create models in SageMaker.
 */
export const deleteModelPackage: (
  input: DeleteModelPackageInput,
) => effect.Effect<
  DeleteModelPackageResponse,
  ConflictException | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteModelPackageInput,
  output: DeleteModelPackageResponse,
  errors: [ConflictException],
}));
/**
 * Deletes the specified model group.
 */
export const deleteModelPackageGroup: (
  input: DeleteModelPackageGroupInput,
) => effect.Effect<
  DeleteModelPackageGroupResponse,
  ConflictException | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteModelPackageGroupInput,
  output: DeleteModelPackageGroupResponse,
  errors: [ConflictException],
}));
/**
 * Deletes a model group resource policy.
 */
export const deleteModelPackageGroupPolicy: (
  input: DeleteModelPackageGroupPolicyInput,
) => effect.Effect<
  DeleteModelPackageGroupPolicyResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteModelPackageGroupPolicyInput,
  output: DeleteModelPackageGroupPolicyResponse,
  errors: [],
}));
/**
 * Deletes the secified model quality monitoring job definition.
 */
export const deleteModelQualityJobDefinition: (
  input: DeleteModelQualityJobDefinitionRequest,
) => effect.Effect<
  DeleteModelQualityJobDefinitionResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteModelQualityJobDefinitionRequest,
  output: DeleteModelQualityJobDefinitionResponse,
  errors: [ResourceNotFound],
}));
/**
 * Deletes a monitoring schedule. Also stops the schedule had not already been stopped. This does not delete the job execution history of the monitoring schedule.
 */
export const deleteMonitoringSchedule: (
  input: DeleteMonitoringScheduleRequest,
) => effect.Effect<
  DeleteMonitoringScheduleResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteMonitoringScheduleRequest,
  output: DeleteMonitoringScheduleResponse,
  errors: [ResourceNotFound],
}));
/**
 * Deletes an SageMaker AI notebook instance. Before you can delete a notebook instance, you must call the `StopNotebookInstance` API.
 *
 * When you delete a notebook instance, you lose all of your data. SageMaker AI removes the ML compute instance, and deletes the ML storage volume and the network interface associated with the notebook instance.
 */
export const deleteNotebookInstance: (
  input: DeleteNotebookInstanceInput,
) => effect.Effect<
  DeleteNotebookInstanceResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteNotebookInstanceInput,
  output: DeleteNotebookInstanceResponse,
  errors: [],
}));
/**
 * Deletes a notebook instance lifecycle configuration.
 */
export const deleteNotebookInstanceLifecycleConfig: (
  input: DeleteNotebookInstanceLifecycleConfigInput,
) => effect.Effect<
  DeleteNotebookInstanceLifecycleConfigResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteNotebookInstanceLifecycleConfigInput,
  output: DeleteNotebookInstanceLifecycleConfigResponse,
  errors: [],
}));
/**
 * Deletes an optimization job.
 */
export const deleteOptimizationJob: (
  input: DeleteOptimizationJobRequest,
) => effect.Effect<
  DeleteOptimizationJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteOptimizationJobRequest,
  output: DeleteOptimizationJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Deletes a SageMaker Partner AI App.
 */
export const deletePartnerApp: (
  input: DeletePartnerAppRequest,
) => effect.Effect<
  DeletePartnerAppResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeletePartnerAppRequest,
  output: DeletePartnerAppResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Deletes a pipeline if there are no running instances of the pipeline. To delete a pipeline, you must stop all running instances of the pipeline using the `StopPipelineExecution` API. When you delete a pipeline, all instances of the pipeline are deleted.
 */
export const deletePipeline: (
  input: DeletePipelineRequest,
) => effect.Effect<
  DeletePipelineResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeletePipelineRequest,
  output: DeletePipelineResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Deletes a processing job. After Amazon SageMaker deletes a processing job, all of the metadata for the processing job is lost. You can delete only processing jobs that are in a terminal state (`Stopped`, `Failed`, or `Completed`). You cannot delete a job that is in the `InProgress` or `Stopping` state. After deleting the job, you can reuse its name to create another processing job.
 */
export const deleteProcessingJob: (
  input: DeleteProcessingJobRequest,
) => effect.Effect<
  DeleteProcessingJobResponse,
  ResourceInUse | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteProcessingJobRequest,
  output: DeleteProcessingJobResponse,
  errors: [ResourceInUse, ResourceNotFound],
}));
/**
 * Delete the specified project.
 */
export const deleteProject: (
  input: DeleteProjectInput,
) => effect.Effect<
  DeleteProjectResponse,
  ConflictException | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteProjectInput,
  output: DeleteProjectResponse,
  errors: [ConflictException],
}));
/**
 * Used to delete a space.
 */
export const deleteSpace: (
  input: DeleteSpaceRequest,
) => effect.Effect<
  DeleteSpaceResponse,
  ResourceInUse | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteSpaceRequest,
  output: DeleteSpaceResponse,
  errors: [ResourceInUse, ResourceNotFound],
}));
/**
 * Deletes the Amazon SageMaker AI Studio Lifecycle Configuration. In order to delete the Lifecycle Configuration, there must be no running apps using the Lifecycle Configuration. You must also remove the Lifecycle Configuration from UserSettings in all Domains and UserProfiles.
 */
export const deleteStudioLifecycleConfig: (
  input: DeleteStudioLifecycleConfigRequest,
) => effect.Effect<
  DeleteStudioLifecycleConfigResponse,
  ResourceInUse | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteStudioLifecycleConfigRequest,
  output: DeleteStudioLifecycleConfigResponse,
  errors: [ResourceInUse, ResourceNotFound],
}));
/**
 * Deletes the specified tags from an SageMaker resource.
 *
 * To list a resource's tags, use the `ListTags` API.
 *
 * When you call this API to delete tags from a hyperparameter tuning job, the deleted tags are not removed from training jobs that the hyperparameter tuning job launched before you called this API.
 *
 * When you call this API to delete tags from a SageMaker Domain or User Profile, the deleted tags are not removed from Apps that the SageMaker Domain or User Profile launched before you called this API.
 */
export const deleteTags: (
  input: DeleteTagsInput,
) => effect.Effect<
  DeleteTagsOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTagsInput,
  output: DeleteTagsOutput,
  errors: [],
}));
/**
 * Deletes a training job. After SageMaker deletes a training job, all of the metadata for the training job is lost. You can delete only training jobs that are in a terminal state (`Stopped`, `Failed`, or `Completed`) and don't retain an `Available` managed warm pool. You cannot delete a job that is in the `InProgress` or `Stopping` state. After deleting the job, you can reuse its name to create another training job.
 */
export const deleteTrainingJob: (
  input: DeleteTrainingJobRequest,
) => effect.Effect<
  DeleteTrainingJobResponse,
  ResourceInUse | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTrainingJobRequest,
  output: DeleteTrainingJobResponse,
  errors: [ResourceInUse, ResourceNotFound],
}));
/**
 * Deletes the specified trial. All trial components that make up the trial must be deleted first. Use the DescribeTrialComponent API to get the list of trial components.
 */
export const deleteTrial: (
  input: DeleteTrialRequest,
) => effect.Effect<
  DeleteTrialResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTrialRequest,
  output: DeleteTrialResponse,
  errors: [ResourceNotFound],
}));
/**
 * Deletes the specified trial component. A trial component must be disassociated from all trials before the trial component can be deleted. To disassociate a trial component from a trial, call the DisassociateTrialComponent API.
 */
export const deleteTrialComponent: (
  input: DeleteTrialComponentRequest,
) => effect.Effect<
  DeleteTrialComponentResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTrialComponentRequest,
  output: DeleteTrialComponentResponse,
  errors: [ResourceNotFound],
}));
/**
 * Deletes a user profile. When a user profile is deleted, the user loses access to their EFS volume, including data, notebooks, and other artifacts.
 */
export const deleteUserProfile: (
  input: DeleteUserProfileRequest,
) => effect.Effect<
  DeleteUserProfileResponse,
  ResourceInUse | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteUserProfileRequest,
  output: DeleteUserProfileResponse,
  errors: [ResourceInUse, ResourceNotFound],
}));
/**
 * Use this operation to delete a workforce.
 *
 * If you want to create a new workforce in an Amazon Web Services Region where a workforce already exists, use this operation to delete the existing workforce and then use CreateWorkforce to create a new workforce.
 *
 * If a private workforce contains one or more work teams, you must use the DeleteWorkteam operation to delete all work teams before you delete the workforce. If you try to delete a workforce that contains one or more work teams, you will receive a `ResourceInUse` error.
 */
export const deleteWorkforce: (
  input: DeleteWorkforceRequest,
) => effect.Effect<
  DeleteWorkforceResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteWorkforceRequest,
  output: DeleteWorkforceResponse,
  errors: [],
}));
/**
 * Deletes an existing work team. This operation can't be undone.
 */
export const deleteWorkteam: (
  input: DeleteWorkteamRequest,
) => effect.Effect<
  DeleteWorkteamResponse,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteWorkteamRequest,
  output: DeleteWorkteamResponse,
  errors: [ResourceLimitExceeded],
}));
/**
 * Deregisters the specified devices. After you deregister a device, you will need to re-register the devices.
 */
export const deregisterDevices: (
  input: DeregisterDevicesRequest,
) => effect.Effect<
  DeregisterDevicesResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeregisterDevicesRequest,
  output: DeregisterDevicesResponse,
  errors: [],
}));
/**
 * Describes an action.
 */
export const describeAction: (
  input: DescribeActionRequest,
) => effect.Effect<
  DescribeActionResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeActionRequest,
  output: DescribeActionResponse,
  errors: [ResourceNotFound],
}));
/**
 * Returns a description of the specified algorithm that is in your account.
 */
export const describeAlgorithm: (
  input: DescribeAlgorithmInput,
) => effect.Effect<
  DescribeAlgorithmOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAlgorithmInput,
  output: DescribeAlgorithmOutput,
  errors: [],
}));
/**
 * Describes the app.
 */
export const describeApp: (
  input: DescribeAppRequest,
) => effect.Effect<
  DescribeAppResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAppRequest,
  output: DescribeAppResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes an AppImageConfig.
 */
export const describeAppImageConfig: (
  input: DescribeAppImageConfigRequest,
) => effect.Effect<
  DescribeAppImageConfigResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAppImageConfigRequest,
  output: DescribeAppImageConfigResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes an artifact.
 */
export const describeArtifact: (
  input: DescribeArtifactRequest,
) => effect.Effect<
  DescribeArtifactResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeArtifactRequest,
  output: DescribeArtifactResponse,
  errors: [ResourceNotFound],
}));
/**
 * Returns information about an AutoML job created by calling CreateAutoMLJob.
 *
 * AutoML jobs created by calling CreateAutoMLJobV2 cannot be described by `DescribeAutoMLJob`.
 */
export const describeAutoMLJob: (
  input: DescribeAutoMLJobRequest,
) => effect.Effect<
  DescribeAutoMLJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAutoMLJobRequest,
  output: DescribeAutoMLJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Returns information about an AutoML job created by calling CreateAutoMLJobV2 or CreateAutoMLJob.
 */
export const describeAutoMLJobV2: (
  input: DescribeAutoMLJobV2Request,
) => effect.Effect<
  DescribeAutoMLJobV2Response,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAutoMLJobV2Request,
  output: DescribeAutoMLJobV2Response,
  errors: [ResourceNotFound],
}));
/**
 * Retrieves information of a SageMaker HyperPod cluster.
 */
export const describeCluster: (
  input: DescribeClusterRequest,
) => effect.Effect<
  DescribeClusterResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeClusterRequest,
  output: DescribeClusterResponse,
  errors: [ResourceNotFound],
}));
/**
 * Retrieves detailed information about a specific event for a given HyperPod cluster. This functionality is only supported when the `NodeProvisioningMode` is set to `Continuous`.
 */
export const describeClusterEvent: (
  input: DescribeClusterEventRequest,
) => effect.Effect<
  DescribeClusterEventResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeClusterEventRequest,
  output: DescribeClusterEventResponse,
  errors: [ResourceNotFound],
}));
/**
 * Retrieves information of a node (also called a *instance* interchangeably) of a SageMaker HyperPod cluster.
 */
export const describeClusterNode: (
  input: DescribeClusterNodeRequest,
) => effect.Effect<
  DescribeClusterNodeResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeClusterNodeRequest,
  output: DescribeClusterNodeResponse,
  errors: [ResourceNotFound],
}));
/**
 * Description of the cluster policy. This policy is used for task prioritization and fair-share allocation. This helps prioritize critical workloads and distributes idle compute across entities.
 */
export const describeClusterSchedulerConfig: (
  input: DescribeClusterSchedulerConfigRequest,
) => effect.Effect<
  DescribeClusterSchedulerConfigResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeClusterSchedulerConfigRequest,
  output: DescribeClusterSchedulerConfigResponse,
  errors: [ResourceNotFound],
}));
/**
 * Gets details about the specified Git repository.
 */
export const describeCodeRepository: (
  input: DescribeCodeRepositoryInput,
) => effect.Effect<
  DescribeCodeRepositoryOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeCodeRepositoryInput,
  output: DescribeCodeRepositoryOutput,
  errors: [],
}));
/**
 * Returns information about a model compilation job.
 *
 * To create a model compilation job, use CreateCompilationJob. To get information about multiple model compilation jobs, use ListCompilationJobs.
 */
export const describeCompilationJob: (
  input: DescribeCompilationJobRequest,
) => effect.Effect<
  DescribeCompilationJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeCompilationJobRequest,
  output: DescribeCompilationJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Description of the compute allocation definition.
 */
export const describeComputeQuota: (
  input: DescribeComputeQuotaRequest,
) => effect.Effect<
  DescribeComputeQuotaResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeComputeQuotaRequest,
  output: DescribeComputeQuotaResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes a context.
 */
export const describeContext: (
  input: DescribeContextRequest,
) => effect.Effect<
  DescribeContextResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeContextRequest,
  output: DescribeContextResponse,
  errors: [ResourceNotFound],
}));
/**
 * Gets the details of a data quality monitoring job definition.
 */
export const describeDataQualityJobDefinition: (
  input: DescribeDataQualityJobDefinitionRequest,
) => effect.Effect<
  DescribeDataQualityJobDefinitionResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDataQualityJobDefinitionRequest,
  output: DescribeDataQualityJobDefinitionResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes the device.
 */
export const describeDevice: (
  input: DescribeDeviceRequest,
) => effect.Effect<
  DescribeDeviceResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDeviceRequest,
  output: DescribeDeviceResponse,
  errors: [ResourceNotFound],
}));
/**
 * A description of the fleet the device belongs to.
 */
export const describeDeviceFleet: (
  input: DescribeDeviceFleetRequest,
) => effect.Effect<
  DescribeDeviceFleetResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDeviceFleetRequest,
  output: DescribeDeviceFleetResponse,
  errors: [ResourceNotFound],
}));
/**
 * The description of the domain.
 */
export const describeDomain: (
  input: DescribeDomainRequest,
) => effect.Effect<
  DescribeDomainResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDomainRequest,
  output: DescribeDomainResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes an edge deployment plan with deployment status per stage.
 */
export const describeEdgeDeploymentPlan: (
  input: DescribeEdgeDeploymentPlanRequest,
) => effect.Effect<
  DescribeEdgeDeploymentPlanResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeEdgeDeploymentPlanRequest,
  output: DescribeEdgeDeploymentPlanResponse,
  errors: [ResourceNotFound],
}));
/**
 * A description of edge packaging jobs.
 */
export const describeEdgePackagingJob: (
  input: DescribeEdgePackagingJobRequest,
) => effect.Effect<
  DescribeEdgePackagingJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeEdgePackagingJobRequest,
  output: DescribeEdgePackagingJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Returns the description of an endpoint.
 */
export const describeEndpoint: (
  input: DescribeEndpointInput,
) => effect.Effect<
  DescribeEndpointOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeEndpointInput,
  output: DescribeEndpointOutput,
  errors: [],
}));
/**
 * Returns the description of an endpoint configuration created using the `CreateEndpointConfig` API.
 */
export const describeEndpointConfig: (
  input: DescribeEndpointConfigInput,
) => effect.Effect<
  DescribeEndpointConfigOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeEndpointConfigInput,
  output: DescribeEndpointConfigOutput,
  errors: [],
}));
/**
 * Provides a list of an experiment's properties.
 */
export const describeExperiment: (
  input: DescribeExperimentRequest,
) => effect.Effect<
  DescribeExperimentResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeExperimentRequest,
  output: DescribeExperimentResponse,
  errors: [ResourceNotFound],
}));
/**
 * Use this operation to describe a `FeatureGroup`. The response includes information on the creation time, `FeatureGroup` name, the unique identifier for each `FeatureGroup`, and more.
 */
export const describeFeatureGroup: (
  input: DescribeFeatureGroupRequest,
) => effect.Effect<
  DescribeFeatureGroupResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeFeatureGroupRequest,
  output: DescribeFeatureGroupResponse,
  errors: [ResourceNotFound],
}));
/**
 * Shows the metadata for a feature within a feature group.
 */
export const describeFeatureMetadata: (
  input: DescribeFeatureMetadataRequest,
) => effect.Effect<
  DescribeFeatureMetadataResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeFeatureMetadataRequest,
  output: DescribeFeatureMetadataResponse,
  errors: [ResourceNotFound],
}));
/**
 * Returns information about the specified flow definition.
 */
export const describeFlowDefinition: (
  input: DescribeFlowDefinitionRequest,
) => effect.Effect<
  DescribeFlowDefinitionResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeFlowDefinitionRequest,
  output: DescribeFlowDefinitionResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes a hub.
 */
export const describeHub: (
  input: DescribeHubRequest,
) => effect.Effect<
  DescribeHubResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeHubRequest,
  output: DescribeHubResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describe the content of a hub.
 */
export const describeHubContent: (
  input: DescribeHubContentRequest,
) => effect.Effect<
  DescribeHubContentResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeHubContentRequest,
  output: DescribeHubContentResponse,
  errors: [ResourceNotFound],
}));
/**
 * Returns information about the requested human task user interface (worker task template).
 */
export const describeHumanTaskUi: (
  input: DescribeHumanTaskUiRequest,
) => effect.Effect<
  DescribeHumanTaskUiResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeHumanTaskUiRequest,
  output: DescribeHumanTaskUiResponse,
  errors: [ResourceNotFound],
}));
/**
 * Returns a description of a hyperparameter tuning job, depending on the fields selected. These fields can include the name, Amazon Resource Name (ARN), job status of your tuning job and more.
 */
export const describeHyperParameterTuningJob: (
  input: DescribeHyperParameterTuningJobRequest,
) => effect.Effect<
  DescribeHyperParameterTuningJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeHyperParameterTuningJobRequest,
  output: DescribeHyperParameterTuningJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes a SageMaker AI image.
 */
export const describeImage: (
  input: DescribeImageRequest,
) => effect.Effect<
  DescribeImageResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeImageRequest,
  output: DescribeImageResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes a version of a SageMaker AI image.
 */
export const describeImageVersion: (
  input: DescribeImageVersionRequest,
) => effect.Effect<
  DescribeImageVersionResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeImageVersionRequest,
  output: DescribeImageVersionResponse,
  errors: [ResourceNotFound],
}));
/**
 * Returns information about an inference component.
 */
export const describeInferenceComponent: (
  input: DescribeInferenceComponentInput,
) => effect.Effect<
  DescribeInferenceComponentOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeInferenceComponentInput,
  output: DescribeInferenceComponentOutput,
  errors: [],
}));
/**
 * Returns details about an inference experiment.
 */
export const describeInferenceExperiment: (
  input: DescribeInferenceExperimentRequest,
) => effect.Effect<
  DescribeInferenceExperimentResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeInferenceExperimentRequest,
  output: DescribeInferenceExperimentResponse,
  errors: [ResourceNotFound],
}));
/**
 * Provides the results of the Inference Recommender job. One or more recommendation jobs are returned.
 */
export const describeInferenceRecommendationsJob: (
  input: DescribeInferenceRecommendationsJobRequest,
) => effect.Effect<
  DescribeInferenceRecommendationsJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeInferenceRecommendationsJobRequest,
  output: DescribeInferenceRecommendationsJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Gets information about a labeling job.
 */
export const describeLabelingJob: (
  input: DescribeLabelingJobRequest,
) => effect.Effect<
  DescribeLabelingJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeLabelingJobRequest,
  output: DescribeLabelingJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Provides a list of properties for the requested lineage group. For more information, see Cross-Account Lineage Tracking in the *Amazon SageMaker Developer Guide*.
 */
export const describeLineageGroup: (
  input: DescribeLineageGroupRequest,
) => effect.Effect<
  DescribeLineageGroupResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeLineageGroupRequest,
  output: DescribeLineageGroupResponse,
  errors: [ResourceNotFound],
}));
/**
 * Returns information about an MLflow App.
 */
export const describeMlflowApp: (
  input: DescribeMlflowAppRequest,
) => effect.Effect<
  DescribeMlflowAppResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeMlflowAppRequest,
  output: DescribeMlflowAppResponse,
  errors: [ResourceNotFound],
}));
/**
 * Returns information about an MLflow Tracking Server.
 */
export const describeMlflowTrackingServer: (
  input: DescribeMlflowTrackingServerRequest,
) => effect.Effect<
  DescribeMlflowTrackingServerResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeMlflowTrackingServerRequest,
  output: DescribeMlflowTrackingServerResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes a model that you created using the `CreateModel` API.
 */
export const describeModel: (
  input: DescribeModelInput,
) => effect.Effect<
  DescribeModelOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeModelInput,
  output: DescribeModelOutput,
  errors: [],
}));
/**
 * Returns a description of a model bias job definition.
 */
export const describeModelBiasJobDefinition: (
  input: DescribeModelBiasJobDefinitionRequest,
) => effect.Effect<
  DescribeModelBiasJobDefinitionResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeModelBiasJobDefinitionRequest,
  output: DescribeModelBiasJobDefinitionResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes the content, creation time, and security configuration of an Amazon SageMaker Model Card.
 */
export const describeModelCard: (
  input: DescribeModelCardRequest,
) => effect.Effect<
  DescribeModelCardResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeModelCardRequest,
  output: DescribeModelCardResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes an Amazon SageMaker Model Card export job.
 */
export const describeModelCardExportJob: (
  input: DescribeModelCardExportJobRequest,
) => effect.Effect<
  DescribeModelCardExportJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeModelCardExportJobRequest,
  output: DescribeModelCardExportJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Returns a description of a model explainability job definition.
 */
export const describeModelExplainabilityJobDefinition: (
  input: DescribeModelExplainabilityJobDefinitionRequest,
) => effect.Effect<
  DescribeModelExplainabilityJobDefinitionResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeModelExplainabilityJobDefinitionRequest,
  output: DescribeModelExplainabilityJobDefinitionResponse,
  errors: [ResourceNotFound],
}));
/**
 * Returns a description of the specified model package, which is used to create SageMaker models or list them on Amazon Web Services Marketplace.
 *
 * If you provided a KMS Key ID when you created your model package, you will see the KMS Decrypt API call in your CloudTrail logs when you use this API.
 *
 * To create models in SageMaker, buyers can subscribe to model packages listed on Amazon Web Services Marketplace.
 */
export const describeModelPackage: (
  input: DescribeModelPackageInput,
) => effect.Effect<
  DescribeModelPackageOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeModelPackageInput,
  output: DescribeModelPackageOutput,
  errors: [],
}));
/**
 * Gets a description for the specified model group.
 */
export const describeModelPackageGroup: (
  input: DescribeModelPackageGroupInput,
) => effect.Effect<
  DescribeModelPackageGroupOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeModelPackageGroupInput,
  output: DescribeModelPackageGroupOutput,
  errors: [],
}));
/**
 * Returns a description of a model quality job definition.
 */
export const describeModelQualityJobDefinition: (
  input: DescribeModelQualityJobDefinitionRequest,
) => effect.Effect<
  DescribeModelQualityJobDefinitionResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeModelQualityJobDefinitionRequest,
  output: DescribeModelQualityJobDefinitionResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes the schedule for a monitoring job.
 */
export const describeMonitoringSchedule: (
  input: DescribeMonitoringScheduleRequest,
) => effect.Effect<
  DescribeMonitoringScheduleResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeMonitoringScheduleRequest,
  output: DescribeMonitoringScheduleResponse,
  errors: [ResourceNotFound],
}));
/**
 * Returns information about a notebook instance.
 */
export const describeNotebookInstance: (
  input: DescribeNotebookInstanceInput,
) => effect.Effect<
  DescribeNotebookInstanceOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeNotebookInstanceInput,
  output: DescribeNotebookInstanceOutput,
  errors: [],
}));
/**
 * Returns a description of a notebook instance lifecycle configuration.
 *
 * For information about notebook instance lifestyle configurations, see Step 2.1: (Optional) Customize a Notebook Instance.
 */
export const describeNotebookInstanceLifecycleConfig: (
  input: DescribeNotebookInstanceLifecycleConfigInput,
) => effect.Effect<
  DescribeNotebookInstanceLifecycleConfigOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeNotebookInstanceLifecycleConfigInput,
  output: DescribeNotebookInstanceLifecycleConfigOutput,
  errors: [],
}));
/**
 * Provides the properties of the specified optimization job.
 */
export const describeOptimizationJob: (
  input: DescribeOptimizationJobRequest,
) => effect.Effect<
  DescribeOptimizationJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeOptimizationJobRequest,
  output: DescribeOptimizationJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Gets information about a SageMaker Partner AI App.
 */
export const describePartnerApp: (
  input: DescribePartnerAppRequest,
) => effect.Effect<
  DescribePartnerAppResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribePartnerAppRequest,
  output: DescribePartnerAppResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes the details of a pipeline.
 */
export const describePipeline: (
  input: DescribePipelineRequest,
) => effect.Effect<
  DescribePipelineResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribePipelineRequest,
  output: DescribePipelineResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes the details of an execution's pipeline definition.
 */
export const describePipelineDefinitionForExecution: (
  input: DescribePipelineDefinitionForExecutionRequest,
) => effect.Effect<
  DescribePipelineDefinitionForExecutionResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribePipelineDefinitionForExecutionRequest,
  output: DescribePipelineDefinitionForExecutionResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes the details of a pipeline execution.
 */
export const describePipelineExecution: (
  input: DescribePipelineExecutionRequest,
) => effect.Effect<
  DescribePipelineExecutionResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribePipelineExecutionRequest,
  output: DescribePipelineExecutionResponse,
  errors: [ResourceNotFound],
}));
/**
 * Returns a description of a processing job.
 */
export const describeProcessingJob: (
  input: DescribeProcessingJobRequest,
) => effect.Effect<
  DescribeProcessingJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeProcessingJobRequest,
  output: DescribeProcessingJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes the details of a project.
 */
export const describeProject: (
  input: DescribeProjectInput,
) => effect.Effect<
  DescribeProjectOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeProjectInput,
  output: DescribeProjectOutput,
  errors: [],
}));
/**
 * Retrieves details about a reserved capacity.
 */
export const describeReservedCapacity: (
  input: DescribeReservedCapacityRequest,
) => effect.Effect<
  DescribeReservedCapacityResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeReservedCapacityRequest,
  output: DescribeReservedCapacityResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes the space.
 */
export const describeSpace: (
  input: DescribeSpaceRequest,
) => effect.Effect<
  DescribeSpaceResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeSpaceRequest,
  output: DescribeSpaceResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes the Amazon SageMaker AI Studio Lifecycle Configuration.
 */
export const describeStudioLifecycleConfig: (
  input: DescribeStudioLifecycleConfigRequest,
) => effect.Effect<
  DescribeStudioLifecycleConfigResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeStudioLifecycleConfigRequest,
  output: DescribeStudioLifecycleConfigResponse,
  errors: [ResourceNotFound],
}));
/**
 * Gets information about a work team provided by a vendor. It returns details about the subscription with a vendor in the Amazon Web Services Marketplace.
 */
export const describeSubscribedWorkteam: (
  input: DescribeSubscribedWorkteamRequest,
) => effect.Effect<
  DescribeSubscribedWorkteamResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeSubscribedWorkteamRequest,
  output: DescribeSubscribedWorkteamResponse,
  errors: [],
}));
/**
 * Returns information about a training job.
 *
 * Some of the attributes below only appear if the training job successfully starts. If the training job fails, `TrainingJobStatus` is `Failed` and, depending on the `FailureReason`, attributes like `TrainingStartTime`, `TrainingTimeInSeconds`, `TrainingEndTime`, and `BillableTimeInSeconds` may not be present in the response.
 */
export const describeTrainingJob: (
  input: DescribeTrainingJobRequest,
) => effect.Effect<
  DescribeTrainingJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeTrainingJobRequest,
  output: DescribeTrainingJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Retrieves detailed information about a specific training plan.
 */
export const describeTrainingPlan: (
  input: DescribeTrainingPlanRequest,
) => effect.Effect<
  DescribeTrainingPlanResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeTrainingPlanRequest,
  output: DescribeTrainingPlanResponse,
  errors: [ResourceNotFound],
}));
/**
 * Returns information about a transform job.
 */
export const describeTransformJob: (
  input: DescribeTransformJobRequest,
) => effect.Effect<
  DescribeTransformJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeTransformJobRequest,
  output: DescribeTransformJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Provides a list of a trial's properties.
 */
export const describeTrial: (
  input: DescribeTrialRequest,
) => effect.Effect<
  DescribeTrialResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeTrialRequest,
  output: DescribeTrialResponse,
  errors: [ResourceNotFound],
}));
/**
 * Provides a list of a trials component's properties.
 */
export const describeTrialComponent: (
  input: DescribeTrialComponentRequest,
) => effect.Effect<
  DescribeTrialComponentResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeTrialComponentRequest,
  output: DescribeTrialComponentResponse,
  errors: [ResourceNotFound],
}));
/**
 * Describes a user profile. For more information, see `CreateUserProfile`.
 */
export const describeUserProfile: (
  input: DescribeUserProfileRequest,
) => effect.Effect<
  DescribeUserProfileResponse,
  ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeUserProfileRequest,
  output: DescribeUserProfileResponse,
  errors: [ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Lists private workforce information, including workforce name, Amazon Resource Name (ARN), and, if applicable, allowed IP address ranges (CIDRs). Allowable IP address ranges are the IP addresses that workers can use to access tasks.
 *
 * This operation applies only to private workforces.
 */
export const describeWorkforce: (
  input: DescribeWorkforceRequest,
) => effect.Effect<
  DescribeWorkforceResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeWorkforceRequest,
  output: DescribeWorkforceResponse,
  errors: [],
}));
/**
 * Gets information about a specific work team. You can see information such as the creation date, the last updated date, membership information, and the work team's Amazon Resource Name (ARN).
 */
export const describeWorkteam: (
  input: DescribeWorkteamRequest,
) => effect.Effect<
  DescribeWorkteamResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeWorkteamRequest,
  output: DescribeWorkteamResponse,
  errors: [],
}));
/**
 * Detaches your Amazon Elastic Block Store (Amazon EBS) volume from a node in your EKS orchestrated SageMaker HyperPod cluster.
 *
 * This API works with the Amazon Elastic Block Store (Amazon EBS) Container Storage Interface (CSI) driver to manage the lifecycle of persistent storage in your HyperPod EKS clusters.
 */
export const detachClusterNodeVolume: (
  input: DetachClusterNodeVolumeRequest,
) => effect.Effect<
  DetachClusterNodeVolumeResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DetachClusterNodeVolumeRequest,
  output: DetachClusterNodeVolumeResponse,
  errors: [ResourceNotFound],
}));
/**
 * Disables using Service Catalog in SageMaker. Service Catalog is used to create SageMaker projects.
 */
export const disableSagemakerServicecatalogPortfolio: (
  input: DisableSagemakerServicecatalogPortfolioInput,
) => effect.Effect<
  DisableSagemakerServicecatalogPortfolioOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisableSagemakerServicecatalogPortfolioInput,
  output: DisableSagemakerServicecatalogPortfolioOutput,
  errors: [],
}));
/**
 * Disassociates a trial component from a trial. This doesn't effect other trials the component is associated with. Before you can delete a component, you must disassociate the component from all trials it is associated with. To associate a trial component with a trial, call the AssociateTrialComponent API.
 *
 * To get a list of the trials a component is associated with, use the Search API. Specify `ExperimentTrialComponent` for the `Resource` parameter. The list appears in the response under `Results.TrialComponent.Parents`.
 */
export const disassociateTrialComponent: (
  input: DisassociateTrialComponentRequest,
) => effect.Effect<
  DisassociateTrialComponentResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateTrialComponentRequest,
  output: DisassociateTrialComponentResponse,
  errors: [ResourceNotFound],
}));
/**
 * Enables using Service Catalog in SageMaker. Service Catalog is used to create SageMaker projects.
 */
export const enableSagemakerServicecatalogPortfolio: (
  input: EnableSagemakerServicecatalogPortfolioInput,
) => effect.Effect<
  EnableSagemakerServicecatalogPortfolioOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: EnableSagemakerServicecatalogPortfolioInput,
  output: EnableSagemakerServicecatalogPortfolioOutput,
  errors: [],
}));
/**
 * Describes a fleet.
 */
export const getDeviceFleetReport: (
  input: GetDeviceFleetReportRequest,
) => effect.Effect<
  GetDeviceFleetReportResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetDeviceFleetReportRequest,
  output: GetDeviceFleetReportResponse,
  errors: [],
}));
/**
 * The resource policy for the lineage group.
 */
export const getLineageGroupPolicy: (
  input: GetLineageGroupPolicyRequest,
) => effect.Effect<
  GetLineageGroupPolicyResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetLineageGroupPolicyRequest,
  output: GetLineageGroupPolicyResponse,
  errors: [ResourceNotFound],
}));
/**
 * Gets a resource policy that manages access for a model group. For information about resource policies, see Identity-based policies and resource-based policies in the *Amazon Web Services Identity and Access Management User Guide.*.
 */
export const getModelPackageGroupPolicy: (
  input: GetModelPackageGroupPolicyInput,
) => effect.Effect<
  GetModelPackageGroupPolicyOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetModelPackageGroupPolicyInput,
  output: GetModelPackageGroupPolicyOutput,
  errors: [],
}));
/**
 * Gets the status of Service Catalog in SageMaker. Service Catalog is used to create SageMaker projects.
 */
export const getSagemakerServicecatalogPortfolioStatus: (
  input: GetSagemakerServicecatalogPortfolioStatusInput,
) => effect.Effect<
  GetSagemakerServicecatalogPortfolioStatusOutput,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetSagemakerServicecatalogPortfolioStatusInput,
  output: GetSagemakerServicecatalogPortfolioStatusOutput,
  errors: [],
}));
/**
 * Starts an Amazon SageMaker Inference Recommender autoscaling recommendation job. Returns recommendations for autoscaling policies that you can apply to your SageMaker endpoint.
 */
export const getScalingConfigurationRecommendation: (
  input: GetScalingConfigurationRecommendationRequest,
) => effect.Effect<
  GetScalingConfigurationRecommendationResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetScalingConfigurationRecommendationRequest,
  output: GetScalingConfigurationRecommendationResponse,
  errors: [ResourceNotFound],
}));
/**
 * An auto-complete API for the search functionality in the SageMaker console. It returns suggestions of possible matches for the property name to use in `Search` queries. Provides suggestions for `HyperParameters`, `Tags`, and `Metrics`.
 */
export const getSearchSuggestions: (
  input: GetSearchSuggestionsRequest,
) => effect.Effect<
  GetSearchSuggestionsResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetSearchSuggestionsRequest,
  output: GetSearchSuggestionsResponse,
  errors: [],
}));
/**
 * Import hub content.
 */
export const importHubContent: (
  input: ImportHubContentRequest,
) => effect.Effect<
  ImportHubContentResponse,
  ResourceInUse | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ImportHubContentRequest,
  output: ImportHubContentResponse,
  errors: [ResourceInUse, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Lists the actions in your account and their properties.
 */
export const listActions: {
  (
    input: ListActionsRequest,
  ): effect.Effect<
    ListActionsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListActionsRequest,
  ) => stream.Stream<
    ListActionsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListActionsRequest,
  ) => stream.Stream<
    ActionSummary,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListActionsRequest,
  output: ListActionsResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ActionSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the machine learning algorithms that have been created.
 */
export const listAlgorithms: {
  (
    input: ListAlgorithmsInput,
  ): effect.Effect<
    ListAlgorithmsOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListAlgorithmsInput,
  ) => stream.Stream<
    ListAlgorithmsOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListAlgorithmsInput,
  ) => stream.Stream<
    AlgorithmSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListAlgorithmsInput,
  output: ListAlgorithmsOutput,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AlgorithmSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the aliases of a specified image or image version.
 */
export const listAliases: {
  (
    input: ListAliasesRequest,
  ): effect.Effect<
    ListAliasesResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListAliasesRequest,
  ) => stream.Stream<
    ListAliasesResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListAliasesRequest,
  ) => stream.Stream<
    SageMakerImageVersionAlias,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListAliasesRequest,
  output: ListAliasesResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SageMakerImageVersionAliases",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the AppImageConfigs in your account and their properties. The list can be filtered by creation time or modified time, and whether the AppImageConfig name contains a specified string.
 */
export const listAppImageConfigs: {
  (
    input: ListAppImageConfigsRequest,
  ): effect.Effect<
    ListAppImageConfigsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListAppImageConfigsRequest,
  ) => stream.Stream<
    ListAppImageConfigsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListAppImageConfigsRequest,
  ) => stream.Stream<
    AppImageConfigDetails,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListAppImageConfigsRequest,
  output: ListAppImageConfigsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AppImageConfigs",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists apps.
 */
export const listApps: {
  (
    input: ListAppsRequest,
  ): effect.Effect<
    ListAppsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListAppsRequest,
  ) => stream.Stream<
    ListAppsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListAppsRequest,
  ) => stream.Stream<
    AppDetails,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListAppsRequest,
  output: ListAppsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Apps",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the artifacts in your account and their properties.
 */
export const listArtifacts: {
  (
    input: ListArtifactsRequest,
  ): effect.Effect<
    ListArtifactsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListArtifactsRequest,
  ) => stream.Stream<
    ListArtifactsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListArtifactsRequest,
  ) => stream.Stream<
    ArtifactSummary,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListArtifactsRequest,
  output: ListArtifactsResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ArtifactSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the associations in your account and their properties.
 */
export const listAssociations: {
  (
    input: ListAssociationsRequest,
  ): effect.Effect<
    ListAssociationsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListAssociationsRequest,
  ) => stream.Stream<
    ListAssociationsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListAssociationsRequest,
  ) => stream.Stream<
    AssociationSummary,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListAssociationsRequest,
  output: ListAssociationsResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AssociationSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Request a list of jobs.
 */
export const listAutoMLJobs: {
  (
    input: ListAutoMLJobsRequest,
  ): effect.Effect<
    ListAutoMLJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListAutoMLJobsRequest,
  ) => stream.Stream<
    ListAutoMLJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListAutoMLJobsRequest,
  ) => stream.Stream<
    AutoMLJobSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListAutoMLJobsRequest,
  output: ListAutoMLJobsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AutoMLJobSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * List the candidates created for the job.
 */
export const listCandidatesForAutoMLJob: {
  (
    input: ListCandidatesForAutoMLJobRequest,
  ): effect.Effect<
    ListCandidatesForAutoMLJobResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListCandidatesForAutoMLJobRequest,
  ) => stream.Stream<
    ListCandidatesForAutoMLJobResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListCandidatesForAutoMLJobRequest,
  ) => stream.Stream<
    AutoMLCandidate,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListCandidatesForAutoMLJobRequest,
  output: ListCandidatesForAutoMLJobResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Candidates",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Retrieves a list of event summaries for a specified HyperPod cluster. The operation supports filtering, sorting, and pagination of results. This functionality is only supported when the `NodeProvisioningMode` is set to `Continuous`.
 */
export const listClusterEvents: {
  (
    input: ListClusterEventsRequest,
  ): effect.Effect<
    ListClusterEventsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListClusterEventsRequest,
  ) => stream.Stream<
    ListClusterEventsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListClusterEventsRequest,
  ) => stream.Stream<
    ClusterEventSummary,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListClusterEventsRequest,
  output: ListClusterEventsResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Events",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Retrieves the list of instances (also called *nodes* interchangeably) in a SageMaker HyperPod cluster.
 */
export const listClusterNodes: {
  (
    input: ListClusterNodesRequest,
  ): effect.Effect<
    ListClusterNodesResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListClusterNodesRequest,
  ) => stream.Stream<
    ListClusterNodesResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListClusterNodesRequest,
  ) => stream.Stream<
    ClusterNodeSummary,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListClusterNodesRequest,
  output: ListClusterNodesResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ClusterNodeSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Retrieves the list of SageMaker HyperPod clusters.
 */
export const listClusters: {
  (
    input: ListClustersRequest,
  ): effect.Effect<
    ListClustersResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListClustersRequest,
  ) => stream.Stream<
    ListClustersResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListClustersRequest,
  ) => stream.Stream<
    ClusterSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListClustersRequest,
  output: ListClustersResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ClusterSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * List the cluster policy configurations.
 */
export const listClusterSchedulerConfigs: {
  (
    input: ListClusterSchedulerConfigsRequest,
  ): effect.Effect<
    ListClusterSchedulerConfigsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListClusterSchedulerConfigsRequest,
  ) => stream.Stream<
    ListClusterSchedulerConfigsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListClusterSchedulerConfigsRequest,
  ) => stream.Stream<
    ClusterSchedulerConfigSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListClusterSchedulerConfigsRequest,
  output: ListClusterSchedulerConfigsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ClusterSchedulerConfigSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets a list of the Git repositories in your account.
 */
export const listCodeRepositories: {
  (
    input: ListCodeRepositoriesInput,
  ): effect.Effect<
    ListCodeRepositoriesOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListCodeRepositoriesInput,
  ) => stream.Stream<
    ListCodeRepositoriesOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListCodeRepositoriesInput,
  ) => stream.Stream<
    CodeRepositorySummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListCodeRepositoriesInput,
  output: ListCodeRepositoriesOutput,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "CodeRepositorySummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists model compilation jobs that satisfy various filters.
 *
 * To create a model compilation job, use CreateCompilationJob. To get information about a particular model compilation job you have created, use DescribeCompilationJob.
 */
export const listCompilationJobs: {
  (
    input: ListCompilationJobsRequest,
  ): effect.Effect<
    ListCompilationJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListCompilationJobsRequest,
  ) => stream.Stream<
    ListCompilationJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListCompilationJobsRequest,
  ) => stream.Stream<
    CompilationJobSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListCompilationJobsRequest,
  output: ListCompilationJobsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "CompilationJobSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * List the resource allocation definitions.
 */
export const listComputeQuotas: {
  (
    input: ListComputeQuotasRequest,
  ): effect.Effect<
    ListComputeQuotasResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListComputeQuotasRequest,
  ) => stream.Stream<
    ListComputeQuotasResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListComputeQuotasRequest,
  ) => stream.Stream<
    ComputeQuotaSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListComputeQuotasRequest,
  output: ListComputeQuotasResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ComputeQuotaSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the contexts in your account and their properties.
 */
export const listContexts: {
  (
    input: ListContextsRequest,
  ): effect.Effect<
    ListContextsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListContextsRequest,
  ) => stream.Stream<
    ListContextsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListContextsRequest,
  ) => stream.Stream<
    ContextSummary,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListContextsRequest,
  output: ListContextsResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ContextSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the data quality job definitions in your account.
 */
export const listDataQualityJobDefinitions: {
  (
    input: ListDataQualityJobDefinitionsRequest,
  ): effect.Effect<
    ListDataQualityJobDefinitionsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListDataQualityJobDefinitionsRequest,
  ) => stream.Stream<
    ListDataQualityJobDefinitionsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListDataQualityJobDefinitionsRequest,
  ) => stream.Stream<
    MonitoringJobDefinitionSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListDataQualityJobDefinitionsRequest,
  output: ListDataQualityJobDefinitionsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "JobDefinitionSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Returns a list of devices in the fleet.
 */
export const listDeviceFleets: {
  (
    input: ListDeviceFleetsRequest,
  ): effect.Effect<
    ListDeviceFleetsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListDeviceFleetsRequest,
  ) => stream.Stream<
    ListDeviceFleetsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListDeviceFleetsRequest,
  ) => stream.Stream<
    DeviceFleetSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListDeviceFleetsRequest,
  output: ListDeviceFleetsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "DeviceFleetSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * A list of devices.
 */
export const listDevices: {
  (
    input: ListDevicesRequest,
  ): effect.Effect<
    ListDevicesResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListDevicesRequest,
  ) => stream.Stream<
    ListDevicesResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListDevicesRequest,
  ) => stream.Stream<
    DeviceSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListDevicesRequest,
  output: ListDevicesResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "DeviceSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the domains.
 */
export const listDomains: {
  (
    input: ListDomainsRequest,
  ): effect.Effect<
    ListDomainsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListDomainsRequest,
  ) => stream.Stream<
    ListDomainsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListDomainsRequest,
  ) => stream.Stream<
    DomainDetails,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListDomainsRequest,
  output: ListDomainsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Domains",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all edge deployment plans.
 */
export const listEdgeDeploymentPlans: {
  (
    input: ListEdgeDeploymentPlansRequest,
  ): effect.Effect<
    ListEdgeDeploymentPlansResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListEdgeDeploymentPlansRequest,
  ) => stream.Stream<
    ListEdgeDeploymentPlansResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListEdgeDeploymentPlansRequest,
  ) => stream.Stream<
    EdgeDeploymentPlanSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListEdgeDeploymentPlansRequest,
  output: ListEdgeDeploymentPlansResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "EdgeDeploymentPlanSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Returns a list of edge packaging jobs.
 */
export const listEdgePackagingJobs: {
  (
    input: ListEdgePackagingJobsRequest,
  ): effect.Effect<
    ListEdgePackagingJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListEdgePackagingJobsRequest,
  ) => stream.Stream<
    ListEdgePackagingJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListEdgePackagingJobsRequest,
  ) => stream.Stream<
    EdgePackagingJobSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListEdgePackagingJobsRequest,
  output: ListEdgePackagingJobsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "EdgePackagingJobSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists endpoint configurations.
 */
export const listEndpointConfigs: {
  (
    input: ListEndpointConfigsInput,
  ): effect.Effect<
    ListEndpointConfigsOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListEndpointConfigsInput,
  ) => stream.Stream<
    ListEndpointConfigsOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListEndpointConfigsInput,
  ) => stream.Stream<
    EndpointConfigSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListEndpointConfigsInput,
  output: ListEndpointConfigsOutput,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "EndpointConfigs",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists endpoints.
 */
export const listEndpoints: {
  (
    input: ListEndpointsInput,
  ): effect.Effect<
    ListEndpointsOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListEndpointsInput,
  ) => stream.Stream<
    ListEndpointsOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListEndpointsInput,
  ) => stream.Stream<
    EndpointSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListEndpointsInput,
  output: ListEndpointsOutput,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Endpoints",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all the experiments in your account. The list can be filtered to show only experiments that were created in a specific time range. The list can be sorted by experiment name or creation time.
 */
export const listExperiments: {
  (
    input: ListExperimentsRequest,
  ): effect.Effect<
    ListExperimentsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListExperimentsRequest,
  ) => stream.Stream<
    ListExperimentsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListExperimentsRequest,
  ) => stream.Stream<
    ExperimentSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListExperimentsRequest,
  output: ListExperimentsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ExperimentSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * List `FeatureGroup`s based on given filter and order.
 */
export const listFeatureGroups: {
  (
    input: ListFeatureGroupsRequest,
  ): effect.Effect<
    ListFeatureGroupsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListFeatureGroupsRequest,
  ) => stream.Stream<
    ListFeatureGroupsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListFeatureGroupsRequest,
  ) => stream.Stream<
    FeatureGroupSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListFeatureGroupsRequest,
  output: ListFeatureGroupsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "FeatureGroupSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Returns information about the flow definitions in your account.
 */
export const listFlowDefinitions: {
  (
    input: ListFlowDefinitionsRequest,
  ): effect.Effect<
    ListFlowDefinitionsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListFlowDefinitionsRequest,
  ) => stream.Stream<
    ListFlowDefinitionsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListFlowDefinitionsRequest,
  ) => stream.Stream<
    FlowDefinitionSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListFlowDefinitionsRequest,
  output: ListFlowDefinitionsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "FlowDefinitionSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * List the contents of a hub.
 */
export const listHubContents: (
  input: ListHubContentsRequest,
) => effect.Effect<
  ListHubContentsResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListHubContentsRequest,
  output: ListHubContentsResponse,
  errors: [ResourceNotFound],
}));
/**
 * List hub content versions.
 */
export const listHubContentVersions: (
  input: ListHubContentVersionsRequest,
) => effect.Effect<
  ListHubContentVersionsResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListHubContentVersionsRequest,
  output: ListHubContentVersionsResponse,
  errors: [ResourceNotFound],
}));
/**
 * List all existing hubs.
 */
export const listHubs: (
  input: ListHubsRequest,
) => effect.Effect<
  ListHubsResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListHubsRequest,
  output: ListHubsResponse,
  errors: [],
}));
/**
 * Returns information about the human task user interfaces in your account.
 */
export const listHumanTaskUis: {
  (
    input: ListHumanTaskUisRequest,
  ): effect.Effect<
    ListHumanTaskUisResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListHumanTaskUisRequest,
  ) => stream.Stream<
    ListHumanTaskUisResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListHumanTaskUisRequest,
  ) => stream.Stream<
    HumanTaskUiSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListHumanTaskUisRequest,
  output: ListHumanTaskUisResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "HumanTaskUiSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets a list of HyperParameterTuningJobSummary objects that describe the hyperparameter tuning jobs launched in your account.
 */
export const listHyperParameterTuningJobs: {
  (
    input: ListHyperParameterTuningJobsRequest,
  ): effect.Effect<
    ListHyperParameterTuningJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListHyperParameterTuningJobsRequest,
  ) => stream.Stream<
    ListHyperParameterTuningJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListHyperParameterTuningJobsRequest,
  ) => stream.Stream<
    HyperParameterTuningJobSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListHyperParameterTuningJobsRequest,
  output: ListHyperParameterTuningJobsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "HyperParameterTuningJobSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the images in your account and their properties. The list can be filtered by creation time or modified time, and whether the image name contains a specified string.
 */
export const listImages: {
  (
    input: ListImagesRequest,
  ): effect.Effect<
    ListImagesResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListImagesRequest,
  ) => stream.Stream<
    ListImagesResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListImagesRequest,
  ) => stream.Stream<
    Image,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListImagesRequest,
  output: ListImagesResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Images",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the versions of a specified image and their properties. The list can be filtered by creation time or modified time.
 */
export const listImageVersions: {
  (
    input: ListImageVersionsRequest,
  ): effect.Effect<
    ListImageVersionsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListImageVersionsRequest,
  ) => stream.Stream<
    ListImageVersionsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListImageVersionsRequest,
  ) => stream.Stream<
    ImageVersion,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListImageVersionsRequest,
  output: ListImageVersionsResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ImageVersions",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the inference components in your account and their properties.
 */
export const listInferenceComponents: {
  (
    input: ListInferenceComponentsInput,
  ): effect.Effect<
    ListInferenceComponentsOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListInferenceComponentsInput,
  ) => stream.Stream<
    ListInferenceComponentsOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListInferenceComponentsInput,
  ) => stream.Stream<
    InferenceComponentSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListInferenceComponentsInput,
  output: ListInferenceComponentsOutput,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "InferenceComponents",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Returns the list of all inference experiments.
 */
export const listInferenceExperiments: {
  (
    input: ListInferenceExperimentsRequest,
  ): effect.Effect<
    ListInferenceExperimentsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListInferenceExperimentsRequest,
  ) => stream.Stream<
    ListInferenceExperimentsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListInferenceExperimentsRequest,
  ) => stream.Stream<
    InferenceExperimentSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListInferenceExperimentsRequest,
  output: ListInferenceExperimentsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "InferenceExperiments",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists recommendation jobs that satisfy various filters.
 */
export const listInferenceRecommendationsJobs: {
  (
    input: ListInferenceRecommendationsJobsRequest,
  ): effect.Effect<
    ListInferenceRecommendationsJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListInferenceRecommendationsJobsRequest,
  ) => stream.Stream<
    ListInferenceRecommendationsJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListInferenceRecommendationsJobsRequest,
  ) => stream.Stream<
    InferenceRecommendationsJob,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListInferenceRecommendationsJobsRequest,
  output: ListInferenceRecommendationsJobsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "InferenceRecommendationsJobs",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Returns a list of the subtasks for an Inference Recommender job.
 *
 * The supported subtasks are benchmarks, which evaluate the performance of your model on different instance types.
 */
export const listInferenceRecommendationsJobSteps: {
  (
    input: ListInferenceRecommendationsJobStepsRequest,
  ): effect.Effect<
    ListInferenceRecommendationsJobStepsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListInferenceRecommendationsJobStepsRequest,
  ) => stream.Stream<
    ListInferenceRecommendationsJobStepsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListInferenceRecommendationsJobStepsRequest,
  ) => stream.Stream<
    InferenceRecommendationsJobStep,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListInferenceRecommendationsJobStepsRequest,
  output: ListInferenceRecommendationsJobStepsResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Steps",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets a list of labeling jobs.
 */
export const listLabelingJobs: {
  (
    input: ListLabelingJobsRequest,
  ): effect.Effect<
    ListLabelingJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListLabelingJobsRequest,
  ) => stream.Stream<
    ListLabelingJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListLabelingJobsRequest,
  ) => stream.Stream<
    LabelingJobSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListLabelingJobsRequest,
  output: ListLabelingJobsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "LabelingJobSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets a list of labeling jobs assigned to a specified work team.
 */
export const listLabelingJobsForWorkteam: {
  (
    input: ListLabelingJobsForWorkteamRequest,
  ): effect.Effect<
    ListLabelingJobsForWorkteamResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListLabelingJobsForWorkteamRequest,
  ) => stream.Stream<
    ListLabelingJobsForWorkteamResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListLabelingJobsForWorkteamRequest,
  ) => stream.Stream<
    LabelingJobForWorkteamSummary,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListLabelingJobsForWorkteamRequest,
  output: ListLabelingJobsForWorkteamResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "LabelingJobSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * A list of lineage groups shared with your Amazon Web Services account. For more information, see Cross-Account Lineage Tracking in the *Amazon SageMaker Developer Guide*.
 */
export const listLineageGroups: {
  (
    input: ListLineageGroupsRequest,
  ): effect.Effect<
    ListLineageGroupsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListLineageGroupsRequest,
  ) => stream.Stream<
    ListLineageGroupsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListLineageGroupsRequest,
  ) => stream.Stream<
    LineageGroupSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListLineageGroupsRequest,
  output: ListLineageGroupsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "LineageGroupSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all MLflow Apps
 */
export const listMlflowApps: {
  (
    input: ListMlflowAppsRequest,
  ): effect.Effect<
    ListMlflowAppsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListMlflowAppsRequest,
  ) => stream.Stream<
    ListMlflowAppsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListMlflowAppsRequest,
  ) => stream.Stream<
    MlflowAppSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListMlflowAppsRequest,
  output: ListMlflowAppsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Summaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all MLflow Tracking Servers.
 */
export const listMlflowTrackingServers: {
  (
    input: ListMlflowTrackingServersRequest,
  ): effect.Effect<
    ListMlflowTrackingServersResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListMlflowTrackingServersRequest,
  ) => stream.Stream<
    ListMlflowTrackingServersResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListMlflowTrackingServersRequest,
  ) => stream.Stream<
    TrackingServerSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListMlflowTrackingServersRequest,
  output: ListMlflowTrackingServersResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TrackingServerSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists model bias jobs definitions that satisfy various filters.
 */
export const listModelBiasJobDefinitions: {
  (
    input: ListModelBiasJobDefinitionsRequest,
  ): effect.Effect<
    ListModelBiasJobDefinitionsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListModelBiasJobDefinitionsRequest,
  ) => stream.Stream<
    ListModelBiasJobDefinitionsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListModelBiasJobDefinitionsRequest,
  ) => stream.Stream<
    MonitoringJobDefinitionSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListModelBiasJobDefinitionsRequest,
  output: ListModelBiasJobDefinitionsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "JobDefinitionSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * List the export jobs for the Amazon SageMaker Model Card.
 */
export const listModelCardExportJobs: {
  (
    input: ListModelCardExportJobsRequest,
  ): effect.Effect<
    ListModelCardExportJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListModelCardExportJobsRequest,
  ) => stream.Stream<
    ListModelCardExportJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListModelCardExportJobsRequest,
  ) => stream.Stream<
    ModelCardExportJobSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListModelCardExportJobsRequest,
  output: ListModelCardExportJobsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ModelCardExportJobSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * List existing model cards.
 */
export const listModelCards: {
  (
    input: ListModelCardsRequest,
  ): effect.Effect<
    ListModelCardsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListModelCardsRequest,
  ) => stream.Stream<
    ListModelCardsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListModelCardsRequest,
  ) => stream.Stream<
    ModelCardSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListModelCardsRequest,
  output: ListModelCardsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ModelCardSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * List existing versions of an Amazon SageMaker Model Card.
 */
export const listModelCardVersions: {
  (
    input: ListModelCardVersionsRequest,
  ): effect.Effect<
    ListModelCardVersionsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListModelCardVersionsRequest,
  ) => stream.Stream<
    ListModelCardVersionsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListModelCardVersionsRequest,
  ) => stream.Stream<
    ModelCardVersionSummary,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListModelCardVersionsRequest,
  output: ListModelCardVersionsResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ModelCardVersionSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists model explainability job definitions that satisfy various filters.
 */
export const listModelExplainabilityJobDefinitions: {
  (
    input: ListModelExplainabilityJobDefinitionsRequest,
  ): effect.Effect<
    ListModelExplainabilityJobDefinitionsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListModelExplainabilityJobDefinitionsRequest,
  ) => stream.Stream<
    ListModelExplainabilityJobDefinitionsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListModelExplainabilityJobDefinitionsRequest,
  ) => stream.Stream<
    MonitoringJobDefinitionSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListModelExplainabilityJobDefinitionsRequest,
  output: ListModelExplainabilityJobDefinitionsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "JobDefinitionSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the domain, framework, task, and model name of standard machine learning models found in common model zoos.
 */
export const listModelMetadata: {
  (
    input: ListModelMetadataRequest,
  ): effect.Effect<
    ListModelMetadataResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListModelMetadataRequest,
  ) => stream.Stream<
    ListModelMetadataResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListModelMetadataRequest,
  ) => stream.Stream<
    ModelMetadataSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListModelMetadataRequest,
  output: ListModelMetadataResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ModelMetadataSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets a list of the model groups in your Amazon Web Services account.
 */
export const listModelPackageGroups: {
  (
    input: ListModelPackageGroupsInput,
  ): effect.Effect<
    ListModelPackageGroupsOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListModelPackageGroupsInput,
  ) => stream.Stream<
    ListModelPackageGroupsOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListModelPackageGroupsInput,
  ) => stream.Stream<
    ModelPackageGroupSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListModelPackageGroupsInput,
  output: ListModelPackageGroupsOutput,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ModelPackageGroupSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the model packages that have been created.
 */
export const listModelPackages: {
  (
    input: ListModelPackagesInput,
  ): effect.Effect<
    ListModelPackagesOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListModelPackagesInput,
  ) => stream.Stream<
    ListModelPackagesOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListModelPackagesInput,
  ) => stream.Stream<
    ModelPackageSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListModelPackagesInput,
  output: ListModelPackagesOutput,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ModelPackageSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets a list of model quality monitoring job definitions in your account.
 */
export const listModelQualityJobDefinitions: {
  (
    input: ListModelQualityJobDefinitionsRequest,
  ): effect.Effect<
    ListModelQualityJobDefinitionsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListModelQualityJobDefinitionsRequest,
  ) => stream.Stream<
    ListModelQualityJobDefinitionsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListModelQualityJobDefinitionsRequest,
  ) => stream.Stream<
    MonitoringJobDefinitionSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListModelQualityJobDefinitionsRequest,
  output: ListModelQualityJobDefinitionsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "JobDefinitionSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists models created with the `CreateModel` API.
 */
export const listModels: {
  (
    input: ListModelsInput,
  ): effect.Effect<
    ListModelsOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListModelsInput,
  ) => stream.Stream<
    ListModelsOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListModelsInput,
  ) => stream.Stream<
    ModelSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListModelsInput,
  output: ListModelsOutput,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Models",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets a list of past alerts in a model monitoring schedule.
 */
export const listMonitoringAlertHistory: {
  (
    input: ListMonitoringAlertHistoryRequest,
  ): effect.Effect<
    ListMonitoringAlertHistoryResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListMonitoringAlertHistoryRequest,
  ) => stream.Stream<
    ListMonitoringAlertHistoryResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListMonitoringAlertHistoryRequest,
  ) => stream.Stream<
    MonitoringAlertHistorySummary,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListMonitoringAlertHistoryRequest,
  output: ListMonitoringAlertHistoryResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "MonitoringAlertHistory",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets the alerts for a single monitoring schedule.
 */
export const listMonitoringAlerts: {
  (
    input: ListMonitoringAlertsRequest,
  ): effect.Effect<
    ListMonitoringAlertsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListMonitoringAlertsRequest,
  ) => stream.Stream<
    ListMonitoringAlertsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListMonitoringAlertsRequest,
  ) => stream.Stream<
    MonitoringAlertSummary,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListMonitoringAlertsRequest,
  output: ListMonitoringAlertsResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "MonitoringAlertSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Returns list of all monitoring job executions.
 */
export const listMonitoringExecutions: {
  (
    input: ListMonitoringExecutionsRequest,
  ): effect.Effect<
    ListMonitoringExecutionsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListMonitoringExecutionsRequest,
  ) => stream.Stream<
    ListMonitoringExecutionsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListMonitoringExecutionsRequest,
  ) => stream.Stream<
    MonitoringExecutionSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListMonitoringExecutionsRequest,
  output: ListMonitoringExecutionsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "MonitoringExecutionSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Returns list of all monitoring schedules.
 */
export const listMonitoringSchedules: {
  (
    input: ListMonitoringSchedulesRequest,
  ): effect.Effect<
    ListMonitoringSchedulesResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListMonitoringSchedulesRequest,
  ) => stream.Stream<
    ListMonitoringSchedulesResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListMonitoringSchedulesRequest,
  ) => stream.Stream<
    MonitoringScheduleSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListMonitoringSchedulesRequest,
  output: ListMonitoringSchedulesResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "MonitoringScheduleSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists notebook instance lifestyle configurations created with the CreateNotebookInstanceLifecycleConfig API.
 */
export const listNotebookInstanceLifecycleConfigs: {
  (
    input: ListNotebookInstanceLifecycleConfigsInput,
  ): effect.Effect<
    ListNotebookInstanceLifecycleConfigsOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListNotebookInstanceLifecycleConfigsInput,
  ) => stream.Stream<
    ListNotebookInstanceLifecycleConfigsOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListNotebookInstanceLifecycleConfigsInput,
  ) => stream.Stream<
    NotebookInstanceLifecycleConfigSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListNotebookInstanceLifecycleConfigsInput,
  output: ListNotebookInstanceLifecycleConfigsOutput,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "NotebookInstanceLifecycleConfigs",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Returns a list of the SageMaker AI notebook instances in the requester's account in an Amazon Web Services Region.
 */
export const listNotebookInstances: {
  (
    input: ListNotebookInstancesInput,
  ): effect.Effect<
    ListNotebookInstancesOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListNotebookInstancesInput,
  ) => stream.Stream<
    ListNotebookInstancesOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListNotebookInstancesInput,
  ) => stream.Stream<
    NotebookInstanceSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListNotebookInstancesInput,
  output: ListNotebookInstancesOutput,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "NotebookInstances",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the optimization jobs in your account and their properties.
 */
export const listOptimizationJobs: {
  (
    input: ListOptimizationJobsRequest,
  ): effect.Effect<
    ListOptimizationJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListOptimizationJobsRequest,
  ) => stream.Stream<
    ListOptimizationJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListOptimizationJobsRequest,
  ) => stream.Stream<
    OptimizationJobSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListOptimizationJobsRequest,
  output: ListOptimizationJobsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "OptimizationJobSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all of the SageMaker Partner AI Apps in an account.
 */
export const listPartnerApps: {
  (
    input: ListPartnerAppsRequest,
  ): effect.Effect<
    ListPartnerAppsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListPartnerAppsRequest,
  ) => stream.Stream<
    ListPartnerAppsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListPartnerAppsRequest,
  ) => stream.Stream<
    PartnerAppSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListPartnerAppsRequest,
  output: ListPartnerAppsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Summaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets a list of the pipeline executions.
 */
export const listPipelineExecutions: {
  (
    input: ListPipelineExecutionsRequest,
  ): effect.Effect<
    ListPipelineExecutionsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListPipelineExecutionsRequest,
  ) => stream.Stream<
    ListPipelineExecutionsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListPipelineExecutionsRequest,
  ) => stream.Stream<
    PipelineExecutionSummary,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListPipelineExecutionsRequest,
  output: ListPipelineExecutionsResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PipelineExecutionSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets a list of `PipeLineExecutionStep` objects.
 */
export const listPipelineExecutionSteps: {
  (
    input: ListPipelineExecutionStepsRequest,
  ): effect.Effect<
    ListPipelineExecutionStepsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListPipelineExecutionStepsRequest,
  ) => stream.Stream<
    ListPipelineExecutionStepsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListPipelineExecutionStepsRequest,
  ) => stream.Stream<
    PipelineExecutionStep,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListPipelineExecutionStepsRequest,
  output: ListPipelineExecutionStepsResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PipelineExecutionSteps",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets a list of parameters for a pipeline execution.
 */
export const listPipelineParametersForExecution: {
  (
    input: ListPipelineParametersForExecutionRequest,
  ): effect.Effect<
    ListPipelineParametersForExecutionResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListPipelineParametersForExecutionRequest,
  ) => stream.Stream<
    ListPipelineParametersForExecutionResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListPipelineParametersForExecutionRequest,
  ) => stream.Stream<
    Parameter,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListPipelineParametersForExecutionRequest,
  output: ListPipelineParametersForExecutionResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PipelineParameters",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets a list of pipelines.
 */
export const listPipelines: {
  (
    input: ListPipelinesRequest,
  ): effect.Effect<
    ListPipelinesResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListPipelinesRequest,
  ) => stream.Stream<
    ListPipelinesResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListPipelinesRequest,
  ) => stream.Stream<
    PipelineSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListPipelinesRequest,
  output: ListPipelinesResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PipelineSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets a list of all versions of the pipeline.
 */
export const listPipelineVersions: {
  (
    input: ListPipelineVersionsRequest,
  ): effect.Effect<
    ListPipelineVersionsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListPipelineVersionsRequest,
  ) => stream.Stream<
    ListPipelineVersionsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListPipelineVersionsRequest,
  ) => stream.Stream<
    PipelineVersionSummary,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListPipelineVersionsRequest,
  output: ListPipelineVersionsResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PipelineVersionSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists processing jobs that satisfy various filters.
 */
export const listProcessingJobs: {
  (
    input: ListProcessingJobsRequest,
  ): effect.Effect<
    ListProcessingJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListProcessingJobsRequest,
  ) => stream.Stream<
    ListProcessingJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListProcessingJobsRequest,
  ) => stream.Stream<
    ProcessingJobSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListProcessingJobsRequest,
  output: ListProcessingJobsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ProcessingJobSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets a list of the projects in an Amazon Web Services account.
 */
export const listProjects: {
  (
    input: ListProjectsInput,
  ): effect.Effect<
    ListProjectsOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListProjectsInput,
  ) => stream.Stream<
    ListProjectsOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListProjectsInput,
  ) => stream.Stream<
    unknown,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListProjectsInput,
  output: ListProjectsOutput,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists Amazon SageMaker Catalogs based on given filters and orders. The maximum number of `ResourceCatalog`s viewable is 1000.
 */
export const listResourceCatalogs: {
  (
    input: ListResourceCatalogsRequest,
  ): effect.Effect<
    ListResourceCatalogsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListResourceCatalogsRequest,
  ) => stream.Stream<
    ListResourceCatalogsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListResourceCatalogsRequest,
  ) => stream.Stream<
    ResourceCatalog,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListResourceCatalogsRequest,
  output: ListResourceCatalogsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ResourceCatalogs",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists spaces.
 */
export const listSpaces: {
  (
    input: ListSpacesRequest,
  ): effect.Effect<
    ListSpacesResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListSpacesRequest,
  ) => stream.Stream<
    ListSpacesResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListSpacesRequest,
  ) => stream.Stream<
    SpaceDetails,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListSpacesRequest,
  output: ListSpacesResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Spaces",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists devices allocated to the stage, containing detailed device information and deployment status.
 */
export const listStageDevices: {
  (
    input: ListStageDevicesRequest,
  ): effect.Effect<
    ListStageDevicesResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListStageDevicesRequest,
  ) => stream.Stream<
    ListStageDevicesResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListStageDevicesRequest,
  ) => stream.Stream<
    DeviceDeploymentSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListStageDevicesRequest,
  output: ListStageDevicesResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "DeviceDeploymentSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the Amazon SageMaker AI Studio Lifecycle Configurations in your Amazon Web Services Account.
 */
export const listStudioLifecycleConfigs: {
  (
    input: ListStudioLifecycleConfigsRequest,
  ): effect.Effect<
    ListStudioLifecycleConfigsResponse,
    ResourceInUse | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListStudioLifecycleConfigsRequest,
  ) => stream.Stream<
    ListStudioLifecycleConfigsResponse,
    ResourceInUse | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListStudioLifecycleConfigsRequest,
  ) => stream.Stream<
    StudioLifecycleConfigDetails,
    ResourceInUse | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListStudioLifecycleConfigsRequest,
  output: ListStudioLifecycleConfigsResponse,
  errors: [ResourceInUse],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "StudioLifecycleConfigs",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets a list of the work teams that you are subscribed to in the Amazon Web Services Marketplace. The list may be empty if no work team satisfies the filter specified in the `NameContains` parameter.
 */
export const listSubscribedWorkteams: {
  (
    input: ListSubscribedWorkteamsRequest,
  ): effect.Effect<
    ListSubscribedWorkteamsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListSubscribedWorkteamsRequest,
  ) => stream.Stream<
    ListSubscribedWorkteamsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListSubscribedWorkteamsRequest,
  ) => stream.Stream<
    SubscribedWorkteam,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListSubscribedWorkteamsRequest,
  output: ListSubscribedWorkteamsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SubscribedWorkteams",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Returns the tags for the specified SageMaker resource.
 */
export const listTags: {
  (
    input: ListTagsInput,
  ): effect.Effect<
    ListTagsOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListTagsInput,
  ) => stream.Stream<
    ListTagsOutput,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListTagsInput,
  ) => stream.Stream<
    Tag,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListTagsInput,
  output: ListTagsOutput,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Tags",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists training jobs.
 *
 * When `StatusEquals` and `MaxResults` are set at the same time, the `MaxResults` number of training jobs are first retrieved ignoring the `StatusEquals` parameter and then they are filtered by the `StatusEquals` parameter, which is returned as a response.
 *
 * For example, if `ListTrainingJobs` is invoked with the following parameters:
 *
 * `{ ... MaxResults: 100, StatusEquals: InProgress ... }`
 *
 * First, 100 trainings jobs with any status, including those other than `InProgress`, are selected (sorted according to the creation time, from the most current to the oldest). Next, those with a status of `InProgress` are returned.
 *
 * You can quickly test the API using the following Amazon Web Services CLI code.
 *
 * `aws sagemaker list-training-jobs --max-results 100 --status-equals InProgress`
 */
export const listTrainingJobs: {
  (
    input: ListTrainingJobsRequest,
  ): effect.Effect<
    ListTrainingJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListTrainingJobsRequest,
  ) => stream.Stream<
    ListTrainingJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListTrainingJobsRequest,
  ) => stream.Stream<
    TrainingJobSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListTrainingJobsRequest,
  output: ListTrainingJobsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TrainingJobSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets a list of TrainingJobSummary objects that describe the training jobs that a hyperparameter tuning job launched.
 */
export const listTrainingJobsForHyperParameterTuningJob: {
  (
    input: ListTrainingJobsForHyperParameterTuningJobRequest,
  ): effect.Effect<
    ListTrainingJobsForHyperParameterTuningJobResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListTrainingJobsForHyperParameterTuningJobRequest,
  ) => stream.Stream<
    ListTrainingJobsForHyperParameterTuningJobResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListTrainingJobsForHyperParameterTuningJobRequest,
  ) => stream.Stream<
    HyperParameterTrainingJobSummary,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListTrainingJobsForHyperParameterTuningJobRequest,
  output: ListTrainingJobsForHyperParameterTuningJobResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TrainingJobSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Retrieves a list of training plans for the current account.
 */
export const listTrainingPlans: {
  (
    input: ListTrainingPlansRequest,
  ): effect.Effect<
    ListTrainingPlansResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListTrainingPlansRequest,
  ) => stream.Stream<
    ListTrainingPlansResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListTrainingPlansRequest,
  ) => stream.Stream<
    TrainingPlanSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListTrainingPlansRequest,
  output: ListTrainingPlansResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TrainingPlanSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists transform jobs.
 */
export const listTransformJobs: {
  (
    input: ListTransformJobsRequest,
  ): effect.Effect<
    ListTransformJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListTransformJobsRequest,
  ) => stream.Stream<
    ListTransformJobsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListTransformJobsRequest,
  ) => stream.Stream<
    TransformJobSummary,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListTransformJobsRequest,
  output: ListTransformJobsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TransformJobSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the trial components in your account. You can sort the list by trial component name or creation time. You can filter the list to show only components that were created in a specific time range. You can also filter on one of the following:
 *
 * - `ExperimentName`
 *
 * - `SourceArn`
 *
 * - `TrialName`
 */
export const listTrialComponents: {
  (
    input: ListTrialComponentsRequest,
  ): effect.Effect<
    ListTrialComponentsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListTrialComponentsRequest,
  ) => stream.Stream<
    ListTrialComponentsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListTrialComponentsRequest,
  ) => stream.Stream<
    TrialComponentSummary,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListTrialComponentsRequest,
  output: ListTrialComponentsResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TrialComponentSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the trials in your account. Specify an experiment name to limit the list to the trials that are part of that experiment. Specify a trial component name to limit the list to the trials that associated with that trial component. The list can be filtered to show only trials that were created in a specific time range. The list can be sorted by trial name or creation time.
 */
export const listTrials: {
  (
    input: ListTrialsRequest,
  ): effect.Effect<
    ListTrialsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListTrialsRequest,
  ) => stream.Stream<
    ListTrialsResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListTrialsRequest,
  ) => stream.Stream<
    TrialSummary,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListTrialsRequest,
  output: ListTrialsResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TrialSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all UltraServers that are part of a specified reserved capacity.
 */
export const listUltraServersByReservedCapacity: {
  (
    input: ListUltraServersByReservedCapacityRequest,
  ): effect.Effect<
    ListUltraServersByReservedCapacityResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListUltraServersByReservedCapacityRequest,
  ) => stream.Stream<
    ListUltraServersByReservedCapacityResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListUltraServersByReservedCapacityRequest,
  ) => stream.Stream<
    UltraServer,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListUltraServersByReservedCapacityRequest,
  output: ListUltraServersByReservedCapacityResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "UltraServers",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists user profiles.
 */
export const listUserProfiles: {
  (
    input: ListUserProfilesRequest,
  ): effect.Effect<
    ListUserProfilesResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListUserProfilesRequest,
  ) => stream.Stream<
    ListUserProfilesResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListUserProfilesRequest,
  ) => stream.Stream<
    UserProfileDetails,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListUserProfilesRequest,
  output: ListUserProfilesResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "UserProfiles",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Use this operation to list all private and vendor workforces in an Amazon Web Services Region. Note that you can only have one private workforce per Amazon Web Services Region.
 */
export const listWorkforces: {
  (
    input: ListWorkforcesRequest,
  ): effect.Effect<
    ListWorkforcesResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListWorkforcesRequest,
  ) => stream.Stream<
    ListWorkforcesResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListWorkforcesRequest,
  ) => stream.Stream<
    Workforce,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListWorkforcesRequest,
  output: ListWorkforcesResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Workforces",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets a list of private work teams that you have defined in a region. The list may be empty if no work team satisfies the filter specified in the `NameContains` parameter.
 */
export const listWorkteams: {
  (
    input: ListWorkteamsRequest,
  ): effect.Effect<
    ListWorkteamsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListWorkteamsRequest,
  ) => stream.Stream<
    ListWorkteamsResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListWorkteamsRequest,
  ) => stream.Stream<
    Workteam,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListWorkteamsRequest,
  output: ListWorkteamsResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Workteams",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Adds a resouce policy to control access to a model group. For information about resoure policies, see Identity-based policies and resource-based policies in the *Amazon Web Services Identity and Access Management User Guide.*.
 */
export const putModelPackageGroupPolicy: (
  input: PutModelPackageGroupPolicyInput,
) => effect.Effect<
  PutModelPackageGroupPolicyOutput,
  ConflictException | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: PutModelPackageGroupPolicyInput,
  output: PutModelPackageGroupPolicyOutput,
  errors: [ConflictException],
}));
/**
 * Use this action to inspect your lineage and discover relationships between entities. For more information, see Querying Lineage Entities in the *Amazon SageMaker Developer Guide*.
 */
export const queryLineage: {
  (
    input: QueryLineageRequest,
  ): effect.Effect<
    QueryLineageResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: QueryLineageRequest,
  ) => stream.Stream<
    QueryLineageResponse,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: QueryLineageRequest,
  ) => stream.Stream<
    unknown,
    ResourceNotFound | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: QueryLineageRequest,
  output: QueryLineageResponse,
  errors: [ResourceNotFound],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Register devices.
 */
export const registerDevices: (
  input: RegisterDevicesRequest,
) => effect.Effect<
  RegisterDevicesResponse,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RegisterDevicesRequest,
  output: RegisterDevicesResponse,
  errors: [ResourceLimitExceeded],
}));
/**
 * Renders the UI template so that you can preview the worker's experience.
 */
export const renderUiTemplate: (
  input: RenderUiTemplateRequest,
) => effect.Effect<
  RenderUiTemplateResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RenderUiTemplateRequest,
  output: RenderUiTemplateResponse,
  errors: [ResourceNotFound],
}));
/**
 * Retry the execution of the pipeline.
 */
export const retryPipelineExecution: (
  input: RetryPipelineExecutionRequest,
) => effect.Effect<
  RetryPipelineExecutionResponse,
  ConflictException | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RetryPipelineExecutionRequest,
  output: RetryPipelineExecutionResponse,
  errors: [ConflictException, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Finds SageMaker resources that match a search query. Matching resources are returned as a list of `SearchRecord` objects in the response. You can sort the search results by any resource property in a ascending or descending order.
 *
 * You can query against the following value types: numeric, text, Boolean, and timestamp.
 *
 * The Search API may provide access to otherwise restricted data. See Amazon SageMaker API Permissions: Actions, Permissions, and Resources Reference for more information.
 */
export const search: {
  (
    input: SearchRequest,
  ): effect.Effect<
    SearchResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchRequest,
  ) => stream.Stream<
    SearchResponse,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchRequest,
  ) => stream.Stream<
    SearchRecord,
    CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchRequest,
  output: SearchResponse,
  errors: [],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Results",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches for available training plan offerings based on specified criteria.
 *
 * - Users search for available plan offerings based on their requirements (e.g., instance type, count, start time, duration).
 *
 * - And then, they create a plan that best matches their needs using the ID of the plan offering they want to use.
 *
 * For more information about how to reserve GPU capacity for your SageMaker training jobs or SageMaker HyperPod clusters using Amazon SageMaker Training Plan , see ` CreateTrainingPlan `.
 */
export const searchTrainingPlanOfferings: (
  input: SearchTrainingPlanOfferingsRequest,
) => effect.Effect<
  SearchTrainingPlanOfferingsResponse,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SearchTrainingPlanOfferingsRequest,
  output: SearchTrainingPlanOfferingsResponse,
  errors: [ResourceLimitExceeded],
}));
/**
 * Notifies the pipeline that the execution of a callback step failed, along with a message describing why. When a callback step is run, the pipeline generates a callback token and includes the token in a message sent to Amazon Simple Queue Service (Amazon SQS).
 */
export const sendPipelineExecutionStepFailure: (
  input: SendPipelineExecutionStepFailureRequest,
) => effect.Effect<
  SendPipelineExecutionStepFailureResponse,
  ConflictException | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SendPipelineExecutionStepFailureRequest,
  output: SendPipelineExecutionStepFailureResponse,
  errors: [ConflictException, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Notifies the pipeline that the execution of a callback step succeeded and provides a list of the step's output parameters. When a callback step is run, the pipeline generates a callback token and includes the token in a message sent to Amazon Simple Queue Service (Amazon SQS).
 */
export const sendPipelineExecutionStepSuccess: (
  input: SendPipelineExecutionStepSuccessRequest,
) => effect.Effect<
  SendPipelineExecutionStepSuccessResponse,
  ConflictException | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SendPipelineExecutionStepSuccessRequest,
  output: SendPipelineExecutionStepSuccessResponse,
  errors: [ConflictException, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Starts a stage in an edge deployment plan.
 */
export const startEdgeDeploymentStage: (
  input: StartEdgeDeploymentStageRequest,
) => effect.Effect<
  StartEdgeDeploymentStageResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartEdgeDeploymentStageRequest,
  output: StartEdgeDeploymentStageResponse,
  errors: [],
}));
/**
 * Starts an inference experiment.
 */
export const startInferenceExperiment: (
  input: StartInferenceExperimentRequest,
) => effect.Effect<
  StartInferenceExperimentResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartInferenceExperimentRequest,
  output: StartInferenceExperimentResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Programmatically start an MLflow Tracking Server.
 */
export const startMlflowTrackingServer: (
  input: StartMlflowTrackingServerRequest,
) => effect.Effect<
  StartMlflowTrackingServerResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartMlflowTrackingServerRequest,
  output: StartMlflowTrackingServerResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Starts a previously stopped monitoring schedule.
 *
 * By default, when you successfully create a new schedule, the status of a monitoring schedule is `scheduled`.
 */
export const startMonitoringSchedule: (
  input: StartMonitoringScheduleRequest,
) => effect.Effect<
  StartMonitoringScheduleResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartMonitoringScheduleRequest,
  output: StartMonitoringScheduleResponse,
  errors: [ResourceNotFound],
}));
/**
 * Launches an ML compute instance with the latest version of the libraries and attaches your ML storage volume. After configuring the notebook instance, SageMaker AI sets the notebook instance status to `InService`. A notebook instance's status must be `InService` before you can connect to your Jupyter notebook.
 */
export const startNotebookInstance: (
  input: StartNotebookInstanceInput,
) => effect.Effect<
  StartNotebookInstanceResponse,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartNotebookInstanceInput,
  output: StartNotebookInstanceResponse,
  errors: [ResourceLimitExceeded],
}));
/**
 * Starts a pipeline execution.
 */
export const startPipelineExecution: (
  input: StartPipelineExecutionRequest,
) => effect.Effect<
  StartPipelineExecutionResponse,
  ConflictException | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartPipelineExecutionRequest,
  output: StartPipelineExecutionResponse,
  errors: [ConflictException, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Initiates a remote connection session between a local integrated development environments (IDEs) and a remote SageMaker space.
 */
export const startSession: (
  input: StartSessionRequest,
) => effect.Effect<
  StartSessionResponse,
  ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartSessionRequest,
  output: StartSessionResponse,
  errors: [ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * A method for forcing a running job to shut down.
 */
export const stopAutoMLJob: (
  input: StopAutoMLJobRequest,
) => effect.Effect<
  StopAutoMLJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopAutoMLJobRequest,
  output: StopAutoMLJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Stops a model compilation job.
 *
 * To stop a job, Amazon SageMaker AI sends the algorithm the SIGTERM signal. This gracefully shuts the job down. If the job hasn't stopped, it sends the SIGKILL signal.
 *
 * When it receives a `StopCompilationJob` request, Amazon SageMaker AI changes the `CompilationJobStatus` of the job to `Stopping`. After Amazon SageMaker stops the job, it sets the `CompilationJobStatus` to `Stopped`.
 */
export const stopCompilationJob: (
  input: StopCompilationJobRequest,
) => effect.Effect<
  StopCompilationJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopCompilationJobRequest,
  output: StopCompilationJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Stops a stage in an edge deployment plan.
 */
export const stopEdgeDeploymentStage: (
  input: StopEdgeDeploymentStageRequest,
) => effect.Effect<
  StopEdgeDeploymentStageResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopEdgeDeploymentStageRequest,
  output: StopEdgeDeploymentStageResponse,
  errors: [],
}));
/**
 * Request to stop an edge packaging job.
 */
export const stopEdgePackagingJob: (
  input: StopEdgePackagingJobRequest,
) => effect.Effect<
  StopEdgePackagingJobResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopEdgePackagingJobRequest,
  output: StopEdgePackagingJobResponse,
  errors: [],
}));
/**
 * Stops a running hyperparameter tuning job and all running training jobs that the tuning job launched.
 *
 * All model artifacts output from the training jobs are stored in Amazon Simple Storage Service (Amazon S3). All data that the training jobs write to Amazon CloudWatch Logs are still available in CloudWatch. After the tuning job moves to the `Stopped` state, it releases all reserved resources for the tuning job.
 */
export const stopHyperParameterTuningJob: (
  input: StopHyperParameterTuningJobRequest,
) => effect.Effect<
  StopHyperParameterTuningJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopHyperParameterTuningJobRequest,
  output: StopHyperParameterTuningJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Stops an inference experiment.
 */
export const stopInferenceExperiment: (
  input: StopInferenceExperimentRequest,
) => effect.Effect<
  StopInferenceExperimentResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopInferenceExperimentRequest,
  output: StopInferenceExperimentResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Stops an Inference Recommender job.
 */
export const stopInferenceRecommendationsJob: (
  input: StopInferenceRecommendationsJobRequest,
) => effect.Effect<
  StopInferenceRecommendationsJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopInferenceRecommendationsJobRequest,
  output: StopInferenceRecommendationsJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Stops a running labeling job. A job that is stopped cannot be restarted. Any results obtained before the job is stopped are placed in the Amazon S3 output bucket.
 */
export const stopLabelingJob: (
  input: StopLabelingJobRequest,
) => effect.Effect<
  StopLabelingJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopLabelingJobRequest,
  output: StopLabelingJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Programmatically stop an MLflow Tracking Server.
 */
export const stopMlflowTrackingServer: (
  input: StopMlflowTrackingServerRequest,
) => effect.Effect<
  StopMlflowTrackingServerResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopMlflowTrackingServerRequest,
  output: StopMlflowTrackingServerResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Stops a previously started monitoring schedule.
 */
export const stopMonitoringSchedule: (
  input: StopMonitoringScheduleRequest,
) => effect.Effect<
  StopMonitoringScheduleResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopMonitoringScheduleRequest,
  output: StopMonitoringScheduleResponse,
  errors: [ResourceNotFound],
}));
/**
 * Terminates the ML compute instance. Before terminating the instance, SageMaker AI disconnects the ML storage volume from it. SageMaker AI preserves the ML storage volume. SageMaker AI stops charging you for the ML compute instance when you call `StopNotebookInstance`.
 *
 * To access data on the ML storage volume for a notebook instance that has been terminated, call the `StartNotebookInstance` API. `StartNotebookInstance` launches another ML compute instance, configures it, and attaches the preserved ML storage volume so you can continue your work.
 */
export const stopNotebookInstance: (
  input: StopNotebookInstanceInput,
) => effect.Effect<
  StopNotebookInstanceResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopNotebookInstanceInput,
  output: StopNotebookInstanceResponse,
  errors: [],
}));
/**
 * Ends a running inference optimization job.
 */
export const stopOptimizationJob: (
  input: StopOptimizationJobRequest,
) => effect.Effect<
  StopOptimizationJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopOptimizationJobRequest,
  output: StopOptimizationJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Stops a pipeline execution.
 *
 * **Callback Step**
 *
 * A pipeline execution won't stop while a callback step is running. When you call `StopPipelineExecution` on a pipeline execution with a running callback step, SageMaker Pipelines sends an additional Amazon SQS message to the specified SQS queue. The body of the SQS message contains a "Status" field which is set to "Stopping".
 *
 * You should add logic to your Amazon SQS message consumer to take any needed action (for example, resource cleanup) upon receipt of the message followed by a call to `SendPipelineExecutionStepSuccess` or `SendPipelineExecutionStepFailure`.
 *
 * Only when SageMaker Pipelines receives one of these calls will it stop the pipeline execution.
 *
 * **Lambda Step**
 *
 * A pipeline execution can't be stopped while a lambda step is running because the Lambda function invoked by the lambda step can't be stopped. If you attempt to stop the execution while the Lambda function is running, the pipeline waits for the Lambda function to finish or until the timeout is hit, whichever occurs first, and then stops. If the Lambda function finishes, the pipeline execution status is `Stopped`. If the timeout is hit the pipeline execution status is `Failed`.
 */
export const stopPipelineExecution: (
  input: StopPipelineExecutionRequest,
) => effect.Effect<
  StopPipelineExecutionResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopPipelineExecutionRequest,
  output: StopPipelineExecutionResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Stops a processing job.
 */
export const stopProcessingJob: (
  input: StopProcessingJobRequest,
) => effect.Effect<
  StopProcessingJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopProcessingJobRequest,
  output: StopProcessingJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Stops a training job. To stop a job, SageMaker sends the algorithm the `SIGTERM` signal, which delays job termination for 120 seconds. Algorithms might use this 120-second window to save the model artifacts, so the results of the training is not lost.
 *
 * When it receives a `StopTrainingJob` request, SageMaker changes the status of the job to `Stopping`. After SageMaker stops the job, it sets the status to `Stopped`.
 */
export const stopTrainingJob: (
  input: StopTrainingJobRequest,
) => effect.Effect<
  StopTrainingJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopTrainingJobRequest,
  output: StopTrainingJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Stops a batch transform job.
 *
 * When Amazon SageMaker receives a `StopTransformJob` request, the status of the job changes to `Stopping`. After Amazon SageMaker stops the job, the status is set to `Stopped`. When you stop a batch transform job before it is completed, Amazon SageMaker doesn't store the job's output in Amazon S3.
 */
export const stopTransformJob: (
  input: StopTransformJobRequest,
) => effect.Effect<
  StopTransformJobResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopTransformJobRequest,
  output: StopTransformJobResponse,
  errors: [ResourceNotFound],
}));
/**
 * Updates an action.
 */
export const updateAction: (
  input: UpdateActionRequest,
) => effect.Effect<
  UpdateActionResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateActionRequest,
  output: UpdateActionResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Updates the properties of an AppImageConfig.
 */
export const updateAppImageConfig: (
  input: UpdateAppImageConfigRequest,
) => effect.Effect<
  UpdateAppImageConfigResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateAppImageConfigRequest,
  output: UpdateAppImageConfigResponse,
  errors: [ResourceNotFound],
}));
/**
 * Updates an artifact.
 */
export const updateArtifact: (
  input: UpdateArtifactRequest,
) => effect.Effect<
  UpdateArtifactResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateArtifactRequest,
  output: UpdateArtifactResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Updates a SageMaker HyperPod cluster.
 */
export const updateCluster: (
  input: UpdateClusterRequest,
) => effect.Effect<
  UpdateClusterResponse,
  ConflictException | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateClusterRequest,
  output: UpdateClusterResponse,
  errors: [ConflictException, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Update the cluster policy configuration.
 */
export const updateClusterSchedulerConfig: (
  input: UpdateClusterSchedulerConfigRequest,
) => effect.Effect<
  UpdateClusterSchedulerConfigResponse,
  ConflictException | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateClusterSchedulerConfigRequest,
  output: UpdateClusterSchedulerConfigResponse,
  errors: [ConflictException, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Updates the platform software of a SageMaker HyperPod cluster for security patching. To learn how to use this API, see Update the SageMaker HyperPod platform software of a cluster.
 *
 * The `UpgradeClusterSoftware` API call may impact your SageMaker HyperPod cluster uptime and availability. Plan accordingly to mitigate potential disruptions to your workloads.
 */
export const updateClusterSoftware: (
  input: UpdateClusterSoftwareRequest,
) => effect.Effect<
  UpdateClusterSoftwareResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateClusterSoftwareRequest,
  output: UpdateClusterSoftwareResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Updates the specified Git repository with the specified values.
 */
export const updateCodeRepository: (
  input: UpdateCodeRepositoryInput,
) => effect.Effect<
  UpdateCodeRepositoryOutput,
  ConflictException | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateCodeRepositoryInput,
  output: UpdateCodeRepositoryOutput,
  errors: [ConflictException],
}));
/**
 * Update the compute allocation definition.
 */
export const updateComputeQuota: (
  input: UpdateComputeQuotaRequest,
) => effect.Effect<
  UpdateComputeQuotaResponse,
  ConflictException | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateComputeQuotaRequest,
  output: UpdateComputeQuotaResponse,
  errors: [ConflictException, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Updates a context.
 */
export const updateContext: (
  input: UpdateContextRequest,
) => effect.Effect<
  UpdateContextResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContextRequest,
  output: UpdateContextResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Updates a fleet of devices.
 */
export const updateDeviceFleet: (
  input: UpdateDeviceFleetRequest,
) => effect.Effect<
  UpdateDeviceFleetResponse,
  ResourceInUse | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDeviceFleetRequest,
  output: UpdateDeviceFleetResponse,
  errors: [ResourceInUse],
}));
/**
 * Updates one or more devices in a fleet.
 */
export const updateDevices: (
  input: UpdateDevicesRequest,
) => effect.Effect<
  UpdateDevicesResponse,
  CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDevicesRequest,
  output: UpdateDevicesResponse,
  errors: [],
}));
/**
 * Updates the default settings for new user profiles in the domain.
 */
export const updateDomain: (
  input: UpdateDomainRequest,
) => effect.Effect<
  UpdateDomainResponse,
  ResourceInUse | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDomainRequest,
  output: UpdateDomainResponse,
  errors: [ResourceInUse, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Deploys the `EndpointConfig` specified in the request to a new fleet of instances. SageMaker shifts endpoint traffic to the new instances with the updated endpoint configuration and then deletes the old instances using the previous `EndpointConfig` (there is no availability loss). For more information about how to control the update and traffic shifting process, see Update models in production.
 *
 * When SageMaker receives the request, it sets the endpoint status to `Updating`. After updating the endpoint, it sets the status to `InService`. To check the status of an endpoint, use the DescribeEndpoint API.
 *
 * You must not delete an `EndpointConfig` in use by an endpoint that is live or while the `UpdateEndpoint` or `CreateEndpoint` operations are being performed on the endpoint. To update an endpoint, you must create a new `EndpointConfig`.
 *
 * If you delete the `EndpointConfig` of an endpoint that is active or being created or updated you may lose visibility into the instance type the endpoint is using. The endpoint must be deleted in order to stop incurring charges.
 */
export const updateEndpoint: (
  input: UpdateEndpointInput,
) => effect.Effect<
  UpdateEndpointOutput,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateEndpointInput,
  output: UpdateEndpointOutput,
  errors: [ResourceLimitExceeded],
}));
/**
 * Updates variant weight of one or more variants associated with an existing endpoint, or capacity of one variant associated with an existing endpoint. When it receives the request, SageMaker sets the endpoint status to `Updating`. After updating the endpoint, it sets the status to `InService`. To check the status of an endpoint, use the DescribeEndpoint API.
 */
export const updateEndpointWeightsAndCapacities: (
  input: UpdateEndpointWeightsAndCapacitiesInput,
) => effect.Effect<
  UpdateEndpointWeightsAndCapacitiesOutput,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateEndpointWeightsAndCapacitiesInput,
  output: UpdateEndpointWeightsAndCapacitiesOutput,
  errors: [ResourceLimitExceeded],
}));
/**
 * Adds, updates, or removes the description of an experiment. Updates the display name of an experiment.
 */
export const updateExperiment: (
  input: UpdateExperimentRequest,
) => effect.Effect<
  UpdateExperimentResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateExperimentRequest,
  output: UpdateExperimentResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Updates the feature group by either adding features or updating the online store configuration. Use one of the following request parameters at a time while using the `UpdateFeatureGroup` API.
 *
 * You can add features for your feature group using the `FeatureAdditions` request parameter. Features cannot be removed from a feature group.
 *
 * You can update the online store configuration by using the `OnlineStoreConfig` request parameter. If a `TtlDuration` is specified, the default `TtlDuration` applies for all records added to the feature group *after the feature group is updated*. If a record level `TtlDuration` exists from using the `PutRecord` API, the record level `TtlDuration` applies to that record instead of the default `TtlDuration`. To remove the default `TtlDuration` from an existing feature group, use the `UpdateFeatureGroup` API and set the `TtlDuration` `Unit` and `Value` to `null`.
 */
export const updateFeatureGroup: (
  input: UpdateFeatureGroupRequest,
) => effect.Effect<
  UpdateFeatureGroupResponse,
  ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateFeatureGroupRequest,
  output: UpdateFeatureGroupResponse,
  errors: [ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Updates the description and parameters of the feature group.
 */
export const updateFeatureMetadata: (
  input: UpdateFeatureMetadataRequest,
) => effect.Effect<
  UpdateFeatureMetadataResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateFeatureMetadataRequest,
  output: UpdateFeatureMetadataResponse,
  errors: [ResourceNotFound],
}));
/**
 * Update a hub.
 */
export const updateHub: (
  input: UpdateHubRequest,
) => effect.Effect<
  UpdateHubResponse,
  ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateHubRequest,
  output: UpdateHubResponse,
  errors: [ResourceNotFound],
}));
/**
 * Updates SageMaker hub content (either a `Model` or `Notebook` resource).
 *
 * You can update the metadata that describes the resource. In addition to the required request fields, specify at least one of the following fields to update:
 *
 * - `HubContentDescription`
 *
 * - `HubContentDisplayName`
 *
 * - `HubContentMarkdown`
 *
 * - `HubContentSearchKeywords`
 *
 * - `SupportStatus`
 *
 * For more information about hubs, see Private curated hubs for foundation model access control in JumpStart.
 *
 * If you want to update a `ModelReference` resource in your hub, use the `UpdateHubContentResource` API instead.
 */
export const updateHubContent: (
  input: UpdateHubContentRequest,
) => effect.Effect<
  UpdateHubContentResponse,
  ResourceInUse | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateHubContentRequest,
  output: UpdateHubContentResponse,
  errors: [ResourceInUse, ResourceNotFound],
}));
/**
 * Updates the contents of a SageMaker hub for a `ModelReference` resource. A `ModelReference` allows you to access public SageMaker JumpStart models from within your private hub.
 *
 * When using this API, you can update the `MinVersion` field for additional flexibility in the model version. You shouldn't update any additional fields when using this API, because the metadata in your private hub should match the public JumpStart model's metadata.
 *
 * If you want to update a `Model` or `Notebook` resource in your hub, use the `UpdateHubContent` API instead.
 *
 * For more information about adding model references to your hub, see Add models to a private hub.
 */
export const updateHubContentReference: (
  input: UpdateHubContentReferenceRequest,
) => effect.Effect<
  UpdateHubContentReferenceResponse,
  ResourceInUse | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateHubContentReferenceRequest,
  output: UpdateHubContentReferenceResponse,
  errors: [ResourceInUse, ResourceNotFound],
}));
/**
 * Updates the properties of a SageMaker AI image. To change the image's tags, use the AddTags and DeleteTags APIs.
 */
export const updateImage: (
  input: UpdateImageRequest,
) => effect.Effect<
  UpdateImageResponse,
  ResourceInUse | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateImageRequest,
  output: UpdateImageResponse,
  errors: [ResourceInUse, ResourceNotFound],
}));
/**
 * Updates the properties of a SageMaker AI image version.
 */
export const updateImageVersion: (
  input: UpdateImageVersionRequest,
) => effect.Effect<
  UpdateImageVersionResponse,
  ResourceInUse | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateImageVersionRequest,
  output: UpdateImageVersionResponse,
  errors: [ResourceInUse, ResourceNotFound],
}));
/**
 * Updates an inference component.
 */
export const updateInferenceComponent: (
  input: UpdateInferenceComponentInput,
) => effect.Effect<
  UpdateInferenceComponentOutput,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateInferenceComponentInput,
  output: UpdateInferenceComponentOutput,
  errors: [ResourceLimitExceeded],
}));
/**
 * Runtime settings for a model that is deployed with an inference component.
 */
export const updateInferenceComponentRuntimeConfig: (
  input: UpdateInferenceComponentRuntimeConfigInput,
) => effect.Effect<
  UpdateInferenceComponentRuntimeConfigOutput,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateInferenceComponentRuntimeConfigInput,
  output: UpdateInferenceComponentRuntimeConfigOutput,
  errors: [ResourceLimitExceeded],
}));
/**
 * Updates an inference experiment that you created. The status of the inference experiment has to be either `Created`, `Running`. For more information on the status of an inference experiment, see DescribeInferenceExperiment.
 */
export const updateInferenceExperiment: (
  input: UpdateInferenceExperimentRequest,
) => effect.Effect<
  UpdateInferenceExperimentResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateInferenceExperimentRequest,
  output: UpdateInferenceExperimentResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Updates an MLflow App.
 */
export const updateMlflowApp: (
  input: UpdateMlflowAppRequest,
) => effect.Effect<
  UpdateMlflowAppResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateMlflowAppRequest,
  output: UpdateMlflowAppResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Updates properties of an existing MLflow Tracking Server.
 */
export const updateMlflowTrackingServer: (
  input: UpdateMlflowTrackingServerRequest,
) => effect.Effect<
  UpdateMlflowTrackingServerResponse,
  ConflictException | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateMlflowTrackingServerRequest,
  output: UpdateMlflowTrackingServerResponse,
  errors: [ConflictException, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Update an Amazon SageMaker Model Card.
 *
 * You cannot update both model card content and model card status in a single call.
 */
export const updateModelCard: (
  input: UpdateModelCardRequest,
) => effect.Effect<
  UpdateModelCardResponse,
  ConflictException | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateModelCardRequest,
  output: UpdateModelCardResponse,
  errors: [ConflictException, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Updates a versioned model.
 */
export const updateModelPackage: (
  input: UpdateModelPackageInput,
) => effect.Effect<
  UpdateModelPackageOutput,
  ConflictException | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateModelPackageInput,
  output: UpdateModelPackageOutput,
  errors: [ConflictException],
}));
/**
 * Update the parameters of a model monitor alert.
 */
export const updateMonitoringAlert: (
  input: UpdateMonitoringAlertRequest,
) => effect.Effect<
  UpdateMonitoringAlertResponse,
  ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateMonitoringAlertRequest,
  output: UpdateMonitoringAlertResponse,
  errors: [ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Updates a previously created schedule.
 */
export const updateMonitoringSchedule: (
  input: UpdateMonitoringScheduleRequest,
) => effect.Effect<
  UpdateMonitoringScheduleResponse,
  ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateMonitoringScheduleRequest,
  output: UpdateMonitoringScheduleResponse,
  errors: [ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Updates a notebook instance. NotebookInstance updates include upgrading or downgrading the ML compute instance used for your notebook instance to accommodate changes in your workload requirements.
 */
export const updateNotebookInstance: (
  input: UpdateNotebookInstanceInput,
) => effect.Effect<
  UpdateNotebookInstanceOutput,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateNotebookInstanceInput,
  output: UpdateNotebookInstanceOutput,
  errors: [ResourceLimitExceeded],
}));
/**
 * Updates a notebook instance lifecycle configuration created with the CreateNotebookInstanceLifecycleConfig API.
 */
export const updateNotebookInstanceLifecycleConfig: (
  input: UpdateNotebookInstanceLifecycleConfigInput,
) => effect.Effect<
  UpdateNotebookInstanceLifecycleConfigOutput,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateNotebookInstanceLifecycleConfigInput,
  output: UpdateNotebookInstanceLifecycleConfigOutput,
  errors: [ResourceLimitExceeded],
}));
/**
 * Updates all of the SageMaker Partner AI Apps in an account.
 */
export const updatePartnerApp: (
  input: UpdatePartnerAppRequest,
) => effect.Effect<
  UpdatePartnerAppResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdatePartnerAppRequest,
  output: UpdatePartnerAppResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Updates a pipeline.
 */
export const updatePipeline: (
  input: UpdatePipelineRequest,
) => effect.Effect<
  UpdatePipelineResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdatePipelineRequest,
  output: UpdatePipelineResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Updates a pipeline execution.
 */
export const updatePipelineExecution: (
  input: UpdatePipelineExecutionRequest,
) => effect.Effect<
  UpdatePipelineExecutionResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdatePipelineExecutionRequest,
  output: UpdatePipelineExecutionResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Updates a pipeline version.
 */
export const updatePipelineVersion: (
  input: UpdatePipelineVersionRequest,
) => effect.Effect<
  UpdatePipelineVersionResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdatePipelineVersionRequest,
  output: UpdatePipelineVersionResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Updates a machine learning (ML) project that is created from a template that sets up an ML pipeline from training to deploying an approved model.
 *
 * You must not update a project that is in use. If you update the `ServiceCatalogProvisioningUpdateDetails` of a project that is active or being created, or updated, you may lose resources already created by the project.
 */
export const updateProject: (
  input: UpdateProjectInput,
) => effect.Effect<
  UpdateProjectOutput,
  ConflictException | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateProjectInput,
  output: UpdateProjectOutput,
  errors: [ConflictException],
}));
/**
 * Updates the settings of a space.
 *
 * You can't edit the app type of a space in the `SpaceSettings`.
 */
export const updateSpace: (
  input: UpdateSpaceRequest,
) => effect.Effect<
  UpdateSpaceResponse,
  ResourceInUse | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateSpaceRequest,
  output: UpdateSpaceResponse,
  errors: [ResourceInUse, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Update a model training job to request a new Debugger profiling configuration or to change warm pool retention length.
 */
export const updateTrainingJob: (
  input: UpdateTrainingJobRequest,
) => effect.Effect<
  UpdateTrainingJobResponse,
  ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateTrainingJobRequest,
  output: UpdateTrainingJobResponse,
  errors: [ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Updates the display name of a trial.
 */
export const updateTrial: (
  input: UpdateTrialRequest,
) => effect.Effect<
  UpdateTrialResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateTrialRequest,
  output: UpdateTrialResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Updates one or more properties of a trial component.
 */
export const updateTrialComponent: (
  input: UpdateTrialComponentRequest,
) => effect.Effect<
  UpdateTrialComponentResponse,
  ConflictException | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateTrialComponentRequest,
  output: UpdateTrialComponentResponse,
  errors: [ConflictException, ResourceNotFound],
}));
/**
 * Updates a user profile.
 */
export const updateUserProfile: (
  input: UpdateUserProfileRequest,
) => effect.Effect<
  UpdateUserProfileResponse,
  ResourceInUse | ResourceLimitExceeded | ResourceNotFound | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserProfileRequest,
  output: UpdateUserProfileResponse,
  errors: [ResourceInUse, ResourceLimitExceeded, ResourceNotFound],
}));
/**
 * Use this operation to update your workforce. You can use this operation to require that workers use specific IP addresses to work on tasks and to update your OpenID Connect (OIDC) Identity Provider (IdP) workforce configuration.
 *
 * The worker portal is now supported in VPC and public internet.
 *
 * Use `SourceIpConfig` to restrict worker access to tasks to a specific range of IP addresses. You specify allowed IP addresses by creating a list of up to ten CIDRs. By default, a workforce isn't restricted to specific IP addresses. If you specify a range of IP addresses, workers who attempt to access tasks using any IP address outside the specified range are denied and get a `Not Found` error message on the worker portal.
 *
 * To restrict public internet access for all workers, configure the `SourceIpConfig` CIDR value. For example, when using `SourceIpConfig` with an `IpAddressType` of `IPv4`, you can restrict access to the IPv4 CIDR block "10.0.0.0/16". When using an `IpAddressType` of `dualstack`, you can specify both the IPv4 and IPv6 CIDR blocks, such as "10.0.0.0/16" for IPv4 only, "2001:db8:1234:1a00::/56" for IPv6 only, or "10.0.0.0/16" and "2001:db8:1234:1a00::/56" for dual stack.
 *
 * Amazon SageMaker does not support Source Ip restriction for worker portals in VPC.
 *
 * Use `OidcConfig` to update the configuration of a workforce created using your own OIDC IdP.
 *
 * You can only update your OIDC IdP configuration when there are no work teams associated with your workforce. You can delete work teams using the DeleteWorkteam operation.
 *
 * After restricting access to a range of IP addresses or updating your OIDC IdP configuration with this operation, you can view details about your update workforce using the DescribeWorkforce operation.
 *
 * This operation only applies to private workforces.
 */
export const updateWorkforce: (
  input: UpdateWorkforceRequest,
) => effect.Effect<
  UpdateWorkforceResponse,
  ConflictException | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateWorkforceRequest,
  output: UpdateWorkforceResponse,
  errors: [ConflictException],
}));
/**
 * Updates an existing work team with new member definitions or description.
 */
export const updateWorkteam: (
  input: UpdateWorkteamRequest,
) => effect.Effect<
  UpdateWorkteamResponse,
  ResourceLimitExceeded | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateWorkteamRequest,
  output: UpdateWorkteamResponse,
  errors: [ResourceLimitExceeded],
}));
