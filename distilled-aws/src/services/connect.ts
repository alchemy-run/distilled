import * as HttpClient from "effect/unstable/http/HttpClient";
import * as effect from "effect/Effect";
import * as redacted from "effect/Redacted";
import * as S from "effect/Schema";
import * as stream from "effect/Stream";
import * as API from "../client/api.ts";
import * as T from "../traits.ts";
import * as C from "../category.ts";
import type { Credentials as Creds } from "../credentials.ts";
import type { CommonErrors } from "../errors.ts";
import type { Region } from "../region.ts";
import { SensitiveString, SensitiveBlob } from "../sensitive.ts";
const svc = T.AwsApiService({
  sdkId: "Connect",
  serviceShapeName: "AmazonConnectService",
});
const auth = T.AwsAuthSigv4({ name: "connect" });
const ver = T.ServiceVersion("2017-08-08");
const proto = T.AwsProtocolsRestJson1();
const rules = T.EndpointResolver((p, _) => {
  const { Region, UseDualStack = false, UseFIPS = false, Endpoint } = p;
  const e = (u: unknown, p = {}, h = {}): T.EndpointResolverResult => ({
    type: "endpoint" as const,
    endpoint: { url: u as string, properties: p, headers: h },
  });
  const err = (m: unknown): T.EndpointResolverResult => ({
    type: "error" as const,
    message: m as string,
  });
  if (Endpoint != null) {
    if (UseFIPS === true) {
      return err(
        "Invalid Configuration: FIPS and custom endpoint are not supported",
      );
    }
    if (UseDualStack === true) {
      return err(
        "Invalid Configuration: Dualstack and custom endpoint are not supported",
      );
    }
    return e(Endpoint);
  }
  if (Region != null) {
    {
      const PartitionResult = _.partition(Region);
      if (PartitionResult != null && PartitionResult !== false) {
        if (UseFIPS === true && UseDualStack === true) {
          if (
            true === _.getAttr(PartitionResult, "supportsFIPS") &&
            true === _.getAttr(PartitionResult, "supportsDualStack")
          ) {
            return e(
              `https://connect-fips.${Region}.${_.getAttr(PartitionResult, "dualStackDnsSuffix")}`,
            );
          }
          return err(
            "FIPS and DualStack are enabled, but this partition does not support one or both",
          );
        }
        if (UseFIPS === true) {
          if (_.getAttr(PartitionResult, "supportsFIPS") === true) {
            if (_.getAttr(PartitionResult, "name") === "aws-us-gov") {
              return e(`https://connect.${Region}.amazonaws.com`);
            }
            return e(
              `https://connect-fips.${Region}.${_.getAttr(PartitionResult, "dnsSuffix")}`,
            );
          }
          return err(
            "FIPS is enabled but this partition does not support FIPS",
          );
        }
        if (UseDualStack === true) {
          if (true === _.getAttr(PartitionResult, "supportsDualStack")) {
            return e(
              `https://connect.${Region}.${_.getAttr(PartitionResult, "dualStackDnsSuffix")}`,
            );
          }
          return err(
            "DualStack is enabled but this partition does not support DualStack",
          );
        }
        return e(
          `https://connect.${Region}.${_.getAttr(PartitionResult, "dnsSuffix")}`,
        );
      }
    }
  }
  return err("Invalid Configuration: Missing Region");
});

//# Newtypes
export type InstanceId = string;
export type ResourceId = string;
export type VersionNumber = number;
export type ARN = string;
export type Message = string;
export type DataSetId = string;
export type AWSAccountId = string;
export type Origin = string;
export type ClientToken = string;
export type BotName = string;
export type LexRegion = string;
export type AliasArn = string;
export type ContactId = string;
export type AgentResourceId = string;
export type VocabularyId = string;
export type EmailAddressId = string;
export type HoursOfOperationId = string;
export type AssociationId = string;
export type BucketName = string;
export type Prefix = string;
export type KeyId = string;
export type Hours = number;
export type FunctionArn = string;
export type PhoneNumberId = string;
export type ContactFlowId = string;
export type QueueId = string;
export type QuickConnectId = string;
export type RoutingProfileId = string;
export type Priority = number;
export type Delay = number;
export type PEM = string;
export type SecurityProfileId = string;
export type EntityArn = string;
export type TrafficDistributionGroupIdOrArn = string;
export type UserId = string;
export type PredefinedAttributeName = string;
export type PredefinedAttributeStringValue = string;
export type ProficiencyLevel = number;
export type WorkspaceId = string;
export type WorkspaceErrorCode = string;
export type WorkspaceBatchErrorMessage = string;
export type DataTableId = string;
export type DataTableName = string;
export type RegionName = string;
export type FileId = string;
export type ISO8601Datetime = string;
export type FileName = string;
export type FileSizeInBytes = number;
export type TagKey = string;
export type TagValue = string;
export type ErrorCode = string;
export type ErrorMessage = string;
export type EndpointAddress = string;
export type RequestIdentifier = string;
export type AttributeName = string;
export type AttributeValue = string;
export type CampaignId = string;
export type PostAcceptPreviewTimeoutDurationInSeconds = number;
export type PhoneNumber = string;
export type PhoneNumberDescription = string;
export type AgentStatusName = string;
export type AgentStatusDescription = string;
export type AgentStatusOrderNumber = number;
export type AgentStatusId = string;
export type ReferenceKey = string;
export type ReferenceValue = string;
export type ReferenceArn = string;
export type ReferenceStatusReason = string;
export type ExpiryDurationInMinutes = number;
export type Name = string | redacted.Redacted<string>;
export type Description = string | redacted.Redacted<string>;
export type SegmentAttributeName = string;
export type SegmentAttributeValueString = string;
export type SegmentAttributeValueInteger = number;
export type ContactFlowName = string;
export type ContactFlowDescription = string;
export type ContactFlowContent = string;
export type FlowContentSha256 = string;
export type ProblemMessageString = string;
export type ContactFlowModuleName = string;
export type ContactFlowModuleDescription = string;
export type ContactFlowModuleContent = string;
export type FlowModuleSettings = string;
export type ContactFlowModuleId = string;
export type InstanceIdOrArn = string;
export type ResourceVersion = number;
export type ContactFlowModuleAlias = string;
export type FlowModuleContentSha256 = string;
export type DataTableDescription = string;
export type TimeZone = string;
export type LengthBoundary = number;
export type ValueBoundary = number;
export type PositiveAndNegativeDouble = number;
export type PositiveDouble = number;
export type EmailAddress = string | redacted.Redacted<string>;
export type EmailAddressDisplayName = string | redacted.Redacted<string>;
export type EmailAddressArn = string;
export type EvaluationFormTitle = string;
export type EvaluationFormDescription = string;
export type EvaluationFormSectionTitle = string;
export type ReferenceId = string;
export type EvaluationFormQuestionInstructions = string;
export type EvaluationFormItemWeight = number;
export type EvaluationFormQuestionTitle = string;
export type EvaluationFormQuestionAnswerScore = number;
export type EvaluationFormSingleSelectQuestionOptionText = string;
export type SingleSelectQuestionRuleCategoryAutomationLabel = string;
export type EvaluationFormMultiSelectQuestionOptionText = string;
export type MultiSelectQuestionRuleCategoryAutomationLabel = string;
export type BoxedBoolean = boolean;
export type CommonNameLength127 = string;
export type HoursOfOperationDescription = string;
export type Hours24Format = number;
export type MinutesLimit60 = number;
export type CommonHumanReadableName = string;
export type CommonHumanReadableDescription = string;
export type HoursOfOperationOverrideYearMonthDayDateFormat = string;
export type IntervalPositiveInteger = number;
export type Month = number;
export type MonthDay = number;
export type WeekdayOccurrenceInteger = number;
export type HoursOfOperationOverrideId = string;
export type DirectoryAlias = string | redacted.Redacted<string>;
export type DirectoryId = string;
export type InboundCallsEnabled = boolean;
export type OutboundCallsEnabled = boolean;
export type URI = string;
export type SourceApplicationName = string;
export type IntegrationAssociationId = string;
export type LocalizedString = string;
export type NotificationId = string;
export type DisplayName = string;
export type ParticipantToken = string;
export type ParticipantId = string;
export type PredefinedAttributePurposeName = string;
export type EnableValueValidationOnAssociation = boolean;
export type PromptDescription = string;
export type S3Uri = string;
export type PromptId = string;
export type DeviceToken = string;
export type IncludeRawMessage = boolean;
export type RegistrationId = string;
export type QueueDescription = string;
export type OutboundCallerIdName = string;
export type QueueMaxContacts = number;
export type QuickConnectName = string;
export type QuickConnectDescription = string;
export type RoutingProfileName = string;
export type RoutingProfileDescription = string;
export type Concurrency = number;
export type RuleName = string;
export type RuleFunction = string;
export type TaskNameExpression = string;
export type TaskDescriptionExpression = string;
export type EventBridgeActionName = string;
export type Subject = string;
export type Content = string;
export type FieldValueId = string;
export type FieldStringValue = string;
export type TemplateId = string;
export type SlaName = string;
export type TargetSlaMinutes = number;
export type EvaluationFormId = string;
export type RuleId = string;
export type CreateSecurityProfileName = string;
export type SecurityProfileDescription = string;
export type SecurityProfilePermission = string;
export type SecurityProfilePolicyKey = string;
export type SecurityProfilePolicyValue = string;
export type TagRestrictedResourceName = string;
export type Namespace = string;
export type Permission = string;
export type HierarchyRestrictedResourceName = string;
export type HierarchyGroupId = string;
export type FlowModuleId = string;
export type PrimaryAttributeContextKeyName = string;
export type IAMRestrictedPrimaryValue = string;
export type TaskTemplateName = string;
export type TaskTemplateDescription = string;
export type TaskTemplateFieldName = string;
export type TaskTemplateFieldValue = string;
export type TaskTemplateFieldDescription = string;
export type TaskTemplateSingleSelectOption = string;
export type TaskTemplateId = string;
export type TaskTemplateArn = string;
export type TestCaseName = string;
export type TestCaseDescription = string;
export type TestCaseContent = string;
export type TestCaseInitializationData = string;
export type TestCaseId = string;
export type Name128 = string;
export type Description250 = string;
export type TrafficDistributionGroupId = string;
export type TrafficDistributionGroupArn = string;
export type UseCaseId = string;
export type AgentUsername = string;
export type Password = string | redacted.Redacted<string>;
export type AgentFirstName = string | redacted.Redacted<string>;
export type AgentLastName = string | redacted.Redacted<string>;
export type Email = string | redacted.Redacted<string>;
export type AutoAccept = boolean;
export type AfterContactWorkTimeLimit = number;
export type SensitivePhoneNumber = string | redacted.Redacted<string>;
export type PersistentConnection = boolean;
export type DirectoryUserId = string;
export type AgentFirstCallbackAutoAccept = boolean;
export type HierarchyGroupName = string;
export type ViewsInstanceId = string;
export type ViewsClientToken = string;
export type ViewTemplate = string;
export type ViewAction = string | redacted.Redacted<string>;
export type ViewDescription = string;
export type ViewName = string | redacted.Redacted<string>;
export type ViewId = string;
export type ViewVersion = number;
export type ViewInputSchema = string | redacted.Redacted<string>;
export type ViewContentSha256 = string;
export type VocabularyName = string;
export type VocabularyContent = string;
export type WorkspaceName = string;
export type WorkspaceDescription = string;
export type ThemeString = string;
export type ThemeImageLink = string;
export type WorkspaceTitle = string;
export type Page = string;
export type Slug = string;
export type InputData = string;
export type AuthenticationProfileId = string;
export type AuthenticationProfileName = string;
export type AuthenticationProfileDescription = string;
export type IpCidr = string;
export type AccessTokenDuration = number;
export type RefreshTokenDuration = number;
export type InactivityDuration = number;
export type AgentPauseDurationInSeconds = number;
export type PlatformName = string;
export type PlatformVersion = string;
export type OperatingSystem = string;
export type Duration = number;
export type TotalPauseCount = number;
export type TotalPauseDurationInSeconds = number;
export type AiAgentVersionId = string;
export type CustomerId = string;
export type EndpointDisplayName = string;
export type QueueTimeAdjustmentSeconds = number;
export type QueuePriority = number;
export type ContactTagKey = string;
export type ContactTagValue = string;
export type DurationInSeconds = number;
export type ProficiencyValue = string;
export type NullableProficiencyLevel = number;
export type AgentId = string;
export type ComparisonOperator = string;
export type Index = number;
export type AudioQualityScore = number;
export type PotentialAudioQualityIssue = string;
export type Count = number;
export type DurationMillis = number;
export type PotentialDisconnectIssue = string;
export type RecordingLocation = string;
export type FragmentNumber = string;
export type RecordingDeletionReason = string;
export type UnprocessedTranscriptLocation = string;
export type EvaluationId = string;
export type FormId = string;
export type EvaluationArn = string;
export type ExportLocation = string;
export type ContactDetailName = string;
export type ContactDetailDescription = string;
export type ActiveRegion = string;
export type OriginRegion = string;
export type EvaluationScorePercentage = number;
export type EvaluationAcknowledgerCommentString = string;
export type EvaluationReviewRequestCommentContent = string;
export type EvaluationAnswerDataStringValue = string;
export type EvaluationAnswerDataNumericValue = number;
export type EvaluationSuggestedAnswerJustification = string;
export type EvaluationSuggestedAnswerTranscriptMillisOffset = number;
export type EvaluationSuggestedAnswerTranscriptSegment = string;
export type QuestionRuleCategoryAutomationLabel = string;
export type EvaluationNoteString = string;
export type DataTableVersion = string;
export type EvaluationFormVersionIsLocked = boolean;
export type Url = string;
export type AwsRegion = string;
export type ReplicationStatusReason = string;
export type GlobalSignInEndpoint = string;
export type InstanceAttributeValue = string;
export type PhoneNumberWorkflowMessage = string;
export type IsReadOnly = boolean;
export type SecurityProfileName = string;
export type TestCaseSha256 = string;
export type InstanceArn = string;
export type HierarchyLevelId = string;
export type HierarchyLevelName = string;
export type VocabularyLastModifiedTime = Date;
export type VocabularyFailureReason = string;
export type NextToken = string;
export type MaxResult100 = number;
export type URLExpiryInSeconds = number;
export type MetadataUrl = string;
export type RoutingExpression = string;
export type Subtype = string;
export type ValidationTestType = string;
export type CurrentMetricId = string;
export type Value = number;
export type ApproximateTotalCount = number;
export type IntegerCount = number;
export type SecurityToken = string | redacted.Redacted<string>;
export type ThresholdValue = number;
export type ResourceArnOrId = string;
export type GroupingV2 = string;
export type MetricNameV2 = string;
export type MetricId = string;
export type NextToken2500 = string;
export type DimensionsV2Key = string;
export type DimensionsV2Value = string;
export type PromptPresignedUrl = string;
export type SnapshotVersion = string;
export type TestCaseExecutionId = string;
export type Percentage = number;
export type MediaSource = string;
export type MaxResult1000 = number;
export type MaxResult25 = number;
export type ListAssociatedContactsRequestMaxResults = number;
export type VocabularyNextToken = string;
export type HoursOfOperationName = string;
export type MaxResult7 = number;
export type MaxResult10 = number;
export type LargeNextToken = string;
export type PhoneNumberPrefix = string;
export type PromptName = string;
export type QueueName = string;
export type RealTimeContactAnalysisId256 = string;
export type RealTimeContactAnalysisTranscriptContent = string;
export type RealTimeContactAnalysisContentType = string;
export type RealTimeContactAnalysisTimeInstant = Date;
export type RealTimeContactAnalysisOffset = number;
export type RealTimeContactAnalysisCategoryName = string;
export type RealTimeContactAnalysisEventType = string;
export type AttachmentName = string;
export type ContentType = string;
export type ArtifactId = string;
export type RealTimeContactAnalysisPostContactSummaryContent = string;
export type MaxResult200 = number;
export type MaxResult2 = number;
export type TestCaseResourceId = string;
export type ExecutionRecordString = string;
export type ViewsNextToken = string;
export type MaxResults = number;
export type NullableProficiencyLimitValue = number;
export type DateTimeFormat = string;
export type SearchText = string | redacted.Redacted<string>;
export type SearchableContactAttributeKey = string | redacted.Redacted<string>;
export type SearchableContactAttributeValue =
  | string
  | redacted.Redacted<string>;
export type SearchableSegmentAttributeKey = string | redacted.Redacted<string>;
export type SearchableSegmentAttributeValue =
  | string
  | redacted.Redacted<string>;
export type TotalCount = number;
export type DateYearMonthDayFormat = string;
export type MaxResult500 = number;
export type TagKeyString = string;
export type TagValueString = string;
export type WorkspaceAssociatedResourceId = string;
export type WorkspaceAssociatedResourceType = string;
export type WorkspaceAssociatedResourceName = string;
export type SourceId = string;
export type DestinationId = string;
export type ChatContentType = string;
export type ChatContent = string;
export type SupportedMessagingContentType = string;
export type ChatStreamingEndpointARN = string;
export type NewChatCreated = boolean;
export type MessageTemplateKnowledgeBaseId = string;
export type MessageTemplateId = string;
export type CustomerProfileAttributesSerialized = string;
export type OutboundSubject = string | redacted.Redacted<string>;
export type Body = string | redacted.Redacted<string>;
export type EmailMessageContentType = string;
export type OutboundRequestId = string;
export type UrlMetadataSignedHeadersKey = string;
export type UrlMetadataSignedHeadersValue = string;
export type ChatDurationInMinutes = number;
export type CustomerIdNonEmpty = string | redacted.Redacted<string>;
export type StreamingId = string;
export type InboundSubject = string | redacted.Redacted<string>;
export type EmailHeaderValue = string;
export type PreSignedAttachmentUrl = string;
export type RingTimeoutInSeconds = number;
export type AttendeeId = string;
export type JoinToken = string | redacted.Redacted<string>;
export type MediaRegion = string;
export type MeetingId = string;
export type DisconnectReasonCode = string;
export type UpdateAgentStatusDescription = string;
export type UpdateHoursOfOperationDescription = string;
export type AuthorizationCode = string | redacted.Redacted<string>;
export type AuthenticationError = string | redacted.Redacted<string>;
export type AuthenticationErrorDescription = string | redacted.Redacted<string>;
export type ParticipantTimerDurationInMinutes = number;
export type UpdateQuickConnectDescription = string;

//# Schemas
export interface ActivateEvaluationFormRequest {
  InstanceId: string;
  EvaluationFormId: string;
  EvaluationFormVersion: number;
}
export const ActivateEvaluationFormRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationFormId: S.String.pipe(T.HttpLabel("EvaluationFormId")),
    EvaluationFormVersion: S.Number,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/evaluation-forms/{InstanceId}/{EvaluationFormId}/activate",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ActivateEvaluationFormRequest",
}) as any as S.Schema<ActivateEvaluationFormRequest>;
export interface ActivateEvaluationFormResponse {
  EvaluationFormId: string;
  EvaluationFormArn: string;
  EvaluationFormVersion: number;
}
export const ActivateEvaluationFormResponse = S.suspend(() =>
  S.Struct({
    EvaluationFormId: S.String,
    EvaluationFormArn: S.String,
    EvaluationFormVersion: S.Number,
  }),
).annotate({
  identifier: "ActivateEvaluationFormResponse",
}) as any as S.Schema<ActivateEvaluationFormResponse>;
export interface AssociateAnalyticsDataSetRequest {
  InstanceId: string;
  DataSetId: string;
  TargetAccountId?: string;
}
export const AssociateAnalyticsDataSetRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataSetId: S.String,
    TargetAccountId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/analytics-data/instance/{InstanceId}/association",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateAnalyticsDataSetRequest",
}) as any as S.Schema<AssociateAnalyticsDataSetRequest>;
export interface AssociateAnalyticsDataSetResponse {
  DataSetId?: string;
  TargetAccountId?: string;
  ResourceShareId?: string;
  ResourceShareArn?: string;
}
export const AssociateAnalyticsDataSetResponse = S.suspend(() =>
  S.Struct({
    DataSetId: S.optional(S.String),
    TargetAccountId: S.optional(S.String),
    ResourceShareId: S.optional(S.String),
    ResourceShareArn: S.optional(S.String),
  }),
).annotate({
  identifier: "AssociateAnalyticsDataSetResponse",
}) as any as S.Schema<AssociateAnalyticsDataSetResponse>;
export type AttachedFileInvalidRequestExceptionReason =
  | "INVALID_FILE_SIZE"
  | "INVALID_FILE_TYPE"
  | "INVALID_FILE_NAME"
  | (string & {});
export const AttachedFileInvalidRequestExceptionReason = S.String;
export type InvalidRequestExceptionReason = {
  AttachedFileInvalidRequestExceptionReason: AttachedFileInvalidRequestExceptionReason;
};
export const InvalidRequestExceptionReason = S.Union([
  S.Struct({
    AttachedFileInvalidRequestExceptionReason:
      AttachedFileInvalidRequestExceptionReason,
  }),
]);
export interface AssociateApprovedOriginRequest {
  InstanceId: string;
  Origin: string;
  ClientToken?: string;
}
export const AssociateApprovedOriginRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Origin: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/instance/{InstanceId}/approved-origin" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateApprovedOriginRequest",
}) as any as S.Schema<AssociateApprovedOriginRequest>;
export interface AssociateApprovedOriginResponse {}
export const AssociateApprovedOriginResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "AssociateApprovedOriginResponse",
}) as any as S.Schema<AssociateApprovedOriginResponse>;
export type AttachedFileServiceQuotaExceededExceptionReason =
  | "TOTAL_FILE_SIZE_EXCEEDED"
  | "TOTAL_FILE_COUNT_EXCEEDED"
  | (string & {});
export const AttachedFileServiceQuotaExceededExceptionReason = S.String;
export type ServiceQuotaExceededExceptionReason = {
  AttachedFileServiceQuotaExceededExceptionReason: AttachedFileServiceQuotaExceededExceptionReason;
};
export const ServiceQuotaExceededExceptionReason = S.Union([
  S.Struct({
    AttachedFileServiceQuotaExceededExceptionReason:
      AttachedFileServiceQuotaExceededExceptionReason,
  }),
]);
export interface LexBot {
  Name: string;
  LexRegion: string;
}
export const LexBot = S.suspend(() =>
  S.Struct({ Name: S.String, LexRegion: S.String }),
).annotate({ identifier: "LexBot" }) as any as S.Schema<LexBot>;
export interface LexV2Bot {
  AliasArn?: string;
}
export const LexV2Bot = S.suspend(() =>
  S.Struct({ AliasArn: S.optional(S.String) }),
).annotate({ identifier: "LexV2Bot" }) as any as S.Schema<LexV2Bot>;
export interface AssociateBotRequest {
  InstanceId: string;
  LexBot?: LexBot;
  LexV2Bot?: LexV2Bot;
  ClientToken?: string;
}
export const AssociateBotRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    LexBot: S.optional(LexBot),
    LexV2Bot: S.optional(LexV2Bot),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/instance/{InstanceId}/bot" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateBotRequest",
}) as any as S.Schema<AssociateBotRequest>;
export interface AssociateBotResponse {}
export const AssociateBotResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "AssociateBotResponse",
}) as any as S.Schema<AssociateBotResponse>;
export interface AssociateContactWithUserRequest {
  InstanceId: string;
  ContactId: string;
  UserId: string;
}
export const AssociateContactWithUserRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String.pipe(T.HttpLabel("ContactId")),
    UserId: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contacts/{InstanceId}/{ContactId}/associate-user",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateContactWithUserRequest",
}) as any as S.Schema<AssociateContactWithUserRequest>;
export interface AssociateContactWithUserResponse {}
export const AssociateContactWithUserResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "AssociateContactWithUserResponse",
}) as any as S.Schema<AssociateContactWithUserResponse>;
export type VocabularyLanguageCode =
  | "ar-AE"
  | "de-CH"
  | "de-DE"
  | "en-AB"
  | "en-AU"
  | "en-GB"
  | "en-IE"
  | "en-IN"
  | "en-US"
  | "en-WL"
  | "es-ES"
  | "es-US"
  | "fr-CA"
  | "fr-FR"
  | "hi-IN"
  | "it-IT"
  | "ja-JP"
  | "ko-KR"
  | "pt-BR"
  | "pt-PT"
  | "zh-CN"
  | "en-NZ"
  | "en-ZA"
  | "ca-ES"
  | "da-DK"
  | "fi-FI"
  | "id-ID"
  | "ms-MY"
  | "nl-NL"
  | "no-NO"
  | "pl-PL"
  | "sv-SE"
  | "tl-PH"
  | (string & {});
export const VocabularyLanguageCode = S.String;
export interface AssociateDefaultVocabularyRequest {
  InstanceId: string;
  LanguageCode: VocabularyLanguageCode;
  VocabularyId?: string;
}
export const AssociateDefaultVocabularyRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    LanguageCode: VocabularyLanguageCode.pipe(T.HttpLabel("LanguageCode")),
    VocabularyId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/default-vocabulary/{InstanceId}/{LanguageCode}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateDefaultVocabularyRequest",
}) as any as S.Schema<AssociateDefaultVocabularyRequest>;
export interface AssociateDefaultVocabularyResponse {}
export const AssociateDefaultVocabularyResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "AssociateDefaultVocabularyResponse",
}) as any as S.Schema<AssociateDefaultVocabularyResponse>;
export interface AliasConfiguration {
  EmailAddressId: string;
}
export const AliasConfiguration = S.suspend(() =>
  S.Struct({ EmailAddressId: S.String }),
).annotate({
  identifier: "AliasConfiguration",
}) as any as S.Schema<AliasConfiguration>;
export interface AssociateEmailAddressAliasRequest {
  EmailAddressId: string;
  InstanceId: string;
  AliasConfiguration: AliasConfiguration;
  ClientToken?: string;
}
export const AssociateEmailAddressAliasRequest = S.suspend(() =>
  S.Struct({
    EmailAddressId: S.String.pipe(T.HttpLabel("EmailAddressId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AliasConfiguration: AliasConfiguration,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/email-addresses/{InstanceId}/{EmailAddressId}/associate-alias",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateEmailAddressAliasRequest",
}) as any as S.Schema<AssociateEmailAddressAliasRequest>;
export interface AssociateEmailAddressAliasResponse {}
export const AssociateEmailAddressAliasResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "AssociateEmailAddressAliasResponse",
}) as any as S.Schema<AssociateEmailAddressAliasResponse>;
export type FlowAssociationResourceType =
  | "SMS_PHONE_NUMBER"
  | "INBOUND_EMAIL"
  | "OUTBOUND_EMAIL"
  | "ANALYTICS_CONNECTOR"
  | "WHATSAPP_MESSAGING_PHONE_NUMBER"
  | (string & {});
export const FlowAssociationResourceType = S.String;
export interface AssociateFlowRequest {
  InstanceId: string;
  ResourceId: string;
  FlowId: string;
  ResourceType: FlowAssociationResourceType;
}
export const AssociateFlowRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ResourceId: S.String,
    FlowId: S.String,
    ResourceType: FlowAssociationResourceType,
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/flow-associations/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateFlowRequest",
}) as any as S.Schema<AssociateFlowRequest>;
export interface AssociateFlowResponse {}
export const AssociateFlowResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "AssociateFlowResponse",
}) as any as S.Schema<AssociateFlowResponse>;
export interface ParentHoursOfOperationConfig {
  HoursOfOperationId?: string;
}
export const ParentHoursOfOperationConfig = S.suspend(() =>
  S.Struct({ HoursOfOperationId: S.optional(S.String) }),
).annotate({
  identifier: "ParentHoursOfOperationConfig",
}) as any as S.Schema<ParentHoursOfOperationConfig>;
export type ParentHoursOfOperationConfigList = ParentHoursOfOperationConfig[];
export const ParentHoursOfOperationConfigList = S.Array(
  ParentHoursOfOperationConfig,
);
export interface AssociateHoursOfOperationsRequest {
  InstanceId: string;
  HoursOfOperationId: string;
  ParentHoursOfOperationConfigs: ParentHoursOfOperationConfig[];
}
export const AssociateHoursOfOperationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
    ParentHoursOfOperationConfigs: ParentHoursOfOperationConfigList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}/associate-hours",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateHoursOfOperationsRequest",
}) as any as S.Schema<AssociateHoursOfOperationsRequest>;
export interface AssociateHoursOfOperationsResponse {}
export const AssociateHoursOfOperationsResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "AssociateHoursOfOperationsResponse",
}) as any as S.Schema<AssociateHoursOfOperationsResponse>;
export type InstanceStorageResourceType =
  | "CHAT_TRANSCRIPTS"
  | "CALL_RECORDINGS"
  | "SCHEDULED_REPORTS"
  | "MEDIA_STREAMS"
  | "CONTACT_TRACE_RECORDS"
  | "AGENT_EVENTS"
  | "REAL_TIME_CONTACT_ANALYSIS_SEGMENTS"
  | "ATTACHMENTS"
  | "CONTACT_EVALUATIONS"
  | "SCREEN_RECORDINGS"
  | "REAL_TIME_CONTACT_ANALYSIS_CHAT_SEGMENTS"
  | "REAL_TIME_CONTACT_ANALYSIS_VOICE_SEGMENTS"
  | "EMAIL_MESSAGES"
  | (string & {});
export const InstanceStorageResourceType = S.String;
export type StorageType =
  | "S3"
  | "KINESIS_VIDEO_STREAM"
  | "KINESIS_STREAM"
  | "KINESIS_FIREHOSE"
  | (string & {});
export const StorageType = S.String;
export type EncryptionType = "KMS" | (string & {});
export const EncryptionType = S.String;
export interface EncryptionConfig {
  EncryptionType: EncryptionType;
  KeyId: string;
}
export const EncryptionConfig = S.suspend(() =>
  S.Struct({ EncryptionType: EncryptionType, KeyId: S.String }),
).annotate({
  identifier: "EncryptionConfig",
}) as any as S.Schema<EncryptionConfig>;
export interface S3Config {
  BucketName: string;
  BucketPrefix: string;
  EncryptionConfig?: EncryptionConfig;
}
export const S3Config = S.suspend(() =>
  S.Struct({
    BucketName: S.String,
    BucketPrefix: S.String,
    EncryptionConfig: S.optional(EncryptionConfig),
  }),
).annotate({ identifier: "S3Config" }) as any as S.Schema<S3Config>;
export interface KinesisVideoStreamConfig {
  Prefix: string;
  RetentionPeriodHours: number;
  EncryptionConfig: EncryptionConfig;
}
export const KinesisVideoStreamConfig = S.suspend(() =>
  S.Struct({
    Prefix: S.String,
    RetentionPeriodHours: S.Number,
    EncryptionConfig: EncryptionConfig,
  }),
).annotate({
  identifier: "KinesisVideoStreamConfig",
}) as any as S.Schema<KinesisVideoStreamConfig>;
export interface KinesisStreamConfig {
  StreamArn: string;
}
export const KinesisStreamConfig = S.suspend(() =>
  S.Struct({ StreamArn: S.String }),
).annotate({
  identifier: "KinesisStreamConfig",
}) as any as S.Schema<KinesisStreamConfig>;
export interface KinesisFirehoseConfig {
  FirehoseArn: string;
}
export const KinesisFirehoseConfig = S.suspend(() =>
  S.Struct({ FirehoseArn: S.String }),
).annotate({
  identifier: "KinesisFirehoseConfig",
}) as any as S.Schema<KinesisFirehoseConfig>;
export interface InstanceStorageConfig {
  AssociationId?: string;
  StorageType: StorageType;
  S3Config?: S3Config;
  KinesisVideoStreamConfig?: KinesisVideoStreamConfig;
  KinesisStreamConfig?: KinesisStreamConfig;
  KinesisFirehoseConfig?: KinesisFirehoseConfig;
}
export const InstanceStorageConfig = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String),
    StorageType: StorageType,
    S3Config: S.optional(S3Config),
    KinesisVideoStreamConfig: S.optional(KinesisVideoStreamConfig),
    KinesisStreamConfig: S.optional(KinesisStreamConfig),
    KinesisFirehoseConfig: S.optional(KinesisFirehoseConfig),
  }),
).annotate({
  identifier: "InstanceStorageConfig",
}) as any as S.Schema<InstanceStorageConfig>;
export interface AssociateInstanceStorageConfigRequest {
  InstanceId: string;
  ResourceType: InstanceStorageResourceType;
  StorageConfig: InstanceStorageConfig;
  ClientToken?: string;
}
export const AssociateInstanceStorageConfigRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ResourceType: InstanceStorageResourceType,
    StorageConfig: InstanceStorageConfig,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/instance/{InstanceId}/storage-config" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateInstanceStorageConfigRequest",
}) as any as S.Schema<AssociateInstanceStorageConfigRequest>;
export interface AssociateInstanceStorageConfigResponse {
  AssociationId?: string;
}
export const AssociateInstanceStorageConfigResponse = S.suspend(() =>
  S.Struct({ AssociationId: S.optional(S.String) }),
).annotate({
  identifier: "AssociateInstanceStorageConfigResponse",
}) as any as S.Schema<AssociateInstanceStorageConfigResponse>;
export interface AssociateLambdaFunctionRequest {
  InstanceId: string;
  FunctionArn: string;
  ClientToken?: string;
}
export const AssociateLambdaFunctionRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    FunctionArn: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/instance/{InstanceId}/lambda-function" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateLambdaFunctionRequest",
}) as any as S.Schema<AssociateLambdaFunctionRequest>;
export interface AssociateLambdaFunctionResponse {}
export const AssociateLambdaFunctionResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "AssociateLambdaFunctionResponse",
}) as any as S.Schema<AssociateLambdaFunctionResponse>;
export interface AssociateLexBotRequest {
  InstanceId: string;
  LexBot: LexBot;
  ClientToken?: string;
}
export const AssociateLexBotRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    LexBot: LexBot,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/instance/{InstanceId}/lex-bot" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateLexBotRequest",
}) as any as S.Schema<AssociateLexBotRequest>;
export interface AssociateLexBotResponse {}
export const AssociateLexBotResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "AssociateLexBotResponse",
}) as any as S.Schema<AssociateLexBotResponse>;
export interface AssociatePhoneNumberContactFlowRequest {
  PhoneNumberId: string;
  InstanceId: string;
  ContactFlowId: string;
}
export const AssociatePhoneNumberContactFlowRequest = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.String.pipe(T.HttpLabel("PhoneNumberId")),
    InstanceId: S.String,
    ContactFlowId: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/phone-number/{PhoneNumberId}/contact-flow",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociatePhoneNumberContactFlowRequest",
}) as any as S.Schema<AssociatePhoneNumberContactFlowRequest>;
export interface AssociatePhoneNumberContactFlowResponse {}
export const AssociatePhoneNumberContactFlowResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "AssociatePhoneNumberContactFlowResponse",
}) as any as S.Schema<AssociatePhoneNumberContactFlowResponse>;
export type QuickConnectsList = string[];
export const QuickConnectsList = S.Array(S.String);
export interface AssociateQueueQuickConnectsRequest {
  InstanceId: string;
  QueueId: string;
  QuickConnectIds: string[];
}
export const AssociateQueueQuickConnectsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
    QuickConnectIds: QuickConnectsList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/queues/{InstanceId}/{QueueId}/associate-quick-connects",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateQueueQuickConnectsRequest",
}) as any as S.Schema<AssociateQueueQuickConnectsRequest>;
export interface AssociateQueueQuickConnectsResponse {}
export const AssociateQueueQuickConnectsResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "AssociateQueueQuickConnectsResponse",
}) as any as S.Schema<AssociateQueueQuickConnectsResponse>;
export type Channel = "VOICE" | "CHAT" | "TASK" | "EMAIL" | (string & {});
export const Channel = S.String;
export interface RoutingProfileQueueReference {
  QueueId: string;
  Channel: Channel;
}
export const RoutingProfileQueueReference = S.suspend(() =>
  S.Struct({ QueueId: S.String, Channel: Channel }),
).annotate({
  identifier: "RoutingProfileQueueReference",
}) as any as S.Schema<RoutingProfileQueueReference>;
export interface RoutingProfileQueueConfig {
  QueueReference: RoutingProfileQueueReference;
  Priority: number;
  Delay: number;
}
export const RoutingProfileQueueConfig = S.suspend(() =>
  S.Struct({
    QueueReference: RoutingProfileQueueReference,
    Priority: S.Number,
    Delay: S.Number,
  }),
).annotate({
  identifier: "RoutingProfileQueueConfig",
}) as any as S.Schema<RoutingProfileQueueConfig>;
export type RoutingProfileQueueConfigList = RoutingProfileQueueConfig[];
export const RoutingProfileQueueConfigList = S.Array(RoutingProfileQueueConfig);
export interface RoutingProfileManualAssignmentQueueConfig {
  QueueReference: RoutingProfileQueueReference;
}
export const RoutingProfileManualAssignmentQueueConfig = S.suspend(() =>
  S.Struct({ QueueReference: RoutingProfileQueueReference }),
).annotate({
  identifier: "RoutingProfileManualAssignmentQueueConfig",
}) as any as S.Schema<RoutingProfileManualAssignmentQueueConfig>;
export type RoutingProfileManualAssignmentQueueConfigList =
  RoutingProfileManualAssignmentQueueConfig[];
export const RoutingProfileManualAssignmentQueueConfigList = S.Array(
  RoutingProfileManualAssignmentQueueConfig,
);
export interface AssociateRoutingProfileQueuesRequest {
  InstanceId: string;
  RoutingProfileId: string;
  QueueConfigs?: RoutingProfileQueueConfig[];
  ManualAssignmentQueueConfigs?: RoutingProfileManualAssignmentQueueConfig[];
}
export const AssociateRoutingProfileQueuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
    QueueConfigs: S.optional(RoutingProfileQueueConfigList),
    ManualAssignmentQueueConfigs: S.optional(
      RoutingProfileManualAssignmentQueueConfigList,
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}/associate-queues",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateRoutingProfileQueuesRequest",
}) as any as S.Schema<AssociateRoutingProfileQueuesRequest>;
export interface AssociateRoutingProfileQueuesResponse {}
export const AssociateRoutingProfileQueuesResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "AssociateRoutingProfileQueuesResponse",
}) as any as S.Schema<AssociateRoutingProfileQueuesResponse>;
export interface AssociateSecurityKeyRequest {
  InstanceId: string;
  Key: string;
  ClientToken?: string;
}
export const AssociateSecurityKeyRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Key: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/instance/{InstanceId}/security-key" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateSecurityKeyRequest",
}) as any as S.Schema<AssociateSecurityKeyRequest>;
export interface AssociateSecurityKeyResponse {
  AssociationId?: string;
}
export const AssociateSecurityKeyResponse = S.suspend(() =>
  S.Struct({ AssociationId: S.optional(S.String) }),
).annotate({
  identifier: "AssociateSecurityKeyResponse",
}) as any as S.Schema<AssociateSecurityKeyResponse>;
export interface SecurityProfileItem {
  Id?: string;
}
export const SecurityProfileItem = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String) }),
).annotate({
  identifier: "SecurityProfileItem",
}) as any as S.Schema<SecurityProfileItem>;
export type SecurityProfiles = SecurityProfileItem[];
export const SecurityProfiles = S.Array(SecurityProfileItem);
export type EntityType = "USER" | "AI_AGENT" | (string & {});
export const EntityType = S.String;
export interface AssociateSecurityProfilesRequest {
  InstanceId: string;
  SecurityProfiles: SecurityProfileItem[];
  EntityType: EntityType;
  EntityArn: string;
}
export const AssociateSecurityProfilesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    SecurityProfiles: SecurityProfiles,
    EntityType: EntityType,
    EntityArn: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/associate-security-profiles/{InstanceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateSecurityProfilesRequest",
}) as any as S.Schema<AssociateSecurityProfilesRequest>;
export interface AssociateSecurityProfilesResponse {}
export const AssociateSecurityProfilesResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "AssociateSecurityProfilesResponse",
}) as any as S.Schema<AssociateSecurityProfilesResponse>;
export interface AssociateTrafficDistributionGroupUserRequest {
  TrafficDistributionGroupId: string;
  UserId: string;
  InstanceId: string;
}
export const AssociateTrafficDistributionGroupUserRequest = S.suspend(() =>
  S.Struct({
    TrafficDistributionGroupId: S.String.pipe(
      T.HttpLabel("TrafficDistributionGroupId"),
    ),
    UserId: S.String,
    InstanceId: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/traffic-distribution-group/{TrafficDistributionGroupId}/user",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateTrafficDistributionGroupUserRequest",
}) as any as S.Schema<AssociateTrafficDistributionGroupUserRequest>;
export interface AssociateTrafficDistributionGroupUserResponse {}
export const AssociateTrafficDistributionGroupUserResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "AssociateTrafficDistributionGroupUserResponse",
}) as any as S.Schema<AssociateTrafficDistributionGroupUserResponse>;
export interface UserProficiency {
  AttributeName: string;
  AttributeValue: string;
  Level: number;
}
export const UserProficiency = S.suspend(() =>
  S.Struct({
    AttributeName: S.String,
    AttributeValue: S.String,
    Level: S.Number,
  }),
).annotate({
  identifier: "UserProficiency",
}) as any as S.Schema<UserProficiency>;
export type UserProficiencyList = UserProficiency[];
export const UserProficiencyList = S.Array(UserProficiency);
export interface AssociateUserProficienciesRequest {
  InstanceId: string;
  UserId: string;
  UserProficiencies: UserProficiency[];
}
export const AssociateUserProficienciesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    UserProficiencies: UserProficiencyList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/users/{InstanceId}/{UserId}/associate-proficiencies",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateUserProficienciesRequest",
}) as any as S.Schema<AssociateUserProficienciesRequest>;
export interface AssociateUserProficienciesResponse {}
export const AssociateUserProficienciesResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "AssociateUserProficienciesResponse",
}) as any as S.Schema<AssociateUserProficienciesResponse>;
export type WorkspaceResourceArnList = string[];
export const WorkspaceResourceArnList = S.Array(S.String);
export interface AssociateWorkspaceRequest {
  InstanceId: string;
  WorkspaceId: string;
  ResourceArns: string[];
}
export const AssociateWorkspaceRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    ResourceArns: WorkspaceResourceArnList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/associate",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "AssociateWorkspaceRequest",
}) as any as S.Schema<AssociateWorkspaceRequest>;
export interface SuccessfulBatchAssociationSummary {
  ResourceArn?: string;
}
export const SuccessfulBatchAssociationSummary = S.suspend(() =>
  S.Struct({ ResourceArn: S.optional(S.String) }),
).annotate({
  identifier: "SuccessfulBatchAssociationSummary",
}) as any as S.Schema<SuccessfulBatchAssociationSummary>;
export type SuccessfulBatchAssociationSummaryList =
  SuccessfulBatchAssociationSummary[];
export const SuccessfulBatchAssociationSummaryList = S.Array(
  SuccessfulBatchAssociationSummary,
);
export interface FailedBatchAssociationSummary {
  ResourceArn?: string;
  ErrorCode?: string;
  ErrorMessage?: string;
}
export const FailedBatchAssociationSummary = S.suspend(() =>
  S.Struct({
    ResourceArn: S.optional(S.String),
    ErrorCode: S.optional(S.String),
    ErrorMessage: S.optional(S.String),
  }),
).annotate({
  identifier: "FailedBatchAssociationSummary",
}) as any as S.Schema<FailedBatchAssociationSummary>;
export type FailedBatchAssociationSummaryList = FailedBatchAssociationSummary[];
export const FailedBatchAssociationSummaryList = S.Array(
  FailedBatchAssociationSummary,
);
export interface AssociateWorkspaceResponse {
  SuccessfulList?: SuccessfulBatchAssociationSummary[];
  FailedList?: FailedBatchAssociationSummary[];
}
export const AssociateWorkspaceResponse = S.suspend(() =>
  S.Struct({
    SuccessfulList: S.optional(SuccessfulBatchAssociationSummaryList),
    FailedList: S.optional(FailedBatchAssociationSummaryList),
  }),
).annotate({
  identifier: "AssociateWorkspaceResponse",
}) as any as S.Schema<AssociateWorkspaceResponse>;
export type DataSetIds = string[];
export const DataSetIds = S.Array(S.String);
export interface BatchAssociateAnalyticsDataSetRequest {
  InstanceId: string;
  DataSetIds: string[];
  TargetAccountId?: string;
}
export const BatchAssociateAnalyticsDataSetRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataSetIds: DataSetIds,
    TargetAccountId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/analytics-data/instance/{InstanceId}/associations",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "BatchAssociateAnalyticsDataSetRequest",
}) as any as S.Schema<BatchAssociateAnalyticsDataSetRequest>;
export interface AnalyticsDataAssociationResult {
  DataSetId?: string;
  TargetAccountId?: string;
  ResourceShareId?: string;
  ResourceShareArn?: string;
  ResourceShareStatus?: string;
}
export const AnalyticsDataAssociationResult = S.suspend(() =>
  S.Struct({
    DataSetId: S.optional(S.String),
    TargetAccountId: S.optional(S.String),
    ResourceShareId: S.optional(S.String),
    ResourceShareArn: S.optional(S.String),
    ResourceShareStatus: S.optional(S.String),
  }),
).annotate({
  identifier: "AnalyticsDataAssociationResult",
}) as any as S.Schema<AnalyticsDataAssociationResult>;
export type AnalyticsDataAssociationResults = AnalyticsDataAssociationResult[];
export const AnalyticsDataAssociationResults = S.Array(
  AnalyticsDataAssociationResult,
);
export interface ErrorResult {
  ErrorCode?: string;
  ErrorMessage?: string;
}
export const ErrorResult = S.suspend(() =>
  S.Struct({
    ErrorCode: S.optional(S.String),
    ErrorMessage: S.optional(S.String),
  }),
).annotate({ identifier: "ErrorResult" }) as any as S.Schema<ErrorResult>;
export type ErrorResults = ErrorResult[];
export const ErrorResults = S.Array(ErrorResult);
export interface BatchAssociateAnalyticsDataSetResponse {
  Created?: AnalyticsDataAssociationResult[];
  Errors?: ErrorResult[];
}
export const BatchAssociateAnalyticsDataSetResponse = S.suspend(() =>
  S.Struct({
    Created: S.optional(AnalyticsDataAssociationResults),
    Errors: S.optional(ErrorResults),
  }),
).annotate({
  identifier: "BatchAssociateAnalyticsDataSetResponse",
}) as any as S.Schema<BatchAssociateAnalyticsDataSetResponse>;
export interface PrimaryValue {
  AttributeName: string;
  Value: string;
}
export const PrimaryValue = S.suspend(() =>
  S.Struct({ AttributeName: S.String, Value: S.String }),
).annotate({ identifier: "PrimaryValue" }) as any as S.Schema<PrimaryValue>;
export type PrimaryValuesSet = PrimaryValue[];
export const PrimaryValuesSet = S.Array(PrimaryValue);
export interface DataTableLockVersion {
  DataTable?: string;
  Attribute?: string;
  PrimaryValues?: string;
  Value?: string;
}
export const DataTableLockVersion = S.suspend(() =>
  S.Struct({
    DataTable: S.optional(S.String),
    Attribute: S.optional(S.String),
    PrimaryValues: S.optional(S.String),
    Value: S.optional(S.String),
  }),
).annotate({
  identifier: "DataTableLockVersion",
}) as any as S.Schema<DataTableLockVersion>;
export interface DataTableValue {
  PrimaryValues?: PrimaryValue[];
  AttributeName: string;
  Value: string;
  LockVersion?: DataTableLockVersion;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const DataTableValue = S.suspend(() =>
  S.Struct({
    PrimaryValues: S.optional(PrimaryValuesSet),
    AttributeName: S.String,
    Value: S.String,
    LockVersion: S.optional(DataTableLockVersion),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({ identifier: "DataTableValue" }) as any as S.Schema<DataTableValue>;
export type DataTableValueList = DataTableValue[];
export const DataTableValueList = S.Array(DataTableValue);
export interface BatchCreateDataTableValueRequest {
  InstanceId: string;
  DataTableId: string;
  Values: DataTableValue[];
}
export const BatchCreateDataTableValueRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    Values: DataTableValueList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/values/create",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "BatchCreateDataTableValueRequest",
}) as any as S.Schema<BatchCreateDataTableValueRequest>;
export interface BatchCreateDataTableValueSuccessResult {
  PrimaryValues: PrimaryValue[];
  AttributeName: string;
  RecordId: string;
  LockVersion: DataTableLockVersion;
}
export const BatchCreateDataTableValueSuccessResult = S.suspend(() =>
  S.Struct({
    PrimaryValues: PrimaryValuesSet,
    AttributeName: S.String,
    RecordId: S.String,
    LockVersion: DataTableLockVersion,
  }),
).annotate({
  identifier: "BatchCreateDataTableValueSuccessResult",
}) as any as S.Schema<BatchCreateDataTableValueSuccessResult>;
export type BatchCreateDataTableValueSuccessResultList =
  BatchCreateDataTableValueSuccessResult[];
export const BatchCreateDataTableValueSuccessResultList = S.Array(
  BatchCreateDataTableValueSuccessResult,
);
export interface BatchCreateDataTableValueFailureResult {
  PrimaryValues: PrimaryValue[];
  AttributeName: string;
  Message: string;
}
export const BatchCreateDataTableValueFailureResult = S.suspend(() =>
  S.Struct({
    PrimaryValues: PrimaryValuesSet,
    AttributeName: S.String,
    Message: S.String,
  }),
).annotate({
  identifier: "BatchCreateDataTableValueFailureResult",
}) as any as S.Schema<BatchCreateDataTableValueFailureResult>;
export type BatchCreateDataTableValueFailureResultList =
  BatchCreateDataTableValueFailureResult[];
export const BatchCreateDataTableValueFailureResultList = S.Array(
  BatchCreateDataTableValueFailureResult,
);
export interface BatchCreateDataTableValueResponse {
  Successful: BatchCreateDataTableValueSuccessResult[];
  Failed: BatchCreateDataTableValueFailureResult[];
}
export const BatchCreateDataTableValueResponse = S.suspend(() =>
  S.Struct({
    Successful: BatchCreateDataTableValueSuccessResultList,
    Failed: BatchCreateDataTableValueFailureResultList,
  }),
).annotate({
  identifier: "BatchCreateDataTableValueResponse",
}) as any as S.Schema<BatchCreateDataTableValueResponse>;
export interface DataTableDeleteValueIdentifier {
  PrimaryValues?: PrimaryValue[];
  AttributeName: string;
  LockVersion: DataTableLockVersion;
}
export const DataTableDeleteValueIdentifier = S.suspend(() =>
  S.Struct({
    PrimaryValues: S.optional(PrimaryValuesSet),
    AttributeName: S.String,
    LockVersion: DataTableLockVersion,
  }),
).annotate({
  identifier: "DataTableDeleteValueIdentifier",
}) as any as S.Schema<DataTableDeleteValueIdentifier>;
export type DataTableDeleteValueIdentifierList =
  DataTableDeleteValueIdentifier[];
export const DataTableDeleteValueIdentifierList = S.Array(
  DataTableDeleteValueIdentifier,
);
export interface BatchDeleteDataTableValueRequest {
  InstanceId: string;
  DataTableId: string;
  Values: DataTableDeleteValueIdentifier[];
}
export const BatchDeleteDataTableValueRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    Values: DataTableDeleteValueIdentifierList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/values/delete",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "BatchDeleteDataTableValueRequest",
}) as any as S.Schema<BatchDeleteDataTableValueRequest>;
export interface BatchDeleteDataTableValueSuccessResult {
  PrimaryValues: PrimaryValue[];
  AttributeName: string;
  LockVersion: DataTableLockVersion;
}
export const BatchDeleteDataTableValueSuccessResult = S.suspend(() =>
  S.Struct({
    PrimaryValues: PrimaryValuesSet,
    AttributeName: S.String,
    LockVersion: DataTableLockVersion,
  }),
).annotate({
  identifier: "BatchDeleteDataTableValueSuccessResult",
}) as any as S.Schema<BatchDeleteDataTableValueSuccessResult>;
export type BatchDeleteDataTableValueSuccessResultList =
  BatchDeleteDataTableValueSuccessResult[];
export const BatchDeleteDataTableValueSuccessResultList = S.Array(
  BatchDeleteDataTableValueSuccessResult,
);
export interface BatchDeleteDataTableValueFailureResult {
  PrimaryValues: PrimaryValue[];
  AttributeName: string;
  Message: string;
}
export const BatchDeleteDataTableValueFailureResult = S.suspend(() =>
  S.Struct({
    PrimaryValues: PrimaryValuesSet,
    AttributeName: S.String,
    Message: S.String,
  }),
).annotate({
  identifier: "BatchDeleteDataTableValueFailureResult",
}) as any as S.Schema<BatchDeleteDataTableValueFailureResult>;
export type BatchDeleteDataTableValueFailureResultList =
  BatchDeleteDataTableValueFailureResult[];
export const BatchDeleteDataTableValueFailureResultList = S.Array(
  BatchDeleteDataTableValueFailureResult,
);
export interface BatchDeleteDataTableValueResponse {
  Successful: BatchDeleteDataTableValueSuccessResult[];
  Failed: BatchDeleteDataTableValueFailureResult[];
}
export const BatchDeleteDataTableValueResponse = S.suspend(() =>
  S.Struct({
    Successful: BatchDeleteDataTableValueSuccessResultList,
    Failed: BatchDeleteDataTableValueFailureResultList,
  }),
).annotate({
  identifier: "BatchDeleteDataTableValueResponse",
}) as any as S.Schema<BatchDeleteDataTableValueResponse>;
export interface DataTableValueIdentifier {
  PrimaryValues?: PrimaryValue[];
  AttributeName: string;
}
export const DataTableValueIdentifier = S.suspend(() =>
  S.Struct({
    PrimaryValues: S.optional(PrimaryValuesSet),
    AttributeName: S.String,
  }),
).annotate({
  identifier: "DataTableValueIdentifier",
}) as any as S.Schema<DataTableValueIdentifier>;
export type DataTableValueIdentifierList = DataTableValueIdentifier[];
export const DataTableValueIdentifierList = S.Array(DataTableValueIdentifier);
export interface BatchDescribeDataTableValueRequest {
  InstanceId: string;
  DataTableId: string;
  Values: DataTableValueIdentifier[];
}
export const BatchDescribeDataTableValueRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    Values: DataTableValueIdentifierList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/values/describe",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "BatchDescribeDataTableValueRequest",
}) as any as S.Schema<BatchDescribeDataTableValueRequest>;
export interface PrimaryValueResponse {
  AttributeName?: string;
  AttributeId?: string;
  Value?: string;
}
export const PrimaryValueResponse = S.suspend(() =>
  S.Struct({
    AttributeName: S.optional(S.String),
    AttributeId: S.optional(S.String),
    Value: S.optional(S.String),
  }),
).annotate({
  identifier: "PrimaryValueResponse",
}) as any as S.Schema<PrimaryValueResponse>;
export type PrimaryValuesResponseSet = PrimaryValueResponse[];
export const PrimaryValuesResponseSet = S.Array(PrimaryValueResponse);
export interface BatchDescribeDataTableValueSuccessResult {
  RecordId: string;
  AttributeId: string;
  PrimaryValues: PrimaryValueResponse[];
  AttributeName: string;
  Value?: string;
  LockVersion: DataTableLockVersion;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const BatchDescribeDataTableValueSuccessResult = S.suspend(() =>
  S.Struct({
    RecordId: S.String,
    AttributeId: S.String,
    PrimaryValues: PrimaryValuesResponseSet,
    AttributeName: S.String,
    Value: S.optional(S.String),
    LockVersion: DataTableLockVersion,
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "BatchDescribeDataTableValueSuccessResult",
}) as any as S.Schema<BatchDescribeDataTableValueSuccessResult>;
export type BatchDescribeDataTableValueSuccessResultList =
  BatchDescribeDataTableValueSuccessResult[];
export const BatchDescribeDataTableValueSuccessResultList = S.Array(
  BatchDescribeDataTableValueSuccessResult,
);
export interface BatchDescribeDataTableValueFailureResult {
  PrimaryValues: PrimaryValue[];
  AttributeName: string;
  Message: string;
}
export const BatchDescribeDataTableValueFailureResult = S.suspend(() =>
  S.Struct({
    PrimaryValues: PrimaryValuesSet,
    AttributeName: S.String,
    Message: S.String,
  }),
).annotate({
  identifier: "BatchDescribeDataTableValueFailureResult",
}) as any as S.Schema<BatchDescribeDataTableValueFailureResult>;
export type BatchDescribeDataTableValueFailureResultList =
  BatchDescribeDataTableValueFailureResult[];
export const BatchDescribeDataTableValueFailureResultList = S.Array(
  BatchDescribeDataTableValueFailureResult,
);
export interface BatchDescribeDataTableValueResponse {
  Successful: BatchDescribeDataTableValueSuccessResult[];
  Failed: BatchDescribeDataTableValueFailureResult[];
}
export const BatchDescribeDataTableValueResponse = S.suspend(() =>
  S.Struct({
    Successful: BatchDescribeDataTableValueSuccessResultList,
    Failed: BatchDescribeDataTableValueFailureResultList,
  }),
).annotate({
  identifier: "BatchDescribeDataTableValueResponse",
}) as any as S.Schema<BatchDescribeDataTableValueResponse>;
export interface BatchDisassociateAnalyticsDataSetRequest {
  InstanceId: string;
  DataSetIds: string[];
  TargetAccountId?: string;
}
export const BatchDisassociateAnalyticsDataSetRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataSetIds: DataSetIds,
    TargetAccountId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/analytics-data/instance/{InstanceId}/associations",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "BatchDisassociateAnalyticsDataSetRequest",
}) as any as S.Schema<BatchDisassociateAnalyticsDataSetRequest>;
export interface BatchDisassociateAnalyticsDataSetResponse {
  Deleted?: string[];
  Errors?: ErrorResult[];
}
export const BatchDisassociateAnalyticsDataSetResponse = S.suspend(() =>
  S.Struct({
    Deleted: S.optional(DataSetIds),
    Errors: S.optional(ErrorResults),
  }),
).annotate({
  identifier: "BatchDisassociateAnalyticsDataSetResponse",
}) as any as S.Schema<BatchDisassociateAnalyticsDataSetResponse>;
export type FileIdList = string[];
export const FileIdList = S.Array(S.String);
export interface BatchGetAttachedFileMetadataRequest {
  FileIds: string[];
  InstanceId: string;
  AssociatedResourceArn: string;
}
export const BatchGetAttachedFileMetadataRequest = S.suspend(() =>
  S.Struct({
    FileIds: FileIdList,
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AssociatedResourceArn: S.String.pipe(T.HttpQuery("associatedResourceArn")),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/attached-files/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "BatchGetAttachedFileMetadataRequest",
}) as any as S.Schema<BatchGetAttachedFileMetadataRequest>;
export type FileStatusType =
  | "APPROVED"
  | "REJECTED"
  | "PROCESSING"
  | "FAILED"
  | (string & {});
export const FileStatusType = S.String;
export type CreatedByInfo =
  | { ConnectUserArn: string; AWSIdentityArn?: never }
  | { ConnectUserArn?: never; AWSIdentityArn: string };
export const CreatedByInfo = S.Union([
  S.Struct({ ConnectUserArn: S.String }),
  S.Struct({ AWSIdentityArn: S.String }),
]);
export type FileUseCaseType = "EMAIL_MESSAGE" | "ATTACHMENT" | (string & {});
export const FileUseCaseType = S.String;
export type TagMap = { [key: string]: string | undefined };
export const TagMap = S.Record(S.String, S.String.pipe(S.optional));
export interface AttachedFile {
  CreationTime: string;
  FileArn: string;
  FileId: string;
  FileName: string;
  FileSizeInBytes: number;
  FileStatus: FileStatusType;
  CreatedBy?: CreatedByInfo;
  FileUseCaseType?: FileUseCaseType;
  AssociatedResourceArn?: string;
  Tags?: { [key: string]: string | undefined };
}
export const AttachedFile = S.suspend(() =>
  S.Struct({
    CreationTime: S.String,
    FileArn: S.String,
    FileId: S.String,
    FileName: S.String,
    FileSizeInBytes: S.Number,
    FileStatus: FileStatusType,
    CreatedBy: S.optional(CreatedByInfo),
    FileUseCaseType: S.optional(FileUseCaseType),
    AssociatedResourceArn: S.optional(S.String),
    Tags: S.optional(TagMap),
  }),
).annotate({ identifier: "AttachedFile" }) as any as S.Schema<AttachedFile>;
export type AttachedFilesList = AttachedFile[];
export const AttachedFilesList = S.Array(AttachedFile);
export interface AttachedFileError {
  ErrorCode?: string;
  ErrorMessage?: string;
  FileId?: string;
}
export const AttachedFileError = S.suspend(() =>
  S.Struct({
    ErrorCode: S.optional(S.String),
    ErrorMessage: S.optional(S.String),
    FileId: S.optional(S.String),
  }),
).annotate({
  identifier: "AttachedFileError",
}) as any as S.Schema<AttachedFileError>;
export type AttachedFileErrorsList = AttachedFileError[];
export const AttachedFileErrorsList = S.Array(AttachedFileError);
export interface BatchGetAttachedFileMetadataResponse {
  Files?: AttachedFile[];
  Errors?: AttachedFileError[];
}
export const BatchGetAttachedFileMetadataResponse = S.suspend(() =>
  S.Struct({
    Files: S.optional(AttachedFilesList),
    Errors: S.optional(AttachedFileErrorsList),
  }),
).annotate({
  identifier: "BatchGetAttachedFileMetadataResponse",
}) as any as S.Schema<BatchGetAttachedFileMetadataResponse>;
export type ResourceArnListMaxLimit100 = string[];
export const ResourceArnListMaxLimit100 = S.Array(S.String);
export type ListFlowAssociationResourceType =
  | "WHATSAPP_MESSAGING_PHONE_NUMBER"
  | "VOICE_PHONE_NUMBER"
  | "INBOUND_EMAIL"
  | "OUTBOUND_EMAIL"
  | "ANALYTICS_CONNECTOR"
  | (string & {});
export const ListFlowAssociationResourceType = S.String;
export interface BatchGetFlowAssociationRequest {
  InstanceId: string;
  ResourceIds: string[];
  ResourceType?: ListFlowAssociationResourceType;
}
export const BatchGetFlowAssociationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ResourceIds: ResourceArnListMaxLimit100,
    ResourceType: S.optional(ListFlowAssociationResourceType),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/flow-associations-batch/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "BatchGetFlowAssociationRequest",
}) as any as S.Schema<BatchGetFlowAssociationRequest>;
export interface FlowAssociationSummary {
  ResourceId?: string;
  FlowId?: string;
  ResourceType?: ListFlowAssociationResourceType;
}
export const FlowAssociationSummary = S.suspend(() =>
  S.Struct({
    ResourceId: S.optional(S.String),
    FlowId: S.optional(S.String),
    ResourceType: S.optional(ListFlowAssociationResourceType),
  }),
).annotate({
  identifier: "FlowAssociationSummary",
}) as any as S.Schema<FlowAssociationSummary>;
export type FlowAssociationSummaryList = FlowAssociationSummary[];
export const FlowAssociationSummaryList = S.Array(FlowAssociationSummary);
export interface BatchGetFlowAssociationResponse {
  FlowAssociationSummaryList?: FlowAssociationSummary[];
}
export const BatchGetFlowAssociationResponse = S.suspend(() =>
  S.Struct({
    FlowAssociationSummaryList: S.optional(FlowAssociationSummaryList),
  }),
).annotate({
  identifier: "BatchGetFlowAssociationResponse",
}) as any as S.Schema<BatchGetFlowAssociationResponse>;
export type EndpointType =
  | "TELEPHONE_NUMBER"
  | "VOIP"
  | "CONTACT_FLOW"
  | "CONNECT_PHONENUMBER_ARN"
  | "EMAIL_ADDRESS"
  | (string & {});
export const EndpointType = S.String;
export interface Endpoint {
  Type?: EndpointType;
  Address?: string;
}
export const Endpoint = S.suspend(() =>
  S.Struct({ Type: S.optional(EndpointType), Address: S.optional(S.String) }),
).annotate({ identifier: "Endpoint" }) as any as S.Schema<Endpoint>;
export type Attributes = { [key: string]: string | undefined };
export const Attributes = S.Record(S.String, S.String.pipe(S.optional));
export interface Campaign {
  CampaignId?: string;
}
export const Campaign = S.suspend(() =>
  S.Struct({ CampaignId: S.optional(S.String) }),
).annotate({ identifier: "Campaign" }) as any as S.Schema<Campaign>;
export type OutboundStrategyType = "AGENT_FIRST" | (string & {});
export const OutboundStrategyType = S.String;
export interface PostAcceptTimeoutConfig {
  DurationInSeconds: number;
}
export const PostAcceptTimeoutConfig = S.suspend(() =>
  S.Struct({ DurationInSeconds: S.Number }),
).annotate({
  identifier: "PostAcceptTimeoutConfig",
}) as any as S.Schema<PostAcceptTimeoutConfig>;
export type AllowedUserAction = "CALL" | "DISCARD" | (string & {});
export const AllowedUserAction = S.String;
export type AllowedUserActions = AllowedUserAction[];
export const AllowedUserActions = S.Array(AllowedUserAction);
export interface Preview {
  PostAcceptTimeoutConfig: PostAcceptTimeoutConfig;
  AllowedUserActions: AllowedUserAction[];
}
export const Preview = S.suspend(() =>
  S.Struct({
    PostAcceptTimeoutConfig: PostAcceptTimeoutConfig,
    AllowedUserActions: AllowedUserActions,
  }),
).annotate({ identifier: "Preview" }) as any as S.Schema<Preview>;
export interface AgentFirst {
  Preview?: Preview;
}
export const AgentFirst = S.suspend(() =>
  S.Struct({ Preview: S.optional(Preview) }),
).annotate({ identifier: "AgentFirst" }) as any as S.Schema<AgentFirst>;
export interface OutboundStrategyConfig {
  AgentFirst?: AgentFirst;
}
export const OutboundStrategyConfig = S.suspend(() =>
  S.Struct({ AgentFirst: S.optional(AgentFirst) }),
).annotate({
  identifier: "OutboundStrategyConfig",
}) as any as S.Schema<OutboundStrategyConfig>;
export interface OutboundStrategy {
  Type: OutboundStrategyType;
  Config?: OutboundStrategyConfig;
}
export const OutboundStrategy = S.suspend(() =>
  S.Struct({
    Type: OutboundStrategyType,
    Config: S.optional(OutboundStrategyConfig),
  }),
).annotate({
  identifier: "OutboundStrategy",
}) as any as S.Schema<OutboundStrategy>;
export interface ContactDataRequest {
  SystemEndpoint?: Endpoint;
  CustomerEndpoint?: Endpoint;
  RequestIdentifier?: string;
  QueueId?: string;
  Attributes?: { [key: string]: string | undefined };
  Campaign?: Campaign;
  OutboundStrategy?: OutboundStrategy;
}
export const ContactDataRequest = S.suspend(() =>
  S.Struct({
    SystemEndpoint: S.optional(Endpoint),
    CustomerEndpoint: S.optional(Endpoint),
    RequestIdentifier: S.optional(S.String),
    QueueId: S.optional(S.String),
    Attributes: S.optional(Attributes),
    Campaign: S.optional(Campaign),
    OutboundStrategy: S.optional(OutboundStrategy),
  }),
).annotate({
  identifier: "ContactDataRequest",
}) as any as S.Schema<ContactDataRequest>;
export type ContactDataRequestList = ContactDataRequest[];
export const ContactDataRequestList = S.Array(ContactDataRequest);
export interface BatchPutContactRequest {
  ClientToken?: string;
  InstanceId: string;
  ContactDataRequestList: ContactDataRequest[];
}
export const BatchPutContactRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactDataRequestList: ContactDataRequestList,
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/batch/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "BatchPutContactRequest",
}) as any as S.Schema<BatchPutContactRequest>;
export interface SuccessfulRequest {
  RequestIdentifier?: string;
  ContactId?: string;
}
export const SuccessfulRequest = S.suspend(() =>
  S.Struct({
    RequestIdentifier: S.optional(S.String),
    ContactId: S.optional(S.String),
  }),
).annotate({
  identifier: "SuccessfulRequest",
}) as any as S.Schema<SuccessfulRequest>;
export type SuccessfulRequestList = SuccessfulRequest[];
export const SuccessfulRequestList = S.Array(SuccessfulRequest);
export type FailureReasonCode =
  | "INVALID_ATTRIBUTE_KEY"
  | "INVALID_CUSTOMER_ENDPOINT"
  | "INVALID_SYSTEM_ENDPOINT"
  | "INVALID_QUEUE"
  | "INVALID_OUTBOUND_STRATEGY"
  | "MISSING_CAMPAIGN"
  | "MISSING_CUSTOMER_ENDPOINT"
  | "MISSING_QUEUE_ID_AND_SYSTEM_ENDPOINT"
  | "REQUEST_THROTTLED"
  | "IDEMPOTENCY_EXCEPTION"
  | "INTERNAL_ERROR"
  | (string & {});
export const FailureReasonCode = S.String;
export interface FailedRequest {
  RequestIdentifier?: string;
  FailureReasonCode?: FailureReasonCode;
  FailureReasonMessage?: string;
}
export const FailedRequest = S.suspend(() =>
  S.Struct({
    RequestIdentifier: S.optional(S.String),
    FailureReasonCode: S.optional(FailureReasonCode),
    FailureReasonMessage: S.optional(S.String),
  }),
).annotate({ identifier: "FailedRequest" }) as any as S.Schema<FailedRequest>;
export type FailedRequestList = FailedRequest[];
export const FailedRequestList = S.Array(FailedRequest);
export interface BatchPutContactResponse {
  SuccessfulRequestList?: SuccessfulRequest[];
  FailedRequestList?: FailedRequest[];
}
export const BatchPutContactResponse = S.suspend(() =>
  S.Struct({
    SuccessfulRequestList: S.optional(SuccessfulRequestList),
    FailedRequestList: S.optional(FailedRequestList),
  }),
).annotate({
  identifier: "BatchPutContactResponse",
}) as any as S.Schema<BatchPutContactResponse>;
export interface BatchUpdateDataTableValueRequest {
  InstanceId: string;
  DataTableId: string;
  Values: DataTableValue[];
}
export const BatchUpdateDataTableValueRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    Values: DataTableValueList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/values/update",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "BatchUpdateDataTableValueRequest",
}) as any as S.Schema<BatchUpdateDataTableValueRequest>;
export interface BatchUpdateDataTableValueSuccessResult {
  PrimaryValues: PrimaryValue[];
  AttributeName: string;
  LockVersion: DataTableLockVersion;
}
export const BatchUpdateDataTableValueSuccessResult = S.suspend(() =>
  S.Struct({
    PrimaryValues: PrimaryValuesSet,
    AttributeName: S.String,
    LockVersion: DataTableLockVersion,
  }),
).annotate({
  identifier: "BatchUpdateDataTableValueSuccessResult",
}) as any as S.Schema<BatchUpdateDataTableValueSuccessResult>;
export type BatchUpdateDataTableValueSuccessResultList =
  BatchUpdateDataTableValueSuccessResult[];
export const BatchUpdateDataTableValueSuccessResultList = S.Array(
  BatchUpdateDataTableValueSuccessResult,
);
export interface BatchUpdateDataTableValueFailureResult {
  PrimaryValues: PrimaryValue[];
  AttributeName: string;
  Message: string;
}
export const BatchUpdateDataTableValueFailureResult = S.suspend(() =>
  S.Struct({
    PrimaryValues: PrimaryValuesSet,
    AttributeName: S.String,
    Message: S.String,
  }),
).annotate({
  identifier: "BatchUpdateDataTableValueFailureResult",
}) as any as S.Schema<BatchUpdateDataTableValueFailureResult>;
export type BatchUpdateDataTableValueFailureResultList =
  BatchUpdateDataTableValueFailureResult[];
export const BatchUpdateDataTableValueFailureResultList = S.Array(
  BatchUpdateDataTableValueFailureResult,
);
export interface BatchUpdateDataTableValueResponse {
  Successful: BatchUpdateDataTableValueSuccessResult[];
  Failed: BatchUpdateDataTableValueFailureResult[];
}
export const BatchUpdateDataTableValueResponse = S.suspend(() =>
  S.Struct({
    Successful: BatchUpdateDataTableValueSuccessResultList,
    Failed: BatchUpdateDataTableValueFailureResultList,
  }),
).annotate({
  identifier: "BatchUpdateDataTableValueResponse",
}) as any as S.Schema<BatchUpdateDataTableValueResponse>;
export interface ClaimPhoneNumberRequest {
  TargetArn?: string;
  InstanceId?: string;
  PhoneNumber: string;
  PhoneNumberDescription?: string;
  Tags?: { [key: string]: string | undefined };
  ClientToken?: string;
}
export const ClaimPhoneNumberRequest = S.suspend(() =>
  S.Struct({
    TargetArn: S.optional(S.String),
    InstanceId: S.optional(S.String),
    PhoneNumber: S.String,
    PhoneNumberDescription: S.optional(S.String),
    Tags: S.optional(TagMap),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/phone-number/claim" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ClaimPhoneNumberRequest",
}) as any as S.Schema<ClaimPhoneNumberRequest>;
export interface ClaimPhoneNumberResponse {
  PhoneNumberId?: string;
  PhoneNumberArn?: string;
}
export const ClaimPhoneNumberResponse = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.optional(S.String),
    PhoneNumberArn: S.optional(S.String),
  }),
).annotate({
  identifier: "ClaimPhoneNumberResponse",
}) as any as S.Schema<ClaimPhoneNumberResponse>;
export interface CompleteAttachedFileUploadRequest {
  InstanceId: string;
  FileId: string;
  AssociatedResourceArn: string;
}
export const CompleteAttachedFileUploadRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    FileId: S.String.pipe(T.HttpLabel("FileId")),
    AssociatedResourceArn: S.String.pipe(T.HttpQuery("associatedResourceArn")),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/attached-files/{InstanceId}/{FileId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CompleteAttachedFileUploadRequest",
}) as any as S.Schema<CompleteAttachedFileUploadRequest>;
export interface CompleteAttachedFileUploadResponse {}
export const CompleteAttachedFileUploadResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "CompleteAttachedFileUploadResponse",
}) as any as S.Schema<CompleteAttachedFileUploadResponse>;
export type AgentStatusState = "ENABLED" | "DISABLED" | (string & {});
export const AgentStatusState = S.String;
export interface CreateAgentStatusRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  State: AgentStatusState;
  DisplayOrder?: number;
  Tags?: { [key: string]: string | undefined };
}
export const CreateAgentStatusRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    State: AgentStatusState,
    DisplayOrder: S.optional(S.Number),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/agent-status/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateAgentStatusRequest",
}) as any as S.Schema<CreateAgentStatusRequest>;
export interface CreateAgentStatusResponse {
  AgentStatusARN?: string;
  AgentStatusId?: string;
}
export const CreateAgentStatusResponse = S.suspend(() =>
  S.Struct({
    AgentStatusARN: S.optional(S.String),
    AgentStatusId: S.optional(S.String),
  }),
).annotate({
  identifier: "CreateAgentStatusResponse",
}) as any as S.Schema<CreateAgentStatusResponse>;
export type ReferenceType =
  | "URL"
  | "ATTACHMENT"
  | "CONTACT_ANALYSIS"
  | "NUMBER"
  | "STRING"
  | "DATE"
  | "EMAIL"
  | "EMAIL_MESSAGE"
  | "EMAIL_MESSAGE_PLAIN_TEXT"
  | (string & {});
export const ReferenceType = S.String;
export type ReferenceStatus =
  | "AVAILABLE"
  | "DELETED"
  | "APPROVED"
  | "REJECTED"
  | "PROCESSING"
  | "FAILED"
  | (string & {});
export const ReferenceStatus = S.String;
export interface Reference {
  Value?: string;
  Type: ReferenceType;
  Status?: ReferenceStatus;
  Arn?: string;
  StatusReason?: string;
}
export const Reference = S.suspend(() =>
  S.Struct({
    Value: S.optional(S.String),
    Type: ReferenceType,
    Status: S.optional(ReferenceStatus),
    Arn: S.optional(S.String),
    StatusReason: S.optional(S.String),
  }),
).annotate({ identifier: "Reference" }) as any as S.Schema<Reference>;
export type ContactReferences = { [key: string]: Reference | undefined };
export const ContactReferences = S.Record(S.String, Reference.pipe(S.optional));
export type ContactInitiationMethod =
  | "INBOUND"
  | "OUTBOUND"
  | "TRANSFER"
  | "QUEUE_TRANSFER"
  | "CALLBACK"
  | "API"
  | "DISCONNECT"
  | "MONITOR"
  | "EXTERNAL_OUTBOUND"
  | "WEBRTC_API"
  | "AGENT_REPLY"
  | "FLOW"
  | (string & {});
export const ContactInitiationMethod = S.String;
export interface UserInfo {
  UserId?: string;
}
export const UserInfo = S.suspend(() =>
  S.Struct({ UserId: S.optional(S.String) }),
).annotate({ identifier: "UserInfo" }) as any as S.Schema<UserInfo>;
export type InitiateAs = "CONNECTED_TO_USER" | "COMPLETED" | (string & {});
export const InitiateAs = S.String;
export type SegmentAttributeValueMap = {
  [key: string]: SegmentAttributeValue | undefined;
};
export const SegmentAttributeValueMap = S.Record(
  S.String,
  S.suspend((): S.Schema<SegmentAttributeValue> => SegmentAttributeValue)
    .annotate({ identifier: "SegmentAttributeValue" })
    .pipe(S.optional),
) as any as S.Schema<SegmentAttributeValueMap>;
export type SegmentAttributeValueList = SegmentAttributeValue[];
export const SegmentAttributeValueList = S.Array(
  S.suspend(
    (): S.Schema<SegmentAttributeValue> => SegmentAttributeValue,
  ).annotate({ identifier: "SegmentAttributeValue" }),
) as any as S.Schema<SegmentAttributeValueList>;
export interface SegmentAttributeValue {
  ValueString?: string;
  ValueMap?: { [key: string]: SegmentAttributeValue | undefined };
  ValueInteger?: number;
  ValueList?: SegmentAttributeValue[];
  ValueArn?: string;
}
export const SegmentAttributeValue = S.suspend(() =>
  S.Struct({
    ValueString: S.optional(S.String),
    ValueMap: S.optional(
      S.suspend(() => SegmentAttributeValueMap).annotate({
        identifier: "SegmentAttributeValueMap",
      }),
    ),
    ValueInteger: S.optional(S.Number),
    ValueList: S.optional(
      S.suspend(() => SegmentAttributeValueList).annotate({
        identifier: "SegmentAttributeValueList",
      }),
    ),
    ValueArn: S.optional(S.String),
  }),
).annotate({
  identifier: "SegmentAttributeValue",
}) as any as S.Schema<SegmentAttributeValue>;
export type SegmentAttributes = {
  [key: string]: SegmentAttributeValue | undefined;
};
export const SegmentAttributes = S.Record(
  S.String,
  S.suspend((): S.Schema<SegmentAttributeValue> => SegmentAttributeValue)
    .annotate({ identifier: "SegmentAttributeValue" })
    .pipe(S.optional),
);
export interface CreateContactRequest {
  InstanceId: string;
  ClientToken?: string;
  RelatedContactId?: string;
  Attributes?: { [key: string]: string | undefined };
  References?: { [key: string]: Reference | undefined };
  Channel: Channel;
  InitiationMethod: ContactInitiationMethod;
  ExpiryDurationInMinutes?: number;
  UserInfo?: UserInfo;
  InitiateAs?: InitiateAs;
  Name?: string | redacted.Redacted<string>;
  Description?: string | redacted.Redacted<string>;
  SegmentAttributes?: { [key: string]: SegmentAttributeValue | undefined };
  PreviousContactId?: string;
}
export const CreateContactRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    RelatedContactId: S.optional(S.String),
    Attributes: S.optional(Attributes),
    References: S.optional(ContactReferences),
    Channel: Channel,
    InitiationMethod: ContactInitiationMethod,
    ExpiryDurationInMinutes: S.optional(S.Number),
    UserInfo: S.optional(UserInfo),
    InitiateAs: S.optional(InitiateAs),
    Name: S.optional(SensitiveString),
    Description: S.optional(SensitiveString),
    SegmentAttributes: S.optional(SegmentAttributes),
    PreviousContactId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/create-contact" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateContactRequest",
}) as any as S.Schema<CreateContactRequest>;
export interface CreateContactResponse {
  ContactId?: string;
  ContactArn?: string;
}
export const CreateContactResponse = S.suspend(() =>
  S.Struct({
    ContactId: S.optional(S.String),
    ContactArn: S.optional(S.String),
  }),
).annotate({
  identifier: "CreateContactResponse",
}) as any as S.Schema<CreateContactResponse>;
export type ContactFlowType =
  | "CONTACT_FLOW"
  | "CUSTOMER_QUEUE"
  | "CUSTOMER_HOLD"
  | "CUSTOMER_WHISPER"
  | "AGENT_HOLD"
  | "AGENT_WHISPER"
  | "OUTBOUND_WHISPER"
  | "AGENT_TRANSFER"
  | "QUEUE_TRANSFER"
  | "CAMPAIGN"
  | (string & {});
export const ContactFlowType = S.String;
export type ContactFlowStatus = "PUBLISHED" | "SAVED" | (string & {});
export const ContactFlowStatus = S.String;
export interface CreateContactFlowRequest {
  InstanceId: string;
  Name: string;
  Type: ContactFlowType;
  Description?: string;
  Content: string;
  Status?: ContactFlowStatus;
  Tags?: { [key: string]: string | undefined };
}
export const CreateContactFlowRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Type: ContactFlowType,
    Description: S.optional(S.String),
    Content: S.String,
    Status: S.optional(ContactFlowStatus),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact-flows/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateContactFlowRequest",
}) as any as S.Schema<CreateContactFlowRequest>;
export interface CreateContactFlowResponse {
  ContactFlowId?: string;
  ContactFlowArn?: string;
  FlowContentSha256?: string;
}
export const CreateContactFlowResponse = S.suspend(() =>
  S.Struct({
    ContactFlowId: S.optional(S.String),
    ContactFlowArn: S.optional(S.String),
    FlowContentSha256: S.optional(S.String),
  }),
).annotate({
  identifier: "CreateContactFlowResponse",
}) as any as S.Schema<CreateContactFlowResponse>;
export interface ProblemDetail {
  message?: string;
}
export const ProblemDetail = S.suspend(() =>
  S.Struct({ message: S.optional(S.String) }),
).annotate({ identifier: "ProblemDetail" }) as any as S.Schema<ProblemDetail>;
export type Problems = ProblemDetail[];
export const Problems = S.Array(ProblemDetail);
export interface ExternalInvocationConfiguration {
  Enabled?: boolean;
}
export const ExternalInvocationConfiguration = S.suspend(() =>
  S.Struct({ Enabled: S.optional(S.Boolean) }),
).annotate({
  identifier: "ExternalInvocationConfiguration",
}) as any as S.Schema<ExternalInvocationConfiguration>;
export interface CreateContactFlowModuleRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  Content: string;
  Tags?: { [key: string]: string | undefined };
  ClientToken?: string;
  Settings?: string;
  ExternalInvocationConfiguration?: ExternalInvocationConfiguration;
}
export const CreateContactFlowModuleRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    Content: S.String,
    Tags: S.optional(TagMap),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    Settings: S.optional(S.String),
    ExternalInvocationConfiguration: S.optional(
      ExternalInvocationConfiguration,
    ),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact-flow-modules/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateContactFlowModuleRequest",
}) as any as S.Schema<CreateContactFlowModuleRequest>;
export interface CreateContactFlowModuleResponse {
  Id?: string;
  Arn?: string;
}
export const CreateContactFlowModuleResponse = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String), Arn: S.optional(S.String) }),
).annotate({
  identifier: "CreateContactFlowModuleResponse",
}) as any as S.Schema<CreateContactFlowModuleResponse>;
export interface CreateContactFlowModuleAliasRequest {
  InstanceId: string;
  Description?: string;
  ContactFlowModuleId: string;
  ContactFlowModuleVersion: number;
  AliasName: string;
}
export const CreateContactFlowModuleAliasRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Description: S.optional(S.String),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    ContactFlowModuleVersion: S.Number,
    AliasName: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/alias",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateContactFlowModuleAliasRequest",
}) as any as S.Schema<CreateContactFlowModuleAliasRequest>;
export interface CreateContactFlowModuleAliasResponse {
  ContactFlowModuleArn?: string;
  Id?: string;
}
export const CreateContactFlowModuleAliasResponse = S.suspend(() =>
  S.Struct({
    ContactFlowModuleArn: S.optional(S.String),
    Id: S.optional(S.String),
  }),
).annotate({
  identifier: "CreateContactFlowModuleAliasResponse",
}) as any as S.Schema<CreateContactFlowModuleAliasResponse>;
export interface CreateContactFlowModuleVersionRequest {
  InstanceId: string;
  Description?: string;
  ContactFlowModuleId: string;
  FlowModuleContentSha256?: string;
}
export const CreateContactFlowModuleVersionRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Description: S.optional(S.String),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    FlowModuleContentSha256: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/version",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateContactFlowModuleVersionRequest",
}) as any as S.Schema<CreateContactFlowModuleVersionRequest>;
export interface CreateContactFlowModuleVersionResponse {
  ContactFlowModuleArn?: string;
  Version?: number;
}
export const CreateContactFlowModuleVersionResponse = S.suspend(() =>
  S.Struct({
    ContactFlowModuleArn: S.optional(S.String),
    Version: S.optional(S.Number),
  }),
).annotate({
  identifier: "CreateContactFlowModuleVersionResponse",
}) as any as S.Schema<CreateContactFlowModuleVersionResponse>;
export interface CreateContactFlowVersionRequest {
  InstanceId: string;
  Description?: string;
  ContactFlowId: string;
  FlowContentSha256?: string;
  ContactFlowVersion?: number;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const CreateContactFlowVersionRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Description: S.optional(S.String),
    ContactFlowId: S.String.pipe(T.HttpLabel("ContactFlowId")),
    FlowContentSha256: S.optional(S.String),
    ContactFlowVersion: S.optional(S.Number),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/contact-flows/{InstanceId}/{ContactFlowId}/version",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateContactFlowVersionRequest",
}) as any as S.Schema<CreateContactFlowVersionRequest>;
export interface CreateContactFlowVersionResponse {
  ContactFlowArn?: string;
  Version?: number;
}
export const CreateContactFlowVersionResponse = S.suspend(() =>
  S.Struct({
    ContactFlowArn: S.optional(S.String),
    Version: S.optional(S.Number),
  }),
).annotate({
  identifier: "CreateContactFlowVersionResponse",
}) as any as S.Schema<CreateContactFlowVersionResponse>;
export type DataTableLockLevel =
  | "NONE"
  | "DATA_TABLE"
  | "PRIMARY_VALUE"
  | "ATTRIBUTE"
  | "VALUE"
  | (string & {});
export const DataTableLockLevel = S.String;
export type DataTableStatus = "PUBLISHED" | (string & {});
export const DataTableStatus = S.String;
export interface CreateDataTableRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  TimeZone: string;
  ValueLockLevel: DataTableLockLevel;
  Status: DataTableStatus;
  Tags?: { [key: string]: string | undefined };
}
export const CreateDataTableRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    TimeZone: S.String,
    ValueLockLevel: DataTableLockLevel,
    Status: DataTableStatus,
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/data-tables/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateDataTableRequest",
}) as any as S.Schema<CreateDataTableRequest>;
export interface CreateDataTableResponse {
  Id: string;
  Arn: string;
  LockVersion: DataTableLockVersion;
}
export const CreateDataTableResponse = S.suspend(() =>
  S.Struct({ Id: S.String, Arn: S.String, LockVersion: DataTableLockVersion }),
).annotate({
  identifier: "CreateDataTableResponse",
}) as any as S.Schema<CreateDataTableResponse>;
export type DataTableAttributeValueType =
  | "TEXT"
  | "NUMBER"
  | "BOOLEAN"
  | "TEXT_LIST"
  | "NUMBER_LIST"
  | (string & {});
export const DataTableAttributeValueType = S.String;
export type ValidationEnumValues = string[];
export const ValidationEnumValues = S.Array(S.String);
export interface ValidationEnum {
  Strict?: boolean;
  Values?: string[];
}
export const ValidationEnum = S.suspend(() =>
  S.Struct({
    Strict: S.optional(S.Boolean),
    Values: S.optional(ValidationEnumValues),
  }),
).annotate({ identifier: "ValidationEnum" }) as any as S.Schema<ValidationEnum>;
export interface Validation {
  MinLength?: number;
  MaxLength?: number;
  MinValues?: number;
  MaxValues?: number;
  IgnoreCase?: boolean;
  Minimum?: number;
  Maximum?: number;
  ExclusiveMinimum?: number;
  ExclusiveMaximum?: number;
  MultipleOf?: number;
  Enum?: ValidationEnum;
}
export const Validation = S.suspend(() =>
  S.Struct({
    MinLength: S.optional(S.Number),
    MaxLength: S.optional(S.Number),
    MinValues: S.optional(S.Number),
    MaxValues: S.optional(S.Number),
    IgnoreCase: S.optional(S.Boolean),
    Minimum: S.optional(S.Number),
    Maximum: S.optional(S.Number),
    ExclusiveMinimum: S.optional(S.Number),
    ExclusiveMaximum: S.optional(S.Number),
    MultipleOf: S.optional(S.Number),
    Enum: S.optional(ValidationEnum),
  }),
).annotate({ identifier: "Validation" }) as any as S.Schema<Validation>;
export interface CreateDataTableAttributeRequest {
  InstanceId: string;
  DataTableId: string;
  Name: string;
  ValueType: DataTableAttributeValueType;
  Description?: string;
  Primary?: boolean;
  Validation?: Validation;
}
export const CreateDataTableAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    Name: S.String,
    ValueType: DataTableAttributeValueType,
    Description: S.optional(S.String),
    Primary: S.optional(S.Boolean),
    Validation: S.optional(Validation),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/data-tables/{InstanceId}/{DataTableId}/attributes",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateDataTableAttributeRequest",
}) as any as S.Schema<CreateDataTableAttributeRequest>;
export interface CreateDataTableAttributeResponse {
  Name: string;
  AttributeId?: string;
  LockVersion: DataTableLockVersion;
}
export const CreateDataTableAttributeResponse = S.suspend(() =>
  S.Struct({
    Name: S.String,
    AttributeId: S.optional(S.String),
    LockVersion: DataTableLockVersion,
  }),
).annotate({
  identifier: "CreateDataTableAttributeResponse",
}) as any as S.Schema<CreateDataTableAttributeResponse>;
export interface CreateEmailAddressRequest {
  Description?: string | redacted.Redacted<string>;
  InstanceId: string;
  EmailAddress: string | redacted.Redacted<string>;
  DisplayName?: string | redacted.Redacted<string>;
  Tags?: { [key: string]: string | undefined };
  ClientToken?: string;
}
export const CreateEmailAddressRequest = S.suspend(() =>
  S.Struct({
    Description: S.optional(SensitiveString),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EmailAddress: SensitiveString,
    DisplayName: S.optional(SensitiveString),
    Tags: S.optional(TagMap),
    ClientToken: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/email-addresses/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateEmailAddressRequest",
}) as any as S.Schema<CreateEmailAddressRequest>;
export interface CreateEmailAddressResponse {
  EmailAddressId?: string;
  EmailAddressArn?: string;
}
export const CreateEmailAddressResponse = S.suspend(() =>
  S.Struct({
    EmailAddressId: S.optional(S.String),
    EmailAddressArn: S.optional(S.String),
  }),
).annotate({
  identifier: "CreateEmailAddressResponse",
}) as any as S.Schema<CreateEmailAddressResponse>;
export interface EvaluationFormSection {
  Title: string;
  RefId: string;
  Instructions?: string;
  Items: EvaluationFormItem[];
  Weight?: number;
}
export const EvaluationFormSection = S.suspend(() =>
  S.Struct({
    Title: S.String,
    RefId: S.String,
    Instructions: S.optional(S.String),
    Items: S.suspend(() => EvaluationFormItemsList).annotate({
      identifier: "EvaluationFormItemsList",
    }),
    Weight: S.optional(S.Number),
  }),
).annotate({
  identifier: "EvaluationFormSection",
}) as any as S.Schema<EvaluationFormSection>;
export type EvaluationFormQuestionType =
  | "TEXT"
  | "SINGLESELECT"
  | "NUMERIC"
  | "MULTISELECT"
  | "DATETIME"
  | (string & {});
export const EvaluationFormQuestionType = S.String;
export interface AutomaticFailConfiguration {
  TargetSection?: string;
}
export const AutomaticFailConfiguration = S.suspend(() =>
  S.Struct({ TargetSection: S.optional(S.String) }),
).annotate({
  identifier: "AutomaticFailConfiguration",
}) as any as S.Schema<AutomaticFailConfiguration>;
export interface EvaluationFormNumericQuestionOption {
  MinValue: number;
  MaxValue: number;
  Score?: number;
  AutomaticFail?: boolean;
  AutomaticFailConfiguration?: AutomaticFailConfiguration;
}
export const EvaluationFormNumericQuestionOption = S.suspend(() =>
  S.Struct({
    MinValue: S.Number,
    MaxValue: S.Number,
    Score: S.optional(S.Number),
    AutomaticFail: S.optional(S.Boolean),
    AutomaticFailConfiguration: S.optional(AutomaticFailConfiguration),
  }),
).annotate({
  identifier: "EvaluationFormNumericQuestionOption",
}) as any as S.Schema<EvaluationFormNumericQuestionOption>;
export type EvaluationFormNumericQuestionOptionList =
  EvaluationFormNumericQuestionOption[];
export const EvaluationFormNumericQuestionOptionList = S.Array(
  EvaluationFormNumericQuestionOption,
);
export type NumericQuestionPropertyAutomationLabel =
  | "OVERALL_CUSTOMER_SENTIMENT_SCORE"
  | "OVERALL_AGENT_SENTIMENT_SCORE"
  | "CUSTOMER_SENTIMENT_SCORE_WITHOUT_AGENT"
  | "CUSTOMER_SENTIMENT_SCORE_WITH_AGENT"
  | "NON_TALK_TIME"
  | "NON_TALK_TIME_PERCENTAGE"
  | "NUMBER_OF_INTERRUPTIONS"
  | "CONTACT_DURATION"
  | "AGENT_INTERACTION_DURATION"
  | "CUSTOMER_HOLD_TIME"
  | "LONGEST_HOLD_DURATION"
  | "NUMBER_OF_HOLDS"
  | "AGENT_INTERACTION_AND_HOLD_DURATION"
  | (string & {});
export const NumericQuestionPropertyAutomationLabel = S.String;
export interface NumericQuestionPropertyValueAutomation {
  Label: NumericQuestionPropertyAutomationLabel;
}
export const NumericQuestionPropertyValueAutomation = S.suspend(() =>
  S.Struct({ Label: NumericQuestionPropertyAutomationLabel }),
).annotate({
  identifier: "NumericQuestionPropertyValueAutomation",
}) as any as S.Schema<NumericQuestionPropertyValueAutomation>;
export type EvaluationFormQuestionAutomationAnswerSourceType =
  | "CONTACT_LENS_DATA"
  | "GEN_AI"
  | (string & {});
export const EvaluationFormQuestionAutomationAnswerSourceType = S.String;
export interface EvaluationFormQuestionAutomationAnswerSource {
  SourceType: EvaluationFormQuestionAutomationAnswerSourceType;
}
export const EvaluationFormQuestionAutomationAnswerSource = S.suspend(() =>
  S.Struct({ SourceType: EvaluationFormQuestionAutomationAnswerSourceType }),
).annotate({
  identifier: "EvaluationFormQuestionAutomationAnswerSource",
}) as any as S.Schema<EvaluationFormQuestionAutomationAnswerSource>;
export type EvaluationFormNumericQuestionAutomation =
  | {
      PropertyValue: NumericQuestionPropertyValueAutomation;
      AnswerSource?: never;
    }
  | {
      PropertyValue?: never;
      AnswerSource: EvaluationFormQuestionAutomationAnswerSource;
    };
export const EvaluationFormNumericQuestionAutomation = S.Union([
  S.Struct({ PropertyValue: NumericQuestionPropertyValueAutomation }),
  S.Struct({ AnswerSource: EvaluationFormQuestionAutomationAnswerSource }),
]);
export interface EvaluationFormNumericQuestionProperties {
  MinValue: number;
  MaxValue: number;
  Options?: EvaluationFormNumericQuestionOption[];
  Automation?: EvaluationFormNumericQuestionAutomation;
}
export const EvaluationFormNumericQuestionProperties = S.suspend(() =>
  S.Struct({
    MinValue: S.Number,
    MaxValue: S.Number,
    Options: S.optional(EvaluationFormNumericQuestionOptionList),
    Automation: S.optional(EvaluationFormNumericQuestionAutomation),
  }),
).annotate({
  identifier: "EvaluationFormNumericQuestionProperties",
}) as any as S.Schema<EvaluationFormNumericQuestionProperties>;
export interface EvaluationFormSingleSelectQuestionOption {
  RefId: string;
  Text: string;
  Score?: number;
  AutomaticFail?: boolean;
  AutomaticFailConfiguration?: AutomaticFailConfiguration;
}
export const EvaluationFormSingleSelectQuestionOption = S.suspend(() =>
  S.Struct({
    RefId: S.String,
    Text: S.String,
    Score: S.optional(S.Number),
    AutomaticFail: S.optional(S.Boolean),
    AutomaticFailConfiguration: S.optional(AutomaticFailConfiguration),
  }),
).annotate({
  identifier: "EvaluationFormSingleSelectQuestionOption",
}) as any as S.Schema<EvaluationFormSingleSelectQuestionOption>;
export type EvaluationFormSingleSelectQuestionOptionList =
  EvaluationFormSingleSelectQuestionOption[];
export const EvaluationFormSingleSelectQuestionOptionList = S.Array(
  EvaluationFormSingleSelectQuestionOption,
);
export type EvaluationFormSingleSelectQuestionDisplayMode =
  | "DROPDOWN"
  | "RADIO"
  | (string & {});
export const EvaluationFormSingleSelectQuestionDisplayMode = S.String;
export type SingleSelectQuestionRuleCategoryAutomationCondition =
  | "PRESENT"
  | "NOT_PRESENT"
  | (string & {});
export const SingleSelectQuestionRuleCategoryAutomationCondition = S.String;
export interface SingleSelectQuestionRuleCategoryAutomation {
  Category: string;
  Condition: SingleSelectQuestionRuleCategoryAutomationCondition;
  OptionRefId: string;
}
export const SingleSelectQuestionRuleCategoryAutomation = S.suspend(() =>
  S.Struct({
    Category: S.String,
    Condition: SingleSelectQuestionRuleCategoryAutomationCondition,
    OptionRefId: S.String,
  }),
).annotate({
  identifier: "SingleSelectQuestionRuleCategoryAutomation",
}) as any as S.Schema<SingleSelectQuestionRuleCategoryAutomation>;
export type EvaluationFormSingleSelectQuestionAutomationOption = {
  RuleCategory: SingleSelectQuestionRuleCategoryAutomation;
};
export const EvaluationFormSingleSelectQuestionAutomationOption = S.Union([
  S.Struct({ RuleCategory: SingleSelectQuestionRuleCategoryAutomation }),
]);
export type EvaluationFormSingleSelectQuestionAutomationOptionList =
  EvaluationFormSingleSelectQuestionAutomationOption[];
export const EvaluationFormSingleSelectQuestionAutomationOptionList = S.Array(
  EvaluationFormSingleSelectQuestionAutomationOption,
);
export interface EvaluationFormSingleSelectQuestionAutomation {
  Options?: EvaluationFormSingleSelectQuestionAutomationOption[];
  DefaultOptionRefId?: string;
  AnswerSource?: EvaluationFormQuestionAutomationAnswerSource;
}
export const EvaluationFormSingleSelectQuestionAutomation = S.suspend(() =>
  S.Struct({
    Options: S.optional(EvaluationFormSingleSelectQuestionAutomationOptionList),
    DefaultOptionRefId: S.optional(S.String),
    AnswerSource: S.optional(EvaluationFormQuestionAutomationAnswerSource),
  }),
).annotate({
  identifier: "EvaluationFormSingleSelectQuestionAutomation",
}) as any as S.Schema<EvaluationFormSingleSelectQuestionAutomation>;
export interface EvaluationFormSingleSelectQuestionProperties {
  Options: EvaluationFormSingleSelectQuestionOption[];
  DisplayAs?: EvaluationFormSingleSelectQuestionDisplayMode;
  Automation?: EvaluationFormSingleSelectQuestionAutomation;
}
export const EvaluationFormSingleSelectQuestionProperties = S.suspend(() =>
  S.Struct({
    Options: EvaluationFormSingleSelectQuestionOptionList,
    DisplayAs: S.optional(EvaluationFormSingleSelectQuestionDisplayMode),
    Automation: S.optional(EvaluationFormSingleSelectQuestionAutomation),
  }),
).annotate({
  identifier: "EvaluationFormSingleSelectQuestionProperties",
}) as any as S.Schema<EvaluationFormSingleSelectQuestionProperties>;
export interface EvaluationFormTextQuestionAutomation {
  AnswerSource?: EvaluationFormQuestionAutomationAnswerSource;
}
export const EvaluationFormTextQuestionAutomation = S.suspend(() =>
  S.Struct({
    AnswerSource: S.optional(EvaluationFormQuestionAutomationAnswerSource),
  }),
).annotate({
  identifier: "EvaluationFormTextQuestionAutomation",
}) as any as S.Schema<EvaluationFormTextQuestionAutomation>;
export interface EvaluationFormTextQuestionProperties {
  Automation?: EvaluationFormTextQuestionAutomation;
}
export const EvaluationFormTextQuestionProperties = S.suspend(() =>
  S.Struct({ Automation: S.optional(EvaluationFormTextQuestionAutomation) }),
).annotate({
  identifier: "EvaluationFormTextQuestionProperties",
}) as any as S.Schema<EvaluationFormTextQuestionProperties>;
export interface EvaluationFormMultiSelectQuestionOption {
  RefId: string;
  Text: string;
}
export const EvaluationFormMultiSelectQuestionOption = S.suspend(() =>
  S.Struct({ RefId: S.String, Text: S.String }),
).annotate({
  identifier: "EvaluationFormMultiSelectQuestionOption",
}) as any as S.Schema<EvaluationFormMultiSelectQuestionOption>;
export type EvaluationFormMultiSelectQuestionOptionList =
  EvaluationFormMultiSelectQuestionOption[];
export const EvaluationFormMultiSelectQuestionOptionList = S.Array(
  EvaluationFormMultiSelectQuestionOption,
);
export type EvaluationFormMultiSelectQuestionDisplayMode =
  | "DROPDOWN"
  | "CHECKBOX"
  | (string & {});
export const EvaluationFormMultiSelectQuestionDisplayMode = S.String;
export type MultiSelectQuestionRuleCategoryAutomationCondition =
  | "PRESENT"
  | "NOT_PRESENT"
  | (string & {});
export const MultiSelectQuestionRuleCategoryAutomationCondition = S.String;
export type ReferenceIdList = string[];
export const ReferenceIdList = S.Array(S.String);
export interface MultiSelectQuestionRuleCategoryAutomation {
  Category: string;
  Condition: MultiSelectQuestionRuleCategoryAutomationCondition;
  OptionRefIds: string[];
}
export const MultiSelectQuestionRuleCategoryAutomation = S.suspend(() =>
  S.Struct({
    Category: S.String,
    Condition: MultiSelectQuestionRuleCategoryAutomationCondition,
    OptionRefIds: ReferenceIdList,
  }),
).annotate({
  identifier: "MultiSelectQuestionRuleCategoryAutomation",
}) as any as S.Schema<MultiSelectQuestionRuleCategoryAutomation>;
export type EvaluationFormMultiSelectQuestionAutomationOption = {
  RuleCategory: MultiSelectQuestionRuleCategoryAutomation;
};
export const EvaluationFormMultiSelectQuestionAutomationOption = S.Union([
  S.Struct({ RuleCategory: MultiSelectQuestionRuleCategoryAutomation }),
]);
export type EvaluationFormMultiSelectQuestionAutomationOptionList =
  EvaluationFormMultiSelectQuestionAutomationOption[];
export const EvaluationFormMultiSelectQuestionAutomationOptionList = S.Array(
  EvaluationFormMultiSelectQuestionAutomationOption,
);
export interface EvaluationFormMultiSelectQuestionAutomation {
  Options?: EvaluationFormMultiSelectQuestionAutomationOption[];
  DefaultOptionRefIds?: string[];
  AnswerSource?: EvaluationFormQuestionAutomationAnswerSource;
}
export const EvaluationFormMultiSelectQuestionAutomation = S.suspend(() =>
  S.Struct({
    Options: S.optional(EvaluationFormMultiSelectQuestionAutomationOptionList),
    DefaultOptionRefIds: S.optional(ReferenceIdList),
    AnswerSource: S.optional(EvaluationFormQuestionAutomationAnswerSource),
  }),
).annotate({
  identifier: "EvaluationFormMultiSelectQuestionAutomation",
}) as any as S.Schema<EvaluationFormMultiSelectQuestionAutomation>;
export interface EvaluationFormMultiSelectQuestionProperties {
  Options: EvaluationFormMultiSelectQuestionOption[];
  DisplayAs?: EvaluationFormMultiSelectQuestionDisplayMode;
  Automation?: EvaluationFormMultiSelectQuestionAutomation;
}
export const EvaluationFormMultiSelectQuestionProperties = S.suspend(() =>
  S.Struct({
    Options: EvaluationFormMultiSelectQuestionOptionList,
    DisplayAs: S.optional(EvaluationFormMultiSelectQuestionDisplayMode),
    Automation: S.optional(EvaluationFormMultiSelectQuestionAutomation),
  }),
).annotate({
  identifier: "EvaluationFormMultiSelectQuestionProperties",
}) as any as S.Schema<EvaluationFormMultiSelectQuestionProperties>;
export type EvaluationFormQuestionTypeProperties =
  | {
      Numeric: EvaluationFormNumericQuestionProperties;
      SingleSelect?: never;
      Text?: never;
      MultiSelect?: never;
    }
  | {
      Numeric?: never;
      SingleSelect: EvaluationFormSingleSelectQuestionProperties;
      Text?: never;
      MultiSelect?: never;
    }
  | {
      Numeric?: never;
      SingleSelect?: never;
      Text: EvaluationFormTextQuestionProperties;
      MultiSelect?: never;
    }
  | {
      Numeric?: never;
      SingleSelect?: never;
      Text?: never;
      MultiSelect: EvaluationFormMultiSelectQuestionProperties;
    };
export const EvaluationFormQuestionTypeProperties = S.Union([
  S.Struct({ Numeric: EvaluationFormNumericQuestionProperties }),
  S.Struct({ SingleSelect: EvaluationFormSingleSelectQuestionProperties }),
  S.Struct({ Text: EvaluationFormTextQuestionProperties }),
  S.Struct({ MultiSelect: EvaluationFormMultiSelectQuestionProperties }),
]);
export type EvaluationFormItemEnablementSourceType =
  | "QUESTION_REF_ID"
  | (string & {});
export const EvaluationFormItemEnablementSourceType = S.String;
export interface EvaluationFormItemEnablementSource {
  Type: EvaluationFormItemEnablementSourceType;
  RefId?: string;
}
export const EvaluationFormItemEnablementSource = S.suspend(() =>
  S.Struct({
    Type: EvaluationFormItemEnablementSourceType,
    RefId: S.optional(S.String),
  }),
).annotate({
  identifier: "EvaluationFormItemEnablementSource",
}) as any as S.Schema<EvaluationFormItemEnablementSource>;
export type EvaluationFormItemEnablementSourceValueType =
  | "OPTION_REF_ID"
  | (string & {});
export const EvaluationFormItemEnablementSourceValueType = S.String;
export interface EvaluationFormItemEnablementSourceValue {
  Type: EvaluationFormItemEnablementSourceValueType;
  RefId?: string;
}
export const EvaluationFormItemEnablementSourceValue = S.suspend(() =>
  S.Struct({
    Type: EvaluationFormItemEnablementSourceValueType,
    RefId: S.optional(S.String),
  }),
).annotate({
  identifier: "EvaluationFormItemEnablementSourceValue",
}) as any as S.Schema<EvaluationFormItemEnablementSourceValue>;
export type EvaluationFormItemEnablementSourceValueList =
  EvaluationFormItemEnablementSourceValue[];
export const EvaluationFormItemEnablementSourceValueList = S.Array(
  EvaluationFormItemEnablementSourceValue,
);
export type EvaluationFormItemSourceValuesComparator =
  | "IN"
  | "NOT_IN"
  | "ALL_IN"
  | "EXACT"
  | (string & {});
export const EvaluationFormItemSourceValuesComparator = S.String;
export interface EvaluationFormItemEnablementExpression {
  Source: EvaluationFormItemEnablementSource;
  Values: EvaluationFormItemEnablementSourceValue[];
  Comparator: EvaluationFormItemSourceValuesComparator;
}
export const EvaluationFormItemEnablementExpression = S.suspend(() =>
  S.Struct({
    Source: EvaluationFormItemEnablementSource,
    Values: EvaluationFormItemEnablementSourceValueList,
    Comparator: EvaluationFormItemSourceValuesComparator,
  }),
).annotate({
  identifier: "EvaluationFormItemEnablementExpression",
}) as any as S.Schema<EvaluationFormItemEnablementExpression>;
export type EvaluationFormItemEnablementConditionOperand =
  | { Expression: EvaluationFormItemEnablementExpression; Condition?: never }
  | { Expression?: never; Condition: EvaluationFormItemEnablementCondition };
export const EvaluationFormItemEnablementConditionOperand = S.Union([
  S.Struct({ Expression: EvaluationFormItemEnablementExpression }),
  S.Struct({
    Condition: S.suspend(
      (): S.Schema<EvaluationFormItemEnablementCondition> =>
        EvaluationFormItemEnablementCondition,
    ).annotate({ identifier: "EvaluationFormItemEnablementCondition" }),
  }),
]) as any as S.Schema<EvaluationFormItemEnablementConditionOperand>;
export type EvaluationFormItemEnablementConditionOperandList =
  EvaluationFormItemEnablementConditionOperand[];
export const EvaluationFormItemEnablementConditionOperandList = S.Array(
  S.suspend(() => EvaluationFormItemEnablementConditionOperand).annotate({
    identifier: "EvaluationFormItemEnablementConditionOperand",
  }),
) as any as S.Schema<EvaluationFormItemEnablementConditionOperandList>;
export type EvaluationFormItemEnablementOperator = "OR" | "AND" | (string & {});
export const EvaluationFormItemEnablementOperator = S.String;
export interface EvaluationFormItemEnablementCondition {
  Operands: EvaluationFormItemEnablementConditionOperand[];
  Operator?: EvaluationFormItemEnablementOperator;
}
export const EvaluationFormItemEnablementCondition = S.suspend(() =>
  S.Struct({
    Operands: S.suspend(
      () => EvaluationFormItemEnablementConditionOperandList,
    ).annotate({
      identifier: "EvaluationFormItemEnablementConditionOperandList",
    }),
    Operator: S.optional(EvaluationFormItemEnablementOperator),
  }),
).annotate({
  identifier: "EvaluationFormItemEnablementCondition",
}) as any as S.Schema<EvaluationFormItemEnablementCondition>;
export type EvaluationFormItemEnablementAction =
  | "DISABLE"
  | "ENABLE"
  | (string & {});
export const EvaluationFormItemEnablementAction = S.String;
export interface EvaluationFormItemEnablementConfiguration {
  Condition: EvaluationFormItemEnablementCondition;
  Action: EvaluationFormItemEnablementAction;
  DefaultAction?: EvaluationFormItemEnablementAction;
}
export const EvaluationFormItemEnablementConfiguration = S.suspend(() =>
  S.Struct({
    Condition: EvaluationFormItemEnablementCondition,
    Action: EvaluationFormItemEnablementAction,
    DefaultAction: S.optional(EvaluationFormItemEnablementAction),
  }),
).annotate({
  identifier: "EvaluationFormItemEnablementConfiguration",
}) as any as S.Schema<EvaluationFormItemEnablementConfiguration>;
export interface EvaluationFormQuestion {
  Title: string;
  Instructions?: string;
  RefId: string;
  NotApplicableEnabled?: boolean;
  QuestionType: EvaluationFormQuestionType;
  QuestionTypeProperties?: EvaluationFormQuestionTypeProperties;
  Enablement?: EvaluationFormItemEnablementConfiguration;
  Weight?: number;
}
export const EvaluationFormQuestion = S.suspend(() =>
  S.Struct({
    Title: S.String,
    Instructions: S.optional(S.String),
    RefId: S.String,
    NotApplicableEnabled: S.optional(S.Boolean),
    QuestionType: EvaluationFormQuestionType,
    QuestionTypeProperties: S.optional(EvaluationFormQuestionTypeProperties),
    Enablement: S.optional(EvaluationFormItemEnablementConfiguration),
    Weight: S.optional(S.Number),
  }),
).annotate({
  identifier: "EvaluationFormQuestion",
}) as any as S.Schema<EvaluationFormQuestion>;
export type EvaluationFormItem =
  | { Section: EvaluationFormSection; Question?: never }
  | { Section?: never; Question: EvaluationFormQuestion };
export const EvaluationFormItem = S.Union([
  S.Struct({
    Section: S.suspend(
      (): S.Schema<EvaluationFormSection> => EvaluationFormSection,
    ).annotate({ identifier: "EvaluationFormSection" }),
  }),
  S.Struct({ Question: EvaluationFormQuestion }),
]) as any as S.Schema<EvaluationFormItem>;
export type EvaluationFormItemsList = EvaluationFormItem[];
export const EvaluationFormItemsList = S.Array(
  S.suspend(() => EvaluationFormItem).annotate({
    identifier: "EvaluationFormItem",
  }),
) as any as S.Schema<EvaluationFormItemsList>;
export type EvaluationFormScoringMode =
  | "QUESTION_ONLY"
  | "SECTION_ONLY"
  | (string & {});
export const EvaluationFormScoringMode = S.String;
export type EvaluationFormScoringStatus =
  | "ENABLED"
  | "DISABLED"
  | (string & {});
export const EvaluationFormScoringStatus = S.String;
export interface EvaluationFormScoringStrategy {
  Mode: EvaluationFormScoringMode;
  Status: EvaluationFormScoringStatus;
}
export const EvaluationFormScoringStrategy = S.suspend(() =>
  S.Struct({
    Mode: EvaluationFormScoringMode,
    Status: EvaluationFormScoringStatus,
  }),
).annotate({
  identifier: "EvaluationFormScoringStrategy",
}) as any as S.Schema<EvaluationFormScoringStrategy>;
export interface EvaluationFormAutoEvaluationConfiguration {
  Enabled: boolean;
}
export const EvaluationFormAutoEvaluationConfiguration = S.suspend(() =>
  S.Struct({ Enabled: S.Boolean }),
).annotate({
  identifier: "EvaluationFormAutoEvaluationConfiguration",
}) as any as S.Schema<EvaluationFormAutoEvaluationConfiguration>;
export type EvaluationReviewNotificationRecipientType =
  | "USER_ID"
  | (string & {});
export const EvaluationReviewNotificationRecipientType = S.String;
export interface EvaluationReviewNotificationRecipientValue {
  UserId?: string;
}
export const EvaluationReviewNotificationRecipientValue = S.suspend(() =>
  S.Struct({ UserId: S.optional(S.String) }),
).annotate({
  identifier: "EvaluationReviewNotificationRecipientValue",
}) as any as S.Schema<EvaluationReviewNotificationRecipientValue>;
export interface EvaluationReviewNotificationRecipient {
  Type: EvaluationReviewNotificationRecipientType;
  Value: EvaluationReviewNotificationRecipientValue;
}
export const EvaluationReviewNotificationRecipient = S.suspend(() =>
  S.Struct({
    Type: EvaluationReviewNotificationRecipientType,
    Value: EvaluationReviewNotificationRecipientValue,
  }),
).annotate({
  identifier: "EvaluationReviewNotificationRecipient",
}) as any as S.Schema<EvaluationReviewNotificationRecipient>;
export type EvaluationReviewNotificationRecipientList =
  EvaluationReviewNotificationRecipient[];
export const EvaluationReviewNotificationRecipientList = S.Array(
  EvaluationReviewNotificationRecipient,
);
export interface EvaluationReviewConfiguration {
  ReviewNotificationRecipients: EvaluationReviewNotificationRecipient[];
  EligibilityDays?: number;
}
export const EvaluationReviewConfiguration = S.suspend(() =>
  S.Struct({
    ReviewNotificationRecipients: EvaluationReviewNotificationRecipientList,
    EligibilityDays: S.optional(S.Number),
  }),
).annotate({
  identifier: "EvaluationReviewConfiguration",
}) as any as S.Schema<EvaluationReviewConfiguration>;
export type ContactInteractionType = "AGENT" | "AUTOMATED" | (string & {});
export const ContactInteractionType = S.String;
export interface EvaluationFormTargetConfiguration {
  ContactInteractionType: ContactInteractionType;
}
export const EvaluationFormTargetConfiguration = S.suspend(() =>
  S.Struct({ ContactInteractionType: ContactInteractionType }),
).annotate({
  identifier: "EvaluationFormTargetConfiguration",
}) as any as S.Schema<EvaluationFormTargetConfiguration>;
export type EvaluationFormLanguageCode =
  | "de-DE"
  | "en-US"
  | "es-ES"
  | "fr-FR"
  | "it-IT"
  | "pt-BR"
  | (string & {});
export const EvaluationFormLanguageCode = S.String;
export interface EvaluationFormLanguageConfiguration {
  FormLanguage?: EvaluationFormLanguageCode;
}
export const EvaluationFormLanguageConfiguration = S.suspend(() =>
  S.Struct({ FormLanguage: S.optional(EvaluationFormLanguageCode) }),
).annotate({
  identifier: "EvaluationFormLanguageConfiguration",
}) as any as S.Schema<EvaluationFormLanguageConfiguration>;
export interface CreateEvaluationFormRequest {
  InstanceId: string;
  Title: string;
  Description?: string;
  Items: EvaluationFormItem[];
  ScoringStrategy?: EvaluationFormScoringStrategy;
  AutoEvaluationConfiguration?: EvaluationFormAutoEvaluationConfiguration;
  ClientToken?: string;
  AsDraft?: boolean;
  Tags?: { [key: string]: string | undefined };
  ReviewConfiguration?: EvaluationReviewConfiguration;
  TargetConfiguration?: EvaluationFormTargetConfiguration;
  LanguageConfiguration?: EvaluationFormLanguageConfiguration;
}
export const CreateEvaluationFormRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Title: S.String,
    Description: S.optional(S.String),
    Items: EvaluationFormItemsList,
    ScoringStrategy: S.optional(EvaluationFormScoringStrategy),
    AutoEvaluationConfiguration: S.optional(
      EvaluationFormAutoEvaluationConfiguration,
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    AsDraft: S.optional(S.Boolean),
    Tags: S.optional(TagMap),
    ReviewConfiguration: S.optional(EvaluationReviewConfiguration),
    TargetConfiguration: S.optional(EvaluationFormTargetConfiguration),
    LanguageConfiguration: S.optional(EvaluationFormLanguageConfiguration),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/evaluation-forms/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateEvaluationFormRequest",
}) as any as S.Schema<CreateEvaluationFormRequest>;
export interface CreateEvaluationFormResponse {
  EvaluationFormId: string;
  EvaluationFormArn: string;
}
export const CreateEvaluationFormResponse = S.suspend(() =>
  S.Struct({ EvaluationFormId: S.String, EvaluationFormArn: S.String }),
).annotate({
  identifier: "CreateEvaluationFormResponse",
}) as any as S.Schema<CreateEvaluationFormResponse>;
export type HoursOfOperationDays =
  | "SUNDAY"
  | "MONDAY"
  | "TUESDAY"
  | "WEDNESDAY"
  | "THURSDAY"
  | "FRIDAY"
  | "SATURDAY"
  | (string & {});
export const HoursOfOperationDays = S.String;
export interface HoursOfOperationTimeSlice {
  Hours: number;
  Minutes: number;
}
export const HoursOfOperationTimeSlice = S.suspend(() =>
  S.Struct({ Hours: S.Number, Minutes: S.Number }),
).annotate({
  identifier: "HoursOfOperationTimeSlice",
}) as any as S.Schema<HoursOfOperationTimeSlice>;
export interface HoursOfOperationConfig {
  Day: HoursOfOperationDays;
  StartTime: HoursOfOperationTimeSlice;
  EndTime: HoursOfOperationTimeSlice;
}
export const HoursOfOperationConfig = S.suspend(() =>
  S.Struct({
    Day: HoursOfOperationDays,
    StartTime: HoursOfOperationTimeSlice,
    EndTime: HoursOfOperationTimeSlice,
  }),
).annotate({
  identifier: "HoursOfOperationConfig",
}) as any as S.Schema<HoursOfOperationConfig>;
export type HoursOfOperationConfigList = HoursOfOperationConfig[];
export const HoursOfOperationConfigList = S.Array(HoursOfOperationConfig);
export interface CreateHoursOfOperationRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  TimeZone: string;
  Config: HoursOfOperationConfig[];
  ParentHoursOfOperationConfigs?: ParentHoursOfOperationConfig[];
  Tags?: { [key: string]: string | undefined };
}
export const CreateHoursOfOperationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    TimeZone: S.String,
    Config: HoursOfOperationConfigList,
    ParentHoursOfOperationConfigs: S.optional(ParentHoursOfOperationConfigList),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/hours-of-operations/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateHoursOfOperationRequest",
}) as any as S.Schema<CreateHoursOfOperationRequest>;
export interface CreateHoursOfOperationResponse {
  HoursOfOperationId?: string;
  HoursOfOperationArn?: string;
}
export const CreateHoursOfOperationResponse = S.suspend(() =>
  S.Struct({
    HoursOfOperationId: S.optional(S.String),
    HoursOfOperationArn: S.optional(S.String),
  }),
).annotate({
  identifier: "CreateHoursOfOperationResponse",
}) as any as S.Schema<CreateHoursOfOperationResponse>;
export type OverrideDays =
  | "SUNDAY"
  | "MONDAY"
  | "TUESDAY"
  | "WEDNESDAY"
  | "THURSDAY"
  | "FRIDAY"
  | "SATURDAY"
  | (string & {});
export const OverrideDays = S.String;
export interface OverrideTimeSlice {
  Hours: number;
  Minutes: number;
}
export const OverrideTimeSlice = S.suspend(() =>
  S.Struct({ Hours: S.Number, Minutes: S.Number }),
).annotate({
  identifier: "OverrideTimeSlice",
}) as any as S.Schema<OverrideTimeSlice>;
export interface HoursOfOperationOverrideConfig {
  Day?: OverrideDays;
  StartTime?: OverrideTimeSlice;
  EndTime?: OverrideTimeSlice;
}
export const HoursOfOperationOverrideConfig = S.suspend(() =>
  S.Struct({
    Day: S.optional(OverrideDays),
    StartTime: S.optional(OverrideTimeSlice),
    EndTime: S.optional(OverrideTimeSlice),
  }),
).annotate({
  identifier: "HoursOfOperationOverrideConfig",
}) as any as S.Schema<HoursOfOperationOverrideConfig>;
export type HoursOfOperationOverrideConfigList =
  HoursOfOperationOverrideConfig[];
export const HoursOfOperationOverrideConfigList = S.Array(
  HoursOfOperationOverrideConfig,
);
export type RecurrenceFrequency =
  | "WEEKLY"
  | "MONTHLY"
  | "YEARLY"
  | (string & {});
export const RecurrenceFrequency = S.String;
export type MonthList = number[];
export const MonthList = S.Array(S.Number);
export type MonthDayList = number[];
export const MonthDayList = S.Array(S.Number);
export type WeekdayOccurrenceList = number[];
export const WeekdayOccurrenceList = S.Array(S.Number);
export interface RecurrencePattern {
  Frequency: RecurrenceFrequency;
  Interval: number;
  ByMonth?: number[];
  ByMonthDay?: number[];
  ByWeekdayOccurrence?: number[];
}
export const RecurrencePattern = S.suspend(() =>
  S.Struct({
    Frequency: RecurrenceFrequency,
    Interval: S.Number,
    ByMonth: S.optional(MonthList),
    ByMonthDay: S.optional(MonthDayList),
    ByWeekdayOccurrence: S.optional(WeekdayOccurrenceList),
  }),
).annotate({
  identifier: "RecurrencePattern",
}) as any as S.Schema<RecurrencePattern>;
export interface RecurrenceConfig {
  RecurrencePattern: RecurrencePattern;
}
export const RecurrenceConfig = S.suspend(() =>
  S.Struct({ RecurrencePattern: RecurrencePattern }),
).annotate({
  identifier: "RecurrenceConfig",
}) as any as S.Schema<RecurrenceConfig>;
export type OverrideType = "STANDARD" | "OPEN" | "CLOSED" | (string & {});
export const OverrideType = S.String;
export interface CreateHoursOfOperationOverrideRequest {
  InstanceId: string;
  HoursOfOperationId: string;
  Name: string;
  Description?: string;
  Config: HoursOfOperationOverrideConfig[];
  EffectiveFrom: string;
  EffectiveTill: string;
  RecurrenceConfig?: RecurrenceConfig;
  OverrideType?: OverrideType;
}
export const CreateHoursOfOperationOverrideRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
    Name: S.String,
    Description: S.optional(S.String),
    Config: HoursOfOperationOverrideConfigList,
    EffectiveFrom: S.String,
    EffectiveTill: S.String,
    RecurrenceConfig: S.optional(RecurrenceConfig),
    OverrideType: S.optional(OverrideType),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}/overrides",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateHoursOfOperationOverrideRequest",
}) as any as S.Schema<CreateHoursOfOperationOverrideRequest>;
export interface CreateHoursOfOperationOverrideResponse {
  HoursOfOperationOverrideId?: string;
}
export const CreateHoursOfOperationOverrideResponse = S.suspend(() =>
  S.Struct({ HoursOfOperationOverrideId: S.optional(S.String) }),
).annotate({
  identifier: "CreateHoursOfOperationOverrideResponse",
}) as any as S.Schema<CreateHoursOfOperationOverrideResponse>;
export type DirectoryType =
  | "SAML"
  | "CONNECT_MANAGED"
  | "EXISTING_DIRECTORY"
  | (string & {});
export const DirectoryType = S.String;
export interface CreateInstanceRequest {
  ClientToken?: string;
  IdentityManagementType: DirectoryType;
  InstanceAlias?: string | redacted.Redacted<string>;
  DirectoryId?: string;
  InboundCallsEnabled: boolean;
  OutboundCallsEnabled: boolean;
  Tags?: { [key: string]: string | undefined };
}
export const CreateInstanceRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    IdentityManagementType: DirectoryType,
    InstanceAlias: S.optional(SensitiveString),
    DirectoryId: S.optional(S.String),
    InboundCallsEnabled: S.Boolean,
    OutboundCallsEnabled: S.Boolean,
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/instance" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateInstanceRequest",
}) as any as S.Schema<CreateInstanceRequest>;
export interface CreateInstanceResponse {
  Id?: string;
  Arn?: string;
}
export const CreateInstanceResponse = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String), Arn: S.optional(S.String) }),
).annotate({
  identifier: "CreateInstanceResponse",
}) as any as S.Schema<CreateInstanceResponse>;
export type IntegrationType =
  | "EVENT"
  | "VOICE_ID"
  | "PINPOINT_APP"
  | "WISDOM_ASSISTANT"
  | "WISDOM_KNOWLEDGE_BASE"
  | "WISDOM_QUICK_RESPONSES"
  | "Q_MESSAGE_TEMPLATES"
  | "CASES_DOMAIN"
  | "APPLICATION"
  | "FILE_SCANNER"
  | "SES_IDENTITY"
  | "ANALYTICS_CONNECTOR"
  | "CALL_TRANSFER_CONNECTOR"
  | "COGNITO_USER_POOL"
  | "MESSAGE_PROCESSOR"
  | (string & {});
export const IntegrationType = S.String;
export type SourceType = "SALESFORCE" | "ZENDESK" | "CASES" | (string & {});
export const SourceType = S.String;
export interface CreateIntegrationAssociationRequest {
  InstanceId: string;
  IntegrationType: IntegrationType;
  IntegrationArn: string;
  SourceApplicationUrl?: string;
  SourceApplicationName?: string;
  SourceType?: SourceType;
  Tags?: { [key: string]: string | undefined };
}
export const CreateIntegrationAssociationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    IntegrationType: IntegrationType,
    IntegrationArn: S.String,
    SourceApplicationUrl: S.optional(S.String),
    SourceApplicationName: S.optional(S.String),
    SourceType: S.optional(SourceType),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/instance/{InstanceId}/integration-associations",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateIntegrationAssociationRequest",
}) as any as S.Schema<CreateIntegrationAssociationRequest>;
export interface CreateIntegrationAssociationResponse {
  IntegrationAssociationId?: string;
  IntegrationAssociationArn?: string;
}
export const CreateIntegrationAssociationResponse = S.suspend(() =>
  S.Struct({
    IntegrationAssociationId: S.optional(S.String),
    IntegrationAssociationArn: S.optional(S.String),
  }),
).annotate({
  identifier: "CreateIntegrationAssociationResponse",
}) as any as S.Schema<CreateIntegrationAssociationResponse>;
export type RecipientList = string[];
export const RecipientList = S.Array(S.String);
export type ConfigurableNotificationPriority = "HIGH" | "LOW" | (string & {});
export const ConfigurableNotificationPriority = S.String;
export type LocaleCode =
  | "en_US"
  | "de_DE"
  | "es_ES"
  | "fr_FR"
  | "id_ID"
  | "it_IT"
  | "ja_JP"
  | "ko_KR"
  | "pt_BR"
  | "zh_CN"
  | "zh_TW"
  | (string & {});
export const LocaleCode = S.String;
export type NotificationContent = { [key in LocaleCode]?: string };
export const NotificationContent = S.Record(
  LocaleCode,
  S.String.pipe(S.optional),
);
export interface CreateNotificationRequest {
  InstanceId: string;
  ExpiresAt?: Date;
  Recipients: string[];
  Priority?: ConfigurableNotificationPriority;
  Content: { [key: string]: string | undefined };
  Tags?: { [key: string]: string | undefined };
  PredefinedNotificationId?: string;
  ClientToken?: string;
}
export const CreateNotificationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ExpiresAt: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Recipients: RecipientList,
    Priority: S.optional(ConfigurableNotificationPriority),
    Content: NotificationContent,
    Tags: S.optional(TagMap),
    PredefinedNotificationId: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/notifications/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateNotificationRequest",
}) as any as S.Schema<CreateNotificationRequest>;
export interface CreateNotificationResponse {
  NotificationId: string;
  NotificationArn: string;
}
export const CreateNotificationResponse = S.suspend(() =>
  S.Struct({ NotificationId: S.String, NotificationArn: S.String }),
).annotate({
  identifier: "CreateNotificationResponse",
}) as any as S.Schema<CreateNotificationResponse>;
export type ParticipantRole =
  | "AGENT"
  | "CUSTOMER"
  | "SYSTEM"
  | "CUSTOM_BOT"
  | "SUPERVISOR"
  | (string & {});
export const ParticipantRole = S.String;
export type VideoCapability = "SEND" | (string & {});
export const VideoCapability = S.String;
export type ScreenShareCapability = "SEND" | (string & {});
export const ScreenShareCapability = S.String;
export interface ParticipantCapabilities {
  Video?: VideoCapability;
  ScreenShare?: ScreenShareCapability;
}
export const ParticipantCapabilities = S.suspend(() =>
  S.Struct({
    Video: S.optional(VideoCapability),
    ScreenShare: S.optional(ScreenShareCapability),
  }),
).annotate({
  identifier: "ParticipantCapabilities",
}) as any as S.Schema<ParticipantCapabilities>;
export interface ParticipantDetailsToAdd {
  ParticipantRole?: ParticipantRole;
  DisplayName?: string;
  ParticipantCapabilities?: ParticipantCapabilities;
}
export const ParticipantDetailsToAdd = S.suspend(() =>
  S.Struct({
    ParticipantRole: S.optional(ParticipantRole),
    DisplayName: S.optional(S.String),
    ParticipantCapabilities: S.optional(ParticipantCapabilities),
  }),
).annotate({
  identifier: "ParticipantDetailsToAdd",
}) as any as S.Schema<ParticipantDetailsToAdd>;
export interface CreateParticipantRequest {
  InstanceId: string;
  ContactId: string;
  ClientToken?: string;
  ParticipantDetails: ParticipantDetailsToAdd;
}
export const CreateParticipantRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    ParticipantDetails: ParticipantDetailsToAdd,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/create-participant" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateParticipantRequest",
}) as any as S.Schema<CreateParticipantRequest>;
export interface ParticipantTokenCredentials {
  ParticipantToken?: string;
  Expiry?: string;
}
export const ParticipantTokenCredentials = S.suspend(() =>
  S.Struct({
    ParticipantToken: S.optional(S.String),
    Expiry: S.optional(S.String),
  }),
).annotate({
  identifier: "ParticipantTokenCredentials",
}) as any as S.Schema<ParticipantTokenCredentials>;
export interface CreateParticipantResponse {
  ParticipantCredentials?: ParticipantTokenCredentials;
  ParticipantId?: string;
}
export const CreateParticipantResponse = S.suspend(() =>
  S.Struct({
    ParticipantCredentials: S.optional(ParticipantTokenCredentials),
    ParticipantId: S.optional(S.String),
  }),
).annotate({
  identifier: "CreateParticipantResponse",
}) as any as S.Schema<CreateParticipantResponse>;
export type RehydrationType =
  | "ENTIRE_PAST_SESSION"
  | "FROM_SEGMENT"
  | (string & {});
export const RehydrationType = S.String;
export interface CreatePersistentContactAssociationRequest {
  InstanceId: string;
  InitialContactId: string;
  RehydrationType: RehydrationType;
  SourceContactId: string;
  ClientToken?: string;
}
export const CreatePersistentContactAssociationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    InitialContactId: S.String.pipe(T.HttpLabel("InitialContactId")),
    RehydrationType: RehydrationType,
    SourceContactId: S.String,
    ClientToken: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact/persistent-contact-association/{InstanceId}/{InitialContactId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreatePersistentContactAssociationRequest",
}) as any as S.Schema<CreatePersistentContactAssociationRequest>;
export interface CreatePersistentContactAssociationResponse {
  ContinuedFromContactId?: string;
}
export const CreatePersistentContactAssociationResponse = S.suspend(() =>
  S.Struct({ ContinuedFromContactId: S.optional(S.String) }),
).annotate({
  identifier: "CreatePersistentContactAssociationResponse",
}) as any as S.Schema<CreatePersistentContactAssociationResponse>;
export type PredefinedAttributeStringValuesList = string[];
export const PredefinedAttributeStringValuesList = S.Array(S.String);
export type PredefinedAttributeValues = { StringList: string[] };
export const PredefinedAttributeValues = S.Union([
  S.Struct({ StringList: PredefinedAttributeStringValuesList }),
]);
export type PredefinedAttributePurposeNameList = string[];
export const PredefinedAttributePurposeNameList = S.Array(S.String);
export interface InputPredefinedAttributeConfiguration {
  EnableValueValidationOnAssociation?: boolean;
}
export const InputPredefinedAttributeConfiguration = S.suspend(() =>
  S.Struct({ EnableValueValidationOnAssociation: S.optional(S.Boolean) }),
).annotate({
  identifier: "InputPredefinedAttributeConfiguration",
}) as any as S.Schema<InputPredefinedAttributeConfiguration>;
export interface CreatePredefinedAttributeRequest {
  InstanceId: string;
  Name: string;
  Values?: PredefinedAttributeValues;
  Purposes?: string[];
  AttributeConfiguration?: InputPredefinedAttributeConfiguration;
}
export const CreatePredefinedAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Values: S.optional(PredefinedAttributeValues),
    Purposes: S.optional(PredefinedAttributePurposeNameList),
    AttributeConfiguration: S.optional(InputPredefinedAttributeConfiguration),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/predefined-attributes/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreatePredefinedAttributeRequest",
}) as any as S.Schema<CreatePredefinedAttributeRequest>;
export interface CreatePredefinedAttributeResponse {}
export const CreatePredefinedAttributeResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "CreatePredefinedAttributeResponse",
}) as any as S.Schema<CreatePredefinedAttributeResponse>;
export interface CreatePromptRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  S3Uri: string;
  Tags?: { [key: string]: string | undefined };
}
export const CreatePromptRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    S3Uri: S.String,
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/prompts/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreatePromptRequest",
}) as any as S.Schema<CreatePromptRequest>;
export interface CreatePromptResponse {
  PromptARN?: string;
  PromptId?: string;
}
export const CreatePromptResponse = S.suspend(() =>
  S.Struct({ PromptARN: S.optional(S.String), PromptId: S.optional(S.String) }),
).annotate({
  identifier: "CreatePromptResponse",
}) as any as S.Schema<CreatePromptResponse>;
export type DeviceType = "GCM" | "APNS" | "APNS_SANDBOX" | (string & {});
export const DeviceType = S.String;
export interface ContactConfiguration {
  ContactId: string;
  ParticipantRole?: ParticipantRole;
  IncludeRawMessage?: boolean;
}
export const ContactConfiguration = S.suspend(() =>
  S.Struct({
    ContactId: S.String,
    ParticipantRole: S.optional(ParticipantRole),
    IncludeRawMessage: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "ContactConfiguration",
}) as any as S.Schema<ContactConfiguration>;
export interface CreatePushNotificationRegistrationRequest {
  InstanceId: string;
  ClientToken?: string;
  PinpointAppArn: string;
  DeviceToken: string;
  DeviceType: DeviceType;
  ContactConfiguration: ContactConfiguration;
}
export const CreatePushNotificationRegistrationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    PinpointAppArn: S.String,
    DeviceToken: S.String,
    DeviceType: DeviceType,
    ContactConfiguration: ContactConfiguration,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/push-notification/{InstanceId}/registrations",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreatePushNotificationRegistrationRequest",
}) as any as S.Schema<CreatePushNotificationRegistrationRequest>;
export interface CreatePushNotificationRegistrationResponse {
  RegistrationId: string;
}
export const CreatePushNotificationRegistrationResponse = S.suspend(() =>
  S.Struct({ RegistrationId: S.String }),
).annotate({
  identifier: "CreatePushNotificationRegistrationResponse",
}) as any as S.Schema<CreatePushNotificationRegistrationResponse>;
export interface OutboundCallerConfig {
  OutboundCallerIdName?: string;
  OutboundCallerIdNumberId?: string;
  OutboundFlowId?: string;
}
export const OutboundCallerConfig = S.suspend(() =>
  S.Struct({
    OutboundCallerIdName: S.optional(S.String),
    OutboundCallerIdNumberId: S.optional(S.String),
    OutboundFlowId: S.optional(S.String),
  }),
).annotate({
  identifier: "OutboundCallerConfig",
}) as any as S.Schema<OutboundCallerConfig>;
export interface OutboundEmailConfig {
  OutboundEmailAddressId?: string;
}
export const OutboundEmailConfig = S.suspend(() =>
  S.Struct({ OutboundEmailAddressId: S.optional(S.String) }),
).annotate({
  identifier: "OutboundEmailConfig",
}) as any as S.Schema<OutboundEmailConfig>;
export interface CreateQueueRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  OutboundCallerConfig?: OutboundCallerConfig;
  OutboundEmailConfig?: OutboundEmailConfig;
  HoursOfOperationId: string;
  MaxContacts?: number;
  QuickConnectIds?: string[];
  Tags?: { [key: string]: string | undefined };
}
export const CreateQueueRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    OutboundCallerConfig: S.optional(OutboundCallerConfig),
    OutboundEmailConfig: S.optional(OutboundEmailConfig),
    HoursOfOperationId: S.String,
    MaxContacts: S.optional(S.Number),
    QuickConnectIds: S.optional(QuickConnectsList),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/queues/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateQueueRequest",
}) as any as S.Schema<CreateQueueRequest>;
export interface CreateQueueResponse {
  QueueArn?: string;
  QueueId?: string;
}
export const CreateQueueResponse = S.suspend(() =>
  S.Struct({ QueueArn: S.optional(S.String), QueueId: S.optional(S.String) }),
).annotate({
  identifier: "CreateQueueResponse",
}) as any as S.Schema<CreateQueueResponse>;
export type QuickConnectType =
  | "USER"
  | "QUEUE"
  | "PHONE_NUMBER"
  | "FLOW"
  | (string & {});
export const QuickConnectType = S.String;
export interface UserQuickConnectConfig {
  UserId: string;
  ContactFlowId: string;
}
export const UserQuickConnectConfig = S.suspend(() =>
  S.Struct({ UserId: S.String, ContactFlowId: S.String }),
).annotate({
  identifier: "UserQuickConnectConfig",
}) as any as S.Schema<UserQuickConnectConfig>;
export interface QueueQuickConnectConfig {
  QueueId: string;
  ContactFlowId: string;
}
export const QueueQuickConnectConfig = S.suspend(() =>
  S.Struct({ QueueId: S.String, ContactFlowId: S.String }),
).annotate({
  identifier: "QueueQuickConnectConfig",
}) as any as S.Schema<QueueQuickConnectConfig>;
export interface PhoneNumberQuickConnectConfig {
  PhoneNumber: string;
}
export const PhoneNumberQuickConnectConfig = S.suspend(() =>
  S.Struct({ PhoneNumber: S.String }),
).annotate({
  identifier: "PhoneNumberQuickConnectConfig",
}) as any as S.Schema<PhoneNumberQuickConnectConfig>;
export interface FlowQuickConnectConfig {
  ContactFlowId: string;
}
export const FlowQuickConnectConfig = S.suspend(() =>
  S.Struct({ ContactFlowId: S.String }),
).annotate({
  identifier: "FlowQuickConnectConfig",
}) as any as S.Schema<FlowQuickConnectConfig>;
export interface QuickConnectConfig {
  QuickConnectType: QuickConnectType;
  UserConfig?: UserQuickConnectConfig;
  QueueConfig?: QueueQuickConnectConfig;
  PhoneConfig?: PhoneNumberQuickConnectConfig;
  FlowConfig?: FlowQuickConnectConfig;
}
export const QuickConnectConfig = S.suspend(() =>
  S.Struct({
    QuickConnectType: QuickConnectType,
    UserConfig: S.optional(UserQuickConnectConfig),
    QueueConfig: S.optional(QueueQuickConnectConfig),
    PhoneConfig: S.optional(PhoneNumberQuickConnectConfig),
    FlowConfig: S.optional(FlowQuickConnectConfig),
  }),
).annotate({
  identifier: "QuickConnectConfig",
}) as any as S.Schema<QuickConnectConfig>;
export interface CreateQuickConnectRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  QuickConnectConfig: QuickConnectConfig;
  Tags?: { [key: string]: string | undefined };
}
export const CreateQuickConnectRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    QuickConnectConfig: QuickConnectConfig,
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/quick-connects/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateQuickConnectRequest",
}) as any as S.Schema<CreateQuickConnectRequest>;
export interface CreateQuickConnectResponse {
  QuickConnectARN?: string;
  QuickConnectId?: string;
}
export const CreateQuickConnectResponse = S.suspend(() =>
  S.Struct({
    QuickConnectARN: S.optional(S.String),
    QuickConnectId: S.optional(S.String),
  }),
).annotate({
  identifier: "CreateQuickConnectResponse",
}) as any as S.Schema<CreateQuickConnectResponse>;
export type BehaviorType =
  | "ROUTE_CURRENT_CHANNEL_ONLY"
  | "ROUTE_ANY_CHANNEL"
  | (string & {});
export const BehaviorType = S.String;
export interface CrossChannelBehavior {
  BehaviorType: BehaviorType;
}
export const CrossChannelBehavior = S.suspend(() =>
  S.Struct({ BehaviorType: BehaviorType }),
).annotate({
  identifier: "CrossChannelBehavior",
}) as any as S.Schema<CrossChannelBehavior>;
export interface MediaConcurrency {
  Channel: Channel;
  Concurrency: number;
  CrossChannelBehavior?: CrossChannelBehavior;
}
export const MediaConcurrency = S.suspend(() =>
  S.Struct({
    Channel: Channel,
    Concurrency: S.Number,
    CrossChannelBehavior: S.optional(CrossChannelBehavior),
  }),
).annotate({
  identifier: "MediaConcurrency",
}) as any as S.Schema<MediaConcurrency>;
export type MediaConcurrencies = MediaConcurrency[];
export const MediaConcurrencies = S.Array(MediaConcurrency);
export type AgentAvailabilityTimer =
  | "TIME_SINCE_LAST_ACTIVITY"
  | "TIME_SINCE_LAST_INBOUND"
  | (string & {});
export const AgentAvailabilityTimer = S.String;
export interface CreateRoutingProfileRequest {
  InstanceId: string;
  Name: string;
  Description: string;
  DefaultOutboundQueueId: string;
  QueueConfigs?: RoutingProfileQueueConfig[];
  ManualAssignmentQueueConfigs?: RoutingProfileManualAssignmentQueueConfig[];
  MediaConcurrencies: MediaConcurrency[];
  Tags?: { [key: string]: string | undefined };
  AgentAvailabilityTimer?: AgentAvailabilityTimer;
}
export const CreateRoutingProfileRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.String,
    DefaultOutboundQueueId: S.String,
    QueueConfigs: S.optional(RoutingProfileQueueConfigList),
    ManualAssignmentQueueConfigs: S.optional(
      RoutingProfileManualAssignmentQueueConfigList,
    ),
    MediaConcurrencies: MediaConcurrencies,
    Tags: S.optional(TagMap),
    AgentAvailabilityTimer: S.optional(AgentAvailabilityTimer),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/routing-profiles/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateRoutingProfileRequest",
}) as any as S.Schema<CreateRoutingProfileRequest>;
export interface CreateRoutingProfileResponse {
  RoutingProfileArn?: string;
  RoutingProfileId?: string;
}
export const CreateRoutingProfileResponse = S.suspend(() =>
  S.Struct({
    RoutingProfileArn: S.optional(S.String),
    RoutingProfileId: S.optional(S.String),
  }),
).annotate({
  identifier: "CreateRoutingProfileResponse",
}) as any as S.Schema<CreateRoutingProfileResponse>;
export type EventSourceName =
  | "OnPostCallAnalysisAvailable"
  | "OnRealTimeCallAnalysisAvailable"
  | "OnRealTimeChatAnalysisAvailable"
  | "OnPostChatAnalysisAvailable"
  | "OnZendeskTicketCreate"
  | "OnZendeskTicketStatusUpdate"
  | "OnSalesforceCaseCreate"
  | "OnContactEvaluationSubmit"
  | "OnMetricDataUpdate"
  | "OnCaseCreate"
  | "OnCaseUpdate"
  | "OnSlaBreach"
  | (string & {});
export const EventSourceName = S.String;
export interface RuleTriggerEventSource {
  EventSourceName: EventSourceName;
  IntegrationAssociationId?: string;
}
export const RuleTriggerEventSource = S.suspend(() =>
  S.Struct({
    EventSourceName: EventSourceName,
    IntegrationAssociationId: S.optional(S.String),
  }),
).annotate({
  identifier: "RuleTriggerEventSource",
}) as any as S.Schema<RuleTriggerEventSource>;
export type ActionType =
  | "CREATE_TASK"
  | "ASSIGN_CONTACT_CATEGORY"
  | "GENERATE_EVENTBRIDGE_EVENT"
  | "SEND_NOTIFICATION"
  | "CREATE_CASE"
  | "UPDATE_CASE"
  | "ASSIGN_SLA"
  | "END_ASSOCIATED_TASKS"
  | "SUBMIT_AUTO_EVALUATION"
  | (string & {});
export const ActionType = S.String;
export interface TaskActionDefinition {
  Name: string;
  Description?: string;
  ContactFlowId: string;
  References?: { [key: string]: Reference | undefined };
}
export const TaskActionDefinition = S.suspend(() =>
  S.Struct({
    Name: S.String,
    Description: S.optional(S.String),
    ContactFlowId: S.String,
    References: S.optional(ContactReferences),
  }),
).annotate({
  identifier: "TaskActionDefinition",
}) as any as S.Schema<TaskActionDefinition>;
export interface EventBridgeActionDefinition {
  Name: string;
}
export const EventBridgeActionDefinition = S.suspend(() =>
  S.Struct({ Name: S.String }),
).annotate({
  identifier: "EventBridgeActionDefinition",
}) as any as S.Schema<EventBridgeActionDefinition>;
export interface AssignContactCategoryActionDefinition {}
export const AssignContactCategoryActionDefinition = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "AssignContactCategoryActionDefinition",
}) as any as S.Schema<AssignContactCategoryActionDefinition>;
export type NotificationDeliveryType = "EMAIL" | (string & {});
export const NotificationDeliveryType = S.String;
export type NotificationContentType = "PLAIN_TEXT" | (string & {});
export const NotificationContentType = S.String;
export type UserTagMap = { [key: string]: string | undefined };
export const UserTagMap = S.Record(S.String, S.String.pipe(S.optional));
export type UserIdList = string[];
export const UserIdList = S.Array(S.String);
export interface NotificationRecipientType {
  UserTags?: { [key: string]: string | undefined };
  UserIds?: string[];
}
export const NotificationRecipientType = S.suspend(() =>
  S.Struct({
    UserTags: S.optional(UserTagMap),
    UserIds: S.optional(UserIdList),
  }),
).annotate({
  identifier: "NotificationRecipientType",
}) as any as S.Schema<NotificationRecipientType>;
export interface SendNotificationActionDefinition {
  DeliveryMethod: NotificationDeliveryType;
  Subject?: string;
  Content: string;
  ContentType: NotificationContentType;
  Recipient: NotificationRecipientType;
  Exclusion?: NotificationRecipientType;
}
export const SendNotificationActionDefinition = S.suspend(() =>
  S.Struct({
    DeliveryMethod: NotificationDeliveryType,
    Subject: S.optional(S.String),
    Content: S.String,
    ContentType: NotificationContentType,
    Recipient: NotificationRecipientType,
    Exclusion: S.optional(NotificationRecipientType),
  }),
).annotate({
  identifier: "SendNotificationActionDefinition",
}) as any as S.Schema<SendNotificationActionDefinition>;
export interface EmptyFieldValue {}
export const EmptyFieldValue = S.suspend(() => S.Struct({})).annotate({
  identifier: "EmptyFieldValue",
}) as any as S.Schema<EmptyFieldValue>;
export interface FieldValueUnion {
  BooleanValue?: boolean;
  DoubleValue?: number;
  EmptyValue?: EmptyFieldValue;
  StringValue?: string;
}
export const FieldValueUnion = S.suspend(() =>
  S.Struct({
    BooleanValue: S.optional(S.Boolean),
    DoubleValue: S.optional(S.Number),
    EmptyValue: S.optional(EmptyFieldValue),
    StringValue: S.optional(S.String),
  }),
).annotate({
  identifier: "FieldValueUnion",
}) as any as S.Schema<FieldValueUnion>;
export interface FieldValue {
  Id: string;
  Value: FieldValueUnion;
}
export const FieldValue = S.suspend(() =>
  S.Struct({ Id: S.String, Value: FieldValueUnion }),
).annotate({ identifier: "FieldValue" }) as any as S.Schema<FieldValue>;
export type FieldValues = FieldValue[];
export const FieldValues = S.Array(FieldValue);
export interface CreateCaseActionDefinition {
  Fields: FieldValue[];
  TemplateId: string;
}
export const CreateCaseActionDefinition = S.suspend(() =>
  S.Struct({ Fields: FieldValues, TemplateId: S.String }),
).annotate({
  identifier: "CreateCaseActionDefinition",
}) as any as S.Schema<CreateCaseActionDefinition>;
export interface UpdateCaseActionDefinition {
  Fields: FieldValue[];
}
export const UpdateCaseActionDefinition = S.suspend(() =>
  S.Struct({ Fields: FieldValues }),
).annotate({
  identifier: "UpdateCaseActionDefinition",
}) as any as S.Schema<UpdateCaseActionDefinition>;
export type SlaAssignmentType = "CASES" | (string & {});
export const SlaAssignmentType = S.String;
export type SlaType = "CaseField" | (string & {});
export const SlaType = S.String;
export type SlaFieldValueUnionList = FieldValueUnion[];
export const SlaFieldValueUnionList = S.Array(FieldValueUnion);
export interface CaseSlaConfiguration {
  Name: string;
  Type: SlaType;
  FieldId?: string;
  TargetFieldValues?: FieldValueUnion[];
  TargetSlaMinutes: number;
}
export const CaseSlaConfiguration = S.suspend(() =>
  S.Struct({
    Name: S.String,
    Type: SlaType,
    FieldId: S.optional(S.String),
    TargetFieldValues: S.optional(SlaFieldValueUnionList),
    TargetSlaMinutes: S.Number,
  }),
).annotate({
  identifier: "CaseSlaConfiguration",
}) as any as S.Schema<CaseSlaConfiguration>;
export interface AssignSlaActionDefinition {
  SlaAssignmentType: SlaAssignmentType;
  CaseSlaConfiguration?: CaseSlaConfiguration;
}
export const AssignSlaActionDefinition = S.suspend(() =>
  S.Struct({
    SlaAssignmentType: SlaAssignmentType,
    CaseSlaConfiguration: S.optional(CaseSlaConfiguration),
  }),
).annotate({
  identifier: "AssignSlaActionDefinition",
}) as any as S.Schema<AssignSlaActionDefinition>;
export interface EndAssociatedTasksActionDefinition {}
export const EndAssociatedTasksActionDefinition = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "EndAssociatedTasksActionDefinition",
}) as any as S.Schema<EndAssociatedTasksActionDefinition>;
export interface SubmitAutoEvaluationActionDefinition {
  EvaluationFormId: string;
}
export const SubmitAutoEvaluationActionDefinition = S.suspend(() =>
  S.Struct({ EvaluationFormId: S.String }),
).annotate({
  identifier: "SubmitAutoEvaluationActionDefinition",
}) as any as S.Schema<SubmitAutoEvaluationActionDefinition>;
export interface RuleAction {
  ActionType: ActionType;
  TaskAction?: TaskActionDefinition;
  EventBridgeAction?: EventBridgeActionDefinition;
  AssignContactCategoryAction?: AssignContactCategoryActionDefinition;
  SendNotificationAction?: SendNotificationActionDefinition;
  CreateCaseAction?: CreateCaseActionDefinition;
  UpdateCaseAction?: UpdateCaseActionDefinition;
  AssignSlaAction?: AssignSlaActionDefinition;
  EndAssociatedTasksAction?: EndAssociatedTasksActionDefinition;
  SubmitAutoEvaluationAction?: SubmitAutoEvaluationActionDefinition;
}
export const RuleAction = S.suspend(() =>
  S.Struct({
    ActionType: ActionType,
    TaskAction: S.optional(TaskActionDefinition),
    EventBridgeAction: S.optional(EventBridgeActionDefinition),
    AssignContactCategoryAction: S.optional(
      AssignContactCategoryActionDefinition,
    ),
    SendNotificationAction: S.optional(SendNotificationActionDefinition),
    CreateCaseAction: S.optional(CreateCaseActionDefinition),
    UpdateCaseAction: S.optional(UpdateCaseActionDefinition),
    AssignSlaAction: S.optional(AssignSlaActionDefinition),
    EndAssociatedTasksAction: S.optional(EndAssociatedTasksActionDefinition),
    SubmitAutoEvaluationAction: S.optional(
      SubmitAutoEvaluationActionDefinition,
    ),
  }),
).annotate({ identifier: "RuleAction" }) as any as S.Schema<RuleAction>;
export type RuleActions = RuleAction[];
export const RuleActions = S.Array(RuleAction);
export type RulePublishStatus = "DRAFT" | "PUBLISHED" | (string & {});
export const RulePublishStatus = S.String;
export interface CreateRuleRequest {
  InstanceId: string;
  Name: string;
  TriggerEventSource: RuleTriggerEventSource;
  Function: string;
  Actions: RuleAction[];
  PublishStatus: RulePublishStatus;
  ClientToken?: string;
}
export const CreateRuleRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    TriggerEventSource: RuleTriggerEventSource,
    Function: S.String,
    Actions: RuleActions,
    PublishStatus: RulePublishStatus,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/rules/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateRuleRequest",
}) as any as S.Schema<CreateRuleRequest>;
export interface CreateRuleResponse {
  RuleArn: string;
  RuleId: string;
}
export const CreateRuleResponse = S.suspend(() =>
  S.Struct({ RuleArn: S.String, RuleId: S.String }),
).annotate({
  identifier: "CreateRuleResponse",
}) as any as S.Schema<CreateRuleResponse>;
export type PermissionsList = string[];
export const PermissionsList = S.Array(S.String);
export type AllowedAccessControlTags = { [key: string]: string | undefined };
export const AllowedAccessControlTags = S.Record(
  S.String,
  S.String.pipe(S.optional),
);
export type TagRestrictedResourceList = string[];
export const TagRestrictedResourceList = S.Array(S.String);
export type ApplicationPermissions = string[];
export const ApplicationPermissions = S.Array(S.String);
export type ApplicationType = "MCP" | "THIRD_PARTY_APPLICATION" | (string & {});
export const ApplicationType = S.String;
export interface Application {
  Namespace?: string;
  ApplicationPermissions?: string[];
  Type?: ApplicationType;
}
export const Application = S.suspend(() =>
  S.Struct({
    Namespace: S.optional(S.String),
    ApplicationPermissions: S.optional(ApplicationPermissions),
    Type: S.optional(ApplicationType),
  }),
).annotate({ identifier: "Application" }) as any as S.Schema<Application>;
export type Applications = Application[];
export const Applications = S.Array(Application);
export type HierarchyRestrictedResourceList = string[];
export const HierarchyRestrictedResourceList = S.Array(S.String);
export type FlowModuleType = "MCP" | (string & {});
export const FlowModuleType = S.String;
export interface FlowModule {
  Type?: FlowModuleType;
  FlowModuleId?: string;
}
export const FlowModule = S.suspend(() =>
  S.Struct({
    Type: S.optional(FlowModuleType),
    FlowModuleId: S.optional(S.String),
  }),
).annotate({ identifier: "FlowModule" }) as any as S.Schema<FlowModule>;
export type AllowedFlowModules = FlowModule[];
export const AllowedFlowModules = S.Array(FlowModule);
export type AccessType = "ALLOW" | (string & {});
export const AccessType = S.String;
export type PrimaryValueList = string[];
export const PrimaryValueList = S.Array(S.String);
export interface PrimaryAttributeValue {
  AccessType?: AccessType;
  AttributeName?: string;
  Values?: string[];
}
export const PrimaryAttributeValue = S.suspend(() =>
  S.Struct({
    AccessType: S.optional(AccessType),
    AttributeName: S.optional(S.String),
    Values: S.optional(PrimaryValueList),
  }),
).annotate({
  identifier: "PrimaryAttributeValue",
}) as any as S.Schema<PrimaryAttributeValue>;
export type PrimaryAttributeValuesSet = PrimaryAttributeValue[];
export const PrimaryAttributeValuesSet = S.Array(PrimaryAttributeValue);
export interface PrimaryAttributeAccessControlConfigurationItem {
  PrimaryAttributeValues?: PrimaryAttributeValue[];
}
export const PrimaryAttributeAccessControlConfigurationItem = S.suspend(() =>
  S.Struct({ PrimaryAttributeValues: S.optional(PrimaryAttributeValuesSet) }),
).annotate({
  identifier: "PrimaryAttributeAccessControlConfigurationItem",
}) as any as S.Schema<PrimaryAttributeAccessControlConfigurationItem>;
export interface DataTableAccessControlConfiguration {
  PrimaryAttributeAccessControlConfiguration?: PrimaryAttributeAccessControlConfigurationItem;
}
export const DataTableAccessControlConfiguration = S.suspend(() =>
  S.Struct({
    PrimaryAttributeAccessControlConfiguration: S.optional(
      PrimaryAttributeAccessControlConfigurationItem,
    ),
  }),
).annotate({
  identifier: "DataTableAccessControlConfiguration",
}) as any as S.Schema<DataTableAccessControlConfiguration>;
export interface GranularAccessControlConfiguration {
  DataTableAccessControlConfiguration?: DataTableAccessControlConfiguration;
}
export const GranularAccessControlConfiguration = S.suspend(() =>
  S.Struct({
    DataTableAccessControlConfiguration: S.optional(
      DataTableAccessControlConfiguration,
    ),
  }),
).annotate({
  identifier: "GranularAccessControlConfiguration",
}) as any as S.Schema<GranularAccessControlConfiguration>;
export interface CreateSecurityProfileRequest {
  SecurityProfileName: string;
  Description?: string;
  Permissions?: string[];
  InstanceId: string;
  Tags?: { [key: string]: string | undefined };
  AllowedAccessControlTags?: { [key: string]: string | undefined };
  TagRestrictedResources?: string[];
  Applications?: Application[];
  HierarchyRestrictedResources?: string[];
  AllowedAccessControlHierarchyGroupId?: string;
  AllowedFlowModules?: FlowModule[];
  GranularAccessControlConfiguration?: GranularAccessControlConfiguration;
}
export const CreateSecurityProfileRequest = S.suspend(() =>
  S.Struct({
    SecurityProfileName: S.String,
    Description: S.optional(S.String),
    Permissions: S.optional(PermissionsList),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Tags: S.optional(TagMap),
    AllowedAccessControlTags: S.optional(AllowedAccessControlTags),
    TagRestrictedResources: S.optional(TagRestrictedResourceList),
    Applications: S.optional(Applications),
    HierarchyRestrictedResources: S.optional(HierarchyRestrictedResourceList),
    AllowedAccessControlHierarchyGroupId: S.optional(S.String),
    AllowedFlowModules: S.optional(AllowedFlowModules),
    GranularAccessControlConfiguration: S.optional(
      GranularAccessControlConfiguration,
    ),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/security-profiles/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateSecurityProfileRequest",
}) as any as S.Schema<CreateSecurityProfileRequest>;
export interface CreateSecurityProfileResponse {
  SecurityProfileId?: string;
  SecurityProfileArn?: string;
}
export const CreateSecurityProfileResponse = S.suspend(() =>
  S.Struct({
    SecurityProfileId: S.optional(S.String),
    SecurityProfileArn: S.optional(S.String),
  }),
).annotate({
  identifier: "CreateSecurityProfileResponse",
}) as any as S.Schema<CreateSecurityProfileResponse>;
export interface TaskTemplateFieldIdentifier {
  Name?: string;
}
export const TaskTemplateFieldIdentifier = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String) }),
).annotate({
  identifier: "TaskTemplateFieldIdentifier",
}) as any as S.Schema<TaskTemplateFieldIdentifier>;
export interface RequiredFieldInfo {
  Id?: TaskTemplateFieldIdentifier;
}
export const RequiredFieldInfo = S.suspend(() =>
  S.Struct({ Id: S.optional(TaskTemplateFieldIdentifier) }),
).annotate({
  identifier: "RequiredFieldInfo",
}) as any as S.Schema<RequiredFieldInfo>;
export type RequiredTaskTemplateFields = RequiredFieldInfo[];
export const RequiredTaskTemplateFields = S.Array(RequiredFieldInfo);
export interface ReadOnlyFieldInfo {
  Id?: TaskTemplateFieldIdentifier;
}
export const ReadOnlyFieldInfo = S.suspend(() =>
  S.Struct({ Id: S.optional(TaskTemplateFieldIdentifier) }),
).annotate({
  identifier: "ReadOnlyFieldInfo",
}) as any as S.Schema<ReadOnlyFieldInfo>;
export type ReadOnlyTaskTemplateFields = ReadOnlyFieldInfo[];
export const ReadOnlyTaskTemplateFields = S.Array(ReadOnlyFieldInfo);
export interface InvisibleFieldInfo {
  Id?: TaskTemplateFieldIdentifier;
}
export const InvisibleFieldInfo = S.suspend(() =>
  S.Struct({ Id: S.optional(TaskTemplateFieldIdentifier) }),
).annotate({
  identifier: "InvisibleFieldInfo",
}) as any as S.Schema<InvisibleFieldInfo>;
export type InvisibleTaskTemplateFields = InvisibleFieldInfo[];
export const InvisibleTaskTemplateFields = S.Array(InvisibleFieldInfo);
export interface TaskTemplateConstraints {
  RequiredFields?: RequiredFieldInfo[];
  ReadOnlyFields?: ReadOnlyFieldInfo[];
  InvisibleFields?: InvisibleFieldInfo[];
}
export const TaskTemplateConstraints = S.suspend(() =>
  S.Struct({
    RequiredFields: S.optional(RequiredTaskTemplateFields),
    ReadOnlyFields: S.optional(ReadOnlyTaskTemplateFields),
    InvisibleFields: S.optional(InvisibleTaskTemplateFields),
  }),
).annotate({
  identifier: "TaskTemplateConstraints",
}) as any as S.Schema<TaskTemplateConstraints>;
export interface TaskTemplateDefaultFieldValue {
  Id?: TaskTemplateFieldIdentifier;
  DefaultValue?: string;
}
export const TaskTemplateDefaultFieldValue = S.suspend(() =>
  S.Struct({
    Id: S.optional(TaskTemplateFieldIdentifier),
    DefaultValue: S.optional(S.String),
  }),
).annotate({
  identifier: "TaskTemplateDefaultFieldValue",
}) as any as S.Schema<TaskTemplateDefaultFieldValue>;
export type TaskTemplateDefaultFieldValueList = TaskTemplateDefaultFieldValue[];
export const TaskTemplateDefaultFieldValueList = S.Array(
  TaskTemplateDefaultFieldValue,
);
export interface TaskTemplateDefaults {
  DefaultFieldValues?: TaskTemplateDefaultFieldValue[];
}
export const TaskTemplateDefaults = S.suspend(() =>
  S.Struct({
    DefaultFieldValues: S.optional(TaskTemplateDefaultFieldValueList),
  }),
).annotate({
  identifier: "TaskTemplateDefaults",
}) as any as S.Schema<TaskTemplateDefaults>;
export type TaskTemplateStatus = "ACTIVE" | "INACTIVE" | (string & {});
export const TaskTemplateStatus = S.String;
export type TaskTemplateFieldType =
  | "NAME"
  | "DESCRIPTION"
  | "SCHEDULED_TIME"
  | "QUICK_CONNECT"
  | "URL"
  | "NUMBER"
  | "TEXT"
  | "TEXT_AREA"
  | "DATE_TIME"
  | "BOOLEAN"
  | "SINGLE_SELECT"
  | "EMAIL"
  | "SELF_ASSIGN"
  | "EXPIRY_DURATION"
  | (string & {});
export const TaskTemplateFieldType = S.String;
export type SingleSelectOptions = string[];
export const SingleSelectOptions = S.Array(S.String);
export interface TaskTemplateField {
  Id: TaskTemplateFieldIdentifier;
  Description?: string;
  Type?: TaskTemplateFieldType;
  SingleSelectOptions?: string[];
}
export const TaskTemplateField = S.suspend(() =>
  S.Struct({
    Id: TaskTemplateFieldIdentifier,
    Description: S.optional(S.String),
    Type: S.optional(TaskTemplateFieldType),
    SingleSelectOptions: S.optional(SingleSelectOptions),
  }),
).annotate({
  identifier: "TaskTemplateField",
}) as any as S.Schema<TaskTemplateField>;
export type TaskTemplateFields = TaskTemplateField[];
export const TaskTemplateFields = S.Array(TaskTemplateField);
export interface CreateTaskTemplateRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  ContactFlowId?: string;
  SelfAssignFlowId?: string;
  Constraints?: TaskTemplateConstraints;
  Defaults?: TaskTemplateDefaults;
  Status?: TaskTemplateStatus;
  Fields: TaskTemplateField[];
  ClientToken?: string;
}
export const CreateTaskTemplateRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    ContactFlowId: S.optional(S.String),
    SelfAssignFlowId: S.optional(S.String),
    Constraints: S.optional(TaskTemplateConstraints),
    Defaults: S.optional(TaskTemplateDefaults),
    Status: S.optional(TaskTemplateStatus),
    Fields: TaskTemplateFields,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/instance/{InstanceId}/task/template" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTaskTemplateRequest",
}) as any as S.Schema<CreateTaskTemplateRequest>;
export interface CreateTaskTemplateResponse {
  Id: string;
  Arn: string;
}
export const CreateTaskTemplateResponse = S.suspend(() =>
  S.Struct({ Id: S.String, Arn: S.String }),
).annotate({
  identifier: "CreateTaskTemplateResponse",
}) as any as S.Schema<CreateTaskTemplateResponse>;
export type PropertyValidationExceptionReason =
  | "INVALID_FORMAT"
  | "UNIQUE_CONSTRAINT_VIOLATED"
  | "REFERENCED_RESOURCE_NOT_FOUND"
  | "RESOURCE_NAME_ALREADY_EXISTS"
  | "REQUIRED_PROPERTY_MISSING"
  | "NOT_SUPPORTED"
  | (string & {});
export const PropertyValidationExceptionReason = S.String;
export interface PropertyValidationExceptionProperty {
  PropertyPath: string;
  Reason: PropertyValidationExceptionReason;
  Message: string;
}
export const PropertyValidationExceptionProperty = S.suspend(() =>
  S.Struct({
    PropertyPath: S.String,
    Reason: PropertyValidationExceptionReason,
    Message: S.String,
  }),
).annotate({
  identifier: "PropertyValidationExceptionProperty",
}) as any as S.Schema<PropertyValidationExceptionProperty>;
export type PropertyValidationExceptionPropertyList =
  PropertyValidationExceptionProperty[];
export const PropertyValidationExceptionPropertyList = S.Array(
  PropertyValidationExceptionProperty,
);
export type TestCaseEntryPointType = "VOICE_CALL" | (string & {});
export const TestCaseEntryPointType = S.String;
export interface VoiceCallEntryPointParameters {
  SourcePhoneNumber?: string;
  DestinationPhoneNumber?: string;
  FlowId?: string;
}
export const VoiceCallEntryPointParameters = S.suspend(() =>
  S.Struct({
    SourcePhoneNumber: S.optional(S.String),
    DestinationPhoneNumber: S.optional(S.String),
    FlowId: S.optional(S.String),
  }),
).annotate({
  identifier: "VoiceCallEntryPointParameters",
}) as any as S.Schema<VoiceCallEntryPointParameters>;
export interface TestCaseEntryPoint {
  Type?: TestCaseEntryPointType;
  VoiceCallEntryPointParameters?: VoiceCallEntryPointParameters;
}
export const TestCaseEntryPoint = S.suspend(() =>
  S.Struct({
    Type: S.optional(TestCaseEntryPointType),
    VoiceCallEntryPointParameters: S.optional(VoiceCallEntryPointParameters),
  }),
).annotate({
  identifier: "TestCaseEntryPoint",
}) as any as S.Schema<TestCaseEntryPoint>;
export type TestCaseStatus = "PUBLISHED" | "SAVED" | (string & {});
export const TestCaseStatus = S.String;
export interface CreateTestCaseRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  Content: string;
  EntryPoint?: TestCaseEntryPoint;
  InitializationData?: string;
  Status?: TestCaseStatus;
  TestCaseId?: string;
  Tags?: { [key: string]: string | undefined };
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const CreateTestCaseRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    Content: S.String,
    EntryPoint: S.optional(TestCaseEntryPoint),
    InitializationData: S.optional(S.String),
    Status: S.optional(TestCaseStatus),
    TestCaseId: S.optional(S.String).pipe(T.HttpHeader("x-amz-resource-id")),
    Tags: S.optional(TagMap),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("http-date")),
    ).pipe(T.HttpHeader("x-amz-last-modified-time")),
    LastModifiedRegion: S.optional(S.String).pipe(
      T.HttpHeader("x-amz-last-modified-region"),
    ),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/test-cases/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTestCaseRequest",
}) as any as S.Schema<CreateTestCaseRequest>;
export interface CreateTestCaseResponse {
  TestCaseId?: string;
  TestCaseArn?: string;
}
export const CreateTestCaseResponse = S.suspend(() =>
  S.Struct({
    TestCaseId: S.optional(S.String),
    TestCaseArn: S.optional(S.String),
  }),
).annotate({
  identifier: "CreateTestCaseResponse",
}) as any as S.Schema<CreateTestCaseResponse>;
export interface CreateTrafficDistributionGroupRequest {
  Name: string;
  Description?: string;
  InstanceId: string;
  ClientToken?: string;
  Tags?: { [key: string]: string | undefined };
}
export const CreateTrafficDistributionGroupRequest = S.suspend(() =>
  S.Struct({
    Name: S.String,
    Description: S.optional(S.String),
    InstanceId: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/traffic-distribution-group" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateTrafficDistributionGroupRequest",
}) as any as S.Schema<CreateTrafficDistributionGroupRequest>;
export interface CreateTrafficDistributionGroupResponse {
  Id?: string;
  Arn?: string;
}
export const CreateTrafficDistributionGroupResponse = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String), Arn: S.optional(S.String) }),
).annotate({
  identifier: "CreateTrafficDistributionGroupResponse",
}) as any as S.Schema<CreateTrafficDistributionGroupResponse>;
export type UseCaseType =
  | "RULES_EVALUATION"
  | "CONNECT_CAMPAIGNS"
  | (string & {});
export const UseCaseType = S.String;
export interface CreateUseCaseRequest {
  InstanceId: string;
  IntegrationAssociationId: string;
  UseCaseType: UseCaseType;
  Tags?: { [key: string]: string | undefined };
}
export const CreateUseCaseRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    IntegrationAssociationId: S.String.pipe(
      T.HttpLabel("IntegrationAssociationId"),
    ),
    UseCaseType: UseCaseType,
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/instance/{InstanceId}/integration-associations/{IntegrationAssociationId}/use-cases",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateUseCaseRequest",
}) as any as S.Schema<CreateUseCaseRequest>;
export interface CreateUseCaseResponse {
  UseCaseId?: string;
  UseCaseArn?: string;
}
export const CreateUseCaseResponse = S.suspend(() =>
  S.Struct({
    UseCaseId: S.optional(S.String),
    UseCaseArn: S.optional(S.String),
  }),
).annotate({
  identifier: "CreateUseCaseResponse",
}) as any as S.Schema<CreateUseCaseResponse>;
export interface UserIdentityInfo {
  FirstName?: string | redacted.Redacted<string>;
  LastName?: string | redacted.Redacted<string>;
  Email?: string | redacted.Redacted<string>;
  SecondaryEmail?: string | redacted.Redacted<string>;
  Mobile?: string;
}
export const UserIdentityInfo = S.suspend(() =>
  S.Struct({
    FirstName: S.optional(SensitiveString),
    LastName: S.optional(SensitiveString),
    Email: S.optional(SensitiveString),
    SecondaryEmail: S.optional(SensitiveString),
    Mobile: S.optional(S.String),
  }),
).annotate({
  identifier: "UserIdentityInfo",
}) as any as S.Schema<UserIdentityInfo>;
export type PhoneType = "SOFT_PHONE" | "DESK_PHONE" | (string & {});
export const PhoneType = S.String;
export interface UserPhoneConfig {
  PhoneType?: PhoneType;
  AutoAccept?: boolean;
  AfterContactWorkTimeLimit?: number;
  DeskPhoneNumber?: string | redacted.Redacted<string>;
  PersistentConnection?: boolean;
}
export const UserPhoneConfig = S.suspend(() =>
  S.Struct({
    PhoneType: S.optional(PhoneType),
    AutoAccept: S.optional(S.Boolean),
    AfterContactWorkTimeLimit: S.optional(S.Number),
    DeskPhoneNumber: S.optional(SensitiveString),
    PersistentConnection: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "UserPhoneConfig",
}) as any as S.Schema<UserPhoneConfig>;
export type SecurityProfileIds = string[];
export const SecurityProfileIds = S.Array(S.String);
export interface AutoAcceptConfig {
  Channel: Channel;
  AutoAccept: boolean;
  AgentFirstCallbackAutoAccept?: boolean;
}
export const AutoAcceptConfig = S.suspend(() =>
  S.Struct({
    Channel: Channel,
    AutoAccept: S.Boolean,
    AgentFirstCallbackAutoAccept: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "AutoAcceptConfig",
}) as any as S.Schema<AutoAcceptConfig>;
export type AutoAcceptConfigs = AutoAcceptConfig[];
export const AutoAcceptConfigs = S.Array(AutoAcceptConfig);
export interface AfterContactWorkConfig {
  AfterContactWorkTimeLimit?: number;
}
export const AfterContactWorkConfig = S.suspend(() =>
  S.Struct({ AfterContactWorkTimeLimit: S.optional(S.Number) }),
).annotate({
  identifier: "AfterContactWorkConfig",
}) as any as S.Schema<AfterContactWorkConfig>;
export interface AfterContactWorkConfigPerChannel {
  Channel: Channel;
  AfterContactWorkConfig: AfterContactWorkConfig;
  AgentFirstCallbackAfterContactWorkConfig?: AfterContactWorkConfig;
}
export const AfterContactWorkConfigPerChannel = S.suspend(() =>
  S.Struct({
    Channel: Channel,
    AfterContactWorkConfig: AfterContactWorkConfig,
    AgentFirstCallbackAfterContactWorkConfig: S.optional(
      AfterContactWorkConfig,
    ),
  }),
).annotate({
  identifier: "AfterContactWorkConfigPerChannel",
}) as any as S.Schema<AfterContactWorkConfigPerChannel>;
export type AfterContactWorkConfigs = AfterContactWorkConfigPerChannel[];
export const AfterContactWorkConfigs = S.Array(
  AfterContactWorkConfigPerChannel,
);
export interface PhoneNumberConfig {
  Channel: Channel;
  PhoneType: PhoneType;
  PhoneNumber?: string | redacted.Redacted<string>;
}
export const PhoneNumberConfig = S.suspend(() =>
  S.Struct({
    Channel: Channel,
    PhoneType: PhoneType,
    PhoneNumber: S.optional(SensitiveString),
  }),
).annotate({
  identifier: "PhoneNumberConfig",
}) as any as S.Schema<PhoneNumberConfig>;
export type PhoneNumberConfigs = PhoneNumberConfig[];
export const PhoneNumberConfigs = S.Array(PhoneNumberConfig);
export interface PersistentConnectionConfig {
  Channel: Channel;
  PersistentConnection: boolean;
}
export const PersistentConnectionConfig = S.suspend(() =>
  S.Struct({ Channel: Channel, PersistentConnection: S.Boolean }),
).annotate({
  identifier: "PersistentConnectionConfig",
}) as any as S.Schema<PersistentConnectionConfig>;
export type PersistentConnectionConfigs = PersistentConnectionConfig[];
export const PersistentConnectionConfigs = S.Array(PersistentConnectionConfig);
export type VoiceEnhancementMode =
  | "VOICE_ISOLATION"
  | "NOISE_SUPPRESSION"
  | "NONE"
  | (string & {});
export const VoiceEnhancementMode = S.String;
export interface VoiceEnhancementConfig {
  Channel: Channel;
  VoiceEnhancementMode: VoiceEnhancementMode;
}
export const VoiceEnhancementConfig = S.suspend(() =>
  S.Struct({ Channel: Channel, VoiceEnhancementMode: VoiceEnhancementMode }),
).annotate({
  identifier: "VoiceEnhancementConfig",
}) as any as S.Schema<VoiceEnhancementConfig>;
export type VoiceEnhancementConfigs = VoiceEnhancementConfig[];
export const VoiceEnhancementConfigs = S.Array(VoiceEnhancementConfig);
export interface CreateUserRequest {
  Username: string;
  Password?: string | redacted.Redacted<string>;
  IdentityInfo?: UserIdentityInfo;
  PhoneConfig?: UserPhoneConfig;
  DirectoryUserId?: string;
  SecurityProfileIds: string[];
  RoutingProfileId: string;
  HierarchyGroupId?: string;
  InstanceId: string;
  AutoAcceptConfigs?: AutoAcceptConfig[];
  AfterContactWorkConfigs?: AfterContactWorkConfigPerChannel[];
  PhoneNumberConfigs?: PhoneNumberConfig[];
  PersistentConnectionConfigs?: PersistentConnectionConfig[];
  VoiceEnhancementConfigs?: VoiceEnhancementConfig[];
  Tags?: { [key: string]: string | undefined };
}
export const CreateUserRequest = S.suspend(() =>
  S.Struct({
    Username: S.String,
    Password: S.optional(SensitiveString),
    IdentityInfo: S.optional(UserIdentityInfo),
    PhoneConfig: S.optional(UserPhoneConfig),
    DirectoryUserId: S.optional(S.String),
    SecurityProfileIds: SecurityProfileIds,
    RoutingProfileId: S.String,
    HierarchyGroupId: S.optional(S.String),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AutoAcceptConfigs: S.optional(AutoAcceptConfigs),
    AfterContactWorkConfigs: S.optional(AfterContactWorkConfigs),
    PhoneNumberConfigs: S.optional(PhoneNumberConfigs),
    PersistentConnectionConfigs: S.optional(PersistentConnectionConfigs),
    VoiceEnhancementConfigs: S.optional(VoiceEnhancementConfigs),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/users/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateUserRequest",
}) as any as S.Schema<CreateUserRequest>;
export interface CreateUserResponse {
  UserId?: string;
  UserArn?: string;
}
export const CreateUserResponse = S.suspend(() =>
  S.Struct({ UserId: S.optional(S.String), UserArn: S.optional(S.String) }),
).annotate({
  identifier: "CreateUserResponse",
}) as any as S.Schema<CreateUserResponse>;
export interface CreateUserHierarchyGroupRequest {
  Name: string;
  ParentGroupId?: string;
  InstanceId: string;
  Tags?: { [key: string]: string | undefined };
}
export const CreateUserHierarchyGroupRequest = S.suspend(() =>
  S.Struct({
    Name: S.String,
    ParentGroupId: S.optional(S.String),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/user-hierarchy-groups/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateUserHierarchyGroupRequest",
}) as any as S.Schema<CreateUserHierarchyGroupRequest>;
export interface CreateUserHierarchyGroupResponse {
  HierarchyGroupId?: string;
  HierarchyGroupArn?: string;
}
export const CreateUserHierarchyGroupResponse = S.suspend(() =>
  S.Struct({
    HierarchyGroupId: S.optional(S.String),
    HierarchyGroupArn: S.optional(S.String),
  }),
).annotate({
  identifier: "CreateUserHierarchyGroupResponse",
}) as any as S.Schema<CreateUserHierarchyGroupResponse>;
export type ViewStatus = "PUBLISHED" | "SAVED" | (string & {});
export const ViewStatus = S.String;
export type ViewActions = string | redacted.Redacted<string>[];
export const ViewActions = S.Array(SensitiveString);
export interface ViewInputContent {
  Template?: string;
  Actions?: string | redacted.Redacted<string>[];
}
export const ViewInputContent = S.suspend(() =>
  S.Struct({
    Template: S.optional(S.String),
    Actions: S.optional(ViewActions),
  }),
).annotate({
  identifier: "ViewInputContent",
}) as any as S.Schema<ViewInputContent>;
export interface CreateViewRequest {
  InstanceId: string;
  ClientToken?: string;
  Status: ViewStatus;
  Content: ViewInputContent;
  Description?: string;
  Name: string | redacted.Redacted<string>;
  Tags?: { [key: string]: string | undefined };
}
export const CreateViewRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ClientToken: S.optional(S.String),
    Status: ViewStatus,
    Content: ViewInputContent,
    Description: S.optional(S.String),
    Name: SensitiveString,
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/views/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateViewRequest",
}) as any as S.Schema<CreateViewRequest>;
export type ViewType = "CUSTOMER_MANAGED" | "AWS_MANAGED" | (string & {});
export const ViewType = S.String;
export interface ViewContent {
  InputSchema?: string | redacted.Redacted<string>;
  Template?: string;
  Actions?: string | redacted.Redacted<string>[];
}
export const ViewContent = S.suspend(() =>
  S.Struct({
    InputSchema: S.optional(SensitiveString),
    Template: S.optional(S.String),
    Actions: S.optional(ViewActions),
  }),
).annotate({ identifier: "ViewContent" }) as any as S.Schema<ViewContent>;
export interface View {
  Id?: string;
  Arn?: string;
  Name?: string | redacted.Redacted<string>;
  Status?: ViewStatus;
  Type?: ViewType;
  Description?: string;
  Version?: number;
  VersionDescription?: string;
  Content?: ViewContent;
  Tags?: { [key: string]: string | undefined };
  CreatedTime?: Date;
  LastModifiedTime?: Date;
  ViewContentSha256?: string;
}
export const View = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(SensitiveString),
    Status: S.optional(ViewStatus),
    Type: S.optional(ViewType),
    Description: S.optional(S.String),
    Version: S.optional(S.Number),
    VersionDescription: S.optional(S.String),
    Content: S.optional(ViewContent),
    Tags: S.optional(TagMap),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ViewContentSha256: S.optional(S.String),
  }),
).annotate({ identifier: "View" }) as any as S.Schema<View>;
export interface CreateViewResponse {
  View?: View;
}
export const CreateViewResponse = S.suspend(() =>
  S.Struct({ View: S.optional(View) }),
).annotate({
  identifier: "CreateViewResponse",
}) as any as S.Schema<CreateViewResponse>;
export type ResourceType =
  | "CONTACT"
  | "CONTACT_FLOW"
  | "INSTANCE"
  | "PARTICIPANT"
  | "HIERARCHY_LEVEL"
  | "HIERARCHY_GROUP"
  | "USER"
  | "PHONE_NUMBER"
  | (string & {});
export const ResourceType = S.String;
export interface CreateViewVersionRequest {
  InstanceId: string;
  ViewId: string;
  VersionDescription?: string;
  ViewContentSha256?: string;
}
export const CreateViewVersionRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ViewId: S.String.pipe(T.HttpLabel("ViewId")),
    VersionDescription: S.optional(S.String),
    ViewContentSha256: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/views/{InstanceId}/{ViewId}/versions" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateViewVersionRequest",
}) as any as S.Schema<CreateViewVersionRequest>;
export interface CreateViewVersionResponse {
  View?: View;
}
export const CreateViewVersionResponse = S.suspend(() =>
  S.Struct({ View: S.optional(View) }),
).annotate({
  identifier: "CreateViewVersionResponse",
}) as any as S.Schema<CreateViewVersionResponse>;
export interface CreateVocabularyRequest {
  ClientToken?: string;
  InstanceId: string;
  VocabularyName: string;
  LanguageCode: VocabularyLanguageCode;
  Content: string;
  Tags?: { [key: string]: string | undefined };
}
export const CreateVocabularyRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    VocabularyName: S.String,
    LanguageCode: VocabularyLanguageCode,
    Content: S.String,
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/vocabulary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateVocabularyRequest",
}) as any as S.Schema<CreateVocabularyRequest>;
export type VocabularyState =
  | "CREATION_IN_PROGRESS"
  | "ACTIVE"
  | "CREATION_FAILED"
  | "DELETE_IN_PROGRESS"
  | (string & {});
export const VocabularyState = S.String;
export interface CreateVocabularyResponse {
  VocabularyArn: string;
  VocabularyId: string;
  State: VocabularyState;
}
export const CreateVocabularyResponse = S.suspend(() =>
  S.Struct({
    VocabularyArn: S.String,
    VocabularyId: S.String,
    State: VocabularyState,
  }),
).annotate({
  identifier: "CreateVocabularyResponse",
}) as any as S.Schema<CreateVocabularyResponse>;
export interface PaletteHeader {
  Background?: string;
  Text?: string;
  TextHover?: string;
  InvertActionsColors?: boolean;
}
export const PaletteHeader = S.suspend(() =>
  S.Struct({
    Background: S.optional(S.String),
    Text: S.optional(S.String),
    TextHover: S.optional(S.String),
    InvertActionsColors: S.optional(S.Boolean),
  }),
).annotate({ identifier: "PaletteHeader" }) as any as S.Schema<PaletteHeader>;
export interface PaletteNavigation {
  Background?: string;
  TextBackgroundHover?: string;
  TextBackgroundActive?: string;
  Text?: string;
  TextHover?: string;
  TextActive?: string;
  InvertActionsColors?: boolean;
}
export const PaletteNavigation = S.suspend(() =>
  S.Struct({
    Background: S.optional(S.String),
    TextBackgroundHover: S.optional(S.String),
    TextBackgroundActive: S.optional(S.String),
    Text: S.optional(S.String),
    TextHover: S.optional(S.String),
    TextActive: S.optional(S.String),
    InvertActionsColors: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "PaletteNavigation",
}) as any as S.Schema<PaletteNavigation>;
export interface PaletteCanvas {
  ContainerBackground?: string;
  PageBackground?: string;
  ActiveBackground?: string;
}
export const PaletteCanvas = S.suspend(() =>
  S.Struct({
    ContainerBackground: S.optional(S.String),
    PageBackground: S.optional(S.String),
    ActiveBackground: S.optional(S.String),
  }),
).annotate({ identifier: "PaletteCanvas" }) as any as S.Schema<PaletteCanvas>;
export interface PalettePrimary {
  Default?: string;
  Active?: string;
  ContrastText?: string;
}
export const PalettePrimary = S.suspend(() =>
  S.Struct({
    Default: S.optional(S.String),
    Active: S.optional(S.String),
    ContrastText: S.optional(S.String),
  }),
).annotate({ identifier: "PalettePrimary" }) as any as S.Schema<PalettePrimary>;
export interface WorkspaceThemePalette {
  Header?: PaletteHeader;
  Navigation?: PaletteNavigation;
  Canvas?: PaletteCanvas;
  Primary?: PalettePrimary;
}
export const WorkspaceThemePalette = S.suspend(() =>
  S.Struct({
    Header: S.optional(PaletteHeader),
    Navigation: S.optional(PaletteNavigation),
    Canvas: S.optional(PaletteCanvas),
    Primary: S.optional(PalettePrimary),
  }),
).annotate({
  identifier: "WorkspaceThemePalette",
}) as any as S.Schema<WorkspaceThemePalette>;
export interface ImagesLogo {
  Default?: string;
  Favicon?: string;
}
export const ImagesLogo = S.suspend(() =>
  S.Struct({ Default: S.optional(S.String), Favicon: S.optional(S.String) }),
).annotate({ identifier: "ImagesLogo" }) as any as S.Schema<ImagesLogo>;
export interface WorkspaceThemeImages {
  Logo?: ImagesLogo;
}
export const WorkspaceThemeImages = S.suspend(() =>
  S.Struct({ Logo: S.optional(ImagesLogo) }),
).annotate({
  identifier: "WorkspaceThemeImages",
}) as any as S.Schema<WorkspaceThemeImages>;
export type WorkspaceFontFamily =
  | "Arial"
  | "Courier New"
  | "Georgia"
  | "Times New Roman"
  | "Trebuchet"
  | "Verdana"
  | (string & {});
export const WorkspaceFontFamily = S.String;
export interface FontFamily {
  Default?: WorkspaceFontFamily;
}
export const FontFamily = S.suspend(() =>
  S.Struct({ Default: S.optional(WorkspaceFontFamily) }),
).annotate({ identifier: "FontFamily" }) as any as S.Schema<FontFamily>;
export interface WorkspaceThemeTypography {
  FontFamily?: FontFamily;
}
export const WorkspaceThemeTypography = S.suspend(() =>
  S.Struct({ FontFamily: S.optional(FontFamily) }),
).annotate({
  identifier: "WorkspaceThemeTypography",
}) as any as S.Schema<WorkspaceThemeTypography>;
export interface WorkspaceThemeConfig {
  Palette?: WorkspaceThemePalette;
  Images?: WorkspaceThemeImages;
  Typography?: WorkspaceThemeTypography;
}
export const WorkspaceThemeConfig = S.suspend(() =>
  S.Struct({
    Palette: S.optional(WorkspaceThemePalette),
    Images: S.optional(WorkspaceThemeImages),
    Typography: S.optional(WorkspaceThemeTypography),
  }),
).annotate({
  identifier: "WorkspaceThemeConfig",
}) as any as S.Schema<WorkspaceThemeConfig>;
export interface WorkspaceTheme {
  Light?: WorkspaceThemeConfig;
  Dark?: WorkspaceThemeConfig;
}
export const WorkspaceTheme = S.suspend(() =>
  S.Struct({
    Light: S.optional(WorkspaceThemeConfig),
    Dark: S.optional(WorkspaceThemeConfig),
  }),
).annotate({ identifier: "WorkspaceTheme" }) as any as S.Schema<WorkspaceTheme>;
export interface CreateWorkspaceRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  Theme?: WorkspaceTheme;
  Title?: string;
  Tags?: { [key: string]: string | undefined };
}
export const CreateWorkspaceRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    Theme: S.optional(WorkspaceTheme),
    Title: S.optional(S.String),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/workspaces/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateWorkspaceRequest",
}) as any as S.Schema<CreateWorkspaceRequest>;
export interface CreateWorkspaceResponse {
  WorkspaceId: string;
  WorkspaceArn: string;
}
export const CreateWorkspaceResponse = S.suspend(() =>
  S.Struct({ WorkspaceId: S.String, WorkspaceArn: S.String }),
).annotate({
  identifier: "CreateWorkspaceResponse",
}) as any as S.Schema<CreateWorkspaceResponse>;
export interface CreateWorkspacePageRequest {
  InstanceId: string;
  WorkspaceId: string;
  ResourceArn: string;
  Page: string;
  Slug?: string;
  InputData?: string;
}
export const CreateWorkspacePageRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    ResourceArn: S.String,
    Page: S.String,
    Slug: S.optional(S.String),
    InputData: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/pages",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "CreateWorkspacePageRequest",
}) as any as S.Schema<CreateWorkspacePageRequest>;
export interface CreateWorkspacePageResponse {}
export const CreateWorkspacePageResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "CreateWorkspacePageResponse",
}) as any as S.Schema<CreateWorkspacePageResponse>;
export interface DeactivateEvaluationFormRequest {
  InstanceId: string;
  EvaluationFormId: string;
  EvaluationFormVersion: number;
}
export const DeactivateEvaluationFormRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationFormId: S.String.pipe(T.HttpLabel("EvaluationFormId")),
    EvaluationFormVersion: S.Number,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/evaluation-forms/{InstanceId}/{EvaluationFormId}/deactivate",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeactivateEvaluationFormRequest",
}) as any as S.Schema<DeactivateEvaluationFormRequest>;
export interface DeactivateEvaluationFormResponse {
  EvaluationFormId: string;
  EvaluationFormArn: string;
  EvaluationFormVersion: number;
}
export const DeactivateEvaluationFormResponse = S.suspend(() =>
  S.Struct({
    EvaluationFormId: S.String,
    EvaluationFormArn: S.String,
    EvaluationFormVersion: S.Number,
  }),
).annotate({
  identifier: "DeactivateEvaluationFormResponse",
}) as any as S.Schema<DeactivateEvaluationFormResponse>;
export interface DeleteAttachedFileRequest {
  InstanceId: string;
  FileId: string;
  AssociatedResourceArn: string;
}
export const DeleteAttachedFileRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    FileId: S.String.pipe(T.HttpLabel("FileId")),
    AssociatedResourceArn: S.String.pipe(T.HttpQuery("associatedResourceArn")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/attached-files/{InstanceId}/{FileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteAttachedFileRequest",
}) as any as S.Schema<DeleteAttachedFileRequest>;
export interface DeleteAttachedFileResponse {}
export const DeleteAttachedFileResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteAttachedFileResponse",
}) as any as S.Schema<DeleteAttachedFileResponse>;
export interface DeleteContactEvaluationRequest {
  InstanceId: string;
  EvaluationId: string;
}
export const DeleteContactEvaluationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationId: S.String.pipe(T.HttpLabel("EvaluationId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/contact-evaluations/{InstanceId}/{EvaluationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteContactEvaluationRequest",
}) as any as S.Schema<DeleteContactEvaluationRequest>;
export interface DeleteContactEvaluationResponse {}
export const DeleteContactEvaluationResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteContactEvaluationResponse",
}) as any as S.Schema<DeleteContactEvaluationResponse>;
export interface DeleteContactFlowRequest {
  InstanceId: string;
  ContactFlowId: string;
}
export const DeleteContactFlowRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowId: S.String.pipe(T.HttpLabel("ContactFlowId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/contact-flows/{InstanceId}/{ContactFlowId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteContactFlowRequest",
}) as any as S.Schema<DeleteContactFlowRequest>;
export interface DeleteContactFlowResponse {}
export const DeleteContactFlowResponse = S.suspend(() => S.Struct({})).annotate(
  { identifier: "DeleteContactFlowResponse" },
) as any as S.Schema<DeleteContactFlowResponse>;
export interface DeleteContactFlowModuleRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
}
export const DeleteContactFlowModuleRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteContactFlowModuleRequest",
}) as any as S.Schema<DeleteContactFlowModuleRequest>;
export interface DeleteContactFlowModuleResponse {}
export const DeleteContactFlowModuleResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteContactFlowModuleResponse",
}) as any as S.Schema<DeleteContactFlowModuleResponse>;
export interface DeleteContactFlowModuleAliasRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
  AliasId: string;
}
export const DeleteContactFlowModuleAliasRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    AliasId: S.String.pipe(T.HttpLabel("AliasId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/alias/{AliasId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteContactFlowModuleAliasRequest",
}) as any as S.Schema<DeleteContactFlowModuleAliasRequest>;
export interface DeleteContactFlowModuleAliasResponse {}
export const DeleteContactFlowModuleAliasResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteContactFlowModuleAliasResponse",
}) as any as S.Schema<DeleteContactFlowModuleAliasResponse>;
export interface DeleteContactFlowModuleVersionRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
  ContactFlowModuleVersion: number;
}
export const DeleteContactFlowModuleVersionRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    ContactFlowModuleVersion: S.Number.pipe(
      T.HttpLabel("ContactFlowModuleVersion"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/version/{ContactFlowModuleVersion}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteContactFlowModuleVersionRequest",
}) as any as S.Schema<DeleteContactFlowModuleVersionRequest>;
export interface DeleteContactFlowModuleVersionResponse {}
export const DeleteContactFlowModuleVersionResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteContactFlowModuleVersionResponse",
}) as any as S.Schema<DeleteContactFlowModuleVersionResponse>;
export interface DeleteContactFlowVersionRequest {
  InstanceId: string;
  ContactFlowId: string;
  ContactFlowVersion: number;
}
export const DeleteContactFlowVersionRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowId: S.String.pipe(T.HttpLabel("ContactFlowId")),
    ContactFlowVersion: S.Number.pipe(T.HttpLabel("ContactFlowVersion")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/contact-flows/{InstanceId}/{ContactFlowId}/version/{ContactFlowVersion}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteContactFlowVersionRequest",
}) as any as S.Schema<DeleteContactFlowVersionRequest>;
export interface DeleteContactFlowVersionResponse {}
export const DeleteContactFlowVersionResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteContactFlowVersionResponse",
}) as any as S.Schema<DeleteContactFlowVersionResponse>;
export interface DeleteDataTableRequest {
  InstanceId: string;
  DataTableId: string;
}
export const DeleteDataTableRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/data-tables/{InstanceId}/{DataTableId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteDataTableRequest",
}) as any as S.Schema<DeleteDataTableRequest>;
export interface DeleteDataTableResponse {}
export const DeleteDataTableResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "DeleteDataTableResponse",
}) as any as S.Schema<DeleteDataTableResponse>;
export interface DeleteDataTableAttributeRequest {
  InstanceId: string;
  DataTableId: string;
  AttributeName: string;
}
export const DeleteDataTableAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    AttributeName: S.String.pipe(T.HttpLabel("AttributeName")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/data-tables/{InstanceId}/{DataTableId}/attributes/{AttributeName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteDataTableAttributeRequest",
}) as any as S.Schema<DeleteDataTableAttributeRequest>;
export interface DeleteDataTableAttributeResponse {
  LockVersion: DataTableLockVersion;
}
export const DeleteDataTableAttributeResponse = S.suspend(() =>
  S.Struct({ LockVersion: DataTableLockVersion }),
).annotate({
  identifier: "DeleteDataTableAttributeResponse",
}) as any as S.Schema<DeleteDataTableAttributeResponse>;
export interface DeleteEmailAddressRequest {
  InstanceId: string;
  EmailAddressId: string;
}
export const DeleteEmailAddressRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EmailAddressId: S.String.pipe(T.HttpLabel("EmailAddressId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/email-addresses/{InstanceId}/{EmailAddressId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteEmailAddressRequest",
}) as any as S.Schema<DeleteEmailAddressRequest>;
export interface DeleteEmailAddressResponse {}
export const DeleteEmailAddressResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteEmailAddressResponse",
}) as any as S.Schema<DeleteEmailAddressResponse>;
export interface DeleteEvaluationFormRequest {
  InstanceId: string;
  EvaluationFormId: string;
  EvaluationFormVersion?: number;
}
export const DeleteEvaluationFormRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationFormId: S.String.pipe(T.HttpLabel("EvaluationFormId")),
    EvaluationFormVersion: S.optional(S.Number).pipe(T.HttpQuery("version")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/evaluation-forms/{InstanceId}/{EvaluationFormId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteEvaluationFormRequest",
}) as any as S.Schema<DeleteEvaluationFormRequest>;
export interface DeleteEvaluationFormResponse {}
export const DeleteEvaluationFormResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteEvaluationFormResponse",
}) as any as S.Schema<DeleteEvaluationFormResponse>;
export interface DeleteHoursOfOperationRequest {
  InstanceId: string;
  HoursOfOperationId: string;
}
export const DeleteHoursOfOperationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteHoursOfOperationRequest",
}) as any as S.Schema<DeleteHoursOfOperationRequest>;
export interface DeleteHoursOfOperationResponse {}
export const DeleteHoursOfOperationResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteHoursOfOperationResponse",
}) as any as S.Schema<DeleteHoursOfOperationResponse>;
export interface DeleteHoursOfOperationOverrideRequest {
  InstanceId: string;
  HoursOfOperationId: string;
  HoursOfOperationOverrideId: string;
}
export const DeleteHoursOfOperationOverrideRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
    HoursOfOperationOverrideId: S.String.pipe(
      T.HttpLabel("HoursOfOperationOverrideId"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}/overrides/{HoursOfOperationOverrideId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteHoursOfOperationOverrideRequest",
}) as any as S.Schema<DeleteHoursOfOperationOverrideRequest>;
export interface DeleteHoursOfOperationOverrideResponse {}
export const DeleteHoursOfOperationOverrideResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteHoursOfOperationOverrideResponse",
}) as any as S.Schema<DeleteHoursOfOperationOverrideResponse>;
export interface DeleteInstanceRequest {
  InstanceId: string;
  ClientToken?: string;
}
export const DeleteInstanceRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ClientToken: S.optional(S.String).pipe(
      T.HttpQuery("clientToken"),
      T.IdempotencyToken(),
    ),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/instance/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteInstanceRequest",
}) as any as S.Schema<DeleteInstanceRequest>;
export interface DeleteInstanceResponse {}
export const DeleteInstanceResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "DeleteInstanceResponse",
}) as any as S.Schema<DeleteInstanceResponse>;
export interface DeleteIntegrationAssociationRequest {
  InstanceId: string;
  IntegrationAssociationId: string;
}
export const DeleteIntegrationAssociationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    IntegrationAssociationId: S.String.pipe(
      T.HttpLabel("IntegrationAssociationId"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/instance/{InstanceId}/integration-associations/{IntegrationAssociationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteIntegrationAssociationRequest",
}) as any as S.Schema<DeleteIntegrationAssociationRequest>;
export interface DeleteIntegrationAssociationResponse {}
export const DeleteIntegrationAssociationResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteIntegrationAssociationResponse",
}) as any as S.Schema<DeleteIntegrationAssociationResponse>;
export interface DeleteNotificationRequest {
  InstanceId: string;
  NotificationId: string;
}
export const DeleteNotificationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NotificationId: S.String.pipe(T.HttpLabel("NotificationId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/notifications/{InstanceId}/{NotificationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteNotificationRequest",
}) as any as S.Schema<DeleteNotificationRequest>;
export interface DeleteNotificationResponse {}
export const DeleteNotificationResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteNotificationResponse",
}) as any as S.Schema<DeleteNotificationResponse>;
export interface DeletePredefinedAttributeRequest {
  InstanceId: string;
  Name: string;
}
export const DeletePredefinedAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String.pipe(T.HttpLabel("Name")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/predefined-attributes/{InstanceId}/{Name}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeletePredefinedAttributeRequest",
}) as any as S.Schema<DeletePredefinedAttributeRequest>;
export interface DeletePredefinedAttributeResponse {}
export const DeletePredefinedAttributeResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeletePredefinedAttributeResponse",
}) as any as S.Schema<DeletePredefinedAttributeResponse>;
export interface DeletePromptRequest {
  InstanceId: string;
  PromptId: string;
}
export const DeletePromptRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    PromptId: S.String.pipe(T.HttpLabel("PromptId")),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/prompts/{InstanceId}/{PromptId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeletePromptRequest",
}) as any as S.Schema<DeletePromptRequest>;
export interface DeletePromptResponse {}
export const DeletePromptResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "DeletePromptResponse",
}) as any as S.Schema<DeletePromptResponse>;
export interface DeletePushNotificationRegistrationRequest {
  InstanceId: string;
  RegistrationId: string;
  ContactId: string;
}
export const DeletePushNotificationRegistrationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RegistrationId: S.String.pipe(T.HttpLabel("RegistrationId")),
    ContactId: S.String.pipe(T.HttpQuery("contactId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/push-notification/{InstanceId}/registrations/{RegistrationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeletePushNotificationRegistrationRequest",
}) as any as S.Schema<DeletePushNotificationRegistrationRequest>;
export interface DeletePushNotificationRegistrationResponse {}
export const DeletePushNotificationRegistrationResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeletePushNotificationRegistrationResponse",
}) as any as S.Schema<DeletePushNotificationRegistrationResponse>;
export interface DeleteQueueRequest {
  InstanceId: string;
  QueueId: string;
}
export const DeleteQueueRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/queues/{InstanceId}/{QueueId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteQueueRequest",
}) as any as S.Schema<DeleteQueueRequest>;
export interface DeleteQueueResponse {}
export const DeleteQueueResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "DeleteQueueResponse",
}) as any as S.Schema<DeleteQueueResponse>;
export interface DeleteQuickConnectRequest {
  InstanceId: string;
  QuickConnectId: string;
}
export const DeleteQuickConnectRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QuickConnectId: S.String.pipe(T.HttpLabel("QuickConnectId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/quick-connects/{InstanceId}/{QuickConnectId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteQuickConnectRequest",
}) as any as S.Schema<DeleteQuickConnectRequest>;
export interface DeleteQuickConnectResponse {}
export const DeleteQuickConnectResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteQuickConnectResponse",
}) as any as S.Schema<DeleteQuickConnectResponse>;
export interface DeleteRoutingProfileRequest {
  InstanceId: string;
  RoutingProfileId: string;
}
export const DeleteRoutingProfileRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteRoutingProfileRequest",
}) as any as S.Schema<DeleteRoutingProfileRequest>;
export interface DeleteRoutingProfileResponse {}
export const DeleteRoutingProfileResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteRoutingProfileResponse",
}) as any as S.Schema<DeleteRoutingProfileResponse>;
export interface DeleteRuleRequest {
  InstanceId: string;
  RuleId: string;
}
export const DeleteRuleRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RuleId: S.String.pipe(T.HttpLabel("RuleId")),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/rules/{InstanceId}/{RuleId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteRuleRequest",
}) as any as S.Schema<DeleteRuleRequest>;
export interface DeleteRuleResponse {}
export const DeleteRuleResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "DeleteRuleResponse",
}) as any as S.Schema<DeleteRuleResponse>;
export interface DeleteSecurityProfileRequest {
  InstanceId: string;
  SecurityProfileId: string;
}
export const DeleteSecurityProfileRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    SecurityProfileId: S.String.pipe(T.HttpLabel("SecurityProfileId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/security-profiles/{InstanceId}/{SecurityProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteSecurityProfileRequest",
}) as any as S.Schema<DeleteSecurityProfileRequest>;
export interface DeleteSecurityProfileResponse {}
export const DeleteSecurityProfileResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteSecurityProfileResponse",
}) as any as S.Schema<DeleteSecurityProfileResponse>;
export interface DeleteTaskTemplateRequest {
  InstanceId: string;
  TaskTemplateId: string;
}
export const DeleteTaskTemplateRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    TaskTemplateId: S.String.pipe(T.HttpLabel("TaskTemplateId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/instance/{InstanceId}/task/template/{TaskTemplateId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTaskTemplateRequest",
}) as any as S.Schema<DeleteTaskTemplateRequest>;
export interface DeleteTaskTemplateResponse {}
export const DeleteTaskTemplateResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteTaskTemplateResponse",
}) as any as S.Schema<DeleteTaskTemplateResponse>;
export interface DeleteTestCaseRequest {
  InstanceId: string;
  TestCaseId: string;
}
export const DeleteTestCaseRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    TestCaseId: S.String.pipe(T.HttpLabel("TestCaseId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/test-cases/{InstanceId}/{TestCaseId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTestCaseRequest",
}) as any as S.Schema<DeleteTestCaseRequest>;
export interface DeleteTestCaseResponse {}
export const DeleteTestCaseResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "DeleteTestCaseResponse",
}) as any as S.Schema<DeleteTestCaseResponse>;
export interface DeleteTrafficDistributionGroupRequest {
  TrafficDistributionGroupId: string;
}
export const DeleteTrafficDistributionGroupRequest = S.suspend(() =>
  S.Struct({
    TrafficDistributionGroupId: S.String.pipe(
      T.HttpLabel("TrafficDistributionGroupId"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/traffic-distribution-group/{TrafficDistributionGroupId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteTrafficDistributionGroupRequest",
}) as any as S.Schema<DeleteTrafficDistributionGroupRequest>;
export interface DeleteTrafficDistributionGroupResponse {}
export const DeleteTrafficDistributionGroupResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteTrafficDistributionGroupResponse",
}) as any as S.Schema<DeleteTrafficDistributionGroupResponse>;
export interface DeleteUseCaseRequest {
  InstanceId: string;
  IntegrationAssociationId: string;
  UseCaseId: string;
}
export const DeleteUseCaseRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    IntegrationAssociationId: S.String.pipe(
      T.HttpLabel("IntegrationAssociationId"),
    ),
    UseCaseId: S.String.pipe(T.HttpLabel("UseCaseId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/instance/{InstanceId}/integration-associations/{IntegrationAssociationId}/use-cases/{UseCaseId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteUseCaseRequest",
}) as any as S.Schema<DeleteUseCaseRequest>;
export interface DeleteUseCaseResponse {}
export const DeleteUseCaseResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "DeleteUseCaseResponse",
}) as any as S.Schema<DeleteUseCaseResponse>;
export interface DeleteUserRequest {
  InstanceId: string;
  UserId: string;
}
export const DeleteUserRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    UserId: S.String.pipe(T.HttpLabel("UserId")),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/users/{InstanceId}/{UserId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteUserRequest",
}) as any as S.Schema<DeleteUserRequest>;
export interface DeleteUserResponse {}
export const DeleteUserResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "DeleteUserResponse",
}) as any as S.Schema<DeleteUserResponse>;
export interface DeleteUserHierarchyGroupRequest {
  HierarchyGroupId: string;
  InstanceId: string;
}
export const DeleteUserHierarchyGroupRequest = S.suspend(() =>
  S.Struct({
    HierarchyGroupId: S.String.pipe(T.HttpLabel("HierarchyGroupId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/user-hierarchy-groups/{InstanceId}/{HierarchyGroupId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteUserHierarchyGroupRequest",
}) as any as S.Schema<DeleteUserHierarchyGroupRequest>;
export interface DeleteUserHierarchyGroupResponse {}
export const DeleteUserHierarchyGroupResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteUserHierarchyGroupResponse",
}) as any as S.Schema<DeleteUserHierarchyGroupResponse>;
export interface DeleteViewRequest {
  InstanceId: string;
  ViewId: string;
}
export const DeleteViewRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ViewId: S.String.pipe(T.HttpLabel("ViewId")),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/views/{InstanceId}/{ViewId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteViewRequest",
}) as any as S.Schema<DeleteViewRequest>;
export interface DeleteViewResponse {}
export const DeleteViewResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "DeleteViewResponse",
}) as any as S.Schema<DeleteViewResponse>;
export interface DeleteViewVersionRequest {
  InstanceId: string;
  ViewId: string;
  ViewVersion: number;
}
export const DeleteViewVersionRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ViewId: S.String.pipe(T.HttpLabel("ViewId")),
    ViewVersion: S.Number.pipe(T.HttpLabel("ViewVersion")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/views/{InstanceId}/{ViewId}/versions/{ViewVersion}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteViewVersionRequest",
}) as any as S.Schema<DeleteViewVersionRequest>;
export interface DeleteViewVersionResponse {}
export const DeleteViewVersionResponse = S.suspend(() => S.Struct({})).annotate(
  { identifier: "DeleteViewVersionResponse" },
) as any as S.Schema<DeleteViewVersionResponse>;
export interface DeleteVocabularyRequest {
  InstanceId: string;
  VocabularyId: string;
}
export const DeleteVocabularyRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    VocabularyId: S.String.pipe(T.HttpLabel("VocabularyId")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/vocabulary-remove/{InstanceId}/{VocabularyId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteVocabularyRequest",
}) as any as S.Schema<DeleteVocabularyRequest>;
export interface DeleteVocabularyResponse {
  VocabularyArn: string;
  VocabularyId: string;
  State: VocabularyState;
}
export const DeleteVocabularyResponse = S.suspend(() =>
  S.Struct({
    VocabularyArn: S.String,
    VocabularyId: S.String,
    State: VocabularyState,
  }),
).annotate({
  identifier: "DeleteVocabularyResponse",
}) as any as S.Schema<DeleteVocabularyResponse>;
export interface DeleteWorkspaceRequest {
  InstanceId: string;
  WorkspaceId: string;
}
export const DeleteWorkspaceRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteWorkspaceRequest",
}) as any as S.Schema<DeleteWorkspaceRequest>;
export interface DeleteWorkspaceResponse {}
export const DeleteWorkspaceResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "DeleteWorkspaceResponse",
}) as any as S.Schema<DeleteWorkspaceResponse>;
export type MediaType =
  | "IMAGE_LOGO_LIGHT_FAVICON"
  | "IMAGE_LOGO_DARK_FAVICON"
  | "IMAGE_LOGO_LIGHT_HORIZONTAL"
  | "IMAGE_LOGO_DARK_HORIZONTAL"
  | (string & {});
export const MediaType = S.String;
export interface DeleteWorkspaceMediaRequest {
  InstanceId: string;
  WorkspaceId: string;
  MediaType: MediaType;
}
export const DeleteWorkspaceMediaRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    MediaType: MediaType.pipe(T.HttpQuery("mediaType")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/media",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteWorkspaceMediaRequest",
}) as any as S.Schema<DeleteWorkspaceMediaRequest>;
export interface DeleteWorkspaceMediaResponse {}
export const DeleteWorkspaceMediaResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteWorkspaceMediaResponse",
}) as any as S.Schema<DeleteWorkspaceMediaResponse>;
export interface DeleteWorkspacePageRequest {
  InstanceId: string;
  WorkspaceId: string;
  Page: string;
}
export const DeleteWorkspacePageRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    Page: S.String.pipe(T.HttpLabel("Page")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/pages/{Page}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DeleteWorkspacePageRequest",
}) as any as S.Schema<DeleteWorkspacePageRequest>;
export interface DeleteWorkspacePageResponse {}
export const DeleteWorkspacePageResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DeleteWorkspacePageResponse",
}) as any as S.Schema<DeleteWorkspacePageResponse>;
export interface DescribeAgentStatusRequest {
  InstanceId: string;
  AgentStatusId: string;
}
export const DescribeAgentStatusRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AgentStatusId: S.String.pipe(T.HttpLabel("AgentStatusId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/agent-status/{InstanceId}/{AgentStatusId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeAgentStatusRequest",
}) as any as S.Schema<DescribeAgentStatusRequest>;
export type AgentStatusType = "ROUTABLE" | "CUSTOM" | "OFFLINE" | (string & {});
export const AgentStatusType = S.String;
export interface AgentStatus {
  AgentStatusARN?: string;
  AgentStatusId?: string;
  Name?: string;
  Description?: string;
  Type?: AgentStatusType;
  DisplayOrder?: number;
  State?: AgentStatusState;
  Tags?: { [key: string]: string | undefined };
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const AgentStatus = S.suspend(() =>
  S.Struct({
    AgentStatusARN: S.optional(S.String),
    AgentStatusId: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    Type: S.optional(AgentStatusType),
    DisplayOrder: S.optional(S.Number),
    State: S.optional(AgentStatusState),
    Tags: S.optional(TagMap),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({ identifier: "AgentStatus" }) as any as S.Schema<AgentStatus>;
export interface DescribeAgentStatusResponse {
  AgentStatus?: AgentStatus;
}
export const DescribeAgentStatusResponse = S.suspend(() =>
  S.Struct({ AgentStatus: S.optional(AgentStatus) }),
).annotate({
  identifier: "DescribeAgentStatusResponse",
}) as any as S.Schema<DescribeAgentStatusResponse>;
export interface DescribeAuthenticationProfileRequest {
  AuthenticationProfileId: string;
  InstanceId: string;
}
export const DescribeAuthenticationProfileRequest = S.suspend(() =>
  S.Struct({
    AuthenticationProfileId: S.String.pipe(
      T.HttpLabel("AuthenticationProfileId"),
    ),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/authentication-profiles/{InstanceId}/{AuthenticationProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeAuthenticationProfileRequest",
}) as any as S.Schema<DescribeAuthenticationProfileRequest>;
export type IpCidrList = string[];
export const IpCidrList = S.Array(S.String);
export interface AuthenticationProfile {
  Id?: string;
  Arn?: string;
  Name?: string;
  Description?: string;
  AllowedIps?: string[];
  BlockedIps?: string[];
  IsDefault?: boolean;
  CreatedTime?: Date;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
  PeriodicSessionDuration?: number;
  MaxSessionDuration?: number;
  SessionInactivityDuration?: number;
  SessionInactivityHandlingEnabled?: boolean;
}
export const AuthenticationProfile = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    AllowedIps: S.optional(IpCidrList),
    BlockedIps: S.optional(IpCidrList),
    IsDefault: S.optional(S.Boolean),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
    PeriodicSessionDuration: S.optional(S.Number),
    MaxSessionDuration: S.optional(S.Number),
    SessionInactivityDuration: S.optional(S.Number),
    SessionInactivityHandlingEnabled: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "AuthenticationProfile",
}) as any as S.Schema<AuthenticationProfile>;
export interface DescribeAuthenticationProfileResponse {
  AuthenticationProfile?: AuthenticationProfile;
}
export const DescribeAuthenticationProfileResponse = S.suspend(() =>
  S.Struct({ AuthenticationProfile: S.optional(AuthenticationProfile) }),
).annotate({
  identifier: "DescribeAuthenticationProfileResponse",
}) as any as S.Schema<DescribeAuthenticationProfileResponse>;
export interface DescribeContactRequest {
  InstanceId: string;
  ContactId: string;
}
export const DescribeContactRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String.pipe(T.HttpLabel("ContactId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/contacts/{InstanceId}/{ContactId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeContactRequest",
}) as any as S.Schema<DescribeContactRequest>;
export interface QueueInfo {
  Id?: string;
  EnqueueTimestamp?: Date;
}
export const QueueInfo = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    EnqueueTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({ identifier: "QueueInfo" }) as any as S.Schema<QueueInfo>;
export interface AgentHierarchyGroup {
  Arn?: string;
}
export const AgentHierarchyGroup = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }),
).annotate({
  identifier: "AgentHierarchyGroup",
}) as any as S.Schema<AgentHierarchyGroup>;
export interface HierarchyGroups {
  Level1?: AgentHierarchyGroup;
  Level2?: AgentHierarchyGroup;
  Level3?: AgentHierarchyGroup;
  Level4?: AgentHierarchyGroup;
  Level5?: AgentHierarchyGroup;
}
export const HierarchyGroups = S.suspend(() =>
  S.Struct({
    Level1: S.optional(AgentHierarchyGroup),
    Level2: S.optional(AgentHierarchyGroup),
    Level3: S.optional(AgentHierarchyGroup),
    Level4: S.optional(AgentHierarchyGroup),
    Level5: S.optional(AgentHierarchyGroup),
  }),
).annotate({
  identifier: "HierarchyGroups",
}) as any as S.Schema<HierarchyGroups>;
export interface DeviceInfo {
  PlatformName?: string;
  PlatformVersion?: string;
  OperatingSystem?: string;
}
export const DeviceInfo = S.suspend(() =>
  S.Struct({
    PlatformName: S.optional(S.String),
    PlatformVersion: S.optional(S.String),
    OperatingSystem: S.optional(S.String),
  }),
).annotate({ identifier: "DeviceInfo" }) as any as S.Schema<DeviceInfo>;
export type ParticipantState =
  | "INITIAL"
  | "CONNECTED"
  | "DISCONNECTED"
  | "MISSED"
  | (string & {});
export const ParticipantState = S.String;
export interface StateTransition {
  State?: ParticipantState;
  StateStartTimestamp?: Date;
  StateEndTimestamp?: Date;
}
export const StateTransition = S.suspend(() =>
  S.Struct({
    State: S.optional(ParticipantState),
    StateStartTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    StateEndTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "StateTransition",
}) as any as S.Schema<StateTransition>;
export type StateTransitions = StateTransition[];
export const StateTransitions = S.Array(StateTransition);
export interface AgentInfo {
  Id?: string;
  AcceptedByAgentTimestamp?: Date;
  PreviewEndTimestamp?: Date;
  ConnectedToAgentTimestamp?: Date;
  AgentPauseDurationInSeconds?: number;
  HierarchyGroups?: HierarchyGroups;
  DeviceInfo?: DeviceInfo;
  Capabilities?: ParticipantCapabilities;
  AfterContactWorkDuration?: number;
  AfterContactWorkStartTimestamp?: Date;
  AfterContactWorkEndTimestamp?: Date;
  AgentInitiatedHoldDuration?: number;
  StateTransitions?: StateTransition[];
}
export const AgentInfo = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    AcceptedByAgentTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    PreviewEndTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ConnectedToAgentTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    AgentPauseDurationInSeconds: S.optional(S.Number),
    HierarchyGroups: S.optional(HierarchyGroups),
    DeviceInfo: S.optional(DeviceInfo),
    Capabilities: S.optional(ParticipantCapabilities),
    AfterContactWorkDuration: S.optional(S.Number),
    AfterContactWorkStartTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    AfterContactWorkEndTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    AgentInitiatedHoldDuration: S.optional(S.Number),
    StateTransitions: S.optional(StateTransitions),
  }),
).annotate({ identifier: "AgentInfo" }) as any as S.Schema<AgentInfo>;
export type AiUseCase = "AgentAssistance" | "SelfService" | (string & {});
export const AiUseCase = S.String;
export interface AiAgentInfo {
  AiUseCase?: AiUseCase;
  AiAgentVersionId?: string;
  AiAgentEscalated?: boolean;
}
export const AiAgentInfo = S.suspend(() =>
  S.Struct({
    AiUseCase: S.optional(AiUseCase),
    AiAgentVersionId: S.optional(S.String),
    AiAgentEscalated: S.optional(S.Boolean),
  }),
).annotate({ identifier: "AiAgentInfo" }) as any as S.Schema<AiAgentInfo>;
export type AiAgents = AiAgentInfo[];
export const AiAgents = S.Array(AiAgentInfo);
export interface WisdomInfo {
  SessionArn?: string;
  AiAgents?: AiAgentInfo[];
}
export const WisdomInfo = S.suspend(() =>
  S.Struct({
    SessionArn: S.optional(S.String),
    AiAgents: S.optional(AiAgents),
  }),
).annotate({ identifier: "WisdomInfo" }) as any as S.Schema<WisdomInfo>;
export interface EndpointInfo {
  Type?: EndpointType;
  Address?: string;
  DisplayName?: string;
}
export const EndpointInfo = S.suspend(() =>
  S.Struct({
    Type: S.optional(EndpointType),
    Address: S.optional(S.String),
    DisplayName: S.optional(S.String),
  }),
).annotate({ identifier: "EndpointInfo" }) as any as S.Schema<EndpointInfo>;
export type ContactTagMap = { [key: string]: string | undefined };
export const ContactTagMap = S.Record(S.String, S.String.pipe(S.optional));
export interface Expiry {
  DurationInSeconds?: number;
  ExpiryTimestamp?: Date;
}
export const Expiry = S.suspend(() =>
  S.Struct({
    DurationInSeconds: S.optional(S.Number),
    ExpiryTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({ identifier: "Expiry" }) as any as S.Schema<Expiry>;
export interface Range {
  MinProficiencyLevel?: number;
  MaxProficiencyLevel?: number;
}
export const Range = S.suspend(() =>
  S.Struct({
    MinProficiencyLevel: S.optional(S.Number),
    MaxProficiencyLevel: S.optional(S.Number),
  }),
).annotate({ identifier: "Range" }) as any as S.Schema<Range>;
export type AgentIds = string[];
export const AgentIds = S.Array(S.String);
export interface AgentsCriteria {
  AgentIds?: string[];
}
export const AgentsCriteria = S.suspend(() =>
  S.Struct({ AgentIds: S.optional(AgentIds) }),
).annotate({ identifier: "AgentsCriteria" }) as any as S.Schema<AgentsCriteria>;
export interface MatchCriteria {
  AgentsCriteria?: AgentsCriteria;
}
export const MatchCriteria = S.suspend(() =>
  S.Struct({ AgentsCriteria: S.optional(AgentsCriteria) }),
).annotate({ identifier: "MatchCriteria" }) as any as S.Schema<MatchCriteria>;
export interface AttributeCondition {
  Name?: string;
  Value?: string;
  ProficiencyLevel?: number;
  Range?: Range;
  MatchCriteria?: MatchCriteria;
  ComparisonOperator?: string;
}
export const AttributeCondition = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Value: S.optional(S.String),
    ProficiencyLevel: S.optional(S.Number),
    Range: S.optional(Range),
    MatchCriteria: S.optional(MatchCriteria),
    ComparisonOperator: S.optional(S.String),
  }),
).annotate({
  identifier: "AttributeCondition",
}) as any as S.Schema<AttributeCondition>;
export type Expressions = Expression[];
export const Expressions = S.Array(
  S.suspend((): S.Schema<Expression> => Expression).annotate({
    identifier: "Expression",
  }),
) as any as S.Schema<Expressions>;
export interface Expression {
  AttributeCondition?: AttributeCondition;
  AndExpression?: Expression[];
  OrExpression?: Expression[];
  NotAttributeCondition?: AttributeCondition;
}
export const Expression = S.suspend(() =>
  S.Struct({
    AttributeCondition: S.optional(AttributeCondition),
    AndExpression: S.optional(
      S.suspend(() => Expressions).annotate({ identifier: "Expressions" }),
    ),
    OrExpression: S.optional(
      S.suspend(() => Expressions).annotate({ identifier: "Expressions" }),
    ),
    NotAttributeCondition: S.optional(AttributeCondition),
  }),
).annotate({ identifier: "Expression" }) as any as S.Schema<Expression>;
export type RoutingCriteriaStepStatus =
  | "ACTIVE"
  | "INACTIVE"
  | "JOINED"
  | "EXPIRED"
  | (string & {});
export const RoutingCriteriaStepStatus = S.String;
export interface Step {
  Expiry?: Expiry;
  Expression?: Expression;
  Status?: RoutingCriteriaStepStatus;
}
export const Step = S.suspend(() =>
  S.Struct({
    Expiry: S.optional(Expiry),
    Expression: S.optional(Expression),
    Status: S.optional(RoutingCriteriaStepStatus),
  }),
).annotate({ identifier: "Step" }) as any as S.Schema<Step>;
export type Steps = Step[];
export const Steps = S.Array(Step);
export interface RoutingCriteria {
  Steps?: Step[];
  ActivationTimestamp?: Date;
  Index?: number;
}
export const RoutingCriteria = S.suspend(() =>
  S.Struct({
    Steps: S.optional(Steps),
    ActivationTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    Index: S.optional(S.Number),
  }),
).annotate({
  identifier: "RoutingCriteria",
}) as any as S.Schema<RoutingCriteria>;
export interface Customer {
  DeviceInfo?: DeviceInfo;
  Capabilities?: ParticipantCapabilities;
}
export const Customer = S.suspend(() =>
  S.Struct({
    DeviceInfo: S.optional(DeviceInfo),
    Capabilities: S.optional(ParticipantCapabilities),
  }),
).annotate({ identifier: "Customer" }) as any as S.Schema<Customer>;
export type AnsweringMachineDetectionStatus =
  | "ANSWERED"
  | "UNDETECTED"
  | "ERROR"
  | "HUMAN_ANSWERED"
  | "SIT_TONE_DETECTED"
  | "SIT_TONE_BUSY"
  | "SIT_TONE_INVALID_NUMBER"
  | "FAX_MACHINE_DETECTED"
  | "VOICEMAIL_BEEP"
  | "VOICEMAIL_NO_BEEP"
  | "AMD_UNRESOLVED"
  | "AMD_UNANSWERED"
  | "AMD_ERROR"
  | "AMD_NOT_APPLICABLE"
  | (string & {});
export const AnsweringMachineDetectionStatus = S.String;
export interface CustomerVoiceActivity {
  GreetingStartTimestamp?: Date;
  GreetingEndTimestamp?: Date;
}
export const CustomerVoiceActivity = S.suspend(() =>
  S.Struct({
    GreetingStartTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    GreetingEndTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "CustomerVoiceActivity",
}) as any as S.Schema<CustomerVoiceActivity>;
export type PotentialAudioQualityIssues = string[];
export const PotentialAudioQualityIssues = S.Array(S.String);
export interface AudioQualityMetricsInfo {
  QualityScore?: number;
  PotentialQualityIssues?: string[];
}
export const AudioQualityMetricsInfo = S.suspend(() =>
  S.Struct({
    QualityScore: S.optional(S.Number),
    PotentialQualityIssues: S.optional(PotentialAudioQualityIssues),
  }),
).annotate({
  identifier: "AudioQualityMetricsInfo",
}) as any as S.Schema<AudioQualityMetricsInfo>;
export interface AgentQualityMetrics {
  Audio?: AudioQualityMetricsInfo;
}
export const AgentQualityMetrics = S.suspend(() =>
  S.Struct({ Audio: S.optional(AudioQualityMetricsInfo) }),
).annotate({
  identifier: "AgentQualityMetrics",
}) as any as S.Schema<AgentQualityMetrics>;
export interface CustomerQualityMetrics {
  Audio?: AudioQualityMetricsInfo;
}
export const CustomerQualityMetrics = S.suspend(() =>
  S.Struct({ Audio: S.optional(AudioQualityMetricsInfo) }),
).annotate({
  identifier: "CustomerQualityMetrics",
}) as any as S.Schema<CustomerQualityMetrics>;
export interface QualityMetrics {
  Agent?: AgentQualityMetrics;
  Customer?: CustomerQualityMetrics;
}
export const QualityMetrics = S.suspend(() =>
  S.Struct({
    Agent: S.optional(AgentQualityMetrics),
    Customer: S.optional(CustomerQualityMetrics),
  }),
).annotate({ identifier: "QualityMetrics" }) as any as S.Schema<QualityMetrics>;
export interface ChatContactMetrics {
  MultiParty?: boolean;
  TotalMessages?: number;
  TotalBotMessages?: number;
  TotalBotMessageLengthInChars?: number;
  ConversationCloseTimeInMillis?: number;
  ConversationTurnCount?: number;
  AgentFirstResponseTimestamp?: Date;
  AgentFirstResponseTimeInMillis?: number;
}
export const ChatContactMetrics = S.suspend(() =>
  S.Struct({
    MultiParty: S.optional(S.Boolean),
    TotalMessages: S.optional(S.Number),
    TotalBotMessages: S.optional(S.Number),
    TotalBotMessageLengthInChars: S.optional(S.Number),
    ConversationCloseTimeInMillis: S.optional(S.Number),
    ConversationTurnCount: S.optional(S.Number),
    AgentFirstResponseTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    AgentFirstResponseTimeInMillis: S.optional(S.Number),
  }),
).annotate({
  identifier: "ChatContactMetrics",
}) as any as S.Schema<ChatContactMetrics>;
export type ParticipantType =
  | "ALL"
  | "MANAGER"
  | "AGENT"
  | "CUSTOMER"
  | "THIRDPARTY"
  | (string & {});
export const ParticipantType = S.String;
export interface ParticipantMetrics {
  ParticipantId?: string;
  ParticipantType?: ParticipantType;
  ConversationAbandon?: boolean;
  MessagesSent?: number;
  NumResponses?: number;
  MessageLengthInChars?: number;
  TotalResponseTimeInMillis?: number;
  MaxResponseTimeInMillis?: number;
  LastMessageTimestamp?: Date;
}
export const ParticipantMetrics = S.suspend(() =>
  S.Struct({
    ParticipantId: S.optional(S.String),
    ParticipantType: S.optional(ParticipantType),
    ConversationAbandon: S.optional(S.Boolean),
    MessagesSent: S.optional(S.Number),
    NumResponses: S.optional(S.Number),
    MessageLengthInChars: S.optional(S.Number),
    TotalResponseTimeInMillis: S.optional(S.Number),
    MaxResponseTimeInMillis: S.optional(S.Number),
    LastMessageTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "ParticipantMetrics",
}) as any as S.Schema<ParticipantMetrics>;
export interface ChatMetrics {
  ChatContactMetrics?: ChatContactMetrics;
  AgentMetrics?: ParticipantMetrics;
  CustomerMetrics?: ParticipantMetrics;
}
export const ChatMetrics = S.suspend(() =>
  S.Struct({
    ChatContactMetrics: S.optional(ChatContactMetrics),
    AgentMetrics: S.optional(ParticipantMetrics),
    CustomerMetrics: S.optional(ParticipantMetrics),
  }),
).annotate({ identifier: "ChatMetrics" }) as any as S.Schema<ChatMetrics>;
export interface DisconnectDetails {
  PotentialDisconnectIssue?: string;
}
export const DisconnectDetails = S.suspend(() =>
  S.Struct({ PotentialDisconnectIssue: S.optional(S.String) }),
).annotate({
  identifier: "DisconnectDetails",
}) as any as S.Schema<DisconnectDetails>;
export interface EmailRecipient {
  Address?: string;
  DisplayName?: string;
}
export const EmailRecipient = S.suspend(() =>
  S.Struct({
    Address: S.optional(S.String),
    DisplayName: S.optional(S.String),
  }),
).annotate({ identifier: "EmailRecipient" }) as any as S.Schema<EmailRecipient>;
export type EmailRecipientsList = EmailRecipient[];
export const EmailRecipientsList = S.Array(EmailRecipient);
export interface AdditionalEmailRecipients {
  ToList?: EmailRecipient[];
  CcList?: EmailRecipient[];
}
export const AdditionalEmailRecipients = S.suspend(() =>
  S.Struct({
    ToList: S.optional(EmailRecipientsList),
    CcList: S.optional(EmailRecipientsList),
  }),
).annotate({
  identifier: "AdditionalEmailRecipients",
}) as any as S.Schema<AdditionalEmailRecipients>;
export type MediaStreamType = "AUDIO" | "VIDEO" | (string & {});
export const MediaStreamType = S.String;
export type RecordingStatus = "AVAILABLE" | "DELETED" | (string & {});
export const RecordingStatus = S.String;
export interface RecordingInfo {
  StorageType?: StorageType;
  Location?: string;
  MediaStreamType?: MediaStreamType;
  ParticipantType?: ParticipantType;
  FragmentStartNumber?: string;
  FragmentStopNumber?: string;
  StartTimestamp?: Date;
  StopTimestamp?: Date;
  Status?: RecordingStatus;
  DeletionReason?: string;
  UnprocessedTranscriptLocation?: string;
}
export const RecordingInfo = S.suspend(() =>
  S.Struct({
    StorageType: S.optional(StorageType),
    Location: S.optional(S.String),
    MediaStreamType: S.optional(MediaStreamType),
    ParticipantType: S.optional(ParticipantType),
    FragmentStartNumber: S.optional(S.String),
    FragmentStopNumber: S.optional(S.String),
    StartTimestamp: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    StopTimestamp: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Status: S.optional(RecordingStatus),
    DeletionReason: S.optional(S.String),
    UnprocessedTranscriptLocation: S.optional(S.String),
  }),
).annotate({ identifier: "RecordingInfo" }) as any as S.Schema<RecordingInfo>;
export type Recordings = RecordingInfo[];
export const Recordings = S.Array(RecordingInfo);
export type Status = "COMPLETE" | "IN_PROGRESS" | "DELETED" | (string & {});
export const Status = S.String;
export interface ContactEvaluation {
  FormId?: string;
  EvaluationArn?: string;
  Status?: Status;
  StartTimestamp?: Date;
  EndTimestamp?: Date;
  DeleteTimestamp?: Date;
  ExportLocation?: string;
}
export const ContactEvaluation = S.suspend(() =>
  S.Struct({
    FormId: S.optional(S.String),
    EvaluationArn: S.optional(S.String),
    Status: S.optional(Status),
    StartTimestamp: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTimestamp: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    DeleteTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ExportLocation: S.optional(S.String),
  }),
).annotate({
  identifier: "ContactEvaluation",
}) as any as S.Schema<ContactEvaluation>;
export type ContactEvaluations = {
  [key: string]: ContactEvaluation | undefined;
};
export const ContactEvaluations = S.Record(
  S.String,
  ContactEvaluation.pipe(S.optional),
);
export interface TaskTemplateInfoV2 {
  Arn?: string;
  Name?: string;
}
export const TaskTemplateInfoV2 = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String), Name: S.optional(S.String) }),
).annotate({
  identifier: "TaskTemplateInfoV2",
}) as any as S.Schema<TaskTemplateInfoV2>;
export interface ContactDetails {
  Name?: string;
  Description?: string;
}
export const ContactDetails = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Description: S.optional(S.String) }),
).annotate({ identifier: "ContactDetails" }) as any as S.Schema<ContactDetails>;
export type NextContactType = "QUICK_CONNECT" | (string & {});
export const NextContactType = S.String;
export interface QuickConnectContactData {
  ContactId?: string;
  InitiationTimestamp?: Date;
  QuickConnectId?: string;
  QuickConnectName?: string;
  QuickConnectType?: QuickConnectType;
}
export const QuickConnectContactData = S.suspend(() =>
  S.Struct({
    ContactId: S.optional(S.String),
    InitiationTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    QuickConnectId: S.optional(S.String),
    QuickConnectName: S.optional(S.String),
    QuickConnectType: S.optional(QuickConnectType),
  }),
).annotate({
  identifier: "QuickConnectContactData",
}) as any as S.Schema<QuickConnectContactData>;
export type NextContactMetadata = {
  QuickConnectContactData: QuickConnectContactData;
};
export const NextContactMetadata = S.Union([
  S.Struct({ QuickConnectContactData: QuickConnectContactData }),
]);
export interface NextContactEntry {
  Type?: NextContactType;
  NextContactMetadata?: NextContactMetadata;
}
export const NextContactEntry = S.suspend(() =>
  S.Struct({
    Type: S.optional(NextContactType),
    NextContactMetadata: S.optional(NextContactMetadata),
  }),
).annotate({
  identifier: "NextContactEntry",
}) as any as S.Schema<NextContactEntry>;
export type NextContacts = NextContactEntry[];
export const NextContacts = S.Array(NextContactEntry);
export interface GlobalResiliencyMetadata {
  ActiveRegion?: string;
  OriginRegion?: string;
  TrafficDistributionGroupId?: string;
}
export const GlobalResiliencyMetadata = S.suspend(() =>
  S.Struct({
    ActiveRegion: S.optional(S.String),
    OriginRegion: S.optional(S.String),
    TrafficDistributionGroupId: S.optional(S.String),
  }),
).annotate({
  identifier: "GlobalResiliencyMetadata",
}) as any as S.Schema<GlobalResiliencyMetadata>;
export interface Contact {
  Arn?: string;
  Id?: string;
  InitialContactId?: string;
  PreviousContactId?: string;
  ContactAssociationId?: string;
  InitiationMethod?: ContactInitiationMethod;
  Name?: string | redacted.Redacted<string>;
  Description?: string | redacted.Redacted<string>;
  Channel?: Channel;
  QueueInfo?: QueueInfo;
  AgentInfo?: AgentInfo;
  InitiationTimestamp?: Date;
  DisconnectTimestamp?: Date;
  LastUpdateTimestamp?: Date;
  LastPausedTimestamp?: Date;
  LastResumedTimestamp?: Date;
  RingStartTimestamp?: Date;
  TotalPauseCount?: number;
  TotalPauseDurationInSeconds?: number;
  ScheduledTimestamp?: Date;
  RelatedContactId?: string;
  WisdomInfo?: WisdomInfo;
  CustomerId?: string;
  CustomerEndpoint?: EndpointInfo;
  SystemEndpoint?: EndpointInfo;
  QueueTimeAdjustmentSeconds?: number;
  QueuePriority?: number;
  Tags?: { [key: string]: string | undefined };
  ConnectedToSystemTimestamp?: Date;
  RoutingCriteria?: RoutingCriteria;
  Customer?: Customer;
  Campaign?: Campaign;
  AnsweringMachineDetectionStatus?: AnsweringMachineDetectionStatus;
  CustomerVoiceActivity?: CustomerVoiceActivity;
  QualityMetrics?: QualityMetrics;
  ChatMetrics?: ChatMetrics;
  DisconnectDetails?: DisconnectDetails;
  AdditionalEmailRecipients?: AdditionalEmailRecipients;
  SegmentAttributes?: { [key: string]: SegmentAttributeValue | undefined };
  Recordings?: RecordingInfo[];
  DisconnectReason?: string;
  ContactEvaluations?: { [key: string]: ContactEvaluation | undefined };
  TaskTemplateInfo?: TaskTemplateInfoV2;
  ContactDetails?: ContactDetails;
  OutboundStrategy?: OutboundStrategy;
  Attributes?: { [key: string]: string | undefined };
  NextContacts?: NextContactEntry[];
  GlobalResiliencyMetadata?: GlobalResiliencyMetadata;
}
export const Contact = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Id: S.optional(S.String),
    InitialContactId: S.optional(S.String),
    PreviousContactId: S.optional(S.String),
    ContactAssociationId: S.optional(S.String),
    InitiationMethod: S.optional(ContactInitiationMethod),
    Name: S.optional(SensitiveString),
    Description: S.optional(SensitiveString),
    Channel: S.optional(Channel),
    QueueInfo: S.optional(QueueInfo),
    AgentInfo: S.optional(AgentInfo),
    InitiationTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    DisconnectTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastUpdateTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastPausedTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastResumedTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    RingStartTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    TotalPauseCount: S.optional(S.Number),
    TotalPauseDurationInSeconds: S.optional(S.Number),
    ScheduledTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    RelatedContactId: S.optional(S.String),
    WisdomInfo: S.optional(WisdomInfo),
    CustomerId: S.optional(S.String),
    CustomerEndpoint: S.optional(EndpointInfo),
    SystemEndpoint: S.optional(EndpointInfo),
    QueueTimeAdjustmentSeconds: S.optional(S.Number),
    QueuePriority: S.optional(S.Number),
    Tags: S.optional(ContactTagMap),
    ConnectedToSystemTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    RoutingCriteria: S.optional(RoutingCriteria),
    Customer: S.optional(Customer),
    Campaign: S.optional(Campaign),
    AnsweringMachineDetectionStatus: S.optional(
      AnsweringMachineDetectionStatus,
    ),
    CustomerVoiceActivity: S.optional(CustomerVoiceActivity),
    QualityMetrics: S.optional(QualityMetrics),
    ChatMetrics: S.optional(ChatMetrics),
    DisconnectDetails: S.optional(DisconnectDetails),
    AdditionalEmailRecipients: S.optional(AdditionalEmailRecipients),
    SegmentAttributes: S.optional(SegmentAttributes),
    Recordings: S.optional(Recordings),
    DisconnectReason: S.optional(S.String),
    ContactEvaluations: S.optional(ContactEvaluations),
    TaskTemplateInfo: S.optional(TaskTemplateInfoV2),
    ContactDetails: S.optional(ContactDetails),
    OutboundStrategy: S.optional(OutboundStrategy),
    Attributes: S.optional(Attributes),
    NextContacts: S.optional(NextContacts),
    GlobalResiliencyMetadata: S.optional(GlobalResiliencyMetadata),
  }),
).annotate({ identifier: "Contact" }) as any as S.Schema<Contact>;
export interface DescribeContactResponse {
  Contact?: Contact;
}
export const DescribeContactResponse = S.suspend(() =>
  S.Struct({ Contact: S.optional(Contact) }),
).annotate({
  identifier: "DescribeContactResponse",
}) as any as S.Schema<DescribeContactResponse>;
export interface DescribeContactEvaluationRequest {
  InstanceId: string;
  EvaluationId: string;
}
export const DescribeContactEvaluationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationId: S.String.pipe(T.HttpLabel("EvaluationId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact-evaluations/{InstanceId}/{EvaluationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeContactEvaluationRequest",
}) as any as S.Schema<DescribeContactEvaluationRequest>;
export interface EvaluationScore {
  Percentage?: number;
  NotApplicable?: boolean;
  AutomaticFail?: boolean;
  AppliedWeight?: number;
}
export const EvaluationScore = S.suspend(() =>
  S.Struct({
    Percentage: S.optional(S.Number),
    NotApplicable: S.optional(S.Boolean),
    AutomaticFail: S.optional(S.Boolean),
    AppliedWeight: S.optional(S.Number),
  }),
).annotate({
  identifier: "EvaluationScore",
}) as any as S.Schema<EvaluationScore>;
export type AutoEvaluationStatus =
  | "IN_PROGRESS"
  | "FAILED"
  | "SUCCEEDED"
  | (string & {});
export const AutoEvaluationStatus = S.String;
export interface AutoEvaluationDetails {
  AutoEvaluationEnabled: boolean;
  AutoEvaluationStatus?: AutoEvaluationStatus;
}
export const AutoEvaluationDetails = S.suspend(() =>
  S.Struct({
    AutoEvaluationEnabled: S.Boolean,
    AutoEvaluationStatus: S.optional(AutoEvaluationStatus),
  }),
).annotate({
  identifier: "AutoEvaluationDetails",
}) as any as S.Schema<AutoEvaluationDetails>;
export interface EvaluationAcknowledgement {
  AcknowledgedTime: Date;
  AcknowledgedBy: string;
  AcknowledgerComment?: string;
}
export const EvaluationAcknowledgement = S.suspend(() =>
  S.Struct({
    AcknowledgedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    AcknowledgedBy: S.String,
    AcknowledgerComment: S.optional(S.String),
  }),
).annotate({
  identifier: "EvaluationAcknowledgement",
}) as any as S.Schema<EvaluationAcknowledgement>;
export interface EvaluationReviewRequestComment {
  Comment?: string;
  CreatedTime?: Date;
  CreatedBy?: string;
}
export const EvaluationReviewRequestComment = S.suspend(() =>
  S.Struct({
    Comment: S.optional(S.String),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    CreatedBy: S.optional(S.String),
  }),
).annotate({
  identifier: "EvaluationReviewRequestComment",
}) as any as S.Schema<EvaluationReviewRequestComment>;
export type EvaluationReviewRequestCommentList =
  EvaluationReviewRequestComment[];
export const EvaluationReviewRequestCommentList = S.Array(
  EvaluationReviewRequestComment,
);
export interface EvaluationReviewMetadata {
  ReviewId?: string;
  CreatedTime: Date;
  CreatedBy: string;
  ReviewRequestComments: EvaluationReviewRequestComment[];
}
export const EvaluationReviewMetadata = S.suspend(() =>
  S.Struct({
    ReviewId: S.optional(S.String),
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    CreatedBy: S.String,
    ReviewRequestComments: EvaluationReviewRequestCommentList,
  }),
).annotate({
  identifier: "EvaluationReviewMetadata",
}) as any as S.Schema<EvaluationReviewMetadata>;
export type ContactParticipantRole =
  | "AGENT"
  | "SYSTEM"
  | "CUSTOM_BOT"
  | (string & {});
export const ContactParticipantRole = S.String;
export interface EvaluationContactParticipant {
  ContactParticipantRole?: ContactParticipantRole;
  ContactParticipantId?: string;
}
export const EvaluationContactParticipant = S.suspend(() =>
  S.Struct({
    ContactParticipantRole: S.optional(ContactParticipantRole),
    ContactParticipantId: S.optional(S.String),
  }),
).annotate({
  identifier: "EvaluationContactParticipant",
}) as any as S.Schema<EvaluationContactParticipant>;
export interface EvaluationMetadata {
  ContactId: string;
  EvaluatorArn: string;
  ContactAgentId?: string;
  CalibrationSessionId?: string;
  Score?: EvaluationScore;
  AutoEvaluation?: AutoEvaluationDetails;
  Acknowledgement?: EvaluationAcknowledgement;
  Review?: EvaluationReviewMetadata;
  ContactParticipant?: EvaluationContactParticipant;
  SamplingJobId?: string;
}
export const EvaluationMetadata = S.suspend(() =>
  S.Struct({
    ContactId: S.String,
    EvaluatorArn: S.String,
    ContactAgentId: S.optional(S.String),
    CalibrationSessionId: S.optional(S.String),
    Score: S.optional(EvaluationScore),
    AutoEvaluation: S.optional(AutoEvaluationDetails),
    Acknowledgement: S.optional(EvaluationAcknowledgement),
    Review: S.optional(EvaluationReviewMetadata),
    ContactParticipant: S.optional(EvaluationContactParticipant),
    SamplingJobId: S.optional(S.String),
  }),
).annotate({
  identifier: "EvaluationMetadata",
}) as any as S.Schema<EvaluationMetadata>;
export type EvaluationAnswerDataStringValueList = string[];
export const EvaluationAnswerDataStringValueList = S.Array(S.String);
export type EvaluationAnswerData =
  | {
      StringValue: string;
      NumericValue?: never;
      StringValues?: never;
      DateTimeValue?: never;
      NotApplicable?: never;
    }
  | {
      StringValue?: never;
      NumericValue: number;
      StringValues?: never;
      DateTimeValue?: never;
      NotApplicable?: never;
    }
  | {
      StringValue?: never;
      NumericValue?: never;
      StringValues: string[];
      DateTimeValue?: never;
      NotApplicable?: never;
    }
  | {
      StringValue?: never;
      NumericValue?: never;
      StringValues?: never;
      DateTimeValue: string;
      NotApplicable?: never;
    }
  | {
      StringValue?: never;
      NumericValue?: never;
      StringValues?: never;
      DateTimeValue?: never;
      NotApplicable: boolean;
    };
export const EvaluationAnswerData = S.Union([
  S.Struct({ StringValue: S.String }),
  S.Struct({ NumericValue: S.Number }),
  S.Struct({ StringValues: EvaluationAnswerDataStringValueList }),
  S.Struct({ DateTimeValue: S.String }),
  S.Struct({ NotApplicable: S.Boolean }),
]);
export type EvaluationSuggestedAnswerStatus =
  | "IN_PROGRESS"
  | "FAILED"
  | "SUCCEEDED"
  | (string & {});
export const EvaluationSuggestedAnswerStatus = S.String;
export type EvaluationTranscriptType = "RAW" | "REDACTED" | (string & {});
export const EvaluationTranscriptType = S.String;
export interface EvaluationQuestionInputDetails {
  TranscriptType?: EvaluationTranscriptType;
}
export const EvaluationQuestionInputDetails = S.suspend(() =>
  S.Struct({ TranscriptType: S.optional(EvaluationTranscriptType) }),
).annotate({
  identifier: "EvaluationQuestionInputDetails",
}) as any as S.Schema<EvaluationQuestionInputDetails>;
export type EvaluationQuestionAnswerAnalysisType =
  | "CONTACT_LENS_DATA"
  | "GEN_AI"
  | (string & {});
export const EvaluationQuestionAnswerAnalysisType = S.String;
export interface EvaluationSuggestedAnswerTranscriptMillisecondOffsets {
  BeginOffsetMillis: number;
}
export const EvaluationSuggestedAnswerTranscriptMillisecondOffsets = S.suspend(
  () => S.Struct({ BeginOffsetMillis: S.Number }),
).annotate({
  identifier: "EvaluationSuggestedAnswerTranscriptMillisecondOffsets",
}) as any as S.Schema<EvaluationSuggestedAnswerTranscriptMillisecondOffsets>;
export interface EvaluationTranscriptPointOfInterest {
  MillisecondOffsets?: EvaluationSuggestedAnswerTranscriptMillisecondOffsets;
  TranscriptSegment?: string;
}
export const EvaluationTranscriptPointOfInterest = S.suspend(() =>
  S.Struct({
    MillisecondOffsets: S.optional(
      EvaluationSuggestedAnswerTranscriptMillisecondOffsets,
    ),
    TranscriptSegment: S.optional(S.String),
  }),
).annotate({
  identifier: "EvaluationTranscriptPointOfInterest",
}) as any as S.Schema<EvaluationTranscriptPointOfInterest>;
export type EvaluationTranscriptPointsOfInterest =
  EvaluationTranscriptPointOfInterest[];
export const EvaluationTranscriptPointsOfInterest = S.Array(
  EvaluationTranscriptPointOfInterest,
);
export interface EvaluationGenAIAnswerAnalysisDetails {
  Justification?: string;
  PointsOfInterest?: EvaluationTranscriptPointOfInterest[];
}
export const EvaluationGenAIAnswerAnalysisDetails = S.suspend(() =>
  S.Struct({
    Justification: S.optional(S.String),
    PointsOfInterest: S.optional(EvaluationTranscriptPointsOfInterest),
  }),
).annotate({
  identifier: "EvaluationGenAIAnswerAnalysisDetails",
}) as any as S.Schema<EvaluationGenAIAnswerAnalysisDetails>;
export type QuestionRuleCategoryAutomationCondition =
  | "PRESENT"
  | "NOT_PRESENT"
  | (string & {});
export const QuestionRuleCategoryAutomationCondition = S.String;
export interface EvaluationAutomationRuleCategory {
  Category: string;
  Condition: QuestionRuleCategoryAutomationCondition;
  PointsOfInterest?: EvaluationTranscriptPointOfInterest[];
}
export const EvaluationAutomationRuleCategory = S.suspend(() =>
  S.Struct({
    Category: S.String,
    Condition: QuestionRuleCategoryAutomationCondition,
    PointsOfInterest: S.optional(EvaluationTranscriptPointsOfInterest),
  }),
).annotate({
  identifier: "EvaluationAutomationRuleCategory",
}) as any as S.Schema<EvaluationAutomationRuleCategory>;
export type EvaluationAutomationRuleCategoryList =
  EvaluationAutomationRuleCategory[];
export const EvaluationAutomationRuleCategoryList = S.Array(
  EvaluationAutomationRuleCategory,
);
export interface EvaluationContactLensAnswerAnalysisDetails {
  MatchedRuleCategories?: EvaluationAutomationRuleCategory[];
}
export const EvaluationContactLensAnswerAnalysisDetails = S.suspend(() =>
  S.Struct({
    MatchedRuleCategories: S.optional(EvaluationAutomationRuleCategoryList),
  }),
).annotate({
  identifier: "EvaluationContactLensAnswerAnalysisDetails",
}) as any as S.Schema<EvaluationContactLensAnswerAnalysisDetails>;
export type EvaluationQuestionAnswerAnalysisDetails =
  | { GenAI: EvaluationGenAIAnswerAnalysisDetails; ContactLens?: never }
  | { GenAI?: never; ContactLens: EvaluationContactLensAnswerAnalysisDetails };
export const EvaluationQuestionAnswerAnalysisDetails = S.Union([
  S.Struct({ GenAI: EvaluationGenAIAnswerAnalysisDetails }),
  S.Struct({ ContactLens: EvaluationContactLensAnswerAnalysisDetails }),
]);
export interface EvaluationSuggestedAnswer {
  Value?: EvaluationAnswerData;
  Status: EvaluationSuggestedAnswerStatus;
  Input?: EvaluationQuestionInputDetails;
  AnalysisType: EvaluationQuestionAnswerAnalysisType;
  AnalysisDetails?: EvaluationQuestionAnswerAnalysisDetails;
}
export const EvaluationSuggestedAnswer = S.suspend(() =>
  S.Struct({
    Value: S.optional(EvaluationAnswerData),
    Status: EvaluationSuggestedAnswerStatus,
    Input: S.optional(EvaluationQuestionInputDetails),
    AnalysisType: EvaluationQuestionAnswerAnalysisType,
    AnalysisDetails: S.optional(EvaluationQuestionAnswerAnalysisDetails),
  }),
).annotate({
  identifier: "EvaluationSuggestedAnswer",
}) as any as S.Schema<EvaluationSuggestedAnswer>;
export type EvaluationSuggestedAnswersList = EvaluationSuggestedAnswer[];
export const EvaluationSuggestedAnswersList = S.Array(
  EvaluationSuggestedAnswer,
);
export interface EvaluationAnswerOutput {
  Value?: EvaluationAnswerData;
  SystemSuggestedValue?: EvaluationAnswerData;
  SuggestedAnswers?: EvaluationSuggestedAnswer[];
}
export const EvaluationAnswerOutput = S.suspend(() =>
  S.Struct({
    Value: S.optional(EvaluationAnswerData),
    SystemSuggestedValue: S.optional(EvaluationAnswerData),
    SuggestedAnswers: S.optional(EvaluationSuggestedAnswersList),
  }),
).annotate({
  identifier: "EvaluationAnswerOutput",
}) as any as S.Schema<EvaluationAnswerOutput>;
export type EvaluationAnswersOutputMap = {
  [key: string]: EvaluationAnswerOutput | undefined;
};
export const EvaluationAnswersOutputMap = S.Record(
  S.String,
  EvaluationAnswerOutput.pipe(S.optional),
);
export interface EvaluationNote {
  Value?: string;
}
export const EvaluationNote = S.suspend(() =>
  S.Struct({ Value: S.optional(S.String) }),
).annotate({ identifier: "EvaluationNote" }) as any as S.Schema<EvaluationNote>;
export type EvaluationNotesMap = { [key: string]: EvaluationNote | undefined };
export const EvaluationNotesMap = S.Record(
  S.String,
  EvaluationNote.pipe(S.optional),
);
export type EvaluationStatus =
  | "DRAFT"
  | "SUBMITTED"
  | "REVIEW_REQUESTED"
  | "UNDER_REVIEW"
  | (string & {});
export const EvaluationStatus = S.String;
export type EvaluationScoresMap = {
  [key: string]: EvaluationScore | undefined;
};
export const EvaluationScoresMap = S.Record(
  S.String,
  EvaluationScore.pipe(S.optional),
);
export type EvaluationType = "STANDARD" | "CALIBRATION" | (string & {});
export const EvaluationType = S.String;
export interface Evaluation {
  EvaluationId: string;
  EvaluationArn: string;
  Metadata: EvaluationMetadata;
  Answers: { [key: string]: EvaluationAnswerOutput | undefined };
  Notes: { [key: string]: EvaluationNote | undefined };
  Status: EvaluationStatus;
  Scores?: { [key: string]: EvaluationScore | undefined };
  CreatedTime: Date;
  LastModifiedTime: Date;
  EvaluationType?: EvaluationType;
  Tags?: { [key: string]: string | undefined };
}
export const Evaluation = S.suspend(() =>
  S.Struct({
    EvaluationId: S.String,
    EvaluationArn: S.String,
    Metadata: EvaluationMetadata,
    Answers: EvaluationAnswersOutputMap,
    Notes: EvaluationNotesMap,
    Status: EvaluationStatus,
    Scores: S.optional(EvaluationScoresMap),
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    EvaluationType: S.optional(EvaluationType),
    Tags: S.optional(TagMap),
  }),
).annotate({ identifier: "Evaluation" }) as any as S.Schema<Evaluation>;
export interface EvaluationFormContent {
  EvaluationFormVersion: number;
  EvaluationFormId: string;
  EvaluationFormArn: string;
  Title: string;
  Description?: string;
  Items: EvaluationFormItem[];
  ScoringStrategy?: EvaluationFormScoringStrategy;
  AutoEvaluationConfiguration?: EvaluationFormAutoEvaluationConfiguration;
  TargetConfiguration?: EvaluationFormTargetConfiguration;
  LanguageConfiguration?: EvaluationFormLanguageConfiguration;
  ReviewConfiguration?: EvaluationReviewConfiguration;
}
export const EvaluationFormContent = S.suspend(() =>
  S.Struct({
    EvaluationFormVersion: S.Number,
    EvaluationFormId: S.String,
    EvaluationFormArn: S.String,
    Title: S.String,
    Description: S.optional(S.String),
    Items: EvaluationFormItemsList,
    ScoringStrategy: S.optional(EvaluationFormScoringStrategy),
    AutoEvaluationConfiguration: S.optional(
      EvaluationFormAutoEvaluationConfiguration,
    ),
    TargetConfiguration: S.optional(EvaluationFormTargetConfiguration),
    LanguageConfiguration: S.optional(EvaluationFormLanguageConfiguration),
    ReviewConfiguration: S.optional(EvaluationReviewConfiguration),
  }),
).annotate({
  identifier: "EvaluationFormContent",
}) as any as S.Schema<EvaluationFormContent>;
export interface DescribeContactEvaluationResponse {
  Evaluation: Evaluation;
  EvaluationForm: EvaluationFormContent;
}
export const DescribeContactEvaluationResponse = S.suspend(() =>
  S.Struct({ Evaluation: Evaluation, EvaluationForm: EvaluationFormContent }),
).annotate({
  identifier: "DescribeContactEvaluationResponse",
}) as any as S.Schema<DescribeContactEvaluationResponse>;
export interface DescribeContactFlowRequest {
  InstanceId: string;
  ContactFlowId: string;
}
export const DescribeContactFlowRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowId: S.String.pipe(T.HttpLabel("ContactFlowId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact-flows/{InstanceId}/{ContactFlowId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeContactFlowRequest",
}) as any as S.Schema<DescribeContactFlowRequest>;
export type ContactFlowState = "ACTIVE" | "ARCHIVED" | (string & {});
export const ContactFlowState = S.String;
export interface ContactFlow {
  Arn?: string;
  Id?: string;
  Name?: string;
  Type?: ContactFlowType;
  State?: ContactFlowState;
  Status?: ContactFlowStatus;
  Description?: string;
  Content?: string;
  Tags?: { [key: string]: string | undefined };
  FlowContentSha256?: string;
  Version?: number;
  VersionDescription?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const ContactFlow = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Id: S.optional(S.String),
    Name: S.optional(S.String),
    Type: S.optional(ContactFlowType),
    State: S.optional(ContactFlowState),
    Status: S.optional(ContactFlowStatus),
    Description: S.optional(S.String),
    Content: S.optional(S.String),
    Tags: S.optional(TagMap),
    FlowContentSha256: S.optional(S.String),
    Version: S.optional(S.Number),
    VersionDescription: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({ identifier: "ContactFlow" }) as any as S.Schema<ContactFlow>;
export interface DescribeContactFlowResponse {
  ContactFlow?: ContactFlow;
}
export const DescribeContactFlowResponse = S.suspend(() =>
  S.Struct({ ContactFlow: S.optional(ContactFlow) }),
).annotate({
  identifier: "DescribeContactFlowResponse",
}) as any as S.Schema<DescribeContactFlowResponse>;
export interface DescribeContactFlowModuleRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
}
export const DescribeContactFlowModuleRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeContactFlowModuleRequest",
}) as any as S.Schema<DescribeContactFlowModuleRequest>;
export type ContactFlowModuleState = "ACTIVE" | "ARCHIVED" | (string & {});
export const ContactFlowModuleState = S.String;
export type ContactFlowModuleStatus = "PUBLISHED" | "SAVED" | (string & {});
export const ContactFlowModuleStatus = S.String;
export interface ContactFlowModule {
  Arn?: string;
  Id?: string;
  Name?: string;
  Content?: string;
  Description?: string;
  State?: ContactFlowModuleState;
  Status?: ContactFlowModuleStatus;
  Tags?: { [key: string]: string | undefined };
  FlowModuleContentSha256?: string;
  Version?: number;
  VersionDescription?: string;
  Settings?: string;
  ExternalInvocationConfiguration?: ExternalInvocationConfiguration;
}
export const ContactFlowModule = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Id: S.optional(S.String),
    Name: S.optional(S.String),
    Content: S.optional(S.String),
    Description: S.optional(S.String),
    State: S.optional(ContactFlowModuleState),
    Status: S.optional(ContactFlowModuleStatus),
    Tags: S.optional(TagMap),
    FlowModuleContentSha256: S.optional(S.String),
    Version: S.optional(S.Number),
    VersionDescription: S.optional(S.String),
    Settings: S.optional(S.String),
    ExternalInvocationConfiguration: S.optional(
      ExternalInvocationConfiguration,
    ),
  }),
).annotate({
  identifier: "ContactFlowModule",
}) as any as S.Schema<ContactFlowModule>;
export interface DescribeContactFlowModuleResponse {
  ContactFlowModule?: ContactFlowModule;
}
export const DescribeContactFlowModuleResponse = S.suspend(() =>
  S.Struct({ ContactFlowModule: S.optional(ContactFlowModule) }),
).annotate({
  identifier: "DescribeContactFlowModuleResponse",
}) as any as S.Schema<DescribeContactFlowModuleResponse>;
export interface DescribeContactFlowModuleAliasRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
  AliasId: string;
}
export const DescribeContactFlowModuleAliasRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    AliasId: S.String.pipe(T.HttpLabel("AliasId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/alias/{AliasId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeContactFlowModuleAliasRequest",
}) as any as S.Schema<DescribeContactFlowModuleAliasRequest>;
export interface ContactFlowModuleAliasInfo {
  ContactFlowModuleId?: string;
  ContactFlowModuleArn?: string;
  AliasId?: string;
  Version?: number;
  Name?: string;
  Description?: string;
  LastModifiedRegion?: string;
  LastModifiedTime?: Date;
}
export const ContactFlowModuleAliasInfo = S.suspend(() =>
  S.Struct({
    ContactFlowModuleId: S.optional(S.String),
    ContactFlowModuleArn: S.optional(S.String),
    AliasId: S.optional(S.String),
    Version: S.optional(S.Number),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    LastModifiedRegion: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "ContactFlowModuleAliasInfo",
}) as any as S.Schema<ContactFlowModuleAliasInfo>;
export interface DescribeContactFlowModuleAliasResponse {
  ContactFlowModuleAlias?: ContactFlowModuleAliasInfo;
}
export const DescribeContactFlowModuleAliasResponse = S.suspend(() =>
  S.Struct({ ContactFlowModuleAlias: S.optional(ContactFlowModuleAliasInfo) }),
).annotate({
  identifier: "DescribeContactFlowModuleAliasResponse",
}) as any as S.Schema<DescribeContactFlowModuleAliasResponse>;
export interface DescribeDataTableRequest {
  InstanceId: string;
  DataTableId: string;
}
export const DescribeDataTableRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/data-tables/{InstanceId}/{DataTableId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeDataTableRequest",
}) as any as S.Schema<DescribeDataTableRequest>;
export interface DataTable {
  Name: string;
  Id: string;
  Arn: string;
  TimeZone: string;
  Description?: string;
  ValueLockLevel?: DataTableLockLevel;
  LockVersion?: DataTableLockVersion;
  Version?: string;
  VersionDescription?: string;
  Status?: DataTableStatus;
  CreatedTime?: Date;
  LastModifiedTime: Date;
  LastModifiedRegion?: string;
  Tags?: { [key: string]: string | undefined };
}
export const DataTable = S.suspend(() =>
  S.Struct({
    Name: S.String,
    Id: S.String,
    Arn: S.String,
    TimeZone: S.String,
    Description: S.optional(S.String),
    ValueLockLevel: S.optional(DataTableLockLevel),
    LockVersion: S.optional(DataTableLockVersion),
    Version: S.optional(S.String),
    VersionDescription: S.optional(S.String),
    Status: S.optional(DataTableStatus),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastModifiedRegion: S.optional(S.String),
    Tags: S.optional(TagMap),
  }),
).annotate({ identifier: "DataTable" }) as any as S.Schema<DataTable>;
export interface DescribeDataTableResponse {
  DataTable: DataTable;
}
export const DescribeDataTableResponse = S.suspend(() =>
  S.Struct({ DataTable: DataTable }),
).annotate({
  identifier: "DescribeDataTableResponse",
}) as any as S.Schema<DescribeDataTableResponse>;
export interface DescribeDataTableAttributeRequest {
  InstanceId: string;
  DataTableId: string;
  AttributeName: string;
}
export const DescribeDataTableAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    AttributeName: S.String.pipe(T.HttpLabel("AttributeName")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/data-tables/{InstanceId}/{DataTableId}/attributes/{AttributeName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeDataTableAttributeRequest",
}) as any as S.Schema<DescribeDataTableAttributeRequest>;
export interface DataTableAttribute {
  AttributeId?: string;
  Name: string;
  ValueType: DataTableAttributeValueType;
  Description?: string;
  DataTableId?: string;
  DataTableArn?: string;
  Primary?: boolean;
  Version?: string;
  LockVersion?: DataTableLockVersion;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
  Validation?: Validation;
}
export const DataTableAttribute = S.suspend(() =>
  S.Struct({
    AttributeId: S.optional(S.String),
    Name: S.String,
    ValueType: DataTableAttributeValueType,
    Description: S.optional(S.String),
    DataTableId: S.optional(S.String),
    DataTableArn: S.optional(S.String),
    Primary: S.optional(S.Boolean),
    Version: S.optional(S.String),
    LockVersion: S.optional(DataTableLockVersion),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
    Validation: S.optional(Validation),
  }),
).annotate({
  identifier: "DataTableAttribute",
}) as any as S.Schema<DataTableAttribute>;
export interface DescribeDataTableAttributeResponse {
  Attribute: DataTableAttribute;
}
export const DescribeDataTableAttributeResponse = S.suspend(() =>
  S.Struct({ Attribute: DataTableAttribute }),
).annotate({
  identifier: "DescribeDataTableAttributeResponse",
}) as any as S.Schema<DescribeDataTableAttributeResponse>;
export interface DescribeEmailAddressRequest {
  InstanceId: string;
  EmailAddressId: string;
}
export const DescribeEmailAddressRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EmailAddressId: S.String.pipe(T.HttpLabel("EmailAddressId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/email-addresses/{InstanceId}/{EmailAddressId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeEmailAddressRequest",
}) as any as S.Schema<DescribeEmailAddressRequest>;
export type AliasConfigurationList = AliasConfiguration[];
export const AliasConfigurationList = S.Array(AliasConfiguration);
export interface DescribeEmailAddressResponse {
  EmailAddressId?: string;
  EmailAddressArn?: string;
  EmailAddress?: string | redacted.Redacted<string>;
  DisplayName?: string | redacted.Redacted<string>;
  Description?: string | redacted.Redacted<string>;
  CreateTimestamp?: string;
  ModifiedTimestamp?: string;
  AliasConfigurations?: AliasConfiguration[];
  Tags?: { [key: string]: string | undefined };
}
export const DescribeEmailAddressResponse = S.suspend(() =>
  S.Struct({
    EmailAddressId: S.optional(S.String),
    EmailAddressArn: S.optional(S.String),
    EmailAddress: S.optional(SensitiveString),
    DisplayName: S.optional(SensitiveString),
    Description: S.optional(SensitiveString),
    CreateTimestamp: S.optional(S.String),
    ModifiedTimestamp: S.optional(S.String),
    AliasConfigurations: S.optional(AliasConfigurationList),
    Tags: S.optional(TagMap),
  }),
).annotate({
  identifier: "DescribeEmailAddressResponse",
}) as any as S.Schema<DescribeEmailAddressResponse>;
export interface DescribeEvaluationFormRequest {
  InstanceId: string;
  EvaluationFormId: string;
  EvaluationFormVersion?: number;
}
export const DescribeEvaluationFormRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationFormId: S.String.pipe(T.HttpLabel("EvaluationFormId")),
    EvaluationFormVersion: S.optional(S.Number).pipe(T.HttpQuery("version")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/evaluation-forms/{InstanceId}/{EvaluationFormId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeEvaluationFormRequest",
}) as any as S.Schema<DescribeEvaluationFormRequest>;
export type EvaluationFormVersionStatus = "DRAFT" | "ACTIVE" | (string & {});
export const EvaluationFormVersionStatus = S.String;
export interface EvaluationForm {
  EvaluationFormId: string;
  EvaluationFormVersion: number;
  Locked: boolean;
  EvaluationFormArn: string;
  Title: string;
  Description?: string;
  Status: EvaluationFormVersionStatus;
  Items: EvaluationFormItem[];
  ScoringStrategy?: EvaluationFormScoringStrategy;
  CreatedTime: Date;
  CreatedBy: string;
  LastModifiedTime: Date;
  LastModifiedBy: string;
  AutoEvaluationConfiguration?: EvaluationFormAutoEvaluationConfiguration;
  ReviewConfiguration?: EvaluationReviewConfiguration;
  Tags?: { [key: string]: string | undefined };
  TargetConfiguration?: EvaluationFormTargetConfiguration;
  LanguageConfiguration?: EvaluationFormLanguageConfiguration;
}
export const EvaluationForm = S.suspend(() =>
  S.Struct({
    EvaluationFormId: S.String,
    EvaluationFormVersion: S.Number,
    Locked: S.Boolean,
    EvaluationFormArn: S.String,
    Title: S.String,
    Description: S.optional(S.String),
    Status: EvaluationFormVersionStatus,
    Items: EvaluationFormItemsList,
    ScoringStrategy: S.optional(EvaluationFormScoringStrategy),
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    CreatedBy: S.String,
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastModifiedBy: S.String,
    AutoEvaluationConfiguration: S.optional(
      EvaluationFormAutoEvaluationConfiguration,
    ),
    ReviewConfiguration: S.optional(EvaluationReviewConfiguration),
    Tags: S.optional(TagMap),
    TargetConfiguration: S.optional(EvaluationFormTargetConfiguration),
    LanguageConfiguration: S.optional(EvaluationFormLanguageConfiguration),
  }),
).annotate({ identifier: "EvaluationForm" }) as any as S.Schema<EvaluationForm>;
export interface DescribeEvaluationFormResponse {
  EvaluationForm: EvaluationForm;
}
export const DescribeEvaluationFormResponse = S.suspend(() =>
  S.Struct({ EvaluationForm: EvaluationForm }),
).annotate({
  identifier: "DescribeEvaluationFormResponse",
}) as any as S.Schema<DescribeEvaluationFormResponse>;
export interface DescribeHoursOfOperationRequest {
  InstanceId: string;
  HoursOfOperationId: string;
}
export const DescribeHoursOfOperationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeHoursOfOperationRequest",
}) as any as S.Schema<DescribeHoursOfOperationRequest>;
export interface HoursOfOperationsIdentifier {
  Name: string;
  Id: string;
  Arn?: string;
}
export const HoursOfOperationsIdentifier = S.suspend(() =>
  S.Struct({ Name: S.String, Id: S.String, Arn: S.optional(S.String) }),
).annotate({
  identifier: "HoursOfOperationsIdentifier",
}) as any as S.Schema<HoursOfOperationsIdentifier>;
export type ParentHoursOfOperationsList = HoursOfOperationsIdentifier[];
export const ParentHoursOfOperationsList = S.Array(HoursOfOperationsIdentifier);
export interface HoursOfOperation {
  HoursOfOperationId?: string;
  HoursOfOperationArn?: string;
  Name?: string;
  Description?: string;
  TimeZone?: string;
  Config?: HoursOfOperationConfig[];
  ParentHoursOfOperations?: HoursOfOperationsIdentifier[];
  Tags?: { [key: string]: string | undefined };
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const HoursOfOperation = S.suspend(() =>
  S.Struct({
    HoursOfOperationId: S.optional(S.String),
    HoursOfOperationArn: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    TimeZone: S.optional(S.String),
    Config: S.optional(HoursOfOperationConfigList),
    ParentHoursOfOperations: S.optional(ParentHoursOfOperationsList),
    Tags: S.optional(TagMap),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "HoursOfOperation",
}) as any as S.Schema<HoursOfOperation>;
export interface DescribeHoursOfOperationResponse {
  HoursOfOperation?: HoursOfOperation;
}
export const DescribeHoursOfOperationResponse = S.suspend(() =>
  S.Struct({ HoursOfOperation: S.optional(HoursOfOperation) }),
).annotate({
  identifier: "DescribeHoursOfOperationResponse",
}) as any as S.Schema<DescribeHoursOfOperationResponse>;
export interface DescribeHoursOfOperationOverrideRequest {
  InstanceId: string;
  HoursOfOperationId: string;
  HoursOfOperationOverrideId: string;
}
export const DescribeHoursOfOperationOverrideRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
    HoursOfOperationOverrideId: S.String.pipe(
      T.HttpLabel("HoursOfOperationOverrideId"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}/overrides/{HoursOfOperationOverrideId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeHoursOfOperationOverrideRequest",
}) as any as S.Schema<DescribeHoursOfOperationOverrideRequest>;
export interface HoursOfOperationOverride {
  HoursOfOperationOverrideId?: string;
  HoursOfOperationId?: string;
  HoursOfOperationArn?: string;
  Name?: string;
  Description?: string;
  Config?: HoursOfOperationOverrideConfig[];
  EffectiveFrom?: string;
  EffectiveTill?: string;
  RecurrenceConfig?: RecurrenceConfig;
  OverrideType?: OverrideType;
}
export const HoursOfOperationOverride = S.suspend(() =>
  S.Struct({
    HoursOfOperationOverrideId: S.optional(S.String),
    HoursOfOperationId: S.optional(S.String),
    HoursOfOperationArn: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    Config: S.optional(HoursOfOperationOverrideConfigList),
    EffectiveFrom: S.optional(S.String),
    EffectiveTill: S.optional(S.String),
    RecurrenceConfig: S.optional(RecurrenceConfig),
    OverrideType: S.optional(OverrideType),
  }),
).annotate({
  identifier: "HoursOfOperationOverride",
}) as any as S.Schema<HoursOfOperationOverride>;
export interface DescribeHoursOfOperationOverrideResponse {
  HoursOfOperationOverride?: HoursOfOperationOverride;
}
export const DescribeHoursOfOperationOverrideResponse = S.suspend(() =>
  S.Struct({ HoursOfOperationOverride: S.optional(HoursOfOperationOverride) }),
).annotate({
  identifier: "DescribeHoursOfOperationOverrideResponse",
}) as any as S.Schema<DescribeHoursOfOperationOverrideResponse>;
export interface DescribeInstanceRequest {
  InstanceId: string;
}
export const DescribeInstanceRequest = S.suspend(() =>
  S.Struct({ InstanceId: S.String.pipe(T.HttpLabel("InstanceId")) }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInstanceRequest",
}) as any as S.Schema<DescribeInstanceRequest>;
export type InstanceStatus =
  | "CREATION_IN_PROGRESS"
  | "ACTIVE"
  | "CREATION_FAILED"
  | (string & {});
export const InstanceStatus = S.String;
export interface InstanceStatusReason {
  Message?: string;
}
export const InstanceStatusReason = S.suspend(() =>
  S.Struct({ Message: S.optional(S.String) }),
).annotate({
  identifier: "InstanceStatusReason",
}) as any as S.Schema<InstanceStatusReason>;
export interface Instance {
  Id?: string;
  Arn?: string;
  IdentityManagementType?: DirectoryType;
  InstanceAlias?: string | redacted.Redacted<string>;
  CreatedTime?: Date;
  ServiceRole?: string;
  InstanceStatus?: InstanceStatus;
  StatusReason?: InstanceStatusReason;
  InboundCallsEnabled?: boolean;
  OutboundCallsEnabled?: boolean;
  InstanceAccessUrl?: string;
  Tags?: { [key: string]: string | undefined };
}
export const Instance = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    IdentityManagementType: S.optional(DirectoryType),
    InstanceAlias: S.optional(SensitiveString),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ServiceRole: S.optional(S.String),
    InstanceStatus: S.optional(InstanceStatus),
    StatusReason: S.optional(InstanceStatusReason),
    InboundCallsEnabled: S.optional(S.Boolean),
    OutboundCallsEnabled: S.optional(S.Boolean),
    InstanceAccessUrl: S.optional(S.String),
    Tags: S.optional(TagMap),
  }),
).annotate({ identifier: "Instance" }) as any as S.Schema<Instance>;
export type InstanceReplicationStatus =
  | "INSTANCE_REPLICATION_COMPLETE"
  | "INSTANCE_REPLICATION_IN_PROGRESS"
  | "INSTANCE_REPLICATION_FAILED"
  | "INSTANCE_REPLICA_DELETING"
  | "INSTANCE_REPLICATION_DELETION_FAILED"
  | "RESOURCE_REPLICATION_NOT_STARTED"
  | (string & {});
export const InstanceReplicationStatus = S.String;
export interface ReplicationStatusSummary {
  Region?: string;
  ReplicationStatus?: InstanceReplicationStatus;
  ReplicationStatusReason?: string;
}
export const ReplicationStatusSummary = S.suspend(() =>
  S.Struct({
    Region: S.optional(S.String),
    ReplicationStatus: S.optional(InstanceReplicationStatus),
    ReplicationStatusReason: S.optional(S.String),
  }),
).annotate({
  identifier: "ReplicationStatusSummary",
}) as any as S.Schema<ReplicationStatusSummary>;
export type ReplicationStatusSummaryList = ReplicationStatusSummary[];
export const ReplicationStatusSummaryList = S.Array(ReplicationStatusSummary);
export interface ReplicationConfiguration {
  ReplicationStatusSummaryList?: ReplicationStatusSummary[];
  SourceRegion?: string;
  GlobalSignInEndpoint?: string;
}
export const ReplicationConfiguration = S.suspend(() =>
  S.Struct({
    ReplicationStatusSummaryList: S.optional(ReplicationStatusSummaryList),
    SourceRegion: S.optional(S.String),
    GlobalSignInEndpoint: S.optional(S.String),
  }),
).annotate({
  identifier: "ReplicationConfiguration",
}) as any as S.Schema<ReplicationConfiguration>;
export interface DescribeInstanceResponse {
  Instance?: Instance;
  ReplicationConfiguration?: ReplicationConfiguration;
}
export const DescribeInstanceResponse = S.suspend(() =>
  S.Struct({
    Instance: S.optional(Instance),
    ReplicationConfiguration: S.optional(ReplicationConfiguration),
  }),
).annotate({
  identifier: "DescribeInstanceResponse",
}) as any as S.Schema<DescribeInstanceResponse>;
export type InstanceAttributeType =
  | "INBOUND_CALLS"
  | "OUTBOUND_CALLS"
  | "CONTACTFLOW_LOGS"
  | "CONTACT_LENS"
  | "AUTO_RESOLVE_BEST_VOICES"
  | "USE_CUSTOM_TTS_VOICES"
  | "EARLY_MEDIA"
  | "MULTI_PARTY_CONFERENCE"
  | "HIGH_VOLUME_OUTBOUND"
  | "ENHANCED_CONTACT_MONITORING"
  | "ENHANCED_CHAT_MONITORING"
  | "MULTI_PARTY_CHAT_CONFERENCE"
  | "MESSAGE_STREAMING"
  | (string & {});
export const InstanceAttributeType = S.String;
export interface DescribeInstanceAttributeRequest {
  InstanceId: string;
  AttributeType: InstanceAttributeType;
}
export const DescribeInstanceAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AttributeType: InstanceAttributeType.pipe(T.HttpLabel("AttributeType")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/instance/{InstanceId}/attribute/{AttributeType}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInstanceAttributeRequest",
}) as any as S.Schema<DescribeInstanceAttributeRequest>;
export interface Attribute {
  AttributeType?: InstanceAttributeType;
  Value?: string;
}
export const Attribute = S.suspend(() =>
  S.Struct({
    AttributeType: S.optional(InstanceAttributeType),
    Value: S.optional(S.String),
  }),
).annotate({ identifier: "Attribute" }) as any as S.Schema<Attribute>;
export interface DescribeInstanceAttributeResponse {
  Attribute?: Attribute;
}
export const DescribeInstanceAttributeResponse = S.suspend(() =>
  S.Struct({ Attribute: S.optional(Attribute) }),
).annotate({
  identifier: "DescribeInstanceAttributeResponse",
}) as any as S.Schema<DescribeInstanceAttributeResponse>;
export interface DescribeInstanceStorageConfigRequest {
  InstanceId: string;
  AssociationId: string;
  ResourceType: InstanceStorageResourceType;
}
export const DescribeInstanceStorageConfigRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AssociationId: S.String.pipe(T.HttpLabel("AssociationId")),
    ResourceType: InstanceStorageResourceType.pipe(T.HttpQuery("resourceType")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/instance/{InstanceId}/storage-config/{AssociationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeInstanceStorageConfigRequest",
}) as any as S.Schema<DescribeInstanceStorageConfigRequest>;
export interface DescribeInstanceStorageConfigResponse {
  StorageConfig?: InstanceStorageConfig;
}
export const DescribeInstanceStorageConfigResponse = S.suspend(() =>
  S.Struct({ StorageConfig: S.optional(InstanceStorageConfig) }),
).annotate({
  identifier: "DescribeInstanceStorageConfigResponse",
}) as any as S.Schema<DescribeInstanceStorageConfigResponse>;
export interface DescribeNotificationRequest {
  InstanceId: string;
  NotificationId: string;
}
export const DescribeNotificationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NotificationId: S.String.pipe(T.HttpLabel("NotificationId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/notifications/{InstanceId}/{NotificationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeNotificationRequest",
}) as any as S.Schema<DescribeNotificationRequest>;
export type NotificationPriority = "URGENT" | "HIGH" | "LOW" | (string & {});
export const NotificationPriority = S.String;
export interface Notification {
  Content?: { [key: string]: string | undefined };
  Id: string;
  Arn: string;
  Priority?: NotificationPriority;
  Recipients?: string[];
  LastModifiedTime: Date;
  CreatedAt?: Date;
  ExpiresAt?: Date;
  LastModifiedRegion?: string;
  Tags?: { [key: string]: string | undefined };
}
export const Notification = S.suspend(() =>
  S.Struct({
    Content: S.optional(NotificationContent),
    Id: S.String,
    Arn: S.String,
    Priority: S.optional(NotificationPriority),
    Recipients: S.optional(RecipientList),
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    CreatedAt: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ExpiresAt: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedRegion: S.optional(S.String),
    Tags: S.optional(TagMap),
  }),
).annotate({ identifier: "Notification" }) as any as S.Schema<Notification>;
export interface DescribeNotificationResponse {
  Notification: Notification;
}
export const DescribeNotificationResponse = S.suspend(() =>
  S.Struct({ Notification: Notification }),
).annotate({
  identifier: "DescribeNotificationResponse",
}) as any as S.Schema<DescribeNotificationResponse>;
export interface DescribePhoneNumberRequest {
  PhoneNumberId: string;
}
export const DescribePhoneNumberRequest = S.suspend(() =>
  S.Struct({ PhoneNumberId: S.String.pipe(T.HttpLabel("PhoneNumberId")) }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/phone-number/{PhoneNumberId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribePhoneNumberRequest",
}) as any as S.Schema<DescribePhoneNumberRequest>;
export type PhoneNumberCountryCode =
  | "AF"
  | "AL"
  | "DZ"
  | "AS"
  | "AD"
  | "AO"
  | "AI"
  | "AQ"
  | "AG"
  | "AR"
  | "AM"
  | "AW"
  | "AU"
  | "AT"
  | "AZ"
  | "BS"
  | "BH"
  | "BD"
  | "BB"
  | "BY"
  | "BE"
  | "BZ"
  | "BJ"
  | "BM"
  | "BT"
  | "BO"
  | "BA"
  | "BW"
  | "BR"
  | "IO"
  | "VG"
  | "BN"
  | "BG"
  | "BF"
  | "BI"
  | "KH"
  | "CM"
  | "CA"
  | "CV"
  | "KY"
  | "CF"
  | "TD"
  | "CL"
  | "CN"
  | "CX"
  | "CC"
  | "CO"
  | "KM"
  | "CK"
  | "CR"
  | "HR"
  | "CU"
  | "CW"
  | "CY"
  | "CZ"
  | "CD"
  | "DK"
  | "DJ"
  | "DM"
  | "DO"
  | "TL"
  | "EC"
  | "EG"
  | "SV"
  | "GQ"
  | "ER"
  | "EE"
  | "ET"
  | "FK"
  | "FO"
  | "FJ"
  | "FI"
  | "FR"
  | "PF"
  | "GA"
  | "GM"
  | "GE"
  | "DE"
  | "GH"
  | "GI"
  | "GR"
  | "GL"
  | "GD"
  | "GU"
  | "GT"
  | "GG"
  | "GN"
  | "GW"
  | "GY"
  | "HT"
  | "HN"
  | "HK"
  | "HU"
  | "IS"
  | "IN"
  | "ID"
  | "IR"
  | "IQ"
  | "IE"
  | "IM"
  | "IL"
  | "IT"
  | "CI"
  | "JM"
  | "JP"
  | "JE"
  | "JO"
  | "KZ"
  | "KE"
  | "KI"
  | "KW"
  | "KG"
  | "LA"
  | "LV"
  | "LB"
  | "LS"
  | "LR"
  | "LY"
  | "LI"
  | "LT"
  | "LU"
  | "MO"
  | "MK"
  | "MG"
  | "MW"
  | "MY"
  | "MV"
  | "ML"
  | "MT"
  | "MH"
  | "MR"
  | "MU"
  | "YT"
  | "MX"
  | "FM"
  | "MD"
  | "MC"
  | "MN"
  | "ME"
  | "MS"
  | "MA"
  | "MZ"
  | "MM"
  | "NA"
  | "NR"
  | "NP"
  | "NL"
  | "AN"
  | "NC"
  | "NZ"
  | "NI"
  | "NE"
  | "NG"
  | "NU"
  | "KP"
  | "MP"
  | "NO"
  | "OM"
  | "PK"
  | "PW"
  | "PA"
  | "PG"
  | "PY"
  | "PE"
  | "PH"
  | "PN"
  | "PL"
  | "PT"
  | "PR"
  | "QA"
  | "CG"
  | "RE"
  | "RO"
  | "RU"
  | "RW"
  | "BL"
  | "SH"
  | "KN"
  | "LC"
  | "MF"
  | "PM"
  | "VC"
  | "WS"
  | "SM"
  | "ST"
  | "SA"
  | "SN"
  | "RS"
  | "SC"
  | "SL"
  | "SG"
  | "SX"
  | "SK"
  | "SI"
  | "SB"
  | "SO"
  | "ZA"
  | "KR"
  | "ES"
  | "LK"
  | "SD"
  | "SR"
  | "SJ"
  | "SZ"
  | "SE"
  | "CH"
  | "SY"
  | "TW"
  | "TJ"
  | "TZ"
  | "TH"
  | "TG"
  | "TK"
  | "TO"
  | "TT"
  | "TN"
  | "TR"
  | "TM"
  | "TC"
  | "TV"
  | "VI"
  | "UG"
  | "UA"
  | "AE"
  | "GB"
  | "US"
  | "UY"
  | "UZ"
  | "VU"
  | "VA"
  | "VE"
  | "VN"
  | "WF"
  | "EH"
  | "YE"
  | "ZM"
  | "ZW"
  | (string & {});
export const PhoneNumberCountryCode = S.String;
export type PhoneNumberType =
  | "TOLL_FREE"
  | "DID"
  | "UIFN"
  | "SHARED"
  | "THIRD_PARTY_TF"
  | "THIRD_PARTY_DID"
  | "SHORT_CODE"
  | (string & {});
export const PhoneNumberType = S.String;
export type PhoneNumberWorkflowStatus =
  | "CLAIMED"
  | "IN_PROGRESS"
  | "FAILED"
  | (string & {});
export const PhoneNumberWorkflowStatus = S.String;
export interface PhoneNumberStatus {
  Status?: PhoneNumberWorkflowStatus;
  Message?: string;
}
export const PhoneNumberStatus = S.suspend(() =>
  S.Struct({
    Status: S.optional(PhoneNumberWorkflowStatus),
    Message: S.optional(S.String),
  }),
).annotate({
  identifier: "PhoneNumberStatus",
}) as any as S.Schema<PhoneNumberStatus>;
export interface ClaimedPhoneNumberSummary {
  PhoneNumberId?: string;
  PhoneNumberArn?: string;
  PhoneNumber?: string;
  PhoneNumberCountryCode?: PhoneNumberCountryCode;
  PhoneNumberType?: PhoneNumberType;
  PhoneNumberDescription?: string;
  TargetArn?: string;
  InstanceId?: string;
  Tags?: { [key: string]: string | undefined };
  PhoneNumberStatus?: PhoneNumberStatus;
  SourcePhoneNumberArn?: string;
}
export const ClaimedPhoneNumberSummary = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.optional(S.String),
    PhoneNumberArn: S.optional(S.String),
    PhoneNumber: S.optional(S.String),
    PhoneNumberCountryCode: S.optional(PhoneNumberCountryCode),
    PhoneNumberType: S.optional(PhoneNumberType),
    PhoneNumberDescription: S.optional(S.String),
    TargetArn: S.optional(S.String),
    InstanceId: S.optional(S.String),
    Tags: S.optional(TagMap),
    PhoneNumberStatus: S.optional(PhoneNumberStatus),
    SourcePhoneNumberArn: S.optional(S.String),
  }),
).annotate({
  identifier: "ClaimedPhoneNumberSummary",
}) as any as S.Schema<ClaimedPhoneNumberSummary>;
export interface DescribePhoneNumberResponse {
  ClaimedPhoneNumberSummary?: ClaimedPhoneNumberSummary;
}
export const DescribePhoneNumberResponse = S.suspend(() =>
  S.Struct({
    ClaimedPhoneNumberSummary: S.optional(ClaimedPhoneNumberSummary),
  }),
).annotate({
  identifier: "DescribePhoneNumberResponse",
}) as any as S.Schema<DescribePhoneNumberResponse>;
export interface DescribePredefinedAttributeRequest {
  InstanceId: string;
  Name: string;
}
export const DescribePredefinedAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String.pipe(T.HttpLabel("Name")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/predefined-attributes/{InstanceId}/{Name}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribePredefinedAttributeRequest",
}) as any as S.Schema<DescribePredefinedAttributeRequest>;
export interface PredefinedAttributeConfiguration {
  EnableValueValidationOnAssociation?: boolean;
  IsReadOnly?: boolean;
}
export const PredefinedAttributeConfiguration = S.suspend(() =>
  S.Struct({
    EnableValueValidationOnAssociation: S.optional(S.Boolean),
    IsReadOnly: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "PredefinedAttributeConfiguration",
}) as any as S.Schema<PredefinedAttributeConfiguration>;
export interface PredefinedAttribute {
  Name?: string;
  Values?: PredefinedAttributeValues;
  Purposes?: string[];
  AttributeConfiguration?: PredefinedAttributeConfiguration;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const PredefinedAttribute = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Values: S.optional(PredefinedAttributeValues),
    Purposes: S.optional(PredefinedAttributePurposeNameList),
    AttributeConfiguration: S.optional(PredefinedAttributeConfiguration),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "PredefinedAttribute",
}) as any as S.Schema<PredefinedAttribute>;
export interface DescribePredefinedAttributeResponse {
  PredefinedAttribute?: PredefinedAttribute;
}
export const DescribePredefinedAttributeResponse = S.suspend(() =>
  S.Struct({ PredefinedAttribute: S.optional(PredefinedAttribute) }),
).annotate({
  identifier: "DescribePredefinedAttributeResponse",
}) as any as S.Schema<DescribePredefinedAttributeResponse>;
export interface DescribePromptRequest {
  InstanceId: string;
  PromptId: string;
}
export const DescribePromptRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    PromptId: S.String.pipe(T.HttpLabel("PromptId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/prompts/{InstanceId}/{PromptId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribePromptRequest",
}) as any as S.Schema<DescribePromptRequest>;
export interface Prompt {
  PromptARN?: string;
  PromptId?: string;
  Name?: string;
  Description?: string;
  Tags?: { [key: string]: string | undefined };
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const Prompt = S.suspend(() =>
  S.Struct({
    PromptARN: S.optional(S.String),
    PromptId: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    Tags: S.optional(TagMap),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({ identifier: "Prompt" }) as any as S.Schema<Prompt>;
export interface DescribePromptResponse {
  Prompt?: Prompt;
}
export const DescribePromptResponse = S.suspend(() =>
  S.Struct({ Prompt: S.optional(Prompt) }),
).annotate({
  identifier: "DescribePromptResponse",
}) as any as S.Schema<DescribePromptResponse>;
export interface DescribeQueueRequest {
  InstanceId: string;
  QueueId: string;
}
export const DescribeQueueRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/queues/{InstanceId}/{QueueId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeQueueRequest",
}) as any as S.Schema<DescribeQueueRequest>;
export type QueueStatus = "ENABLED" | "DISABLED" | (string & {});
export const QueueStatus = S.String;
export interface Queue {
  Name?: string;
  QueueArn?: string;
  QueueId?: string;
  Description?: string;
  OutboundCallerConfig?: OutboundCallerConfig;
  OutboundEmailConfig?: OutboundEmailConfig;
  HoursOfOperationId?: string;
  MaxContacts?: number;
  Status?: QueueStatus;
  Tags?: { [key: string]: string | undefined };
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const Queue = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    QueueArn: S.optional(S.String),
    QueueId: S.optional(S.String),
    Description: S.optional(S.String),
    OutboundCallerConfig: S.optional(OutboundCallerConfig),
    OutboundEmailConfig: S.optional(OutboundEmailConfig),
    HoursOfOperationId: S.optional(S.String),
    MaxContacts: S.optional(S.Number),
    Status: S.optional(QueueStatus),
    Tags: S.optional(TagMap),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({ identifier: "Queue" }) as any as S.Schema<Queue>;
export interface DescribeQueueResponse {
  Queue?: Queue;
}
export const DescribeQueueResponse = S.suspend(() =>
  S.Struct({ Queue: S.optional(Queue) }),
).annotate({
  identifier: "DescribeQueueResponse",
}) as any as S.Schema<DescribeQueueResponse>;
export interface DescribeQuickConnectRequest {
  InstanceId: string;
  QuickConnectId: string;
}
export const DescribeQuickConnectRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QuickConnectId: S.String.pipe(T.HttpLabel("QuickConnectId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/quick-connects/{InstanceId}/{QuickConnectId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeQuickConnectRequest",
}) as any as S.Schema<DescribeQuickConnectRequest>;
export interface QuickConnect {
  QuickConnectARN?: string;
  QuickConnectId?: string;
  Name?: string;
  Description?: string;
  QuickConnectConfig?: QuickConnectConfig;
  Tags?: { [key: string]: string | undefined };
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const QuickConnect = S.suspend(() =>
  S.Struct({
    QuickConnectARN: S.optional(S.String),
    QuickConnectId: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    QuickConnectConfig: S.optional(QuickConnectConfig),
    Tags: S.optional(TagMap),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({ identifier: "QuickConnect" }) as any as S.Schema<QuickConnect>;
export interface DescribeQuickConnectResponse {
  QuickConnect?: QuickConnect;
}
export const DescribeQuickConnectResponse = S.suspend(() =>
  S.Struct({ QuickConnect: S.optional(QuickConnect) }),
).annotate({
  identifier: "DescribeQuickConnectResponse",
}) as any as S.Schema<DescribeQuickConnectResponse>;
export interface DescribeRoutingProfileRequest {
  InstanceId: string;
  RoutingProfileId: string;
}
export const DescribeRoutingProfileRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeRoutingProfileRequest",
}) as any as S.Schema<DescribeRoutingProfileRequest>;
export type AssociatedQueueIdList = string[];
export const AssociatedQueueIdList = S.Array(S.String);
export interface RoutingProfile {
  InstanceId?: string;
  Name?: string;
  RoutingProfileArn?: string;
  RoutingProfileId?: string;
  Description?: string;
  MediaConcurrencies?: MediaConcurrency[];
  DefaultOutboundQueueId?: string;
  Tags?: { [key: string]: string | undefined };
  NumberOfAssociatedQueues?: number;
  NumberOfAssociatedManualAssignmentQueues?: number;
  NumberOfAssociatedUsers?: number;
  AgentAvailabilityTimer?: AgentAvailabilityTimer;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
  IsDefault?: boolean;
  AssociatedQueueIds?: string[];
  AssociatedManualAssignmentQueueIds?: string[];
}
export const RoutingProfile = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    Name: S.optional(S.String),
    RoutingProfileArn: S.optional(S.String),
    RoutingProfileId: S.optional(S.String),
    Description: S.optional(S.String),
    MediaConcurrencies: S.optional(MediaConcurrencies),
    DefaultOutboundQueueId: S.optional(S.String),
    Tags: S.optional(TagMap),
    NumberOfAssociatedQueues: S.optional(S.Number),
    NumberOfAssociatedManualAssignmentQueues: S.optional(S.Number),
    NumberOfAssociatedUsers: S.optional(S.Number),
    AgentAvailabilityTimer: S.optional(AgentAvailabilityTimer),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
    IsDefault: S.optional(S.Boolean),
    AssociatedQueueIds: S.optional(AssociatedQueueIdList),
    AssociatedManualAssignmentQueueIds: S.optional(AssociatedQueueIdList),
  }),
).annotate({ identifier: "RoutingProfile" }) as any as S.Schema<RoutingProfile>;
export interface DescribeRoutingProfileResponse {
  RoutingProfile?: RoutingProfile;
}
export const DescribeRoutingProfileResponse = S.suspend(() =>
  S.Struct({ RoutingProfile: S.optional(RoutingProfile) }),
).annotate({
  identifier: "DescribeRoutingProfileResponse",
}) as any as S.Schema<DescribeRoutingProfileResponse>;
export interface DescribeRuleRequest {
  InstanceId: string;
  RuleId: string;
}
export const DescribeRuleRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RuleId: S.String.pipe(T.HttpLabel("RuleId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/rules/{InstanceId}/{RuleId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeRuleRequest",
}) as any as S.Schema<DescribeRuleRequest>;
export interface Rule {
  Name: string;
  RuleId: string;
  RuleArn: string;
  TriggerEventSource: RuleTriggerEventSource;
  Function: string;
  Actions: RuleAction[];
  PublishStatus: RulePublishStatus;
  CreatedTime: Date;
  LastUpdatedTime: Date;
  LastUpdatedBy: string;
  Tags?: { [key: string]: string | undefined };
}
export const Rule = S.suspend(() =>
  S.Struct({
    Name: S.String,
    RuleId: S.String,
    RuleArn: S.String,
    TriggerEventSource: RuleTriggerEventSource,
    Function: S.String,
    Actions: RuleActions,
    PublishStatus: RulePublishStatus,
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastUpdatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastUpdatedBy: S.String,
    Tags: S.optional(TagMap),
  }),
).annotate({ identifier: "Rule" }) as any as S.Schema<Rule>;
export interface DescribeRuleResponse {
  Rule: Rule;
}
export const DescribeRuleResponse = S.suspend(() =>
  S.Struct({ Rule: Rule }),
).annotate({
  identifier: "DescribeRuleResponse",
}) as any as S.Schema<DescribeRuleResponse>;
export interface DescribeSecurityProfileRequest {
  SecurityProfileId: string;
  InstanceId: string;
}
export const DescribeSecurityProfileRequest = S.suspend(() =>
  S.Struct({
    SecurityProfileId: S.String.pipe(T.HttpLabel("SecurityProfileId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/security-profiles/{InstanceId}/{SecurityProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeSecurityProfileRequest",
}) as any as S.Schema<DescribeSecurityProfileRequest>;
export interface SecurityProfile {
  Id?: string;
  OrganizationResourceId?: string;
  Arn?: string;
  SecurityProfileName?: string;
  Description?: string;
  Tags?: { [key: string]: string | undefined };
  AllowedAccessControlTags?: { [key: string]: string | undefined };
  TagRestrictedResources?: string[];
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
  HierarchyRestrictedResources?: string[];
  AllowedAccessControlHierarchyGroupId?: string;
  GranularAccessControlConfiguration?: GranularAccessControlConfiguration;
}
export const SecurityProfile = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    OrganizationResourceId: S.optional(S.String),
    Arn: S.optional(S.String),
    SecurityProfileName: S.optional(S.String),
    Description: S.optional(S.String),
    Tags: S.optional(TagMap),
    AllowedAccessControlTags: S.optional(AllowedAccessControlTags),
    TagRestrictedResources: S.optional(TagRestrictedResourceList),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
    HierarchyRestrictedResources: S.optional(HierarchyRestrictedResourceList),
    AllowedAccessControlHierarchyGroupId: S.optional(S.String),
    GranularAccessControlConfiguration: S.optional(
      GranularAccessControlConfiguration,
    ),
  }),
).annotate({
  identifier: "SecurityProfile",
}) as any as S.Schema<SecurityProfile>;
export interface DescribeSecurityProfileResponse {
  SecurityProfile?: SecurityProfile;
}
export const DescribeSecurityProfileResponse = S.suspend(() =>
  S.Struct({ SecurityProfile: S.optional(SecurityProfile) }),
).annotate({
  identifier: "DescribeSecurityProfileResponse",
}) as any as S.Schema<DescribeSecurityProfileResponse>;
export interface DescribeTestCaseRequest {
  InstanceId: string;
  TestCaseId: string;
  Status?: TestCaseStatus;
}
export const DescribeTestCaseRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    TestCaseId: S.String.pipe(T.HttpLabel("TestCaseId")),
    Status: S.optional(TestCaseStatus).pipe(T.HttpQuery("status")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/test-cases/{InstanceId}/{TestCaseId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTestCaseRequest",
}) as any as S.Schema<DescribeTestCaseRequest>;
export interface TestCase {
  Arn?: string;
  Id?: string;
  Name?: string;
  Content?: string;
  EntryPoint?: TestCaseEntryPoint;
  InitializationData?: string;
  Description?: string;
  Status?: TestCaseStatus;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
  Tags?: { [key: string]: string | undefined };
  TestCaseSha256?: string;
}
export const TestCase = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Id: S.optional(S.String),
    Name: S.optional(S.String),
    Content: S.optional(S.String),
    EntryPoint: S.optional(TestCaseEntryPoint),
    InitializationData: S.optional(S.String),
    Description: S.optional(S.String),
    Status: S.optional(TestCaseStatus),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
    Tags: S.optional(TagMap),
    TestCaseSha256: S.optional(S.String),
  }),
).annotate({ identifier: "TestCase" }) as any as S.Schema<TestCase>;
export interface DescribeTestCaseResponse {
  TestCase?: TestCase;
}
export const DescribeTestCaseResponse = S.suspend(() =>
  S.Struct({ TestCase: S.optional(TestCase) }),
).annotate({
  identifier: "DescribeTestCaseResponse",
}) as any as S.Schema<DescribeTestCaseResponse>;
export interface DescribeTrafficDistributionGroupRequest {
  TrafficDistributionGroupId: string;
}
export const DescribeTrafficDistributionGroupRequest = S.suspend(() =>
  S.Struct({
    TrafficDistributionGroupId: S.String.pipe(
      T.HttpLabel("TrafficDistributionGroupId"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/traffic-distribution-group/{TrafficDistributionGroupId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeTrafficDistributionGroupRequest",
}) as any as S.Schema<DescribeTrafficDistributionGroupRequest>;
export type TrafficDistributionGroupStatus =
  | "CREATION_IN_PROGRESS"
  | "ACTIVE"
  | "CREATION_FAILED"
  | "PENDING_DELETION"
  | "DELETION_FAILED"
  | "UPDATE_IN_PROGRESS"
  | (string & {});
export const TrafficDistributionGroupStatus = S.String;
export interface TrafficDistributionGroup {
  Id?: string;
  Arn?: string;
  Name?: string;
  Description?: string;
  InstanceArn?: string;
  Status?: TrafficDistributionGroupStatus;
  Tags?: { [key: string]: string | undefined };
  IsDefault?: boolean;
}
export const TrafficDistributionGroup = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    InstanceArn: S.optional(S.String),
    Status: S.optional(TrafficDistributionGroupStatus),
    Tags: S.optional(TagMap),
    IsDefault: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "TrafficDistributionGroup",
}) as any as S.Schema<TrafficDistributionGroup>;
export interface DescribeTrafficDistributionGroupResponse {
  TrafficDistributionGroup?: TrafficDistributionGroup;
}
export const DescribeTrafficDistributionGroupResponse = S.suspend(() =>
  S.Struct({ TrafficDistributionGroup: S.optional(TrafficDistributionGroup) }),
).annotate({
  identifier: "DescribeTrafficDistributionGroupResponse",
}) as any as S.Schema<DescribeTrafficDistributionGroupResponse>;
export interface DescribeUserRequest {
  UserId: string;
  InstanceId: string;
}
export const DescribeUserRequest = S.suspend(() =>
  S.Struct({
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/users/{InstanceId}/{UserId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeUserRequest",
}) as any as S.Schema<DescribeUserRequest>;
export interface User {
  Id?: string;
  Arn?: string;
  Username?: string;
  IdentityInfo?: UserIdentityInfo;
  PhoneConfig?: UserPhoneConfig;
  DirectoryUserId?: string;
  SecurityProfileIds?: string[];
  RoutingProfileId?: string;
  HierarchyGroupId?: string;
  Tags?: { [key: string]: string | undefined };
  AutoAcceptConfigs?: AutoAcceptConfig[];
  AfterContactWorkConfigs?: AfterContactWorkConfigPerChannel[];
  PhoneNumberConfigs?: PhoneNumberConfig[];
  PersistentConnectionConfigs?: PersistentConnectionConfig[];
  VoiceEnhancementConfigs?: VoiceEnhancementConfig[];
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const User = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Username: S.optional(S.String),
    IdentityInfo: S.optional(UserIdentityInfo),
    PhoneConfig: S.optional(UserPhoneConfig),
    DirectoryUserId: S.optional(S.String),
    SecurityProfileIds: S.optional(SecurityProfileIds),
    RoutingProfileId: S.optional(S.String),
    HierarchyGroupId: S.optional(S.String),
    Tags: S.optional(TagMap),
    AutoAcceptConfigs: S.optional(AutoAcceptConfigs),
    AfterContactWorkConfigs: S.optional(AfterContactWorkConfigs),
    PhoneNumberConfigs: S.optional(PhoneNumberConfigs),
    PersistentConnectionConfigs: S.optional(PersistentConnectionConfigs),
    VoiceEnhancementConfigs: S.optional(VoiceEnhancementConfigs),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({ identifier: "User" }) as any as S.Schema<User>;
export interface DescribeUserResponse {
  User?: User;
}
export const DescribeUserResponse = S.suspend(() =>
  S.Struct({ User: S.optional(User) }),
).annotate({
  identifier: "DescribeUserResponse",
}) as any as S.Schema<DescribeUserResponse>;
export interface DescribeUserHierarchyGroupRequest {
  HierarchyGroupId: string;
  InstanceId: string;
}
export const DescribeUserHierarchyGroupRequest = S.suspend(() =>
  S.Struct({
    HierarchyGroupId: S.String.pipe(T.HttpLabel("HierarchyGroupId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/user-hierarchy-groups/{InstanceId}/{HierarchyGroupId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeUserHierarchyGroupRequest",
}) as any as S.Schema<DescribeUserHierarchyGroupRequest>;
export interface HierarchyGroupSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const HierarchyGroupSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "HierarchyGroupSummary",
}) as any as S.Schema<HierarchyGroupSummary>;
export interface HierarchyPath {
  LevelOne?: HierarchyGroupSummary;
  LevelTwo?: HierarchyGroupSummary;
  LevelThree?: HierarchyGroupSummary;
  LevelFour?: HierarchyGroupSummary;
  LevelFive?: HierarchyGroupSummary;
}
export const HierarchyPath = S.suspend(() =>
  S.Struct({
    LevelOne: S.optional(HierarchyGroupSummary),
    LevelTwo: S.optional(HierarchyGroupSummary),
    LevelThree: S.optional(HierarchyGroupSummary),
    LevelFour: S.optional(HierarchyGroupSummary),
    LevelFive: S.optional(HierarchyGroupSummary),
  }),
).annotate({ identifier: "HierarchyPath" }) as any as S.Schema<HierarchyPath>;
export interface HierarchyGroup {
  Id?: string;
  Arn?: string;
  Name?: string;
  LevelId?: string;
  HierarchyPath?: HierarchyPath;
  Tags?: { [key: string]: string | undefined };
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const HierarchyGroup = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    LevelId: S.optional(S.String),
    HierarchyPath: S.optional(HierarchyPath),
    Tags: S.optional(TagMap),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({ identifier: "HierarchyGroup" }) as any as S.Schema<HierarchyGroup>;
export interface DescribeUserHierarchyGroupResponse {
  HierarchyGroup?: HierarchyGroup;
}
export const DescribeUserHierarchyGroupResponse = S.suspend(() =>
  S.Struct({ HierarchyGroup: S.optional(HierarchyGroup) }),
).annotate({
  identifier: "DescribeUserHierarchyGroupResponse",
}) as any as S.Schema<DescribeUserHierarchyGroupResponse>;
export interface DescribeUserHierarchyStructureRequest {
  InstanceId: string;
}
export const DescribeUserHierarchyStructureRequest = S.suspend(() =>
  S.Struct({ InstanceId: S.String.pipe(T.HttpLabel("InstanceId")) }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/user-hierarchy-structure/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeUserHierarchyStructureRequest",
}) as any as S.Schema<DescribeUserHierarchyStructureRequest>;
export interface HierarchyLevel {
  Id?: string;
  Arn?: string;
  Name?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const HierarchyLevel = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({ identifier: "HierarchyLevel" }) as any as S.Schema<HierarchyLevel>;
export interface HierarchyStructure {
  LevelOne?: HierarchyLevel;
  LevelTwo?: HierarchyLevel;
  LevelThree?: HierarchyLevel;
  LevelFour?: HierarchyLevel;
  LevelFive?: HierarchyLevel;
}
export const HierarchyStructure = S.suspend(() =>
  S.Struct({
    LevelOne: S.optional(HierarchyLevel),
    LevelTwo: S.optional(HierarchyLevel),
    LevelThree: S.optional(HierarchyLevel),
    LevelFour: S.optional(HierarchyLevel),
    LevelFive: S.optional(HierarchyLevel),
  }),
).annotate({
  identifier: "HierarchyStructure",
}) as any as S.Schema<HierarchyStructure>;
export interface DescribeUserHierarchyStructureResponse {
  HierarchyStructure?: HierarchyStructure;
}
export const DescribeUserHierarchyStructureResponse = S.suspend(() =>
  S.Struct({ HierarchyStructure: S.optional(HierarchyStructure) }),
).annotate({
  identifier: "DescribeUserHierarchyStructureResponse",
}) as any as S.Schema<DescribeUserHierarchyStructureResponse>;
export interface DescribeViewRequest {
  InstanceId: string;
  ViewId: string;
}
export const DescribeViewRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ViewId: S.String.pipe(T.HttpLabel("ViewId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/views/{InstanceId}/{ViewId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeViewRequest",
}) as any as S.Schema<DescribeViewRequest>;
export interface DescribeViewResponse {
  View?: View;
}
export const DescribeViewResponse = S.suspend(() =>
  S.Struct({ View: S.optional(View) }),
).annotate({
  identifier: "DescribeViewResponse",
}) as any as S.Schema<DescribeViewResponse>;
export interface DescribeVocabularyRequest {
  InstanceId: string;
  VocabularyId: string;
}
export const DescribeVocabularyRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    VocabularyId: S.String.pipe(T.HttpLabel("VocabularyId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/vocabulary/{InstanceId}/{VocabularyId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeVocabularyRequest",
}) as any as S.Schema<DescribeVocabularyRequest>;
export interface Vocabulary {
  Name: string;
  Id: string;
  Arn: string;
  LanguageCode: VocabularyLanguageCode;
  State: VocabularyState;
  LastModifiedTime: Date;
  FailureReason?: string;
  Content?: string;
  Tags?: { [key: string]: string | undefined };
}
export const Vocabulary = S.suspend(() =>
  S.Struct({
    Name: S.String,
    Id: S.String,
    Arn: S.String,
    LanguageCode: VocabularyLanguageCode,
    State: VocabularyState,
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    FailureReason: S.optional(S.String),
    Content: S.optional(S.String),
    Tags: S.optional(TagMap),
  }),
).annotate({ identifier: "Vocabulary" }) as any as S.Schema<Vocabulary>;
export interface DescribeVocabularyResponse {
  Vocabulary: Vocabulary;
}
export const DescribeVocabularyResponse = S.suspend(() =>
  S.Struct({ Vocabulary: Vocabulary }),
).annotate({
  identifier: "DescribeVocabularyResponse",
}) as any as S.Schema<DescribeVocabularyResponse>;
export interface DescribeWorkspaceRequest {
  InstanceId: string;
  WorkspaceId: string;
}
export const DescribeWorkspaceRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/workspaces/{InstanceId}/{WorkspaceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DescribeWorkspaceRequest",
}) as any as S.Schema<DescribeWorkspaceRequest>;
export type Visibility = "ALL" | "ASSIGNED" | "NONE" | (string & {});
export const Visibility = S.String;
export interface Workspace {
  Visibility?: Visibility;
  Id: string;
  Name: string;
  Arn: string;
  Description?: string;
  Theme?: WorkspaceTheme;
  Title?: string;
  LastModifiedTime: Date;
  LastModifiedRegion?: string;
  Tags?: { [key: string]: string | undefined };
}
export const Workspace = S.suspend(() =>
  S.Struct({
    Visibility: S.optional(Visibility),
    Id: S.String,
    Name: S.String,
    Arn: S.String,
    Description: S.optional(S.String),
    Theme: S.optional(WorkspaceTheme),
    Title: S.optional(S.String),
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastModifiedRegion: S.optional(S.String),
    Tags: S.optional(TagMap),
  }),
).annotate({ identifier: "Workspace" }) as any as S.Schema<Workspace>;
export interface DescribeWorkspaceResponse {
  Workspace: Workspace;
}
export const DescribeWorkspaceResponse = S.suspend(() =>
  S.Struct({ Workspace: Workspace }),
).annotate({
  identifier: "DescribeWorkspaceResponse",
}) as any as S.Schema<DescribeWorkspaceResponse>;
export interface DisassociateAnalyticsDataSetRequest {
  InstanceId: string;
  DataSetId: string;
  TargetAccountId?: string;
}
export const DisassociateAnalyticsDataSetRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataSetId: S.String,
    TargetAccountId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/analytics-data/instance/{InstanceId}/association",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateAnalyticsDataSetRequest",
}) as any as S.Schema<DisassociateAnalyticsDataSetRequest>;
export interface DisassociateAnalyticsDataSetResponse {}
export const DisassociateAnalyticsDataSetResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DisassociateAnalyticsDataSetResponse",
}) as any as S.Schema<DisassociateAnalyticsDataSetResponse>;
export interface DisassociateApprovedOriginRequest {
  InstanceId: string;
  Origin: string;
  ClientToken?: string;
}
export const DisassociateApprovedOriginRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Origin: S.String.pipe(T.HttpQuery("origin")),
    ClientToken: S.optional(S.String).pipe(
      T.HttpQuery("clientToken"),
      T.IdempotencyToken(),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/instance/{InstanceId}/approved-origin",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateApprovedOriginRequest",
}) as any as S.Schema<DisassociateApprovedOriginRequest>;
export interface DisassociateApprovedOriginResponse {}
export const DisassociateApprovedOriginResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DisassociateApprovedOriginResponse",
}) as any as S.Schema<DisassociateApprovedOriginResponse>;
export interface DisassociateBotRequest {
  InstanceId: string;
  LexBot?: LexBot;
  LexV2Bot?: LexV2Bot;
  ClientToken?: string;
}
export const DisassociateBotRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    LexBot: S.optional(LexBot),
    LexV2Bot: S.optional(LexV2Bot),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/instance/{InstanceId}/bot" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateBotRequest",
}) as any as S.Schema<DisassociateBotRequest>;
export interface DisassociateBotResponse {}
export const DisassociateBotResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "DisassociateBotResponse",
}) as any as S.Schema<DisassociateBotResponse>;
export interface DisassociateEmailAddressAliasRequest {
  EmailAddressId: string;
  InstanceId: string;
  AliasConfiguration: AliasConfiguration;
  ClientToken?: string;
}
export const DisassociateEmailAddressAliasRequest = S.suspend(() =>
  S.Struct({
    EmailAddressId: S.String.pipe(T.HttpLabel("EmailAddressId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AliasConfiguration: AliasConfiguration,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/email-addresses/{InstanceId}/{EmailAddressId}/disassociate-alias",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateEmailAddressAliasRequest",
}) as any as S.Schema<DisassociateEmailAddressAliasRequest>;
export interface DisassociateEmailAddressAliasResponse {}
export const DisassociateEmailAddressAliasResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DisassociateEmailAddressAliasResponse",
}) as any as S.Schema<DisassociateEmailAddressAliasResponse>;
export interface DisassociateFlowRequest {
  InstanceId: string;
  ResourceId: string;
  ResourceType: FlowAssociationResourceType;
}
export const DisassociateFlowRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ResourceId: S.String.pipe(T.HttpLabel("ResourceId")),
    ResourceType: FlowAssociationResourceType.pipe(T.HttpLabel("ResourceType")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/flow-associations/{InstanceId}/{ResourceId}/{ResourceType}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateFlowRequest",
}) as any as S.Schema<DisassociateFlowRequest>;
export interface DisassociateFlowResponse {}
export const DisassociateFlowResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "DisassociateFlowResponse",
}) as any as S.Schema<DisassociateFlowResponse>;
export type ParentHoursOfOperationIdList = string[];
export const ParentHoursOfOperationIdList = S.Array(S.String);
export interface DisassociateHoursOfOperationsRequest {
  InstanceId: string;
  HoursOfOperationId: string;
  ParentHoursOfOperationIds: string[];
}
export const DisassociateHoursOfOperationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
    ParentHoursOfOperationIds: ParentHoursOfOperationIdList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}/disassociate-hours",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateHoursOfOperationsRequest",
}) as any as S.Schema<DisassociateHoursOfOperationsRequest>;
export interface DisassociateHoursOfOperationsResponse {}
export const DisassociateHoursOfOperationsResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DisassociateHoursOfOperationsResponse",
}) as any as S.Schema<DisassociateHoursOfOperationsResponse>;
export interface DisassociateInstanceStorageConfigRequest {
  InstanceId: string;
  AssociationId: string;
  ResourceType: InstanceStorageResourceType;
  ClientToken?: string;
}
export const DisassociateInstanceStorageConfigRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AssociationId: S.String.pipe(T.HttpLabel("AssociationId")),
    ResourceType: InstanceStorageResourceType.pipe(T.HttpQuery("resourceType")),
    ClientToken: S.optional(S.String).pipe(
      T.HttpQuery("clientToken"),
      T.IdempotencyToken(),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/instance/{InstanceId}/storage-config/{AssociationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateInstanceStorageConfigRequest",
}) as any as S.Schema<DisassociateInstanceStorageConfigRequest>;
export interface DisassociateInstanceStorageConfigResponse {}
export const DisassociateInstanceStorageConfigResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DisassociateInstanceStorageConfigResponse",
}) as any as S.Schema<DisassociateInstanceStorageConfigResponse>;
export interface DisassociateLambdaFunctionRequest {
  InstanceId: string;
  FunctionArn: string;
  ClientToken?: string;
}
export const DisassociateLambdaFunctionRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    FunctionArn: S.String.pipe(T.HttpQuery("functionArn")),
    ClientToken: S.optional(S.String).pipe(
      T.HttpQuery("clientToken"),
      T.IdempotencyToken(),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/instance/{InstanceId}/lambda-function",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateLambdaFunctionRequest",
}) as any as S.Schema<DisassociateLambdaFunctionRequest>;
export interface DisassociateLambdaFunctionResponse {}
export const DisassociateLambdaFunctionResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DisassociateLambdaFunctionResponse",
}) as any as S.Schema<DisassociateLambdaFunctionResponse>;
export interface DisassociateLexBotRequest {
  InstanceId: string;
  BotName: string;
  LexRegion: string;
  ClientToken?: string;
}
export const DisassociateLexBotRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    BotName: S.String.pipe(T.HttpQuery("botName")),
    LexRegion: S.String.pipe(T.HttpQuery("lexRegion")),
    ClientToken: S.optional(S.String).pipe(
      T.HttpQuery("clientToken"),
      T.IdempotencyToken(),
    ),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/instance/{InstanceId}/lex-bot" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateLexBotRequest",
}) as any as S.Schema<DisassociateLexBotRequest>;
export interface DisassociateLexBotResponse {}
export const DisassociateLexBotResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DisassociateLexBotResponse",
}) as any as S.Schema<DisassociateLexBotResponse>;
export interface DisassociatePhoneNumberContactFlowRequest {
  PhoneNumberId: string;
  InstanceId: string;
}
export const DisassociatePhoneNumberContactFlowRequest = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.String.pipe(T.HttpLabel("PhoneNumberId")),
    InstanceId: S.String.pipe(T.HttpQuery("instanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/phone-number/{PhoneNumberId}/contact-flow",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociatePhoneNumberContactFlowRequest",
}) as any as S.Schema<DisassociatePhoneNumberContactFlowRequest>;
export interface DisassociatePhoneNumberContactFlowResponse {}
export const DisassociatePhoneNumberContactFlowResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DisassociatePhoneNumberContactFlowResponse",
}) as any as S.Schema<DisassociatePhoneNumberContactFlowResponse>;
export interface DisassociateQueueQuickConnectsRequest {
  InstanceId: string;
  QueueId: string;
  QuickConnectIds: string[];
}
export const DisassociateQueueQuickConnectsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
    QuickConnectIds: QuickConnectsList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/queues/{InstanceId}/{QueueId}/disassociate-quick-connects",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateQueueQuickConnectsRequest",
}) as any as S.Schema<DisassociateQueueQuickConnectsRequest>;
export interface DisassociateQueueQuickConnectsResponse {}
export const DisassociateQueueQuickConnectsResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DisassociateQueueQuickConnectsResponse",
}) as any as S.Schema<DisassociateQueueQuickConnectsResponse>;
export type RoutingProfileQueueReferenceList = RoutingProfileQueueReference[];
export const RoutingProfileQueueReferenceList = S.Array(
  RoutingProfileQueueReference,
);
export interface DisassociateRoutingProfileQueuesRequest {
  InstanceId: string;
  RoutingProfileId: string;
  QueueReferences?: RoutingProfileQueueReference[];
  ManualAssignmentQueueReferences?: RoutingProfileQueueReference[];
}
export const DisassociateRoutingProfileQueuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
    QueueReferences: S.optional(RoutingProfileQueueReferenceList),
    ManualAssignmentQueueReferences: S.optional(
      RoutingProfileQueueReferenceList,
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}/disassociate-queues",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateRoutingProfileQueuesRequest",
}) as any as S.Schema<DisassociateRoutingProfileQueuesRequest>;
export interface DisassociateRoutingProfileQueuesResponse {}
export const DisassociateRoutingProfileQueuesResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DisassociateRoutingProfileQueuesResponse",
}) as any as S.Schema<DisassociateRoutingProfileQueuesResponse>;
export interface DisassociateSecurityKeyRequest {
  InstanceId: string;
  AssociationId: string;
  ClientToken?: string;
}
export const DisassociateSecurityKeyRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AssociationId: S.String.pipe(T.HttpLabel("AssociationId")),
    ClientToken: S.optional(S.String).pipe(
      T.HttpQuery("clientToken"),
      T.IdempotencyToken(),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/instance/{InstanceId}/security-key/{AssociationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateSecurityKeyRequest",
}) as any as S.Schema<DisassociateSecurityKeyRequest>;
export interface DisassociateSecurityKeyResponse {}
export const DisassociateSecurityKeyResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DisassociateSecurityKeyResponse",
}) as any as S.Schema<DisassociateSecurityKeyResponse>;
export interface DisassociateSecurityProfilesRequest {
  InstanceId: string;
  SecurityProfiles: SecurityProfileItem[];
  EntityType: EntityType;
  EntityArn: string;
}
export const DisassociateSecurityProfilesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    SecurityProfiles: SecurityProfiles,
    EntityType: EntityType,
    EntityArn: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/disassociate-security-profiles/{InstanceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateSecurityProfilesRequest",
}) as any as S.Schema<DisassociateSecurityProfilesRequest>;
export interface DisassociateSecurityProfilesResponse {}
export const DisassociateSecurityProfilesResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DisassociateSecurityProfilesResponse",
}) as any as S.Schema<DisassociateSecurityProfilesResponse>;
export interface DisassociateTrafficDistributionGroupUserRequest {
  TrafficDistributionGroupId: string;
  UserId: string;
  InstanceId: string;
}
export const DisassociateTrafficDistributionGroupUserRequest = S.suspend(() =>
  S.Struct({
    TrafficDistributionGroupId: S.String.pipe(
      T.HttpLabel("TrafficDistributionGroupId"),
    ),
    UserId: S.String.pipe(T.HttpQuery("UserId")),
    InstanceId: S.String.pipe(T.HttpQuery("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/traffic-distribution-group/{TrafficDistributionGroupId}/user",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateTrafficDistributionGroupUserRequest",
}) as any as S.Schema<DisassociateTrafficDistributionGroupUserRequest>;
export interface DisassociateTrafficDistributionGroupUserResponse {}
export const DisassociateTrafficDistributionGroupUserResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DisassociateTrafficDistributionGroupUserResponse",
}) as any as S.Schema<DisassociateTrafficDistributionGroupUserResponse>;
export interface UserProficiencyDisassociate {
  AttributeName: string;
  AttributeValue: string;
}
export const UserProficiencyDisassociate = S.suspend(() =>
  S.Struct({ AttributeName: S.String, AttributeValue: S.String }),
).annotate({
  identifier: "UserProficiencyDisassociate",
}) as any as S.Schema<UserProficiencyDisassociate>;
export type UserProficiencyDisassociateList = UserProficiencyDisassociate[];
export const UserProficiencyDisassociateList = S.Array(
  UserProficiencyDisassociate,
);
export interface DisassociateUserProficienciesRequest {
  InstanceId: string;
  UserId: string;
  UserProficiencies: UserProficiencyDisassociate[];
}
export const DisassociateUserProficienciesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    UserProficiencies: UserProficiencyDisassociateList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/users/{InstanceId}/{UserId}/disassociate-proficiencies",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateUserProficienciesRequest",
}) as any as S.Schema<DisassociateUserProficienciesRequest>;
export interface DisassociateUserProficienciesResponse {}
export const DisassociateUserProficienciesResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DisassociateUserProficienciesResponse",
}) as any as S.Schema<DisassociateUserProficienciesResponse>;
export interface DisassociateWorkspaceRequest {
  InstanceId: string;
  WorkspaceId: string;
  ResourceArns: string[];
}
export const DisassociateWorkspaceRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    ResourceArns: WorkspaceResourceArnList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/disassociate",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DisassociateWorkspaceRequest",
}) as any as S.Schema<DisassociateWorkspaceRequest>;
export interface DisassociateWorkspaceResponse {
  SuccessfulList?: SuccessfulBatchAssociationSummary[];
  FailedList?: FailedBatchAssociationSummary[];
}
export const DisassociateWorkspaceResponse = S.suspend(() =>
  S.Struct({
    SuccessfulList: S.optional(SuccessfulBatchAssociationSummaryList),
    FailedList: S.optional(FailedBatchAssociationSummaryList),
  }),
).annotate({
  identifier: "DisassociateWorkspaceResponse",
}) as any as S.Schema<DisassociateWorkspaceResponse>;
export interface DismissUserContactRequest {
  UserId: string;
  InstanceId: string;
  ContactId: string;
}
export const DismissUserContactRequest = S.suspend(() =>
  S.Struct({
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/users/{InstanceId}/{UserId}/contact" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "DismissUserContactRequest",
}) as any as S.Schema<DismissUserContactRequest>;
export interface DismissUserContactResponse {}
export const DismissUserContactResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "DismissUserContactResponse",
}) as any as S.Schema<DismissUserContactResponse>;
export type AttributeNameList = string[];
export const AttributeNameList = S.Array(S.String);
export interface DataTableValueEvaluationSet {
  PrimaryValues?: PrimaryValue[];
  AttributeNames: string[];
}
export const DataTableValueEvaluationSet = S.suspend(() =>
  S.Struct({
    PrimaryValues: S.optional(PrimaryValuesSet),
    AttributeNames: AttributeNameList,
  }),
).annotate({
  identifier: "DataTableValueEvaluationSet",
}) as any as S.Schema<DataTableValueEvaluationSet>;
export type DataTableValueEvaluationSetList = DataTableValueEvaluationSet[];
export const DataTableValueEvaluationSetList = S.Array(
  DataTableValueEvaluationSet,
);
export interface EvaluateDataTableValuesRequest {
  InstanceId: string;
  DataTableId: string;
  Values: DataTableValueEvaluationSet[];
  TimeZone?: string;
  NextToken?: string;
  MaxResults?: number;
}
export const EvaluateDataTableValuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    Values: DataTableValueEvaluationSetList,
    TimeZone: S.optional(S.String),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/values/evaluate",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "EvaluateDataTableValuesRequest",
}) as any as S.Schema<EvaluateDataTableValuesRequest>;
export interface DataTableEvaluatedValue {
  RecordId: string;
  PrimaryValues: PrimaryValue[];
  AttributeName: string;
  ValueType: DataTableAttributeValueType;
  Found: boolean;
  Error: boolean;
  EvaluatedValue: string;
}
export const DataTableEvaluatedValue = S.suspend(() =>
  S.Struct({
    RecordId: S.String,
    PrimaryValues: PrimaryValuesSet,
    AttributeName: S.String,
    ValueType: DataTableAttributeValueType,
    Found: S.Boolean,
    Error: S.Boolean,
    EvaluatedValue: S.String,
  }),
).annotate({
  identifier: "DataTableEvaluatedValue",
}) as any as S.Schema<DataTableEvaluatedValue>;
export type DataTableEvaluatedValueList = DataTableEvaluatedValue[];
export const DataTableEvaluatedValueList = S.Array(DataTableEvaluatedValue);
export interface EvaluateDataTableValuesResponse {
  Values: DataTableEvaluatedValue[];
  NextToken?: string;
}
export const EvaluateDataTableValuesResponse = S.suspend(() =>
  S.Struct({
    Values: DataTableEvaluatedValueList,
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "EvaluateDataTableValuesResponse",
}) as any as S.Schema<EvaluateDataTableValuesResponse>;
export interface GetAttachedFileRequest {
  InstanceId: string;
  FileId: string;
  UrlExpiryInSeconds?: number;
  AssociatedResourceArn: string;
}
export const GetAttachedFileRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    FileId: S.String.pipe(T.HttpLabel("FileId")),
    UrlExpiryInSeconds: S.optional(S.Number).pipe(
      T.HttpQuery("urlExpiryInSeconds"),
    ),
    AssociatedResourceArn: S.String.pipe(T.HttpQuery("associatedResourceArn")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/attached-files/{InstanceId}/{FileId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetAttachedFileRequest",
}) as any as S.Schema<GetAttachedFileRequest>;
export interface DownloadUrlMetadata {
  Url?: string;
  UrlExpiry?: string;
}
export const DownloadUrlMetadata = S.suspend(() =>
  S.Struct({ Url: S.optional(S.String), UrlExpiry: S.optional(S.String) }),
).annotate({
  identifier: "DownloadUrlMetadata",
}) as any as S.Schema<DownloadUrlMetadata>;
export interface GetAttachedFileResponse {
  FileArn?: string;
  FileId?: string;
  CreationTime?: string;
  FileStatus?: FileStatusType;
  FileName?: string;
  FileSizeInBytes: number;
  AssociatedResourceArn?: string;
  FileUseCaseType?: FileUseCaseType;
  CreatedBy?: CreatedByInfo;
  DownloadUrlMetadata?: DownloadUrlMetadata;
  Tags?: { [key: string]: string | undefined };
}
export const GetAttachedFileResponse = S.suspend(() =>
  S.Struct({
    FileArn: S.optional(S.String),
    FileId: S.optional(S.String),
    CreationTime: S.optional(S.String),
    FileStatus: S.optional(FileStatusType),
    FileName: S.optional(S.String),
    FileSizeInBytes: S.Number,
    AssociatedResourceArn: S.optional(S.String),
    FileUseCaseType: S.optional(FileUseCaseType),
    CreatedBy: S.optional(CreatedByInfo),
    DownloadUrlMetadata: S.optional(DownloadUrlMetadata),
    Tags: S.optional(TagMap),
  }),
).annotate({
  identifier: "GetAttachedFileResponse",
}) as any as S.Schema<GetAttachedFileResponse>;
export interface GetContactAttributesRequest {
  InstanceId: string;
  InitialContactId: string;
}
export const GetContactAttributesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    InitialContactId: S.String.pipe(T.HttpLabel("InitialContactId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact/attributes/{InstanceId}/{InitialContactId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetContactAttributesRequest",
}) as any as S.Schema<GetContactAttributesRequest>;
export interface GetContactAttributesResponse {
  Attributes?: { [key: string]: string | undefined };
}
export const GetContactAttributesResponse = S.suspend(() =>
  S.Struct({ Attributes: S.optional(Attributes) }),
).annotate({
  identifier: "GetContactAttributesResponse",
}) as any as S.Schema<GetContactAttributesResponse>;
export type ContactMetricName =
  | "ESTIMATED_WAIT_TIME"
  | "POSITION_IN_QUEUE"
  | (string & {});
export const ContactMetricName = S.String;
export interface ContactMetricInfo {
  Name: ContactMetricName;
}
export const ContactMetricInfo = S.suspend(() =>
  S.Struct({ Name: ContactMetricName }),
).annotate({
  identifier: "ContactMetricInfo",
}) as any as S.Schema<ContactMetricInfo>;
export type ContactMetrics = ContactMetricInfo[];
export const ContactMetrics = S.Array(ContactMetricInfo);
export interface GetContactMetricsRequest {
  InstanceId: string;
  ContactId: string;
  Metrics: ContactMetricInfo[];
}
export const GetContactMetricsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    Metrics: ContactMetrics,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/metrics/contact" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetContactMetricsRequest",
}) as any as S.Schema<GetContactMetricsRequest>;
export type ContactMetricValue = { Number: number };
export const ContactMetricValue = S.Union([S.Struct({ Number: S.Number })]);
export interface ContactMetricResult {
  Name: ContactMetricName;
  Value: ContactMetricValue;
}
export const ContactMetricResult = S.suspend(() =>
  S.Struct({ Name: ContactMetricName, Value: ContactMetricValue }),
).annotate({
  identifier: "ContactMetricResult",
}) as any as S.Schema<ContactMetricResult>;
export type ContactMetricResults = ContactMetricResult[];
export const ContactMetricResults = S.Array(ContactMetricResult);
export interface GetContactMetricsResponse {
  MetricResults?: ContactMetricResult[];
  Id?: string;
  Arn?: string;
}
export const GetContactMetricsResponse = S.suspend(() =>
  S.Struct({
    MetricResults: S.optional(ContactMetricResults),
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
  }),
).annotate({
  identifier: "GetContactMetricsResponse",
}) as any as S.Schema<GetContactMetricsResponse>;
export type Queues = string[];
export const Queues = S.Array(S.String);
export type Channels = Channel[];
export const Channels = S.Array(Channel);
export type RoutingProfiles = string[];
export const RoutingProfiles = S.Array(S.String);
export type RoutingExpressions = string[];
export const RoutingExpressions = S.Array(S.String);
export type AgentStatuses = string[];
export const AgentStatuses = S.Array(S.String);
export type Subtypes = string[];
export const Subtypes = S.Array(S.String);
export type ValidationTestTypes = string[];
export const ValidationTestTypes = S.Array(S.String);
export interface Filters {
  Queues?: string[];
  Channels?: Channel[];
  RoutingProfiles?: string[];
  RoutingStepExpressions?: string[];
  AgentStatuses?: string[];
  Subtypes?: string[];
  ValidationTestTypes?: string[];
}
export const Filters = S.suspend(() =>
  S.Struct({
    Queues: S.optional(Queues),
    Channels: S.optional(Channels),
    RoutingProfiles: S.optional(RoutingProfiles),
    RoutingStepExpressions: S.optional(RoutingExpressions),
    AgentStatuses: S.optional(AgentStatuses),
    Subtypes: S.optional(Subtypes),
    ValidationTestTypes: S.optional(ValidationTestTypes),
  }),
).annotate({ identifier: "Filters" }) as any as S.Schema<Filters>;
export type Grouping =
  | "QUEUE"
  | "CHANNEL"
  | "ROUTING_PROFILE"
  | "ROUTING_STEP_EXPRESSION"
  | "AGENT_STATUS"
  | "SUBTYPE"
  | "VALIDATION_TEST_TYPE"
  | (string & {});
export const Grouping = S.String;
export type Groupings = Grouping[];
export const Groupings = S.Array(Grouping);
export type CurrentMetricName =
  | "AGENTS_ONLINE"
  | "AGENTS_AVAILABLE"
  | "AGENTS_ON_CALL"
  | "AGENTS_NON_PRODUCTIVE"
  | "AGENTS_AFTER_CONTACT_WORK"
  | "AGENTS_ERROR"
  | "AGENTS_STAFFED"
  | "CONTACTS_IN_QUEUE"
  | "OLDEST_CONTACT_AGE"
  | "CONTACTS_SCHEDULED"
  | "AGENTS_ON_CONTACT"
  | "SLOTS_ACTIVE"
  | "SLOTS_AVAILABLE"
  | "ESTIMATED_WAIT_TIME"
  | (string & {});
export const CurrentMetricName = S.String;
export type Unit = "SECONDS" | "COUNT" | "PERCENT" | (string & {});
export const Unit = S.String;
export interface CurrentMetric {
  Name?: CurrentMetricName;
  MetricId?: string;
  Unit?: Unit;
}
export const CurrentMetric = S.suspend(() =>
  S.Struct({
    Name: S.optional(CurrentMetricName),
    MetricId: S.optional(S.String),
    Unit: S.optional(Unit),
  }),
).annotate({ identifier: "CurrentMetric" }) as any as S.Schema<CurrentMetric>;
export type CurrentMetrics = CurrentMetric[];
export const CurrentMetrics = S.Array(CurrentMetric);
export type SortOrder = "ASCENDING" | "DESCENDING" | (string & {});
export const SortOrder = S.String;
export interface CurrentMetricSortCriteria {
  SortByMetric?: CurrentMetricName;
  SortOrder?: SortOrder;
}
export const CurrentMetricSortCriteria = S.suspend(() =>
  S.Struct({
    SortByMetric: S.optional(CurrentMetricName),
    SortOrder: S.optional(SortOrder),
  }),
).annotate({
  identifier: "CurrentMetricSortCriteria",
}) as any as S.Schema<CurrentMetricSortCriteria>;
export type CurrentMetricSortCriteriaMaxOne = CurrentMetricSortCriteria[];
export const CurrentMetricSortCriteriaMaxOne = S.Array(
  CurrentMetricSortCriteria,
);
export interface GetCurrentMetricDataRequest {
  InstanceId: string;
  Filters: Filters;
  Groupings?: Grouping[];
  CurrentMetrics: CurrentMetric[];
  NextToken?: string;
  MaxResults?: number;
  SortCriteria?: CurrentMetricSortCriteria[];
}
export const GetCurrentMetricDataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Filters: Filters,
    Groupings: S.optional(Groupings),
    CurrentMetrics: CurrentMetrics,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SortCriteria: S.optional(CurrentMetricSortCriteriaMaxOne),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/metrics/current/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetCurrentMetricDataRequest",
}) as any as S.Schema<GetCurrentMetricDataRequest>;
export interface QueueReference {
  Id?: string;
  Arn?: string;
}
export const QueueReference = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String), Arn: S.optional(S.String) }),
).annotate({ identifier: "QueueReference" }) as any as S.Schema<QueueReference>;
export interface RoutingProfileReference {
  Id?: string;
  Arn?: string;
}
export const RoutingProfileReference = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String), Arn: S.optional(S.String) }),
).annotate({
  identifier: "RoutingProfileReference",
}) as any as S.Schema<RoutingProfileReference>;
export interface AgentStatusIdentifier {
  Arn?: string;
  Id?: string;
}
export const AgentStatusIdentifier = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String), Id: S.optional(S.String) }),
).annotate({
  identifier: "AgentStatusIdentifier",
}) as any as S.Schema<AgentStatusIdentifier>;
export interface Dimensions {
  Queue?: QueueReference;
  Channel?: Channel;
  RoutingProfile?: RoutingProfileReference;
  RoutingStepExpression?: string;
  AgentStatus?: AgentStatusIdentifier;
  Subtype?: string;
  ValidationTestType?: string;
}
export const Dimensions = S.suspend(() =>
  S.Struct({
    Queue: S.optional(QueueReference),
    Channel: S.optional(Channel),
    RoutingProfile: S.optional(RoutingProfileReference),
    RoutingStepExpression: S.optional(S.String),
    AgentStatus: S.optional(AgentStatusIdentifier),
    Subtype: S.optional(S.String),
    ValidationTestType: S.optional(S.String),
  }),
).annotate({ identifier: "Dimensions" }) as any as S.Schema<Dimensions>;
export interface CurrentMetricData {
  Metric?: CurrentMetric;
  Value?: number;
}
export const CurrentMetricData = S.suspend(() =>
  S.Struct({ Metric: S.optional(CurrentMetric), Value: S.optional(S.Number) }),
).annotate({
  identifier: "CurrentMetricData",
}) as any as S.Schema<CurrentMetricData>;
export type CurrentMetricDataCollections = CurrentMetricData[];
export const CurrentMetricDataCollections = S.Array(CurrentMetricData);
export interface CurrentMetricResult {
  Dimensions?: Dimensions;
  Collections?: CurrentMetricData[];
}
export const CurrentMetricResult = S.suspend(() =>
  S.Struct({
    Dimensions: S.optional(Dimensions),
    Collections: S.optional(CurrentMetricDataCollections),
  }),
).annotate({
  identifier: "CurrentMetricResult",
}) as any as S.Schema<CurrentMetricResult>;
export type CurrentMetricResults = CurrentMetricResult[];
export const CurrentMetricResults = S.Array(CurrentMetricResult);
export interface GetCurrentMetricDataResponse {
  NextToken?: string;
  MetricResults?: CurrentMetricResult[];
  DataSnapshotTime?: Date;
  ApproximateTotalCount?: number;
}
export const GetCurrentMetricDataResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MetricResults: S.optional(CurrentMetricResults),
    DataSnapshotTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "GetCurrentMetricDataResponse",
}) as any as S.Schema<GetCurrentMetricDataResponse>;
export type ContactState =
  | "INCOMING"
  | "PENDING"
  | "CONNECTING"
  | "CONNECTED"
  | "CONNECTED_ONHOLD"
  | "MISSED"
  | "ERROR"
  | "ENDED"
  | "REJECTED"
  | (string & {});
export const ContactState = S.String;
export type ContactStates = ContactState[];
export const ContactStates = S.Array(ContactState);
export interface ContactFilter {
  ContactStates?: ContactState[];
}
export const ContactFilter = S.suspend(() =>
  S.Struct({ ContactStates: S.optional(ContactStates) }),
).annotate({ identifier: "ContactFilter" }) as any as S.Schema<ContactFilter>;
export type AgentsMinOneMaxHundred = string[];
export const AgentsMinOneMaxHundred = S.Array(S.String);
export type UserDataHierarchyGroups = string[];
export const UserDataHierarchyGroups = S.Array(S.String);
export interface UserDataFilters {
  Queues?: string[];
  ContactFilter?: ContactFilter;
  RoutingProfiles?: string[];
  Agents?: string[];
  UserHierarchyGroups?: string[];
}
export const UserDataFilters = S.suspend(() =>
  S.Struct({
    Queues: S.optional(Queues),
    ContactFilter: S.optional(ContactFilter),
    RoutingProfiles: S.optional(RoutingProfiles),
    Agents: S.optional(AgentsMinOneMaxHundred),
    UserHierarchyGroups: S.optional(UserDataHierarchyGroups),
  }),
).annotate({
  identifier: "UserDataFilters",
}) as any as S.Schema<UserDataFilters>;
export interface GetCurrentUserDataRequest {
  InstanceId: string;
  Filters: UserDataFilters;
  NextToken?: string;
  MaxResults?: number;
}
export const GetCurrentUserDataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Filters: UserDataFilters,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/metrics/userdata/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetCurrentUserDataRequest",
}) as any as S.Schema<GetCurrentUserDataRequest>;
export interface UserReference {
  Id?: string;
  Arn?: string;
}
export const UserReference = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String), Arn: S.optional(S.String) }),
).annotate({ identifier: "UserReference" }) as any as S.Schema<UserReference>;
export interface HierarchyGroupSummaryReference {
  Id?: string;
  Arn?: string;
}
export const HierarchyGroupSummaryReference = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String), Arn: S.optional(S.String) }),
).annotate({
  identifier: "HierarchyGroupSummaryReference",
}) as any as S.Schema<HierarchyGroupSummaryReference>;
export interface HierarchyPathReference {
  LevelOne?: HierarchyGroupSummaryReference;
  LevelTwo?: HierarchyGroupSummaryReference;
  LevelThree?: HierarchyGroupSummaryReference;
  LevelFour?: HierarchyGroupSummaryReference;
  LevelFive?: HierarchyGroupSummaryReference;
}
export const HierarchyPathReference = S.suspend(() =>
  S.Struct({
    LevelOne: S.optional(HierarchyGroupSummaryReference),
    LevelTwo: S.optional(HierarchyGroupSummaryReference),
    LevelThree: S.optional(HierarchyGroupSummaryReference),
    LevelFour: S.optional(HierarchyGroupSummaryReference),
    LevelFive: S.optional(HierarchyGroupSummaryReference),
  }),
).annotate({
  identifier: "HierarchyPathReference",
}) as any as S.Schema<HierarchyPathReference>;
export interface AgentStatusReference {
  StatusStartTimestamp?: Date;
  StatusArn?: string;
  StatusName?: string;
}
export const AgentStatusReference = S.suspend(() =>
  S.Struct({
    StatusStartTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    StatusArn: S.optional(S.String),
    StatusName: S.optional(S.String),
  }),
).annotate({
  identifier: "AgentStatusReference",
}) as any as S.Schema<AgentStatusReference>;
export type ChannelToCountMap = { [key in Channel]?: number };
export const ChannelToCountMap = S.Record(Channel, S.Number.pipe(S.optional));
export interface AgentContactReference {
  ContactId?: string;
  Channel?: Channel;
  InitiationMethod?: ContactInitiationMethod;
  AgentContactState?: ContactState;
  StateStartTimestamp?: Date;
  ConnectedToAgentTimestamp?: Date;
  Queue?: QueueReference;
}
export const AgentContactReference = S.suspend(() =>
  S.Struct({
    ContactId: S.optional(S.String),
    Channel: S.optional(Channel),
    InitiationMethod: S.optional(ContactInitiationMethod),
    AgentContactState: S.optional(ContactState),
    StateStartTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ConnectedToAgentTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    Queue: S.optional(QueueReference),
  }),
).annotate({
  identifier: "AgentContactReference",
}) as any as S.Schema<AgentContactReference>;
export type AgentContactReferenceList = AgentContactReference[];
export const AgentContactReferenceList = S.Array(AgentContactReference);
export interface UserData {
  User?: UserReference;
  RoutingProfile?: RoutingProfileReference;
  HierarchyPath?: HierarchyPathReference;
  Status?: AgentStatusReference;
  AvailableSlotsByChannel?: { [key: string]: number | undefined };
  MaxSlotsByChannel?: { [key: string]: number | undefined };
  ActiveSlotsByChannel?: { [key: string]: number | undefined };
  Contacts?: AgentContactReference[];
  NextStatus?: string;
}
export const UserData = S.suspend(() =>
  S.Struct({
    User: S.optional(UserReference),
    RoutingProfile: S.optional(RoutingProfileReference),
    HierarchyPath: S.optional(HierarchyPathReference),
    Status: S.optional(AgentStatusReference),
    AvailableSlotsByChannel: S.optional(ChannelToCountMap),
    MaxSlotsByChannel: S.optional(ChannelToCountMap),
    ActiveSlotsByChannel: S.optional(ChannelToCountMap),
    Contacts: S.optional(AgentContactReferenceList),
    NextStatus: S.optional(S.String),
  }),
).annotate({ identifier: "UserData" }) as any as S.Schema<UserData>;
export type UserDataList = UserData[];
export const UserDataList = S.Array(UserData);
export interface GetCurrentUserDataResponse {
  NextToken?: string;
  UserDataList?: UserData[];
  ApproximateTotalCount?: number;
}
export const GetCurrentUserDataResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    UserDataList: S.optional(UserDataList),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "GetCurrentUserDataResponse",
}) as any as S.Schema<GetCurrentUserDataResponse>;
export interface GetEffectiveHoursOfOperationsRequest {
  InstanceId: string;
  HoursOfOperationId: string;
  FromDate: string;
  ToDate: string;
}
export const GetEffectiveHoursOfOperationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
    FromDate: S.String.pipe(T.HttpQuery("fromDate")),
    ToDate: S.String.pipe(T.HttpQuery("toDate")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/effective-hours-of-operations/{InstanceId}/{HoursOfOperationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetEffectiveHoursOfOperationsRequest",
}) as any as S.Schema<GetEffectiveHoursOfOperationsRequest>;
export interface OperationalHour {
  Start?: OverrideTimeSlice;
  End?: OverrideTimeSlice;
}
export const OperationalHour = S.suspend(() =>
  S.Struct({
    Start: S.optional(OverrideTimeSlice),
    End: S.optional(OverrideTimeSlice),
  }),
).annotate({
  identifier: "OperationalHour",
}) as any as S.Schema<OperationalHour>;
export type OperationalHours = OperationalHour[];
export const OperationalHours = S.Array(OperationalHour);
export interface EffectiveHoursOfOperations {
  Date?: string;
  OperationalHours?: OperationalHour[];
}
export const EffectiveHoursOfOperations = S.suspend(() =>
  S.Struct({
    Date: S.optional(S.String),
    OperationalHours: S.optional(OperationalHours),
  }),
).annotate({
  identifier: "EffectiveHoursOfOperations",
}) as any as S.Schema<EffectiveHoursOfOperations>;
export type EffectiveHoursOfOperationList = EffectiveHoursOfOperations[];
export const EffectiveHoursOfOperationList = S.Array(
  EffectiveHoursOfOperations,
);
export type OperationalStatus = "OPEN" | "CLOSED" | (string & {});
export const OperationalStatus = S.String;
export interface OverrideHour {
  Start?: OverrideTimeSlice;
  End?: OverrideTimeSlice;
  OverrideName?: string;
  OperationalStatus?: OperationalStatus;
}
export const OverrideHour = S.suspend(() =>
  S.Struct({
    Start: S.optional(OverrideTimeSlice),
    End: S.optional(OverrideTimeSlice),
    OverrideName: S.optional(S.String),
    OperationalStatus: S.optional(OperationalStatus),
  }),
).annotate({ identifier: "OverrideHour" }) as any as S.Schema<OverrideHour>;
export type OverrideHours = OverrideHour[];
export const OverrideHours = S.Array(OverrideHour);
export interface EffectiveOverrideHours {
  Date?: string;
  OverrideHours?: OverrideHour[];
}
export const EffectiveOverrideHours = S.suspend(() =>
  S.Struct({
    Date: S.optional(S.String),
    OverrideHours: S.optional(OverrideHours),
  }),
).annotate({
  identifier: "EffectiveOverrideHours",
}) as any as S.Schema<EffectiveOverrideHours>;
export type EffectiveOverrideHoursList = EffectiveOverrideHours[];
export const EffectiveOverrideHoursList = S.Array(EffectiveOverrideHours);
export interface GetEffectiveHoursOfOperationsResponse {
  EffectiveHoursOfOperationList?: EffectiveHoursOfOperations[];
  EffectiveOverrideHoursList?: EffectiveOverrideHours[];
  TimeZone?: string;
}
export const GetEffectiveHoursOfOperationsResponse = S.suspend(() =>
  S.Struct({
    EffectiveHoursOfOperationList: S.optional(EffectiveHoursOfOperationList),
    EffectiveOverrideHoursList: S.optional(EffectiveOverrideHoursList),
    TimeZone: S.optional(S.String),
  }),
).annotate({
  identifier: "GetEffectiveHoursOfOperationsResponse",
}) as any as S.Schema<GetEffectiveHoursOfOperationsResponse>;
export interface GetFederationTokenRequest {
  InstanceId: string;
}
export const GetFederationTokenRequest = S.suspend(() =>
  S.Struct({ InstanceId: S.String.pipe(T.HttpLabel("InstanceId")) }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/user/federate/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetFederationTokenRequest",
}) as any as S.Schema<GetFederationTokenRequest>;
export interface Credentials {
  AccessToken?: string | redacted.Redacted<string>;
  AccessTokenExpiration?: Date;
  RefreshToken?: string | redacted.Redacted<string>;
  RefreshTokenExpiration?: Date;
}
export const Credentials = S.suspend(() =>
  S.Struct({
    AccessToken: S.optional(SensitiveString),
    AccessTokenExpiration: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    RefreshToken: S.optional(SensitiveString),
    RefreshTokenExpiration: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({ identifier: "Credentials" }) as any as S.Schema<Credentials>;
export interface GetFederationTokenResponse {
  Credentials?: Credentials;
  SignInUrl?: string;
  UserArn?: string;
  UserId?: string;
}
export const GetFederationTokenResponse = S.suspend(() =>
  S.Struct({
    Credentials: S.optional(Credentials),
    SignInUrl: S.optional(S.String),
    UserArn: S.optional(S.String),
    UserId: S.optional(S.String),
  }),
).annotate({
  identifier: "GetFederationTokenResponse",
}) as any as S.Schema<GetFederationTokenResponse>;
export interface GetFlowAssociationRequest {
  InstanceId: string;
  ResourceId: string;
  ResourceType: FlowAssociationResourceType;
}
export const GetFlowAssociationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ResourceId: S.String.pipe(T.HttpLabel("ResourceId")),
    ResourceType: FlowAssociationResourceType.pipe(T.HttpLabel("ResourceType")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/flow-associations/{InstanceId}/{ResourceId}/{ResourceType}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetFlowAssociationRequest",
}) as any as S.Schema<GetFlowAssociationRequest>;
export interface GetFlowAssociationResponse {
  ResourceId?: string;
  FlowId?: string;
  ResourceType?: FlowAssociationResourceType;
}
export const GetFlowAssociationResponse = S.suspend(() =>
  S.Struct({
    ResourceId: S.optional(S.String),
    FlowId: S.optional(S.String),
    ResourceType: S.optional(FlowAssociationResourceType),
  }),
).annotate({
  identifier: "GetFlowAssociationResponse",
}) as any as S.Schema<GetFlowAssociationResponse>;
export type HistoricalMetricName =
  | "CONTACTS_QUEUED"
  | "CONTACTS_HANDLED"
  | "CONTACTS_ABANDONED"
  | "CONTACTS_CONSULTED"
  | "CONTACTS_AGENT_HUNG_UP_FIRST"
  | "CONTACTS_HANDLED_INCOMING"
  | "CONTACTS_HANDLED_OUTBOUND"
  | "CONTACTS_HOLD_ABANDONS"
  | "CONTACTS_TRANSFERRED_IN"
  | "CONTACTS_TRANSFERRED_OUT"
  | "CONTACTS_TRANSFERRED_IN_FROM_QUEUE"
  | "CONTACTS_TRANSFERRED_OUT_FROM_QUEUE"
  | "CONTACTS_MISSED"
  | "CALLBACK_CONTACTS_HANDLED"
  | "API_CONTACTS_HANDLED"
  | "OCCUPANCY"
  | "HANDLE_TIME"
  | "AFTER_CONTACT_WORK_TIME"
  | "QUEUED_TIME"
  | "ABANDON_TIME"
  | "QUEUE_ANSWER_TIME"
  | "HOLD_TIME"
  | "INTERACTION_TIME"
  | "INTERACTION_AND_HOLD_TIME"
  | "SERVICE_LEVEL"
  | (string & {});
export const HistoricalMetricName = S.String;
export type Comparison = "LT" | (string & {});
export const Comparison = S.String;
export interface Threshold {
  Comparison?: Comparison;
  ThresholdValue?: number;
}
export const Threshold = S.suspend(() =>
  S.Struct({
    Comparison: S.optional(Comparison),
    ThresholdValue: S.optional(S.Number),
  }),
).annotate({ identifier: "Threshold" }) as any as S.Schema<Threshold>;
export type Statistic = "SUM" | "MAX" | "AVG" | (string & {});
export const Statistic = S.String;
export interface HistoricalMetric {
  Name?: HistoricalMetricName;
  Threshold?: Threshold;
  Statistic?: Statistic;
  Unit?: Unit;
}
export const HistoricalMetric = S.suspend(() =>
  S.Struct({
    Name: S.optional(HistoricalMetricName),
    Threshold: S.optional(Threshold),
    Statistic: S.optional(Statistic),
    Unit: S.optional(Unit),
  }),
).annotate({
  identifier: "HistoricalMetric",
}) as any as S.Schema<HistoricalMetric>;
export type HistoricalMetrics = HistoricalMetric[];
export const HistoricalMetrics = S.Array(HistoricalMetric);
export interface GetMetricDataRequest {
  InstanceId: string;
  StartTime: Date;
  EndTime: Date;
  Filters: Filters;
  Groupings?: Grouping[];
  HistoricalMetrics: HistoricalMetric[];
  NextToken?: string;
  MaxResults?: number;
}
export const GetMetricDataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    StartTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    EndTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    Filters: Filters,
    Groupings: S.optional(Groupings),
    HistoricalMetrics: HistoricalMetrics,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/metrics/historical/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetMetricDataRequest",
}) as any as S.Schema<GetMetricDataRequest>;
export interface HistoricalMetricData {
  Metric?: HistoricalMetric;
  Value?: number;
}
export const HistoricalMetricData = S.suspend(() =>
  S.Struct({
    Metric: S.optional(HistoricalMetric),
    Value: S.optional(S.Number),
  }),
).annotate({
  identifier: "HistoricalMetricData",
}) as any as S.Schema<HistoricalMetricData>;
export type HistoricalMetricDataCollections = HistoricalMetricData[];
export const HistoricalMetricDataCollections = S.Array(HistoricalMetricData);
export interface HistoricalMetricResult {
  Dimensions?: Dimensions;
  Collections?: HistoricalMetricData[];
}
export const HistoricalMetricResult = S.suspend(() =>
  S.Struct({
    Dimensions: S.optional(Dimensions),
    Collections: S.optional(HistoricalMetricDataCollections),
  }),
).annotate({
  identifier: "HistoricalMetricResult",
}) as any as S.Schema<HistoricalMetricResult>;
export type HistoricalMetricResults = HistoricalMetricResult[];
export const HistoricalMetricResults = S.Array(HistoricalMetricResult);
export interface GetMetricDataResponse {
  NextToken?: string;
  MetricResults?: HistoricalMetricResult[];
}
export const GetMetricDataResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MetricResults: S.optional(HistoricalMetricResults),
  }),
).annotate({
  identifier: "GetMetricDataResponse",
}) as any as S.Schema<GetMetricDataResponse>;
export type IntervalPeriod =
  | "FIFTEEN_MIN"
  | "THIRTY_MIN"
  | "HOUR"
  | "DAY"
  | "WEEK"
  | "TOTAL"
  | (string & {});
export const IntervalPeriod = S.String;
export interface IntervalDetails {
  TimeZone?: string;
  IntervalPeriod?: IntervalPeriod;
}
export const IntervalDetails = S.suspend(() =>
  S.Struct({
    TimeZone: S.optional(S.String),
    IntervalPeriod: S.optional(IntervalPeriod),
  }),
).annotate({
  identifier: "IntervalDetails",
}) as any as S.Schema<IntervalDetails>;
export type FilterValueList = string[];
export const FilterValueList = S.Array(S.String);
export type FilterV2StringConditionComparisonOperator =
  | "NOT_EXISTS"
  | (string & {});
export const FilterV2StringConditionComparisonOperator = S.String;
export interface FilterV2StringCondition {
  Comparison?: FilterV2StringConditionComparisonOperator;
}
export const FilterV2StringCondition = S.suspend(() =>
  S.Struct({
    Comparison: S.optional(FilterV2StringConditionComparisonOperator),
  }),
).annotate({
  identifier: "FilterV2StringCondition",
}) as any as S.Schema<FilterV2StringCondition>;
export interface FilterV2 {
  FilterKey?: string;
  FilterValues?: string[];
  StringCondition?: FilterV2StringCondition;
}
export const FilterV2 = S.suspend(() =>
  S.Struct({
    FilterKey: S.optional(S.String),
    FilterValues: S.optional(FilterValueList),
    StringCondition: S.optional(FilterV2StringCondition),
  }),
).annotate({ identifier: "FilterV2" }) as any as S.Schema<FilterV2>;
export type FiltersV2List = FilterV2[];
export const FiltersV2List = S.Array(FilterV2);
export type GroupingsV2 = string[];
export const GroupingsV2 = S.Array(S.String);
export interface ThresholdV2 {
  Comparison?: string;
  ThresholdValue?: number;
}
export const ThresholdV2 = S.suspend(() =>
  S.Struct({
    Comparison: S.optional(S.String),
    ThresholdValue: S.optional(S.Number),
  }),
).annotate({ identifier: "ThresholdV2" }) as any as S.Schema<ThresholdV2>;
export type ThresholdCollections = ThresholdV2[];
export const ThresholdCollections = S.Array(ThresholdV2);
export type MetricFilterValueList = string[];
export const MetricFilterValueList = S.Array(S.String);
export interface MetricFilterV2 {
  MetricFilterKey?: string;
  MetricFilterValues?: string[];
  Negate?: boolean;
}
export const MetricFilterV2 = S.suspend(() =>
  S.Struct({
    MetricFilterKey: S.optional(S.String),
    MetricFilterValues: S.optional(MetricFilterValueList),
    Negate: S.optional(S.Boolean),
  }),
).annotate({ identifier: "MetricFilterV2" }) as any as S.Schema<MetricFilterV2>;
export type MetricFiltersV2List = MetricFilterV2[];
export const MetricFiltersV2List = S.Array(MetricFilterV2);
export interface MetricV2 {
  Name?: string;
  Threshold?: ThresholdV2[];
  MetricId?: string;
  MetricFilters?: MetricFilterV2[];
}
export const MetricV2 = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Threshold: S.optional(ThresholdCollections),
    MetricId: S.optional(S.String),
    MetricFilters: S.optional(MetricFiltersV2List),
  }),
).annotate({ identifier: "MetricV2" }) as any as S.Schema<MetricV2>;
export type MetricsV2 = MetricV2[];
export const MetricsV2 = S.Array(MetricV2);
export interface GetMetricDataV2Request {
  ResourceArn: string;
  StartTime: Date;
  EndTime: Date;
  Interval?: IntervalDetails;
  Filters: FilterV2[];
  Groupings?: string[];
  Metrics: MetricV2[];
  NextToken?: string;
  MaxResults?: number;
}
export const GetMetricDataV2Request = S.suspend(() =>
  S.Struct({
    ResourceArn: S.String,
    StartTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    EndTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    Interval: S.optional(IntervalDetails),
    Filters: FiltersV2List,
    Groupings: S.optional(GroupingsV2),
    Metrics: MetricsV2,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/metrics/data" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetMetricDataV2Request",
}) as any as S.Schema<GetMetricDataV2Request>;
export type DimensionsV2Map = { [key: string]: string | undefined };
export const DimensionsV2Map = S.Record(S.String, S.String.pipe(S.optional));
export interface MetricInterval {
  Interval?: IntervalPeriod;
  StartTime?: Date;
  EndTime?: Date;
}
export const MetricInterval = S.suspend(() =>
  S.Struct({
    Interval: S.optional(IntervalPeriod),
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotate({ identifier: "MetricInterval" }) as any as S.Schema<MetricInterval>;
export interface MetricDataV2 {
  Metric?: MetricV2;
  Value?: number;
}
export const MetricDataV2 = S.suspend(() =>
  S.Struct({ Metric: S.optional(MetricV2), Value: S.optional(S.Number) }),
).annotate({ identifier: "MetricDataV2" }) as any as S.Schema<MetricDataV2>;
export type MetricDataCollectionsV2 = MetricDataV2[];
export const MetricDataCollectionsV2 = S.Array(MetricDataV2);
export interface MetricResultV2 {
  Dimensions?: { [key: string]: string | undefined };
  MetricInterval?: MetricInterval;
  Collections?: MetricDataV2[];
}
export const MetricResultV2 = S.suspend(() =>
  S.Struct({
    Dimensions: S.optional(DimensionsV2Map),
    MetricInterval: S.optional(MetricInterval),
    Collections: S.optional(MetricDataCollectionsV2),
  }),
).annotate({ identifier: "MetricResultV2" }) as any as S.Schema<MetricResultV2>;
export type MetricResultsV2 = MetricResultV2[];
export const MetricResultsV2 = S.Array(MetricResultV2);
export interface GetMetricDataV2Response {
  NextToken?: string;
  MetricResults?: MetricResultV2[];
}
export const GetMetricDataV2Response = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MetricResults: S.optional(MetricResultsV2),
  }),
).annotate({
  identifier: "GetMetricDataV2Response",
}) as any as S.Schema<GetMetricDataV2Response>;
export interface GetPromptFileRequest {
  InstanceId: string;
  PromptId: string;
}
export const GetPromptFileRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    PromptId: S.String.pipe(T.HttpLabel("PromptId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/prompts/{InstanceId}/{PromptId}/file" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetPromptFileRequest",
}) as any as S.Schema<GetPromptFileRequest>;
export interface GetPromptFileResponse {
  PromptPresignedUrl?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const GetPromptFileResponse = S.suspend(() =>
  S.Struct({
    PromptPresignedUrl: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "GetPromptFileResponse",
}) as any as S.Schema<GetPromptFileResponse>;
export interface GetTaskTemplateRequest {
  InstanceId: string;
  TaskTemplateId: string;
  SnapshotVersion?: string;
}
export const GetTaskTemplateRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    TaskTemplateId: S.String.pipe(T.HttpLabel("TaskTemplateId")),
    SnapshotVersion: S.optional(S.String).pipe(T.HttpQuery("snapshotVersion")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/instance/{InstanceId}/task/template/{TaskTemplateId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetTaskTemplateRequest",
}) as any as S.Schema<GetTaskTemplateRequest>;
export interface GetTaskTemplateResponse {
  InstanceId?: string;
  Id: string;
  Arn: string;
  Name: string;
  Description?: string;
  ContactFlowId?: string;
  SelfAssignFlowId?: string;
  Constraints?: TaskTemplateConstraints;
  Defaults?: TaskTemplateDefaults;
  Fields?: TaskTemplateField[];
  Status?: TaskTemplateStatus;
  LastModifiedTime?: Date;
  CreatedTime?: Date;
  Tags?: { [key: string]: string | undefined };
}
export const GetTaskTemplateResponse = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    Id: S.String,
    Arn: S.String,
    Name: S.String,
    Description: S.optional(S.String),
    ContactFlowId: S.optional(S.String),
    SelfAssignFlowId: S.optional(S.String),
    Constraints: S.optional(TaskTemplateConstraints),
    Defaults: S.optional(TaskTemplateDefaults),
    Fields: S.optional(TaskTemplateFields),
    Status: S.optional(TaskTemplateStatus),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Tags: S.optional(TagMap),
  }),
).annotate({
  identifier: "GetTaskTemplateResponse",
}) as any as S.Schema<GetTaskTemplateResponse>;
export interface GetTestCaseExecutionSummaryRequest {
  InstanceId: string;
  TestCaseId: string;
  TestCaseExecutionId: string;
}
export const GetTestCaseExecutionSummaryRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    TestCaseId: S.String.pipe(T.HttpLabel("TestCaseId")),
    TestCaseExecutionId: S.String.pipe(T.HttpLabel("TestCaseExecutionId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/test-cases/{InstanceId}/{TestCaseId}/{TestCaseExecutionId}/summary",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetTestCaseExecutionSummaryRequest",
}) as any as S.Schema<GetTestCaseExecutionSummaryRequest>;
export type TestCaseExecutionStatus =
  | "INITIATED"
  | "PASSED"
  | "FAILED"
  | "IN_PROGRESS"
  | "STOPPED"
  | (string & {});
export const TestCaseExecutionStatus = S.String;
export interface ObservationSummary {
  TotalObservations?: number;
  ObservationsPassed?: number;
  ObservationsFailed?: number;
}
export const ObservationSummary = S.suspend(() =>
  S.Struct({
    TotalObservations: S.optional(S.Number),
    ObservationsPassed: S.optional(S.Number),
    ObservationsFailed: S.optional(S.Number),
  }),
).annotate({
  identifier: "ObservationSummary",
}) as any as S.Schema<ObservationSummary>;
export interface GetTestCaseExecutionSummaryResponse {
  StartTime?: Date;
  EndTime?: Date;
  Status?: TestCaseExecutionStatus;
  ObservationSummary?: ObservationSummary;
}
export const GetTestCaseExecutionSummaryResponse = S.suspend(() =>
  S.Struct({
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Status: S.optional(TestCaseExecutionStatus),
    ObservationSummary: S.optional(ObservationSummary),
  }),
).annotate({
  identifier: "GetTestCaseExecutionSummaryResponse",
}) as any as S.Schema<GetTestCaseExecutionSummaryResponse>;
export interface GetTrafficDistributionRequest {
  Id: string;
}
export const GetTrafficDistributionRequest = S.suspend(() =>
  S.Struct({ Id: S.String.pipe(T.HttpLabel("Id")) }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/traffic-distribution/{Id}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "GetTrafficDistributionRequest",
}) as any as S.Schema<GetTrafficDistributionRequest>;
export interface Distribution {
  Region: string;
  Percentage: number;
}
export const Distribution = S.suspend(() =>
  S.Struct({ Region: S.String, Percentage: S.Number }),
).annotate({ identifier: "Distribution" }) as any as S.Schema<Distribution>;
export type DistributionList = Distribution[];
export const DistributionList = S.Array(Distribution);
export interface TelephonyConfig {
  Distributions: Distribution[];
}
export const TelephonyConfig = S.suspend(() =>
  S.Struct({ Distributions: DistributionList }),
).annotate({
  identifier: "TelephonyConfig",
}) as any as S.Schema<TelephonyConfig>;
export interface SignInDistribution {
  Region: string;
  Enabled: boolean;
}
export const SignInDistribution = S.suspend(() =>
  S.Struct({ Region: S.String, Enabled: S.Boolean }),
).annotate({
  identifier: "SignInDistribution",
}) as any as S.Schema<SignInDistribution>;
export type SignInDistributionList = SignInDistribution[];
export const SignInDistributionList = S.Array(SignInDistribution);
export interface SignInConfig {
  Distributions: SignInDistribution[];
}
export const SignInConfig = S.suspend(() =>
  S.Struct({ Distributions: SignInDistributionList }),
).annotate({ identifier: "SignInConfig" }) as any as S.Schema<SignInConfig>;
export interface AgentConfig {
  Distributions: Distribution[];
}
export const AgentConfig = S.suspend(() =>
  S.Struct({ Distributions: DistributionList }),
).annotate({ identifier: "AgentConfig" }) as any as S.Schema<AgentConfig>;
export interface GetTrafficDistributionResponse {
  TelephonyConfig?: TelephonyConfig;
  Id?: string;
  Arn?: string;
  SignInConfig?: SignInConfig;
  AgentConfig?: AgentConfig;
}
export const GetTrafficDistributionResponse = S.suspend(() =>
  S.Struct({
    TelephonyConfig: S.optional(TelephonyConfig),
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    SignInConfig: S.optional(SignInConfig),
    AgentConfig: S.optional(AgentConfig),
  }),
).annotate({
  identifier: "GetTrafficDistributionResponse",
}) as any as S.Schema<GetTrafficDistributionResponse>;
export interface ImportPhoneNumberRequest {
  InstanceId: string;
  SourcePhoneNumberArn: string;
  PhoneNumberDescription?: string;
  Tags?: { [key: string]: string | undefined };
  ClientToken?: string;
}
export const ImportPhoneNumberRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    SourcePhoneNumberArn: S.String,
    PhoneNumberDescription: S.optional(S.String),
    Tags: S.optional(TagMap),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/phone-number/import" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ImportPhoneNumberRequest",
}) as any as S.Schema<ImportPhoneNumberRequest>;
export interface ImportPhoneNumberResponse {
  PhoneNumberId?: string;
  PhoneNumberArn?: string;
}
export const ImportPhoneNumberResponse = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.optional(S.String),
    PhoneNumberArn: S.optional(S.String),
  }),
).annotate({
  identifier: "ImportPhoneNumberResponse",
}) as any as S.Schema<ImportPhoneNumberResponse>;
export interface ImportWorkspaceMediaRequest {
  InstanceId: string;
  WorkspaceId: string;
  MediaType: MediaType;
  MediaSource: string;
}
export const ImportWorkspaceMediaRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    MediaType: MediaType,
    MediaSource: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/media",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ImportWorkspaceMediaRequest",
}) as any as S.Schema<ImportWorkspaceMediaRequest>;
export interface ImportWorkspaceMediaResponse {}
export const ImportWorkspaceMediaResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "ImportWorkspaceMediaResponse",
}) as any as S.Schema<ImportWorkspaceMediaResponse>;
export type AgentStatusTypes = AgentStatusType[];
export const AgentStatusTypes = S.Array(AgentStatusType);
export interface ListAgentStatusRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  AgentStatusTypes?: AgentStatusType[];
}
export const ListAgentStatusRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    AgentStatusTypes: S.optional(AgentStatusTypes).pipe(
      T.HttpQuery("AgentStatusTypes"),
    ),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/agent-status/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListAgentStatusRequest",
}) as any as S.Schema<ListAgentStatusRequest>;
export interface AgentStatusSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  Type?: AgentStatusType;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const AgentStatusSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    Type: S.optional(AgentStatusType),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "AgentStatusSummary",
}) as any as S.Schema<AgentStatusSummary>;
export type AgentStatusSummaryList = AgentStatusSummary[];
export const AgentStatusSummaryList = S.Array(AgentStatusSummary);
export interface ListAgentStatusResponse {
  NextToken?: string;
  AgentStatusSummaryList?: AgentStatusSummary[];
}
export const ListAgentStatusResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    AgentStatusSummaryList: S.optional(AgentStatusSummaryList),
  }),
).annotate({
  identifier: "ListAgentStatusResponse",
}) as any as S.Schema<ListAgentStatusResponse>;
export interface ListAnalyticsDataAssociationsRequest {
  InstanceId: string;
  DataSetId?: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListAnalyticsDataAssociationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataSetId: S.optional(S.String).pipe(T.HttpQuery("DataSetId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/analytics-data/instance/{InstanceId}/association",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListAnalyticsDataAssociationsRequest",
}) as any as S.Schema<ListAnalyticsDataAssociationsRequest>;
export interface ListAnalyticsDataAssociationsResponse {
  Results?: AnalyticsDataAssociationResult[];
  NextToken?: string;
}
export const ListAnalyticsDataAssociationsResponse = S.suspend(() =>
  S.Struct({
    Results: S.optional(AnalyticsDataAssociationResults),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListAnalyticsDataAssociationsResponse",
}) as any as S.Schema<ListAnalyticsDataAssociationsResponse>;
export interface ListAnalyticsDataLakeDataSetsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListAnalyticsDataLakeDataSetsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/analytics-data/instance/{InstanceId}/datasets",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListAnalyticsDataLakeDataSetsRequest",
}) as any as S.Schema<ListAnalyticsDataLakeDataSetsRequest>;
export interface AnalyticsDataSetsResult {
  DataSetId?: string;
  DataSetName?: string;
}
export const AnalyticsDataSetsResult = S.suspend(() =>
  S.Struct({
    DataSetId: S.optional(S.String),
    DataSetName: S.optional(S.String),
  }),
).annotate({
  identifier: "AnalyticsDataSetsResult",
}) as any as S.Schema<AnalyticsDataSetsResult>;
export type AnalyticsDataSetsResults = AnalyticsDataSetsResult[];
export const AnalyticsDataSetsResults = S.Array(AnalyticsDataSetsResult);
export interface ListAnalyticsDataLakeDataSetsResponse {
  Results?: AnalyticsDataSetsResult[];
  NextToken?: string;
}
export const ListAnalyticsDataLakeDataSetsResponse = S.suspend(() =>
  S.Struct({
    Results: S.optional(AnalyticsDataSetsResults),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListAnalyticsDataLakeDataSetsResponse",
}) as any as S.Schema<ListAnalyticsDataLakeDataSetsResponse>;
export interface ListApprovedOriginsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListApprovedOriginsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance/{InstanceId}/approved-origins" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListApprovedOriginsRequest",
}) as any as S.Schema<ListApprovedOriginsRequest>;
export type OriginsList = string[];
export const OriginsList = S.Array(S.String);
export interface ListApprovedOriginsResponse {
  Origins?: string[];
  NextToken?: string;
}
export const ListApprovedOriginsResponse = S.suspend(() =>
  S.Struct({
    Origins: S.optional(OriginsList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListApprovedOriginsResponse",
}) as any as S.Schema<ListApprovedOriginsResponse>;
export interface ListAssociatedContactsRequest {
  InstanceId: string;
  ContactId: string;
  MaxResults?: number;
  NextToken?: string;
}
export const ListAssociatedContactsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String.pipe(T.HttpQuery("contactId")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/contact/associated/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListAssociatedContactsRequest",
}) as any as S.Schema<ListAssociatedContactsRequest>;
export interface AssociatedContactSummary {
  ContactId?: string;
  ContactArn?: string;
  InitiationTimestamp?: Date;
  DisconnectTimestamp?: Date;
  InitialContactId?: string;
  PreviousContactId?: string;
  RelatedContactId?: string;
  InitiationMethod?: ContactInitiationMethod;
  Channel?: Channel;
}
export const AssociatedContactSummary = S.suspend(() =>
  S.Struct({
    ContactId: S.optional(S.String),
    ContactArn: S.optional(S.String),
    InitiationTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    DisconnectTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    InitialContactId: S.optional(S.String),
    PreviousContactId: S.optional(S.String),
    RelatedContactId: S.optional(S.String),
    InitiationMethod: S.optional(ContactInitiationMethod),
    Channel: S.optional(Channel),
  }),
).annotate({
  identifier: "AssociatedContactSummary",
}) as any as S.Schema<AssociatedContactSummary>;
export type AssociatedContactSummaryList = AssociatedContactSummary[];
export const AssociatedContactSummaryList = S.Array(AssociatedContactSummary);
export interface ListAssociatedContactsResponse {
  ContactSummaryList?: AssociatedContactSummary[];
  NextToken?: string;
}
export const ListAssociatedContactsResponse = S.suspend(() =>
  S.Struct({
    ContactSummaryList: S.optional(AssociatedContactSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListAssociatedContactsResponse",
}) as any as S.Schema<ListAssociatedContactsResponse>;
export interface ListAuthenticationProfilesRequest {
  InstanceId: string;
  MaxResults?: number;
  NextToken?: string;
}
export const ListAuthenticationProfilesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/authentication-profiles-summary/{InstanceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListAuthenticationProfilesRequest",
}) as any as S.Schema<ListAuthenticationProfilesRequest>;
export interface AuthenticationProfileSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  IsDefault?: boolean;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const AuthenticationProfileSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    IsDefault: S.optional(S.Boolean),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "AuthenticationProfileSummary",
}) as any as S.Schema<AuthenticationProfileSummary>;
export type AuthenticationProfileSummaryList = AuthenticationProfileSummary[];
export const AuthenticationProfileSummaryList = S.Array(
  AuthenticationProfileSummary,
);
export interface ListAuthenticationProfilesResponse {
  AuthenticationProfileSummaryList?: AuthenticationProfileSummary[];
  NextToken?: string;
}
export const ListAuthenticationProfilesResponse = S.suspend(() =>
  S.Struct({
    AuthenticationProfileSummaryList: S.optional(
      AuthenticationProfileSummaryList,
    ),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListAuthenticationProfilesResponse",
}) as any as S.Schema<ListAuthenticationProfilesResponse>;
export type LexVersion = "V1" | "V2" | (string & {});
export const LexVersion = S.String;
export interface ListBotsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  LexVersion: LexVersion;
}
export const ListBotsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    LexVersion: LexVersion.pipe(T.HttpQuery("lexVersion")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance/{InstanceId}/bots" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListBotsRequest",
}) as any as S.Schema<ListBotsRequest>;
export interface LexBotConfig {
  LexBot?: LexBot;
  LexV2Bot?: LexV2Bot;
}
export const LexBotConfig = S.suspend(() =>
  S.Struct({ LexBot: S.optional(LexBot), LexV2Bot: S.optional(LexV2Bot) }),
).annotate({ identifier: "LexBotConfig" }) as any as S.Schema<LexBotConfig>;
export type LexBotConfigList = LexBotConfig[];
export const LexBotConfigList = S.Array(LexBotConfig);
export interface ListBotsResponse {
  LexBots?: LexBotConfig[];
  NextToken?: string;
}
export const ListBotsResponse = S.suspend(() =>
  S.Struct({
    LexBots: S.optional(LexBotConfigList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListBotsResponse",
}) as any as S.Schema<ListBotsResponse>;
export interface ListChildHoursOfOperationsRequest {
  InstanceId: string;
  HoursOfOperationId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListChildHoursOfOperationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}/hours",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListChildHoursOfOperationsRequest",
}) as any as S.Schema<ListChildHoursOfOperationsRequest>;
export type ChildHoursOfOperationsList = HoursOfOperationsIdentifier[];
export const ChildHoursOfOperationsList = S.Array(HoursOfOperationsIdentifier);
export interface ListChildHoursOfOperationsResponse {
  NextToken?: string;
  ChildHoursOfOperationsSummaryList?: HoursOfOperationsIdentifier[];
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const ListChildHoursOfOperationsResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    ChildHoursOfOperationsSummaryList: S.optional(ChildHoursOfOperationsList),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "ListChildHoursOfOperationsResponse",
}) as any as S.Schema<ListChildHoursOfOperationsResponse>;
export interface ListContactEvaluationsRequest {
  InstanceId: string;
  ContactId: string;
  NextToken?: string;
}
export const ListContactEvaluationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String.pipe(T.HttpQuery("contactId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/contact-evaluations/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListContactEvaluationsRequest",
}) as any as S.Schema<ListContactEvaluationsRequest>;
export interface EvaluationAcknowledgementSummary {
  AcknowledgedTime?: Date;
  AcknowledgedBy?: string;
  AcknowledgerComment?: string;
}
export const EvaluationAcknowledgementSummary = S.suspend(() =>
  S.Struct({
    AcknowledgedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    AcknowledgedBy: S.optional(S.String),
    AcknowledgerComment: S.optional(S.String),
  }),
).annotate({
  identifier: "EvaluationAcknowledgementSummary",
}) as any as S.Schema<EvaluationAcknowledgementSummary>;
export interface EvaluationSummary {
  EvaluationId: string;
  EvaluationArn: string;
  EvaluationFormTitle: string;
  EvaluationFormId: string;
  CalibrationSessionId?: string;
  Status: EvaluationStatus;
  AutoEvaluationEnabled?: boolean;
  AutoEvaluationStatus?: AutoEvaluationStatus;
  EvaluatorArn: string;
  Score?: EvaluationScore;
  Acknowledgement?: EvaluationAcknowledgementSummary;
  EvaluationType?: EvaluationType;
  CreatedTime: Date;
  LastModifiedTime: Date;
  ContactParticipant?: EvaluationContactParticipant;
}
export const EvaluationSummary = S.suspend(() =>
  S.Struct({
    EvaluationId: S.String,
    EvaluationArn: S.String,
    EvaluationFormTitle: S.String,
    EvaluationFormId: S.String,
    CalibrationSessionId: S.optional(S.String),
    Status: EvaluationStatus,
    AutoEvaluationEnabled: S.optional(S.Boolean),
    AutoEvaluationStatus: S.optional(AutoEvaluationStatus),
    EvaluatorArn: S.String,
    Score: S.optional(EvaluationScore),
    Acknowledgement: S.optional(EvaluationAcknowledgementSummary),
    EvaluationType: S.optional(EvaluationType),
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ContactParticipant: S.optional(EvaluationContactParticipant),
  }),
).annotate({
  identifier: "EvaluationSummary",
}) as any as S.Schema<EvaluationSummary>;
export type EvaluationSummaryList = EvaluationSummary[];
export const EvaluationSummaryList = S.Array(EvaluationSummary);
export interface ListContactEvaluationsResponse {
  EvaluationSummaryList: EvaluationSummary[];
  NextToken?: string;
}
export const ListContactEvaluationsResponse = S.suspend(() =>
  S.Struct({
    EvaluationSummaryList: EvaluationSummaryList,
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListContactEvaluationsResponse",
}) as any as S.Schema<ListContactEvaluationsResponse>;
export interface ListContactFlowModuleAliasesRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListContactFlowModuleAliasesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/aliases",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListContactFlowModuleAliasesRequest",
}) as any as S.Schema<ListContactFlowModuleAliasesRequest>;
export interface ContactFlowModuleAliasSummary {
  Arn?: string;
  AliasId?: string;
  Version?: number;
  AliasName?: string;
  AliasDescription?: string;
  LastModifiedTime?: Date;
}
export const ContactFlowModuleAliasSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    AliasId: S.optional(S.String),
    Version: S.optional(S.Number),
    AliasName: S.optional(S.String),
    AliasDescription: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "ContactFlowModuleAliasSummary",
}) as any as S.Schema<ContactFlowModuleAliasSummary>;
export type ContactFlowModuleAliasSummaryList = ContactFlowModuleAliasSummary[];
export const ContactFlowModuleAliasSummaryList = S.Array(
  ContactFlowModuleAliasSummary,
);
export interface ListContactFlowModuleAliasesResponse {
  ContactFlowModuleAliasSummaryList?: ContactFlowModuleAliasSummary[];
  NextToken?: string;
}
export const ListContactFlowModuleAliasesResponse = S.suspend(() =>
  S.Struct({
    ContactFlowModuleAliasSummaryList: S.optional(
      ContactFlowModuleAliasSummaryList,
    ),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListContactFlowModuleAliasesResponse",
}) as any as S.Schema<ListContactFlowModuleAliasesResponse>;
export interface ListContactFlowModulesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  ContactFlowModuleState?: ContactFlowModuleState;
}
export const ListContactFlowModulesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    ContactFlowModuleState: S.optional(ContactFlowModuleState).pipe(
      T.HttpQuery("state"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact-flow-modules-summary/{InstanceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListContactFlowModulesRequest",
}) as any as S.Schema<ListContactFlowModulesRequest>;
export interface ContactFlowModuleSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  State?: ContactFlowModuleState;
}
export const ContactFlowModuleSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    State: S.optional(ContactFlowModuleState),
  }),
).annotate({
  identifier: "ContactFlowModuleSummary",
}) as any as S.Schema<ContactFlowModuleSummary>;
export type ContactFlowModulesSummaryList = ContactFlowModuleSummary[];
export const ContactFlowModulesSummaryList = S.Array(ContactFlowModuleSummary);
export interface ListContactFlowModulesResponse {
  ContactFlowModulesSummaryList?: ContactFlowModuleSummary[];
  NextToken?: string;
}
export const ListContactFlowModulesResponse = S.suspend(() =>
  S.Struct({
    ContactFlowModulesSummaryList: S.optional(ContactFlowModulesSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListContactFlowModulesResponse",
}) as any as S.Schema<ListContactFlowModulesResponse>;
export interface ListContactFlowModuleVersionsRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListContactFlowModuleVersionsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/versions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListContactFlowModuleVersionsRequest",
}) as any as S.Schema<ListContactFlowModuleVersionsRequest>;
export interface ContactFlowModuleVersionSummary {
  Arn?: string;
  VersionDescription?: string;
  Version?: number;
}
export const ContactFlowModuleVersionSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    VersionDescription: S.optional(S.String),
    Version: S.optional(S.Number),
  }),
).annotate({
  identifier: "ContactFlowModuleVersionSummary",
}) as any as S.Schema<ContactFlowModuleVersionSummary>;
export type ContactFlowModuleVersionSummaryList =
  ContactFlowModuleVersionSummary[];
export const ContactFlowModuleVersionSummaryList = S.Array(
  ContactFlowModuleVersionSummary,
);
export interface ListContactFlowModuleVersionsResponse {
  ContactFlowModuleVersionSummaryList?: ContactFlowModuleVersionSummary[];
  NextToken?: string;
}
export const ListContactFlowModuleVersionsResponse = S.suspend(() =>
  S.Struct({
    ContactFlowModuleVersionSummaryList: S.optional(
      ContactFlowModuleVersionSummaryList,
    ),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListContactFlowModuleVersionsResponse",
}) as any as S.Schema<ListContactFlowModuleVersionsResponse>;
export type ContactFlowTypes = ContactFlowType[];
export const ContactFlowTypes = S.Array(ContactFlowType);
export interface ListContactFlowsRequest {
  InstanceId: string;
  ContactFlowTypes?: ContactFlowType[];
  NextToken?: string;
  MaxResults?: number;
}
export const ListContactFlowsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowTypes: S.optional(ContactFlowTypes).pipe(
      T.HttpQuery("contactFlowTypes"),
    ),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/contact-flows-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListContactFlowsRequest",
}) as any as S.Schema<ListContactFlowsRequest>;
export interface ContactFlowSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  ContactFlowType?: ContactFlowType;
  ContactFlowState?: ContactFlowState;
  ContactFlowStatus?: ContactFlowStatus;
}
export const ContactFlowSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    ContactFlowType: S.optional(ContactFlowType),
    ContactFlowState: S.optional(ContactFlowState),
    ContactFlowStatus: S.optional(ContactFlowStatus),
  }),
).annotate({
  identifier: "ContactFlowSummary",
}) as any as S.Schema<ContactFlowSummary>;
export type ContactFlowSummaryList = ContactFlowSummary[];
export const ContactFlowSummaryList = S.Array(ContactFlowSummary);
export interface ListContactFlowsResponse {
  ContactFlowSummaryList?: ContactFlowSummary[];
  NextToken?: string;
}
export const ListContactFlowsResponse = S.suspend(() =>
  S.Struct({
    ContactFlowSummaryList: S.optional(ContactFlowSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListContactFlowsResponse",
}) as any as S.Schema<ListContactFlowsResponse>;
export interface ListContactFlowVersionsRequest {
  InstanceId: string;
  ContactFlowId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListContactFlowVersionsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowId: S.String.pipe(T.HttpLabel("ContactFlowId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact-flows/{InstanceId}/{ContactFlowId}/versions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListContactFlowVersionsRequest",
}) as any as S.Schema<ListContactFlowVersionsRequest>;
export interface ContactFlowVersionSummary {
  Arn?: string;
  VersionDescription?: string;
  Version?: number;
}
export const ContactFlowVersionSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    VersionDescription: S.optional(S.String),
    Version: S.optional(S.Number),
  }),
).annotate({
  identifier: "ContactFlowVersionSummary",
}) as any as S.Schema<ContactFlowVersionSummary>;
export type ContactFlowVersionSummaryList = ContactFlowVersionSummary[];
export const ContactFlowVersionSummaryList = S.Array(ContactFlowVersionSummary);
export interface ListContactFlowVersionsResponse {
  ContactFlowVersionSummaryList?: ContactFlowVersionSummary[];
  NextToken?: string;
}
export const ListContactFlowVersionsResponse = S.suspend(() =>
  S.Struct({
    ContactFlowVersionSummaryList: S.optional(ContactFlowVersionSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListContactFlowVersionsResponse",
}) as any as S.Schema<ListContactFlowVersionsResponse>;
export type ReferenceTypes = ReferenceType[];
export const ReferenceTypes = S.Array(ReferenceType);
export interface ListContactReferencesRequest {
  InstanceId: string;
  ContactId: string;
  ReferenceTypes: ReferenceType[];
  NextToken?: string;
}
export const ListContactReferencesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String.pipe(T.HttpLabel("ContactId")),
    ReferenceTypes: ReferenceTypes.pipe(T.HttpQuery("referenceTypes")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact/references/{InstanceId}/{ContactId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListContactReferencesRequest",
}) as any as S.Schema<ListContactReferencesRequest>;
export interface UrlReference {
  Name?: string;
  Value?: string;
}
export const UrlReference = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Value: S.optional(S.String) }),
).annotate({ identifier: "UrlReference" }) as any as S.Schema<UrlReference>;
export interface AttachmentReference {
  Name?: string;
  Value?: string;
  Status?: ReferenceStatus;
  Arn?: string;
}
export const AttachmentReference = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Value: S.optional(S.String),
    Status: S.optional(ReferenceStatus),
    Arn: S.optional(S.String),
  }),
).annotate({
  identifier: "AttachmentReference",
}) as any as S.Schema<AttachmentReference>;
export interface EmailMessageReference {
  Name?: string;
  Arn?: string;
}
export const EmailMessageReference = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Arn: S.optional(S.String) }),
).annotate({
  identifier: "EmailMessageReference",
}) as any as S.Schema<EmailMessageReference>;
export interface StringReference {
  Name?: string;
  Value?: string;
}
export const StringReference = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Value: S.optional(S.String) }),
).annotate({
  identifier: "StringReference",
}) as any as S.Schema<StringReference>;
export interface NumberReference {
  Name?: string;
  Value?: string;
}
export const NumberReference = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Value: S.optional(S.String) }),
).annotate({
  identifier: "NumberReference",
}) as any as S.Schema<NumberReference>;
export interface DateReference {
  Name?: string;
  Value?: string;
}
export const DateReference = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Value: S.optional(S.String) }),
).annotate({ identifier: "DateReference" }) as any as S.Schema<DateReference>;
export interface EmailReference {
  Name?: string;
  Value?: string;
}
export const EmailReference = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Value: S.optional(S.String) }),
).annotate({ identifier: "EmailReference" }) as any as S.Schema<EmailReference>;
export type ReferenceSummary =
  | {
      Url: UrlReference;
      Attachment?: never;
      EmailMessage?: never;
      EmailMessagePlainText?: never;
      String?: never;
      Number?: never;
      Date?: never;
      Email?: never;
    }
  | {
      Url?: never;
      Attachment: AttachmentReference;
      EmailMessage?: never;
      EmailMessagePlainText?: never;
      String?: never;
      Number?: never;
      Date?: never;
      Email?: never;
    }
  | {
      Url?: never;
      Attachment?: never;
      EmailMessage: EmailMessageReference;
      EmailMessagePlainText?: never;
      String?: never;
      Number?: never;
      Date?: never;
      Email?: never;
    }
  | {
      Url?: never;
      Attachment?: never;
      EmailMessage?: never;
      EmailMessagePlainText: EmailMessageReference;
      String?: never;
      Number?: never;
      Date?: never;
      Email?: never;
    }
  | {
      Url?: never;
      Attachment?: never;
      EmailMessage?: never;
      EmailMessagePlainText?: never;
      String: StringReference;
      Number?: never;
      Date?: never;
      Email?: never;
    }
  | {
      Url?: never;
      Attachment?: never;
      EmailMessage?: never;
      EmailMessagePlainText?: never;
      String?: never;
      Number: NumberReference;
      Date?: never;
      Email?: never;
    }
  | {
      Url?: never;
      Attachment?: never;
      EmailMessage?: never;
      EmailMessagePlainText?: never;
      String?: never;
      Number?: never;
      Date: DateReference;
      Email?: never;
    }
  | {
      Url?: never;
      Attachment?: never;
      EmailMessage?: never;
      EmailMessagePlainText?: never;
      String?: never;
      Number?: never;
      Date?: never;
      Email: EmailReference;
    };
export const ReferenceSummary = S.Union([
  S.Struct({ Url: UrlReference }),
  S.Struct({ Attachment: AttachmentReference }),
  S.Struct({ EmailMessage: EmailMessageReference }),
  S.Struct({ EmailMessagePlainText: EmailMessageReference }),
  S.Struct({ String: StringReference }),
  S.Struct({ Number: NumberReference }),
  S.Struct({ Date: DateReference }),
  S.Struct({ Email: EmailReference }),
]);
export type ReferenceSummaryList = ReferenceSummary[];
export const ReferenceSummaryList = S.Array(ReferenceSummary);
export interface ListContactReferencesResponse {
  ReferenceSummaryList?: ReferenceSummary[];
  NextToken?: string;
}
export const ListContactReferencesResponse = S.suspend(() =>
  S.Struct({
    ReferenceSummaryList: S.optional(ReferenceSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListContactReferencesResponse",
}) as any as S.Schema<ListContactReferencesResponse>;
export type AttributeIds = string[];
export const AttributeIds = S.Array(S.String);
export interface ListDataTableAttributesRequest {
  InstanceId: string;
  DataTableId: string;
  AttributeIds?: string[];
  NextToken?: string;
  MaxResults?: number;
}
export const ListDataTableAttributesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    AttributeIds: S.optional(AttributeIds),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/attributes",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListDataTableAttributesRequest",
}) as any as S.Schema<ListDataTableAttributesRequest>;
export type AttributeList = DataTableAttribute[];
export const AttributeList = S.Array(DataTableAttribute);
export interface ListDataTableAttributesResponse {
  NextToken?: string;
  Attributes: DataTableAttribute[];
}
export const ListDataTableAttributesResponse = S.suspend(() =>
  S.Struct({ NextToken: S.optional(S.String), Attributes: AttributeList }),
).annotate({
  identifier: "ListDataTableAttributesResponse",
}) as any as S.Schema<ListDataTableAttributesResponse>;
export type RecordIds = string[];
export const RecordIds = S.Array(S.String);
export type ValueList = string[];
export const ValueList = S.Array(S.String);
export interface PrimaryAttributeValueFilter {
  AttributeName: string;
  Values: string[];
}
export const PrimaryAttributeValueFilter = S.suspend(() =>
  S.Struct({ AttributeName: S.String, Values: ValueList }),
).annotate({
  identifier: "PrimaryAttributeValueFilter",
}) as any as S.Schema<PrimaryAttributeValueFilter>;
export type PrimaryAttributeValueFilters = PrimaryAttributeValueFilter[];
export const PrimaryAttributeValueFilters = S.Array(
  PrimaryAttributeValueFilter,
);
export interface ListDataTablePrimaryValuesRequest {
  InstanceId: string;
  DataTableId: string;
  RecordIds?: string[];
  PrimaryAttributeValues?: PrimaryAttributeValueFilter[];
  NextToken?: string;
  MaxResults?: number;
}
export const ListDataTablePrimaryValuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    RecordIds: S.optional(RecordIds),
    PrimaryAttributeValues: S.optional(PrimaryAttributeValueFilters),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/values/list-primary",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListDataTablePrimaryValuesRequest",
}) as any as S.Schema<ListDataTablePrimaryValuesRequest>;
export interface RecordPrimaryValue {
  RecordId?: string;
  PrimaryValues?: PrimaryValueResponse[];
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const RecordPrimaryValue = S.suspend(() =>
  S.Struct({
    RecordId: S.optional(S.String),
    PrimaryValues: S.optional(PrimaryValuesResponseSet),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "RecordPrimaryValue",
}) as any as S.Schema<RecordPrimaryValue>;
export type PrimaryValuesList = RecordPrimaryValue[];
export const PrimaryValuesList = S.Array(RecordPrimaryValue);
export interface ListDataTablePrimaryValuesResponse {
  NextToken?: string;
  PrimaryValuesList: RecordPrimaryValue[];
}
export const ListDataTablePrimaryValuesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    PrimaryValuesList: PrimaryValuesList,
  }),
).annotate({
  identifier: "ListDataTablePrimaryValuesResponse",
}) as any as S.Schema<ListDataTablePrimaryValuesResponse>;
export interface ListDataTablesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListDataTablesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/data-tables/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListDataTablesRequest",
}) as any as S.Schema<ListDataTablesRequest>;
export interface DataTableSummary {
  Name?: string;
  Id?: string;
  Arn?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const DataTableSummary = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "DataTableSummary",
}) as any as S.Schema<DataTableSummary>;
export type DataTableSummaryList = DataTableSummary[];
export const DataTableSummaryList = S.Array(DataTableSummary);
export interface ListDataTablesResponse {
  NextToken?: string;
  DataTableSummaryList: DataTableSummary[];
}
export const ListDataTablesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    DataTableSummaryList: DataTableSummaryList,
  }),
).annotate({
  identifier: "ListDataTablesResponse",
}) as any as S.Schema<ListDataTablesResponse>;
export interface ListDataTableValuesRequest {
  InstanceId: string;
  DataTableId: string;
  RecordIds?: string[];
  PrimaryAttributeValues?: PrimaryAttributeValueFilter[];
  NextToken?: string;
  MaxResults?: number;
}
export const ListDataTableValuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    RecordIds: S.optional(RecordIds),
    PrimaryAttributeValues: S.optional(PrimaryAttributeValueFilters),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/values/list",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListDataTableValuesRequest",
}) as any as S.Schema<ListDataTableValuesRequest>;
export interface DataTableValueSummary {
  RecordId?: string;
  AttributeId?: string;
  PrimaryValues: PrimaryValueResponse[];
  AttributeName: string;
  ValueType: DataTableAttributeValueType;
  Value: string;
  LockVersion?: DataTableLockVersion;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const DataTableValueSummary = S.suspend(() =>
  S.Struct({
    RecordId: S.optional(S.String),
    AttributeId: S.optional(S.String),
    PrimaryValues: PrimaryValuesResponseSet,
    AttributeName: S.String,
    ValueType: DataTableAttributeValueType,
    Value: S.String,
    LockVersion: S.optional(DataTableLockVersion),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "DataTableValueSummary",
}) as any as S.Schema<DataTableValueSummary>;
export type DataTableValueSummaryList = DataTableValueSummary[];
export const DataTableValueSummaryList = S.Array(DataTableValueSummary);
export interface ListDataTableValuesResponse {
  NextToken?: string;
  Values: DataTableValueSummary[];
}
export const ListDataTableValuesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    Values: DataTableValueSummaryList,
  }),
).annotate({
  identifier: "ListDataTableValuesResponse",
}) as any as S.Schema<ListDataTableValuesResponse>;
export interface ListDefaultVocabulariesRequest {
  InstanceId: string;
  LanguageCode?: VocabularyLanguageCode;
  MaxResults?: number;
  NextToken?: string;
}
export const ListDefaultVocabulariesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    LanguageCode: S.optional(VocabularyLanguageCode),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/default-vocabulary-summary/{InstanceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListDefaultVocabulariesRequest",
}) as any as S.Schema<ListDefaultVocabulariesRequest>;
export interface DefaultVocabulary {
  InstanceId: string;
  LanguageCode: VocabularyLanguageCode;
  VocabularyId: string;
  VocabularyName: string;
}
export const DefaultVocabulary = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    LanguageCode: VocabularyLanguageCode,
    VocabularyId: S.String,
    VocabularyName: S.String,
  }),
).annotate({
  identifier: "DefaultVocabulary",
}) as any as S.Schema<DefaultVocabulary>;
export type DefaultVocabularyList = DefaultVocabulary[];
export const DefaultVocabularyList = S.Array(DefaultVocabulary);
export interface ListDefaultVocabulariesResponse {
  DefaultVocabularyList: DefaultVocabulary[];
  NextToken?: string;
}
export const ListDefaultVocabulariesResponse = S.suspend(() =>
  S.Struct({
    DefaultVocabularyList: DefaultVocabularyList,
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListDefaultVocabulariesResponse",
}) as any as S.Schema<ListDefaultVocabulariesResponse>;
export interface ListEntitySecurityProfilesRequest {
  InstanceId: string;
  EntityType: EntityType;
  EntityArn: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListEntitySecurityProfilesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EntityType: EntityType,
    EntityArn: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/entity-security-profiles-summary/{InstanceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListEntitySecurityProfilesRequest",
}) as any as S.Schema<ListEntitySecurityProfilesRequest>;
export type SecurityProfiles100 = SecurityProfileItem[];
export const SecurityProfiles100 = S.Array(SecurityProfileItem);
export interface ListEntitySecurityProfilesResponse {
  SecurityProfiles?: SecurityProfileItem[];
  NextToken?: string;
}
export const ListEntitySecurityProfilesResponse = S.suspend(() =>
  S.Struct({
    SecurityProfiles: S.optional(SecurityProfiles100),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListEntitySecurityProfilesResponse",
}) as any as S.Schema<ListEntitySecurityProfilesResponse>;
export interface ListEvaluationFormsRequest {
  InstanceId: string;
  MaxResults?: number;
  NextToken?: string;
}
export const ListEvaluationFormsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/evaluation-forms/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListEvaluationFormsRequest",
}) as any as S.Schema<ListEvaluationFormsRequest>;
export interface EvaluationFormSummary {
  EvaluationFormId: string;
  EvaluationFormArn: string;
  Title: string;
  CreatedTime: Date;
  CreatedBy: string;
  LastModifiedTime: Date;
  LastModifiedBy: string;
  LastActivatedTime?: Date;
  LastActivatedBy?: string;
  LatestVersion: number;
  ActiveVersion?: number;
}
export const EvaluationFormSummary = S.suspend(() =>
  S.Struct({
    EvaluationFormId: S.String,
    EvaluationFormArn: S.String,
    Title: S.String,
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    CreatedBy: S.String,
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastModifiedBy: S.String,
    LastActivatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastActivatedBy: S.optional(S.String),
    LatestVersion: S.Number,
    ActiveVersion: S.optional(S.Number),
  }),
).annotate({
  identifier: "EvaluationFormSummary",
}) as any as S.Schema<EvaluationFormSummary>;
export type EvaluationFormSummaryList = EvaluationFormSummary[];
export const EvaluationFormSummaryList = S.Array(EvaluationFormSummary);
export interface ListEvaluationFormsResponse {
  EvaluationFormSummaryList: EvaluationFormSummary[];
  NextToken?: string;
}
export const ListEvaluationFormsResponse = S.suspend(() =>
  S.Struct({
    EvaluationFormSummaryList: EvaluationFormSummaryList,
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListEvaluationFormsResponse",
}) as any as S.Schema<ListEvaluationFormsResponse>;
export interface ListEvaluationFormVersionsRequest {
  InstanceId: string;
  EvaluationFormId: string;
  MaxResults?: number;
  NextToken?: string;
}
export const ListEvaluationFormVersionsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationFormId: S.String.pipe(T.HttpLabel("EvaluationFormId")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/evaluation-forms/{InstanceId}/{EvaluationFormId}/versions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListEvaluationFormVersionsRequest",
}) as any as S.Schema<ListEvaluationFormVersionsRequest>;
export interface EvaluationFormVersionSummary {
  EvaluationFormArn: string;
  EvaluationFormId: string;
  EvaluationFormVersion: number;
  Locked: boolean;
  Status: EvaluationFormVersionStatus;
  CreatedTime: Date;
  CreatedBy: string;
  LastModifiedTime: Date;
  LastModifiedBy: string;
}
export const EvaluationFormVersionSummary = S.suspend(() =>
  S.Struct({
    EvaluationFormArn: S.String,
    EvaluationFormId: S.String,
    EvaluationFormVersion: S.Number,
    Locked: S.Boolean,
    Status: EvaluationFormVersionStatus,
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    CreatedBy: S.String,
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastModifiedBy: S.String,
  }),
).annotate({
  identifier: "EvaluationFormVersionSummary",
}) as any as S.Schema<EvaluationFormVersionSummary>;
export type EvaluationFormVersionSummaryList = EvaluationFormVersionSummary[];
export const EvaluationFormVersionSummaryList = S.Array(
  EvaluationFormVersionSummary,
);
export interface ListEvaluationFormVersionsResponse {
  EvaluationFormVersionSummaryList: EvaluationFormVersionSummary[];
  NextToken?: string;
}
export const ListEvaluationFormVersionsResponse = S.suspend(() =>
  S.Struct({
    EvaluationFormVersionSummaryList: EvaluationFormVersionSummaryList,
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListEvaluationFormVersionsResponse",
}) as any as S.Schema<ListEvaluationFormVersionsResponse>;
export interface ListFlowAssociationsRequest {
  InstanceId: string;
  ResourceType?: ListFlowAssociationResourceType;
  NextToken?: string;
  MaxResults?: number;
}
export const ListFlowAssociationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ResourceType: S.optional(ListFlowAssociationResourceType).pipe(
      T.HttpQuery("ResourceType"),
    ),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/flow-associations-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListFlowAssociationsRequest",
}) as any as S.Schema<ListFlowAssociationsRequest>;
export interface ListFlowAssociationsResponse {
  FlowAssociationSummaryList?: FlowAssociationSummary[];
  NextToken?: string;
}
export const ListFlowAssociationsResponse = S.suspend(() =>
  S.Struct({
    FlowAssociationSummaryList: S.optional(FlowAssociationSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListFlowAssociationsResponse",
}) as any as S.Schema<ListFlowAssociationsResponse>;
export interface ListHoursOfOperationOverridesRequest {
  InstanceId: string;
  HoursOfOperationId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListHoursOfOperationOverridesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}/overrides",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListHoursOfOperationOverridesRequest",
}) as any as S.Schema<ListHoursOfOperationOverridesRequest>;
export type HoursOfOperationOverrideList = HoursOfOperationOverride[];
export const HoursOfOperationOverrideList = S.Array(HoursOfOperationOverride);
export interface ListHoursOfOperationOverridesResponse {
  NextToken?: string;
  HoursOfOperationOverrideList?: HoursOfOperationOverride[];
  LastModifiedRegion?: string;
  LastModifiedTime?: Date;
}
export const ListHoursOfOperationOverridesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    HoursOfOperationOverrideList: S.optional(HoursOfOperationOverrideList),
    LastModifiedRegion: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "ListHoursOfOperationOverridesResponse",
}) as any as S.Schema<ListHoursOfOperationOverridesResponse>;
export interface ListHoursOfOperationsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListHoursOfOperationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/hours-of-operations-summary/{InstanceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListHoursOfOperationsRequest",
}) as any as S.Schema<ListHoursOfOperationsRequest>;
export interface HoursOfOperationSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const HoursOfOperationSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "HoursOfOperationSummary",
}) as any as S.Schema<HoursOfOperationSummary>;
export type HoursOfOperationSummaryList = HoursOfOperationSummary[];
export const HoursOfOperationSummaryList = S.Array(HoursOfOperationSummary);
export interface ListHoursOfOperationsResponse {
  HoursOfOperationSummaryList?: HoursOfOperationSummary[];
  NextToken?: string;
}
export const ListHoursOfOperationsResponse = S.suspend(() =>
  S.Struct({
    HoursOfOperationSummaryList: S.optional(HoursOfOperationSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListHoursOfOperationsResponse",
}) as any as S.Schema<ListHoursOfOperationsResponse>;
export interface ListInstanceAttributesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListInstanceAttributesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance/{InstanceId}/attributes" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListInstanceAttributesRequest",
}) as any as S.Schema<ListInstanceAttributesRequest>;
export type AttributesList = Attribute[];
export const AttributesList = S.Array(Attribute);
export interface ListInstanceAttributesResponse {
  Attributes?: Attribute[];
  NextToken?: string;
}
export const ListInstanceAttributesResponse = S.suspend(() =>
  S.Struct({
    Attributes: S.optional(AttributesList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListInstanceAttributesResponse",
}) as any as S.Schema<ListInstanceAttributesResponse>;
export interface ListInstancesRequest {
  NextToken?: string;
  MaxResults?: number;
}
export const ListInstancesRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListInstancesRequest",
}) as any as S.Schema<ListInstancesRequest>;
export interface InstanceSummary {
  Id?: string;
  Arn?: string;
  IdentityManagementType?: DirectoryType;
  InstanceAlias?: string | redacted.Redacted<string>;
  CreatedTime?: Date;
  ServiceRole?: string;
  InstanceStatus?: InstanceStatus;
  InboundCallsEnabled?: boolean;
  OutboundCallsEnabled?: boolean;
  InstanceAccessUrl?: string;
}
export const InstanceSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    IdentityManagementType: S.optional(DirectoryType),
    InstanceAlias: S.optional(SensitiveString),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ServiceRole: S.optional(S.String),
    InstanceStatus: S.optional(InstanceStatus),
    InboundCallsEnabled: S.optional(S.Boolean),
    OutboundCallsEnabled: S.optional(S.Boolean),
    InstanceAccessUrl: S.optional(S.String),
  }),
).annotate({
  identifier: "InstanceSummary",
}) as any as S.Schema<InstanceSummary>;
export type InstanceSummaryList = InstanceSummary[];
export const InstanceSummaryList = S.Array(InstanceSummary);
export interface ListInstancesResponse {
  InstanceSummaryList?: InstanceSummary[];
  NextToken?: string;
}
export const ListInstancesResponse = S.suspend(() =>
  S.Struct({
    InstanceSummaryList: S.optional(InstanceSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListInstancesResponse",
}) as any as S.Schema<ListInstancesResponse>;
export interface ListInstanceStorageConfigsRequest {
  InstanceId: string;
  ResourceType: InstanceStorageResourceType;
  NextToken?: string;
  MaxResults?: number;
}
export const ListInstanceStorageConfigsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ResourceType: InstanceStorageResourceType.pipe(T.HttpQuery("resourceType")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance/{InstanceId}/storage-configs" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListInstanceStorageConfigsRequest",
}) as any as S.Schema<ListInstanceStorageConfigsRequest>;
export type InstanceStorageConfigs = InstanceStorageConfig[];
export const InstanceStorageConfigs = S.Array(InstanceStorageConfig);
export interface ListInstanceStorageConfigsResponse {
  StorageConfigs?: InstanceStorageConfig[];
  NextToken?: string;
}
export const ListInstanceStorageConfigsResponse = S.suspend(() =>
  S.Struct({
    StorageConfigs: S.optional(InstanceStorageConfigs),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListInstanceStorageConfigsResponse",
}) as any as S.Schema<ListInstanceStorageConfigsResponse>;
export interface ListIntegrationAssociationsRequest {
  InstanceId: string;
  IntegrationType?: IntegrationType;
  NextToken?: string;
  MaxResults?: number;
  IntegrationArn?: string;
}
export const ListIntegrationAssociationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    IntegrationType: S.optional(IntegrationType).pipe(
      T.HttpQuery("integrationType"),
    ),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    IntegrationArn: S.optional(S.String).pipe(T.HttpQuery("integrationArn")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/instance/{InstanceId}/integration-associations",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListIntegrationAssociationsRequest",
}) as any as S.Schema<ListIntegrationAssociationsRequest>;
export interface IntegrationAssociationSummary {
  IntegrationAssociationId?: string;
  IntegrationAssociationArn?: string;
  InstanceId?: string;
  IntegrationType?: IntegrationType;
  IntegrationArn?: string;
  SourceApplicationUrl?: string;
  SourceApplicationName?: string;
  SourceType?: SourceType;
}
export const IntegrationAssociationSummary = S.suspend(() =>
  S.Struct({
    IntegrationAssociationId: S.optional(S.String),
    IntegrationAssociationArn: S.optional(S.String),
    InstanceId: S.optional(S.String),
    IntegrationType: S.optional(IntegrationType),
    IntegrationArn: S.optional(S.String),
    SourceApplicationUrl: S.optional(S.String),
    SourceApplicationName: S.optional(S.String),
    SourceType: S.optional(SourceType),
  }),
).annotate({
  identifier: "IntegrationAssociationSummary",
}) as any as S.Schema<IntegrationAssociationSummary>;
export type IntegrationAssociationSummaryList = IntegrationAssociationSummary[];
export const IntegrationAssociationSummaryList = S.Array(
  IntegrationAssociationSummary,
);
export interface ListIntegrationAssociationsResponse {
  IntegrationAssociationSummaryList?: IntegrationAssociationSummary[];
  NextToken?: string;
}
export const ListIntegrationAssociationsResponse = S.suspend(() =>
  S.Struct({
    IntegrationAssociationSummaryList: S.optional(
      IntegrationAssociationSummaryList,
    ),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListIntegrationAssociationsResponse",
}) as any as S.Schema<ListIntegrationAssociationsResponse>;
export interface ListLambdaFunctionsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListLambdaFunctionsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance/{InstanceId}/lambda-functions" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListLambdaFunctionsRequest",
}) as any as S.Schema<ListLambdaFunctionsRequest>;
export type FunctionArnsList = string[];
export const FunctionArnsList = S.Array(S.String);
export interface ListLambdaFunctionsResponse {
  LambdaFunctions?: string[];
  NextToken?: string;
}
export const ListLambdaFunctionsResponse = S.suspend(() =>
  S.Struct({
    LambdaFunctions: S.optional(FunctionArnsList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListLambdaFunctionsResponse",
}) as any as S.Schema<ListLambdaFunctionsResponse>;
export interface ListLexBotsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListLexBotsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance/{InstanceId}/lex-bots" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListLexBotsRequest",
}) as any as S.Schema<ListLexBotsRequest>;
export type LexBotsList = LexBot[];
export const LexBotsList = S.Array(LexBot);
export interface ListLexBotsResponse {
  LexBots?: LexBot[];
  NextToken?: string;
}
export const ListLexBotsResponse = S.suspend(() =>
  S.Struct({
    LexBots: S.optional(LexBotsList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListLexBotsResponse",
}) as any as S.Schema<ListLexBotsResponse>;
export interface ListNotificationsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListNotificationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/notifications/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListNotificationsRequest",
}) as any as S.Schema<ListNotificationsRequest>;
export type NotificationSummaryList = Notification[];
export const NotificationSummaryList = S.Array(Notification);
export interface ListNotificationsResponse {
  NextToken?: string;
  NotificationSummaryList: Notification[];
}
export const ListNotificationsResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    NotificationSummaryList: NotificationSummaryList,
  }),
).annotate({
  identifier: "ListNotificationsResponse",
}) as any as S.Schema<ListNotificationsResponse>;
export type PhoneNumberTypes = PhoneNumberType[];
export const PhoneNumberTypes = S.Array(PhoneNumberType);
export type PhoneNumberCountryCodes = PhoneNumberCountryCode[];
export const PhoneNumberCountryCodes = S.Array(PhoneNumberCountryCode);
export interface ListPhoneNumbersRequest {
  InstanceId: string;
  PhoneNumberTypes?: PhoneNumberType[];
  PhoneNumberCountryCodes?: PhoneNumberCountryCode[];
  NextToken?: string;
  MaxResults?: number;
}
export const ListPhoneNumbersRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    PhoneNumberTypes: S.optional(PhoneNumberTypes).pipe(
      T.HttpQuery("phoneNumberTypes"),
    ),
    PhoneNumberCountryCodes: S.optional(PhoneNumberCountryCodes).pipe(
      T.HttpQuery("phoneNumberCountryCodes"),
    ),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/phone-numbers-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListPhoneNumbersRequest",
}) as any as S.Schema<ListPhoneNumbersRequest>;
export interface PhoneNumberSummary {
  Id?: string;
  Arn?: string;
  PhoneNumber?: string;
  PhoneNumberType?: PhoneNumberType;
  PhoneNumberCountryCode?: PhoneNumberCountryCode;
}
export const PhoneNumberSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    PhoneNumber: S.optional(S.String),
    PhoneNumberType: S.optional(PhoneNumberType),
    PhoneNumberCountryCode: S.optional(PhoneNumberCountryCode),
  }),
).annotate({
  identifier: "PhoneNumberSummary",
}) as any as S.Schema<PhoneNumberSummary>;
export type PhoneNumberSummaryList = PhoneNumberSummary[];
export const PhoneNumberSummaryList = S.Array(PhoneNumberSummary);
export interface ListPhoneNumbersResponse {
  PhoneNumberSummaryList?: PhoneNumberSummary[];
  NextToken?: string;
}
export const ListPhoneNumbersResponse = S.suspend(() =>
  S.Struct({
    PhoneNumberSummaryList: S.optional(PhoneNumberSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListPhoneNumbersResponse",
}) as any as S.Schema<ListPhoneNumbersResponse>;
export interface ListPhoneNumbersV2Request {
  TargetArn?: string;
  InstanceId?: string;
  MaxResults?: number;
  NextToken?: string;
  PhoneNumberCountryCodes?: PhoneNumberCountryCode[];
  PhoneNumberTypes?: PhoneNumberType[];
  PhoneNumberPrefix?: string;
}
export const ListPhoneNumbersV2Request = S.suspend(() =>
  S.Struct({
    TargetArn: S.optional(S.String),
    InstanceId: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    PhoneNumberCountryCodes: S.optional(PhoneNumberCountryCodes),
    PhoneNumberTypes: S.optional(PhoneNumberTypes),
    PhoneNumberPrefix: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/phone-number/list" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListPhoneNumbersV2Request",
}) as any as S.Schema<ListPhoneNumbersV2Request>;
export interface ListPhoneNumbersSummary {
  PhoneNumberId?: string;
  PhoneNumberArn?: string;
  PhoneNumber?: string;
  PhoneNumberCountryCode?: PhoneNumberCountryCode;
  PhoneNumberType?: PhoneNumberType;
  TargetArn?: string;
  InstanceId?: string;
  PhoneNumberDescription?: string;
  SourcePhoneNumberArn?: string;
}
export const ListPhoneNumbersSummary = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.optional(S.String),
    PhoneNumberArn: S.optional(S.String),
    PhoneNumber: S.optional(S.String),
    PhoneNumberCountryCode: S.optional(PhoneNumberCountryCode),
    PhoneNumberType: S.optional(PhoneNumberType),
    TargetArn: S.optional(S.String),
    InstanceId: S.optional(S.String),
    PhoneNumberDescription: S.optional(S.String),
    SourcePhoneNumberArn: S.optional(S.String),
  }),
).annotate({
  identifier: "ListPhoneNumbersSummary",
}) as any as S.Schema<ListPhoneNumbersSummary>;
export type ListPhoneNumbersSummaryList = ListPhoneNumbersSummary[];
export const ListPhoneNumbersSummaryList = S.Array(ListPhoneNumbersSummary);
export interface ListPhoneNumbersV2Response {
  NextToken?: string;
  ListPhoneNumbersSummaryList?: ListPhoneNumbersSummary[];
}
export const ListPhoneNumbersV2Response = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    ListPhoneNumbersSummaryList: S.optional(ListPhoneNumbersSummaryList),
  }),
).annotate({
  identifier: "ListPhoneNumbersV2Response",
}) as any as S.Schema<ListPhoneNumbersV2Response>;
export interface ListPredefinedAttributesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListPredefinedAttributesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/predefined-attributes/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListPredefinedAttributesRequest",
}) as any as S.Schema<ListPredefinedAttributesRequest>;
export interface PredefinedAttributeSummary {
  Name?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const PredefinedAttributeSummary = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "PredefinedAttributeSummary",
}) as any as S.Schema<PredefinedAttributeSummary>;
export type PredefinedAttributeSummaryList = PredefinedAttributeSummary[];
export const PredefinedAttributeSummaryList = S.Array(
  PredefinedAttributeSummary,
);
export interface ListPredefinedAttributesResponse {
  NextToken?: string;
  PredefinedAttributeSummaryList?: PredefinedAttributeSummary[];
}
export const ListPredefinedAttributesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    PredefinedAttributeSummaryList: S.optional(PredefinedAttributeSummaryList),
  }),
).annotate({
  identifier: "ListPredefinedAttributesResponse",
}) as any as S.Schema<ListPredefinedAttributesResponse>;
export interface ListPromptsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListPromptsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/prompts-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListPromptsRequest",
}) as any as S.Schema<ListPromptsRequest>;
export interface PromptSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const PromptSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({ identifier: "PromptSummary" }) as any as S.Schema<PromptSummary>;
export type PromptSummaryList = PromptSummary[];
export const PromptSummaryList = S.Array(PromptSummary);
export interface ListPromptsResponse {
  PromptSummaryList?: PromptSummary[];
  NextToken?: string;
}
export const ListPromptsResponse = S.suspend(() =>
  S.Struct({
    PromptSummaryList: S.optional(PromptSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListPromptsResponse",
}) as any as S.Schema<ListPromptsResponse>;
export interface ListQueueQuickConnectsRequest {
  InstanceId: string;
  QueueId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListQueueQuickConnectsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/queues/{InstanceId}/{QueueId}/quick-connects",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListQueueQuickConnectsRequest",
}) as any as S.Schema<ListQueueQuickConnectsRequest>;
export interface QuickConnectSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  QuickConnectType?: QuickConnectType;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const QuickConnectSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    QuickConnectType: S.optional(QuickConnectType),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "QuickConnectSummary",
}) as any as S.Schema<QuickConnectSummary>;
export type QuickConnectSummaryList = QuickConnectSummary[];
export const QuickConnectSummaryList = S.Array(QuickConnectSummary);
export interface ListQueueQuickConnectsResponse {
  NextToken?: string;
  QuickConnectSummaryList?: QuickConnectSummary[];
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const ListQueueQuickConnectsResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    QuickConnectSummaryList: S.optional(QuickConnectSummaryList),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "ListQueueQuickConnectsResponse",
}) as any as S.Schema<ListQueueQuickConnectsResponse>;
export type QueueType = "STANDARD" | "AGENT" | (string & {});
export const QueueType = S.String;
export type QueueTypes = QueueType[];
export const QueueTypes = S.Array(QueueType);
export interface ListQueuesRequest {
  InstanceId: string;
  QueueTypes?: QueueType[];
  NextToken?: string;
  MaxResults?: number;
}
export const ListQueuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueTypes: S.optional(QueueTypes).pipe(T.HttpQuery("queueTypes")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/queues-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListQueuesRequest",
}) as any as S.Schema<ListQueuesRequest>;
export interface QueueSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  QueueType?: QueueType;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const QueueSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    QueueType: S.optional(QueueType),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({ identifier: "QueueSummary" }) as any as S.Schema<QueueSummary>;
export type QueueSummaryList = QueueSummary[];
export const QueueSummaryList = S.Array(QueueSummary);
export interface ListQueuesResponse {
  QueueSummaryList?: QueueSummary[];
  NextToken?: string;
}
export const ListQueuesResponse = S.suspend(() =>
  S.Struct({
    QueueSummaryList: S.optional(QueueSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListQueuesResponse",
}) as any as S.Schema<ListQueuesResponse>;
export type QuickConnectTypes = QuickConnectType[];
export const QuickConnectTypes = S.Array(QuickConnectType);
export interface ListQuickConnectsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  QuickConnectTypes?: QuickConnectType[];
}
export const ListQuickConnectsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    QuickConnectTypes: S.optional(QuickConnectTypes).pipe(
      T.HttpQuery("QuickConnectTypes"),
    ),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/quick-connects/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListQuickConnectsRequest",
}) as any as S.Schema<ListQuickConnectsRequest>;
export interface ListQuickConnectsResponse {
  QuickConnectSummaryList?: QuickConnectSummary[];
  NextToken?: string;
}
export const ListQuickConnectsResponse = S.suspend(() =>
  S.Struct({
    QuickConnectSummaryList: S.optional(QuickConnectSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListQuickConnectsResponse",
}) as any as S.Schema<ListQuickConnectsResponse>;
export type RealTimeContactAnalysisOutputType =
  | "Raw"
  | "Redacted"
  | (string & {});
export const RealTimeContactAnalysisOutputType = S.String;
export type RealTimeContactAnalysisSegmentType =
  | "Transcript"
  | "Categories"
  | "Issues"
  | "Event"
  | "Attachments"
  | "PostContactSummary"
  | (string & {});
export const RealTimeContactAnalysisSegmentType = S.String;
export type RealTimeContactAnalysisSegmentTypes =
  RealTimeContactAnalysisSegmentType[];
export const RealTimeContactAnalysisSegmentTypes = S.Array(
  RealTimeContactAnalysisSegmentType,
);
export interface ListRealtimeContactAnalysisSegmentsV2Request {
  InstanceId: string;
  ContactId: string;
  MaxResults?: number;
  NextToken?: string;
  OutputType: RealTimeContactAnalysisOutputType;
  SegmentTypes: RealTimeContactAnalysisSegmentType[];
}
export const ListRealtimeContactAnalysisSegmentsV2Request = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String.pipe(T.HttpLabel("ContactId")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    OutputType: RealTimeContactAnalysisOutputType,
    SegmentTypes: RealTimeContactAnalysisSegmentTypes,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact/list-real-time-analysis-segments-v2/{InstanceId}/{ContactId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListRealtimeContactAnalysisSegmentsV2Request",
}) as any as S.Schema<ListRealtimeContactAnalysisSegmentsV2Request>;
export type RealTimeContactAnalysisSupportedChannel =
  | "VOICE"
  | "CHAT"
  | (string & {});
export const RealTimeContactAnalysisSupportedChannel = S.String;
export type RealTimeContactAnalysisStatus =
  | "IN_PROGRESS"
  | "FAILED"
  | "COMPLETED"
  | (string & {});
export const RealTimeContactAnalysisStatus = S.String;
export type RealTimeContactAnalysisTimeData = { AbsoluteTime: Date };
export const RealTimeContactAnalysisTimeData = S.Union([
  S.Struct({
    AbsoluteTime: T.DateFromString.pipe(T.TimestampFormat("date-time")),
  }),
]);
export interface RealTimeContactAnalysisCharacterInterval {
  BeginOffsetChar: number;
  EndOffsetChar: number;
}
export const RealTimeContactAnalysisCharacterInterval = S.suspend(() =>
  S.Struct({ BeginOffsetChar: S.Number, EndOffsetChar: S.Number }),
).annotate({
  identifier: "RealTimeContactAnalysisCharacterInterval",
}) as any as S.Schema<RealTimeContactAnalysisCharacterInterval>;
export type RealTimeContactAnalysisCharacterIntervals =
  RealTimeContactAnalysisCharacterInterval[];
export const RealTimeContactAnalysisCharacterIntervals = S.Array(
  RealTimeContactAnalysisCharacterInterval,
);
export interface RealTimeContactAnalysisTranscriptItemRedaction {
  CharacterOffsets?: RealTimeContactAnalysisCharacterInterval[];
}
export const RealTimeContactAnalysisTranscriptItemRedaction = S.suspend(() =>
  S.Struct({
    CharacterOffsets: S.optional(RealTimeContactAnalysisCharacterIntervals),
  }),
).annotate({
  identifier: "RealTimeContactAnalysisTranscriptItemRedaction",
}) as any as S.Schema<RealTimeContactAnalysisTranscriptItemRedaction>;
export type RealTimeContactAnalysisSentimentLabel =
  | "POSITIVE"
  | "NEGATIVE"
  | "NEUTRAL"
  | (string & {});
export const RealTimeContactAnalysisSentimentLabel = S.String;
export interface RealTimeContactAnalysisSegmentTranscript {
  Id: string;
  ParticipantId: string;
  ParticipantRole: ParticipantRole;
  DisplayName?: string;
  Content: string;
  ContentType?: string;
  Time: RealTimeContactAnalysisTimeData;
  Redaction?: RealTimeContactAnalysisTranscriptItemRedaction;
  Sentiment?: RealTimeContactAnalysisSentimentLabel;
}
export const RealTimeContactAnalysisSegmentTranscript = S.suspend(() =>
  S.Struct({
    Id: S.String,
    ParticipantId: S.String,
    ParticipantRole: ParticipantRole,
    DisplayName: S.optional(S.String),
    Content: S.String,
    ContentType: S.optional(S.String),
    Time: RealTimeContactAnalysisTimeData,
    Redaction: S.optional(RealTimeContactAnalysisTranscriptItemRedaction),
    Sentiment: S.optional(RealTimeContactAnalysisSentimentLabel),
  }),
).annotate({
  identifier: "RealTimeContactAnalysisSegmentTranscript",
}) as any as S.Schema<RealTimeContactAnalysisSegmentTranscript>;
export interface RealTimeContactAnalysisTranscriptItemWithCharacterOffsets {
  Id: string;
  CharacterOffsets?: RealTimeContactAnalysisCharacterInterval;
}
export const RealTimeContactAnalysisTranscriptItemWithCharacterOffsets =
  S.suspend(() =>
    S.Struct({
      Id: S.String,
      CharacterOffsets: S.optional(RealTimeContactAnalysisCharacterInterval),
    }),
  ).annotate({
    identifier: "RealTimeContactAnalysisTranscriptItemWithCharacterOffsets",
  }) as any as S.Schema<RealTimeContactAnalysisTranscriptItemWithCharacterOffsets>;
export type RealTimeContactAnalysisTranscriptItemsWithCharacterOffsets =
  RealTimeContactAnalysisTranscriptItemWithCharacterOffsets[];
export const RealTimeContactAnalysisTranscriptItemsWithCharacterOffsets =
  S.Array(RealTimeContactAnalysisTranscriptItemWithCharacterOffsets);
export interface RealTimeContactAnalysisPointOfInterest {
  TranscriptItems?: RealTimeContactAnalysisTranscriptItemWithCharacterOffsets[];
}
export const RealTimeContactAnalysisPointOfInterest = S.suspend(() =>
  S.Struct({
    TranscriptItems: S.optional(
      RealTimeContactAnalysisTranscriptItemsWithCharacterOffsets,
    ),
  }),
).annotate({
  identifier: "RealTimeContactAnalysisPointOfInterest",
}) as any as S.Schema<RealTimeContactAnalysisPointOfInterest>;
export type RealTimeContactAnalysisPointsOfInterest =
  RealTimeContactAnalysisPointOfInterest[];
export const RealTimeContactAnalysisPointsOfInterest = S.Array(
  RealTimeContactAnalysisPointOfInterest,
);
export interface RealTimeContactAnalysisCategoryDetails {
  PointsOfInterest: RealTimeContactAnalysisPointOfInterest[];
}
export const RealTimeContactAnalysisCategoryDetails = S.suspend(() =>
  S.Struct({ PointsOfInterest: RealTimeContactAnalysisPointsOfInterest }),
).annotate({
  identifier: "RealTimeContactAnalysisCategoryDetails",
}) as any as S.Schema<RealTimeContactAnalysisCategoryDetails>;
export type RealTimeContactAnalysisMatchedDetails = {
  [key: string]: RealTimeContactAnalysisCategoryDetails | undefined;
};
export const RealTimeContactAnalysisMatchedDetails = S.Record(
  S.String,
  RealTimeContactAnalysisCategoryDetails.pipe(S.optional),
);
export interface RealTimeContactAnalysisSegmentCategories {
  MatchedDetails: {
    [key: string]: RealTimeContactAnalysisCategoryDetails | undefined;
  };
}
export const RealTimeContactAnalysisSegmentCategories = S.suspend(() =>
  S.Struct({ MatchedDetails: RealTimeContactAnalysisMatchedDetails }),
).annotate({
  identifier: "RealTimeContactAnalysisSegmentCategories",
}) as any as S.Schema<RealTimeContactAnalysisSegmentCategories>;
export interface RealTimeContactAnalysisTranscriptItemWithContent {
  Content?: string;
  Id: string;
  CharacterOffsets?: RealTimeContactAnalysisCharacterInterval;
}
export const RealTimeContactAnalysisTranscriptItemWithContent = S.suspend(() =>
  S.Struct({
    Content: S.optional(S.String),
    Id: S.String,
    CharacterOffsets: S.optional(RealTimeContactAnalysisCharacterInterval),
  }),
).annotate({
  identifier: "RealTimeContactAnalysisTranscriptItemWithContent",
}) as any as S.Schema<RealTimeContactAnalysisTranscriptItemWithContent>;
export type RealTimeContactAnalysisTranscriptItemsWithContent =
  RealTimeContactAnalysisTranscriptItemWithContent[];
export const RealTimeContactAnalysisTranscriptItemsWithContent = S.Array(
  RealTimeContactAnalysisTranscriptItemWithContent,
);
export interface RealTimeContactAnalysisIssueDetected {
  TranscriptItems: RealTimeContactAnalysisTranscriptItemWithContent[];
}
export const RealTimeContactAnalysisIssueDetected = S.suspend(() =>
  S.Struct({
    TranscriptItems: RealTimeContactAnalysisTranscriptItemsWithContent,
  }),
).annotate({
  identifier: "RealTimeContactAnalysisIssueDetected",
}) as any as S.Schema<RealTimeContactAnalysisIssueDetected>;
export type RealTimeContactAnalysisIssuesDetected =
  RealTimeContactAnalysisIssueDetected[];
export const RealTimeContactAnalysisIssuesDetected = S.Array(
  RealTimeContactAnalysisIssueDetected,
);
export interface RealTimeContactAnalysisSegmentIssues {
  IssuesDetected: RealTimeContactAnalysisIssueDetected[];
}
export const RealTimeContactAnalysisSegmentIssues = S.suspend(() =>
  S.Struct({ IssuesDetected: RealTimeContactAnalysisIssuesDetected }),
).annotate({
  identifier: "RealTimeContactAnalysisSegmentIssues",
}) as any as S.Schema<RealTimeContactAnalysisSegmentIssues>;
export interface RealTimeContactAnalysisSegmentEvent {
  Id: string;
  ParticipantId?: string;
  ParticipantRole?: ParticipantRole;
  DisplayName?: string;
  EventType: string;
  Time: RealTimeContactAnalysisTimeData;
}
export const RealTimeContactAnalysisSegmentEvent = S.suspend(() =>
  S.Struct({
    Id: S.String,
    ParticipantId: S.optional(S.String),
    ParticipantRole: S.optional(ParticipantRole),
    DisplayName: S.optional(S.String),
    EventType: S.String,
    Time: RealTimeContactAnalysisTimeData,
  }),
).annotate({
  identifier: "RealTimeContactAnalysisSegmentEvent",
}) as any as S.Schema<RealTimeContactAnalysisSegmentEvent>;
export type ArtifactStatus =
  | "APPROVED"
  | "REJECTED"
  | "IN_PROGRESS"
  | (string & {});
export const ArtifactStatus = S.String;
export interface RealTimeContactAnalysisAttachment {
  AttachmentName: string;
  ContentType?: string;
  AttachmentId: string;
  Status?: ArtifactStatus;
}
export const RealTimeContactAnalysisAttachment = S.suspend(() =>
  S.Struct({
    AttachmentName: S.String,
    ContentType: S.optional(S.String),
    AttachmentId: S.String,
    Status: S.optional(ArtifactStatus),
  }),
).annotate({
  identifier: "RealTimeContactAnalysisAttachment",
}) as any as S.Schema<RealTimeContactAnalysisAttachment>;
export type RealTimeContactAnalysisAttachments =
  RealTimeContactAnalysisAttachment[];
export const RealTimeContactAnalysisAttachments = S.Array(
  RealTimeContactAnalysisAttachment,
);
export interface RealTimeContactAnalysisSegmentAttachments {
  Id: string;
  ParticipantId: string;
  ParticipantRole: ParticipantRole;
  DisplayName?: string;
  Attachments: RealTimeContactAnalysisAttachment[];
  Time: RealTimeContactAnalysisTimeData;
}
export const RealTimeContactAnalysisSegmentAttachments = S.suspend(() =>
  S.Struct({
    Id: S.String,
    ParticipantId: S.String,
    ParticipantRole: ParticipantRole,
    DisplayName: S.optional(S.String),
    Attachments: RealTimeContactAnalysisAttachments,
    Time: RealTimeContactAnalysisTimeData,
  }),
).annotate({
  identifier: "RealTimeContactAnalysisSegmentAttachments",
}) as any as S.Schema<RealTimeContactAnalysisSegmentAttachments>;
export type RealTimeContactAnalysisPostContactSummaryStatus =
  | "FAILED"
  | "COMPLETED"
  | (string & {});
export const RealTimeContactAnalysisPostContactSummaryStatus = S.String;
export type RealTimeContactAnalysisPostContactSummaryFailureCode =
  | "QUOTA_EXCEEDED"
  | "INSUFFICIENT_CONVERSATION_CONTENT"
  | "FAILED_SAFETY_GUIDELINES"
  | "INVALID_ANALYSIS_CONFIGURATION"
  | "INTERNAL_ERROR"
  | (string & {});
export const RealTimeContactAnalysisPostContactSummaryFailureCode = S.String;
export interface RealTimeContactAnalysisSegmentPostContactSummary {
  Content?: string;
  Status: RealTimeContactAnalysisPostContactSummaryStatus;
  FailureCode?: RealTimeContactAnalysisPostContactSummaryFailureCode;
}
export const RealTimeContactAnalysisSegmentPostContactSummary = S.suspend(() =>
  S.Struct({
    Content: S.optional(S.String),
    Status: RealTimeContactAnalysisPostContactSummaryStatus,
    FailureCode: S.optional(
      RealTimeContactAnalysisPostContactSummaryFailureCode,
    ),
  }),
).annotate({
  identifier: "RealTimeContactAnalysisSegmentPostContactSummary",
}) as any as S.Schema<RealTimeContactAnalysisSegmentPostContactSummary>;
export type RealtimeContactAnalysisSegment =
  | {
      Transcript: RealTimeContactAnalysisSegmentTranscript;
      Categories?: never;
      Issues?: never;
      Event?: never;
      Attachments?: never;
      PostContactSummary?: never;
    }
  | {
      Transcript?: never;
      Categories: RealTimeContactAnalysisSegmentCategories;
      Issues?: never;
      Event?: never;
      Attachments?: never;
      PostContactSummary?: never;
    }
  | {
      Transcript?: never;
      Categories?: never;
      Issues: RealTimeContactAnalysisSegmentIssues;
      Event?: never;
      Attachments?: never;
      PostContactSummary?: never;
    }
  | {
      Transcript?: never;
      Categories?: never;
      Issues?: never;
      Event: RealTimeContactAnalysisSegmentEvent;
      Attachments?: never;
      PostContactSummary?: never;
    }
  | {
      Transcript?: never;
      Categories?: never;
      Issues?: never;
      Event?: never;
      Attachments: RealTimeContactAnalysisSegmentAttachments;
      PostContactSummary?: never;
    }
  | {
      Transcript?: never;
      Categories?: never;
      Issues?: never;
      Event?: never;
      Attachments?: never;
      PostContactSummary: RealTimeContactAnalysisSegmentPostContactSummary;
    };
export const RealtimeContactAnalysisSegment = S.Union([
  S.Struct({ Transcript: RealTimeContactAnalysisSegmentTranscript }),
  S.Struct({ Categories: RealTimeContactAnalysisSegmentCategories }),
  S.Struct({ Issues: RealTimeContactAnalysisSegmentIssues }),
  S.Struct({ Event: RealTimeContactAnalysisSegmentEvent }),
  S.Struct({ Attachments: RealTimeContactAnalysisSegmentAttachments }),
  S.Struct({
    PostContactSummary: RealTimeContactAnalysisSegmentPostContactSummary,
  }),
]);
export type RealtimeContactAnalysisSegments = RealtimeContactAnalysisSegment[];
export const RealtimeContactAnalysisSegments = S.Array(
  RealtimeContactAnalysisSegment,
);
export interface ListRealtimeContactAnalysisSegmentsV2Response {
  Channel: RealTimeContactAnalysisSupportedChannel;
  Status: RealTimeContactAnalysisStatus;
  Segments: RealtimeContactAnalysisSegment[];
  NextToken?: string;
}
export const ListRealtimeContactAnalysisSegmentsV2Response = S.suspend(() =>
  S.Struct({
    Channel: RealTimeContactAnalysisSupportedChannel,
    Status: RealTimeContactAnalysisStatus,
    Segments: RealtimeContactAnalysisSegments,
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListRealtimeContactAnalysisSegmentsV2Response",
}) as any as S.Schema<ListRealtimeContactAnalysisSegmentsV2Response>;
export interface ListRoutingProfileManualAssignmentQueuesRequest {
  InstanceId: string;
  RoutingProfileId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListRoutingProfileManualAssignmentQueuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}/manual-assignment-queues",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListRoutingProfileManualAssignmentQueuesRequest",
}) as any as S.Schema<ListRoutingProfileManualAssignmentQueuesRequest>;
export interface RoutingProfileManualAssignmentQueueConfigSummary {
  QueueId: string;
  QueueArn: string;
  QueueName: string;
  Channel: Channel;
}
export const RoutingProfileManualAssignmentQueueConfigSummary = S.suspend(() =>
  S.Struct({
    QueueId: S.String,
    QueueArn: S.String,
    QueueName: S.String,
    Channel: Channel,
  }),
).annotate({
  identifier: "RoutingProfileManualAssignmentQueueConfigSummary",
}) as any as S.Schema<RoutingProfileManualAssignmentQueueConfigSummary>;
export type RoutingProfileManualAssignmentQueueConfigSummaryList =
  RoutingProfileManualAssignmentQueueConfigSummary[];
export const RoutingProfileManualAssignmentQueueConfigSummaryList = S.Array(
  RoutingProfileManualAssignmentQueueConfigSummary,
);
export interface ListRoutingProfileManualAssignmentQueuesResponse {
  NextToken?: string;
  RoutingProfileManualAssignmentQueueConfigSummaryList?: RoutingProfileManualAssignmentQueueConfigSummary[];
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const ListRoutingProfileManualAssignmentQueuesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    RoutingProfileManualAssignmentQueueConfigSummaryList: S.optional(
      RoutingProfileManualAssignmentQueueConfigSummaryList,
    ),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "ListRoutingProfileManualAssignmentQueuesResponse",
}) as any as S.Schema<ListRoutingProfileManualAssignmentQueuesResponse>;
export interface ListRoutingProfileQueuesRequest {
  InstanceId: string;
  RoutingProfileId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListRoutingProfileQueuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}/queues",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListRoutingProfileQueuesRequest",
}) as any as S.Schema<ListRoutingProfileQueuesRequest>;
export interface RoutingProfileQueueConfigSummary {
  QueueId: string;
  QueueArn: string;
  QueueName: string;
  Priority: number;
  Delay: number;
  Channel: Channel;
}
export const RoutingProfileQueueConfigSummary = S.suspend(() =>
  S.Struct({
    QueueId: S.String,
    QueueArn: S.String,
    QueueName: S.String,
    Priority: S.Number,
    Delay: S.Number,
    Channel: Channel,
  }),
).annotate({
  identifier: "RoutingProfileQueueConfigSummary",
}) as any as S.Schema<RoutingProfileQueueConfigSummary>;
export type RoutingProfileQueueConfigSummaryList =
  RoutingProfileQueueConfigSummary[];
export const RoutingProfileQueueConfigSummaryList = S.Array(
  RoutingProfileQueueConfigSummary,
);
export interface ListRoutingProfileQueuesResponse {
  NextToken?: string;
  RoutingProfileQueueConfigSummaryList?: RoutingProfileQueueConfigSummary[];
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const ListRoutingProfileQueuesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    RoutingProfileQueueConfigSummaryList: S.optional(
      RoutingProfileQueueConfigSummaryList,
    ),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "ListRoutingProfileQueuesResponse",
}) as any as S.Schema<ListRoutingProfileQueuesResponse>;
export interface ListRoutingProfilesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListRoutingProfilesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/routing-profiles-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListRoutingProfilesRequest",
}) as any as S.Schema<ListRoutingProfilesRequest>;
export interface RoutingProfileSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const RoutingProfileSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "RoutingProfileSummary",
}) as any as S.Schema<RoutingProfileSummary>;
export type RoutingProfileSummaryList = RoutingProfileSummary[];
export const RoutingProfileSummaryList = S.Array(RoutingProfileSummary);
export interface ListRoutingProfilesResponse {
  RoutingProfileSummaryList?: RoutingProfileSummary[];
  NextToken?: string;
}
export const ListRoutingProfilesResponse = S.suspend(() =>
  S.Struct({
    RoutingProfileSummaryList: S.optional(RoutingProfileSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListRoutingProfilesResponse",
}) as any as S.Schema<ListRoutingProfilesResponse>;
export interface ListRulesRequest {
  InstanceId: string;
  PublishStatus?: RulePublishStatus;
  EventSourceName?: EventSourceName;
  MaxResults?: number;
  NextToken?: string;
}
export const ListRulesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    PublishStatus: S.optional(RulePublishStatus).pipe(
      T.HttpQuery("publishStatus"),
    ),
    EventSourceName: S.optional(EventSourceName).pipe(
      T.HttpQuery("eventSourceName"),
    ),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/rules/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListRulesRequest",
}) as any as S.Schema<ListRulesRequest>;
export interface ActionSummary {
  ActionType: ActionType;
}
export const ActionSummary = S.suspend(() =>
  S.Struct({ ActionType: ActionType }),
).annotate({ identifier: "ActionSummary" }) as any as S.Schema<ActionSummary>;
export type ActionSummaries = ActionSummary[];
export const ActionSummaries = S.Array(ActionSummary);
export interface RuleSummary {
  Name: string;
  RuleId: string;
  RuleArn: string;
  EventSourceName: EventSourceName;
  PublishStatus: RulePublishStatus;
  ActionSummaries: ActionSummary[];
  CreatedTime: Date;
  LastUpdatedTime: Date;
}
export const RuleSummary = S.suspend(() =>
  S.Struct({
    Name: S.String,
    RuleId: S.String,
    RuleArn: S.String,
    EventSourceName: EventSourceName,
    PublishStatus: RulePublishStatus,
    ActionSummaries: ActionSummaries,
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastUpdatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
  }),
).annotate({ identifier: "RuleSummary" }) as any as S.Schema<RuleSummary>;
export type RuleSummaryList = RuleSummary[];
export const RuleSummaryList = S.Array(RuleSummary);
export interface ListRulesResponse {
  RuleSummaryList: RuleSummary[];
  NextToken?: string;
}
export const ListRulesResponse = S.suspend(() =>
  S.Struct({
    RuleSummaryList: RuleSummaryList,
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListRulesResponse",
}) as any as S.Schema<ListRulesResponse>;
export interface ListSecurityKeysRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListSecurityKeysRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance/{InstanceId}/security-keys" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListSecurityKeysRequest",
}) as any as S.Schema<ListSecurityKeysRequest>;
export interface SecurityKey {
  AssociationId?: string;
  Key?: string;
  CreationTime?: Date;
}
export const SecurityKey = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String),
    Key: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotate({ identifier: "SecurityKey" }) as any as S.Schema<SecurityKey>;
export type SecurityKeysList = SecurityKey[];
export const SecurityKeysList = S.Array(SecurityKey);
export interface ListSecurityKeysResponse {
  SecurityKeys?: SecurityKey[];
  NextToken?: string;
}
export const ListSecurityKeysResponse = S.suspend(() =>
  S.Struct({
    SecurityKeys: S.optional(SecurityKeysList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListSecurityKeysResponse",
}) as any as S.Schema<ListSecurityKeysResponse>;
export interface ListSecurityProfileApplicationsRequest {
  SecurityProfileId: string;
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListSecurityProfileApplicationsRequest = S.suspend(() =>
  S.Struct({
    SecurityProfileId: S.String.pipe(T.HttpLabel("SecurityProfileId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/security-profiles-applications/{InstanceId}/{SecurityProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListSecurityProfileApplicationsRequest",
}) as any as S.Schema<ListSecurityProfileApplicationsRequest>;
export interface ListSecurityProfileApplicationsResponse {
  Applications?: Application[];
  NextToken?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const ListSecurityProfileApplicationsResponse = S.suspend(() =>
  S.Struct({
    Applications: S.optional(Applications),
    NextToken: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "ListSecurityProfileApplicationsResponse",
}) as any as S.Schema<ListSecurityProfileApplicationsResponse>;
export interface ListSecurityProfileFlowModulesRequest {
  SecurityProfileId: string;
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListSecurityProfileFlowModulesRequest = S.suspend(() =>
  S.Struct({
    SecurityProfileId: S.String.pipe(T.HttpLabel("SecurityProfileId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/security-profiles-flow-modules/{InstanceId}/{SecurityProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListSecurityProfileFlowModulesRequest",
}) as any as S.Schema<ListSecurityProfileFlowModulesRequest>;
export interface ListSecurityProfileFlowModulesResponse {
  AllowedFlowModules?: FlowModule[];
  NextToken?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const ListSecurityProfileFlowModulesResponse = S.suspend(() =>
  S.Struct({
    AllowedFlowModules: S.optional(AllowedFlowModules),
    NextToken: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "ListSecurityProfileFlowModulesResponse",
}) as any as S.Schema<ListSecurityProfileFlowModulesResponse>;
export interface ListSecurityProfilePermissionsRequest {
  SecurityProfileId: string;
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListSecurityProfilePermissionsRequest = S.suspend(() =>
  S.Struct({
    SecurityProfileId: S.String.pipe(T.HttpLabel("SecurityProfileId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/security-profiles-permissions/{InstanceId}/{SecurityProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListSecurityProfilePermissionsRequest",
}) as any as S.Schema<ListSecurityProfilePermissionsRequest>;
export interface ListSecurityProfilePermissionsResponse {
  Permissions?: string[];
  NextToken?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const ListSecurityProfilePermissionsResponse = S.suspend(() =>
  S.Struct({
    Permissions: S.optional(PermissionsList),
    NextToken: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "ListSecurityProfilePermissionsResponse",
}) as any as S.Schema<ListSecurityProfilePermissionsResponse>;
export interface ListSecurityProfilesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListSecurityProfilesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/security-profiles-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListSecurityProfilesRequest",
}) as any as S.Schema<ListSecurityProfilesRequest>;
export interface SecurityProfileSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const SecurityProfileSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "SecurityProfileSummary",
}) as any as S.Schema<SecurityProfileSummary>;
export type SecurityProfileSummaryList = SecurityProfileSummary[];
export const SecurityProfileSummaryList = S.Array(SecurityProfileSummary);
export interface ListSecurityProfilesResponse {
  SecurityProfileSummaryList?: SecurityProfileSummary[];
  NextToken?: string;
}
export const ListSecurityProfilesResponse = S.suspend(() =>
  S.Struct({
    SecurityProfileSummaryList: S.optional(SecurityProfileSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListSecurityProfilesResponse",
}) as any as S.Schema<ListSecurityProfilesResponse>;
export interface ListTagsForResourceRequest {
  resourceArn: string;
}
export const ListTagsForResourceRequest = S.suspend(() =>
  S.Struct({ resourceArn: S.String.pipe(T.HttpLabel("resourceArn")) }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/tags/{resourceArn}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListTagsForResourceRequest",
}) as any as S.Schema<ListTagsForResourceRequest>;
export interface ListTagsForResourceResponse {
  tags?: { [key: string]: string | undefined };
}
export const ListTagsForResourceResponse = S.suspend(() =>
  S.Struct({ tags: S.optional(TagMap) }),
).annotate({
  identifier: "ListTagsForResourceResponse",
}) as any as S.Schema<ListTagsForResourceResponse>;
export interface ListTaskTemplatesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  Status?: TaskTemplateStatus;
  Name?: string;
}
export const ListTaskTemplatesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    Status: S.optional(TaskTemplateStatus).pipe(T.HttpQuery("status")),
    Name: S.optional(S.String).pipe(T.HttpQuery("name")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance/{InstanceId}/task/template" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListTaskTemplatesRequest",
}) as any as S.Schema<ListTaskTemplatesRequest>;
export interface TaskTemplateMetadata {
  Id?: string;
  Arn?: string;
  Name?: string;
  Description?: string;
  Status?: TaskTemplateStatus;
  LastModifiedTime?: Date;
  CreatedTime?: Date;
}
export const TaskTemplateMetadata = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    Status: S.optional(TaskTemplateStatus),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotate({
  identifier: "TaskTemplateMetadata",
}) as any as S.Schema<TaskTemplateMetadata>;
export type TaskTemplateList = TaskTemplateMetadata[];
export const TaskTemplateList = S.Array(TaskTemplateMetadata);
export interface ListTaskTemplatesResponse {
  TaskTemplates?: TaskTemplateMetadata[];
  NextToken?: string;
}
export const ListTaskTemplatesResponse = S.suspend(() =>
  S.Struct({
    TaskTemplates: S.optional(TaskTemplateList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListTaskTemplatesResponse",
}) as any as S.Schema<ListTaskTemplatesResponse>;
export interface ListTestCaseExecutionRecordsRequest {
  InstanceId: string;
  TestCaseId: string;
  TestCaseExecutionId: string;
  Status?: TestCaseExecutionStatus;
  NextToken?: string;
  MaxResults?: number;
}
export const ListTestCaseExecutionRecordsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    TestCaseId: S.String.pipe(T.HttpLabel("TestCaseId")),
    TestCaseExecutionId: S.String.pipe(T.HttpLabel("TestCaseExecutionId")),
    Status: S.optional(TestCaseExecutionStatus).pipe(T.HttpQuery("status")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/test-cases/{InstanceId}/{TestCaseId}/{TestCaseExecutionId}/records",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListTestCaseExecutionRecordsRequest",
}) as any as S.Schema<ListTestCaseExecutionRecordsRequest>;
export type ExecutionRecordStatus =
  | "PASSED"
  | "FAILED"
  | "IN_PROGRESS"
  | "STOPPED"
  | (string & {});
export const ExecutionRecordStatus = S.String;
export interface ExecutionRecord {
  ObservationId?: string;
  Status?: ExecutionRecordStatus;
  Timestamp?: Date;
  Record?: string;
}
export const ExecutionRecord = S.suspend(() =>
  S.Struct({
    ObservationId: S.optional(S.String),
    Status: S.optional(ExecutionRecordStatus),
    Timestamp: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Record: S.optional(S.String),
  }),
).annotate({
  identifier: "ExecutionRecord",
}) as any as S.Schema<ExecutionRecord>;
export type ExecutionRecordList = ExecutionRecord[];
export const ExecutionRecordList = S.Array(ExecutionRecord);
export interface ListTestCaseExecutionRecordsResponse {
  ExecutionRecords?: ExecutionRecord[];
  NextToken?: string;
}
export const ListTestCaseExecutionRecordsResponse = S.suspend(() =>
  S.Struct({
    ExecutionRecords: S.optional(ExecutionRecordList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListTestCaseExecutionRecordsResponse",
}) as any as S.Schema<ListTestCaseExecutionRecordsResponse>;
export interface ListTestCaseExecutionsRequest {
  InstanceId: string;
  TestCaseId?: string;
  TestCaseName?: string;
  StartTime?: Date;
  EndTime?: Date;
  Status?: TestCaseExecutionStatus;
  NextToken?: string;
  MaxResults?: number;
}
export const ListTestCaseExecutionsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    TestCaseId: S.optional(S.String).pipe(T.HttpQuery("testCaseId")),
    TestCaseName: S.optional(S.String).pipe(T.HttpQuery("testCaseName")),
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))).pipe(
      T.HttpQuery("startTime"),
    ),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))).pipe(
      T.HttpQuery("endTime"),
    ),
    Status: S.optional(TestCaseExecutionStatus).pipe(T.HttpQuery("status")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/test-case-executions/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListTestCaseExecutionsRequest",
}) as any as S.Schema<ListTestCaseExecutionsRequest>;
export interface TestCaseExecution {
  StartTime?: Date;
  EndTime?: Date;
  TestCaseExecutionId?: string;
  TestCaseId?: string;
  TestCaseExecutionStatus?: TestCaseExecutionStatus;
  Tags?: { [key: string]: string | undefined };
}
export const TestCaseExecution = S.suspend(() =>
  S.Struct({
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    TestCaseExecutionId: S.optional(S.String),
    TestCaseId: S.optional(S.String),
    TestCaseExecutionStatus: S.optional(TestCaseExecutionStatus),
    Tags: S.optional(TagMap),
  }),
).annotate({
  identifier: "TestCaseExecution",
}) as any as S.Schema<TestCaseExecution>;
export type TestCaseExecutionList = TestCaseExecution[];
export const TestCaseExecutionList = S.Array(TestCaseExecution);
export interface ListTestCaseExecutionsResponse {
  TestCaseExecutions?: TestCaseExecution[];
  NextToken?: string;
}
export const ListTestCaseExecutionsResponse = S.suspend(() =>
  S.Struct({
    TestCaseExecutions: S.optional(TestCaseExecutionList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListTestCaseExecutionsResponse",
}) as any as S.Schema<ListTestCaseExecutionsResponse>;
export interface ListTestCasesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListTestCasesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/test-cases-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListTestCasesRequest",
}) as any as S.Schema<ListTestCasesRequest>;
export interface TestCaseSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  Status?: TestCaseStatus;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const TestCaseSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    Status: S.optional(TestCaseStatus),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "TestCaseSummary",
}) as any as S.Schema<TestCaseSummary>;
export type TestCaseSummaryList = TestCaseSummary[];
export const TestCaseSummaryList = S.Array(TestCaseSummary);
export interface ListTestCasesResponse {
  TestCaseSummaryList?: TestCaseSummary[];
  NextToken?: string;
}
export const ListTestCasesResponse = S.suspend(() =>
  S.Struct({
    TestCaseSummaryList: S.optional(TestCaseSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListTestCasesResponse",
}) as any as S.Schema<ListTestCasesResponse>;
export interface ListTrafficDistributionGroupsRequest {
  MaxResults?: number;
  NextToken?: string;
  InstanceId?: string;
}
export const ListTrafficDistributionGroupsRequest = S.suspend(() =>
  S.Struct({
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    InstanceId: S.optional(S.String).pipe(T.HttpQuery("instanceId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/traffic-distribution-groups" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListTrafficDistributionGroupsRequest",
}) as any as S.Schema<ListTrafficDistributionGroupsRequest>;
export interface TrafficDistributionGroupSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  InstanceArn?: string;
  Status?: TrafficDistributionGroupStatus;
  IsDefault?: boolean;
}
export const TrafficDistributionGroupSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    InstanceArn: S.optional(S.String),
    Status: S.optional(TrafficDistributionGroupStatus),
    IsDefault: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "TrafficDistributionGroupSummary",
}) as any as S.Schema<TrafficDistributionGroupSummary>;
export type TrafficDistributionGroupSummaryList =
  TrafficDistributionGroupSummary[];
export const TrafficDistributionGroupSummaryList = S.Array(
  TrafficDistributionGroupSummary,
);
export interface ListTrafficDistributionGroupsResponse {
  NextToken?: string;
  TrafficDistributionGroupSummaryList?: TrafficDistributionGroupSummary[];
}
export const ListTrafficDistributionGroupsResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    TrafficDistributionGroupSummaryList: S.optional(
      TrafficDistributionGroupSummaryList,
    ),
  }),
).annotate({
  identifier: "ListTrafficDistributionGroupsResponse",
}) as any as S.Schema<ListTrafficDistributionGroupsResponse>;
export interface ListTrafficDistributionGroupUsersRequest {
  TrafficDistributionGroupId: string;
  MaxResults?: number;
  NextToken?: string;
}
export const ListTrafficDistributionGroupUsersRequest = S.suspend(() =>
  S.Struct({
    TrafficDistributionGroupId: S.String.pipe(
      T.HttpLabel("TrafficDistributionGroupId"),
    ),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/traffic-distribution-group/{TrafficDistributionGroupId}/user",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListTrafficDistributionGroupUsersRequest",
}) as any as S.Schema<ListTrafficDistributionGroupUsersRequest>;
export interface TrafficDistributionGroupUserSummary {
  UserId?: string;
}
export const TrafficDistributionGroupUserSummary = S.suspend(() =>
  S.Struct({ UserId: S.optional(S.String) }),
).annotate({
  identifier: "TrafficDistributionGroupUserSummary",
}) as any as S.Schema<TrafficDistributionGroupUserSummary>;
export type TrafficDistributionGroupUserSummaryList =
  TrafficDistributionGroupUserSummary[];
export const TrafficDistributionGroupUserSummaryList = S.Array(
  TrafficDistributionGroupUserSummary,
);
export interface ListTrafficDistributionGroupUsersResponse {
  NextToken?: string;
  TrafficDistributionGroupUserSummaryList?: TrafficDistributionGroupUserSummary[];
}
export const ListTrafficDistributionGroupUsersResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    TrafficDistributionGroupUserSummaryList: S.optional(
      TrafficDistributionGroupUserSummaryList,
    ),
  }),
).annotate({
  identifier: "ListTrafficDistributionGroupUsersResponse",
}) as any as S.Schema<ListTrafficDistributionGroupUsersResponse>;
export interface ListUseCasesRequest {
  InstanceId: string;
  IntegrationAssociationId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListUseCasesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    IntegrationAssociationId: S.String.pipe(
      T.HttpLabel("IntegrationAssociationId"),
    ),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/instance/{InstanceId}/integration-associations/{IntegrationAssociationId}/use-cases",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListUseCasesRequest",
}) as any as S.Schema<ListUseCasesRequest>;
export interface UseCase {
  UseCaseId?: string;
  UseCaseArn?: string;
  UseCaseType?: UseCaseType;
}
export const UseCase = S.suspend(() =>
  S.Struct({
    UseCaseId: S.optional(S.String),
    UseCaseArn: S.optional(S.String),
    UseCaseType: S.optional(UseCaseType),
  }),
).annotate({ identifier: "UseCase" }) as any as S.Schema<UseCase>;
export type UseCaseSummaryList = UseCase[];
export const UseCaseSummaryList = S.Array(UseCase);
export interface ListUseCasesResponse {
  UseCaseSummaryList?: UseCase[];
  NextToken?: string;
}
export const ListUseCasesResponse = S.suspend(() =>
  S.Struct({
    UseCaseSummaryList: S.optional(UseCaseSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListUseCasesResponse",
}) as any as S.Schema<ListUseCasesResponse>;
export interface ListUserHierarchyGroupsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListUserHierarchyGroupsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/user-hierarchy-groups-summary/{InstanceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListUserHierarchyGroupsRequest",
}) as any as S.Schema<ListUserHierarchyGroupsRequest>;
export type HierarchyGroupSummaryList = HierarchyGroupSummary[];
export const HierarchyGroupSummaryList = S.Array(HierarchyGroupSummary);
export interface ListUserHierarchyGroupsResponse {
  UserHierarchyGroupSummaryList?: HierarchyGroupSummary[];
  NextToken?: string;
}
export const ListUserHierarchyGroupsResponse = S.suspend(() =>
  S.Struct({
    UserHierarchyGroupSummaryList: S.optional(HierarchyGroupSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListUserHierarchyGroupsResponse",
}) as any as S.Schema<ListUserHierarchyGroupsResponse>;
export interface ListUserNotificationsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  UserId: string;
}
export const ListUserNotificationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    UserId: S.String.pipe(T.HttpLabel("UserId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/users/{InstanceId}/{UserId}/notifications",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListUserNotificationsRequest",
}) as any as S.Schema<ListUserNotificationsRequest>;
export type NotificationStatus = "READ" | "UNREAD" | "HIDDEN" | (string & {});
export const NotificationStatus = S.String;
export type NotificationSource =
  | "CUSTOMER"
  | "RULES"
  | "SYSTEM"
  | (string & {});
export const NotificationSource = S.String;
export interface UserNotificationSummary {
  NotificationId?: string;
  NotificationStatus?: NotificationStatus;
  InstanceId?: string;
  RecipientId?: string;
  Content?: { [key: string]: string | undefined };
  Priority?: NotificationPriority;
  Source?: NotificationSource;
  CreatedAt?: Date;
  ExpiresAt?: Date;
}
export const UserNotificationSummary = S.suspend(() =>
  S.Struct({
    NotificationId: S.optional(S.String),
    NotificationStatus: S.optional(NotificationStatus),
    InstanceId: S.optional(S.String),
    RecipientId: S.optional(S.String),
    Content: S.optional(NotificationContent),
    Priority: S.optional(NotificationPriority),
    Source: S.optional(NotificationSource),
    CreatedAt: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ExpiresAt: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotate({
  identifier: "UserNotificationSummary",
}) as any as S.Schema<UserNotificationSummary>;
export type UserNotificationSummaryList = UserNotificationSummary[];
export const UserNotificationSummaryList = S.Array(UserNotificationSummary);
export interface ListUserNotificationsResponse {
  UserNotifications?: UserNotificationSummary[];
  NextToken?: string;
}
export const ListUserNotificationsResponse = S.suspend(() =>
  S.Struct({
    UserNotifications: S.optional(UserNotificationSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListUserNotificationsResponse",
}) as any as S.Schema<ListUserNotificationsResponse>;
export interface ListUserProficienciesRequest {
  InstanceId: string;
  UserId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListUserProficienciesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/users/{InstanceId}/{UserId}/proficiencies",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListUserProficienciesRequest",
}) as any as S.Schema<ListUserProficienciesRequest>;
export interface ListUserProficienciesResponse {
  NextToken?: string;
  UserProficiencyList?: UserProficiency[];
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const ListUserProficienciesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    UserProficiencyList: S.optional(UserProficiencyList),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "ListUserProficienciesResponse",
}) as any as S.Schema<ListUserProficienciesResponse>;
export interface ListUsersRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListUsersRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/users-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListUsersRequest",
}) as any as S.Schema<ListUsersRequest>;
export interface UserSummary {
  Id?: string;
  Arn?: string;
  Username?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const UserSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Username: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({ identifier: "UserSummary" }) as any as S.Schema<UserSummary>;
export type UserSummaryList = UserSummary[];
export const UserSummaryList = S.Array(UserSummary);
export interface ListUsersResponse {
  UserSummaryList?: UserSummary[];
  NextToken?: string;
}
export const ListUsersResponse = S.suspend(() =>
  S.Struct({
    UserSummaryList: S.optional(UserSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListUsersResponse",
}) as any as S.Schema<ListUsersResponse>;
export interface ListViewsRequest {
  InstanceId: string;
  Type?: ViewType;
  NextToken?: string;
  MaxResults?: number;
}
export const ListViewsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Type: S.optional(ViewType).pipe(T.HttpQuery("type")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/views/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListViewsRequest",
}) as any as S.Schema<ListViewsRequest>;
export interface ViewSummary {
  Id?: string;
  Arn?: string;
  Name?: string | redacted.Redacted<string>;
  Type?: ViewType;
  Status?: ViewStatus;
  Description?: string;
}
export const ViewSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(SensitiveString),
    Type: S.optional(ViewType),
    Status: S.optional(ViewStatus),
    Description: S.optional(S.String),
  }),
).annotate({ identifier: "ViewSummary" }) as any as S.Schema<ViewSummary>;
export type ViewsSummaryList = ViewSummary[];
export const ViewsSummaryList = S.Array(ViewSummary);
export interface ListViewsResponse {
  ViewsSummaryList?: ViewSummary[];
  NextToken?: string;
}
export const ListViewsResponse = S.suspend(() =>
  S.Struct({
    ViewsSummaryList: S.optional(ViewsSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListViewsResponse",
}) as any as S.Schema<ListViewsResponse>;
export interface ListViewVersionsRequest {
  InstanceId: string;
  ViewId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListViewVersionsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ViewId: S.String.pipe(T.HttpLabel("ViewId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/views/{InstanceId}/{ViewId}/versions" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListViewVersionsRequest",
}) as any as S.Schema<ListViewVersionsRequest>;
export interface ViewVersionSummary {
  Id?: string;
  Arn?: string;
  Description?: string;
  Name?: string | redacted.Redacted<string>;
  Type?: ViewType;
  Version?: number;
  VersionDescription?: string;
}
export const ViewVersionSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Description: S.optional(S.String),
    Name: S.optional(SensitiveString),
    Type: S.optional(ViewType),
    Version: S.optional(S.Number),
    VersionDescription: S.optional(S.String),
  }),
).annotate({
  identifier: "ViewVersionSummary",
}) as any as S.Schema<ViewVersionSummary>;
export type ViewVersionSummaryList = ViewVersionSummary[];
export const ViewVersionSummaryList = S.Array(ViewVersionSummary);
export interface ListViewVersionsResponse {
  ViewVersionSummaryList?: ViewVersionSummary[];
  NextToken?: string;
}
export const ListViewVersionsResponse = S.suspend(() =>
  S.Struct({
    ViewVersionSummaryList: S.optional(ViewVersionSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "ListViewVersionsResponse",
}) as any as S.Schema<ListViewVersionsResponse>;
export interface ListWorkspaceMediaRequest {
  InstanceId: string;
  WorkspaceId: string;
}
export const ListWorkspaceMediaRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/media",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListWorkspaceMediaRequest",
}) as any as S.Schema<ListWorkspaceMediaRequest>;
export interface MediaItem {
  Type?: MediaType;
  Source?: string;
}
export const MediaItem = S.suspend(() =>
  S.Struct({ Type: S.optional(MediaType), Source: S.optional(S.String) }),
).annotate({ identifier: "MediaItem" }) as any as S.Schema<MediaItem>;
export type MediaList = MediaItem[];
export const MediaList = S.Array(MediaItem);
export interface ListWorkspaceMediaResponse {
  Media?: MediaItem[];
}
export const ListWorkspaceMediaResponse = S.suspend(() =>
  S.Struct({ Media: S.optional(MediaList) }),
).annotate({
  identifier: "ListWorkspaceMediaResponse",
}) as any as S.Schema<ListWorkspaceMediaResponse>;
export interface ListWorkspacePagesRequest {
  InstanceId: string;
  WorkspaceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListWorkspacePagesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/pages",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListWorkspacePagesRequest",
}) as any as S.Schema<ListWorkspacePagesRequest>;
export interface WorkspacePage {
  ResourceArn?: string;
  Page?: string;
  Slug?: string;
  InputData?: string;
}
export const WorkspacePage = S.suspend(() =>
  S.Struct({
    ResourceArn: S.optional(S.String),
    Page: S.optional(S.String),
    Slug: S.optional(S.String),
    InputData: S.optional(S.String),
  }),
).annotate({ identifier: "WorkspacePage" }) as any as S.Schema<WorkspacePage>;
export type WorkspacePageList = WorkspacePage[];
export const WorkspacePageList = S.Array(WorkspacePage);
export interface ListWorkspacePagesResponse {
  NextToken?: string;
  WorkspacePageList: WorkspacePage[];
}
export const ListWorkspacePagesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    WorkspacePageList: WorkspacePageList,
  }),
).annotate({
  identifier: "ListWorkspacePagesResponse",
}) as any as S.Schema<ListWorkspacePagesResponse>;
export interface ListWorkspacesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListWorkspacesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/workspaces/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ListWorkspacesRequest",
}) as any as S.Schema<ListWorkspacesRequest>;
export interface WorkspaceSummary {
  Id?: string;
  Name?: string;
  Arn?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const WorkspaceSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Name: S.optional(S.String),
    Arn: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotate({
  identifier: "WorkspaceSummary",
}) as any as S.Schema<WorkspaceSummary>;
export type WorkspaceSummaryList = WorkspaceSummary[];
export const WorkspaceSummaryList = S.Array(WorkspaceSummary);
export interface ListWorkspacesResponse {
  NextToken?: string;
  WorkspaceSummaryList: WorkspaceSummary[];
}
export const ListWorkspacesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    WorkspaceSummaryList: WorkspaceSummaryList,
  }),
).annotate({
  identifier: "ListWorkspacesResponse",
}) as any as S.Schema<ListWorkspacesResponse>;
export type MonitorCapability = "SILENT_MONITOR" | "BARGE" | (string & {});
export const MonitorCapability = S.String;
export type AllowedMonitorCapabilities = MonitorCapability[];
export const AllowedMonitorCapabilities = S.Array(MonitorCapability);
export interface MonitorContactRequest {
  InstanceId: string;
  ContactId: string;
  UserId: string;
  AllowedMonitorCapabilities?: MonitorCapability[];
  ClientToken?: string;
}
export const MonitorContactRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    UserId: S.String,
    AllowedMonitorCapabilities: S.optional(AllowedMonitorCapabilities),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/monitor" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "MonitorContactRequest",
}) as any as S.Schema<MonitorContactRequest>;
export interface MonitorContactResponse {
  ContactId?: string;
  ContactArn?: string;
}
export const MonitorContactResponse = S.suspend(() =>
  S.Struct({
    ContactId: S.optional(S.String),
    ContactArn: S.optional(S.String),
  }),
).annotate({
  identifier: "MonitorContactResponse",
}) as any as S.Schema<MonitorContactResponse>;
export interface PauseContactRequest {
  ContactId: string;
  InstanceId: string;
  ContactFlowId?: string;
}
export const PauseContactRequest = S.suspend(() =>
  S.Struct({
    ContactId: S.String,
    InstanceId: S.String,
    ContactFlowId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/pause" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "PauseContactRequest",
}) as any as S.Schema<PauseContactRequest>;
export interface PauseContactResponse {}
export const PauseContactResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "PauseContactResponse",
}) as any as S.Schema<PauseContactResponse>;
export interface PutUserStatusRequest {
  UserId: string;
  InstanceId: string;
  AgentStatusId: string;
}
export const PutUserStatusRequest = S.suspend(() =>
  S.Struct({
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AgentStatusId: S.String,
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/users/{InstanceId}/{UserId}/status" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "PutUserStatusRequest",
}) as any as S.Schema<PutUserStatusRequest>;
export interface PutUserStatusResponse {}
export const PutUserStatusResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "PutUserStatusResponse",
}) as any as S.Schema<PutUserStatusResponse>;
export interface ReleasePhoneNumberRequest {
  PhoneNumberId: string;
  ClientToken?: string;
}
export const ReleasePhoneNumberRequest = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.String.pipe(T.HttpLabel("PhoneNumberId")),
    ClientToken: S.optional(S.String).pipe(
      T.HttpQuery("clientToken"),
      T.IdempotencyToken(),
    ),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/phone-number/{PhoneNumberId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ReleasePhoneNumberRequest",
}) as any as S.Schema<ReleasePhoneNumberRequest>;
export interface ReleasePhoneNumberResponse {}
export const ReleasePhoneNumberResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "ReleasePhoneNumberResponse",
}) as any as S.Schema<ReleasePhoneNumberResponse>;
export interface ReplicateInstanceRequest {
  InstanceId: string;
  ReplicaRegion: string;
  ClientToken?: string;
  ReplicaAlias: string | redacted.Redacted<string>;
}
export const ReplicateInstanceRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ReplicaRegion: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    ReplicaAlias: SensitiveString,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/instance/{InstanceId}/replicate" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ReplicateInstanceRequest",
}) as any as S.Schema<ReplicateInstanceRequest>;
export interface ReplicateInstanceResponse {
  Id?: string;
  Arn?: string;
}
export const ReplicateInstanceResponse = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String), Arn: S.optional(S.String) }),
).annotate({
  identifier: "ReplicateInstanceResponse",
}) as any as S.Schema<ReplicateInstanceResponse>;
export interface ResumeContactRequest {
  ContactId: string;
  InstanceId: string;
  ContactFlowId?: string;
}
export const ResumeContactRequest = S.suspend(() =>
  S.Struct({
    ContactId: S.String,
    InstanceId: S.String,
    ContactFlowId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/resume" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ResumeContactRequest",
}) as any as S.Schema<ResumeContactRequest>;
export interface ResumeContactResponse {}
export const ResumeContactResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "ResumeContactResponse",
}) as any as S.Schema<ResumeContactResponse>;
export type ContactRecordingType = "AGENT" | "IVR" | "SCREEN" | (string & {});
export const ContactRecordingType = S.String;
export interface ResumeContactRecordingRequest {
  InstanceId: string;
  ContactId: string;
  InitialContactId: string;
  ContactRecordingType?: ContactRecordingType;
}
export const ResumeContactRecordingRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    InitialContactId: S.String,
    ContactRecordingType: S.optional(ContactRecordingType),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/resume-recording" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "ResumeContactRecordingRequest",
}) as any as S.Schema<ResumeContactRecordingRequest>;
export interface ResumeContactRecordingResponse {}
export const ResumeContactRecordingResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "ResumeContactRecordingResponse",
}) as any as S.Schema<ResumeContactRecordingResponse>;
export interface TagCondition {
  TagKey?: string;
  TagValue?: string;
}
export const TagCondition = S.suspend(() =>
  S.Struct({ TagKey: S.optional(S.String), TagValue: S.optional(S.String) }),
).annotate({ identifier: "TagCondition" }) as any as S.Schema<TagCondition>;
export type TagAndConditionList = TagCondition[];
export const TagAndConditionList = S.Array(TagCondition);
export interface CommonAttributeAndCondition {
  TagConditions?: TagCondition[];
}
export const CommonAttributeAndCondition = S.suspend(() =>
  S.Struct({ TagConditions: S.optional(TagAndConditionList) }),
).annotate({
  identifier: "CommonAttributeAndCondition",
}) as any as S.Schema<CommonAttributeAndCondition>;
export type CommonAttributeOrConditionList = CommonAttributeAndCondition[];
export const CommonAttributeOrConditionList = S.Array(
  CommonAttributeAndCondition,
);
export interface ControlPlaneAttributeFilter {
  OrConditions?: CommonAttributeAndCondition[];
  AndCondition?: CommonAttributeAndCondition;
  TagCondition?: TagCondition;
}
export const ControlPlaneAttributeFilter = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(CommonAttributeOrConditionList),
    AndCondition: S.optional(CommonAttributeAndCondition),
    TagCondition: S.optional(TagCondition),
  }),
).annotate({
  identifier: "ControlPlaneAttributeFilter",
}) as any as S.Schema<ControlPlaneAttributeFilter>;
export interface AgentStatusSearchFilter {
  AttributeFilter?: ControlPlaneAttributeFilter;
}
export const AgentStatusSearchFilter = S.suspend(() =>
  S.Struct({ AttributeFilter: S.optional(ControlPlaneAttributeFilter) }),
).annotate({
  identifier: "AgentStatusSearchFilter",
}) as any as S.Schema<AgentStatusSearchFilter>;
export type AgentStatusSearchConditionList = AgentStatusSearchCriteria[];
export const AgentStatusSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<AgentStatusSearchCriteria> => AgentStatusSearchCriteria,
  ).annotate({ identifier: "AgentStatusSearchCriteria" }),
) as any as S.Schema<AgentStatusSearchConditionList>;
export type StringComparisonType =
  | "STARTS_WITH"
  | "CONTAINS"
  | "EXACT"
  | (string & {});
export const StringComparisonType = S.String;
export interface StringCondition {
  FieldName?: string;
  Value?: string;
  ComparisonType?: StringComparisonType;
}
export const StringCondition = S.suspend(() =>
  S.Struct({
    FieldName: S.optional(S.String),
    Value: S.optional(S.String),
    ComparisonType: S.optional(StringComparisonType),
  }),
).annotate({
  identifier: "StringCondition",
}) as any as S.Schema<StringCondition>;
export interface AgentStatusSearchCriteria {
  OrConditions?: AgentStatusSearchCriteria[];
  AndConditions?: AgentStatusSearchCriteria[];
  StringCondition?: StringCondition;
}
export const AgentStatusSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => AgentStatusSearchConditionList).annotate({
        identifier: "AgentStatusSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => AgentStatusSearchConditionList).annotate({
        identifier: "AgentStatusSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotate({
  identifier: "AgentStatusSearchCriteria",
}) as any as S.Schema<AgentStatusSearchCriteria>;
export interface SearchAgentStatusesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: AgentStatusSearchFilter;
  SearchCriteria?: AgentStatusSearchCriteria;
}
export const SearchAgentStatusesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(AgentStatusSearchFilter),
    SearchCriteria: S.optional(AgentStatusSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-agent-statuses" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchAgentStatusesRequest",
}) as any as S.Schema<SearchAgentStatusesRequest>;
export type AgentStatusList = AgentStatus[];
export const AgentStatusList = S.Array(AgentStatus);
export interface SearchAgentStatusesResponse {
  AgentStatuses?: AgentStatus[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchAgentStatusesResponse = S.suspend(() =>
  S.Struct({
    AgentStatuses: S.optional(AgentStatusList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchAgentStatusesResponse",
}) as any as S.Schema<SearchAgentStatusesResponse>;
export interface SearchAvailablePhoneNumbersRequest {
  TargetArn?: string;
  InstanceId?: string;
  PhoneNumberCountryCode: PhoneNumberCountryCode;
  PhoneNumberType: PhoneNumberType;
  PhoneNumberPrefix?: string;
  MaxResults?: number;
  NextToken?: string;
}
export const SearchAvailablePhoneNumbersRequest = S.suspend(() =>
  S.Struct({
    TargetArn: S.optional(S.String),
    InstanceId: S.optional(S.String),
    PhoneNumberCountryCode: PhoneNumberCountryCode,
    PhoneNumberType: PhoneNumberType,
    PhoneNumberPrefix: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/phone-number/search-available" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchAvailablePhoneNumbersRequest",
}) as any as S.Schema<SearchAvailablePhoneNumbersRequest>;
export interface AvailableNumberSummary {
  PhoneNumber?: string;
  PhoneNumberCountryCode?: PhoneNumberCountryCode;
  PhoneNumberType?: PhoneNumberType;
}
export const AvailableNumberSummary = S.suspend(() =>
  S.Struct({
    PhoneNumber: S.optional(S.String),
    PhoneNumberCountryCode: S.optional(PhoneNumberCountryCode),
    PhoneNumberType: S.optional(PhoneNumberType),
  }),
).annotate({
  identifier: "AvailableNumberSummary",
}) as any as S.Schema<AvailableNumberSummary>;
export type AvailableNumbersList = AvailableNumberSummary[];
export const AvailableNumbersList = S.Array(AvailableNumberSummary);
export interface SearchAvailablePhoneNumbersResponse {
  NextToken?: string;
  AvailableNumbersList?: AvailableNumberSummary[];
}
export const SearchAvailablePhoneNumbersResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    AvailableNumbersList: S.optional(AvailableNumbersList),
  }),
).annotate({
  identifier: "SearchAvailablePhoneNumbersResponse",
}) as any as S.Schema<SearchAvailablePhoneNumbersResponse>;
export type EvaluationSearchConditionList = EvaluationSearchCriteria[];
export const EvaluationSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<EvaluationSearchCriteria> => EvaluationSearchCriteria,
  ).annotate({ identifier: "EvaluationSearchCriteria" }),
) as any as S.Schema<EvaluationSearchConditionList>;
export type NumberComparisonType =
  | "GREATER_OR_EQUAL"
  | "GREATER"
  | "LESSER_OR_EQUAL"
  | "LESSER"
  | "EQUAL"
  | "NOT_EQUAL"
  | "RANGE"
  | (string & {});
export const NumberComparisonType = S.String;
export interface NumberCondition {
  FieldName?: string;
  MinValue?: number;
  MaxValue?: number;
  ComparisonType?: NumberComparisonType;
}
export const NumberCondition = S.suspend(() =>
  S.Struct({
    FieldName: S.optional(S.String),
    MinValue: S.optional(S.Number),
    MaxValue: S.optional(S.Number),
    ComparisonType: S.optional(NumberComparisonType),
  }),
).annotate({
  identifier: "NumberCondition",
}) as any as S.Schema<NumberCondition>;
export type BooleanComparisonType = "IS_TRUE" | "IS_FALSE" | (string & {});
export const BooleanComparisonType = S.String;
export interface BooleanCondition {
  FieldName?: string;
  ComparisonType?: BooleanComparisonType;
}
export const BooleanCondition = S.suspend(() =>
  S.Struct({
    FieldName: S.optional(S.String),
    ComparisonType: S.optional(BooleanComparisonType),
  }),
).annotate({
  identifier: "BooleanCondition",
}) as any as S.Schema<BooleanCondition>;
export type DateTimeComparisonType =
  | "GREATER_THAN"
  | "LESS_THAN"
  | "GREATER_THAN_OR_EQUAL_TO"
  | "LESS_THAN_OR_EQUAL_TO"
  | "EQUAL_TO"
  | "RANGE"
  | (string & {});
export const DateTimeComparisonType = S.String;
export interface DateTimeCondition {
  FieldName?: string;
  MinValue?: string;
  MaxValue?: string;
  ComparisonType?: DateTimeComparisonType;
}
export const DateTimeCondition = S.suspend(() =>
  S.Struct({
    FieldName: S.optional(S.String),
    MinValue: S.optional(S.String),
    MaxValue: S.optional(S.String),
    ComparisonType: S.optional(DateTimeComparisonType),
  }),
).annotate({
  identifier: "DateTimeCondition",
}) as any as S.Schema<DateTimeCondition>;
export type DecimalComparisonType =
  | "GREATER_OR_EQUAL"
  | "GREATER"
  | "LESSER_OR_EQUAL"
  | "LESSER"
  | "EQUAL"
  | "NOT_EQUAL"
  | "RANGE"
  | (string & {});
export const DecimalComparisonType = S.String;
export interface DecimalCondition {
  FieldName?: string;
  MinValue?: number;
  MaxValue?: number;
  ComparisonType?: DecimalComparisonType;
}
export const DecimalCondition = S.suspend(() =>
  S.Struct({
    FieldName: S.optional(S.String),
    MinValue: S.optional(S.Number),
    MaxValue: S.optional(S.Number),
    ComparisonType: S.optional(DecimalComparisonType),
  }),
).annotate({
  identifier: "DecimalCondition",
}) as any as S.Schema<DecimalCondition>;
export interface EvaluationSearchCriteria {
  OrConditions?: EvaluationSearchCriteria[];
  AndConditions?: EvaluationSearchCriteria[];
  StringCondition?: StringCondition;
  NumberCondition?: NumberCondition;
  BooleanCondition?: BooleanCondition;
  DateTimeCondition?: DateTimeCondition;
  DecimalCondition?: DecimalCondition;
}
export const EvaluationSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => EvaluationSearchConditionList).annotate({
        identifier: "EvaluationSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => EvaluationSearchConditionList).annotate({
        identifier: "EvaluationSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
    NumberCondition: S.optional(NumberCondition),
    BooleanCondition: S.optional(BooleanCondition),
    DateTimeCondition: S.optional(DateTimeCondition),
    DecimalCondition: S.optional(DecimalCondition),
  }),
).annotate({
  identifier: "EvaluationSearchCriteria",
}) as any as S.Schema<EvaluationSearchCriteria>;
export interface EvaluationSearchFilter {
  AttributeFilter?: ControlPlaneAttributeFilter;
}
export const EvaluationSearchFilter = S.suspend(() =>
  S.Struct({ AttributeFilter: S.optional(ControlPlaneAttributeFilter) }),
).annotate({
  identifier: "EvaluationSearchFilter",
}) as any as S.Schema<EvaluationSearchFilter>;
export interface SearchContactEvaluationsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchCriteria?: EvaluationSearchCriteria;
  SearchFilter?: EvaluationSearchFilter;
}
export const SearchContactEvaluationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchCriteria: S.optional(EvaluationSearchCriteria),
    SearchFilter: S.optional(EvaluationSearchFilter),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-contact-evaluations" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchContactEvaluationsRequest",
}) as any as S.Schema<SearchContactEvaluationsRequest>;
export interface EvaluationSearchMetadata {
  ContactId: string;
  EvaluatorArn: string;
  ContactAgentId?: string;
  CalibrationSessionId?: string;
  ScorePercentage?: number;
  ScoreAutomaticFail?: boolean;
  ScoreNotApplicable?: boolean;
  AutoEvaluationEnabled?: boolean;
  AutoEvaluationStatus?: AutoEvaluationStatus;
  AcknowledgedTime?: Date;
  AcknowledgedBy?: string;
  AcknowledgerComment?: string;
  SamplingJobId?: string;
  ReviewId?: string;
  ContactParticipantRole?: ContactParticipantRole;
  ContactParticipantId?: string;
}
export const EvaluationSearchMetadata = S.suspend(() =>
  S.Struct({
    ContactId: S.String,
    EvaluatorArn: S.String,
    ContactAgentId: S.optional(S.String),
    CalibrationSessionId: S.optional(S.String),
    ScorePercentage: S.optional(S.Number),
    ScoreAutomaticFail: S.optional(S.Boolean),
    ScoreNotApplicable: S.optional(S.Boolean),
    AutoEvaluationEnabled: S.optional(S.Boolean),
    AutoEvaluationStatus: S.optional(AutoEvaluationStatus),
    AcknowledgedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    AcknowledgedBy: S.optional(S.String),
    AcknowledgerComment: S.optional(S.String),
    SamplingJobId: S.optional(S.String),
    ReviewId: S.optional(S.String),
    ContactParticipantRole: S.optional(ContactParticipantRole),
    ContactParticipantId: S.optional(S.String),
  }),
).annotate({
  identifier: "EvaluationSearchMetadata",
}) as any as S.Schema<EvaluationSearchMetadata>;
export interface EvaluationSearchSummary {
  EvaluationId: string;
  EvaluationArn: string;
  EvaluationFormId?: string;
  EvaluationFormVersion: number;
  EvaluationFormTitle?: string;
  Metadata: EvaluationSearchMetadata;
  Status: EvaluationStatus;
  EvaluationType?: EvaluationType;
  CreatedTime: Date;
  LastModifiedTime: Date;
  Tags?: { [key: string]: string | undefined };
}
export const EvaluationSearchSummary = S.suspend(() =>
  S.Struct({
    EvaluationId: S.String,
    EvaluationArn: S.String,
    EvaluationFormId: S.optional(S.String),
    EvaluationFormVersion: S.Number,
    EvaluationFormTitle: S.optional(S.String),
    Metadata: EvaluationSearchMetadata,
    Status: EvaluationStatus,
    EvaluationType: S.optional(EvaluationType),
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    Tags: S.optional(TagMap),
  }),
).annotate({
  identifier: "EvaluationSearchSummary",
}) as any as S.Schema<EvaluationSearchSummary>;
export type EvaluationSearchSummaryList = EvaluationSearchSummary[];
export const EvaluationSearchSummaryList = S.Array(EvaluationSearchSummary);
export interface SearchContactEvaluationsResponse {
  EvaluationSearchSummaryList?: EvaluationSearchSummary[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchContactEvaluationsResponse = S.suspend(() =>
  S.Struct({
    EvaluationSearchSummaryList: S.optional(EvaluationSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchContactEvaluationsResponse",
}) as any as S.Schema<SearchContactEvaluationsResponse>;
export type TagOrConditionList = TagCondition[][];
export const TagOrConditionList = S.Array(TagAndConditionList);
export interface ControlPlaneTagFilter {
  OrConditions?: TagCondition[][];
  AndConditions?: TagCondition[];
  TagCondition?: TagCondition;
}
export const ControlPlaneTagFilter = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(TagOrConditionList),
    AndConditions: S.optional(TagAndConditionList),
    TagCondition: S.optional(TagCondition),
  }),
).annotate({
  identifier: "ControlPlaneTagFilter",
}) as any as S.Schema<ControlPlaneTagFilter>;
export interface ContactFlowModuleSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
}
export const ContactFlowModuleSearchFilter = S.suspend(() =>
  S.Struct({ TagFilter: S.optional(ControlPlaneTagFilter) }),
).annotate({
  identifier: "ContactFlowModuleSearchFilter",
}) as any as S.Schema<ContactFlowModuleSearchFilter>;
export type ContactFlowModuleSearchConditionList =
  ContactFlowModuleSearchCriteria[];
export const ContactFlowModuleSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<ContactFlowModuleSearchCriteria> =>
      ContactFlowModuleSearchCriteria,
  ).annotate({ identifier: "ContactFlowModuleSearchCriteria" }),
) as any as S.Schema<ContactFlowModuleSearchConditionList>;
export interface ContactFlowModuleSearchCriteria {
  OrConditions?: ContactFlowModuleSearchCriteria[];
  AndConditions?: ContactFlowModuleSearchCriteria[];
  StringCondition?: StringCondition;
  StateCondition?: ContactFlowModuleState;
  StatusCondition?: ContactFlowModuleStatus;
}
export const ContactFlowModuleSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => ContactFlowModuleSearchConditionList).annotate({
        identifier: "ContactFlowModuleSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => ContactFlowModuleSearchConditionList).annotate({
        identifier: "ContactFlowModuleSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
    StateCondition: S.optional(ContactFlowModuleState),
    StatusCondition: S.optional(ContactFlowModuleStatus),
  }),
).annotate({
  identifier: "ContactFlowModuleSearchCriteria",
}) as any as S.Schema<ContactFlowModuleSearchCriteria>;
export interface SearchContactFlowModulesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: ContactFlowModuleSearchFilter;
  SearchCriteria?: ContactFlowModuleSearchCriteria;
}
export const SearchContactFlowModulesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(ContactFlowModuleSearchFilter),
    SearchCriteria: S.optional(ContactFlowModuleSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-contact-flow-modules" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchContactFlowModulesRequest",
}) as any as S.Schema<SearchContactFlowModulesRequest>;
export type ContactFlowModuleSearchSummaryList = ContactFlowModule[];
export const ContactFlowModuleSearchSummaryList = S.Array(ContactFlowModule);
export interface SearchContactFlowModulesResponse {
  ContactFlowModules?: ContactFlowModule[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchContactFlowModulesResponse = S.suspend(() =>
  S.Struct({
    ContactFlowModules: S.optional(ContactFlowModuleSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchContactFlowModulesResponse",
}) as any as S.Schema<SearchContactFlowModulesResponse>;
export interface ContactFlowTypeCondition {
  ContactFlowType?: ContactFlowType;
}
export const ContactFlowTypeCondition = S.suspend(() =>
  S.Struct({ ContactFlowType: S.optional(ContactFlowType) }),
).annotate({
  identifier: "ContactFlowTypeCondition",
}) as any as S.Schema<ContactFlowTypeCondition>;
export interface ContactFlowAttributeAndCondition {
  TagConditions?: TagCondition[];
  ContactFlowTypeCondition?: ContactFlowTypeCondition;
}
export const ContactFlowAttributeAndCondition = S.suspend(() =>
  S.Struct({
    TagConditions: S.optional(TagAndConditionList),
    ContactFlowTypeCondition: S.optional(ContactFlowTypeCondition),
  }),
).annotate({
  identifier: "ContactFlowAttributeAndCondition",
}) as any as S.Schema<ContactFlowAttributeAndCondition>;
export type ContactFlowAttributeOrConditionList =
  ContactFlowAttributeAndCondition[];
export const ContactFlowAttributeOrConditionList = S.Array(
  ContactFlowAttributeAndCondition,
);
export interface ContactFlowAttributeFilter {
  OrConditions?: ContactFlowAttributeAndCondition[];
  AndCondition?: ContactFlowAttributeAndCondition;
  TagCondition?: TagCondition;
  ContactFlowTypeCondition?: ContactFlowTypeCondition;
}
export const ContactFlowAttributeFilter = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(ContactFlowAttributeOrConditionList),
    AndCondition: S.optional(ContactFlowAttributeAndCondition),
    TagCondition: S.optional(TagCondition),
    ContactFlowTypeCondition: S.optional(ContactFlowTypeCondition),
  }),
).annotate({
  identifier: "ContactFlowAttributeFilter",
}) as any as S.Schema<ContactFlowAttributeFilter>;
export interface ContactFlowSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
  FlowAttributeFilter?: ContactFlowAttributeFilter;
}
export const ContactFlowSearchFilter = S.suspend(() =>
  S.Struct({
    TagFilter: S.optional(ControlPlaneTagFilter),
    FlowAttributeFilter: S.optional(ContactFlowAttributeFilter),
  }),
).annotate({
  identifier: "ContactFlowSearchFilter",
}) as any as S.Schema<ContactFlowSearchFilter>;
export type ContactFlowSearchConditionList = ContactFlowSearchCriteria[];
export const ContactFlowSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<ContactFlowSearchCriteria> => ContactFlowSearchCriteria,
  ).annotate({ identifier: "ContactFlowSearchCriteria" }),
) as any as S.Schema<ContactFlowSearchConditionList>;
export interface ContactFlowSearchCriteria {
  OrConditions?: ContactFlowSearchCriteria[];
  AndConditions?: ContactFlowSearchCriteria[];
  StringCondition?: StringCondition;
  TypeCondition?: ContactFlowType;
  StateCondition?: ContactFlowState;
  StatusCondition?: ContactFlowStatus;
}
export const ContactFlowSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => ContactFlowSearchConditionList).annotate({
        identifier: "ContactFlowSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => ContactFlowSearchConditionList).annotate({
        identifier: "ContactFlowSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
    TypeCondition: S.optional(ContactFlowType),
    StateCondition: S.optional(ContactFlowState),
    StatusCondition: S.optional(ContactFlowStatus),
  }),
).annotate({
  identifier: "ContactFlowSearchCriteria",
}) as any as S.Schema<ContactFlowSearchCriteria>;
export interface SearchContactFlowsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: ContactFlowSearchFilter;
  SearchCriteria?: ContactFlowSearchCriteria;
}
export const SearchContactFlowsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(ContactFlowSearchFilter),
    SearchCriteria: S.optional(ContactFlowSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-contact-flows" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchContactFlowsRequest",
}) as any as S.Schema<SearchContactFlowsRequest>;
export type ContactFlowSearchSummaryList = ContactFlow[];
export const ContactFlowSearchSummaryList = S.Array(ContactFlow);
export interface SearchContactFlowsResponse {
  ContactFlows?: ContactFlow[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchContactFlowsResponse = S.suspend(() =>
  S.Struct({
    ContactFlows: S.optional(ContactFlowSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchContactFlowsResponse",
}) as any as S.Schema<SearchContactFlowsResponse>;
export type SearchContactsTimeRangeType =
  | "INITIATION_TIMESTAMP"
  | "SCHEDULED_TIMESTAMP"
  | "CONNECTED_TO_AGENT_TIMESTAMP"
  | "DISCONNECT_TIMESTAMP"
  | "ENQUEUE_TIMESTAMP"
  | (string & {});
export const SearchContactsTimeRangeType = S.String;
export interface SearchContactsTimeRange {
  Type: SearchContactsTimeRangeType;
  StartTime: Date;
  EndTime: Date;
}
export const SearchContactsTimeRange = S.suspend(() =>
  S.Struct({
    Type: SearchContactsTimeRangeType,
    StartTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    EndTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
  }),
).annotate({
  identifier: "SearchContactsTimeRange",
}) as any as S.Schema<SearchContactsTimeRange>;
export type SearchTextList = string | redacted.Redacted<string>[];
export const SearchTextList = S.Array(SensitiveString);
export type SearchContactsMatchType =
  | "MATCH_ALL"
  | "MATCH_ANY"
  | "MATCH_EXACT"
  | "MATCH_NONE"
  | (string & {});
export const SearchContactsMatchType = S.String;
export interface NameCriteria {
  SearchText: string | redacted.Redacted<string>[];
  MatchType: SearchContactsMatchType;
}
export const NameCriteria = S.suspend(() =>
  S.Struct({ SearchText: SearchTextList, MatchType: SearchContactsMatchType }),
).annotate({ identifier: "NameCriteria" }) as any as S.Schema<NameCriteria>;
export type AgentResourceIdList = string[];
export const AgentResourceIdList = S.Array(S.String);
export type HierarchyGroupIdList = string[];
export const HierarchyGroupIdList = S.Array(S.String);
export interface AgentHierarchyGroups {
  L1Ids?: string[];
  L2Ids?: string[];
  L3Ids?: string[];
  L4Ids?: string[];
  L5Ids?: string[];
}
export const AgentHierarchyGroups = S.suspend(() =>
  S.Struct({
    L1Ids: S.optional(HierarchyGroupIdList),
    L2Ids: S.optional(HierarchyGroupIdList),
    L3Ids: S.optional(HierarchyGroupIdList),
    L4Ids: S.optional(HierarchyGroupIdList),
    L5Ids: S.optional(HierarchyGroupIdList),
  }),
).annotate({
  identifier: "AgentHierarchyGroups",
}) as any as S.Schema<AgentHierarchyGroups>;
export type ChannelList = Channel[];
export const ChannelList = S.Array(Channel);
export interface TranscriptCriteria {
  ParticipantRole: ParticipantRole;
  SearchText: string | redacted.Redacted<string>[];
  MatchType: SearchContactsMatchType;
}
export const TranscriptCriteria = S.suspend(() =>
  S.Struct({
    ParticipantRole: ParticipantRole,
    SearchText: SearchTextList,
    MatchType: SearchContactsMatchType,
  }),
).annotate({
  identifier: "TranscriptCriteria",
}) as any as S.Schema<TranscriptCriteria>;
export type TranscriptCriteriaList = TranscriptCriteria[];
export const TranscriptCriteriaList = S.Array(TranscriptCriteria);
export interface Transcript {
  Criteria: TranscriptCriteria[];
  MatchType?: SearchContactsMatchType;
}
export const Transcript = S.suspend(() =>
  S.Struct({
    Criteria: TranscriptCriteriaList,
    MatchType: S.optional(SearchContactsMatchType),
  }),
).annotate({ identifier: "Transcript" }) as any as S.Schema<Transcript>;
export interface ContactAnalysis {
  Transcript?: Transcript;
}
export const ContactAnalysis = S.suspend(() =>
  S.Struct({ Transcript: S.optional(Transcript) }),
).annotate({
  identifier: "ContactAnalysis",
}) as any as S.Schema<ContactAnalysis>;
export type InitiationMethodList = ContactInitiationMethod[];
export const InitiationMethodList = S.Array(ContactInitiationMethod);
export type QueueIdList = string[];
export const QueueIdList = S.Array(S.String);
export interface SearchableAgentCriteriaStep {
  AgentIds?: string[];
  MatchType?: SearchContactsMatchType;
}
export const SearchableAgentCriteriaStep = S.suspend(() =>
  S.Struct({
    AgentIds: S.optional(AgentResourceIdList),
    MatchType: S.optional(SearchContactsMatchType),
  }),
).annotate({
  identifier: "SearchableAgentCriteriaStep",
}) as any as S.Schema<SearchableAgentCriteriaStep>;
export interface SearchableRoutingCriteriaStep {
  AgentCriteria?: SearchableAgentCriteriaStep;
}
export const SearchableRoutingCriteriaStep = S.suspend(() =>
  S.Struct({ AgentCriteria: S.optional(SearchableAgentCriteriaStep) }),
).annotate({
  identifier: "SearchableRoutingCriteriaStep",
}) as any as S.Schema<SearchableRoutingCriteriaStep>;
export type SearchableRoutingCriteriaStepList = SearchableRoutingCriteriaStep[];
export const SearchableRoutingCriteriaStepList = S.Array(
  SearchableRoutingCriteriaStep,
);
export interface SearchableRoutingCriteria {
  Steps?: SearchableRoutingCriteriaStep[];
}
export const SearchableRoutingCriteria = S.suspend(() =>
  S.Struct({ Steps: S.optional(SearchableRoutingCriteriaStepList) }),
).annotate({
  identifier: "SearchableRoutingCriteria",
}) as any as S.Schema<SearchableRoutingCriteria>;
export type SearchContactsTimeRangeConditionType = "NOT_EXISTS" | (string & {});
export const SearchContactsTimeRangeConditionType = S.String;
export interface SearchContactsTimestampCondition {
  Type: SearchContactsTimeRangeType;
  ConditionType: SearchContactsTimeRangeConditionType;
}
export const SearchContactsTimestampCondition = S.suspend(() =>
  S.Struct({
    Type: SearchContactsTimeRangeType,
    ConditionType: SearchContactsTimeRangeConditionType,
  }),
).annotate({
  identifier: "SearchContactsTimestampCondition",
}) as any as S.Schema<SearchContactsTimestampCondition>;
export interface SearchContactsAdditionalTimeRangeCriteria {
  TimeRange?: SearchContactsTimeRange;
  TimestampCondition?: SearchContactsTimestampCondition;
}
export const SearchContactsAdditionalTimeRangeCriteria = S.suspend(() =>
  S.Struct({
    TimeRange: S.optional(SearchContactsTimeRange),
    TimestampCondition: S.optional(SearchContactsTimestampCondition),
  }),
).annotate({
  identifier: "SearchContactsAdditionalTimeRangeCriteria",
}) as any as S.Schema<SearchContactsAdditionalTimeRangeCriteria>;
export type SearchContactsAdditionalTimeRangeCriteriaList =
  SearchContactsAdditionalTimeRangeCriteria[];
export const SearchContactsAdditionalTimeRangeCriteriaList = S.Array(
  SearchContactsAdditionalTimeRangeCriteria,
);
export interface SearchContactsAdditionalTimeRange {
  Criteria: SearchContactsAdditionalTimeRangeCriteria[];
  MatchType: SearchContactsMatchType;
}
export const SearchContactsAdditionalTimeRange = S.suspend(() =>
  S.Struct({
    Criteria: SearchContactsAdditionalTimeRangeCriteriaList,
    MatchType: SearchContactsMatchType,
  }),
).annotate({
  identifier: "SearchContactsAdditionalTimeRange",
}) as any as S.Schema<SearchContactsAdditionalTimeRange>;
export type SearchableContactAttributeValueList =
  | string
  | redacted.Redacted<string>[];
export const SearchableContactAttributeValueList = S.Array(SensitiveString);
export interface SearchableContactAttributesCriteria {
  Key: string | redacted.Redacted<string>;
  Values: string | redacted.Redacted<string>[];
}
export const SearchableContactAttributesCriteria = S.suspend(() =>
  S.Struct({
    Key: SensitiveString,
    Values: SearchableContactAttributeValueList,
  }),
).annotate({
  identifier: "SearchableContactAttributesCriteria",
}) as any as S.Schema<SearchableContactAttributesCriteria>;
export type SearchableContactAttributesCriteriaList =
  SearchableContactAttributesCriteria[];
export const SearchableContactAttributesCriteriaList = S.Array(
  SearchableContactAttributesCriteria,
);
export interface SearchableContactAttributes {
  Criteria: SearchableContactAttributesCriteria[];
  MatchType?: SearchContactsMatchType;
}
export const SearchableContactAttributes = S.suspend(() =>
  S.Struct({
    Criteria: SearchableContactAttributesCriteriaList,
    MatchType: S.optional(SearchContactsMatchType),
  }),
).annotate({
  identifier: "SearchableContactAttributes",
}) as any as S.Schema<SearchableContactAttributes>;
export type SearchableSegmentAttributeValueList =
  | string
  | redacted.Redacted<string>[];
export const SearchableSegmentAttributeValueList = S.Array(SensitiveString);
export interface SearchableSegmentAttributesCriteria {
  Key: string | redacted.Redacted<string>;
  Values: string | redacted.Redacted<string>[];
}
export const SearchableSegmentAttributesCriteria = S.suspend(() =>
  S.Struct({
    Key: SensitiveString,
    Values: SearchableSegmentAttributeValueList,
  }),
).annotate({
  identifier: "SearchableSegmentAttributesCriteria",
}) as any as S.Schema<SearchableSegmentAttributesCriteria>;
export type SearchableSegmentAttributesCriteriaList =
  SearchableSegmentAttributesCriteria[];
export const SearchableSegmentAttributesCriteriaList = S.Array(
  SearchableSegmentAttributesCriteria,
);
export interface SearchableSegmentAttributes {
  Criteria: SearchableSegmentAttributesCriteria[];
  MatchType?: SearchContactsMatchType;
}
export const SearchableSegmentAttributes = S.suspend(() =>
  S.Struct({
    Criteria: SearchableSegmentAttributesCriteriaList,
    MatchType: S.optional(SearchContactsMatchType),
  }),
).annotate({
  identifier: "SearchableSegmentAttributes",
}) as any as S.Schema<SearchableSegmentAttributes>;
export type ActiveRegionList = string[];
export const ActiveRegionList = S.Array(S.String);
export interface SearchCriteria {
  Name?: NameCriteria;
  AgentIds?: string[];
  AgentHierarchyGroups?: AgentHierarchyGroups;
  Channels?: Channel[];
  ContactAnalysis?: ContactAnalysis;
  InitiationMethods?: ContactInitiationMethod[];
  QueueIds?: string[];
  RoutingCriteria?: SearchableRoutingCriteria;
  AdditionalTimeRange?: SearchContactsAdditionalTimeRange;
  SearchableContactAttributes?: SearchableContactAttributes;
  SearchableSegmentAttributes?: SearchableSegmentAttributes;
  ActiveRegions?: string[];
  ContactTags?: ControlPlaneTagFilter;
}
export const SearchCriteria = S.suspend(() =>
  S.Struct({
    Name: S.optional(NameCriteria),
    AgentIds: S.optional(AgentResourceIdList),
    AgentHierarchyGroups: S.optional(AgentHierarchyGroups),
    Channels: S.optional(ChannelList),
    ContactAnalysis: S.optional(ContactAnalysis),
    InitiationMethods: S.optional(InitiationMethodList),
    QueueIds: S.optional(QueueIdList),
    RoutingCriteria: S.optional(SearchableRoutingCriteria),
    AdditionalTimeRange: S.optional(SearchContactsAdditionalTimeRange),
    SearchableContactAttributes: S.optional(SearchableContactAttributes),
    SearchableSegmentAttributes: S.optional(SearchableSegmentAttributes),
    ActiveRegions: S.optional(ActiveRegionList),
    ContactTags: S.optional(ControlPlaneTagFilter),
  }),
).annotate({ identifier: "SearchCriteria" }) as any as S.Schema<SearchCriteria>;
export type SortableFieldName =
  | "INITIATION_TIMESTAMP"
  | "SCHEDULED_TIMESTAMP"
  | "CONNECTED_TO_AGENT_TIMESTAMP"
  | "DISCONNECT_TIMESTAMP"
  | "INITIATION_METHOD"
  | "CHANNEL"
  | "EXPIRY_TIMESTAMP"
  | (string & {});
export const SortableFieldName = S.String;
export interface Sort {
  FieldName: SortableFieldName;
  Order: SortOrder;
}
export const Sort = S.suspend(() =>
  S.Struct({ FieldName: SortableFieldName, Order: SortOrder }),
).annotate({ identifier: "Sort" }) as any as S.Schema<Sort>;
export interface SearchContactsRequest {
  InstanceId: string;
  TimeRange: SearchContactsTimeRange;
  SearchCriteria?: SearchCriteria;
  MaxResults?: number;
  NextToken?: string;
  Sort?: Sort;
}
export const SearchContactsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    TimeRange: SearchContactsTimeRange,
    SearchCriteria: S.optional(SearchCriteria),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    Sort: S.optional(Sort),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-contacts" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchContactsRequest",
}) as any as S.Schema<SearchContactsRequest>;
export interface ContactSearchSummaryQueueInfo {
  Id?: string;
  EnqueueTimestamp?: Date;
}
export const ContactSearchSummaryQueueInfo = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    EnqueueTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "ContactSearchSummaryQueueInfo",
}) as any as S.Schema<ContactSearchSummaryQueueInfo>;
export interface ContactSearchSummaryAgentInfo {
  Id?: string;
  ConnectedToAgentTimestamp?: Date;
}
export const ContactSearchSummaryAgentInfo = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    ConnectedToAgentTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotate({
  identifier: "ContactSearchSummaryAgentInfo",
}) as any as S.Schema<ContactSearchSummaryAgentInfo>;
export interface ContactSearchSummarySegmentAttributeValue {
  ValueString?: string;
  ValueMap?: { [key: string]: SegmentAttributeValue | undefined };
}
export const ContactSearchSummarySegmentAttributeValue = S.suspend(() =>
  S.Struct({
    ValueString: S.optional(S.String),
    ValueMap: S.optional(SegmentAttributeValueMap),
  }),
).annotate({
  identifier: "ContactSearchSummarySegmentAttributeValue",
}) as any as S.Schema<ContactSearchSummarySegmentAttributeValue>;
export type ContactSearchSummarySegmentAttributes = {
  [key: string]: ContactSearchSummarySegmentAttributeValue | undefined;
};
export const ContactSearchSummarySegmentAttributes = S.Record(
  S.String,
  ContactSearchSummarySegmentAttributeValue.pipe(S.optional),
);
export interface ContactSearchSummary {
  Arn?: string;
  Id?: string;
  InitialContactId?: string;
  PreviousContactId?: string;
  InitiationMethod?: ContactInitiationMethod;
  Channel?: Channel;
  QueueInfo?: ContactSearchSummaryQueueInfo;
  AgentInfo?: ContactSearchSummaryAgentInfo;
  InitiationTimestamp?: Date;
  DisconnectTimestamp?: Date;
  ScheduledTimestamp?: Date;
  SegmentAttributes?: {
    [key: string]: ContactSearchSummarySegmentAttributeValue | undefined;
  };
  Name?: string | redacted.Redacted<string>;
  RoutingCriteria?: RoutingCriteria;
  Tags?: { [key: string]: string | undefined };
  GlobalResiliencyMetadata?: GlobalResiliencyMetadata;
}
export const ContactSearchSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Id: S.optional(S.String),
    InitialContactId: S.optional(S.String),
    PreviousContactId: S.optional(S.String),
    InitiationMethod: S.optional(ContactInitiationMethod),
    Channel: S.optional(Channel),
    QueueInfo: S.optional(ContactSearchSummaryQueueInfo),
    AgentInfo: S.optional(ContactSearchSummaryAgentInfo),
    InitiationTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    DisconnectTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ScheduledTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SegmentAttributes: S.optional(ContactSearchSummarySegmentAttributes),
    Name: S.optional(SensitiveString),
    RoutingCriteria: S.optional(RoutingCriteria),
    Tags: S.optional(ContactTagMap),
    GlobalResiliencyMetadata: S.optional(GlobalResiliencyMetadata),
  }),
).annotate({
  identifier: "ContactSearchSummary",
}) as any as S.Schema<ContactSearchSummary>;
export type Contacts = ContactSearchSummary[];
export const Contacts = S.Array(ContactSearchSummary);
export interface SearchContactsResponse {
  Contacts: ContactSearchSummary[];
  NextToken?: string;
  TotalCount?: number;
}
export const SearchContactsResponse = S.suspend(() =>
  S.Struct({
    Contacts: Contacts,
    NextToken: S.optional(S.String),
    TotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchContactsResponse",
}) as any as S.Schema<SearchContactsResponse>;
export interface DataTableSearchFilter {
  AttributeFilter?: ControlPlaneAttributeFilter;
}
export const DataTableSearchFilter = S.suspend(() =>
  S.Struct({ AttributeFilter: S.optional(ControlPlaneAttributeFilter) }),
).annotate({
  identifier: "DataTableSearchFilter",
}) as any as S.Schema<DataTableSearchFilter>;
export type DataTableSearchConditionList = DataTableSearchCriteria[];
export const DataTableSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<DataTableSearchCriteria> => DataTableSearchCriteria,
  ).annotate({ identifier: "DataTableSearchCriteria" }),
) as any as S.Schema<DataTableSearchConditionList>;
export interface DataTableSearchCriteria {
  OrConditions?: DataTableSearchCriteria[];
  AndConditions?: DataTableSearchCriteria[];
  StringCondition?: StringCondition;
}
export const DataTableSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => DataTableSearchConditionList).annotate({
        identifier: "DataTableSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => DataTableSearchConditionList).annotate({
        identifier: "DataTableSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotate({
  identifier: "DataTableSearchCriteria",
}) as any as S.Schema<DataTableSearchCriteria>;
export interface SearchDataTablesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: DataTableSearchFilter;
  SearchCriteria?: DataTableSearchCriteria;
}
export const SearchDataTablesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(DataTableSearchFilter),
    SearchCriteria: S.optional(DataTableSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-data-tables" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchDataTablesRequest",
}) as any as S.Schema<SearchDataTablesRequest>;
export type DataTableList = DataTable[];
export const DataTableList = S.Array(DataTable);
export interface SearchDataTablesResponse {
  DataTables?: DataTable[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchDataTablesResponse = S.suspend(() =>
  S.Struct({
    DataTables: S.optional(DataTableList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchDataTablesResponse",
}) as any as S.Schema<SearchDataTablesResponse>;
export type EmailAddressSearchConditionList = EmailAddressSearchCriteria[];
export const EmailAddressSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<EmailAddressSearchCriteria> => EmailAddressSearchCriteria,
  ).annotate({ identifier: "EmailAddressSearchCriteria" }),
) as any as S.Schema<EmailAddressSearchConditionList>;
export interface EmailAddressSearchCriteria {
  OrConditions?: EmailAddressSearchCriteria[];
  AndConditions?: EmailAddressSearchCriteria[];
  StringCondition?: StringCondition;
}
export const EmailAddressSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => EmailAddressSearchConditionList).annotate({
        identifier: "EmailAddressSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => EmailAddressSearchConditionList).annotate({
        identifier: "EmailAddressSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotate({
  identifier: "EmailAddressSearchCriteria",
}) as any as S.Schema<EmailAddressSearchCriteria>;
export interface EmailAddressSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
}
export const EmailAddressSearchFilter = S.suspend(() =>
  S.Struct({ TagFilter: S.optional(ControlPlaneTagFilter) }),
).annotate({
  identifier: "EmailAddressSearchFilter",
}) as any as S.Schema<EmailAddressSearchFilter>;
export interface SearchEmailAddressesRequest {
  InstanceId: string;
  MaxResults?: number;
  NextToken?: string;
  SearchCriteria?: EmailAddressSearchCriteria;
  SearchFilter?: EmailAddressSearchFilter;
}
export const SearchEmailAddressesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    SearchCriteria: S.optional(EmailAddressSearchCriteria),
    SearchFilter: S.optional(EmailAddressSearchFilter),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-email-addresses" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchEmailAddressesRequest",
}) as any as S.Schema<SearchEmailAddressesRequest>;
export interface EmailAddressMetadata {
  EmailAddressId?: string;
  EmailAddressArn?: string;
  EmailAddress?: string | redacted.Redacted<string>;
  Description?: string | redacted.Redacted<string>;
  DisplayName?: string | redacted.Redacted<string>;
  AliasConfigurations?: AliasConfiguration[];
}
export const EmailAddressMetadata = S.suspend(() =>
  S.Struct({
    EmailAddressId: S.optional(S.String),
    EmailAddressArn: S.optional(S.String),
    EmailAddress: S.optional(SensitiveString),
    Description: S.optional(SensitiveString),
    DisplayName: S.optional(SensitiveString),
    AliasConfigurations: S.optional(AliasConfigurationList),
  }),
).annotate({
  identifier: "EmailAddressMetadata",
}) as any as S.Schema<EmailAddressMetadata>;
export type EmailAddressList = EmailAddressMetadata[];
export const EmailAddressList = S.Array(EmailAddressMetadata);
export interface SearchEmailAddressesResponse {
  NextToken?: string;
  EmailAddresses?: EmailAddressMetadata[];
  ApproximateTotalCount?: number;
}
export const SearchEmailAddressesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    EmailAddresses: S.optional(EmailAddressList),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchEmailAddressesResponse",
}) as any as S.Schema<SearchEmailAddressesResponse>;
export type EvaluationFormSearchConditionList = EvaluationFormSearchCriteria[];
export const EvaluationFormSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<EvaluationFormSearchCriteria> => EvaluationFormSearchCriteria,
  ).annotate({ identifier: "EvaluationFormSearchCriteria" }),
) as any as S.Schema<EvaluationFormSearchConditionList>;
export interface EvaluationFormSearchCriteria {
  OrConditions?: EvaluationFormSearchCriteria[];
  AndConditions?: EvaluationFormSearchCriteria[];
  StringCondition?: StringCondition;
  NumberCondition?: NumberCondition;
  BooleanCondition?: BooleanCondition;
  DateTimeCondition?: DateTimeCondition;
}
export const EvaluationFormSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => EvaluationFormSearchConditionList).annotate({
        identifier: "EvaluationFormSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => EvaluationFormSearchConditionList).annotate({
        identifier: "EvaluationFormSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
    NumberCondition: S.optional(NumberCondition),
    BooleanCondition: S.optional(BooleanCondition),
    DateTimeCondition: S.optional(DateTimeCondition),
  }),
).annotate({
  identifier: "EvaluationFormSearchCriteria",
}) as any as S.Schema<EvaluationFormSearchCriteria>;
export interface EvaluationFormSearchFilter {
  AttributeFilter?: ControlPlaneAttributeFilter;
}
export const EvaluationFormSearchFilter = S.suspend(() =>
  S.Struct({ AttributeFilter: S.optional(ControlPlaneAttributeFilter) }),
).annotate({
  identifier: "EvaluationFormSearchFilter",
}) as any as S.Schema<EvaluationFormSearchFilter>;
export interface SearchEvaluationFormsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchCriteria?: EvaluationFormSearchCriteria;
  SearchFilter?: EvaluationFormSearchFilter;
}
export const SearchEvaluationFormsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchCriteria: S.optional(EvaluationFormSearchCriteria),
    SearchFilter: S.optional(EvaluationFormSearchFilter),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-evaluation-forms" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchEvaluationFormsRequest",
}) as any as S.Schema<SearchEvaluationFormsRequest>;
export interface EvaluationFormSearchSummary {
  EvaluationFormId: string;
  EvaluationFormArn: string;
  Title: string;
  Status: EvaluationFormVersionStatus;
  Description?: string;
  CreatedTime: Date;
  CreatedBy: string;
  LastModifiedTime: Date;
  LastModifiedBy: string;
  LastActivatedTime?: Date;
  LastActivatedBy?: string;
  LatestVersion: number;
  ActiveVersion?: number;
  AutoEvaluationEnabled?: boolean;
  EvaluationFormLanguage?: EvaluationFormLanguageCode;
  ContactInteractionType?: ContactInteractionType;
  Tags?: { [key: string]: string | undefined };
}
export const EvaluationFormSearchSummary = S.suspend(() =>
  S.Struct({
    EvaluationFormId: S.String,
    EvaluationFormArn: S.String,
    Title: S.String,
    Status: EvaluationFormVersionStatus,
    Description: S.optional(S.String),
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    CreatedBy: S.String,
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastModifiedBy: S.String,
    LastActivatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastActivatedBy: S.optional(S.String),
    LatestVersion: S.Number,
    ActiveVersion: S.optional(S.Number),
    AutoEvaluationEnabled: S.optional(S.Boolean),
    EvaluationFormLanguage: S.optional(EvaluationFormLanguageCode),
    ContactInteractionType: S.optional(ContactInteractionType),
    Tags: S.optional(TagMap),
  }),
).annotate({
  identifier: "EvaluationFormSearchSummary",
}) as any as S.Schema<EvaluationFormSearchSummary>;
export type EvaluationFormSearchSummaryList = EvaluationFormSearchSummary[];
export const EvaluationFormSearchSummaryList = S.Array(
  EvaluationFormSearchSummary,
);
export interface SearchEvaluationFormsResponse {
  EvaluationFormSearchSummaryList?: EvaluationFormSearchSummary[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchEvaluationFormsResponse = S.suspend(() =>
  S.Struct({
    EvaluationFormSearchSummaryList: S.optional(
      EvaluationFormSearchSummaryList,
    ),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchEvaluationFormsResponse",
}) as any as S.Schema<SearchEvaluationFormsResponse>;
export interface HoursOfOperationSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
}
export const HoursOfOperationSearchFilter = S.suspend(() =>
  S.Struct({ TagFilter: S.optional(ControlPlaneTagFilter) }),
).annotate({
  identifier: "HoursOfOperationSearchFilter",
}) as any as S.Schema<HoursOfOperationSearchFilter>;
export type HoursOfOperationOverrideSearchConditionList =
  HoursOfOperationOverrideSearchCriteria[];
export const HoursOfOperationOverrideSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<HoursOfOperationOverrideSearchCriteria> =>
      HoursOfOperationOverrideSearchCriteria,
  ).annotate({ identifier: "HoursOfOperationOverrideSearchCriteria" }),
) as any as S.Schema<HoursOfOperationOverrideSearchConditionList>;
export type DateComparisonType =
  | "GREATER_THAN"
  | "LESS_THAN"
  | "GREATER_THAN_OR_EQUAL_TO"
  | "LESS_THAN_OR_EQUAL_TO"
  | "EQUAL_TO"
  | (string & {});
export const DateComparisonType = S.String;
export interface DateCondition {
  FieldName?: string;
  Value?: string;
  ComparisonType?: DateComparisonType;
}
export const DateCondition = S.suspend(() =>
  S.Struct({
    FieldName: S.optional(S.String),
    Value: S.optional(S.String),
    ComparisonType: S.optional(DateComparisonType),
  }),
).annotate({ identifier: "DateCondition" }) as any as S.Schema<DateCondition>;
export interface HoursOfOperationOverrideSearchCriteria {
  OrConditions?: HoursOfOperationOverrideSearchCriteria[];
  AndConditions?: HoursOfOperationOverrideSearchCriteria[];
  StringCondition?: StringCondition;
  DateCondition?: DateCondition;
}
export const HoursOfOperationOverrideSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => HoursOfOperationOverrideSearchConditionList).annotate({
        identifier: "HoursOfOperationOverrideSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => HoursOfOperationOverrideSearchConditionList).annotate({
        identifier: "HoursOfOperationOverrideSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
    DateCondition: S.optional(DateCondition),
  }),
).annotate({
  identifier: "HoursOfOperationOverrideSearchCriteria",
}) as any as S.Schema<HoursOfOperationOverrideSearchCriteria>;
export interface SearchHoursOfOperationOverridesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: HoursOfOperationSearchFilter;
  SearchCriteria?: HoursOfOperationOverrideSearchCriteria;
}
export const SearchHoursOfOperationOverridesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(HoursOfOperationSearchFilter),
    SearchCriteria: S.optional(HoursOfOperationOverrideSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-hours-of-operation-overrides" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchHoursOfOperationOverridesRequest",
}) as any as S.Schema<SearchHoursOfOperationOverridesRequest>;
export interface SearchHoursOfOperationOverridesResponse {
  HoursOfOperationOverrides?: HoursOfOperationOverride[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchHoursOfOperationOverridesResponse = S.suspend(() =>
  S.Struct({
    HoursOfOperationOverrides: S.optional(HoursOfOperationOverrideList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchHoursOfOperationOverridesResponse",
}) as any as S.Schema<SearchHoursOfOperationOverridesResponse>;
export type HoursOfOperationSearchConditionList =
  HoursOfOperationSearchCriteria[];
export const HoursOfOperationSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<HoursOfOperationSearchCriteria> =>
      HoursOfOperationSearchCriteria,
  ).annotate({ identifier: "HoursOfOperationSearchCriteria" }),
) as any as S.Schema<HoursOfOperationSearchConditionList>;
export interface HoursOfOperationSearchCriteria {
  OrConditions?: HoursOfOperationSearchCriteria[];
  AndConditions?: HoursOfOperationSearchCriteria[];
  StringCondition?: StringCondition;
}
export const HoursOfOperationSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => HoursOfOperationSearchConditionList).annotate({
        identifier: "HoursOfOperationSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => HoursOfOperationSearchConditionList).annotate({
        identifier: "HoursOfOperationSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotate({
  identifier: "HoursOfOperationSearchCriteria",
}) as any as S.Schema<HoursOfOperationSearchCriteria>;
export interface SearchHoursOfOperationsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: HoursOfOperationSearchFilter;
  SearchCriteria?: HoursOfOperationSearchCriteria;
}
export const SearchHoursOfOperationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(HoursOfOperationSearchFilter),
    SearchCriteria: S.optional(HoursOfOperationSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-hours-of-operations" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchHoursOfOperationsRequest",
}) as any as S.Schema<SearchHoursOfOperationsRequest>;
export type HoursOfOperationList = HoursOfOperation[];
export const HoursOfOperationList = S.Array(HoursOfOperation);
export interface SearchHoursOfOperationsResponse {
  HoursOfOperations?: HoursOfOperation[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchHoursOfOperationsResponse = S.suspend(() =>
  S.Struct({
    HoursOfOperations: S.optional(HoursOfOperationList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchHoursOfOperationsResponse",
}) as any as S.Schema<SearchHoursOfOperationsResponse>;
export interface NotificationSearchFilter {
  AttributeFilter?: ControlPlaneAttributeFilter;
}
export const NotificationSearchFilter = S.suspend(() =>
  S.Struct({ AttributeFilter: S.optional(ControlPlaneAttributeFilter) }),
).annotate({
  identifier: "NotificationSearchFilter",
}) as any as S.Schema<NotificationSearchFilter>;
export type NotificationSearchConditionList = NotificationSearchCriteria[];
export const NotificationSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<NotificationSearchCriteria> => NotificationSearchCriteria,
  ).annotate({ identifier: "NotificationSearchCriteria" }),
) as any as S.Schema<NotificationSearchConditionList>;
export interface NotificationSearchCriteria {
  OrConditions?: NotificationSearchCriteria[];
  AndConditions?: NotificationSearchCriteria[];
  StringCondition?: StringCondition;
}
export const NotificationSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => NotificationSearchConditionList).annotate({
        identifier: "NotificationSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => NotificationSearchConditionList).annotate({
        identifier: "NotificationSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotate({
  identifier: "NotificationSearchCriteria",
}) as any as S.Schema<NotificationSearchCriteria>;
export interface SearchNotificationsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: NotificationSearchFilter;
  SearchCriteria?: NotificationSearchCriteria;
}
export const SearchNotificationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(NotificationSearchFilter),
    SearchCriteria: S.optional(NotificationSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-notifications" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchNotificationsRequest",
}) as any as S.Schema<SearchNotificationsRequest>;
export interface NotificationSearchSummary {
  Id?: string;
  Arn?: string;
  InstanceId?: string;
  Content?: { [key: string]: string | undefined };
  Priority?: NotificationPriority;
  Recipients?: string[];
  CreatedAt?: Date;
  ExpiresAt?: Date;
  LastModifiedRegion?: string;
  LastModifiedTime?: Date;
  Tags?: { [key: string]: string | undefined };
}
export const NotificationSearchSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    InstanceId: S.optional(S.String),
    Content: S.optional(NotificationContent),
    Priority: S.optional(NotificationPriority),
    Recipients: S.optional(RecipientList),
    CreatedAt: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ExpiresAt: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedRegion: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    Tags: S.optional(TagMap),
  }),
).annotate({
  identifier: "NotificationSearchSummary",
}) as any as S.Schema<NotificationSearchSummary>;
export type NotificationSearchSummaryList = NotificationSearchSummary[];
export const NotificationSearchSummaryList = S.Array(NotificationSearchSummary);
export interface SearchNotificationsResponse {
  Notifications?: NotificationSearchSummary[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchNotificationsResponse = S.suspend(() =>
  S.Struct({
    Notifications: S.optional(NotificationSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchNotificationsResponse",
}) as any as S.Schema<SearchNotificationsResponse>;
export type PredefinedAttributeSearchConditionList =
  PredefinedAttributeSearchCriteria[];
export const PredefinedAttributeSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<PredefinedAttributeSearchCriteria> =>
      PredefinedAttributeSearchCriteria,
  ).annotate({ identifier: "PredefinedAttributeSearchCriteria" }),
) as any as S.Schema<PredefinedAttributeSearchConditionList>;
export interface PredefinedAttributeSearchCriteria {
  OrConditions?: PredefinedAttributeSearchCriteria[];
  AndConditions?: PredefinedAttributeSearchCriteria[];
  StringCondition?: StringCondition;
}
export const PredefinedAttributeSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => PredefinedAttributeSearchConditionList).annotate({
        identifier: "PredefinedAttributeSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => PredefinedAttributeSearchConditionList).annotate({
        identifier: "PredefinedAttributeSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotate({
  identifier: "PredefinedAttributeSearchCriteria",
}) as any as S.Schema<PredefinedAttributeSearchCriteria>;
export interface SearchPredefinedAttributesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchCriteria?: PredefinedAttributeSearchCriteria;
}
export const SearchPredefinedAttributesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchCriteria: S.optional(PredefinedAttributeSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-predefined-attributes" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchPredefinedAttributesRequest",
}) as any as S.Schema<SearchPredefinedAttributesRequest>;
export type PredefinedAttributeSearchSummaryList = PredefinedAttribute[];
export const PredefinedAttributeSearchSummaryList =
  S.Array(PredefinedAttribute);
export interface SearchPredefinedAttributesResponse {
  PredefinedAttributes?: PredefinedAttribute[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchPredefinedAttributesResponse = S.suspend(() =>
  S.Struct({
    PredefinedAttributes: S.optional(PredefinedAttributeSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchPredefinedAttributesResponse",
}) as any as S.Schema<SearchPredefinedAttributesResponse>;
export interface PromptSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
}
export const PromptSearchFilter = S.suspend(() =>
  S.Struct({ TagFilter: S.optional(ControlPlaneTagFilter) }),
).annotate({
  identifier: "PromptSearchFilter",
}) as any as S.Schema<PromptSearchFilter>;
export type PromptSearchConditionList = PromptSearchCriteria[];
export const PromptSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<PromptSearchCriteria> => PromptSearchCriteria,
  ).annotate({ identifier: "PromptSearchCriteria" }),
) as any as S.Schema<PromptSearchConditionList>;
export interface PromptSearchCriteria {
  OrConditions?: PromptSearchCriteria[];
  AndConditions?: PromptSearchCriteria[];
  StringCondition?: StringCondition;
}
export const PromptSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => PromptSearchConditionList).annotate({
        identifier: "PromptSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => PromptSearchConditionList).annotate({
        identifier: "PromptSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotate({
  identifier: "PromptSearchCriteria",
}) as any as S.Schema<PromptSearchCriteria>;
export interface SearchPromptsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: PromptSearchFilter;
  SearchCriteria?: PromptSearchCriteria;
}
export const SearchPromptsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(PromptSearchFilter),
    SearchCriteria: S.optional(PromptSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-prompts" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchPromptsRequest",
}) as any as S.Schema<SearchPromptsRequest>;
export type PromptList = Prompt[];
export const PromptList = S.Array(Prompt);
export interface SearchPromptsResponse {
  Prompts?: Prompt[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchPromptsResponse = S.suspend(() =>
  S.Struct({
    Prompts: S.optional(PromptList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchPromptsResponse",
}) as any as S.Schema<SearchPromptsResponse>;
export interface QueueSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
}
export const QueueSearchFilter = S.suspend(() =>
  S.Struct({ TagFilter: S.optional(ControlPlaneTagFilter) }),
).annotate({
  identifier: "QueueSearchFilter",
}) as any as S.Schema<QueueSearchFilter>;
export type QueueSearchConditionList = QueueSearchCriteria[];
export const QueueSearchConditionList = S.Array(
  S.suspend((): S.Schema<QueueSearchCriteria> => QueueSearchCriteria).annotate({
    identifier: "QueueSearchCriteria",
  }),
) as any as S.Schema<QueueSearchConditionList>;
export type SearchableQueueType = "STANDARD" | (string & {});
export const SearchableQueueType = S.String;
export interface QueueSearchCriteria {
  OrConditions?: QueueSearchCriteria[];
  AndConditions?: QueueSearchCriteria[];
  StringCondition?: StringCondition;
  QueueTypeCondition?: SearchableQueueType;
}
export const QueueSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => QueueSearchConditionList).annotate({
        identifier: "QueueSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => QueueSearchConditionList).annotate({
        identifier: "QueueSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
    QueueTypeCondition: S.optional(SearchableQueueType),
  }),
).annotate({
  identifier: "QueueSearchCriteria",
}) as any as S.Schema<QueueSearchCriteria>;
export interface SearchQueuesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: QueueSearchFilter;
  SearchCriteria?: QueueSearchCriteria;
}
export const SearchQueuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(QueueSearchFilter),
    SearchCriteria: S.optional(QueueSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-queues" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchQueuesRequest",
}) as any as S.Schema<SearchQueuesRequest>;
export type QueueSearchSummaryList = Queue[];
export const QueueSearchSummaryList = S.Array(Queue);
export interface SearchQueuesResponse {
  Queues?: Queue[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchQueuesResponse = S.suspend(() =>
  S.Struct({
    Queues: S.optional(QueueSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchQueuesResponse",
}) as any as S.Schema<SearchQueuesResponse>;
export interface QuickConnectSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
}
export const QuickConnectSearchFilter = S.suspend(() =>
  S.Struct({ TagFilter: S.optional(ControlPlaneTagFilter) }),
).annotate({
  identifier: "QuickConnectSearchFilter",
}) as any as S.Schema<QuickConnectSearchFilter>;
export type QuickConnectSearchConditionList = QuickConnectSearchCriteria[];
export const QuickConnectSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<QuickConnectSearchCriteria> => QuickConnectSearchCriteria,
  ).annotate({ identifier: "QuickConnectSearchCriteria" }),
) as any as S.Schema<QuickConnectSearchConditionList>;
export interface QuickConnectSearchCriteria {
  OrConditions?: QuickConnectSearchCriteria[];
  AndConditions?: QuickConnectSearchCriteria[];
  StringCondition?: StringCondition;
}
export const QuickConnectSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => QuickConnectSearchConditionList).annotate({
        identifier: "QuickConnectSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => QuickConnectSearchConditionList).annotate({
        identifier: "QuickConnectSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotate({
  identifier: "QuickConnectSearchCriteria",
}) as any as S.Schema<QuickConnectSearchCriteria>;
export interface SearchQuickConnectsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: QuickConnectSearchFilter;
  SearchCriteria?: QuickConnectSearchCriteria;
}
export const SearchQuickConnectsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(QuickConnectSearchFilter),
    SearchCriteria: S.optional(QuickConnectSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-quick-connects" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchQuickConnectsRequest",
}) as any as S.Schema<SearchQuickConnectsRequest>;
export type QuickConnectSearchSummaryList = QuickConnect[];
export const QuickConnectSearchSummaryList = S.Array(QuickConnect);
export interface SearchQuickConnectsResponse {
  QuickConnects?: QuickConnect[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchQuickConnectsResponse = S.suspend(() =>
  S.Struct({
    QuickConnects: S.optional(QuickConnectSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchQuickConnectsResponse",
}) as any as S.Schema<SearchQuickConnectsResponse>;
export type ResourceTypeList = string[];
export const ResourceTypeList = S.Array(S.String);
export interface TagSearchCondition {
  tagKey?: string;
  tagValue?: string;
  tagKeyComparisonType?: StringComparisonType;
  tagValueComparisonType?: StringComparisonType;
}
export const TagSearchCondition = S.suspend(() =>
  S.Struct({
    tagKey: S.optional(S.String),
    tagValue: S.optional(S.String),
    tagKeyComparisonType: S.optional(StringComparisonType),
    tagValueComparisonType: S.optional(StringComparisonType),
  }),
).annotate({
  identifier: "TagSearchCondition",
}) as any as S.Schema<TagSearchCondition>;
export interface ResourceTagsSearchCriteria {
  TagSearchCondition?: TagSearchCondition;
}
export const ResourceTagsSearchCriteria = S.suspend(() =>
  S.Struct({ TagSearchCondition: S.optional(TagSearchCondition) }),
).annotate({
  identifier: "ResourceTagsSearchCriteria",
}) as any as S.Schema<ResourceTagsSearchCriteria>;
export interface SearchResourceTagsRequest {
  InstanceId: string;
  ResourceTypes?: string[];
  NextToken?: string;
  MaxResults?: number;
  SearchCriteria?: ResourceTagsSearchCriteria;
}
export const SearchResourceTagsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ResourceTypes: S.optional(ResourceTypeList),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchCriteria: S.optional(ResourceTagsSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-resource-tags" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchResourceTagsRequest",
}) as any as S.Schema<SearchResourceTagsRequest>;
export interface TagSet {
  key?: string;
  value?: string;
}
export const TagSet = S.suspend(() =>
  S.Struct({ key: S.optional(S.String), value: S.optional(S.String) }),
).annotate({ identifier: "TagSet" }) as any as S.Schema<TagSet>;
export type TagsList = TagSet[];
export const TagsList = S.Array(TagSet);
export interface SearchResourceTagsResponse {
  Tags?: TagSet[];
  NextToken?: string;
}
export const SearchResourceTagsResponse = S.suspend(() =>
  S.Struct({ Tags: S.optional(TagsList), NextToken: S.optional(S.String) }),
).annotate({
  identifier: "SearchResourceTagsResponse",
}) as any as S.Schema<SearchResourceTagsResponse>;
export interface RoutingProfileSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
}
export const RoutingProfileSearchFilter = S.suspend(() =>
  S.Struct({ TagFilter: S.optional(ControlPlaneTagFilter) }),
).annotate({
  identifier: "RoutingProfileSearchFilter",
}) as any as S.Schema<RoutingProfileSearchFilter>;
export type RoutingProfileSearchConditionList = RoutingProfileSearchCriteria[];
export const RoutingProfileSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<RoutingProfileSearchCriteria> => RoutingProfileSearchCriteria,
  ).annotate({ identifier: "RoutingProfileSearchCriteria" }),
) as any as S.Schema<RoutingProfileSearchConditionList>;
export interface RoutingProfileSearchCriteria {
  OrConditions?: RoutingProfileSearchCriteria[];
  AndConditions?: RoutingProfileSearchCriteria[];
  StringCondition?: StringCondition;
}
export const RoutingProfileSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => RoutingProfileSearchConditionList).annotate({
        identifier: "RoutingProfileSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => RoutingProfileSearchConditionList).annotate({
        identifier: "RoutingProfileSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotate({
  identifier: "RoutingProfileSearchCriteria",
}) as any as S.Schema<RoutingProfileSearchCriteria>;
export interface SearchRoutingProfilesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: RoutingProfileSearchFilter;
  SearchCriteria?: RoutingProfileSearchCriteria;
}
export const SearchRoutingProfilesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(RoutingProfileSearchFilter),
    SearchCriteria: S.optional(RoutingProfileSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-routing-profiles" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchRoutingProfilesRequest",
}) as any as S.Schema<SearchRoutingProfilesRequest>;
export type RoutingProfileList = RoutingProfile[];
export const RoutingProfileList = S.Array(RoutingProfile);
export interface SearchRoutingProfilesResponse {
  RoutingProfiles?: RoutingProfile[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchRoutingProfilesResponse = S.suspend(() =>
  S.Struct({
    RoutingProfiles: S.optional(RoutingProfileList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchRoutingProfilesResponse",
}) as any as S.Schema<SearchRoutingProfilesResponse>;
export type SecurityProfileSearchConditionList =
  SecurityProfileSearchCriteria[];
export const SecurityProfileSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<SecurityProfileSearchCriteria> =>
      SecurityProfileSearchCriteria,
  ).annotate({ identifier: "SecurityProfileSearchCriteria" }),
) as any as S.Schema<SecurityProfileSearchConditionList>;
export interface SecurityProfileSearchCriteria {
  OrConditions?: SecurityProfileSearchCriteria[];
  AndConditions?: SecurityProfileSearchCriteria[];
  StringCondition?: StringCondition;
}
export const SecurityProfileSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => SecurityProfileSearchConditionList).annotate({
        identifier: "SecurityProfileSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => SecurityProfileSearchConditionList).annotate({
        identifier: "SecurityProfileSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotate({
  identifier: "SecurityProfileSearchCriteria",
}) as any as S.Schema<SecurityProfileSearchCriteria>;
export interface SecurityProfilesSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
}
export const SecurityProfilesSearchFilter = S.suspend(() =>
  S.Struct({ TagFilter: S.optional(ControlPlaneTagFilter) }),
).annotate({
  identifier: "SecurityProfilesSearchFilter",
}) as any as S.Schema<SecurityProfilesSearchFilter>;
export interface SearchSecurityProfilesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchCriteria?: SecurityProfileSearchCriteria;
  SearchFilter?: SecurityProfilesSearchFilter;
}
export const SearchSecurityProfilesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchCriteria: S.optional(SecurityProfileSearchCriteria),
    SearchFilter: S.optional(SecurityProfilesSearchFilter),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-security-profiles" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchSecurityProfilesRequest",
}) as any as S.Schema<SearchSecurityProfilesRequest>;
export interface SecurityProfileSearchSummary {
  Id?: string;
  OrganizationResourceId?: string;
  Arn?: string;
  SecurityProfileName?: string;
  Description?: string;
  Tags?: { [key: string]: string | undefined };
}
export const SecurityProfileSearchSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    OrganizationResourceId: S.optional(S.String),
    Arn: S.optional(S.String),
    SecurityProfileName: S.optional(S.String),
    Description: S.optional(S.String),
    Tags: S.optional(TagMap),
  }),
).annotate({
  identifier: "SecurityProfileSearchSummary",
}) as any as S.Schema<SecurityProfileSearchSummary>;
export type SecurityProfilesSearchSummaryList = SecurityProfileSearchSummary[];
export const SecurityProfilesSearchSummaryList = S.Array(
  SecurityProfileSearchSummary,
);
export interface SearchSecurityProfilesResponse {
  SecurityProfiles?: SecurityProfileSearchSummary[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchSecurityProfilesResponse = S.suspend(() =>
  S.Struct({
    SecurityProfiles: S.optional(SecurityProfilesSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchSecurityProfilesResponse",
}) as any as S.Schema<SearchSecurityProfilesResponse>;
export interface TestCaseSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
}
export const TestCaseSearchFilter = S.suspend(() =>
  S.Struct({ TagFilter: S.optional(ControlPlaneTagFilter) }),
).annotate({
  identifier: "TestCaseSearchFilter",
}) as any as S.Schema<TestCaseSearchFilter>;
export type TestCaseSearchConditionList = TestCaseSearchCriteria[];
export const TestCaseSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<TestCaseSearchCriteria> => TestCaseSearchCriteria,
  ).annotate({ identifier: "TestCaseSearchCriteria" }),
) as any as S.Schema<TestCaseSearchConditionList>;
export interface TestCaseSearchCriteria {
  OrConditions?: TestCaseSearchCriteria[];
  AndConditions?: TestCaseSearchCriteria[];
  StringCondition?: StringCondition;
  StatusCondition?: TestCaseStatus;
}
export const TestCaseSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => TestCaseSearchConditionList).annotate({
        identifier: "TestCaseSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => TestCaseSearchConditionList).annotate({
        identifier: "TestCaseSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
    StatusCondition: S.optional(TestCaseStatus),
  }),
).annotate({
  identifier: "TestCaseSearchCriteria",
}) as any as S.Schema<TestCaseSearchCriteria>;
export interface SearchTestCasesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: TestCaseSearchFilter;
  SearchCriteria?: TestCaseSearchCriteria;
}
export const SearchTestCasesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(TestCaseSearchFilter),
    SearchCriteria: S.optional(TestCaseSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-test-cases" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchTestCasesRequest",
}) as any as S.Schema<SearchTestCasesRequest>;
export type TestCaseSearchSummaryList = TestCase[];
export const TestCaseSearchSummaryList = S.Array(TestCase);
export interface SearchTestCasesResponse {
  TestCases?: TestCase[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchTestCasesResponse = S.suspend(() =>
  S.Struct({
    TestCases: S.optional(TestCaseSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchTestCasesResponse",
}) as any as S.Schema<SearchTestCasesResponse>;
export interface UserHierarchyGroupSearchFilter {
  AttributeFilter?: ControlPlaneAttributeFilter;
}
export const UserHierarchyGroupSearchFilter = S.suspend(() =>
  S.Struct({ AttributeFilter: S.optional(ControlPlaneAttributeFilter) }),
).annotate({
  identifier: "UserHierarchyGroupSearchFilter",
}) as any as S.Schema<UserHierarchyGroupSearchFilter>;
export type UserHierarchyGroupSearchConditionList =
  UserHierarchyGroupSearchCriteria[];
export const UserHierarchyGroupSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<UserHierarchyGroupSearchCriteria> =>
      UserHierarchyGroupSearchCriteria,
  ).annotate({ identifier: "UserHierarchyGroupSearchCriteria" }),
) as any as S.Schema<UserHierarchyGroupSearchConditionList>;
export interface UserHierarchyGroupSearchCriteria {
  OrConditions?: UserHierarchyGroupSearchCriteria[];
  AndConditions?: UserHierarchyGroupSearchCriteria[];
  StringCondition?: StringCondition;
}
export const UserHierarchyGroupSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => UserHierarchyGroupSearchConditionList).annotate({
        identifier: "UserHierarchyGroupSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => UserHierarchyGroupSearchConditionList).annotate({
        identifier: "UserHierarchyGroupSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotate({
  identifier: "UserHierarchyGroupSearchCriteria",
}) as any as S.Schema<UserHierarchyGroupSearchCriteria>;
export interface SearchUserHierarchyGroupsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: UserHierarchyGroupSearchFilter;
  SearchCriteria?: UserHierarchyGroupSearchCriteria;
}
export const SearchUserHierarchyGroupsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(UserHierarchyGroupSearchFilter),
    SearchCriteria: S.optional(UserHierarchyGroupSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-user-hierarchy-groups" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchUserHierarchyGroupsRequest",
}) as any as S.Schema<SearchUserHierarchyGroupsRequest>;
export type UserHierarchyGroupList = HierarchyGroup[];
export const UserHierarchyGroupList = S.Array(HierarchyGroup);
export interface SearchUserHierarchyGroupsResponse {
  UserHierarchyGroups?: HierarchyGroup[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchUserHierarchyGroupsResponse = S.suspend(() =>
  S.Struct({
    UserHierarchyGroups: S.optional(UserHierarchyGroupList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchUserHierarchyGroupsResponse",
}) as any as S.Schema<SearchUserHierarchyGroupsResponse>;
export type HierarchyGroupMatchType =
  | "EXACT"
  | "WITH_CHILD_GROUPS"
  | (string & {});
export const HierarchyGroupMatchType = S.String;
export interface HierarchyGroupCondition {
  Value?: string;
  HierarchyGroupMatchType?: HierarchyGroupMatchType;
}
export const HierarchyGroupCondition = S.suspend(() =>
  S.Struct({
    Value: S.optional(S.String),
    HierarchyGroupMatchType: S.optional(HierarchyGroupMatchType),
  }),
).annotate({
  identifier: "HierarchyGroupCondition",
}) as any as S.Schema<HierarchyGroupCondition>;
export interface AttributeAndCondition {
  TagConditions?: TagCondition[];
  HierarchyGroupCondition?: HierarchyGroupCondition;
}
export const AttributeAndCondition = S.suspend(() =>
  S.Struct({
    TagConditions: S.optional(TagAndConditionList),
    HierarchyGroupCondition: S.optional(HierarchyGroupCondition),
  }),
).annotate({
  identifier: "AttributeAndCondition",
}) as any as S.Schema<AttributeAndCondition>;
export type AttributeOrConditionList = AttributeAndCondition[];
export const AttributeOrConditionList = S.Array(AttributeAndCondition);
export interface ControlPlaneUserAttributeFilter {
  OrConditions?: AttributeAndCondition[];
  AndCondition?: AttributeAndCondition;
  TagCondition?: TagCondition;
  HierarchyGroupCondition?: HierarchyGroupCondition;
}
export const ControlPlaneUserAttributeFilter = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(AttributeOrConditionList),
    AndCondition: S.optional(AttributeAndCondition),
    TagCondition: S.optional(TagCondition),
    HierarchyGroupCondition: S.optional(HierarchyGroupCondition),
  }),
).annotate({
  identifier: "ControlPlaneUserAttributeFilter",
}) as any as S.Schema<ControlPlaneUserAttributeFilter>;
export interface UserSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
  UserAttributeFilter?: ControlPlaneUserAttributeFilter;
}
export const UserSearchFilter = S.suspend(() =>
  S.Struct({
    TagFilter: S.optional(ControlPlaneTagFilter),
    UserAttributeFilter: S.optional(ControlPlaneUserAttributeFilter),
  }),
).annotate({
  identifier: "UserSearchFilter",
}) as any as S.Schema<UserSearchFilter>;
export type UserSearchConditionList = UserSearchCriteria[];
export const UserSearchConditionList = S.Array(
  S.suspend((): S.Schema<UserSearchCriteria> => UserSearchCriteria).annotate({
    identifier: "UserSearchCriteria",
  }),
) as any as S.Schema<UserSearchConditionList>;
export type TargetListType = "PROFICIENCIES" | (string & {});
export const TargetListType = S.String;
export interface Condition {
  StringCondition?: StringCondition;
  NumberCondition?: NumberCondition;
}
export const Condition = S.suspend(() =>
  S.Struct({
    StringCondition: S.optional(StringCondition),
    NumberCondition: S.optional(NumberCondition),
  }),
).annotate({ identifier: "Condition" }) as any as S.Schema<Condition>;
export type Conditions = Condition[];
export const Conditions = S.Array(Condition);
export interface ListCondition {
  TargetListType?: TargetListType;
  Conditions?: Condition[];
}
export const ListCondition = S.suspend(() =>
  S.Struct({
    TargetListType: S.optional(TargetListType),
    Conditions: S.optional(Conditions),
  }),
).annotate({ identifier: "ListCondition" }) as any as S.Schema<ListCondition>;
export interface UserSearchCriteria {
  OrConditions?: UserSearchCriteria[];
  AndConditions?: UserSearchCriteria[];
  StringCondition?: StringCondition;
  ListCondition?: ListCondition;
  HierarchyGroupCondition?: HierarchyGroupCondition;
}
export const UserSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => UserSearchConditionList).annotate({
        identifier: "UserSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => UserSearchConditionList).annotate({
        identifier: "UserSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
    ListCondition: S.optional(ListCondition),
    HierarchyGroupCondition: S.optional(HierarchyGroupCondition),
  }),
).annotate({
  identifier: "UserSearchCriteria",
}) as any as S.Schema<UserSearchCriteria>;
export interface SearchUsersRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: UserSearchFilter;
  SearchCriteria?: UserSearchCriteria;
}
export const SearchUsersRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(UserSearchFilter),
    SearchCriteria: S.optional(UserSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-users" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchUsersRequest",
}) as any as S.Schema<SearchUsersRequest>;
export interface UserIdentityInfoLite {
  FirstName?: string | redacted.Redacted<string>;
  LastName?: string | redacted.Redacted<string>;
}
export const UserIdentityInfoLite = S.suspend(() =>
  S.Struct({
    FirstName: S.optional(SensitiveString),
    LastName: S.optional(SensitiveString),
  }),
).annotate({
  identifier: "UserIdentityInfoLite",
}) as any as S.Schema<UserIdentityInfoLite>;
export interface UserSearchSummary {
  Arn?: string;
  DirectoryUserId?: string;
  HierarchyGroupId?: string;
  Id?: string;
  IdentityInfo?: UserIdentityInfoLite;
  PhoneConfig?: UserPhoneConfig;
  RoutingProfileId?: string;
  SecurityProfileIds?: string[];
  Tags?: { [key: string]: string | undefined };
  Username?: string;
  AutoAcceptConfigs?: AutoAcceptConfig[];
  AfterContactWorkConfigs?: AfterContactWorkConfigPerChannel[];
  PhoneNumberConfigs?: PhoneNumberConfig[];
  PersistentConnectionConfigs?: PersistentConnectionConfig[];
  VoiceEnhancementConfigs?: VoiceEnhancementConfig[];
}
export const UserSearchSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    DirectoryUserId: S.optional(S.String),
    HierarchyGroupId: S.optional(S.String),
    Id: S.optional(S.String),
    IdentityInfo: S.optional(UserIdentityInfoLite),
    PhoneConfig: S.optional(UserPhoneConfig),
    RoutingProfileId: S.optional(S.String),
    SecurityProfileIds: S.optional(SecurityProfileIds),
    Tags: S.optional(TagMap),
    Username: S.optional(S.String),
    AutoAcceptConfigs: S.optional(AutoAcceptConfigs),
    AfterContactWorkConfigs: S.optional(AfterContactWorkConfigs),
    PhoneNumberConfigs: S.optional(PhoneNumberConfigs),
    PersistentConnectionConfigs: S.optional(PersistentConnectionConfigs),
    VoiceEnhancementConfigs: S.optional(VoiceEnhancementConfigs),
  }),
).annotate({
  identifier: "UserSearchSummary",
}) as any as S.Schema<UserSearchSummary>;
export type UserSearchSummaryList = UserSearchSummary[];
export const UserSearchSummaryList = S.Array(UserSearchSummary);
export interface SearchUsersResponse {
  Users?: UserSearchSummary[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchUsersResponse = S.suspend(() =>
  S.Struct({
    Users: S.optional(UserSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchUsersResponse",
}) as any as S.Schema<SearchUsersResponse>;
export interface ViewSearchFilter {
  AttributeFilter?: ControlPlaneAttributeFilter;
}
export const ViewSearchFilter = S.suspend(() =>
  S.Struct({ AttributeFilter: S.optional(ControlPlaneAttributeFilter) }),
).annotate({
  identifier: "ViewSearchFilter",
}) as any as S.Schema<ViewSearchFilter>;
export type ViewSearchConditionList = ViewSearchCriteria[];
export const ViewSearchConditionList = S.Array(
  S.suspend((): S.Schema<ViewSearchCriteria> => ViewSearchCriteria).annotate({
    identifier: "ViewSearchCriteria",
  }),
) as any as S.Schema<ViewSearchConditionList>;
export interface ViewSearchCriteria {
  OrConditions?: ViewSearchCriteria[];
  AndConditions?: ViewSearchCriteria[];
  StringCondition?: StringCondition;
  ViewTypeCondition?: ViewType;
  ViewStatusCondition?: ViewStatus;
}
export const ViewSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => ViewSearchConditionList).annotate({
        identifier: "ViewSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => ViewSearchConditionList).annotate({
        identifier: "ViewSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
    ViewTypeCondition: S.optional(ViewType),
    ViewStatusCondition: S.optional(ViewStatus),
  }),
).annotate({
  identifier: "ViewSearchCriteria",
}) as any as S.Schema<ViewSearchCriteria>;
export interface SearchViewsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: ViewSearchFilter;
  SearchCriteria?: ViewSearchCriteria;
}
export const SearchViewsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(ViewSearchFilter),
    SearchCriteria: S.optional(ViewSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-views" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchViewsRequest",
}) as any as S.Schema<SearchViewsRequest>;
export type ViewSearchSummaryList = View[];
export const ViewSearchSummaryList = S.Array(View);
export interface SearchViewsResponse {
  Views?: View[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchViewsResponse = S.suspend(() =>
  S.Struct({
    Views: S.optional(ViewSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchViewsResponse",
}) as any as S.Schema<SearchViewsResponse>;
export interface SearchVocabulariesRequest {
  InstanceId: string;
  MaxResults?: number;
  NextToken?: string;
  State?: VocabularyState;
  NameStartsWith?: string;
  LanguageCode?: VocabularyLanguageCode;
}
export const SearchVocabulariesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    State: S.optional(VocabularyState),
    NameStartsWith: S.optional(S.String),
    LanguageCode: S.optional(VocabularyLanguageCode),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/vocabulary-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchVocabulariesRequest",
}) as any as S.Schema<SearchVocabulariesRequest>;
export interface VocabularySummary {
  Name: string;
  Id: string;
  Arn: string;
  LanguageCode: VocabularyLanguageCode;
  State: VocabularyState;
  LastModifiedTime: Date;
  FailureReason?: string;
}
export const VocabularySummary = S.suspend(() =>
  S.Struct({
    Name: S.String,
    Id: S.String,
    Arn: S.String,
    LanguageCode: VocabularyLanguageCode,
    State: VocabularyState,
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    FailureReason: S.optional(S.String),
  }),
).annotate({
  identifier: "VocabularySummary",
}) as any as S.Schema<VocabularySummary>;
export type VocabularySummaryList = VocabularySummary[];
export const VocabularySummaryList = S.Array(VocabularySummary);
export interface SearchVocabulariesResponse {
  VocabularySummaryList?: VocabularySummary[];
  NextToken?: string;
}
export const SearchVocabulariesResponse = S.suspend(() =>
  S.Struct({
    VocabularySummaryList: S.optional(VocabularySummaryList),
    NextToken: S.optional(S.String),
  }),
).annotate({
  identifier: "SearchVocabulariesResponse",
}) as any as S.Schema<SearchVocabulariesResponse>;
export interface WorkspaceAssociationSearchFilter {
  AttributeFilter?: ControlPlaneAttributeFilter;
}
export const WorkspaceAssociationSearchFilter = S.suspend(() =>
  S.Struct({ AttributeFilter: S.optional(ControlPlaneAttributeFilter) }),
).annotate({
  identifier: "WorkspaceAssociationSearchFilter",
}) as any as S.Schema<WorkspaceAssociationSearchFilter>;
export type WorkspaceAssociationSearchConditionList =
  WorkspaceAssociationSearchCriteria[];
export const WorkspaceAssociationSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<WorkspaceAssociationSearchCriteria> =>
      WorkspaceAssociationSearchCriteria,
  ).annotate({ identifier: "WorkspaceAssociationSearchCriteria" }),
) as any as S.Schema<WorkspaceAssociationSearchConditionList>;
export interface WorkspaceAssociationSearchCriteria {
  OrConditions?: WorkspaceAssociationSearchCriteria[];
  AndConditions?: WorkspaceAssociationSearchCriteria[];
  StringCondition?: StringCondition;
}
export const WorkspaceAssociationSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => WorkspaceAssociationSearchConditionList).annotate({
        identifier: "WorkspaceAssociationSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => WorkspaceAssociationSearchConditionList).annotate({
        identifier: "WorkspaceAssociationSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotate({
  identifier: "WorkspaceAssociationSearchCriteria",
}) as any as S.Schema<WorkspaceAssociationSearchCriteria>;
export interface SearchWorkspaceAssociationsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: WorkspaceAssociationSearchFilter;
  SearchCriteria?: WorkspaceAssociationSearchCriteria;
}
export const SearchWorkspaceAssociationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(WorkspaceAssociationSearchFilter),
    SearchCriteria: S.optional(WorkspaceAssociationSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-workspace-associations" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchWorkspaceAssociationsRequest",
}) as any as S.Schema<SearchWorkspaceAssociationsRequest>;
export interface WorkspaceAssociationSearchSummary {
  WorkspaceId?: string;
  WorkspaceArn?: string;
  ResourceId?: string;
  ResourceArn?: string;
  ResourceType?: string;
  ResourceName?: string;
}
export const WorkspaceAssociationSearchSummary = S.suspend(() =>
  S.Struct({
    WorkspaceId: S.optional(S.String),
    WorkspaceArn: S.optional(S.String),
    ResourceId: S.optional(S.String),
    ResourceArn: S.optional(S.String),
    ResourceType: S.optional(S.String),
    ResourceName: S.optional(S.String),
  }),
).annotate({
  identifier: "WorkspaceAssociationSearchSummary",
}) as any as S.Schema<WorkspaceAssociationSearchSummary>;
export type WorkspaceAssociationSearchSummaryList =
  WorkspaceAssociationSearchSummary[];
export const WorkspaceAssociationSearchSummaryList = S.Array(
  WorkspaceAssociationSearchSummary,
);
export interface SearchWorkspaceAssociationsResponse {
  NextToken?: string;
  WorkspaceAssociations?: WorkspaceAssociationSearchSummary[];
  ApproximateTotalCount?: number;
}
export const SearchWorkspaceAssociationsResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    WorkspaceAssociations: S.optional(WorkspaceAssociationSearchSummaryList),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchWorkspaceAssociationsResponse",
}) as any as S.Schema<SearchWorkspaceAssociationsResponse>;
export interface WorkspaceSearchFilter {
  AttributeFilter?: ControlPlaneAttributeFilter;
}
export const WorkspaceSearchFilter = S.suspend(() =>
  S.Struct({ AttributeFilter: S.optional(ControlPlaneAttributeFilter) }),
).annotate({
  identifier: "WorkspaceSearchFilter",
}) as any as S.Schema<WorkspaceSearchFilter>;
export type WorkspaceSearchConditionList = WorkspaceSearchCriteria[];
export const WorkspaceSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<WorkspaceSearchCriteria> => WorkspaceSearchCriteria,
  ).annotate({ identifier: "WorkspaceSearchCriteria" }),
) as any as S.Schema<WorkspaceSearchConditionList>;
export interface WorkspaceSearchCriteria {
  OrConditions?: WorkspaceSearchCriteria[];
  AndConditions?: WorkspaceSearchCriteria[];
  StringCondition?: StringCondition;
}
export const WorkspaceSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => WorkspaceSearchConditionList).annotate({
        identifier: "WorkspaceSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => WorkspaceSearchConditionList).annotate({
        identifier: "WorkspaceSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotate({
  identifier: "WorkspaceSearchCriteria",
}) as any as S.Schema<WorkspaceSearchCriteria>;
export interface SearchWorkspacesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: WorkspaceSearchFilter;
  SearchCriteria?: WorkspaceSearchCriteria;
}
export const SearchWorkspacesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(WorkspaceSearchFilter),
    SearchCriteria: S.optional(WorkspaceSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-workspaces" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SearchWorkspacesRequest",
}) as any as S.Schema<SearchWorkspacesRequest>;
export interface WorkspaceSearchSummary {
  Id?: string;
  Name?: string;
  Visibility?: Visibility;
  Description?: string;
  Title?: string;
  Arn?: string;
  CreatedAt?: Date;
  Tags?: { [key: string]: string | undefined };
}
export const WorkspaceSearchSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Name: S.optional(S.String),
    Visibility: S.optional(Visibility),
    Description: S.optional(S.String),
    Title: S.optional(S.String),
    Arn: S.optional(S.String),
    CreatedAt: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Tags: S.optional(TagMap),
  }),
).annotate({
  identifier: "WorkspaceSearchSummary",
}) as any as S.Schema<WorkspaceSearchSummary>;
export type WorkspaceSearchSummaryList = WorkspaceSearchSummary[];
export const WorkspaceSearchSummaryList = S.Array(WorkspaceSearchSummary);
export interface SearchWorkspacesResponse {
  NextToken?: string;
  Workspaces?: WorkspaceSearchSummary[];
  ApproximateTotalCount?: number;
}
export const SearchWorkspacesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    Workspaces: S.optional(WorkspaceSearchSummaryList),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotate({
  identifier: "SearchWorkspacesResponse",
}) as any as S.Schema<SearchWorkspacesResponse>;
export type ChatEventType = "DISCONNECT" | "MESSAGE" | "EVENT" | (string & {});
export const ChatEventType = S.String;
export interface ChatEvent {
  Type: ChatEventType;
  ContentType?: string;
  Content?: string;
}
export const ChatEvent = S.suspend(() =>
  S.Struct({
    Type: ChatEventType,
    ContentType: S.optional(S.String),
    Content: S.optional(S.String),
  }),
).annotate({ identifier: "ChatEvent" }) as any as S.Schema<ChatEvent>;
export type SupportedMessagingContentTypes = string[];
export const SupportedMessagingContentTypes = S.Array(S.String);
export interface ParticipantDetails {
  DisplayName: string;
}
export const ParticipantDetails = S.suspend(() =>
  S.Struct({ DisplayName: S.String }),
).annotate({
  identifier: "ParticipantDetails",
}) as any as S.Schema<ParticipantDetails>;
export interface ChatStreamingConfiguration {
  StreamingEndpointArn: string;
}
export const ChatStreamingConfiguration = S.suspend(() =>
  S.Struct({ StreamingEndpointArn: S.String }),
).annotate({
  identifier: "ChatStreamingConfiguration",
}) as any as S.Schema<ChatStreamingConfiguration>;
export interface NewSessionDetails {
  SupportedMessagingContentTypes?: string[];
  ParticipantDetails?: ParticipantDetails;
  Attributes?: { [key: string]: string | undefined };
  StreamingConfiguration?: ChatStreamingConfiguration;
}
export const NewSessionDetails = S.suspend(() =>
  S.Struct({
    SupportedMessagingContentTypes: S.optional(SupportedMessagingContentTypes),
    ParticipantDetails: S.optional(ParticipantDetails),
    Attributes: S.optional(Attributes),
    StreamingConfiguration: S.optional(ChatStreamingConfiguration),
  }),
).annotate({
  identifier: "NewSessionDetails",
}) as any as S.Schema<NewSessionDetails>;
export interface SendChatIntegrationEventRequest {
  SourceId: string;
  DestinationId: string;
  Subtype?: string;
  Event: ChatEvent;
  NewSessionDetails?: NewSessionDetails;
}
export const SendChatIntegrationEventRequest = S.suspend(() =>
  S.Struct({
    SourceId: S.String,
    DestinationId: S.String,
    Subtype: S.optional(S.String),
    Event: ChatEvent,
    NewSessionDetails: S.optional(NewSessionDetails),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/chat-integration-event" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SendChatIntegrationEventRequest",
}) as any as S.Schema<SendChatIntegrationEventRequest>;
export interface SendChatIntegrationEventResponse {
  InitialContactId?: string;
  NewChatCreated?: boolean;
}
export const SendChatIntegrationEventResponse = S.suspend(() =>
  S.Struct({
    InitialContactId: S.optional(S.String),
    NewChatCreated: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "SendChatIntegrationEventResponse",
}) as any as S.Schema<SendChatIntegrationEventResponse>;
export interface EmailAddressInfo {
  EmailAddress: string | redacted.Redacted<string>;
  DisplayName?: string | redacted.Redacted<string>;
}
export const EmailAddressInfo = S.suspend(() =>
  S.Struct({
    EmailAddress: SensitiveString,
    DisplayName: S.optional(SensitiveString),
  }),
).annotate({
  identifier: "EmailAddressInfo",
}) as any as S.Schema<EmailAddressInfo>;
export type EmailAddressRecipientList = EmailAddressInfo[];
export const EmailAddressRecipientList = S.Array(EmailAddressInfo);
export interface OutboundAdditionalRecipients {
  CcEmailAddresses?: EmailAddressInfo[];
}
export const OutboundAdditionalRecipients = S.suspend(() =>
  S.Struct({ CcEmailAddresses: S.optional(EmailAddressRecipientList) }),
).annotate({
  identifier: "OutboundAdditionalRecipients",
}) as any as S.Schema<OutboundAdditionalRecipients>;
export type OutboundMessageSourceType = "TEMPLATE" | "RAW" | (string & {});
export const OutboundMessageSourceType = S.String;
export interface TemplateAttributes {
  CustomAttributes?: { [key: string]: string | undefined };
  CustomerProfileAttributes?: string;
}
export const TemplateAttributes = S.suspend(() =>
  S.Struct({
    CustomAttributes: S.optional(Attributes),
    CustomerProfileAttributes: S.optional(S.String),
  }),
).annotate({
  identifier: "TemplateAttributes",
}) as any as S.Schema<TemplateAttributes>;
export interface TemplatedMessageConfig {
  KnowledgeBaseId: string;
  MessageTemplateId: string;
  TemplateAttributes: TemplateAttributes;
}
export const TemplatedMessageConfig = S.suspend(() =>
  S.Struct({
    KnowledgeBaseId: S.String,
    MessageTemplateId: S.String,
    TemplateAttributes: TemplateAttributes,
  }),
).annotate({
  identifier: "TemplatedMessageConfig",
}) as any as S.Schema<TemplatedMessageConfig>;
export interface OutboundRawMessage {
  Subject: string | redacted.Redacted<string>;
  Body: string | redacted.Redacted<string>;
  ContentType: string;
}
export const OutboundRawMessage = S.suspend(() =>
  S.Struct({
    Subject: SensitiveString,
    Body: SensitiveString,
    ContentType: S.String,
  }),
).annotate({
  identifier: "OutboundRawMessage",
}) as any as S.Schema<OutboundRawMessage>;
export interface OutboundEmailContent {
  MessageSourceType: OutboundMessageSourceType;
  TemplatedMessageConfig?: TemplatedMessageConfig;
  RawMessage?: OutboundRawMessage;
}
export const OutboundEmailContent = S.suspend(() =>
  S.Struct({
    MessageSourceType: OutboundMessageSourceType,
    TemplatedMessageConfig: S.optional(TemplatedMessageConfig),
    RawMessage: S.optional(OutboundRawMessage),
  }),
).annotate({
  identifier: "OutboundEmailContent",
}) as any as S.Schema<OutboundEmailContent>;
export type TrafficType = "GENERAL" | "CAMPAIGN" | (string & {});
export const TrafficType = S.String;
export interface SourceCampaign {
  CampaignId?: string;
  OutboundRequestId?: string;
}
export const SourceCampaign = S.suspend(() =>
  S.Struct({
    CampaignId: S.optional(S.String),
    OutboundRequestId: S.optional(S.String),
  }),
).annotate({ identifier: "SourceCampaign" }) as any as S.Schema<SourceCampaign>;
export interface SendOutboundEmailRequest {
  InstanceId: string;
  FromEmailAddress: EmailAddressInfo;
  DestinationEmailAddress: EmailAddressInfo;
  AdditionalRecipients?: OutboundAdditionalRecipients;
  EmailMessage: OutboundEmailContent;
  TrafficType: TrafficType;
  SourceCampaign?: SourceCampaign;
  ClientToken?: string;
}
export const SendOutboundEmailRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    FromEmailAddress: EmailAddressInfo,
    DestinationEmailAddress: EmailAddressInfo,
    AdditionalRecipients: S.optional(OutboundAdditionalRecipients),
    EmailMessage: OutboundEmailContent,
    TrafficType: TrafficType,
    SourceCampaign: S.optional(SourceCampaign),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/instance/{InstanceId}/outbound-email" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SendOutboundEmailRequest",
}) as any as S.Schema<SendOutboundEmailRequest>;
export interface SendOutboundEmailResponse {}
export const SendOutboundEmailResponse = S.suspend(() => S.Struct({})).annotate(
  { identifier: "SendOutboundEmailResponse" },
) as any as S.Schema<SendOutboundEmailResponse>;
export interface StartAttachedFileUploadRequest {
  ClientToken?: string;
  InstanceId: string;
  FileName: string;
  FileSizeInBytes: number;
  UrlExpiryInSeconds?: number;
  FileUseCaseType: FileUseCaseType;
  AssociatedResourceArn: string;
  CreatedBy?: CreatedByInfo;
  Tags?: { [key: string]: string | undefined };
}
export const StartAttachedFileUploadRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    FileName: S.String,
    FileSizeInBytes: S.Number,
    UrlExpiryInSeconds: S.optional(S.Number),
    FileUseCaseType: FileUseCaseType,
    AssociatedResourceArn: S.String.pipe(T.HttpQuery("associatedResourceArn")),
    CreatedBy: S.optional(CreatedByInfo),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/attached-files/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartAttachedFileUploadRequest",
}) as any as S.Schema<StartAttachedFileUploadRequest>;
export type UrlMetadataSignedHeaders = { [key: string]: string | undefined };
export const UrlMetadataSignedHeaders = S.Record(
  S.String,
  S.String.pipe(S.optional),
);
export interface UploadUrlMetadata {
  Url?: string;
  UrlExpiry?: string;
  HeadersToInclude?: { [key: string]: string | undefined };
}
export const UploadUrlMetadata = S.suspend(() =>
  S.Struct({
    Url: S.optional(S.String),
    UrlExpiry: S.optional(S.String),
    HeadersToInclude: S.optional(UrlMetadataSignedHeaders),
  }),
).annotate({
  identifier: "UploadUrlMetadata",
}) as any as S.Schema<UploadUrlMetadata>;
export interface StartAttachedFileUploadResponse {
  FileArn?: string;
  FileId?: string;
  CreationTime?: string;
  FileStatus?: FileStatusType;
  CreatedBy?: CreatedByInfo;
  UploadUrlMetadata?: UploadUrlMetadata;
}
export const StartAttachedFileUploadResponse = S.suspend(() =>
  S.Struct({
    FileArn: S.optional(S.String),
    FileId: S.optional(S.String),
    CreationTime: S.optional(S.String),
    FileStatus: S.optional(FileStatusType),
    CreatedBy: S.optional(CreatedByInfo),
    UploadUrlMetadata: S.optional(UploadUrlMetadata),
  }),
).annotate({
  identifier: "StartAttachedFileUploadResponse",
}) as any as S.Schema<StartAttachedFileUploadResponse>;
export type ResponseMode = "INCREMENTAL" | "COMPLETE" | (string & {});
export const ResponseMode = S.String;
export interface ParticipantConfiguration {
  ResponseMode?: ResponseMode;
}
export const ParticipantConfiguration = S.suspend(() =>
  S.Struct({ ResponseMode: S.optional(ResponseMode) }),
).annotate({
  identifier: "ParticipantConfiguration",
}) as any as S.Schema<ParticipantConfiguration>;
export interface ChatMessage {
  ContentType: string;
  Content: string;
}
export const ChatMessage = S.suspend(() =>
  S.Struct({ ContentType: S.String, Content: S.String }),
).annotate({ identifier: "ChatMessage" }) as any as S.Schema<ChatMessage>;
export interface PersistentChat {
  RehydrationType?: RehydrationType;
  SourceContactId?: string;
}
export const PersistentChat = S.suspend(() =>
  S.Struct({
    RehydrationType: S.optional(RehydrationType),
    SourceContactId: S.optional(S.String),
  }),
).annotate({ identifier: "PersistentChat" }) as any as S.Schema<PersistentChat>;
export type DisconnectOnCustomerExitParticipantType = "AGENT" | (string & {});
export const DisconnectOnCustomerExitParticipantType = S.String;
export type DisconnectOnCustomerExit =
  DisconnectOnCustomerExitParticipantType[];
export const DisconnectOnCustomerExit = S.Array(
  DisconnectOnCustomerExitParticipantType,
);
export interface StartChatContactRequest {
  InstanceId: string;
  ContactFlowId: string;
  Attributes?: { [key: string]: string | undefined };
  ParticipantDetails: ParticipantDetails;
  ParticipantConfiguration?: ParticipantConfiguration;
  InitialMessage?: ChatMessage;
  ClientToken?: string;
  ChatDurationInMinutes?: number;
  SupportedMessagingContentTypes?: string[];
  PersistentChat?: PersistentChat;
  RelatedContactId?: string;
  SegmentAttributes?: { [key: string]: SegmentAttributeValue | undefined };
  CustomerId?: string | redacted.Redacted<string>;
  DisconnectOnCustomerExit?: DisconnectOnCustomerExitParticipantType[];
}
export const StartChatContactRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactFlowId: S.String,
    Attributes: S.optional(Attributes),
    ParticipantDetails: ParticipantDetails,
    ParticipantConfiguration: S.optional(ParticipantConfiguration),
    InitialMessage: S.optional(ChatMessage),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    ChatDurationInMinutes: S.optional(S.Number),
    SupportedMessagingContentTypes: S.optional(SupportedMessagingContentTypes),
    PersistentChat: S.optional(PersistentChat),
    RelatedContactId: S.optional(S.String),
    SegmentAttributes: S.optional(SegmentAttributes),
    CustomerId: S.optional(SensitiveString),
    DisconnectOnCustomerExit: S.optional(DisconnectOnCustomerExit),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/chat" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartChatContactRequest",
}) as any as S.Schema<StartChatContactRequest>;
export interface StartChatContactResponse {
  ContactId?: string;
  ParticipantId?: string;
  ParticipantToken?: string;
  ContinuedFromContactId?: string;
}
export const StartChatContactResponse = S.suspend(() =>
  S.Struct({
    ContactId: S.optional(S.String),
    ParticipantId: S.optional(S.String),
    ParticipantToken: S.optional(S.String),
    ContinuedFromContactId: S.optional(S.String),
  }),
).annotate({
  identifier: "StartChatContactResponse",
}) as any as S.Schema<StartChatContactResponse>;
export interface AutoEvaluationConfiguration {
  Enabled: boolean;
}
export const AutoEvaluationConfiguration = S.suspend(() =>
  S.Struct({ Enabled: S.Boolean }),
).annotate({
  identifier: "AutoEvaluationConfiguration",
}) as any as S.Schema<AutoEvaluationConfiguration>;
export interface StartContactEvaluationRequest {
  InstanceId: string;
  ContactId: string;
  EvaluationFormId: string;
  AutoEvaluationConfiguration?: AutoEvaluationConfiguration;
  ClientToken?: string;
  Tags?: { [key: string]: string | undefined };
}
export const StartContactEvaluationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String,
    EvaluationFormId: S.String,
    AutoEvaluationConfiguration: S.optional(AutoEvaluationConfiguration),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact-evaluations/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartContactEvaluationRequest",
}) as any as S.Schema<StartContactEvaluationRequest>;
export interface StartContactEvaluationResponse {
  EvaluationId: string;
  EvaluationArn: string;
}
export const StartContactEvaluationResponse = S.suspend(() =>
  S.Struct({ EvaluationId: S.String, EvaluationArn: S.String }),
).annotate({
  identifier: "StartContactEvaluationResponse",
}) as any as S.Schema<StartContactEvaluationResponse>;
export type ContactMediaProcessingFailureMode =
  | "DELIVER_UNPROCESSED_MESSAGE"
  | "DO_NOT_DELIVER_UNPROCESSED_MESSAGE"
  | (string & {});
export const ContactMediaProcessingFailureMode = S.String;
export interface StartContactMediaProcessingRequest {
  InstanceId?: string;
  ContactId?: string;
  ProcessorArn?: string;
  FailureMode?: ContactMediaProcessingFailureMode;
}
export const StartContactMediaProcessingRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    ContactId: S.optional(S.String),
    ProcessorArn: S.optional(S.String),
    FailureMode: S.optional(ContactMediaProcessingFailureMode),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact/start-contact-media-processing",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartContactMediaProcessingRequest",
}) as any as S.Schema<StartContactMediaProcessingRequest>;
export interface StartContactMediaProcessingResponse {}
export const StartContactMediaProcessingResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "StartContactMediaProcessingResponse",
}) as any as S.Schema<StartContactMediaProcessingResponse>;
export type VoiceRecordingTrack =
  | "FROM_AGENT"
  | "TO_AGENT"
  | "ALL"
  | (string & {});
export const VoiceRecordingTrack = S.String;
export type IvrRecordingTrack = "ALL" | (string & {});
export const IvrRecordingTrack = S.String;
export interface VoiceRecordingConfiguration {
  VoiceRecordingTrack?: VoiceRecordingTrack;
  IvrRecordingTrack?: IvrRecordingTrack;
}
export const VoiceRecordingConfiguration = S.suspend(() =>
  S.Struct({
    VoiceRecordingTrack: S.optional(VoiceRecordingTrack),
    IvrRecordingTrack: S.optional(IvrRecordingTrack),
  }),
).annotate({
  identifier: "VoiceRecordingConfiguration",
}) as any as S.Schema<VoiceRecordingConfiguration>;
export interface StartContactRecordingRequest {
  InstanceId: string;
  ContactId: string;
  InitialContactId: string;
  VoiceRecordingConfiguration: VoiceRecordingConfiguration;
}
export const StartContactRecordingRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    InitialContactId: S.String,
    VoiceRecordingConfiguration: VoiceRecordingConfiguration,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/start-recording" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartContactRecordingRequest",
}) as any as S.Schema<StartContactRecordingRequest>;
export interface StartContactRecordingResponse {}
export const StartContactRecordingResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "StartContactRecordingResponse",
}) as any as S.Schema<StartContactRecordingResponse>;
export interface StartContactStreamingRequest {
  InstanceId: string;
  ContactId: string;
  ChatStreamingConfiguration: ChatStreamingConfiguration;
  ClientToken: string;
}
export const StartContactStreamingRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    ChatStreamingConfiguration: ChatStreamingConfiguration,
    ClientToken: S.String.pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/start-streaming" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartContactStreamingRequest",
}) as any as S.Schema<StartContactStreamingRequest>;
export interface StartContactStreamingResponse {
  StreamingId: string;
}
export const StartContactStreamingResponse = S.suspend(() =>
  S.Struct({ StreamingId: S.String }),
).annotate({
  identifier: "StartContactStreamingResponse",
}) as any as S.Schema<StartContactStreamingResponse>;
export type InboundMessageSourceType = "RAW" | (string & {});
export const InboundMessageSourceType = S.String;
export type EmailHeaderType =
  | "REFERENCES"
  | "MESSAGE_ID"
  | "IN_REPLY_TO"
  | "X_SES_SPAM_VERDICT"
  | "X_SES_VIRUS_VERDICT"
  | (string & {});
export const EmailHeaderType = S.String;
export type EmailHeaders = { [key in EmailHeaderType]?: string };
export const EmailHeaders = S.Record(
  EmailHeaderType,
  S.String.pipe(S.optional),
);
export interface InboundRawMessage {
  Subject: string | redacted.Redacted<string>;
  Body: string | redacted.Redacted<string>;
  ContentType: string;
  Headers?: { [key: string]: string | undefined };
}
export const InboundRawMessage = S.suspend(() =>
  S.Struct({
    Subject: SensitiveString,
    Body: SensitiveString,
    ContentType: S.String,
    Headers: S.optional(EmailHeaders),
  }),
).annotate({
  identifier: "InboundRawMessage",
}) as any as S.Schema<InboundRawMessage>;
export interface InboundEmailContent {
  MessageSourceType: InboundMessageSourceType;
  RawMessage?: InboundRawMessage;
}
export const InboundEmailContent = S.suspend(() =>
  S.Struct({
    MessageSourceType: InboundMessageSourceType,
    RawMessage: S.optional(InboundRawMessage),
  }),
).annotate({
  identifier: "InboundEmailContent",
}) as any as S.Schema<InboundEmailContent>;
export interface InboundAdditionalRecipients {
  ToAddresses?: EmailAddressInfo[];
  CcAddresses?: EmailAddressInfo[];
}
export const InboundAdditionalRecipients = S.suspend(() =>
  S.Struct({
    ToAddresses: S.optional(EmailAddressRecipientList),
    CcAddresses: S.optional(EmailAddressRecipientList),
  }),
).annotate({
  identifier: "InboundAdditionalRecipients",
}) as any as S.Schema<InboundAdditionalRecipients>;
export interface EmailAttachment {
  FileName: string;
  S3Url: string;
}
export const EmailAttachment = S.suspend(() =>
  S.Struct({ FileName: S.String, S3Url: S.String }),
).annotate({
  identifier: "EmailAttachment",
}) as any as S.Schema<EmailAttachment>;
export type EmailAttachments = EmailAttachment[];
export const EmailAttachments = S.Array(EmailAttachment);
export interface StartEmailContactRequest {
  InstanceId: string;
  FromEmailAddress: EmailAddressInfo;
  DestinationEmailAddress: string | redacted.Redacted<string>;
  Description?: string | redacted.Redacted<string>;
  References?: { [key: string]: Reference | undefined };
  Name?: string | redacted.Redacted<string>;
  EmailMessage: InboundEmailContent;
  AdditionalRecipients?: InboundAdditionalRecipients;
  Attachments?: EmailAttachment[];
  ContactFlowId?: string;
  RelatedContactId?: string;
  Attributes?: { [key: string]: string | undefined };
  SegmentAttributes?: { [key: string]: SegmentAttributeValue | undefined };
  ClientToken?: string;
}
export const StartEmailContactRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    FromEmailAddress: EmailAddressInfo,
    DestinationEmailAddress: SensitiveString,
    Description: S.optional(SensitiveString),
    References: S.optional(ContactReferences),
    Name: S.optional(SensitiveString),
    EmailMessage: InboundEmailContent,
    AdditionalRecipients: S.optional(InboundAdditionalRecipients),
    Attachments: S.optional(EmailAttachments),
    ContactFlowId: S.optional(S.String),
    RelatedContactId: S.optional(S.String),
    Attributes: S.optional(Attributes),
    SegmentAttributes: S.optional(SegmentAttributes),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/email" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartEmailContactRequest",
}) as any as S.Schema<StartEmailContactRequest>;
export interface StartEmailContactResponse {
  ContactId?: string;
}
export const StartEmailContactResponse = S.suspend(() =>
  S.Struct({ ContactId: S.optional(S.String) }),
).annotate({
  identifier: "StartEmailContactResponse",
}) as any as S.Schema<StartEmailContactResponse>;
export interface StartOutboundChatContactRequest {
  SourceEndpoint: Endpoint;
  DestinationEndpoint: Endpoint;
  InstanceId: string;
  SegmentAttributes: { [key: string]: SegmentAttributeValue | undefined };
  Attributes?: { [key: string]: string | undefined };
  ContactFlowId: string;
  ChatDurationInMinutes?: number;
  ParticipantDetails?: ParticipantDetails;
  InitialSystemMessage?: ChatMessage;
  InitialTemplatedSystemMessage?: TemplatedMessageConfig;
  RelatedContactId?: string;
  SupportedMessagingContentTypes?: string[];
  ClientToken?: string;
}
export const StartOutboundChatContactRequest = S.suspend(() =>
  S.Struct({
    SourceEndpoint: Endpoint,
    DestinationEndpoint: Endpoint,
    InstanceId: S.String,
    SegmentAttributes: SegmentAttributes,
    Attributes: S.optional(Attributes),
    ContactFlowId: S.String,
    ChatDurationInMinutes: S.optional(S.Number),
    ParticipantDetails: S.optional(ParticipantDetails),
    InitialSystemMessage: S.optional(ChatMessage),
    InitialTemplatedSystemMessage: S.optional(TemplatedMessageConfig),
    RelatedContactId: S.optional(S.String),
    SupportedMessagingContentTypes: S.optional(SupportedMessagingContentTypes),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/outbound-chat" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartOutboundChatContactRequest",
}) as any as S.Schema<StartOutboundChatContactRequest>;
export interface StartOutboundChatContactResponse {
  ContactId?: string;
}
export const StartOutboundChatContactResponse = S.suspend(() =>
  S.Struct({ ContactId: S.optional(S.String) }),
).annotate({
  identifier: "StartOutboundChatContactResponse",
}) as any as S.Schema<StartOutboundChatContactResponse>;
export interface StartOutboundEmailContactRequest {
  InstanceId: string;
  ContactId: string;
  FromEmailAddress?: EmailAddressInfo;
  DestinationEmailAddress: EmailAddressInfo;
  AdditionalRecipients?: OutboundAdditionalRecipients;
  EmailMessage: OutboundEmailContent;
  ClientToken?: string;
}
export const StartOutboundEmailContactRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    FromEmailAddress: S.optional(EmailAddressInfo),
    DestinationEmailAddress: EmailAddressInfo,
    AdditionalRecipients: S.optional(OutboundAdditionalRecipients),
    EmailMessage: OutboundEmailContent,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/outbound-email" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartOutboundEmailContactRequest",
}) as any as S.Schema<StartOutboundEmailContactRequest>;
export interface StartOutboundEmailContactResponse {
  ContactId?: string;
}
export const StartOutboundEmailContactResponse = S.suspend(() =>
  S.Struct({ ContactId: S.optional(S.String) }),
).annotate({
  identifier: "StartOutboundEmailContactResponse",
}) as any as S.Schema<StartOutboundEmailContactResponse>;
export interface AnswerMachineDetectionConfig {
  EnableAnswerMachineDetection?: boolean;
  AwaitAnswerMachinePrompt?: boolean;
}
export const AnswerMachineDetectionConfig = S.suspend(() =>
  S.Struct({
    EnableAnswerMachineDetection: S.optional(S.Boolean),
    AwaitAnswerMachinePrompt: S.optional(S.Boolean),
  }),
).annotate({
  identifier: "AnswerMachineDetectionConfig",
}) as any as S.Schema<AnswerMachineDetectionConfig>;
export interface StartOutboundVoiceContactRequest {
  Name?: string | redacted.Redacted<string>;
  Description?: string | redacted.Redacted<string>;
  References?: { [key: string]: Reference | undefined };
  RelatedContactId?: string;
  DestinationPhoneNumber: string;
  ContactFlowId: string;
  InstanceId: string;
  ClientToken?: string;
  SourcePhoneNumber?: string;
  QueueId?: string;
  Attributes?: { [key: string]: string | undefined };
  AnswerMachineDetectionConfig?: AnswerMachineDetectionConfig;
  CampaignId?: string;
  TrafficType?: TrafficType;
  OutboundStrategy?: OutboundStrategy;
  RingTimeoutInSeconds?: number;
}
export const StartOutboundVoiceContactRequest = S.suspend(() =>
  S.Struct({
    Name: S.optional(SensitiveString),
    Description: S.optional(SensitiveString),
    References: S.optional(ContactReferences),
    RelatedContactId: S.optional(S.String),
    DestinationPhoneNumber: S.String,
    ContactFlowId: S.String,
    InstanceId: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    SourcePhoneNumber: S.optional(S.String),
    QueueId: S.optional(S.String),
    Attributes: S.optional(Attributes),
    AnswerMachineDetectionConfig: S.optional(AnswerMachineDetectionConfig),
    CampaignId: S.optional(S.String),
    TrafficType: S.optional(TrafficType),
    OutboundStrategy: S.optional(OutboundStrategy),
    RingTimeoutInSeconds: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/outbound-voice" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartOutboundVoiceContactRequest",
}) as any as S.Schema<StartOutboundVoiceContactRequest>;
export interface StartOutboundVoiceContactResponse {
  ContactId?: string;
}
export const StartOutboundVoiceContactResponse = S.suspend(() =>
  S.Struct({ ContactId: S.optional(S.String) }),
).annotate({
  identifier: "StartOutboundVoiceContactResponse",
}) as any as S.Schema<StartOutboundVoiceContactResponse>;
export interface StartScreenSharingRequest {
  ClientToken?: string;
  InstanceId: string;
  ContactId: string;
}
export const StartScreenSharingRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    InstanceId: S.String,
    ContactId: S.String,
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/screen-sharing" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartScreenSharingRequest",
}) as any as S.Schema<StartScreenSharingRequest>;
export interface StartScreenSharingResponse {}
export const StartScreenSharingResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "StartScreenSharingResponse",
}) as any as S.Schema<StartScreenSharingResponse>;
export interface TaskAttachment {
  FileName: string;
  S3Url: string;
}
export const TaskAttachment = S.suspend(() =>
  S.Struct({ FileName: S.String, S3Url: S.String }),
).annotate({ identifier: "TaskAttachment" }) as any as S.Schema<TaskAttachment>;
export type TaskAttachments = TaskAttachment[];
export const TaskAttachments = S.Array(TaskAttachment);
export interface StartTaskContactRequest {
  InstanceId: string;
  PreviousContactId?: string;
  ContactFlowId?: string;
  Attributes?: { [key: string]: string | undefined };
  Name: string | redacted.Redacted<string>;
  References?: { [key: string]: Reference | undefined };
  Description?: string | redacted.Redacted<string>;
  ClientToken?: string;
  ScheduledTime?: Date;
  TaskTemplateId?: string;
  QuickConnectId?: string;
  RelatedContactId?: string;
  SegmentAttributes?: { [key: string]: SegmentAttributeValue | undefined };
  Attachments?: TaskAttachment[];
}
export const StartTaskContactRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    PreviousContactId: S.optional(S.String),
    ContactFlowId: S.optional(S.String),
    Attributes: S.optional(Attributes),
    Name: SensitiveString,
    References: S.optional(ContactReferences),
    Description: S.optional(SensitiveString),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    ScheduledTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    TaskTemplateId: S.optional(S.String),
    QuickConnectId: S.optional(S.String),
    RelatedContactId: S.optional(S.String),
    SegmentAttributes: S.optional(SegmentAttributes),
    Attachments: S.optional(TaskAttachments),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/task" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartTaskContactRequest",
}) as any as S.Schema<StartTaskContactRequest>;
export interface StartTaskContactResponse {
  ContactId?: string;
}
export const StartTaskContactResponse = S.suspend(() =>
  S.Struct({ ContactId: S.optional(S.String) }),
).annotate({
  identifier: "StartTaskContactResponse",
}) as any as S.Schema<StartTaskContactResponse>;
export interface StartTestCaseExecutionRequest {
  InstanceId: string;
  TestCaseId: string;
  ClientToken?: string;
}
export const StartTestCaseExecutionRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    TestCaseId: S.String.pipe(T.HttpLabel("TestCaseId")),
    ClientToken: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/test-cases/{InstanceId}/{TestCaseId}/start-execution",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartTestCaseExecutionRequest",
}) as any as S.Schema<StartTestCaseExecutionRequest>;
export interface StartTestCaseExecutionResponse {
  TestCaseExecutionId?: string;
  TestCaseId?: string;
  Status?: TestCaseExecutionStatus;
}
export const StartTestCaseExecutionResponse = S.suspend(() =>
  S.Struct({
    TestCaseExecutionId: S.optional(S.String),
    TestCaseId: S.optional(S.String),
    Status: S.optional(TestCaseExecutionStatus),
  }),
).annotate({
  identifier: "StartTestCaseExecutionResponse",
}) as any as S.Schema<StartTestCaseExecutionResponse>;
export interface AllowedCapabilities {
  Customer?: ParticipantCapabilities;
  Agent?: ParticipantCapabilities;
}
export const AllowedCapabilities = S.suspend(() =>
  S.Struct({
    Customer: S.optional(ParticipantCapabilities),
    Agent: S.optional(ParticipantCapabilities),
  }),
).annotate({
  identifier: "AllowedCapabilities",
}) as any as S.Schema<AllowedCapabilities>;
export interface StartWebRTCContactRequest {
  Attributes?: { [key: string]: string | undefined };
  ClientToken?: string;
  ContactFlowId: string;
  InstanceId: string;
  AllowedCapabilities?: AllowedCapabilities;
  ParticipantDetails: ParticipantDetails;
  RelatedContactId?: string;
  References?: { [key: string]: Reference | undefined };
  Description?: string | redacted.Redacted<string>;
}
export const StartWebRTCContactRequest = S.suspend(() =>
  S.Struct({
    Attributes: S.optional(Attributes),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    ContactFlowId: S.String,
    InstanceId: S.String,
    AllowedCapabilities: S.optional(AllowedCapabilities),
    ParticipantDetails: ParticipantDetails,
    RelatedContactId: S.optional(S.String),
    References: S.optional(ContactReferences),
    Description: S.optional(SensitiveString),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/webrtc" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StartWebRTCContactRequest",
}) as any as S.Schema<StartWebRTCContactRequest>;
export interface Attendee {
  AttendeeId?: string;
  JoinToken?: string | redacted.Redacted<string>;
}
export const Attendee = S.suspend(() =>
  S.Struct({
    AttendeeId: S.optional(S.String),
    JoinToken: S.optional(SensitiveString),
  }),
).annotate({ identifier: "Attendee" }) as any as S.Schema<Attendee>;
export interface MediaPlacement {
  AudioHostUrl?: string;
  AudioFallbackUrl?: string;
  SignalingUrl?: string;
  TurnControlUrl?: string;
  EventIngestionUrl?: string;
}
export const MediaPlacement = S.suspend(() =>
  S.Struct({
    AudioHostUrl: S.optional(S.String),
    AudioFallbackUrl: S.optional(S.String),
    SignalingUrl: S.optional(S.String),
    TurnControlUrl: S.optional(S.String),
    EventIngestionUrl: S.optional(S.String),
  }),
).annotate({ identifier: "MediaPlacement" }) as any as S.Schema<MediaPlacement>;
export type MeetingFeatureStatus = "AVAILABLE" | "UNAVAILABLE" | (string & {});
export const MeetingFeatureStatus = S.String;
export interface AudioFeatures {
  EchoReduction?: MeetingFeatureStatus;
}
export const AudioFeatures = S.suspend(() =>
  S.Struct({ EchoReduction: S.optional(MeetingFeatureStatus) }),
).annotate({ identifier: "AudioFeatures" }) as any as S.Schema<AudioFeatures>;
export interface MeetingFeaturesConfiguration {
  Audio?: AudioFeatures;
}
export const MeetingFeaturesConfiguration = S.suspend(() =>
  S.Struct({ Audio: S.optional(AudioFeatures) }),
).annotate({
  identifier: "MeetingFeaturesConfiguration",
}) as any as S.Schema<MeetingFeaturesConfiguration>;
export interface Meeting {
  MediaRegion?: string;
  MediaPlacement?: MediaPlacement;
  MeetingFeatures?: MeetingFeaturesConfiguration;
  MeetingId?: string;
}
export const Meeting = S.suspend(() =>
  S.Struct({
    MediaRegion: S.optional(S.String),
    MediaPlacement: S.optional(MediaPlacement),
    MeetingFeatures: S.optional(MeetingFeaturesConfiguration),
    MeetingId: S.optional(S.String),
  }),
).annotate({ identifier: "Meeting" }) as any as S.Schema<Meeting>;
export interface ConnectionData {
  Attendee?: Attendee;
  Meeting?: Meeting;
}
export const ConnectionData = S.suspend(() =>
  S.Struct({ Attendee: S.optional(Attendee), Meeting: S.optional(Meeting) }),
).annotate({ identifier: "ConnectionData" }) as any as S.Schema<ConnectionData>;
export interface StartWebRTCContactResponse {
  ConnectionData?: ConnectionData;
  ContactId?: string;
  ParticipantId?: string;
  ParticipantToken?: string;
}
export const StartWebRTCContactResponse = S.suspend(() =>
  S.Struct({
    ConnectionData: S.optional(ConnectionData),
    ContactId: S.optional(S.String),
    ParticipantId: S.optional(S.String),
    ParticipantToken: S.optional(S.String),
  }),
).annotate({
  identifier: "StartWebRTCContactResponse",
}) as any as S.Schema<StartWebRTCContactResponse>;
export interface DisconnectReason {
  Code?: string;
}
export const DisconnectReason = S.suspend(() =>
  S.Struct({ Code: S.optional(S.String) }),
).annotate({
  identifier: "DisconnectReason",
}) as any as S.Schema<DisconnectReason>;
export interface StopContactRequest {
  ContactId: string;
  InstanceId: string;
  DisconnectReason?: DisconnectReason;
}
export const StopContactRequest = S.suspend(() =>
  S.Struct({
    ContactId: S.String,
    InstanceId: S.String,
    DisconnectReason: S.optional(DisconnectReason),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/stop" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopContactRequest",
}) as any as S.Schema<StopContactRequest>;
export interface StopContactResponse {}
export const StopContactResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "StopContactResponse",
}) as any as S.Schema<StopContactResponse>;
export interface StopContactMediaProcessingRequest {
  InstanceId?: string;
  ContactId?: string;
}
export const StopContactMediaProcessingRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    ContactId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/stop-contact-media-processing" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopContactMediaProcessingRequest",
}) as any as S.Schema<StopContactMediaProcessingRequest>;
export interface StopContactMediaProcessingResponse {}
export const StopContactMediaProcessingResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "StopContactMediaProcessingResponse",
}) as any as S.Schema<StopContactMediaProcessingResponse>;
export interface StopContactRecordingRequest {
  InstanceId: string;
  ContactId: string;
  InitialContactId: string;
  ContactRecordingType?: ContactRecordingType;
}
export const StopContactRecordingRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    InitialContactId: S.String,
    ContactRecordingType: S.optional(ContactRecordingType),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/stop-recording" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopContactRecordingRequest",
}) as any as S.Schema<StopContactRecordingRequest>;
export interface StopContactRecordingResponse {}
export const StopContactRecordingResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "StopContactRecordingResponse",
}) as any as S.Schema<StopContactRecordingResponse>;
export interface StopContactStreamingRequest {
  InstanceId: string;
  ContactId: string;
  StreamingId: string;
}
export const StopContactStreamingRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    StreamingId: S.String,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/stop-streaming" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopContactStreamingRequest",
}) as any as S.Schema<StopContactStreamingRequest>;
export interface StopContactStreamingResponse {}
export const StopContactStreamingResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "StopContactStreamingResponse",
}) as any as S.Schema<StopContactStreamingResponse>;
export interface StopTestCaseExecutionRequest {
  InstanceId: string;
  TestCaseExecutionId: string;
  TestCaseId: string;
  ClientToken?: string;
}
export const StopTestCaseExecutionRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    TestCaseExecutionId: S.String.pipe(T.HttpLabel("TestCaseExecutionId")),
    TestCaseId: S.String.pipe(T.HttpLabel("TestCaseId")),
    ClientToken: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/test-cases/{InstanceId}/{TestCaseId}/{TestCaseExecutionId}/stop-execution",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "StopTestCaseExecutionRequest",
}) as any as S.Schema<StopTestCaseExecutionRequest>;
export interface StopTestCaseExecutionResponse {}
export const StopTestCaseExecutionResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "StopTestCaseExecutionResponse",
}) as any as S.Schema<StopTestCaseExecutionResponse>;
export interface EvaluationAnswerInput {
  Value?: EvaluationAnswerData;
}
export const EvaluationAnswerInput = S.suspend(() =>
  S.Struct({ Value: S.optional(EvaluationAnswerData) }),
).annotate({
  identifier: "EvaluationAnswerInput",
}) as any as S.Schema<EvaluationAnswerInput>;
export type EvaluationAnswersInputMap = {
  [key: string]: EvaluationAnswerInput | undefined;
};
export const EvaluationAnswersInputMap = S.Record(
  S.String,
  EvaluationAnswerInput.pipe(S.optional),
);
export type EvaluatorUserUnion = { ConnectUserArn: string };
export const EvaluatorUserUnion = S.Union([
  S.Struct({ ConnectUserArn: S.String }),
]);
export interface SubmitContactEvaluationRequest {
  InstanceId: string;
  EvaluationId: string;
  Answers?: { [key: string]: EvaluationAnswerInput | undefined };
  Notes?: { [key: string]: EvaluationNote | undefined };
  SubmittedBy?: EvaluatorUserUnion;
}
export const SubmitContactEvaluationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationId: S.String.pipe(T.HttpLabel("EvaluationId")),
    Answers: S.optional(EvaluationAnswersInputMap),
    Notes: S.optional(EvaluationNotesMap),
    SubmittedBy: S.optional(EvaluatorUserUnion),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact-evaluations/{InstanceId}/{EvaluationId}/submit",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SubmitContactEvaluationRequest",
}) as any as S.Schema<SubmitContactEvaluationRequest>;
export interface SubmitContactEvaluationResponse {
  EvaluationId: string;
  EvaluationArn: string;
}
export const SubmitContactEvaluationResponse = S.suspend(() =>
  S.Struct({ EvaluationId: S.String, EvaluationArn: S.String }),
).annotate({
  identifier: "SubmitContactEvaluationResponse",
}) as any as S.Schema<SubmitContactEvaluationResponse>;
export interface SuspendContactRecordingRequest {
  InstanceId: string;
  ContactId: string;
  InitialContactId: string;
  ContactRecordingType?: ContactRecordingType;
}
export const SuspendContactRecordingRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    InitialContactId: S.String,
    ContactRecordingType: S.optional(ContactRecordingType),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/suspend-recording" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "SuspendContactRecordingRequest",
}) as any as S.Schema<SuspendContactRecordingRequest>;
export interface SuspendContactRecordingResponse {}
export const SuspendContactRecordingResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "SuspendContactRecordingResponse",
}) as any as S.Schema<SuspendContactRecordingResponse>;
export interface TagContactRequest {
  ContactId: string;
  InstanceId: string;
  Tags: { [key: string]: string | undefined };
}
export const TagContactRequest = S.suspend(() =>
  S.Struct({
    ContactId: S.String,
    InstanceId: S.String,
    Tags: ContactTagMap,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/tags" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "TagContactRequest",
}) as any as S.Schema<TagContactRequest>;
export interface TagContactResponse {}
export const TagContactResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "TagContactResponse",
}) as any as S.Schema<TagContactResponse>;
export interface TagResourceRequest {
  resourceArn: string;
  tags: { [key: string]: string | undefined };
}
export const TagResourceRequest = S.suspend(() =>
  S.Struct({
    resourceArn: S.String.pipe(T.HttpLabel("resourceArn")),
    tags: TagMap,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/tags/{resourceArn}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "TagResourceRequest",
}) as any as S.Schema<TagResourceRequest>;
export interface TagResourceResponse {}
export const TagResourceResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "TagResourceResponse",
}) as any as S.Schema<TagResourceResponse>;
export interface TransferContactRequest {
  InstanceId: string;
  ContactId: string;
  QueueId?: string;
  UserId?: string;
  ContactFlowId: string;
  ClientToken?: string;
}
export const TransferContactRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    QueueId: S.optional(S.String),
    UserId: S.optional(S.String),
    ContactFlowId: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/transfer" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "TransferContactRequest",
}) as any as S.Schema<TransferContactRequest>;
export interface TransferContactResponse {
  ContactId?: string;
  ContactArn?: string;
}
export const TransferContactResponse = S.suspend(() =>
  S.Struct({
    ContactId: S.optional(S.String),
    ContactArn: S.optional(S.String),
  }),
).annotate({
  identifier: "TransferContactResponse",
}) as any as S.Schema<TransferContactResponse>;
export type ContactTagKeys = string[];
export const ContactTagKeys = S.Array(S.String);
export interface UntagContactRequest {
  ContactId: string;
  InstanceId: string;
  TagKeys: string[];
}
export const UntagContactRequest = S.suspend(() =>
  S.Struct({
    ContactId: S.String.pipe(T.HttpLabel("ContactId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    TagKeys: ContactTagKeys.pipe(T.HttpQuery("TagKeys")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/contact/tags/{InstanceId}/{ContactId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UntagContactRequest",
}) as any as S.Schema<UntagContactRequest>;
export interface UntagContactResponse {}
export const UntagContactResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "UntagContactResponse",
}) as any as S.Schema<UntagContactResponse>;
export type TagKeyList = string[];
export const TagKeyList = S.Array(S.String);
export interface UntagResourceRequest {
  resourceArn: string;
  tagKeys: string[];
}
export const UntagResourceRequest = S.suspend(() =>
  S.Struct({
    resourceArn: S.String.pipe(T.HttpLabel("resourceArn")),
    tagKeys: TagKeyList.pipe(T.HttpQuery("tagKeys")),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/tags/{resourceArn}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UntagResourceRequest",
}) as any as S.Schema<UntagResourceRequest>;
export interface UntagResourceResponse {}
export const UntagResourceResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "UntagResourceResponse",
}) as any as S.Schema<UntagResourceResponse>;
export interface UpdateAgentStatusRequest {
  InstanceId: string;
  AgentStatusId: string;
  Name?: string;
  Description?: string;
  State?: AgentStatusState;
  DisplayOrder?: number;
  ResetOrderNumber?: boolean;
}
export const UpdateAgentStatusRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AgentStatusId: S.String.pipe(T.HttpLabel("AgentStatusId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    State: S.optional(AgentStatusState),
    DisplayOrder: S.optional(S.Number),
    ResetOrderNumber: S.optional(S.Boolean),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/agent-status/{InstanceId}/{AgentStatusId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateAgentStatusRequest",
}) as any as S.Schema<UpdateAgentStatusRequest>;
export interface UpdateAgentStatusResponse {}
export const UpdateAgentStatusResponse = S.suspend(() => S.Struct({})).annotate(
  { identifier: "UpdateAgentStatusResponse" },
) as any as S.Schema<UpdateAgentStatusResponse>;
export interface UpdateAuthenticationProfileRequest {
  AuthenticationProfileId: string;
  InstanceId: string;
  Name?: string;
  Description?: string;
  AllowedIps?: string[];
  BlockedIps?: string[];
  PeriodicSessionDuration?: number;
  SessionInactivityDuration?: number;
  SessionInactivityHandlingEnabled?: boolean;
}
export const UpdateAuthenticationProfileRequest = S.suspend(() =>
  S.Struct({
    AuthenticationProfileId: S.String.pipe(
      T.HttpLabel("AuthenticationProfileId"),
    ),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    AllowedIps: S.optional(IpCidrList),
    BlockedIps: S.optional(IpCidrList),
    PeriodicSessionDuration: S.optional(S.Number),
    SessionInactivityDuration: S.optional(S.Number),
    SessionInactivityHandlingEnabled: S.optional(S.Boolean),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/authentication-profiles/{InstanceId}/{AuthenticationProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateAuthenticationProfileRequest",
}) as any as S.Schema<UpdateAuthenticationProfileRequest>;
export interface UpdateAuthenticationProfileResponse {}
export const UpdateAuthenticationProfileResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateAuthenticationProfileResponse",
}) as any as S.Schema<UpdateAuthenticationProfileResponse>;
export interface QueueInfoInput {
  Id?: string;
}
export const QueueInfoInput = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String) }),
).annotate({ identifier: "QueueInfoInput" }) as any as S.Schema<QueueInfoInput>;
export interface UpdateContactRequest {
  InstanceId: string;
  ContactId: string;
  Name?: string | redacted.Redacted<string>;
  Description?: string | redacted.Redacted<string>;
  References?: { [key: string]: Reference | undefined };
  SegmentAttributes?: { [key: string]: SegmentAttributeValue | undefined };
  QueueInfo?: QueueInfoInput;
  UserInfo?: UserInfo;
  CustomerEndpoint?: Endpoint;
  SystemEndpoint?: Endpoint;
}
export const UpdateContactRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String.pipe(T.HttpLabel("ContactId")),
    Name: S.optional(SensitiveString),
    Description: S.optional(SensitiveString),
    References: S.optional(ContactReferences),
    SegmentAttributes: S.optional(SegmentAttributes),
    QueueInfo: S.optional(QueueInfoInput),
    UserInfo: S.optional(UserInfo),
    CustomerEndpoint: S.optional(Endpoint),
    SystemEndpoint: S.optional(Endpoint),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contacts/{InstanceId}/{ContactId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateContactRequest",
}) as any as S.Schema<UpdateContactRequest>;
export interface UpdateContactResponse {}
export const UpdateContactResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "UpdateContactResponse",
}) as any as S.Schema<UpdateContactResponse>;
export interface UpdateContactAttributesRequest {
  InitialContactId: string;
  InstanceId: string;
  Attributes: { [key: string]: string | undefined };
}
export const UpdateContactAttributesRequest = S.suspend(() =>
  S.Struct({
    InitialContactId: S.String,
    InstanceId: S.String,
    Attributes: Attributes,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/attributes" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateContactAttributesRequest",
}) as any as S.Schema<UpdateContactAttributesRequest>;
export interface UpdateContactAttributesResponse {}
export const UpdateContactAttributesResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateContactAttributesResponse",
}) as any as S.Schema<UpdateContactAttributesResponse>;
export interface UpdateContactEvaluationRequest {
  InstanceId: string;
  EvaluationId: string;
  Answers?: { [key: string]: EvaluationAnswerInput | undefined };
  Notes?: { [key: string]: EvaluationNote | undefined };
  UpdatedBy?: EvaluatorUserUnion;
}
export const UpdateContactEvaluationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationId: S.String.pipe(T.HttpLabel("EvaluationId")),
    Answers: S.optional(EvaluationAnswersInputMap),
    Notes: S.optional(EvaluationNotesMap),
    UpdatedBy: S.optional(EvaluatorUserUnion),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact-evaluations/{InstanceId}/{EvaluationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateContactEvaluationRequest",
}) as any as S.Schema<UpdateContactEvaluationRequest>;
export interface UpdateContactEvaluationResponse {
  EvaluationId: string;
  EvaluationArn: string;
}
export const UpdateContactEvaluationResponse = S.suspend(() =>
  S.Struct({ EvaluationId: S.String, EvaluationArn: S.String }),
).annotate({
  identifier: "UpdateContactEvaluationResponse",
}) as any as S.Schema<UpdateContactEvaluationResponse>;
export interface UpdateContactFlowContentRequest {
  InstanceId: string;
  ContactFlowId: string;
  Content: string;
}
export const UpdateContactFlowContentRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowId: S.String.pipe(T.HttpLabel("ContactFlowId")),
    Content: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact-flows/{InstanceId}/{ContactFlowId}/content",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateContactFlowContentRequest",
}) as any as S.Schema<UpdateContactFlowContentRequest>;
export interface UpdateContactFlowContentResponse {}
export const UpdateContactFlowContentResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateContactFlowContentResponse",
}) as any as S.Schema<UpdateContactFlowContentResponse>;
export interface UpdateContactFlowMetadataRequest {
  InstanceId: string;
  ContactFlowId: string;
  Name?: string;
  Description?: string;
  ContactFlowState?: ContactFlowState;
}
export const UpdateContactFlowMetadataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowId: S.String.pipe(T.HttpLabel("ContactFlowId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    ContactFlowState: S.optional(ContactFlowState),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact-flows/{InstanceId}/{ContactFlowId}/metadata",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateContactFlowMetadataRequest",
}) as any as S.Schema<UpdateContactFlowMetadataRequest>;
export interface UpdateContactFlowMetadataResponse {}
export const UpdateContactFlowMetadataResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateContactFlowMetadataResponse",
}) as any as S.Schema<UpdateContactFlowMetadataResponse>;
export interface UpdateContactFlowModuleAliasRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
  AliasId: string;
  Name?: string;
  Description?: string;
  ContactFlowModuleVersion?: number;
}
export const UpdateContactFlowModuleAliasRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    AliasId: S.String.pipe(T.HttpLabel("AliasId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    ContactFlowModuleVersion: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/alias/{AliasId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateContactFlowModuleAliasRequest",
}) as any as S.Schema<UpdateContactFlowModuleAliasRequest>;
export interface UpdateContactFlowModuleAliasResponse {}
export const UpdateContactFlowModuleAliasResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateContactFlowModuleAliasResponse",
}) as any as S.Schema<UpdateContactFlowModuleAliasResponse>;
export interface UpdateContactFlowModuleContentRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
  Content?: string;
  Settings?: string;
}
export const UpdateContactFlowModuleContentRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    Content: S.optional(S.String),
    Settings: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/content",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateContactFlowModuleContentRequest",
}) as any as S.Schema<UpdateContactFlowModuleContentRequest>;
export interface UpdateContactFlowModuleContentResponse {}
export const UpdateContactFlowModuleContentResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateContactFlowModuleContentResponse",
}) as any as S.Schema<UpdateContactFlowModuleContentResponse>;
export interface UpdateContactFlowModuleMetadataRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
  Name?: string;
  Description?: string;
  State?: ContactFlowModuleState;
}
export const UpdateContactFlowModuleMetadataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    State: S.optional(ContactFlowModuleState),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/metadata",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateContactFlowModuleMetadataRequest",
}) as any as S.Schema<UpdateContactFlowModuleMetadataRequest>;
export interface UpdateContactFlowModuleMetadataResponse {}
export const UpdateContactFlowModuleMetadataResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateContactFlowModuleMetadataResponse",
}) as any as S.Schema<UpdateContactFlowModuleMetadataResponse>;
export interface UpdateContactFlowNameRequest {
  InstanceId: string;
  ContactFlowId: string;
  Name?: string;
  Description?: string;
}
export const UpdateContactFlowNameRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowId: S.String.pipe(T.HttpLabel("ContactFlowId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact-flows/{InstanceId}/{ContactFlowId}/name",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateContactFlowNameRequest",
}) as any as S.Schema<UpdateContactFlowNameRequest>;
export interface UpdateContactFlowNameResponse {}
export const UpdateContactFlowNameResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateContactFlowNameResponse",
}) as any as S.Schema<UpdateContactFlowNameResponse>;
export interface RoutingCriteriaInputStepExpiry {
  DurationInSeconds?: number;
}
export const RoutingCriteriaInputStepExpiry = S.suspend(() =>
  S.Struct({ DurationInSeconds: S.optional(S.Number) }),
).annotate({
  identifier: "RoutingCriteriaInputStepExpiry",
}) as any as S.Schema<RoutingCriteriaInputStepExpiry>;
export interface RoutingCriteriaInputStep {
  Expiry?: RoutingCriteriaInputStepExpiry;
  Expression?: Expression;
}
export const RoutingCriteriaInputStep = S.suspend(() =>
  S.Struct({
    Expiry: S.optional(RoutingCriteriaInputStepExpiry),
    Expression: S.optional(Expression),
  }),
).annotate({
  identifier: "RoutingCriteriaInputStep",
}) as any as S.Schema<RoutingCriteriaInputStep>;
export type RoutingCriteriaInputSteps = RoutingCriteriaInputStep[];
export const RoutingCriteriaInputSteps = S.Array(RoutingCriteriaInputStep);
export interface RoutingCriteriaInput {
  Steps?: RoutingCriteriaInputStep[];
}
export const RoutingCriteriaInput = S.suspend(() =>
  S.Struct({ Steps: S.optional(RoutingCriteriaInputSteps) }),
).annotate({
  identifier: "RoutingCriteriaInput",
}) as any as S.Schema<RoutingCriteriaInput>;
export interface UpdateContactRoutingDataRequest {
  InstanceId: string;
  ContactId: string;
  QueueTimeAdjustmentSeconds?: number;
  QueuePriority?: number;
  RoutingCriteria?: RoutingCriteriaInput;
}
export const UpdateContactRoutingDataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String.pipe(T.HttpLabel("ContactId")),
    QueueTimeAdjustmentSeconds: S.optional(S.Number),
    QueuePriority: S.optional(S.Number),
    RoutingCriteria: S.optional(RoutingCriteriaInput),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contacts/{InstanceId}/{ContactId}/routing-data",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateContactRoutingDataRequest",
}) as any as S.Schema<UpdateContactRoutingDataRequest>;
export interface UpdateContactRoutingDataResponse {}
export const UpdateContactRoutingDataResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateContactRoutingDataResponse",
}) as any as S.Schema<UpdateContactRoutingDataResponse>;
export interface UpdateContactScheduleRequest {
  InstanceId: string;
  ContactId: string;
  ScheduledTime: Date;
}
export const UpdateContactScheduleRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    ScheduledTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/schedule" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateContactScheduleRequest",
}) as any as S.Schema<UpdateContactScheduleRequest>;
export interface UpdateContactScheduleResponse {}
export const UpdateContactScheduleResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateContactScheduleResponse",
}) as any as S.Schema<UpdateContactScheduleResponse>;
export interface UpdateDataTableAttributeRequest {
  InstanceId: string;
  DataTableId: string;
  AttributeName: string;
  Name: string;
  ValueType: DataTableAttributeValueType;
  Description?: string;
  Primary?: boolean;
  Validation?: Validation;
}
export const UpdateDataTableAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    AttributeName: S.String.pipe(T.HttpLabel("AttributeName")),
    Name: S.String,
    ValueType: DataTableAttributeValueType,
    Description: S.optional(S.String),
    Primary: S.optional(S.Boolean),
    Validation: S.optional(Validation),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/attributes/{AttributeName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateDataTableAttributeRequest",
}) as any as S.Schema<UpdateDataTableAttributeRequest>;
export interface UpdateDataTableAttributeResponse {
  Name: string;
  LockVersion: DataTableLockVersion;
}
export const UpdateDataTableAttributeResponse = S.suspend(() =>
  S.Struct({ Name: S.String, LockVersion: DataTableLockVersion }),
).annotate({
  identifier: "UpdateDataTableAttributeResponse",
}) as any as S.Schema<UpdateDataTableAttributeResponse>;
export interface UpdateDataTableMetadataRequest {
  InstanceId: string;
  DataTableId: string;
  Name: string;
  Description?: string;
  ValueLockLevel: DataTableLockLevel;
  TimeZone: string;
}
export const UpdateDataTableMetadataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    Name: S.String,
    Description: S.optional(S.String),
    ValueLockLevel: DataTableLockLevel,
    TimeZone: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateDataTableMetadataRequest",
}) as any as S.Schema<UpdateDataTableMetadataRequest>;
export interface UpdateDataTableMetadataResponse {
  LockVersion: DataTableLockVersion;
}
export const UpdateDataTableMetadataResponse = S.suspend(() =>
  S.Struct({ LockVersion: DataTableLockVersion }),
).annotate({
  identifier: "UpdateDataTableMetadataResponse",
}) as any as S.Schema<UpdateDataTableMetadataResponse>;
export interface UpdateDataTablePrimaryValuesRequest {
  InstanceId: string;
  DataTableId: string;
  PrimaryValues: PrimaryValue[];
  NewPrimaryValues: PrimaryValue[];
  LockVersion: DataTableLockVersion;
}
export const UpdateDataTablePrimaryValuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    PrimaryValues: PrimaryValuesSet,
    NewPrimaryValues: PrimaryValuesSet,
    LockVersion: DataTableLockVersion,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/values/update-primary",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateDataTablePrimaryValuesRequest",
}) as any as S.Schema<UpdateDataTablePrimaryValuesRequest>;
export interface UpdateDataTablePrimaryValuesResponse {
  LockVersion: DataTableLockVersion;
}
export const UpdateDataTablePrimaryValuesResponse = S.suspend(() =>
  S.Struct({ LockVersion: DataTableLockVersion }),
).annotate({
  identifier: "UpdateDataTablePrimaryValuesResponse",
}) as any as S.Schema<UpdateDataTablePrimaryValuesResponse>;
export interface UpdateEmailAddressMetadataRequest {
  InstanceId: string;
  EmailAddressId: string;
  Description?: string | redacted.Redacted<string>;
  DisplayName?: string | redacted.Redacted<string>;
  ClientToken?: string;
}
export const UpdateEmailAddressMetadataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EmailAddressId: S.String.pipe(T.HttpLabel("EmailAddressId")),
    Description: S.optional(SensitiveString),
    DisplayName: S.optional(SensitiveString),
    ClientToken: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/email-addresses/{InstanceId}/{EmailAddressId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateEmailAddressMetadataRequest",
}) as any as S.Schema<UpdateEmailAddressMetadataRequest>;
export interface UpdateEmailAddressMetadataResponse {
  EmailAddressId?: string;
  EmailAddressArn?: string;
}
export const UpdateEmailAddressMetadataResponse = S.suspend(() =>
  S.Struct({
    EmailAddressId: S.optional(S.String),
    EmailAddressArn: S.optional(S.String),
  }),
).annotate({
  identifier: "UpdateEmailAddressMetadataResponse",
}) as any as S.Schema<UpdateEmailAddressMetadataResponse>;
export interface UpdateEvaluationFormRequest {
  InstanceId: string;
  EvaluationFormId: string;
  EvaluationFormVersion: number;
  CreateNewVersion?: boolean;
  Title: string;
  Description?: string;
  Items: EvaluationFormItem[];
  ScoringStrategy?: EvaluationFormScoringStrategy;
  AutoEvaluationConfiguration?: EvaluationFormAutoEvaluationConfiguration;
  ReviewConfiguration?: EvaluationReviewConfiguration;
  AsDraft?: boolean;
  ClientToken?: string;
  TargetConfiguration?: EvaluationFormTargetConfiguration;
  LanguageConfiguration?: EvaluationFormLanguageConfiguration;
}
export const UpdateEvaluationFormRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationFormId: S.String.pipe(T.HttpLabel("EvaluationFormId")),
    EvaluationFormVersion: S.Number,
    CreateNewVersion: S.optional(S.Boolean),
    Title: S.String,
    Description: S.optional(S.String),
    Items: EvaluationFormItemsList,
    ScoringStrategy: S.optional(EvaluationFormScoringStrategy),
    AutoEvaluationConfiguration: S.optional(
      EvaluationFormAutoEvaluationConfiguration,
    ),
    ReviewConfiguration: S.optional(EvaluationReviewConfiguration),
    AsDraft: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    TargetConfiguration: S.optional(EvaluationFormTargetConfiguration),
    LanguageConfiguration: S.optional(EvaluationFormLanguageConfiguration),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/evaluation-forms/{InstanceId}/{EvaluationFormId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateEvaluationFormRequest",
}) as any as S.Schema<UpdateEvaluationFormRequest>;
export interface UpdateEvaluationFormResponse {
  EvaluationFormId: string;
  EvaluationFormArn: string;
  EvaluationFormVersion: number;
}
export const UpdateEvaluationFormResponse = S.suspend(() =>
  S.Struct({
    EvaluationFormId: S.String,
    EvaluationFormArn: S.String,
    EvaluationFormVersion: S.Number,
  }),
).annotate({
  identifier: "UpdateEvaluationFormResponse",
}) as any as S.Schema<UpdateEvaluationFormResponse>;
export interface UpdateHoursOfOperationRequest {
  InstanceId: string;
  HoursOfOperationId: string;
  Name?: string;
  Description?: string;
  TimeZone?: string;
  Config?: HoursOfOperationConfig[];
}
export const UpdateHoursOfOperationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    TimeZone: S.optional(S.String),
    Config: S.optional(HoursOfOperationConfigList),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateHoursOfOperationRequest",
}) as any as S.Schema<UpdateHoursOfOperationRequest>;
export interface UpdateHoursOfOperationResponse {}
export const UpdateHoursOfOperationResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateHoursOfOperationResponse",
}) as any as S.Schema<UpdateHoursOfOperationResponse>;
export interface UpdateHoursOfOperationOverrideRequest {
  InstanceId: string;
  HoursOfOperationId: string;
  HoursOfOperationOverrideId: string;
  Name?: string;
  Description?: string;
  Config?: HoursOfOperationOverrideConfig[];
  EffectiveFrom?: string;
  EffectiveTill?: string;
  RecurrenceConfig?: RecurrenceConfig;
  OverrideType?: OverrideType;
}
export const UpdateHoursOfOperationOverrideRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
    HoursOfOperationOverrideId: S.String.pipe(
      T.HttpLabel("HoursOfOperationOverrideId"),
    ),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    Config: S.optional(HoursOfOperationOverrideConfigList),
    EffectiveFrom: S.optional(S.String),
    EffectiveTill: S.optional(S.String),
    RecurrenceConfig: S.optional(RecurrenceConfig),
    OverrideType: S.optional(OverrideType),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}/overrides/{HoursOfOperationOverrideId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateHoursOfOperationOverrideRequest",
}) as any as S.Schema<UpdateHoursOfOperationOverrideRequest>;
export interface UpdateHoursOfOperationOverrideResponse {}
export const UpdateHoursOfOperationOverrideResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateHoursOfOperationOverrideResponse",
}) as any as S.Schema<UpdateHoursOfOperationOverrideResponse>;
export interface UpdateInstanceAttributeRequest {
  InstanceId: string;
  AttributeType: InstanceAttributeType;
  Value: string;
  ClientToken?: string;
}
export const UpdateInstanceAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AttributeType: InstanceAttributeType.pipe(T.HttpLabel("AttributeType")),
    Value: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/instance/{InstanceId}/attribute/{AttributeType}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateInstanceAttributeRequest",
}) as any as S.Schema<UpdateInstanceAttributeRequest>;
export interface UpdateInstanceAttributeResponse {}
export const UpdateInstanceAttributeResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateInstanceAttributeResponse",
}) as any as S.Schema<UpdateInstanceAttributeResponse>;
export interface UpdateInstanceStorageConfigRequest {
  InstanceId: string;
  AssociationId: string;
  ResourceType: InstanceStorageResourceType;
  StorageConfig: InstanceStorageConfig;
  ClientToken?: string;
}
export const UpdateInstanceStorageConfigRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AssociationId: S.String.pipe(T.HttpLabel("AssociationId")),
    ResourceType: InstanceStorageResourceType.pipe(T.HttpQuery("resourceType")),
    StorageConfig: InstanceStorageConfig,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/instance/{InstanceId}/storage-config/{AssociationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateInstanceStorageConfigRequest",
}) as any as S.Schema<UpdateInstanceStorageConfigRequest>;
export interface UpdateInstanceStorageConfigResponse {}
export const UpdateInstanceStorageConfigResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateInstanceStorageConfigResponse",
}) as any as S.Schema<UpdateInstanceStorageConfigResponse>;
export interface UpdateNotificationContentRequest {
  InstanceId: string;
  NotificationId: string;
  Content: { [key: string]: string | undefined };
}
export const UpdateNotificationContentRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NotificationId: S.String.pipe(T.HttpLabel("NotificationId")),
    Content: NotificationContent,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/notifications/{InstanceId}/{NotificationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateNotificationContentRequest",
}) as any as S.Schema<UpdateNotificationContentRequest>;
export interface UpdateNotificationContentResponse {}
export const UpdateNotificationContentResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateNotificationContentResponse",
}) as any as S.Schema<UpdateNotificationContentResponse>;
export interface UpdateParticipantAuthenticationRequest {
  State: string;
  InstanceId: string;
  Code?: string | redacted.Redacted<string>;
  Error?: string | redacted.Redacted<string>;
  ErrorDescription?: string | redacted.Redacted<string>;
}
export const UpdateParticipantAuthenticationRequest = S.suspend(() =>
  S.Struct({
    State: S.String,
    InstanceId: S.String,
    Code: S.optional(SensitiveString),
    Error: S.optional(SensitiveString),
    ErrorDescription: S.optional(SensitiveString),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact/update-participant-authentication",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateParticipantAuthenticationRequest",
}) as any as S.Schema<UpdateParticipantAuthenticationRequest>;
export interface UpdateParticipantAuthenticationResponse {}
export const UpdateParticipantAuthenticationResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateParticipantAuthenticationResponse",
}) as any as S.Schema<UpdateParticipantAuthenticationResponse>;
export type TimerEligibleParticipantRoles =
  | "CUSTOMER"
  | "AGENT"
  | (string & {});
export const TimerEligibleParticipantRoles = S.String;
export type ParticipantTimerType =
  | "IDLE"
  | "DISCONNECT_NONCUSTOMER"
  | (string & {});
export const ParticipantTimerType = S.String;
export type ParticipantTimerAction = "Unset" | (string & {});
export const ParticipantTimerAction = S.String;
export type ParticipantTimerValue =
  | {
      ParticipantTimerAction: ParticipantTimerAction;
      ParticipantTimerDurationInMinutes?: never;
    }
  | {
      ParticipantTimerAction?: never;
      ParticipantTimerDurationInMinutes: number;
    };
export const ParticipantTimerValue = S.Union([
  S.Struct({ ParticipantTimerAction: ParticipantTimerAction }),
  S.Struct({ ParticipantTimerDurationInMinutes: S.Number }),
]);
export interface ParticipantTimerConfiguration {
  ParticipantRole: TimerEligibleParticipantRoles;
  TimerType: ParticipantTimerType;
  TimerValue: ParticipantTimerValue;
}
export const ParticipantTimerConfiguration = S.suspend(() =>
  S.Struct({
    ParticipantRole: TimerEligibleParticipantRoles,
    TimerType: ParticipantTimerType,
    TimerValue: ParticipantTimerValue,
  }),
).annotate({
  identifier: "ParticipantTimerConfiguration",
}) as any as S.Schema<ParticipantTimerConfiguration>;
export type ParticipantTimerConfigList = ParticipantTimerConfiguration[];
export const ParticipantTimerConfigList = S.Array(
  ParticipantTimerConfiguration,
);
export interface ChatParticipantRoleConfig {
  ParticipantTimerConfigList: ParticipantTimerConfiguration[];
}
export const ChatParticipantRoleConfig = S.suspend(() =>
  S.Struct({ ParticipantTimerConfigList: ParticipantTimerConfigList }),
).annotate({
  identifier: "ChatParticipantRoleConfig",
}) as any as S.Schema<ChatParticipantRoleConfig>;
export type UpdateParticipantRoleConfigChannelInfo = {
  Chat: ChatParticipantRoleConfig;
};
export const UpdateParticipantRoleConfigChannelInfo = S.Union([
  S.Struct({ Chat: ChatParticipantRoleConfig }),
]);
export interface UpdateParticipantRoleConfigRequest {
  InstanceId: string;
  ContactId: string;
  ChannelConfiguration: UpdateParticipantRoleConfigChannelInfo;
}
export const UpdateParticipantRoleConfigRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String.pipe(T.HttpLabel("ContactId")),
    ChannelConfiguration: UpdateParticipantRoleConfigChannelInfo,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/contact/participant-role-config/{InstanceId}/{ContactId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateParticipantRoleConfigRequest",
}) as any as S.Schema<UpdateParticipantRoleConfigRequest>;
export interface UpdateParticipantRoleConfigResponse {}
export const UpdateParticipantRoleConfigResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateParticipantRoleConfigResponse",
}) as any as S.Schema<UpdateParticipantRoleConfigResponse>;
export interface UpdatePhoneNumberRequest {
  PhoneNumberId: string;
  TargetArn?: string;
  InstanceId?: string;
  ClientToken?: string;
}
export const UpdatePhoneNumberRequest = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.String.pipe(T.HttpLabel("PhoneNumberId")),
    TargetArn: S.optional(S.String),
    InstanceId: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/phone-number/{PhoneNumberId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdatePhoneNumberRequest",
}) as any as S.Schema<UpdatePhoneNumberRequest>;
export interface UpdatePhoneNumberResponse {
  PhoneNumberId?: string;
  PhoneNumberArn?: string;
}
export const UpdatePhoneNumberResponse = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.optional(S.String),
    PhoneNumberArn: S.optional(S.String),
  }),
).annotate({
  identifier: "UpdatePhoneNumberResponse",
}) as any as S.Schema<UpdatePhoneNumberResponse>;
export interface UpdatePhoneNumberMetadataRequest {
  PhoneNumberId: string;
  PhoneNumberDescription?: string;
  ClientToken?: string;
}
export const UpdatePhoneNumberMetadataRequest = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.String.pipe(T.HttpLabel("PhoneNumberId")),
    PhoneNumberDescription: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/phone-number/{PhoneNumberId}/metadata" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdatePhoneNumberMetadataRequest",
}) as any as S.Schema<UpdatePhoneNumberMetadataRequest>;
export interface UpdatePhoneNumberMetadataResponse {}
export const UpdatePhoneNumberMetadataResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdatePhoneNumberMetadataResponse",
}) as any as S.Schema<UpdatePhoneNumberMetadataResponse>;
export interface UpdatePredefinedAttributeRequest {
  InstanceId: string;
  Name: string;
  Values?: PredefinedAttributeValues;
  Purposes?: string[];
  AttributeConfiguration?: InputPredefinedAttributeConfiguration;
}
export const UpdatePredefinedAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String.pipe(T.HttpLabel("Name")),
    Values: S.optional(PredefinedAttributeValues),
    Purposes: S.optional(PredefinedAttributePurposeNameList),
    AttributeConfiguration: S.optional(InputPredefinedAttributeConfiguration),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/predefined-attributes/{InstanceId}/{Name}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdatePredefinedAttributeRequest",
}) as any as S.Schema<UpdatePredefinedAttributeRequest>;
export interface UpdatePredefinedAttributeResponse {}
export const UpdatePredefinedAttributeResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdatePredefinedAttributeResponse",
}) as any as S.Schema<UpdatePredefinedAttributeResponse>;
export interface UpdatePromptRequest {
  InstanceId: string;
  PromptId: string;
  Name?: string;
  Description?: string;
  S3Uri?: string;
}
export const UpdatePromptRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    PromptId: S.String.pipe(T.HttpLabel("PromptId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    S3Uri: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/prompts/{InstanceId}/{PromptId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdatePromptRequest",
}) as any as S.Schema<UpdatePromptRequest>;
export interface UpdatePromptResponse {
  PromptARN?: string;
  PromptId?: string;
}
export const UpdatePromptResponse = S.suspend(() =>
  S.Struct({ PromptARN: S.optional(S.String), PromptId: S.optional(S.String) }),
).annotate({
  identifier: "UpdatePromptResponse",
}) as any as S.Schema<UpdatePromptResponse>;
export interface UpdateQueueHoursOfOperationRequest {
  InstanceId: string;
  QueueId: string;
  HoursOfOperationId: string;
}
export const UpdateQueueHoursOfOperationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
    HoursOfOperationId: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/queues/{InstanceId}/{QueueId}/hours-of-operation",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateQueueHoursOfOperationRequest",
}) as any as S.Schema<UpdateQueueHoursOfOperationRequest>;
export interface UpdateQueueHoursOfOperationResponse {}
export const UpdateQueueHoursOfOperationResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateQueueHoursOfOperationResponse",
}) as any as S.Schema<UpdateQueueHoursOfOperationResponse>;
export interface UpdateQueueMaxContactsRequest {
  InstanceId: string;
  QueueId: string;
  MaxContacts?: number;
}
export const UpdateQueueMaxContactsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
    MaxContacts: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/queues/{InstanceId}/{QueueId}/max-contacts",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateQueueMaxContactsRequest",
}) as any as S.Schema<UpdateQueueMaxContactsRequest>;
export interface UpdateQueueMaxContactsResponse {}
export const UpdateQueueMaxContactsResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateQueueMaxContactsResponse",
}) as any as S.Schema<UpdateQueueMaxContactsResponse>;
export interface UpdateQueueNameRequest {
  InstanceId: string;
  QueueId: string;
  Name?: string;
  Description?: string;
}
export const UpdateQueueNameRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/queues/{InstanceId}/{QueueId}/name" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateQueueNameRequest",
}) as any as S.Schema<UpdateQueueNameRequest>;
export interface UpdateQueueNameResponse {}
export const UpdateQueueNameResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "UpdateQueueNameResponse",
}) as any as S.Schema<UpdateQueueNameResponse>;
export interface UpdateQueueOutboundCallerConfigRequest {
  InstanceId: string;
  QueueId: string;
  OutboundCallerConfig: OutboundCallerConfig;
}
export const UpdateQueueOutboundCallerConfigRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
    OutboundCallerConfig: OutboundCallerConfig,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/queues/{InstanceId}/{QueueId}/outbound-caller-config",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateQueueOutboundCallerConfigRequest",
}) as any as S.Schema<UpdateQueueOutboundCallerConfigRequest>;
export interface UpdateQueueOutboundCallerConfigResponse {}
export const UpdateQueueOutboundCallerConfigResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateQueueOutboundCallerConfigResponse",
}) as any as S.Schema<UpdateQueueOutboundCallerConfigResponse>;
export interface UpdateQueueOutboundEmailConfigRequest {
  InstanceId: string;
  QueueId: string;
  OutboundEmailConfig: OutboundEmailConfig;
}
export const UpdateQueueOutboundEmailConfigRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
    OutboundEmailConfig: OutboundEmailConfig,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/queues/{InstanceId}/{QueueId}/outbound-email-config",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateQueueOutboundEmailConfigRequest",
}) as any as S.Schema<UpdateQueueOutboundEmailConfigRequest>;
export interface UpdateQueueOutboundEmailConfigResponse {}
export const UpdateQueueOutboundEmailConfigResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateQueueOutboundEmailConfigResponse",
}) as any as S.Schema<UpdateQueueOutboundEmailConfigResponse>;
export interface UpdateQueueStatusRequest {
  InstanceId: string;
  QueueId: string;
  Status: QueueStatus;
}
export const UpdateQueueStatusRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
    Status: QueueStatus,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/queues/{InstanceId}/{QueueId}/status" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateQueueStatusRequest",
}) as any as S.Schema<UpdateQueueStatusRequest>;
export interface UpdateQueueStatusResponse {}
export const UpdateQueueStatusResponse = S.suspend(() => S.Struct({})).annotate(
  { identifier: "UpdateQueueStatusResponse" },
) as any as S.Schema<UpdateQueueStatusResponse>;
export interface UpdateQuickConnectConfigRequest {
  InstanceId: string;
  QuickConnectId: string;
  QuickConnectConfig: QuickConnectConfig;
}
export const UpdateQuickConnectConfigRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QuickConnectId: S.String.pipe(T.HttpLabel("QuickConnectId")),
    QuickConnectConfig: QuickConnectConfig,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/quick-connects/{InstanceId}/{QuickConnectId}/config",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateQuickConnectConfigRequest",
}) as any as S.Schema<UpdateQuickConnectConfigRequest>;
export interface UpdateQuickConnectConfigResponse {}
export const UpdateQuickConnectConfigResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateQuickConnectConfigResponse",
}) as any as S.Schema<UpdateQuickConnectConfigResponse>;
export interface UpdateQuickConnectNameRequest {
  InstanceId: string;
  QuickConnectId: string;
  Name?: string;
  Description?: string;
}
export const UpdateQuickConnectNameRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QuickConnectId: S.String.pipe(T.HttpLabel("QuickConnectId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/quick-connects/{InstanceId}/{QuickConnectId}/name",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateQuickConnectNameRequest",
}) as any as S.Schema<UpdateQuickConnectNameRequest>;
export interface UpdateQuickConnectNameResponse {}
export const UpdateQuickConnectNameResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateQuickConnectNameResponse",
}) as any as S.Schema<UpdateQuickConnectNameResponse>;
export interface UpdateRoutingProfileAgentAvailabilityTimerRequest {
  InstanceId: string;
  RoutingProfileId: string;
  AgentAvailabilityTimer: AgentAvailabilityTimer;
}
export const UpdateRoutingProfileAgentAvailabilityTimerRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
    AgentAvailabilityTimer: AgentAvailabilityTimer,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}/agent-availability-timer",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateRoutingProfileAgentAvailabilityTimerRequest",
}) as any as S.Schema<UpdateRoutingProfileAgentAvailabilityTimerRequest>;
export interface UpdateRoutingProfileAgentAvailabilityTimerResponse {}
export const UpdateRoutingProfileAgentAvailabilityTimerResponse = S.suspend(
  () => S.Struct({}),
).annotate({
  identifier: "UpdateRoutingProfileAgentAvailabilityTimerResponse",
}) as any as S.Schema<UpdateRoutingProfileAgentAvailabilityTimerResponse>;
export interface UpdateRoutingProfileConcurrencyRequest {
  InstanceId: string;
  RoutingProfileId: string;
  MediaConcurrencies: MediaConcurrency[];
}
export const UpdateRoutingProfileConcurrencyRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
    MediaConcurrencies: MediaConcurrencies,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}/concurrency",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateRoutingProfileConcurrencyRequest",
}) as any as S.Schema<UpdateRoutingProfileConcurrencyRequest>;
export interface UpdateRoutingProfileConcurrencyResponse {}
export const UpdateRoutingProfileConcurrencyResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateRoutingProfileConcurrencyResponse",
}) as any as S.Schema<UpdateRoutingProfileConcurrencyResponse>;
export interface UpdateRoutingProfileDefaultOutboundQueueRequest {
  InstanceId: string;
  RoutingProfileId: string;
  DefaultOutboundQueueId: string;
}
export const UpdateRoutingProfileDefaultOutboundQueueRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
    DefaultOutboundQueueId: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}/default-outbound-queue",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateRoutingProfileDefaultOutboundQueueRequest",
}) as any as S.Schema<UpdateRoutingProfileDefaultOutboundQueueRequest>;
export interface UpdateRoutingProfileDefaultOutboundQueueResponse {}
export const UpdateRoutingProfileDefaultOutboundQueueResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateRoutingProfileDefaultOutboundQueueResponse",
}) as any as S.Schema<UpdateRoutingProfileDefaultOutboundQueueResponse>;
export interface UpdateRoutingProfileNameRequest {
  InstanceId: string;
  RoutingProfileId: string;
  Name?: string;
  Description?: string;
}
export const UpdateRoutingProfileNameRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}/name",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateRoutingProfileNameRequest",
}) as any as S.Schema<UpdateRoutingProfileNameRequest>;
export interface UpdateRoutingProfileNameResponse {}
export const UpdateRoutingProfileNameResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateRoutingProfileNameResponse",
}) as any as S.Schema<UpdateRoutingProfileNameResponse>;
export interface UpdateRoutingProfileQueuesRequest {
  InstanceId: string;
  RoutingProfileId: string;
  QueueConfigs: RoutingProfileQueueConfig[];
}
export const UpdateRoutingProfileQueuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
    QueueConfigs: RoutingProfileQueueConfigList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}/queues",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateRoutingProfileQueuesRequest",
}) as any as S.Schema<UpdateRoutingProfileQueuesRequest>;
export interface UpdateRoutingProfileQueuesResponse {}
export const UpdateRoutingProfileQueuesResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateRoutingProfileQueuesResponse",
}) as any as S.Schema<UpdateRoutingProfileQueuesResponse>;
export interface UpdateRuleRequest {
  RuleId: string;
  InstanceId: string;
  Name: string;
  Function: string;
  Actions: RuleAction[];
  PublishStatus: RulePublishStatus;
}
export const UpdateRuleRequest = S.suspend(() =>
  S.Struct({
    RuleId: S.String.pipe(T.HttpLabel("RuleId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Function: S.String,
    Actions: RuleActions,
    PublishStatus: RulePublishStatus,
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/rules/{InstanceId}/{RuleId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateRuleRequest",
}) as any as S.Schema<UpdateRuleRequest>;
export interface UpdateRuleResponse {}
export const UpdateRuleResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "UpdateRuleResponse",
}) as any as S.Schema<UpdateRuleResponse>;
export interface UpdateSecurityProfileRequest {
  Description?: string;
  Permissions?: string[];
  SecurityProfileId: string;
  InstanceId: string;
  AllowedAccessControlTags?: { [key: string]: string | undefined };
  TagRestrictedResources?: string[];
  Applications?: Application[];
  HierarchyRestrictedResources?: string[];
  AllowedAccessControlHierarchyGroupId?: string;
  AllowedFlowModules?: FlowModule[];
  GranularAccessControlConfiguration?: GranularAccessControlConfiguration;
}
export const UpdateSecurityProfileRequest = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String),
    Permissions: S.optional(PermissionsList),
    SecurityProfileId: S.String.pipe(T.HttpLabel("SecurityProfileId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AllowedAccessControlTags: S.optional(AllowedAccessControlTags),
    TagRestrictedResources: S.optional(TagRestrictedResourceList),
    Applications: S.optional(Applications),
    HierarchyRestrictedResources: S.optional(HierarchyRestrictedResourceList),
    AllowedAccessControlHierarchyGroupId: S.optional(S.String),
    AllowedFlowModules: S.optional(AllowedFlowModules),
    GranularAccessControlConfiguration: S.optional(
      GranularAccessControlConfiguration,
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/security-profiles/{InstanceId}/{SecurityProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateSecurityProfileRequest",
}) as any as S.Schema<UpdateSecurityProfileRequest>;
export interface UpdateSecurityProfileResponse {}
export const UpdateSecurityProfileResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateSecurityProfileResponse",
}) as any as S.Schema<UpdateSecurityProfileResponse>;
export interface UpdateTaskTemplateRequest {
  TaskTemplateId: string;
  InstanceId: string;
  Name?: string;
  Description?: string;
  ContactFlowId?: string;
  SelfAssignFlowId?: string;
  Constraints?: TaskTemplateConstraints;
  Defaults?: TaskTemplateDefaults;
  Status?: TaskTemplateStatus;
  Fields?: TaskTemplateField[];
}
export const UpdateTaskTemplateRequest = S.suspend(() =>
  S.Struct({
    TaskTemplateId: S.String.pipe(T.HttpLabel("TaskTemplateId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    ContactFlowId: S.optional(S.String),
    SelfAssignFlowId: S.optional(S.String),
    Constraints: S.optional(TaskTemplateConstraints),
    Defaults: S.optional(TaskTemplateDefaults),
    Status: S.optional(TaskTemplateStatus),
    Fields: S.optional(TaskTemplateFields),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/instance/{InstanceId}/task/template/{TaskTemplateId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateTaskTemplateRequest",
}) as any as S.Schema<UpdateTaskTemplateRequest>;
export interface UpdateTaskTemplateResponse {
  InstanceId?: string;
  Id?: string;
  Arn?: string;
  Name?: string;
  Description?: string;
  ContactFlowId?: string;
  SelfAssignFlowId?: string;
  Constraints?: TaskTemplateConstraints;
  Defaults?: TaskTemplateDefaults;
  Fields?: TaskTemplateField[];
  Status?: TaskTemplateStatus;
  LastModifiedTime?: Date;
  CreatedTime?: Date;
}
export const UpdateTaskTemplateResponse = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    ContactFlowId: S.optional(S.String),
    SelfAssignFlowId: S.optional(S.String),
    Constraints: S.optional(TaskTemplateConstraints),
    Defaults: S.optional(TaskTemplateDefaults),
    Fields: S.optional(TaskTemplateFields),
    Status: S.optional(TaskTemplateStatus),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotate({
  identifier: "UpdateTaskTemplateResponse",
}) as any as S.Schema<UpdateTaskTemplateResponse>;
export interface UpdateTestCaseRequest {
  InstanceId: string;
  TestCaseId: string;
  Content?: string;
  EntryPoint?: TestCaseEntryPoint;
  InitializationData?: string;
  Name?: string;
  Description?: string;
  Status?: TestCaseStatus;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const UpdateTestCaseRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    TestCaseId: S.String.pipe(T.HttpLabel("TestCaseId")),
    Content: S.optional(S.String),
    EntryPoint: S.optional(TestCaseEntryPoint),
    InitializationData: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    Status: S.optional(TestCaseStatus),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("http-date")),
    ).pipe(T.HttpHeader("x-amz-last-modified-time")),
    LastModifiedRegion: S.optional(S.String).pipe(
      T.HttpHeader("x-amz-last-modified-region"),
    ),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/test-cases/{InstanceId}/{TestCaseId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateTestCaseRequest",
}) as any as S.Schema<UpdateTestCaseRequest>;
export interface UpdateTestCaseResponse {}
export const UpdateTestCaseResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "UpdateTestCaseResponse",
}) as any as S.Schema<UpdateTestCaseResponse>;
export interface UpdateTrafficDistributionRequest {
  Id: string;
  TelephonyConfig?: TelephonyConfig;
  SignInConfig?: SignInConfig;
  AgentConfig?: AgentConfig;
}
export const UpdateTrafficDistributionRequest = S.suspend(() =>
  S.Struct({
    Id: S.String.pipe(T.HttpLabel("Id")),
    TelephonyConfig: S.optional(TelephonyConfig),
    SignInConfig: S.optional(SignInConfig),
    AgentConfig: S.optional(AgentConfig),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/traffic-distribution/{Id}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateTrafficDistributionRequest",
}) as any as S.Schema<UpdateTrafficDistributionRequest>;
export interface UpdateTrafficDistributionResponse {}
export const UpdateTrafficDistributionResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateTrafficDistributionResponse",
}) as any as S.Schema<UpdateTrafficDistributionResponse>;
export interface UpdateUserConfigRequest {
  AutoAcceptConfigs?: AutoAcceptConfig[];
  AfterContactWorkConfigs?: AfterContactWorkConfigPerChannel[];
  PhoneNumberConfigs?: PhoneNumberConfig[];
  PersistentConnectionConfigs?: PersistentConnectionConfig[];
  VoiceEnhancementConfigs?: VoiceEnhancementConfig[];
  UserId: string;
  InstanceId: string;
}
export const UpdateUserConfigRequest = S.suspend(() =>
  S.Struct({
    AutoAcceptConfigs: S.optional(AutoAcceptConfigs),
    AfterContactWorkConfigs: S.optional(AfterContactWorkConfigs),
    PhoneNumberConfigs: S.optional(PhoneNumberConfigs),
    PersistentConnectionConfigs: S.optional(PersistentConnectionConfigs),
    VoiceEnhancementConfigs: S.optional(VoiceEnhancementConfigs),
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/users/{InstanceId}/{UserId}/config" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateUserConfigRequest",
}) as any as S.Schema<UpdateUserConfigRequest>;
export interface UpdateUserConfigResponse {}
export const UpdateUserConfigResponse = S.suspend(() => S.Struct({})).annotate({
  identifier: "UpdateUserConfigResponse",
}) as any as S.Schema<UpdateUserConfigResponse>;
export interface UpdateUserHierarchyRequest {
  HierarchyGroupId?: string;
  UserId: string;
  InstanceId: string;
}
export const UpdateUserHierarchyRequest = S.suspend(() =>
  S.Struct({
    HierarchyGroupId: S.optional(S.String),
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/users/{InstanceId}/{UserId}/hierarchy" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateUserHierarchyRequest",
}) as any as S.Schema<UpdateUserHierarchyRequest>;
export interface UpdateUserHierarchyResponse {}
export const UpdateUserHierarchyResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateUserHierarchyResponse",
}) as any as S.Schema<UpdateUserHierarchyResponse>;
export interface UpdateUserHierarchyGroupNameRequest {
  Name: string;
  HierarchyGroupId: string;
  InstanceId: string;
}
export const UpdateUserHierarchyGroupNameRequest = S.suspend(() =>
  S.Struct({
    Name: S.String,
    HierarchyGroupId: S.String.pipe(T.HttpLabel("HierarchyGroupId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/user-hierarchy-groups/{InstanceId}/{HierarchyGroupId}/name",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateUserHierarchyGroupNameRequest",
}) as any as S.Schema<UpdateUserHierarchyGroupNameRequest>;
export interface UpdateUserHierarchyGroupNameResponse {}
export const UpdateUserHierarchyGroupNameResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateUserHierarchyGroupNameResponse",
}) as any as S.Schema<UpdateUserHierarchyGroupNameResponse>;
export interface HierarchyLevelUpdate {
  Name: string;
}
export const HierarchyLevelUpdate = S.suspend(() =>
  S.Struct({ Name: S.String }),
).annotate({
  identifier: "HierarchyLevelUpdate",
}) as any as S.Schema<HierarchyLevelUpdate>;
export interface HierarchyStructureUpdate {
  LevelOne?: HierarchyLevelUpdate;
  LevelTwo?: HierarchyLevelUpdate;
  LevelThree?: HierarchyLevelUpdate;
  LevelFour?: HierarchyLevelUpdate;
  LevelFive?: HierarchyLevelUpdate;
}
export const HierarchyStructureUpdate = S.suspend(() =>
  S.Struct({
    LevelOne: S.optional(HierarchyLevelUpdate),
    LevelTwo: S.optional(HierarchyLevelUpdate),
    LevelThree: S.optional(HierarchyLevelUpdate),
    LevelFour: S.optional(HierarchyLevelUpdate),
    LevelFive: S.optional(HierarchyLevelUpdate),
  }),
).annotate({
  identifier: "HierarchyStructureUpdate",
}) as any as S.Schema<HierarchyStructureUpdate>;
export interface UpdateUserHierarchyStructureRequest {
  HierarchyStructure: HierarchyStructureUpdate;
  InstanceId: string;
}
export const UpdateUserHierarchyStructureRequest = S.suspend(() =>
  S.Struct({
    HierarchyStructure: HierarchyStructureUpdate,
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/user-hierarchy-structure/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateUserHierarchyStructureRequest",
}) as any as S.Schema<UpdateUserHierarchyStructureRequest>;
export interface UpdateUserHierarchyStructureResponse {}
export const UpdateUserHierarchyStructureResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateUserHierarchyStructureResponse",
}) as any as S.Schema<UpdateUserHierarchyStructureResponse>;
export interface UpdateUserIdentityInfoRequest {
  IdentityInfo: UserIdentityInfo;
  UserId: string;
  InstanceId: string;
}
export const UpdateUserIdentityInfoRequest = S.suspend(() =>
  S.Struct({
    IdentityInfo: UserIdentityInfo,
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/users/{InstanceId}/{UserId}/identity-info",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateUserIdentityInfoRequest",
}) as any as S.Schema<UpdateUserIdentityInfoRequest>;
export interface UpdateUserIdentityInfoResponse {}
export const UpdateUserIdentityInfoResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateUserIdentityInfoResponse",
}) as any as S.Schema<UpdateUserIdentityInfoResponse>;
export interface UpdateUserNotificationStatusRequest {
  InstanceId: string;
  NotificationId: string;
  UserId: string;
  Status: NotificationStatus;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const UpdateUserNotificationStatusRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NotificationId: S.String.pipe(T.HttpLabel("NotificationId")),
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    Status: NotificationStatus,
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("http-date")),
    ).pipe(T.HttpHeader("x-amz-last-modified-time")),
    LastModifiedRegion: S.optional(S.String).pipe(
      T.HttpHeader("x-amz-last-modified-region"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/users/{InstanceId}/{UserId}/notifications/{NotificationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateUserNotificationStatusRequest",
}) as any as S.Schema<UpdateUserNotificationStatusRequest>;
export interface UpdateUserNotificationStatusResponse {}
export const UpdateUserNotificationStatusResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateUserNotificationStatusResponse",
}) as any as S.Schema<UpdateUserNotificationStatusResponse>;
export interface UpdateUserPhoneConfigRequest {
  PhoneConfig: UserPhoneConfig;
  UserId: string;
  InstanceId: string;
}
export const UpdateUserPhoneConfigRequest = S.suspend(() =>
  S.Struct({
    PhoneConfig: UserPhoneConfig,
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/users/{InstanceId}/{UserId}/phone-config",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateUserPhoneConfigRequest",
}) as any as S.Schema<UpdateUserPhoneConfigRequest>;
export interface UpdateUserPhoneConfigResponse {}
export const UpdateUserPhoneConfigResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateUserPhoneConfigResponse",
}) as any as S.Schema<UpdateUserPhoneConfigResponse>;
export interface UpdateUserProficienciesRequest {
  InstanceId: string;
  UserId: string;
  UserProficiencies: UserProficiency[];
}
export const UpdateUserProficienciesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    UserProficiencies: UserProficiencyList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/users/{InstanceId}/{UserId}/proficiencies",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateUserProficienciesRequest",
}) as any as S.Schema<UpdateUserProficienciesRequest>;
export interface UpdateUserProficienciesResponse {}
export const UpdateUserProficienciesResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateUserProficienciesResponse",
}) as any as S.Schema<UpdateUserProficienciesResponse>;
export interface UpdateUserRoutingProfileRequest {
  RoutingProfileId: string;
  UserId: string;
  InstanceId: string;
}
export const UpdateUserRoutingProfileRequest = S.suspend(() =>
  S.Struct({
    RoutingProfileId: S.String,
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/users/{InstanceId}/{UserId}/routing-profile",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateUserRoutingProfileRequest",
}) as any as S.Schema<UpdateUserRoutingProfileRequest>;
export interface UpdateUserRoutingProfileResponse {}
export const UpdateUserRoutingProfileResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateUserRoutingProfileResponse",
}) as any as S.Schema<UpdateUserRoutingProfileResponse>;
export interface UpdateUserSecurityProfilesRequest {
  SecurityProfileIds: string[];
  UserId: string;
  InstanceId: string;
}
export const UpdateUserSecurityProfilesRequest = S.suspend(() =>
  S.Struct({
    SecurityProfileIds: SecurityProfileIds,
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/users/{InstanceId}/{UserId}/security-profiles",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateUserSecurityProfilesRequest",
}) as any as S.Schema<UpdateUserSecurityProfilesRequest>;
export interface UpdateUserSecurityProfilesResponse {}
export const UpdateUserSecurityProfilesResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateUserSecurityProfilesResponse",
}) as any as S.Schema<UpdateUserSecurityProfilesResponse>;
export interface UpdateViewContentRequest {
  InstanceId: string;
  ViewId: string;
  Status: ViewStatus;
  Content: ViewInputContent;
}
export const UpdateViewContentRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ViewId: S.String.pipe(T.HttpLabel("ViewId")),
    Status: ViewStatus,
    Content: ViewInputContent,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/views/{InstanceId}/{ViewId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateViewContentRequest",
}) as any as S.Schema<UpdateViewContentRequest>;
export interface UpdateViewContentResponse {
  View?: View;
}
export const UpdateViewContentResponse = S.suspend(() =>
  S.Struct({ View: S.optional(View) }),
).annotate({
  identifier: "UpdateViewContentResponse",
}) as any as S.Schema<UpdateViewContentResponse>;
export interface UpdateViewMetadataRequest {
  InstanceId: string;
  ViewId: string;
  Name?: string | redacted.Redacted<string>;
  Description?: string;
}
export const UpdateViewMetadataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ViewId: S.String.pipe(T.HttpLabel("ViewId")),
    Name: S.optional(SensitiveString),
    Description: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/views/{InstanceId}/{ViewId}/metadata" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateViewMetadataRequest",
}) as any as S.Schema<UpdateViewMetadataRequest>;
export interface UpdateViewMetadataResponse {}
export const UpdateViewMetadataResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateViewMetadataResponse",
}) as any as S.Schema<UpdateViewMetadataResponse>;
export interface UpdateWorkspaceMetadataRequest {
  InstanceId: string;
  WorkspaceId: string;
  Name?: string;
  Description?: string;
  Title?: string;
}
export const UpdateWorkspaceMetadataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    Title: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/metadata",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateWorkspaceMetadataRequest",
}) as any as S.Schema<UpdateWorkspaceMetadataRequest>;
export interface UpdateWorkspaceMetadataResponse {}
export const UpdateWorkspaceMetadataResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateWorkspaceMetadataResponse",
}) as any as S.Schema<UpdateWorkspaceMetadataResponse>;
export interface UpdateWorkspacePageRequest {
  InstanceId: string;
  WorkspaceId: string;
  Page: string;
  NewPage?: string;
  ResourceArn?: string;
  Slug?: string;
  InputData?: string;
}
export const UpdateWorkspacePageRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    Page: S.String.pipe(T.HttpLabel("Page")),
    NewPage: S.optional(S.String),
    ResourceArn: S.optional(S.String),
    Slug: S.optional(S.String),
    InputData: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/pages/{Page}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateWorkspacePageRequest",
}) as any as S.Schema<UpdateWorkspacePageRequest>;
export interface UpdateWorkspacePageResponse {}
export const UpdateWorkspacePageResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateWorkspacePageResponse",
}) as any as S.Schema<UpdateWorkspacePageResponse>;
export interface UpdateWorkspaceThemeRequest {
  InstanceId: string;
  WorkspaceId: string;
  Theme?: WorkspaceTheme;
}
export const UpdateWorkspaceThemeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    Theme: S.optional(WorkspaceTheme),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/theme",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateWorkspaceThemeRequest",
}) as any as S.Schema<UpdateWorkspaceThemeRequest>;
export interface UpdateWorkspaceThemeResponse {}
export const UpdateWorkspaceThemeResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateWorkspaceThemeResponse",
}) as any as S.Schema<UpdateWorkspaceThemeResponse>;
export interface UpdateWorkspaceVisibilityRequest {
  InstanceId: string;
  WorkspaceId: string;
  Visibility: Visibility;
}
export const UpdateWorkspaceVisibilityRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    Visibility: Visibility,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/visibility",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotate({
  identifier: "UpdateWorkspaceVisibilityRequest",
}) as any as S.Schema<UpdateWorkspaceVisibilityRequest>;
export interface UpdateWorkspaceVisibilityResponse {}
export const UpdateWorkspaceVisibilityResponse = S.suspend(() =>
  S.Struct({}),
).annotate({
  identifier: "UpdateWorkspaceVisibilityResponse",
}) as any as S.Schema<UpdateWorkspaceVisibilityResponse>;

//# Errors
export class InternalServiceException extends S.TaggedErrorClass<InternalServiceException>()(
  "InternalServiceException",
  { Message: S.optional(S.String) },
).pipe(C.withServerError) {}
export class InvalidParameterException extends S.TaggedErrorClass<InvalidParameterException>()(
  "InvalidParameterException",
  { Message: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class ResourceConflictException extends S.TaggedErrorClass<ResourceConflictException>()(
  "ResourceConflictException",
  { Message: S.optional(S.String) },
).pipe(C.withConflictError) {}
export class ResourceNotFoundException extends S.TaggedErrorClass<ResourceNotFoundException>()(
  "ResourceNotFoundException",
  { Message: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class ThrottlingException extends S.TaggedErrorClass<ThrottlingException>()(
  "ThrottlingException",
  { Message: S.optional(S.String) },
  T.AwsQueryError({ code: "ThrottlingException", httpResponseCode: 429 }),
).pipe(C.withThrottlingError) {}
export class InvalidRequestException extends S.TaggedErrorClass<InvalidRequestException>()(
  "InvalidRequestException",
  {
    Message: S.optional(S.String),
    Reason: S.optional(InvalidRequestExceptionReason),
  },
).pipe(C.withBadRequestError) {}
export class ServiceQuotaExceededException extends S.TaggedErrorClass<ServiceQuotaExceededException>()(
  "ServiceQuotaExceededException",
  {
    Message: S.optional(S.String),
    Reason: S.optional(ServiceQuotaExceededExceptionReason),
  },
).pipe(C.withQuotaError) {}
export class LimitExceededException extends S.TaggedErrorClass<LimitExceededException>()(
  "LimitExceededException",
  { Message: S.optional(S.String) },
  T.AwsQueryError({ code: "LimitExceededException", httpResponseCode: 429 }),
).pipe(C.withThrottlingError) {}
export class AccessDeniedException extends S.TaggedErrorClass<AccessDeniedException>()(
  "AccessDeniedException",
  { Message: S.optional(S.String) },
  T.AwsQueryError({ code: "AccessDeniedException", httpResponseCode: 403 }),
).pipe(C.withAuthError) {}
export class IdempotencyException extends S.TaggedErrorClass<IdempotencyException>()(
  "IdempotencyException",
  { Message: S.optional(S.String) },
).pipe(C.withConflictError) {}
export class ConditionalOperationFailedException extends S.TaggedErrorClass<ConditionalOperationFailedException>()(
  "ConditionalOperationFailedException",
  { Message: S.optional(S.String) },
).pipe(C.withConflictError) {}
export class DuplicateResourceException extends S.TaggedErrorClass<DuplicateResourceException>()(
  "DuplicateResourceException",
  { Message: S.optional(S.String) },
).pipe(C.withConflictError) {}
export class ConflictException extends S.TaggedErrorClass<ConflictException>()(
  "ConflictException",
  { Message: S.optional(S.String) },
).pipe(C.withConflictError) {}
export class InvalidContactFlowException extends S.TaggedErrorClass<InvalidContactFlowException>()(
  "InvalidContactFlowException",
  { problems: S.optional(Problems) },
).pipe(C.withBadRequestError) {}
export class InvalidContactFlowModuleException extends S.TaggedErrorClass<InvalidContactFlowModuleException>()(
  "InvalidContactFlowModuleException",
  { Problems: S.optional(Problems) },
).pipe(C.withBadRequestError) {}
export class PropertyValidationException extends S.TaggedErrorClass<PropertyValidationException>()(
  "PropertyValidationException",
  {
    Message: S.String,
    PropertyList: S.optional(PropertyValidationExceptionPropertyList),
  },
).pipe(C.withBadRequestError) {}
export class InvalidTestCaseException extends S.TaggedErrorClass<InvalidTestCaseException>()(
  "InvalidTestCaseException",
  { Problems: S.optional(Problems) },
).pipe(C.withBadRequestError) {}
export class ResourceNotReadyException extends S.TaggedErrorClass<ResourceNotReadyException>()(
  "ResourceNotReadyException",
  { Message: S.optional(S.String) },
).pipe(C.withConflictError) {}
export class ResourceInUseException extends S.TaggedErrorClass<ResourceInUseException>()(
  "ResourceInUseException",
  {
    Message: S.optional(S.String),
    ResourceType: S.optional(ResourceType),
    ResourceId: S.optional(S.String),
  },
).pipe(C.withConflictError) {}
export class TooManyRequestsException extends S.TaggedErrorClass<TooManyRequestsException>()(
  "TooManyRequestsException",
  { Message: S.optional(S.String) },
).pipe(C.withThrottlingError) {}
export class ContactFlowNotPublishedException extends S.TaggedErrorClass<ContactFlowNotPublishedException>()(
  "ContactFlowNotPublishedException",
  { Message: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class UserNotFoundException extends S.TaggedErrorClass<UserNotFoundException>()(
  "UserNotFoundException",
  { Message: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class OutputTypeNotFoundException extends S.TaggedErrorClass<OutputTypeNotFoundException>()(
  "OutputTypeNotFoundException",
  { Message: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class InvalidActiveRegionException extends S.TaggedErrorClass<InvalidActiveRegionException>()(
  "InvalidActiveRegionException",
  { Message: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class MaximumResultReturnedException extends S.TaggedErrorClass<MaximumResultReturnedException>()(
  "MaximumResultReturnedException",
  { Message: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class DestinationNotAllowedException extends S.TaggedErrorClass<DestinationNotAllowedException>()(
  "DestinationNotAllowedException",
  { Message: S.optional(S.String) },
  T.AwsQueryError({
    code: "DestinationNotAllowedException",
    httpResponseCode: 403,
  }),
).pipe(C.withAuthError) {}
export class OutboundContactNotPermittedException extends S.TaggedErrorClass<OutboundContactNotPermittedException>()(
  "OutboundContactNotPermittedException",
  { Message: S.optional(S.String) },
  T.AwsQueryError({
    code: "OutboundContactNotPermittedException",
    httpResponseCode: 403,
  }),
).pipe(C.withAuthError) {}
export class ContactNotFoundException extends S.TaggedErrorClass<ContactNotFoundException>()(
  "ContactNotFoundException",
  { Message: S.optional(S.String) },
  T.AwsQueryError({ code: "ContactNotFoundException", httpResponseCode: 410 }),
).pipe(C.withBadRequestError) {}

//# Operations
export type ActivateEvaluationFormError =
  | InternalServiceException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Activates an evaluation form in the specified Amazon Connect instance. After the evaluation form is
 * activated, it is available to start new evaluations based on the form.
 */
export const activateEvaluationForm: API.OperationMethod<
  ActivateEvaluationFormRequest,
  ActivateEvaluationFormResponse,
  ActivateEvaluationFormError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ActivateEvaluationFormRequest,
  output: ActivateEvaluationFormResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type AssociateAnalyticsDataSetError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Associates the specified dataset for a Amazon Connect instance with the target account. You can associate
 * only one dataset in a single call.
 */
export const associateAnalyticsDataSet: API.OperationMethod<
  AssociateAnalyticsDataSetRequest,
  AssociateAnalyticsDataSetResponse,
  AssociateAnalyticsDataSetError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateAnalyticsDataSetRequest,
  output: AssociateAnalyticsDataSetResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type AssociateApprovedOriginError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Associates an approved origin to an Amazon Connect instance.
 */
export const associateApprovedOrigin: API.OperationMethod<
  AssociateApprovedOriginRequest,
  AssociateApprovedOriginResponse,
  AssociateApprovedOriginError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateApprovedOriginRequest,
  output: AssociateApprovedOriginResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type AssociateBotError =
  | InternalServiceException
  | InvalidRequestException
  | LimitExceededException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Allows the specified Amazon Connect instance to access the specified Amazon Lex or Amazon Lex V2
 * bot.
 */
export const associateBot: API.OperationMethod<
  AssociateBotRequest,
  AssociateBotResponse,
  AssociateBotError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateBotRequest,
  output: AssociateBotResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    LimitExceededException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type AssociateContactWithUserError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Associates a queued contact with an agent.
 *
 * **Use cases**
 *
 * Following are common uses cases for this API:
 *
 * - Programmatically assign queued contacts to available users.
 *
 * - Leverage the IAM context key `connect:PreferredUserArn` to restrict contact association to specific
 * preferred user.
 *
 * **Important things to know**
 *
 * - Use this API with chat, email, and task contacts. It does not support voice contacts.
 *
 * - Use it to associate contacts with users regardless of their current state, including custom states. Ensure
 * your application logic accounts for user availability before making associations.
 *
 * - It honors the IAM context key `connect:PreferredUserArn` to prevent unauthorized contact
 * associations.
 *
 * - It respects the IAM context key `connect:PreferredUserArn` to enforce authorization controls and
 * prevent unauthorized contact associations. Verify that your IAM policies are properly configured to support your
 * intended use cases.
 *
 * - The service quota *Queues per routing profile per instance* applies to manually assigned
 * queues, too. For more information about this quota, see Amazon Connect
 * quotas in the *Amazon Connect Administrator Guide*.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const associateContactWithUser: API.OperationMethod<
  AssociateContactWithUserRequest,
  AssociateContactWithUserResponse,
  AssociateContactWithUserError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateContactWithUserRequest,
  output: AssociateContactWithUserResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type AssociateDefaultVocabularyError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Associates an existing vocabulary as the default. Contact Lens for Amazon Connect uses the vocabulary in post-call and real-time
 * analysis sessions for the given language.
 */
export const associateDefaultVocabulary: API.OperationMethod<
  AssociateDefaultVocabularyRequest,
  AssociateDefaultVocabularyResponse,
  AssociateDefaultVocabularyError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateDefaultVocabularyRequest,
  output: AssociateDefaultVocabularyResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type AssociateEmailAddressAliasError =
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Associates an email address alias with an existing email address in an Amazon Connect instance. This creates
 * a forwarding relationship where emails sent to the alias email address are automatically forwarded to the primary
 * email address.
 *
 * **Use cases**
 *
 * Following are common uses cases for this API:
 *
 * - **Unified customer support**: Create multiple entry points (for example,
 * support@example.com, help@example.com, customercare@example.com) that all forward to a single agent queue for
 * streamlined management.
 *
 * - **Department consolidation**: Forward emails from legacy department addresses
 * (for example, sales@example.com, info@example.com) to a centralized customer service email during organizational
 * restructuring.
 *
 * - **Brand management**: Enable you to use familiar brand-specific email addresses
 * that forward to the appropriate Amazon Connect instance email address.
 *
 * **Important things to know**
 *
 * - Each email address can have a maximum of one alias. You cannot create multiple aliases for the same email
 * address.
 *
 * - If the alias email address already receives direct emails, it continues to receive direct emails plus
 * forwarded emails.
 *
 * - You cannot chain email aliases together (that is, create an alias of an alias).
 *
 * `AssociateEmailAddressAlias` does not return the following information:
 *
 * - A confirmation of the alias relationship details (you must call DescribeEmailAddress to verify).
 *
 * - The timestamp of when the association occurred.
 *
 * - The status of the forwarding configuration.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 *
 * **Related operations**
 *
 * - DisassociateEmailAddressAlias: Removes the alias association between two email addresses in an Amazon Connect instance.
 *
 * - DescribeEmailAddress: View current alias configurations for an email address.
 *
 * - SearchEmailAddresses: Find email addresses and their alias relationships across an instance.
 *
 * - CreateEmailAddress: Create new email addresses that can participate in alias relationships.
 *
 * - DeleteEmailAddress: Remove email addresses (automatically removes any alias relationships).
 *
 * - UpdateEmailAddressMetadata: Modify email address properties (does not affect alias relationships).
 */
export const associateEmailAddressAlias: API.OperationMethod<
  AssociateEmailAddressAliasRequest,
  AssociateEmailAddressAliasResponse,
  AssociateEmailAddressAliasError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateEmailAddressAliasRequest,
  output: AssociateEmailAddressAliasResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type AssociateFlowError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Associates a connect resource to a flow.
 */
export const associateFlow: API.OperationMethod<
  AssociateFlowRequest,
  AssociateFlowResponse,
  AssociateFlowError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateFlowRequest,
  output: AssociateFlowResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type AssociateHoursOfOperationsError =
  | ConditionalOperationFailedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Associates a set of hours of operations with another hours of operation. Refer to Administrator Guide here for more information on inheriting overrides from parent hours of operation(s).
 */
export const associateHoursOfOperations: API.OperationMethod<
  AssociateHoursOfOperationsRequest,
  AssociateHoursOfOperationsResponse,
  AssociateHoursOfOperationsError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateHoursOfOperationsRequest,
  output: AssociateHoursOfOperationsResponse,
  errors: [
    ConditionalOperationFailedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type AssociateInstanceStorageConfigError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Associates a storage resource type for the first time. You can only associate one type of storage configuration
 * in a single call. This means, for example, that you can't define an instance with multiple S3 buckets for storing
 * chat transcripts.
 *
 * This API does not create a resource that doesn't exist. It only associates it to the instance. Ensure that the
 * resource being specified in the storage configuration, like an S3 bucket, exists when being used for
 * association.
 */
export const associateInstanceStorageConfig: API.OperationMethod<
  AssociateInstanceStorageConfigRequest,
  AssociateInstanceStorageConfigResponse,
  AssociateInstanceStorageConfigError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateInstanceStorageConfigRequest,
  output: AssociateInstanceStorageConfigResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type AssociateLambdaFunctionError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Allows the specified Amazon Connect instance to access the specified Lambda function.
 */
export const associateLambdaFunction: API.OperationMethod<
  AssociateLambdaFunctionRequest,
  AssociateLambdaFunctionResponse,
  AssociateLambdaFunctionError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateLambdaFunctionRequest,
  output: AssociateLambdaFunctionResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type AssociateLexBotError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Allows the specified Amazon Connect instance to access the specified Amazon Lex V1 bot. This API
 * only supports the association of Amazon Lex V1 bots.
 */
export const associateLexBot: API.OperationMethod<
  AssociateLexBotRequest,
  AssociateLexBotResponse,
  AssociateLexBotError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateLexBotRequest,
  output: AssociateLexBotResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type AssociatePhoneNumberContactFlowError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Associates a flow with a phone number claimed to your Amazon Connect instance.
 *
 * If the number is claimed to a traffic distribution group, and you are calling this API using an instance in the Amazon Web Services Region where the traffic distribution group was created, you can use either a full phone number ARN or UUID value for the
 * `PhoneNumberId` URI request parameter. However, if the number is claimed to a traffic distribution group and you are calling
 * this API using an instance in the alternate Amazon Web Services Region associated with the traffic distribution group, you must provide a
 * full phone number ARN. If a UUID is provided
 * in
 * this scenario, you will receive a `ResourceNotFoundException`.
 */
export const associatePhoneNumberContactFlow: API.OperationMethod<
  AssociatePhoneNumberContactFlowRequest,
  AssociatePhoneNumberContactFlowResponse,
  AssociatePhoneNumberContactFlowError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociatePhoneNumberContactFlowRequest,
  output: AssociatePhoneNumberContactFlowResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type AssociateQueueQuickConnectsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Associates a set of quick connects with a queue.
 */
export const associateQueueQuickConnects: API.OperationMethod<
  AssociateQueueQuickConnectsRequest,
  AssociateQueueQuickConnectsResponse,
  AssociateQueueQuickConnectsError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateQueueQuickConnectsRequest,
  output: AssociateQueueQuickConnectsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type AssociateRoutingProfileQueuesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Associates a set of queues with a routing profile.
 */
export const associateRoutingProfileQueues: API.OperationMethod<
  AssociateRoutingProfileQueuesRequest,
  AssociateRoutingProfileQueuesResponse,
  AssociateRoutingProfileQueuesError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateRoutingProfileQueuesRequest,
  output: AssociateRoutingProfileQueuesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type AssociateSecurityKeyError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Associates a security key to the instance.
 */
export const associateSecurityKey: API.OperationMethod<
  AssociateSecurityKeyRequest,
  AssociateSecurityKeyResponse,
  AssociateSecurityKeyError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateSecurityKeyRequest,
  output: AssociateSecurityKeyResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type AssociateSecurityProfilesError =
  | AccessDeniedException
  | ConditionalOperationFailedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | CommonErrors;
/**
 * Associate security profiles with an Entity in an Amazon Connect instance.
 */
export const associateSecurityProfiles: API.OperationMethod<
  AssociateSecurityProfilesRequest,
  AssociateSecurityProfilesResponse,
  AssociateSecurityProfilesError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateSecurityProfilesRequest,
  output: AssociateSecurityProfilesResponse,
  errors: [
    AccessDeniedException,
    ConditionalOperationFailedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
  ],
}));
export type AssociateTrafficDistributionGroupUserError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Associates an agent with a traffic distribution group. This API can be called only in the Region where the traffic distribution group
 * is created.
 */
export const associateTrafficDistributionGroupUser: API.OperationMethod<
  AssociateTrafficDistributionGroupUserRequest,
  AssociateTrafficDistributionGroupUserResponse,
  AssociateTrafficDistributionGroupUserError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateTrafficDistributionGroupUserRequest,
  output: AssociateTrafficDistributionGroupUserResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type AssociateUserProficienciesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Associates a set of proficiencies with a user.
 */
export const associateUserProficiencies: API.OperationMethod<
  AssociateUserProficienciesRequest,
  AssociateUserProficienciesResponse,
  AssociateUserProficienciesError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateUserProficienciesRequest,
  output: AssociateUserProficienciesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type AssociateWorkspaceError =
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Associates a workspace with one or more users or routing profiles, allowing them to access the workspace's
 * configured views and pages.
 */
export const associateWorkspace: API.OperationMethod<
  AssociateWorkspaceRequest,
  AssociateWorkspaceResponse,
  AssociateWorkspaceError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateWorkspaceRequest,
  output: AssociateWorkspaceResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type BatchAssociateAnalyticsDataSetError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Associates a list of analytics datasets for a given Amazon Connect instance to a target account. You can
 * associate multiple datasets in a single call.
 */
export const batchAssociateAnalyticsDataSet: API.OperationMethod<
  BatchAssociateAnalyticsDataSetRequest,
  BatchAssociateAnalyticsDataSetResponse,
  BatchAssociateAnalyticsDataSetError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchAssociateAnalyticsDataSetRequest,
  output: BatchAssociateAnalyticsDataSetResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type BatchCreateDataTableValueError =
  | AccessDeniedException
  | ConflictException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates values for attributes in a data table. The value may be a default or it may be associated with a primary
 * value. The value must pass all customer defined validation as well as the default validation for the value type. The
 * operation must conform to Batch Operation API Standards. Although the standard specifies that successful and failed
 * entities are listed separately in the response, authorization fails if any primary values or attributes are
 * unauthorized. The combination of primary values and the attribute name serve as the identifier for the individual
 * item request.
 */
export const batchCreateDataTableValue: API.OperationMethod<
  BatchCreateDataTableValueRequest,
  BatchCreateDataTableValueResponse,
  BatchCreateDataTableValueError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchCreateDataTableValueRequest,
  output: BatchCreateDataTableValueResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type BatchDeleteDataTableValueError =
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes multiple values from a data table. API users may delete values at any time. When deletion is requested
 * from the admin website, a warning is shown alerting the user of the most recent time the attribute and its values
 * were accessed. System managed values are not deletable by customers.
 */
export const batchDeleteDataTableValue: API.OperationMethod<
  BatchDeleteDataTableValueRequest,
  BatchDeleteDataTableValueResponse,
  BatchDeleteDataTableValueError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchDeleteDataTableValueRequest,
  output: BatchDeleteDataTableValueResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type BatchDescribeDataTableValueError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Retrieves multiple values from a data table without evaluating expressions. Returns the raw stored values along
 * with metadata such as lock versions and modification timestamps. "Describe" is a deprecated term but is allowed to
 * maintain consistency with existing operations.
 */
export const batchDescribeDataTableValue: API.OperationMethod<
  BatchDescribeDataTableValueRequest,
  BatchDescribeDataTableValueResponse,
  BatchDescribeDataTableValueError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchDescribeDataTableValueRequest,
  output: BatchDescribeDataTableValueResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type BatchDisassociateAnalyticsDataSetError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Removes a list of analytics datasets associated with a given Amazon Connect instance. You can disassociate
 * multiple datasets in a single call.
 */
export const batchDisassociateAnalyticsDataSet: API.OperationMethod<
  BatchDisassociateAnalyticsDataSetRequest,
  BatchDisassociateAnalyticsDataSetResponse,
  BatchDisassociateAnalyticsDataSetError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchDisassociateAnalyticsDataSetRequest,
  output: BatchDisassociateAnalyticsDataSetResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type BatchGetAttachedFileMetadataError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Allows you to retrieve metadata about multiple attached files on an associated resource. Each attached file
 * provided in the input list must be associated with the input AssociatedResourceArn.
 */
export const batchGetAttachedFileMetadata: API.OperationMethod<
  BatchGetAttachedFileMetadataRequest,
  BatchGetAttachedFileMetadataResponse,
  BatchGetAttachedFileMetadataError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchGetAttachedFileMetadataRequest,
  output: BatchGetAttachedFileMetadataResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type BatchGetFlowAssociationError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Retrieve the flow associations for the given resources.
 */
export const batchGetFlowAssociation: API.OperationMethod<
  BatchGetFlowAssociationRequest,
  BatchGetFlowAssociationResponse,
  BatchGetFlowAssociationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchGetFlowAssociationRequest,
  output: BatchGetFlowAssociationResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type BatchPutContactError =
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | CommonErrors;
/**
 * Only the Amazon Connect outbound campaigns service principal is allowed to assume a role in your account
 * and call this API.
 *
 * Allows you to create a batch of contacts in Amazon Connect. The outbound campaigns capability ingests dial
 * requests via the PutDialRequestBatch API. It then uses BatchPutContact to create contacts corresponding to those dial
 * requests. If agents are available, the dial requests are dialed out, which results in a voice call. The resulting
 * voice call uses the same contactId that was created by BatchPutContact.
 */
export const batchPutContact: API.OperationMethod<
  BatchPutContactRequest,
  BatchPutContactResponse,
  BatchPutContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchPutContactRequest,
  output: BatchPutContactResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
  ],
}));
export type BatchUpdateDataTableValueError =
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates multiple data table values using all properties from BatchCreateDataTableValue. System managed values
 * are not modifiable by customers. The operation requires proper lock versions to prevent concurrent modification
 * conflicts.
 */
export const batchUpdateDataTableValue: API.OperationMethod<
  BatchUpdateDataTableValueRequest,
  BatchUpdateDataTableValueResponse,
  BatchUpdateDataTableValueError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchUpdateDataTableValueRequest,
  output: BatchUpdateDataTableValueResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type ClaimPhoneNumberError =
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Claims an available phone number to your Amazon Connect instance or traffic distribution group. You can call
 * this API only in the same Amazon Web Services Region where the Amazon Connect instance or traffic distribution group was
 * created.
 *
 * For more information about how to use this operation, see Claim a phone number in your country and Claim
 * phone numbers to traffic distribution groups in the Amazon Connect Administrator
 * Guide.
 *
 * You can call the SearchAvailablePhoneNumbers API for
 * available phone numbers that you can claim. Call the DescribePhoneNumber API to verify the status
 * of a previous ClaimPhoneNumber operation.
 *
 * If you plan to claim and release numbers frequently,
 * contact us for a service quota exception. Otherwise, it is possible you will be blocked from
 * claiming and releasing any more numbers until up to 180 days past the oldest number
 * released has expired.
 *
 * By default you can claim and release up to 200% of your maximum number of active
 * phone numbers. If you claim and release phone numbers using
 * the UI or API during a rolling 180 day cycle that exceeds 200% of your phone number
 * service level quota, you will be blocked from claiming any more numbers until 180
 * days past the oldest number released has expired.
 *
 * For example, if you already have 99 claimed numbers and a service level quota of 99 phone numbers, and in any 180
 * day period you release 99, claim 99, and then release 99, you will have exceeded the
 * 200% limit. At that point you are blocked from claiming any more numbers until you
 * open an Amazon Web Services support ticket.
 */
export const claimPhoneNumber: API.OperationMethod<
  ClaimPhoneNumberRequest,
  ClaimPhoneNumberResponse,
  ClaimPhoneNumberError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ClaimPhoneNumberRequest,
  output: ClaimPhoneNumberResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CompleteAttachedFileUploadError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Allows you to confirm that the attached file has been uploaded using the pre-signed URL provided in the
 * StartAttachedFileUpload API.
 */
export const completeAttachedFileUpload: API.OperationMethod<
  CompleteAttachedFileUploadRequest,
  CompleteAttachedFileUploadResponse,
  CompleteAttachedFileUploadError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CompleteAttachedFileUploadRequest,
  output: CompleteAttachedFileUploadResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreateAgentStatusError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates an agent status for the specified Amazon Connect instance.
 */
export const createAgentStatus: API.OperationMethod<
  CreateAgentStatusRequest,
  CreateAgentStatusResponse,
  CreateAgentStatusError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateAgentStatusRequest,
  output: CreateAgentStatusResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreateContactError =
  | AccessDeniedException
  | ConflictException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Only the VOICE, EMAIL, and TASK channels are supported.
 *
 * - For VOICE: The supported initiation method is `TRANSFER`. The contacts created with this
 * initiation method have a subtype `connect:ExternalAudio`.
 *
 * - For EMAIL: The supported initiation methods are `OUTBOUND`, `AGENT_REPLY`, and
 * `FLOW`.
 *
 * - For TASK: The supported initiation method is `API`. Contacts created with this API have a sub-type
 * of `connect:ExternalTask`.
 *
 * Creates a new VOICE, EMAIL, or TASK contact.
 *
 * After a contact is created, you can move it to the desired state by using the `InitiateAs` parameter.
 * While you can use API to create task contacts that are in the `COMPLETED` state, you must contact Amazon Web Services Support before using it for bulk import use cases. Bulk import causes your requests to be throttled or
 * fail if your CreateContact limits aren't high enough.
 */
export const createContact: API.OperationMethod<
  CreateContactRequest,
  CreateContactResponse,
  CreateContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateContactRequest,
  output: CreateContactResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type CreateContactFlowError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidContactFlowException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a flow for the specified Amazon Connect instance.
 *
 * You can also create and update flows using the Amazon Connect
 * Flow language.
 */
export const createContactFlow: API.OperationMethod<
  CreateContactFlowRequest,
  CreateContactFlowResponse,
  CreateContactFlowError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateContactFlowRequest,
  output: CreateContactFlowResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidContactFlowException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreateContactFlowModuleError =
  | AccessDeniedException
  | DuplicateResourceException
  | IdempotencyException
  | InternalServiceException
  | InvalidContactFlowModuleException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a flow module for the specified Amazon Connect instance.
 */
export const createContactFlowModule: API.OperationMethod<
  CreateContactFlowModuleRequest,
  CreateContactFlowModuleResponse,
  CreateContactFlowModuleError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateContactFlowModuleRequest,
  output: CreateContactFlowModuleResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    IdempotencyException,
    InternalServiceException,
    InvalidContactFlowModuleException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreateContactFlowModuleAliasError =
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a named alias that points to a specific version of a contact flow module.
 */
export const createContactFlowModuleAlias: API.OperationMethod<
  CreateContactFlowModuleAliasRequest,
  CreateContactFlowModuleAliasResponse,
  CreateContactFlowModuleAliasError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateContactFlowModuleAliasRequest,
  output: CreateContactFlowModuleAliasResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreateContactFlowModuleVersionError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates an immutable snapshot of a contact flow module, preserving its content and settings at a specific point
 * in time for version control and rollback capabilities.
 */
export const createContactFlowModuleVersion: API.OperationMethod<
  CreateContactFlowModuleVersionRequest,
  CreateContactFlowModuleVersionResponse,
  CreateContactFlowModuleVersionError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateContactFlowModuleVersionRequest,
  output: CreateContactFlowModuleVersionResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreateContactFlowVersionError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Publishes a new version of the flow provided. Versions are immutable and monotonically increasing. If the
 * `FlowContentSha256` provided is different from the `FlowContentSha256` of the
 * `$LATEST` published flow content, then an error is returned. This API only supports creating versions for
 * flows of type `Campaign`.
 */
export const createContactFlowVersion: API.OperationMethod<
  CreateContactFlowVersionRequest,
  CreateContactFlowVersionResponse,
  CreateContactFlowVersionError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateContactFlowVersionRequest,
  output: CreateContactFlowVersionResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreateDataTableError =
  | AccessDeniedException
  | ConflictException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a new data table with the specified properties. Supports the creation of all table properties except for
 * attributes and values. A table with no attributes and values is a valid state for a table. The number of tables per
 * instance is limited to 100 per instance. Customers can request an increase by using Amazon Web Services Service Quotas.
 */
export const createDataTable: API.OperationMethod<
  CreateDataTableRequest,
  CreateDataTableResponse,
  CreateDataTableError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateDataTableRequest,
  output: CreateDataTableResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type CreateDataTableAttributeError =
  | AccessDeniedException
  | ConflictException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Adds an attribute to an existing data table. Creating a new primary attribute uses the empty value for the
 * specified value type for all existing records. This should not affect uniqueness of published data tables since the
 * existing primary values will already be unique. Creating attributes does not create any values. System managed tables
 * may not allow customers to create new attributes.
 */
export const createDataTableAttribute: API.OperationMethod<
  CreateDataTableAttributeRequest,
  CreateDataTableAttributeResponse,
  CreateDataTableAttributeError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateDataTableAttributeRequest,
  output: CreateDataTableAttributeResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type CreateEmailAddressError =
  | AccessDeniedException
  | DuplicateResourceException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Create new email address in the specified Amazon Connect instance. For more information about email
 * addresses, see Create email
 * addresses in the Amazon Connect Administrator Guide.
 */
export const createEmailAddress: API.OperationMethod<
  CreateEmailAddressRequest,
  CreateEmailAddressResponse,
  CreateEmailAddressError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateEmailAddressRequest,
  output: CreateEmailAddressResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type CreateEvaluationFormError =
  | InternalServiceException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates an evaluation form in the specified Amazon Connect instance. The form can be used to define
 * questions related to agent performance, and create sections to organize such questions. Question and section
 * identifiers cannot be duplicated within the same evaluation form.
 */
export const createEvaluationForm: API.OperationMethod<
  CreateEvaluationFormRequest,
  CreateEvaluationFormResponse,
  CreateEvaluationFormError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateEvaluationFormRequest,
  output: CreateEvaluationFormResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type CreateHoursOfOperationError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates hours of operation.
 */
export const createHoursOfOperation: API.OperationMethod<
  CreateHoursOfOperationRequest,
  CreateHoursOfOperationResponse,
  CreateHoursOfOperationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateHoursOfOperationRequest,
  output: CreateHoursOfOperationResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type CreateHoursOfOperationOverrideError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates an hours of operation override in an Amazon Connect hours of operation resource.
 */
export const createHoursOfOperationOverride: API.OperationMethod<
  CreateHoursOfOperationOverrideRequest,
  CreateHoursOfOperationOverrideResponse,
  CreateHoursOfOperationOverrideError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateHoursOfOperationOverrideRequest,
  output: CreateHoursOfOperationOverrideResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreateInstanceError =
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Initiates an Amazon Connect instance with all the supported channels enabled. It does not attach any
 * storage, such as Amazon Simple Storage Service (Amazon S3) or Amazon Kinesis. It also does not allow for any
 * configurations on features, such as Contact Lens for Amazon Connect.
 *
 * For more information, see Create an Amazon Connect instance in the
 * *Amazon Connect Administrator Guide*.
 *
 * Amazon Connect enforces a limit on the total number of instances that you can create or delete in 30 days.
 * If you exceed this limit, you will get an error message indicating there has been an excessive number of attempts at creating or deleting instances.
 * You must wait 30 days before you can restart creating and deleting instances in your account.
 */
export const createInstance: API.OperationMethod<
  CreateInstanceRequest,
  CreateInstanceResponse,
  CreateInstanceError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateInstanceRequest,
  output: CreateInstanceResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type CreateIntegrationAssociationError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates an Amazon Web Services resource association with an Amazon Connect instance.
 */
export const createIntegrationAssociation: API.OperationMethod<
  CreateIntegrationAssociationRequest,
  CreateIntegrationAssociationResponse,
  CreateIntegrationAssociationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateIntegrationAssociationRequest,
  output: CreateIntegrationAssociationResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreateNotificationError =
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a new notification to be delivered to specified recipients. Notifications can include localized content with links, and an optional expiration time. Recipients can be specified as individual user ARNs or instance ARNs to target all users in an instance.
 */
export const createNotification: API.OperationMethod<
  CreateNotificationRequest,
  CreateNotificationResponse,
  CreateNotificationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateNotificationRequest,
  output: CreateNotificationResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreateParticipantError =
  | ConflictException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Adds a new participant into an on-going chat contact or webRTC call. For more information, see Customize chat flow experiences by
 * integrating custom participants or Enable multi-user web, in-app, and video
 * calling.
 */
export const createParticipant: API.OperationMethod<
  CreateParticipantRequest,
  CreateParticipantResponse,
  CreateParticipantError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateParticipantRequest,
  output: CreateParticipantResponse,
  errors: [
    ConflictException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type CreatePersistentContactAssociationError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Enables rehydration of chats for the lifespan of a contact. For more information about chat rehydration, see
 * Enable persistent chat in
 * the *Amazon Connect Administrator Guide*.
 */
export const createPersistentContactAssociation: API.OperationMethod<
  CreatePersistentContactAssociationRequest,
  CreatePersistentContactAssociationResponse,
  CreatePersistentContactAssociationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreatePersistentContactAssociationRequest,
  output: CreatePersistentContactAssociationResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreatePredefinedAttributeError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a new predefined attribute for the specified Amazon Connect instance. A *predefined attribute*
 * is made up of a name and a value.
 *
 * For the predefined attributes per instance quota, see Amazon Connect
 * quotas.
 *
 * **Use cases**
 *
 * Following are common uses cases for this API:
 *
 * - Create an attribute for routing proficiency (for example, agent certification) that has predefined values (for
 * example, a list of possible certifications). For more information, see Create predefined attributes for routing contacts to
 * agents.
 *
 * - Create an attribute for business unit name that has a list of predefined business unit names used in your
 * organization. This is a use case where information for a contact varies between transfers or conferences. For more
 * information, see Use contact segment attributes.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const createPredefinedAttribute: API.OperationMethod<
  CreatePredefinedAttributeRequest,
  CreatePredefinedAttributeResponse,
  CreatePredefinedAttributeError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreatePredefinedAttributeRequest,
  output: CreatePredefinedAttributeResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreatePromptError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a prompt. For more information about prompts, such as supported file types and maximum length, see
 * Create prompts in the
 * *Amazon Connect Administrator Guide*.
 */
export const createPrompt: API.OperationMethod<
  CreatePromptRequest,
  CreatePromptResponse,
  CreatePromptError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreatePromptRequest,
  output: CreatePromptResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ThrottlingException,
  ],
}));
export type CreatePushNotificationRegistrationError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates registration for a device token and a chat contact to receive real-time push notifications. For more
 * information about push notifications, see Set up push notifications in Amazon Connect for mobile chat in the *Amazon Connect Administrator Guide*.
 */
export const createPushNotificationRegistration: API.OperationMethod<
  CreatePushNotificationRegistrationRequest,
  CreatePushNotificationRegistrationResponse,
  CreatePushNotificationRegistrationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreatePushNotificationRegistrationRequest,
  output: CreatePushNotificationRegistrationResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type CreateQueueError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a new queue for the specified Amazon Connect instance.
 *
 * - If the phone number is claimed to a traffic distribution group that was created in the
 * same Region as the Amazon Connect instance where you are calling this API, then you can use a
 * full phone number ARN or a UUID for `OutboundCallerIdNumberId`. However, if the phone number is claimed
 * to a traffic distribution group that is in one Region, and you are calling this API from an instance in another Amazon Web Services Region that is associated with the traffic distribution group, you must provide a full phone number ARN. If a
 * UUID is provided in this scenario, you will receive a
 * `ResourceNotFoundException`.
 *
 * - Only use the phone number ARN format that doesn't contain `instance` in the path, for example,
 * `arn:aws:connect:us-east-1:1234567890:phone-number/uuid`. This is the same ARN format that is returned
 * when you call the ListPhoneNumbersV2 API.
 *
 * - If you plan to use IAM policies to allow/deny access to this API for phone number resources
 * claimed to a traffic distribution group, see Allow or Deny queue API actions for phone numbers in a replica Region.
 */
export const createQueue: API.OperationMethod<
  CreateQueueRequest,
  CreateQueueResponse,
  CreateQueueError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateQueueRequest,
  output: CreateQueueResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreateQuickConnectError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a quick connect for the specified Amazon Connect instance.
 */
export const createQuickConnect: API.OperationMethod<
  CreateQuickConnectRequest,
  CreateQuickConnectResponse,
  CreateQuickConnectError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateQuickConnectRequest,
  output: CreateQuickConnectResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreateRoutingProfileError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a new routing profile.
 */
export const createRoutingProfile: API.OperationMethod<
  CreateRoutingProfileRequest,
  CreateRoutingProfileResponse,
  CreateRoutingProfileError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateRoutingProfileRequest,
  output: CreateRoutingProfileResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreateRuleError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a rule for the specified Amazon Connect instance.
 *
 * Use the Rules Function
 * language to code conditions for the rule.
 */
export const createRule: API.OperationMethod<
  CreateRuleRequest,
  CreateRuleResponse,
  CreateRuleError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateRuleRequest,
  output: CreateRuleResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type CreateSecurityProfileError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a security profile.
 *
 * For information about security profiles, see Security Profiles in the *Amazon Connect Administrator Guide*. For a mapping of the API name and user interface name of the security
 * profile permissions, see List
 * of security profile permissions.
 */
export const createSecurityProfile: API.OperationMethod<
  CreateSecurityProfileRequest,
  CreateSecurityProfileResponse,
  CreateSecurityProfileError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateSecurityProfileRequest,
  output: CreateSecurityProfileResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreateTaskTemplateError =
  | InternalServiceException
  | InvalidParameterException
  | PropertyValidationException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a new task template in the specified Amazon Connect instance.
 */
export const createTaskTemplate: API.OperationMethod<
  CreateTaskTemplateRequest,
  CreateTaskTemplateResponse,
  CreateTaskTemplateError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTaskTemplateRequest,
  output: CreateTaskTemplateResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    PropertyValidationException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type CreateTestCaseError =
  | AccessDeniedException
  | DuplicateResourceException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | InvalidTestCaseException
  | LimitExceededException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a test case with its content and metadata for the specified Amazon Connect instance.
 */
export const createTestCase: API.OperationMethod<
  CreateTestCaseRequest,
  CreateTestCaseResponse,
  CreateTestCaseError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTestCaseRequest,
  output: CreateTestCaseResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    InvalidTestCaseException,
    LimitExceededException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type CreateTrafficDistributionGroupError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ResourceNotReadyException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a traffic distribution group given an Amazon Connect instance that has been replicated.
 *
 * The `SignInConfig` distribution is available only on a
 * default `TrafficDistributionGroup` (see the `IsDefault` parameter in the
 * TrafficDistributionGroup
 * data type). If you call
 * `UpdateTrafficDistribution` with a modified `SignInConfig` and a non-default `TrafficDistributionGroup`,
 * an `InvalidRequestException` is returned.
 *
 * For more information about creating traffic distribution groups, see Set up traffic distribution groups in the
 * *Amazon Connect Administrator Guide*.
 */
export const createTrafficDistributionGroup: API.OperationMethod<
  CreateTrafficDistributionGroupRequest,
  CreateTrafficDistributionGroupResponse,
  CreateTrafficDistributionGroupError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTrafficDistributionGroupRequest,
  output: CreateTrafficDistributionGroupResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ResourceNotReadyException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type CreateUseCaseError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a use case for an integration association.
 */
export const createUseCase: API.OperationMethod<
  CreateUseCaseRequest,
  CreateUseCaseResponse,
  CreateUseCaseError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateUseCaseRequest,
  output: CreateUseCaseResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreateUserError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a user account for the specified Amazon Connect instance.
 *
 * Certain UserIdentityInfo parameters are required in some situations. For example, `Email`,
 * `FirstName` and `LastName` are required if you are using Amazon Connect or SAML for
 * identity management.
 *
 * Fields in `PhoneConfig` cannot be set simultaneously with their corresponding channel-specific configuration parameters. Specifically:
 *
 * - `PhoneConfig.AutoAccept` conflicts with `AutoAcceptConfigs`
 *
 * - `PhoneConfig.AfterContactWorkTimeLimit` conflicts with `AfterContactWorkConfigs`
 *
 * - `PhoneConfig.PhoneType` and `PhoneConfig.PhoneNumber` conflict with `PhoneNumberConfigs`
 *
 * - `PhoneConfig.PersistentConnection` conflicts with `PersistentConnectionConfigs`
 *
 * We recommend using channel-specific parameters such as `AutoAcceptConfigs`, `AfterContactWorkConfigs`, `PhoneNumberConfigs`, `PersistentConnectionConfigs`, and `VoiceEnhancementConfigs` for per-channel configuration.
 *
 * For information about how to create users using the Amazon Connect admin website, see Add Users in the Amazon Connect
 * Administrator Guide.
 */
export const createUser: API.OperationMethod<
  CreateUserRequest,
  CreateUserResponse,
  CreateUserError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateUserRequest,
  output: CreateUserResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreateUserHierarchyGroupError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a new user hierarchy group.
 */
export const createUserHierarchyGroup: API.OperationMethod<
  CreateUserHierarchyGroupRequest,
  CreateUserHierarchyGroupResponse,
  CreateUserHierarchyGroupError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateUserHierarchyGroupRequest,
  output: CreateUserHierarchyGroupResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type CreateViewError =
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | TooManyRequestsException
  | CommonErrors;
/**
 * Creates a new view with the possible status of `SAVED` or `PUBLISHED`.
 *
 * The views will have a unique name for each connect instance.
 *
 * It performs basic content validation if the status is `SAVED` or full content validation if the
 * status is set to `PUBLISHED`. An error is returned if validation fails. It associates either the
 * `$SAVED` qualifier or both of the `$SAVED` and `$LATEST` qualifiers with the
 * provided view content based on the status. The view is idempotent if ClientToken is provided.
 */
export const createView: API.OperationMethod<
  CreateViewRequest,
  CreateViewResponse,
  CreateViewError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateViewRequest,
  output: CreateViewResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    TooManyRequestsException,
  ],
}));
export type CreateViewVersionError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | TooManyRequestsException
  | CommonErrors;
/**
 * Publishes a new version of the view identifier.
 *
 * Versions are immutable and monotonically increasing.
 *
 * It returns the highest version if there is no change in content compared to that version. An error is displayed
 * if the supplied ViewContentSha256 is different from the ViewContentSha256 of the `$LATEST` alias.
 */
export const createViewVersion: API.OperationMethod<
  CreateViewVersionRequest,
  CreateViewVersionResponse,
  CreateViewVersionError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateViewVersionRequest,
  output: CreateViewVersionResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    TooManyRequestsException,
  ],
}));
export type CreateVocabularyError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a custom vocabulary associated with your Amazon Connect instance. You can set a custom vocabulary to
 * be your default vocabulary for a given language. Contact Lens for Amazon Connect uses the default vocabulary in post-call and real-time
 * contact analysis sessions for that language.
 */
export const createVocabulary: API.OperationMethod<
  CreateVocabularyRequest,
  CreateVocabularyResponse,
  CreateVocabularyError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVocabularyRequest,
  output: CreateVocabularyResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type CreateWorkspaceError =
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates a workspace that defines the user experience by mapping views to pages. Workspaces can be assigned to
 * users or routing profiles.
 */
export const createWorkspace: API.OperationMethod<
  CreateWorkspaceRequest,
  CreateWorkspaceResponse,
  CreateWorkspaceError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateWorkspaceRequest,
  output: CreateWorkspaceResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type CreateWorkspacePageError =
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Associates a view with a page in a workspace, defining what users see when they navigate to that page.
 */
export const createWorkspacePage: API.OperationMethod<
  CreateWorkspacePageRequest,
  CreateWorkspacePageResponse,
  CreateWorkspacePageError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateWorkspacePageRequest,
  output: CreateWorkspacePageResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type DeactivateEvaluationFormError =
  | InternalServiceException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deactivates an evaluation form in the specified Amazon Connect instance. After a form is deactivated, it is no longer
 * available for users to start new evaluations based on the form.
 */
export const deactivateEvaluationForm: API.OperationMethod<
  DeactivateEvaluationFormRequest,
  DeactivateEvaluationFormResponse,
  DeactivateEvaluationFormError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeactivateEvaluationFormRequest,
  output: DeactivateEvaluationFormResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteAttachedFileError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes an attached file along with the underlying S3 Object.
 *
 * The attached file is **permanently deleted** if S3 bucket versioning is not
 * enabled.
 */
export const deleteAttachedFile: API.OperationMethod<
  DeleteAttachedFileRequest,
  DeleteAttachedFileResponse,
  DeleteAttachedFileError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteAttachedFileRequest,
  output: DeleteAttachedFileResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteContactEvaluationError =
  | InternalServiceException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes a contact evaluation in the specified Amazon Connect instance.
 */
export const deleteContactEvaluation: API.OperationMethod<
  DeleteContactEvaluationRequest,
  DeleteContactEvaluationResponse,
  DeleteContactEvaluationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteContactEvaluationRequest,
  output: DeleteContactEvaluationResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteContactFlowError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes a flow for the specified Amazon Connect instance.
 */
export const deleteContactFlow: API.OperationMethod<
  DeleteContactFlowRequest,
  DeleteContactFlowResponse,
  DeleteContactFlowError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteContactFlowRequest,
  output: DeleteContactFlowResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteContactFlowModuleError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes the specified flow module.
 */
export const deleteContactFlowModule: API.OperationMethod<
  DeleteContactFlowModuleRequest,
  DeleteContactFlowModuleResponse,
  DeleteContactFlowModuleError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteContactFlowModuleRequest,
  output: DeleteContactFlowModuleResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteContactFlowModuleAliasError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Removes an alias reference, breaking the named connection to the underlying module version without affecting the
 * version itself.
 */
export const deleteContactFlowModuleAlias: API.OperationMethod<
  DeleteContactFlowModuleAliasRequest,
  DeleteContactFlowModuleAliasResponse,
  DeleteContactFlowModuleAliasError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteContactFlowModuleAliasRequest,
  output: DeleteContactFlowModuleAliasResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteContactFlowModuleVersionError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Removes a specific version of a contact flow module.
 */
export const deleteContactFlowModuleVersion: API.OperationMethod<
  DeleteContactFlowModuleVersionRequest,
  DeleteContactFlowModuleVersionResponse,
  DeleteContactFlowModuleVersionError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteContactFlowModuleVersionRequest,
  output: DeleteContactFlowModuleVersionResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteContactFlowVersionError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes the particular version specified in flow version identifier.
 */
export const deleteContactFlowVersion: API.OperationMethod<
  DeleteContactFlowVersionRequest,
  DeleteContactFlowVersionResponse,
  DeleteContactFlowVersionError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteContactFlowVersionRequest,
  output: DeleteContactFlowVersionResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteDataTableError =
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes a data table and all associated attributes, versions, audits, and values. Does not update any references
 * to the data table, even from other data tables. This includes dynamic values and conditional validations. System
 * managed data tables are not deletable by customers. API users may delete the table at any time. When deletion is
 * requested from the admin website, a warning is shown alerting the user of the most recent time the table and its
 * values were accessed.
 */
export const deleteDataTable: API.OperationMethod<
  DeleteDataTableRequest,
  DeleteDataTableResponse,
  DeleteDataTableError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteDataTableRequest,
  output: DeleteDataTableResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteDataTableAttributeError =
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes an attribute and all its values from a data table.
 */
export const deleteDataTableAttribute: API.OperationMethod<
  DeleteDataTableAttributeRequest,
  DeleteDataTableAttributeResponse,
  DeleteDataTableAttributeError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteDataTableAttributeRequest,
  output: DeleteDataTableAttributeResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteEmailAddressError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes email address from the specified Amazon Connect instance.
 */
export const deleteEmailAddress: API.OperationMethod<
  DeleteEmailAddressRequest,
  DeleteEmailAddressResponse,
  DeleteEmailAddressError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteEmailAddressRequest,
  output: DeleteEmailAddressResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteEvaluationFormError =
  | InternalServiceException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes an evaluation form in the specified Amazon Connect instance.
 *
 * - If the version property is provided, only the specified version of the evaluation form is deleted.
 *
 * - If no version is provided, then the full form (all versions) is deleted.
 */
export const deleteEvaluationForm: API.OperationMethod<
  DeleteEvaluationFormRequest,
  DeleteEvaluationFormResponse,
  DeleteEvaluationFormError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteEvaluationFormRequest,
  output: DeleteEvaluationFormResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteHoursOfOperationError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes an hours of operation.
 */
export const deleteHoursOfOperation: API.OperationMethod<
  DeleteHoursOfOperationRequest,
  DeleteHoursOfOperationResponse,
  DeleteHoursOfOperationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteHoursOfOperationRequest,
  output: DeleteHoursOfOperationResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteHoursOfOperationOverrideError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes an hours of operation override in an Amazon Connect hours of operation resource.
 */
export const deleteHoursOfOperationOverride: API.OperationMethod<
  DeleteHoursOfOperationOverrideRequest,
  DeleteHoursOfOperationOverrideResponse,
  DeleteHoursOfOperationOverrideError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteHoursOfOperationOverrideRequest,
  output: DeleteHoursOfOperationOverrideResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteInstanceError =
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Deletes the Amazon Connect instance. For more information, see Delete your Amazon Connect instance in the
 * *Amazon Connect Administrator Guide*.
 *
 * Amazon Connect enforces a limit on the total number of instances that you can create or delete in 30 days.
 * If you exceed this limit, you will get an error message indicating there has been an excessive number of attempts at creating or deleting instances.
 * You must wait 30 days before you can restart creating and deleting instances in your account.
 */
export const deleteInstance: API.OperationMethod<
  DeleteInstanceRequest,
  DeleteInstanceResponse,
  DeleteInstanceError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteInstanceRequest,
  output: DeleteInstanceResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
export type DeleteIntegrationAssociationError =
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes an Amazon Web Services resource association from an Amazon Connect instance. The association must not
 * have any use cases associated with it.
 */
export const deleteIntegrationAssociation: API.OperationMethod<
  DeleteIntegrationAssociationRequest,
  DeleteIntegrationAssociationResponse,
  DeleteIntegrationAssociationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteIntegrationAssociationRequest,
  output: DeleteIntegrationAssociationResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteNotificationError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes a notification. Once deleted, the notification is no longer visible to all users and cannot be managed through the Admin Website or APIs.
 */
export const deleteNotification: API.OperationMethod<
  DeleteNotificationRequest,
  DeleteNotificationResponse,
  DeleteNotificationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteNotificationRequest,
  output: DeleteNotificationResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeletePredefinedAttributeError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes a predefined attribute from the specified Amazon Connect instance.
 */
export const deletePredefinedAttribute: API.OperationMethod<
  DeletePredefinedAttributeRequest,
  DeletePredefinedAttributeResponse,
  DeletePredefinedAttributeError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeletePredefinedAttributeRequest,
  output: DeletePredefinedAttributeResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeletePromptError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes a prompt.
 */
export const deletePrompt: API.OperationMethod<
  DeletePromptRequest,
  DeletePromptResponse,
  DeletePromptError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeletePromptRequest,
  output: DeletePromptResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeletePushNotificationRegistrationError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes registration for a device token and a chat contact.
 */
export const deletePushNotificationRegistration: API.OperationMethod<
  DeletePushNotificationRegistrationRequest,
  DeletePushNotificationRegistrationResponse,
  DeletePushNotificationRegistrationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeletePushNotificationRegistrationRequest,
  output: DeletePushNotificationRegistrationResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteQueueError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes a queue.
 */
export const deleteQueue: API.OperationMethod<
  DeleteQueueRequest,
  DeleteQueueResponse,
  DeleteQueueError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteQueueRequest,
  output: DeleteQueueResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteQuickConnectError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes a quick connect.
 *
 * After calling DeleteUser, it's important to call `DeleteQuickConnect` to delete any records related to the
 * deleted users. This will help you:
 *
 * - Avoid dangling resources that impact your service quotas.
 *
 * - Remove deleted users so they don't appear to agents as transfer options.
 *
 * - Avoid the disruption of other Amazon Connect processes, such as instance replication and syncing if
 * you're using Amazon Connect Global Resiliency.
 */
export const deleteQuickConnect: API.OperationMethod<
  DeleteQuickConnectRequest,
  DeleteQuickConnectResponse,
  DeleteQuickConnectError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteQuickConnectRequest,
  output: DeleteQuickConnectResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteRoutingProfileError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes a routing profile.
 */
export const deleteRoutingProfile: API.OperationMethod<
  DeleteRoutingProfileRequest,
  DeleteRoutingProfileResponse,
  DeleteRoutingProfileError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteRoutingProfileRequest,
  output: DeleteRoutingProfileResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteRuleError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes a rule for the specified Amazon Connect instance.
 */
export const deleteRule: API.OperationMethod<
  DeleteRuleRequest,
  DeleteRuleResponse,
  DeleteRuleError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteRuleRequest,
  output: DeleteRuleResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteSecurityProfileError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes a security profile.
 */
export const deleteSecurityProfile: API.OperationMethod<
  DeleteSecurityProfileRequest,
  DeleteSecurityProfileResponse,
  DeleteSecurityProfileError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteSecurityProfileRequest,
  output: DeleteSecurityProfileResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteTaskTemplateError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes the task template.
 */
export const deleteTaskTemplate: API.OperationMethod<
  DeleteTaskTemplateRequest,
  DeleteTaskTemplateResponse,
  DeleteTaskTemplateError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTaskTemplateRequest,
  output: DeleteTaskTemplateResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteTestCaseError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes the test case that has already been created for the specified Amazon Connect instance.
 */
export const deleteTestCase: API.OperationMethod<
  DeleteTestCaseRequest,
  DeleteTestCaseResponse,
  DeleteTestCaseError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTestCaseRequest,
  output: DeleteTestCaseResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteTrafficDistributionGroupError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceInUseException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes a traffic distribution group. This API can be called only in the Region where the traffic distribution group is created.
 *
 * For more information about deleting traffic distribution groups, see Delete traffic distribution groups in the
 * *Amazon Connect Administrator Guide*.
 */
export const deleteTrafficDistributionGroup: API.OperationMethod<
  DeleteTrafficDistributionGroupRequest,
  DeleteTrafficDistributionGroupResponse,
  DeleteTrafficDistributionGroupError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTrafficDistributionGroupRequest,
  output: DeleteTrafficDistributionGroupResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceInUseException,
    ThrottlingException,
  ],
}));
export type DeleteUseCaseError =
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes a use case from an integration association.
 */
export const deleteUseCase: API.OperationMethod<
  DeleteUseCaseRequest,
  DeleteUseCaseResponse,
  DeleteUseCaseError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteUseCaseRequest,
  output: DeleteUseCaseResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteUserError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes a user account from the specified Amazon Connect instance.
 *
 * For information about what happens to a user's data when their account is deleted, see Delete Users from Your Amazon Connect
 * Instance in the *Amazon Connect Administrator Guide*.
 *
 * After calling DeleteUser, call DeleteQuickConnect to delete any records
 * related to the deleted users. This will help you:
 *
 * - Avoid dangling resources that impact your service quotas.
 *
 * - Remove deleted users so they don't appear to agents as transfer options.
 *
 * - Avoid the disruption of other Amazon Connect processes, such as instance replication and syncing if
 * you're using Amazon Connect Global Resiliency.
 */
export const deleteUser: API.OperationMethod<
  DeleteUserRequest,
  DeleteUserResponse,
  DeleteUserError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteUserRequest,
  output: DeleteUserResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteUserHierarchyGroupError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes an existing user hierarchy group. It must not be associated with any agents or have any active child
 * groups.
 */
export const deleteUserHierarchyGroup: API.OperationMethod<
  DeleteUserHierarchyGroupRequest,
  DeleteUserHierarchyGroupResponse,
  DeleteUserHierarchyGroupError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteUserHierarchyGroupRequest,
  output: DeleteUserHierarchyGroupResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteViewError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | TooManyRequestsException
  | CommonErrors;
/**
 * Deletes the view entirely. It deletes the view and all associated qualifiers (versions and aliases).
 */
export const deleteView: API.OperationMethod<
  DeleteViewRequest,
  DeleteViewResponse,
  DeleteViewError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteViewRequest,
  output: DeleteViewResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    TooManyRequestsException,
  ],
}));
export type DeleteViewVersionError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | TooManyRequestsException
  | CommonErrors;
/**
 * Deletes the particular version specified in `ViewVersion` identifier.
 */
export const deleteViewVersion: API.OperationMethod<
  DeleteViewVersionRequest,
  DeleteViewVersionResponse,
  DeleteViewVersionError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteViewVersionRequest,
  output: DeleteViewVersionResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    TooManyRequestsException,
  ],
}));
export type DeleteVocabularyError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes the vocabulary that has the given identifier.
 */
export const deleteVocabulary: API.OperationMethod<
  DeleteVocabularyRequest,
  DeleteVocabularyResponse,
  DeleteVocabularyError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVocabularyRequest,
  output: DeleteVocabularyResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteWorkspaceError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes a workspace and removes all associated view and resource assignments.
 */
export const deleteWorkspace: API.OperationMethod<
  DeleteWorkspaceRequest,
  DeleteWorkspaceResponse,
  DeleteWorkspaceError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteWorkspaceRequest,
  output: DeleteWorkspaceResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteWorkspaceMediaError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Deletes a media asset (such as a logo) from a workspace.
 */
export const deleteWorkspaceMedia: API.OperationMethod<
  DeleteWorkspaceMediaRequest,
  DeleteWorkspaceMediaResponse,
  DeleteWorkspaceMediaError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteWorkspaceMediaRequest,
  output: DeleteWorkspaceMediaResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DeleteWorkspacePageError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Removes the association between a view and a page in a workspace. The page will display the default view after
 * deletion.
 */
export const deleteWorkspacePage: API.OperationMethod<
  DeleteWorkspacePageRequest,
  DeleteWorkspacePageResponse,
  DeleteWorkspacePageError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteWorkspacePageRequest,
  output: DeleteWorkspacePageResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeAgentStatusError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describes an agent status.
 */
export const describeAgentStatus: API.OperationMethod<
  DescribeAgentStatusRequest,
  DescribeAgentStatusResponse,
  DescribeAgentStatusError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAgentStatusRequest,
  output: DescribeAgentStatusResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeAuthenticationProfileError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change. To
 * request access to this API, contact Amazon Web Services Support.
 *
 * Describes the target authentication profile.
 */
export const describeAuthenticationProfile: API.OperationMethod<
  DescribeAuthenticationProfileRequest,
  DescribeAuthenticationProfileResponse,
  DescribeAuthenticationProfileError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAuthenticationProfileRequest,
  output: DescribeAuthenticationProfileResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeContactError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Describes the specified contact.
 *
 * **Use cases**
 *
 * Following are common uses cases for this API:
 *
 * - Retrieve contact information such as the caller's phone number and the specific number the caller dialed to
 * integrate into custom monitoring or custom agent experience solutions.
 *
 * - Detect when a customer chat session disconnects due to a network issue on the agent's end. Use the
 * DisconnectReason field in the ContactTraceRecord to detect
 * this event and then re-queue the chat for followup.
 *
 * - Identify after contact work (ACW) duration and call recordings information when a COMPLETED event is received
 * by using the contact event
 * stream.
 *
 * **Important things to know**
 *
 * - `SystemEndpoint` is not populated for contacts with initiation method of MONITOR, QUEUE_TRANSFER,
 * or CALLBACK
 *
 * - Contact information remains available in Amazon Connect for 24 months from the
 * `InitiationTimestamp`, and then it is deleted. Only contact information that is available in Amazon Connect is returned by this API.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const describeContact: API.OperationMethod<
  DescribeContactRequest,
  DescribeContactResponse,
  DescribeContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeContactRequest,
  output: DescribeContactResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeContactEvaluationError =
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describes a contact evaluation in the specified Amazon Connect instance.
 */
export const describeContactEvaluation: API.OperationMethod<
  DescribeContactEvaluationRequest,
  DescribeContactEvaluationResponse,
  DescribeContactEvaluationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeContactEvaluationRequest,
  output: DescribeContactEvaluationResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeContactFlowError =
  | ContactFlowNotPublishedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describes the specified flow.
 *
 * You can also create and update flows using the Amazon Connect
 * Flow language.
 *
 * Use the `$SAVED` alias in the request to describe the `SAVED` content of a Flow. For
 * example, `arn:aws:.../contact-flow/{id}:$SAVED`. After a flow is published, `$SAVED` needs to
 * be supplied to view saved content that has not been published.
 *
 * Use `arn:aws:.../contact-flow/{id}:{version}` to retrieve the content of a specific flow
 * version.
 *
 * In the response, **Status** indicates the flow status as either `SAVED`
 * or `PUBLISHED`. The `PUBLISHED` status will initiate validation on the content.
 * `SAVED` does not initiate validation of the content. `SAVED` | `PUBLISHED`
 */
export const describeContactFlow: API.OperationMethod<
  DescribeContactFlowRequest,
  DescribeContactFlowResponse,
  DescribeContactFlowError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeContactFlowRequest,
  output: DescribeContactFlowResponse,
  errors: [
    ContactFlowNotPublishedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeContactFlowModuleError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describes the specified flow module.
 *
 * Use the `$SAVED` alias in the request to describe the `SAVED` content of a Flow. For
 * example, `arn:aws:.../contact-flow/{id}:$SAVED`. After a flow is published, `$SAVED` needs to
 * be supplied to view saved content that has not been published.
 */
export const describeContactFlowModule: API.OperationMethod<
  DescribeContactFlowModuleRequest,
  DescribeContactFlowModuleResponse,
  DescribeContactFlowModuleError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeContactFlowModuleRequest,
  output: DescribeContactFlowModuleResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeContactFlowModuleAliasError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Retrieves detailed information about a specific alias, including which version it currently points to and its
 * metadata.
 */
export const describeContactFlowModuleAlias: API.OperationMethod<
  DescribeContactFlowModuleAliasRequest,
  DescribeContactFlowModuleAliasResponse,
  DescribeContactFlowModuleAliasError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeContactFlowModuleAliasRequest,
  output: DescribeContactFlowModuleAliasResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeDataTableError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Returns all properties for a data table except for attributes and values. All properties from CreateDataTable
 * are returned as well as properties for region replication, versioning, and system tables. "Describe" is a deprecated
 * term but is allowed to maintain consistency with existing operations.
 */
export const describeDataTable: API.OperationMethod<
  DescribeDataTableRequest,
  DescribeDataTableResponse,
  DescribeDataTableError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDataTableRequest,
  output: DescribeDataTableResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeDataTableAttributeError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Returns detailed information for a specific data table attribute including its configuration, validation rules,
 * and metadata. "Describe" is a deprecated term but is allowed to maintain consistency with existing operations.
 */
export const describeDataTableAttribute: API.OperationMethod<
  DescribeDataTableAttributeRequest,
  DescribeDataTableAttributeResponse,
  DescribeDataTableAttributeError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDataTableAttributeRequest,
  output: DescribeDataTableAttributeResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeEmailAddressError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describe email address form the specified Amazon Connect instance.
 */
export const describeEmailAddress: API.OperationMethod<
  DescribeEmailAddressRequest,
  DescribeEmailAddressResponse,
  DescribeEmailAddressError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeEmailAddressRequest,
  output: DescribeEmailAddressResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeEvaluationFormError =
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describes an evaluation form in the specified Amazon Connect instance. If the version property is not
 * provided, the latest version of the evaluation form is described.
 */
export const describeEvaluationForm: API.OperationMethod<
  DescribeEvaluationFormRequest,
  DescribeEvaluationFormResponse,
  DescribeEvaluationFormError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeEvaluationFormRequest,
  output: DescribeEvaluationFormResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeHoursOfOperationError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describes the hours of operation.
 */
export const describeHoursOfOperation: API.OperationMethod<
  DescribeHoursOfOperationRequest,
  DescribeHoursOfOperationResponse,
  DescribeHoursOfOperationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeHoursOfOperationRequest,
  output: DescribeHoursOfOperationResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeHoursOfOperationOverrideError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describes the hours of operation override.
 */
export const describeHoursOfOperationOverride: API.OperationMethod<
  DescribeHoursOfOperationOverrideRequest,
  DescribeHoursOfOperationOverrideResponse,
  DescribeHoursOfOperationOverrideError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeHoursOfOperationOverrideRequest,
  output: DescribeHoursOfOperationOverrideResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeInstanceError =
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Returns the current state of the specified instance identifier. It tracks the instance while it is being created
 * and returns an error status, if applicable.
 *
 * If an instance is not created successfully, the instance status reason field returns details relevant to the
 * reason. The instance in a failed state is returned only for 24 hours after the CreateInstance API was invoked.
 */
export const describeInstance: API.OperationMethod<
  DescribeInstanceRequest,
  DescribeInstanceResponse,
  DescribeInstanceError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeInstanceRequest,
  output: DescribeInstanceResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
export type DescribeInstanceAttributeError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Describes the specified instance attribute.
 */
export const describeInstanceAttribute: API.OperationMethod<
  DescribeInstanceAttributeRequest,
  DescribeInstanceAttributeResponse,
  DescribeInstanceAttributeError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeInstanceAttributeRequest,
  output: DescribeInstanceAttributeResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeInstanceStorageConfigError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Retrieves the current storage configurations for the specified resource type, association ID, and instance
 * ID.
 */
export const describeInstanceStorageConfig: API.OperationMethod<
  DescribeInstanceStorageConfigRequest,
  DescribeInstanceStorageConfigResponse,
  DescribeInstanceStorageConfigError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeInstanceStorageConfigRequest,
  output: DescribeInstanceStorageConfigResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeNotificationError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Retrieves detailed information about a specific notification, including its content, priority, recipients, and metadata.
 */
export const describeNotification: API.OperationMethod<
  DescribeNotificationRequest,
  DescribeNotificationResponse,
  DescribeNotificationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeNotificationRequest,
  output: DescribeNotificationResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribePhoneNumberError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Gets details and status of a phone number thats claimed to your Amazon Connect instance or traffic distribution group.
 *
 * If the number is claimed to a traffic distribution group, and you are calling in the Amazon Web Services Region where the traffic distribution group was
 * created, you can use either a phone number ARN or UUID value for the `PhoneNumberId` URI request
 * parameter. However, if the number is claimed to a traffic distribution group and you are calling this API in the alternate Amazon Web Services Region associated with the traffic distribution group, you must provide a full phone number ARN. If a UUID is provided
 * in
 * this scenario, you receive a `ResourceNotFoundException`.
 */
export const describePhoneNumber: API.OperationMethod<
  DescribePhoneNumberRequest,
  DescribePhoneNumberResponse,
  DescribePhoneNumberError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribePhoneNumberRequest,
  output: DescribePhoneNumberResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribePredefinedAttributeError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describes a predefined attribute for the specified Amazon Connect instance. A *predefined attribute*
 * is made up of a name and a value. You can use predefined attributes for:
 *
 * - Routing proficiency (for example, agent certification) that has predefined values (for example, a list of
 * possible certifications). For more information, see Create predefined attributes for routing contacts to
 * agents.
 *
 * - Contact information that varies between transfers or conferences, such as the name of the business unit
 * handling the contact. For more information, see Use contact segment attributes.
 *
 * For the predefined attributes per instance quota, see Amazon Connect
 * quotas.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const describePredefinedAttribute: API.OperationMethod<
  DescribePredefinedAttributeRequest,
  DescribePredefinedAttributeResponse,
  DescribePredefinedAttributeError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribePredefinedAttributeRequest,
  output: DescribePredefinedAttributeResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribePromptError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describes the prompt.
 */
export const describePrompt: API.OperationMethod<
  DescribePromptRequest,
  DescribePromptResponse,
  DescribePromptError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribePromptRequest,
  output: DescribePromptResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeQueueError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describes the specified queue.
 */
export const describeQueue: API.OperationMethod<
  DescribeQueueRequest,
  DescribeQueueResponse,
  DescribeQueueError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeQueueRequest,
  output: DescribeQueueResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeQuickConnectError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describes the quick connect.
 */
export const describeQuickConnect: API.OperationMethod<
  DescribeQuickConnectRequest,
  DescribeQuickConnectResponse,
  DescribeQuickConnectError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeQuickConnectRequest,
  output: DescribeQuickConnectResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeRoutingProfileError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describes the specified routing profile.
 *
 * `DescribeRoutingProfile` does not populate AssociatedQueueIds in its response. The example Response
 * Syntax shown on this page is incorrect; we are working to update it. SearchRoutingProfiles does include
 * AssociatedQueueIds.
 */
export const describeRoutingProfile: API.OperationMethod<
  DescribeRoutingProfileRequest,
  DescribeRoutingProfileResponse,
  DescribeRoutingProfileError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeRoutingProfileRequest,
  output: DescribeRoutingProfileResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeRuleError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describes a rule for the specified Amazon Connect instance.
 */
export const describeRule: API.OperationMethod<
  DescribeRuleRequest,
  DescribeRuleResponse,
  DescribeRuleError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeRuleRequest,
  output: DescribeRuleResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeSecurityProfileError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Gets basic information about the security profile.
 *
 * For information about security profiles, see Security Profiles in the *Amazon Connect Administrator Guide*. For a mapping of the API name and user interface name of the security
 * profile permissions, see List
 * of security profile permissions.
 */
export const describeSecurityProfile: API.OperationMethod<
  DescribeSecurityProfileRequest,
  DescribeSecurityProfileResponse,
  DescribeSecurityProfileError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeSecurityProfileRequest,
  output: DescribeSecurityProfileResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeTestCaseError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describes the specified test case and allows you to get the content and metadata of the test case for the specified Amazon Connect instance.
 */
export const describeTestCase: API.OperationMethod<
  DescribeTestCaseRequest,
  DescribeTestCaseResponse,
  DescribeTestCaseError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeTestCaseRequest,
  output: DescribeTestCaseResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeTrafficDistributionGroupError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Gets details and status of a traffic distribution group.
 */
export const describeTrafficDistributionGroup: API.OperationMethod<
  DescribeTrafficDistributionGroupRequest,
  DescribeTrafficDistributionGroupResponse,
  DescribeTrafficDistributionGroupError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeTrafficDistributionGroupRequest,
  output: DescribeTrafficDistributionGroupResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeUserError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describes the specified user. You can find the instance ID in the Amazon Connect
 * console (its the final part of the ARN). The console does not display the user IDs. Instead, list the users
 * and note the IDs provided in the output.
 */
export const describeUser: API.OperationMethod<
  DescribeUserRequest,
  DescribeUserResponse,
  DescribeUserError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeUserRequest,
  output: DescribeUserResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeUserHierarchyGroupError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describes the specified hierarchy group.
 */
export const describeUserHierarchyGroup: API.OperationMethod<
  DescribeUserHierarchyGroupRequest,
  DescribeUserHierarchyGroupResponse,
  DescribeUserHierarchyGroupError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeUserHierarchyGroupRequest,
  output: DescribeUserHierarchyGroupResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeUserHierarchyStructureError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describes the hierarchy structure of the specified Amazon Connect instance.
 */
export const describeUserHierarchyStructure: API.OperationMethod<
  DescribeUserHierarchyStructureRequest,
  DescribeUserHierarchyStructureResponse,
  DescribeUserHierarchyStructureError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeUserHierarchyStructureRequest,
  output: DescribeUserHierarchyStructureResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeViewError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | TooManyRequestsException
  | CommonErrors;
/**
 * Retrieves the view for the specified Amazon Connect instance and view identifier.
 *
 * The view identifier can be supplied as a ViewId or ARN.
 *
 * `$SAVED` needs to be supplied if a view is unpublished.
 *
 * The view identifier can contain an optional qualifier, for example, `:$SAVED`, which
 * is either an actual version number or an Amazon Connect managed qualifier `$SAVED | $LATEST`. If it is
 * not supplied, then `$LATEST` is assumed for customer managed views and an error is returned if there is no
 * published content available. Version 1 is assumed for Amazon Web Services managed views.
 */
export const describeView: API.OperationMethod<
  DescribeViewRequest,
  DescribeViewResponse,
  DescribeViewError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeViewRequest,
  output: DescribeViewResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    TooManyRequestsException,
  ],
}));
export type DescribeVocabularyError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Describes the specified vocabulary.
 */
export const describeVocabulary: API.OperationMethod<
  DescribeVocabularyRequest,
  DescribeVocabularyResponse,
  DescribeVocabularyError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeVocabularyRequest,
  output: DescribeVocabularyResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DescribeWorkspaceError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Retrieves details about a workspace, including its configuration and metadata.
 */
export const describeWorkspace: API.OperationMethod<
  DescribeWorkspaceRequest,
  DescribeWorkspaceResponse,
  DescribeWorkspaceError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeWorkspaceRequest,
  output: DescribeWorkspaceResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DisassociateAnalyticsDataSetError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Removes the dataset ID associated with a given Amazon Connect instance.
 */
export const disassociateAnalyticsDataSet: API.OperationMethod<
  DisassociateAnalyticsDataSetRequest,
  DisassociateAnalyticsDataSetResponse,
  DisassociateAnalyticsDataSetError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateAnalyticsDataSetRequest,
  output: DisassociateAnalyticsDataSetResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DisassociateApprovedOriginError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Revokes access to integrated applications from Amazon Connect.
 */
export const disassociateApprovedOrigin: API.OperationMethod<
  DisassociateApprovedOriginRequest,
  DisassociateApprovedOriginResponse,
  DisassociateApprovedOriginError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateApprovedOriginRequest,
  output: DisassociateApprovedOriginResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DisassociateBotError =
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Revokes authorization from the specified instance to access the specified Amazon Lex or Amazon Lex V2 bot.
 */
export const disassociateBot: API.OperationMethod<
  DisassociateBotRequest,
  DisassociateBotResponse,
  DisassociateBotError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateBotRequest,
  output: DisassociateBotResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DisassociateEmailAddressAliasError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Removes the alias association between two email addresses in an Amazon Connect instance. After
 * disassociation, emails sent to the former alias email address are no longer forwarded to the primary email address.
 * Both email addresses continue to exist independently and can receive emails directly.
 *
 * **Use cases**
 *
 * Following are common uses cases for this API:
 *
 * - **Department separation**: Remove alias relationships when splitting a
 * consolidated support queue back into separate department-specific queues.
 *
 * - **Email address retirement**: Cleanly remove forwarding relationships before
 * decommissioning old email addresses.
 *
 * - **Organizational restructuring**: Reconfigure email routing when business
 * processes change and aliases are no longer needed.
 *
 * **Important things to know**
 *
 * - Concurrent operations: This API uses distributed locking, so concurrent operations on the same email addresses
 * may be temporarily blocked.
 *
 * - Emails sent to the former alias address are still delivered directly to that address if it exists.
 *
 * - You do not need to delete the email addresses after disassociation. Both addresses remain active
 * independently.
 *
 * - After a successful disassociation, you can immediately create a new alias relationship with the same
 * addresses.
 *
 * - 200 status means alias was successfully disassociated.
 *
 * `DisassociateEmailAddressAlias` does not return the following information:
 *
 * - Details in the response about the email that was disassociated. The response returns an empty body.
 *
 * - The timestamp of when the disassociation occurred.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 *
 * **Related operations**
 *
 * - AssociateEmailAddressAlias: Associates an email address alias with an existing email address in an
 * Amazon Connect instance.
 *
 * - DescribeEmailAddress: View current alias configurations for an email address.
 *
 * - SearchEmailAddresses: Find email addresses and their alias relationships across an instance.
 *
 * - CreateEmailAddress: Create new email addresses that can participate in alias relationships.
 *
 * - DeleteEmailAddress: Remove email addresses (automatically removes any alias relationships).
 *
 * - UpdateEmailAddressMetadata: Modify email address properties (does not affect alias relationships).
 */
export const disassociateEmailAddressAlias: API.OperationMethod<
  DisassociateEmailAddressAliasRequest,
  DisassociateEmailAddressAliasResponse,
  DisassociateEmailAddressAliasError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateEmailAddressAliasRequest,
  output: DisassociateEmailAddressAliasResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DisassociateFlowError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Disassociates a connect resource from a flow.
 */
export const disassociateFlow: API.OperationMethod<
  DisassociateFlowRequest,
  DisassociateFlowResponse,
  DisassociateFlowError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateFlowRequest,
  output: DisassociateFlowResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DisassociateHoursOfOperationsError =
  | ConditionalOperationFailedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Disassociates a set of hours of operations with another hours of operation. Refer to Administrator Guide here for more information on inheriting overrides from parent hours of operation(s).
 */
export const disassociateHoursOfOperations: API.OperationMethod<
  DisassociateHoursOfOperationsRequest,
  DisassociateHoursOfOperationsResponse,
  DisassociateHoursOfOperationsError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateHoursOfOperationsRequest,
  output: DisassociateHoursOfOperationsResponse,
  errors: [
    ConditionalOperationFailedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DisassociateInstanceStorageConfigError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Removes the storage type configurations for the specified resource type and association ID.
 */
export const disassociateInstanceStorageConfig: API.OperationMethod<
  DisassociateInstanceStorageConfigRequest,
  DisassociateInstanceStorageConfigResponse,
  DisassociateInstanceStorageConfigError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateInstanceStorageConfigRequest,
  output: DisassociateInstanceStorageConfigResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DisassociateLambdaFunctionError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Remove the Lambda function from the dropdown options available in the relevant flow blocks.
 */
export const disassociateLambdaFunction: API.OperationMethod<
  DisassociateLambdaFunctionRequest,
  DisassociateLambdaFunctionResponse,
  DisassociateLambdaFunctionError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateLambdaFunctionRequest,
  output: DisassociateLambdaFunctionResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DisassociateLexBotError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Revokes authorization from the specified instance to access the specified Amazon Lex bot.
 */
export const disassociateLexBot: API.OperationMethod<
  DisassociateLexBotRequest,
  DisassociateLexBotResponse,
  DisassociateLexBotError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateLexBotRequest,
  output: DisassociateLexBotResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DisassociatePhoneNumberContactFlowError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Removes the flow association from a phone number claimed to your Amazon Connect instance.
 *
 * If the number is claimed to a traffic distribution group, and you are calling this API using an instance in the Amazon Web Services Region where the traffic distribution group was created, you can use either a full phone number ARN or UUID value for the
 * `PhoneNumberId` URI request parameter. However, if the number is claimed to a traffic distribution group and you are calling
 * this API using an instance in the alternate Amazon Web Services Region associated with the traffic distribution group, you must provide a
 * full phone number ARN. If a UUID is provided in this scenario, you will receive a
 * `ResourceNotFoundException`.
 */
export const disassociatePhoneNumberContactFlow: API.OperationMethod<
  DisassociatePhoneNumberContactFlowRequest,
  DisassociatePhoneNumberContactFlowResponse,
  DisassociatePhoneNumberContactFlowError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociatePhoneNumberContactFlowRequest,
  output: DisassociatePhoneNumberContactFlowResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DisassociateQueueQuickConnectsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Disassociates a set of quick connects from a queue.
 */
export const disassociateQueueQuickConnects: API.OperationMethod<
  DisassociateQueueQuickConnectsRequest,
  DisassociateQueueQuickConnectsResponse,
  DisassociateQueueQuickConnectsError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateQueueQuickConnectsRequest,
  output: DisassociateQueueQuickConnectsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DisassociateRoutingProfileQueuesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Disassociates a set of queues from a routing profile.
 *
 * Up to 10 queue references can be disassociated in a single API call. More than 10 queue references results in a
 * single call results in an InvalidParameterException.
 */
export const disassociateRoutingProfileQueues: API.OperationMethod<
  DisassociateRoutingProfileQueuesRequest,
  DisassociateRoutingProfileQueuesResponse,
  DisassociateRoutingProfileQueuesError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateRoutingProfileQueuesRequest,
  output: DisassociateRoutingProfileQueuesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DisassociateSecurityKeyError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Deletes the specified security key.
 */
export const disassociateSecurityKey: API.OperationMethod<
  DisassociateSecurityKeyRequest,
  DisassociateSecurityKeyResponse,
  DisassociateSecurityKeyError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateSecurityKeyRequest,
  output: DisassociateSecurityKeyResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DisassociateSecurityProfilesError =
  | AccessDeniedException
  | ConditionalOperationFailedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | CommonErrors;
/**
 * Disassociates a security profile attached to a Q in Connect AI Agent Entity in an Amazon Connect instance.
 */
export const disassociateSecurityProfiles: API.OperationMethod<
  DisassociateSecurityProfilesRequest,
  DisassociateSecurityProfilesResponse,
  DisassociateSecurityProfilesError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateSecurityProfilesRequest,
  output: DisassociateSecurityProfilesResponse,
  errors: [
    AccessDeniedException,
    ConditionalOperationFailedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
  ],
}));
export type DisassociateTrafficDistributionGroupUserError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Disassociates an agent from a traffic distribution group. This API can be called only in the Region where the
 * traffic distribution group is created.
 */
export const disassociateTrafficDistributionGroupUser: API.OperationMethod<
  DisassociateTrafficDistributionGroupUserRequest,
  DisassociateTrafficDistributionGroupUserResponse,
  DisassociateTrafficDistributionGroupUserError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateTrafficDistributionGroupUserRequest,
  output: DisassociateTrafficDistributionGroupUserResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DisassociateUserProficienciesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Disassociates a set of proficiencies from a user.
 */
export const disassociateUserProficiencies: API.OperationMethod<
  DisassociateUserProficienciesRequest,
  DisassociateUserProficienciesResponse,
  DisassociateUserProficienciesError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateUserProficienciesRequest,
  output: DisassociateUserProficienciesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DisassociateWorkspaceError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Removes the association between a workspace and one or more users or routing profiles.
 */
export const disassociateWorkspace: API.OperationMethod<
  DisassociateWorkspaceRequest,
  DisassociateWorkspaceResponse,
  DisassociateWorkspaceError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateWorkspaceRequest,
  output: DisassociateWorkspaceResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type DismissUserContactError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Dismisses contacts from an agents CCP and returns the agent to an available state, which allows the agent to
 * receive a new routed contact. Contacts can only be dismissed if they are in a `MISSED`,
 * `ERROR`, `ENDED`, or `REJECTED` state in the Agent Event Stream.
 */
export const dismissUserContact: API.OperationMethod<
  DismissUserContactRequest,
  DismissUserContactResponse,
  DismissUserContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DismissUserContactRequest,
  output: DismissUserContactResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type EvaluateDataTableValuesError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Evaluates values at the time of the request and returns them. It considers the request's timezone or the table's
 * timezone, in that order, when accessing time based tables. When a value is accessed, the accessor's identity and the
 * time of access are saved alongside the value to help identify values that are actively in use. The term "Batch" is
 * not included in the operation name since it does not meet all the criteria for a batch operation as specified in
 * Batch Operations: Amazon Web Services API Standards.
 */
export const evaluateDataTableValues: API.OperationMethod<
  EvaluateDataTableValuesRequest,
  EvaluateDataTableValuesResponse,
  EvaluateDataTableValuesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: EvaluateDataTableValuesRequest,
  ) => stream.Stream<
    EvaluateDataTableValuesResponse,
    EvaluateDataTableValuesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: EvaluateDataTableValuesRequest,
  ) => stream.Stream<
    unknown,
    EvaluateDataTableValuesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: EvaluateDataTableValuesRequest,
  output: EvaluateDataTableValuesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    pageSize: "MaxResults",
  } as const,
}));
export type GetAttachedFileError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Provides a pre-signed URL for download of an approved attached file. This API also returns metadata about the
 * attached file. It will only return a downloadURL if the status of the attached file is `APPROVED`.
 */
export const getAttachedFile: API.OperationMethod<
  GetAttachedFileRequest,
  GetAttachedFileResponse,
  GetAttachedFileError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetAttachedFileRequest,
  output: GetAttachedFileResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type GetContactAttributesError =
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors;
/**
 * Retrieves the contact attributes for the specified contact.
 */
export const getContactAttributes: API.OperationMethod<
  GetContactAttributesRequest,
  GetContactAttributesResponse,
  GetContactAttributesError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetContactAttributesRequest,
  output: GetContactAttributesResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
export type GetContactMetricsError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Retrieves contact metric data for a specified contact.
 *
 * **Use cases**
 *
 * Following are common use cases for position in queue and estimated wait time:
 *
 * - Customer-Facing Wait Time Announcements - Display or announce the estimated wait time and position in queue to customers before or during their queue experience.
 *
 * - Callback Offerings - Offer customers a callback option when the estimated wait time or position in queue exceeds a defined threshold.
 *
 * - Queue Routing Decisions - Route incoming contacts to less congested queues by comparing estimated wait time and position in queue across multiple queues.
 *
 * - Self-Service Deflection - Redirect customers to self-service options like chatbots or FAQs when estimated wait time is high or position in queue is unfavorable.
 *
 * **Important things to know**
 *
 * - Metrics are only available while the contact is actively in queue.
 *
 * - For more information, see the Position in queue metric in the *Amazon Connect Administrator Guide*.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const getContactMetrics: API.OperationMethod<
  GetContactMetricsRequest,
  GetContactMetricsResponse,
  GetContactMetricsError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetContactMetricsRequest,
  output: GetContactMetricsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type GetCurrentMetricDataError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Gets the real-time metric data from the specified Amazon Connect instance.
 *
 * For a description of each metric, see Metrics definitions in the *Amazon Connect Administrator Guide*.
 *
 * When you make a successful API request, you can expect the following metric values in the response:
 *
 * - **Metric value is null**: The calculation cannot be performed due to divide by
 * zero or insufficient data
 *
 * - **Metric value is a number (including 0) of defined type**: The number provided
 * is the calculation result
 *
 * - **MetricResult list is empty**: The request cannot find any data in the
 * system
 *
 * The following guidelines can help you work with the API:
 *
 * - Each dimension in the metric response must contain a value
 *
 * - Each item in MetricResult must include all requested metrics
 *
 * - If the response is slow due to large result sets, try these approaches:
 *
 * - Add filters to reduce the amount of data returned
 */
export const getCurrentMetricData: API.OperationMethod<
  GetCurrentMetricDataRequest,
  GetCurrentMetricDataResponse,
  GetCurrentMetricDataError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: GetCurrentMetricDataRequest,
  ) => stream.Stream<
    GetCurrentMetricDataResponse,
    GetCurrentMetricDataError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: GetCurrentMetricDataRequest,
  ) => stream.Stream<
    unknown,
    GetCurrentMetricDataError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetCurrentMetricDataRequest,
  output: GetCurrentMetricDataResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    pageSize: "MaxResults",
  } as const,
}));
export type GetCurrentUserDataError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Gets the real-time active user data from the specified Amazon Connect instance.
 */
export const getCurrentUserData: API.OperationMethod<
  GetCurrentUserDataRequest,
  GetCurrentUserDataResponse,
  GetCurrentUserDataError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: GetCurrentUserDataRequest,
  ) => stream.Stream<
    GetCurrentUserDataResponse,
    GetCurrentUserDataError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: GetCurrentUserDataRequest,
  ) => stream.Stream<
    unknown,
    GetCurrentUserDataError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetCurrentUserDataRequest,
  output: GetCurrentUserDataResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    pageSize: "MaxResults",
  } as const,
}));
export type GetEffectiveHoursOfOperationsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Get the hours of operations with the effective override applied.
 */
export const getEffectiveHoursOfOperations: API.OperationMethod<
  GetEffectiveHoursOfOperationsRequest,
  GetEffectiveHoursOfOperationsResponse,
  GetEffectiveHoursOfOperationsError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetEffectiveHoursOfOperationsRequest,
  output: GetEffectiveHoursOfOperationsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type GetFederationTokenError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | UserNotFoundException
  | CommonErrors;
/**
 * Supports SAML sign-in for Amazon Connect. Retrieves a token for federation. The token is for the Amazon Connect user which corresponds to the IAM credentials that were used to invoke this action.
 *
 * For more information about how SAML sign-in works in Amazon Connect, see Configure SAML with IAM for Amazon Connect
 * in the *Amazon Connect Administrator Guide*.
 *
 * This API doesn't support root users. If you try to invoke GetFederationToken with root credentials, an error
 * message similar to the following one appears:
 *
 * `Provided identity: Principal: .... User: .... cannot be used for federation with Amazon Connect`
 */
export const getFederationToken: API.OperationMethod<
  GetFederationTokenRequest,
  GetFederationTokenResponse,
  GetFederationTokenError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetFederationTokenRequest,
  output: GetFederationTokenResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    UserNotFoundException,
  ],
}));
export type GetFlowAssociationError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Retrieves the flow associated for a given resource.
 */
export const getFlowAssociation: API.OperationMethod<
  GetFlowAssociationRequest,
  GetFlowAssociationResponse,
  GetFlowAssociationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetFlowAssociationRequest,
  output: GetFlowAssociationResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type GetMetricDataError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Gets historical metric data from the specified Amazon Connect instance.
 *
 * For a description of each historical metric, see Metrics definitions in the *Amazon Connect Administrator Guide*.
 *
 * We recommend using the GetMetricDataV2 API. It provides more flexibility, features, and the ability to query longer time ranges
 * than `GetMetricData`. Use it to retrieve historical agent and contact metrics for the last 3 months, at
 * varying intervals. You can also use it to build custom dashboards to measure historical queue and agent performance.
 * For example, you can track the number of incoming contacts for the last 7 days, with data split by day, to see how
 * contact volume changed per day of the week.
 */
export const getMetricData: API.OperationMethod<
  GetMetricDataRequest,
  GetMetricDataResponse,
  GetMetricDataError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: GetMetricDataRequest,
  ) => stream.Stream<
    GetMetricDataResponse,
    GetMetricDataError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: GetMetricDataRequest,
  ) => stream.Stream<
    unknown,
    GetMetricDataError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetMetricDataRequest,
  output: GetMetricDataResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    pageSize: "MaxResults",
  } as const,
}));
export type GetMetricDataV2Error =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Gets metric data from the specified Amazon Connect instance.
 *
 * `GetMetricDataV2` offers more features than GetMetricData, the previous version of this API. It
 * has new metrics, offers filtering at a metric level, and offers the ability to filter and group data by channels,
 * queues, routing profiles, agents, and agent hierarchy levels. It can retrieve historical data for the last 3 months,
 * at varying intervals. It does not support agent queues.
 *
 * For a description of the historical metrics that are supported by `GetMetricDataV2` and
 * `GetMetricData`, see Metrics definitions in the *Amazon Connect Administrator Guide*.
 *
 * When you make a successful API request, you can expect the following metric values in the response:
 *
 * - **Metric value is null**: The calculation cannot be performed due to divide by
 * zero or insufficient data
 *
 * - **Metric value is a number (including 0) of defined type**: The number provided
 * is the calculation result
 *
 * - **MetricResult list is empty**: The request cannot find any data in the
 * system
 *
 * The following guidelines can help you work with the API:
 *
 * - Each dimension in the metric response must contain a value
 *
 * - Each item in MetricResult must include all requested metrics
 *
 * - If the response is slow due to large result sets, try these approaches:
 *
 * - Narrow the time range of your request
 *
 * - Add filters to reduce the amount of data returned
 */
export const getMetricDataV2: API.OperationMethod<
  GetMetricDataV2Request,
  GetMetricDataV2Response,
  GetMetricDataV2Error,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: GetMetricDataV2Request,
  ) => stream.Stream<
    GetMetricDataV2Response,
    GetMetricDataV2Error,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: GetMetricDataV2Request,
  ) => stream.Stream<
    unknown,
    GetMetricDataV2Error,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetMetricDataV2Request,
  output: GetMetricDataV2Response,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    pageSize: "MaxResults",
  } as const,
}));
export type GetPromptFileError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Gets the prompt file.
 */
export const getPromptFile: API.OperationMethod<
  GetPromptFileRequest,
  GetPromptFileResponse,
  GetPromptFileError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetPromptFileRequest,
  output: GetPromptFileResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type GetTaskTemplateError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Gets details about a specific task template in the specified Amazon Connect instance.
 */
export const getTaskTemplate: API.OperationMethod<
  GetTaskTemplateRequest,
  GetTaskTemplateResponse,
  GetTaskTemplateError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetTaskTemplateRequest,
  output: GetTaskTemplateResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type GetTestCaseExecutionSummaryError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Retrieves an overview of a test execution that includes the status of the execution, start and end time, and observation summary.
 */
export const getTestCaseExecutionSummary: API.OperationMethod<
  GetTestCaseExecutionSummaryRequest,
  GetTestCaseExecutionSummaryResponse,
  GetTestCaseExecutionSummaryError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetTestCaseExecutionSummaryRequest,
  output: GetTestCaseExecutionSummaryResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type GetTrafficDistributionError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Retrieves the current traffic distribution for a given traffic distribution group.
 */
export const getTrafficDistribution: API.OperationMethod<
  GetTrafficDistributionRequest,
  GetTrafficDistributionResponse,
  GetTrafficDistributionError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetTrafficDistributionRequest,
  output: GetTrafficDistributionResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type ImportPhoneNumberError =
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Imports a claimed phone number from an external service, such as Amazon Web Services End User Messaging, into an
 * Amazon Connect instance. You can call this API only in the same Amazon Web Services Region where the Amazon Connect instance was created.
 *
 * Call the DescribePhoneNumber API to verify the status of a previous `ImportPhoneNumber` operation.
 *
 * If you plan to claim or import numbers and then release numbers frequently, contact us for a service quota
 * exception. Otherwise, it is possible you will be blocked from claiming and releasing any more numbers until up to 180
 * days past the oldest number released has expired.
 *
 * By default you can claim or import and then release up to 200% of your maximum number of active phone numbers.
 * If you claim or import and then release phone numbers using the UI or API during a rolling 180 day cycle that exceeds
 * 200% of your phone number service level quota, you will be blocked from claiming or importing any more numbers until
 * 180 days past the oldest number released has expired.
 *
 * For example, if you already have 99 claimed or imported numbers and a service level quota of 99 phone numbers,
 * and in any 180 day period you release 99, claim 99, and then release 99, you will have exceeded the 200% limit. At
 * that point you are blocked from claiming any more numbers until you open an Amazon Web Services Support ticket.
 */
export const importPhoneNumber: API.OperationMethod<
  ImportPhoneNumberRequest,
  ImportPhoneNumberResponse,
  ImportPhoneNumberError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ImportPhoneNumberRequest,
  output: ImportPhoneNumberResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type ImportWorkspaceMediaError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Imports a media asset (such as a logo) for use in a workspace.
 */
export const importWorkspaceMedia: API.OperationMethod<
  ImportWorkspaceMediaRequest,
  ImportWorkspaceMediaResponse,
  ImportWorkspaceMediaError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ImportWorkspaceMediaRequest,
  output: ImportWorkspaceMediaResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type ListAgentStatusesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists agent statuses.
 */
export const listAgentStatuses: API.OperationMethod<
  ListAgentStatusRequest,
  ListAgentStatusResponse,
  ListAgentStatusesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListAgentStatusRequest,
  ) => stream.Stream<
    ListAgentStatusResponse,
    ListAgentStatusesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListAgentStatusRequest,
  ) => stream.Stream<
    AgentStatusSummary,
    ListAgentStatusesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListAgentStatusRequest,
  output: ListAgentStatusResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AgentStatusSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListAnalyticsDataAssociationsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists the association status of requested dataset ID for a given Amazon Connect instance.
 */
export const listAnalyticsDataAssociations: API.OperationMethod<
  ListAnalyticsDataAssociationsRequest,
  ListAnalyticsDataAssociationsResponse,
  ListAnalyticsDataAssociationsError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListAnalyticsDataAssociationsRequest,
  output: ListAnalyticsDataAssociationsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type ListAnalyticsDataLakeDataSetsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists the data lake datasets available to associate with for a given Amazon Connect instance.
 */
export const listAnalyticsDataLakeDataSets: API.OperationMethod<
  ListAnalyticsDataLakeDataSetsRequest,
  ListAnalyticsDataLakeDataSetsResponse,
  ListAnalyticsDataLakeDataSetsError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListAnalyticsDataLakeDataSetsRequest,
  output: ListAnalyticsDataLakeDataSetsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type ListApprovedOriginsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Returns a paginated list of all approved origins associated with the instance.
 */
export const listApprovedOrigins: API.OperationMethod<
  ListApprovedOriginsRequest,
  ListApprovedOriginsResponse,
  ListApprovedOriginsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListApprovedOriginsRequest,
  ) => stream.Stream<
    ListApprovedOriginsResponse,
    ListApprovedOriginsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListApprovedOriginsRequest,
  ) => stream.Stream<
    Origin,
    ListApprovedOriginsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListApprovedOriginsRequest,
  output: ListApprovedOriginsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Origins",
    pageSize: "MaxResults",
  } as const,
}));
export type ListAssociatedContactsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Provides information about contact tree, a list of associated contacts with a unique identifier.
 */
export const listAssociatedContacts: API.OperationMethod<
  ListAssociatedContactsRequest,
  ListAssociatedContactsResponse,
  ListAssociatedContactsError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListAssociatedContactsRequest,
  output: ListAssociatedContactsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type ListAuthenticationProfilesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change. To
 * request access to this API, contact Amazon Web Services Support.
 *
 * Provides summary information about the authentication profiles in a specified Amazon Connect
 * instance.
 */
export const listAuthenticationProfiles: API.OperationMethod<
  ListAuthenticationProfilesRequest,
  ListAuthenticationProfilesResponse,
  ListAuthenticationProfilesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListAuthenticationProfilesRequest,
  ) => stream.Stream<
    ListAuthenticationProfilesResponse,
    ListAuthenticationProfilesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListAuthenticationProfilesRequest,
  ) => stream.Stream<
    AuthenticationProfileSummary,
    ListAuthenticationProfilesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListAuthenticationProfilesRequest,
  output: ListAuthenticationProfilesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AuthenticationProfileSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListBotsError =
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * For the specified version of Amazon Lex, returns a paginated list of all the Amazon Lex bots
 * currently associated with the instance. Use this API to return both Amazon Lex V1 and V2
 * bots.
 */
export const listBots: API.OperationMethod<
  ListBotsRequest,
  ListBotsResponse,
  ListBotsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListBotsRequest,
  ) => stream.Stream<
    ListBotsResponse,
    ListBotsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListBotsRequest,
  ) => stream.Stream<
    LexBotConfig,
    ListBotsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListBotsRequest,
  output: ListBotsResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "LexBots",
    pageSize: "MaxResults",
  } as const,
}));
export type ListChildHoursOfOperationsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Provides information about the child hours of operations for the specified parent hours of operation.
 *
 * For more information about child hours of operations, see Link overrides from different hours of operation in the
 * * Administrator Guide*.
 */
export const listChildHoursOfOperations: API.OperationMethod<
  ListChildHoursOfOperationsRequest,
  ListChildHoursOfOperationsResponse,
  ListChildHoursOfOperationsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListChildHoursOfOperationsRequest,
  ) => stream.Stream<
    ListChildHoursOfOperationsResponse,
    ListChildHoursOfOperationsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListChildHoursOfOperationsRequest,
  ) => stream.Stream<
    HoursOfOperationsIdentifier,
    ListChildHoursOfOperationsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListChildHoursOfOperationsRequest,
  output: ListChildHoursOfOperationsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ChildHoursOfOperationsSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListContactEvaluationsError =
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists contact evaluations in the specified Amazon Connect instance.
 */
export const listContactEvaluations: API.OperationMethod<
  ListContactEvaluationsRequest,
  ListContactEvaluationsResponse,
  ListContactEvaluationsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListContactEvaluationsRequest,
  ) => stream.Stream<
    ListContactEvaluationsResponse,
    ListContactEvaluationsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListContactEvaluationsRequest,
  ) => stream.Stream<
    EvaluationSummary,
    ListContactEvaluationsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListContactEvaluationsRequest,
  output: ListContactEvaluationsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "EvaluationSummaryList",
  } as const,
}));
export type ListContactFlowModuleAliasesError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists all aliases associated with a contact flow module, showing their current version mappings and
 * metadata.
 */
export const listContactFlowModuleAliases: API.OperationMethod<
  ListContactFlowModuleAliasesRequest,
  ListContactFlowModuleAliasesResponse,
  ListContactFlowModuleAliasesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListContactFlowModuleAliasesRequest,
  ) => stream.Stream<
    ListContactFlowModuleAliasesResponse,
    ListContactFlowModuleAliasesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListContactFlowModuleAliasesRequest,
  ) => stream.Stream<
    ContactFlowModuleAliasSummary,
    ListContactFlowModuleAliasesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListContactFlowModuleAliasesRequest,
  output: ListContactFlowModuleAliasesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ContactFlowModuleAliasSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListContactFlowModulesError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Provides information about the flow modules for the specified Amazon Connect instance.
 */
export const listContactFlowModules: API.OperationMethod<
  ListContactFlowModulesRequest,
  ListContactFlowModulesResponse,
  ListContactFlowModulesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListContactFlowModulesRequest,
  ) => stream.Stream<
    ListContactFlowModulesResponse,
    ListContactFlowModulesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListContactFlowModulesRequest,
  ) => stream.Stream<
    ContactFlowModuleSummary,
    ListContactFlowModulesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListContactFlowModulesRequest,
  output: ListContactFlowModulesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ContactFlowModulesSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListContactFlowModuleVersionsError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Retrieves a paginated list of all versions for a specific contact flow module.
 */
export const listContactFlowModuleVersions: API.OperationMethod<
  ListContactFlowModuleVersionsRequest,
  ListContactFlowModuleVersionsResponse,
  ListContactFlowModuleVersionsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListContactFlowModuleVersionsRequest,
  ) => stream.Stream<
    ListContactFlowModuleVersionsResponse,
    ListContactFlowModuleVersionsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListContactFlowModuleVersionsRequest,
  ) => stream.Stream<
    ContactFlowModuleVersionSummary,
    ListContactFlowModuleVersionsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListContactFlowModuleVersionsRequest,
  output: ListContactFlowModuleVersionsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ContactFlowModuleVersionSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListContactFlowsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Provides information about the flows for the specified Amazon Connect instance.
 *
 * You can also create and update flows using the Amazon Connect
 * Flow language.
 *
 * For more information about flows, see Flows in the Amazon Connect
 * Administrator Guide.
 */
export const listContactFlows: API.OperationMethod<
  ListContactFlowsRequest,
  ListContactFlowsResponse,
  ListContactFlowsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListContactFlowsRequest,
  ) => stream.Stream<
    ListContactFlowsResponse,
    ListContactFlowsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListContactFlowsRequest,
  ) => stream.Stream<
    ContactFlowSummary,
    ListContactFlowsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListContactFlowsRequest,
  output: ListContactFlowsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ContactFlowSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListContactFlowVersionsError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Returns all the available versions for the specified Amazon Connect instance and flow identifier.
 */
export const listContactFlowVersions: API.OperationMethod<
  ListContactFlowVersionsRequest,
  ListContactFlowVersionsResponse,
  ListContactFlowVersionsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListContactFlowVersionsRequest,
  ) => stream.Stream<
    ListContactFlowVersionsResponse,
    ListContactFlowVersionsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListContactFlowVersionsRequest,
  ) => stream.Stream<
    ContactFlowVersionSummary,
    ListContactFlowVersionsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListContactFlowVersionsRequest,
  output: ListContactFlowVersionsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ContactFlowVersionSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListContactReferencesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * For the specified `referenceTypes`, returns a list of references associated with the contact.
 * *References* are links to documents that are related to a contact, such as emails, attachments,
 * or URLs.
 */
export const listContactReferences: API.OperationMethod<
  ListContactReferencesRequest,
  ListContactReferencesResponse,
  ListContactReferencesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListContactReferencesRequest,
  ) => stream.Stream<
    ListContactReferencesResponse,
    ListContactReferencesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListContactReferencesRequest,
  ) => stream.Stream<
    ReferenceSummary,
    ListContactReferencesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListContactReferencesRequest,
  output: ListContactReferencesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ReferenceSummaryList",
  } as const,
}));
export type ListDataTableAttributesError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Returns all attributes for a specified data table. A maximum of 100 attributes per data table is allowed.
 * Customers can request an increase by using Amazon Web Services Service Quotas. The response can be filtered by specific attribute IDs
 * for CloudFormation integration.
 */
export const listDataTableAttributes: API.OperationMethod<
  ListDataTableAttributesRequest,
  ListDataTableAttributesResponse,
  ListDataTableAttributesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListDataTableAttributesRequest,
  ) => stream.Stream<
    ListDataTableAttributesResponse,
    ListDataTableAttributesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListDataTableAttributesRequest,
  ) => stream.Stream<
    DataTableAttribute,
    ListDataTableAttributesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListDataTableAttributesRequest,
  output: ListDataTableAttributesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Attributes",
    pageSize: "MaxResults",
  } as const,
}));
export type ListDataTablePrimaryValuesError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists all primary value combinations for a given data table. Returns the unique combinations of primary
 * attribute values that identify records in the table. Up to 100 records are returned per request.
 */
export const listDataTablePrimaryValues: API.OperationMethod<
  ListDataTablePrimaryValuesRequest,
  ListDataTablePrimaryValuesResponse,
  ListDataTablePrimaryValuesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListDataTablePrimaryValuesRequest,
  ) => stream.Stream<
    ListDataTablePrimaryValuesResponse,
    ListDataTablePrimaryValuesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListDataTablePrimaryValuesRequest,
  ) => stream.Stream<
    RecordPrimaryValue,
    ListDataTablePrimaryValuesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListDataTablePrimaryValuesRequest,
  output: ListDataTablePrimaryValuesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PrimaryValuesList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListDataTablesError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists all data tables for the specified Amazon Connect instance. Returns summary information for each table
 * including basic metadata and modification details.
 */
export const listDataTables: API.OperationMethod<
  ListDataTablesRequest,
  ListDataTablesResponse,
  ListDataTablesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListDataTablesRequest,
  ) => stream.Stream<
    ListDataTablesResponse,
    ListDataTablesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListDataTablesRequest,
  ) => stream.Stream<
    DataTableSummary,
    ListDataTablesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListDataTablesRequest,
  output: ListDataTablesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "DataTableSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListDataTableValuesError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists values stored in a data table with optional filtering by record IDs or primary attribute values. Returns
 * the raw stored values along with metadata such as lock versions and modification timestamps.
 */
export const listDataTableValues: API.OperationMethod<
  ListDataTableValuesRequest,
  ListDataTableValuesResponse,
  ListDataTableValuesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListDataTableValuesRequest,
  ) => stream.Stream<
    ListDataTableValuesResponse,
    ListDataTableValuesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListDataTableValuesRequest,
  ) => stream.Stream<
    DataTableValueSummary,
    ListDataTableValuesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListDataTableValuesRequest,
  output: ListDataTableValuesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Values",
    pageSize: "MaxResults",
  } as const,
}));
export type ListDefaultVocabulariesError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists the default vocabularies for the specified Amazon Connect instance.
 */
export const listDefaultVocabularies: API.OperationMethod<
  ListDefaultVocabulariesRequest,
  ListDefaultVocabulariesResponse,
  ListDefaultVocabulariesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListDefaultVocabulariesRequest,
  ) => stream.Stream<
    ListDefaultVocabulariesResponse,
    ListDefaultVocabulariesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListDefaultVocabulariesRequest,
  ) => stream.Stream<
    DefaultVocabulary,
    ListDefaultVocabulariesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListDefaultVocabulariesRequest,
  output: ListDefaultVocabulariesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "DefaultVocabularyList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListEntitySecurityProfilesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists all security profiles attached to a Q in Connect AIAgent Entity in an Amazon Connect instance.
 */
export const listEntitySecurityProfiles: API.OperationMethod<
  ListEntitySecurityProfilesRequest,
  ListEntitySecurityProfilesResponse,
  ListEntitySecurityProfilesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListEntitySecurityProfilesRequest,
  ) => stream.Stream<
    ListEntitySecurityProfilesResponse,
    ListEntitySecurityProfilesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListEntitySecurityProfilesRequest,
  ) => stream.Stream<
    SecurityProfileItem,
    ListEntitySecurityProfilesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListEntitySecurityProfilesRequest,
  output: ListEntitySecurityProfilesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SecurityProfiles",
    pageSize: "MaxResults",
  } as const,
}));
export type ListEvaluationFormsError =
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists evaluation forms in the specified Amazon Connect instance.
 */
export const listEvaluationForms: API.OperationMethod<
  ListEvaluationFormsRequest,
  ListEvaluationFormsResponse,
  ListEvaluationFormsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListEvaluationFormsRequest,
  ) => stream.Stream<
    ListEvaluationFormsResponse,
    ListEvaluationFormsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListEvaluationFormsRequest,
  ) => stream.Stream<
    EvaluationFormSummary,
    ListEvaluationFormsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListEvaluationFormsRequest,
  output: ListEvaluationFormsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "EvaluationFormSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListEvaluationFormVersionsError =
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists versions of an evaluation form in the specified Amazon Connect instance.
 */
export const listEvaluationFormVersions: API.OperationMethod<
  ListEvaluationFormVersionsRequest,
  ListEvaluationFormVersionsResponse,
  ListEvaluationFormVersionsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListEvaluationFormVersionsRequest,
  ) => stream.Stream<
    ListEvaluationFormVersionsResponse,
    ListEvaluationFormVersionsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListEvaluationFormVersionsRequest,
  ) => stream.Stream<
    EvaluationFormVersionSummary,
    ListEvaluationFormVersionsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListEvaluationFormVersionsRequest,
  output: ListEvaluationFormVersionsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "EvaluationFormVersionSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListFlowAssociationsError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * List the flow association based on the filters.
 */
export const listFlowAssociations: API.OperationMethod<
  ListFlowAssociationsRequest,
  ListFlowAssociationsResponse,
  ListFlowAssociationsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListFlowAssociationsRequest,
  ) => stream.Stream<
    ListFlowAssociationsResponse,
    ListFlowAssociationsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListFlowAssociationsRequest,
  ) => stream.Stream<
    FlowAssociationSummary,
    ListFlowAssociationsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListFlowAssociationsRequest,
  output: ListFlowAssociationsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "FlowAssociationSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListHoursOfOperationOverridesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * List the hours of operation overrides.
 */
export const listHoursOfOperationOverrides: API.OperationMethod<
  ListHoursOfOperationOverridesRequest,
  ListHoursOfOperationOverridesResponse,
  ListHoursOfOperationOverridesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListHoursOfOperationOverridesRequest,
  ) => stream.Stream<
    ListHoursOfOperationOverridesResponse,
    ListHoursOfOperationOverridesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListHoursOfOperationOverridesRequest,
  ) => stream.Stream<
    HoursOfOperationOverride,
    ListHoursOfOperationOverridesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListHoursOfOperationOverridesRequest,
  output: ListHoursOfOperationOverridesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "HoursOfOperationOverrideList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListHoursOfOperationsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Provides information about the hours of operation for the specified Amazon Connect instance.
 *
 * For more information about hours of operation, see Set the Hours of Operation for a Queue in the
 * *Amazon Connect Administrator Guide*.
 */
export const listHoursOfOperations: API.OperationMethod<
  ListHoursOfOperationsRequest,
  ListHoursOfOperationsResponse,
  ListHoursOfOperationsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListHoursOfOperationsRequest,
  ) => stream.Stream<
    ListHoursOfOperationsResponse,
    ListHoursOfOperationsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListHoursOfOperationsRequest,
  ) => stream.Stream<
    HoursOfOperationSummary,
    ListHoursOfOperationsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListHoursOfOperationsRequest,
  output: ListHoursOfOperationsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "HoursOfOperationSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListInstanceAttributesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Returns a paginated list of all attribute types for the given instance.
 */
export const listInstanceAttributes: API.OperationMethod<
  ListInstanceAttributesRequest,
  ListInstanceAttributesResponse,
  ListInstanceAttributesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListInstanceAttributesRequest,
  ) => stream.Stream<
    ListInstanceAttributesResponse,
    ListInstanceAttributesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListInstanceAttributesRequest,
  ) => stream.Stream<
    Attribute,
    ListInstanceAttributesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListInstanceAttributesRequest,
  output: ListInstanceAttributesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Attributes",
    pageSize: "MaxResults",
  } as const,
}));
export type ListInstancesError =
  | InternalServiceException
  | InvalidRequestException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Return a list of instances which are in active state, creation-in-progress state, and failed state. Instances
 * that aren't successfully created (they are in a failed state) are returned only for 24 hours after the CreateInstance
 * API was invoked.
 */
export const listInstances: API.OperationMethod<
  ListInstancesRequest,
  ListInstancesResponse,
  ListInstancesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListInstancesRequest,
  ) => stream.Stream<
    ListInstancesResponse,
    ListInstancesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListInstancesRequest,
  ) => stream.Stream<
    InstanceSummary,
    ListInstancesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListInstancesRequest,
  output: ListInstancesResponse,
  errors: [InternalServiceException, InvalidRequestException],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "InstanceSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListInstanceStorageConfigsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Returns a paginated list of storage configs for the identified instance and resource type.
 */
export const listInstanceStorageConfigs: API.OperationMethod<
  ListInstanceStorageConfigsRequest,
  ListInstanceStorageConfigsResponse,
  ListInstanceStorageConfigsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListInstanceStorageConfigsRequest,
  ) => stream.Stream<
    ListInstanceStorageConfigsResponse,
    ListInstanceStorageConfigsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListInstanceStorageConfigsRequest,
  ) => stream.Stream<
    InstanceStorageConfig,
    ListInstanceStorageConfigsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListInstanceStorageConfigsRequest,
  output: ListInstanceStorageConfigsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "StorageConfigs",
    pageSize: "MaxResults",
  } as const,
}));
export type ListIntegrationAssociationsError =
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Provides summary information about the Amazon Web Services resource associations for the specified Amazon Connect instance.
 */
export const listIntegrationAssociations: API.OperationMethod<
  ListIntegrationAssociationsRequest,
  ListIntegrationAssociationsResponse,
  ListIntegrationAssociationsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListIntegrationAssociationsRequest,
  ) => stream.Stream<
    ListIntegrationAssociationsResponse,
    ListIntegrationAssociationsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListIntegrationAssociationsRequest,
  ) => stream.Stream<
    IntegrationAssociationSummary,
    ListIntegrationAssociationsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListIntegrationAssociationsRequest,
  output: ListIntegrationAssociationsResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "IntegrationAssociationSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListLambdaFunctionsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Returns a paginated list of all Lambda functions that display in the dropdown options in the relevant flow
 * blocks.
 */
export const listLambdaFunctions: API.OperationMethod<
  ListLambdaFunctionsRequest,
  ListLambdaFunctionsResponse,
  ListLambdaFunctionsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListLambdaFunctionsRequest,
  ) => stream.Stream<
    ListLambdaFunctionsResponse,
    ListLambdaFunctionsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListLambdaFunctionsRequest,
  ) => stream.Stream<
    FunctionArn,
    ListLambdaFunctionsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListLambdaFunctionsRequest,
  output: ListLambdaFunctionsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "LambdaFunctions",
    pageSize: "MaxResults",
  } as const,
}));
export type ListLexBotsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Returns a paginated list of all the Amazon Lex V1 bots currently associated with the instance. To return
 * both Amazon Lex V1 and V2 bots, use the ListBots API.
 */
export const listLexBots: API.OperationMethod<
  ListLexBotsRequest,
  ListLexBotsResponse,
  ListLexBotsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListLexBotsRequest,
  ) => stream.Stream<
    ListLexBotsResponse,
    ListLexBotsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListLexBotsRequest,
  ) => stream.Stream<
    LexBot,
    ListLexBotsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListLexBotsRequest,
  output: ListLexBotsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "LexBots",
    pageSize: "MaxResults",
  } as const,
}));
export type ListNotificationsError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Retrieves a paginated list of all notifications in the Amazon Connect instance.
 */
export const listNotifications: API.OperationMethod<
  ListNotificationsRequest,
  ListNotificationsResponse,
  ListNotificationsError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListNotificationsRequest,
  output: ListNotificationsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type ListPhoneNumbersError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Provides information about the phone numbers for the specified Amazon Connect instance.
 *
 * For more information about phone numbers, see Set Up Phone Numbers for Your Contact
 * Center in the *Amazon Connect Administrator Guide*.
 *
 * - We recommend using ListPhoneNumbersV2 to return phone number types. ListPhoneNumbers doesn't support number types
 * `UIFN`, `SHARED`, `THIRD_PARTY_TF`, and `THIRD_PARTY_DID`. While it
 * returns numbers of those types, it incorrectly lists them as `TOLL_FREE` or `DID`.
 *
 * - The phone number `Arn` value that is returned from each of the items in the PhoneNumberSummaryList cannot be used to tag phone number resources. It will fail with a
 * `ResourceNotFoundException`. Instead, use the ListPhoneNumbersV2 API. It returns the new
 * phone number ARN that can be used to tag phone number resources.
 */
export const listPhoneNumbers: API.OperationMethod<
  ListPhoneNumbersRequest,
  ListPhoneNumbersResponse,
  ListPhoneNumbersError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListPhoneNumbersRequest,
  ) => stream.Stream<
    ListPhoneNumbersResponse,
    ListPhoneNumbersError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListPhoneNumbersRequest,
  ) => stream.Stream<
    PhoneNumberSummary,
    ListPhoneNumbersError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListPhoneNumbersRequest,
  output: ListPhoneNumbersResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PhoneNumberSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListPhoneNumbersV2Error =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists phone numbers claimed to your Amazon Connect instance or traffic distribution group. If the provided `TargetArn`
 * is a traffic distribution group, you can call this API in both Amazon Web Services Regions associated with traffic distribution group.
 *
 * For more information about phone numbers, see Set Up Phone Numbers for Your Contact
 * Center in the *Amazon Connect Administrator Guide*.
 *
 * - When given an instance ARN, `ListPhoneNumbersV2` returns only the phone numbers claimed to the
 * instance.
 *
 * - When given a traffic distribution group ARN `ListPhoneNumbersV2` returns only the phone numbers claimed to the
 * traffic distribution group.
 */
export const listPhoneNumbersV2: API.OperationMethod<
  ListPhoneNumbersV2Request,
  ListPhoneNumbersV2Response,
  ListPhoneNumbersV2Error,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListPhoneNumbersV2Request,
  ) => stream.Stream<
    ListPhoneNumbersV2Response,
    ListPhoneNumbersV2Error,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListPhoneNumbersV2Request,
  ) => stream.Stream<
    ListPhoneNumbersSummary,
    ListPhoneNumbersV2Error,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListPhoneNumbersV2Request,
  output: ListPhoneNumbersV2Response,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ListPhoneNumbersSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListPredefinedAttributesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists predefined attributes for the specified Amazon Connect instance. A *predefined attribute* is
 * made up of a name and a value. You can use predefined attributes for:
 *
 * - Routing proficiency (for example, agent certification) that has predefined values (for example, a list of
 * possible certifications). For more information, see Create predefined attributes for routing contacts to
 * agents.
 *
 * - Contact information that varies between transfers or conferences, such as the name of the business unit
 * handling the contact. For more information, see Use contact segment attributes.
 *
 * For the predefined attributes per instance quota, see Amazon Connect
 * quotas.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const listPredefinedAttributes: API.OperationMethod<
  ListPredefinedAttributesRequest,
  ListPredefinedAttributesResponse,
  ListPredefinedAttributesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListPredefinedAttributesRequest,
  ) => stream.Stream<
    ListPredefinedAttributesResponse,
    ListPredefinedAttributesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListPredefinedAttributesRequest,
  ) => stream.Stream<
    PredefinedAttributeSummary,
    ListPredefinedAttributesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListPredefinedAttributesRequest,
  output: ListPredefinedAttributesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PredefinedAttributeSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListPromptsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Provides information about the prompts for the specified Amazon Connect instance.
 */
export const listPrompts: API.OperationMethod<
  ListPromptsRequest,
  ListPromptsResponse,
  ListPromptsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListPromptsRequest,
  ) => stream.Stream<
    ListPromptsResponse,
    ListPromptsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListPromptsRequest,
  ) => stream.Stream<
    PromptSummary,
    ListPromptsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListPromptsRequest,
  output: ListPromptsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PromptSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListQueueQuickConnectsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists the quick connects associated with a queue.
 */
export const listQueueQuickConnects: API.OperationMethod<
  ListQueueQuickConnectsRequest,
  ListQueueQuickConnectsResponse,
  ListQueueQuickConnectsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListQueueQuickConnectsRequest,
  ) => stream.Stream<
    ListQueueQuickConnectsResponse,
    ListQueueQuickConnectsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListQueueQuickConnectsRequest,
  ) => stream.Stream<
    QuickConnectSummary,
    ListQueueQuickConnectsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListQueueQuickConnectsRequest,
  output: ListQueueQuickConnectsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "QuickConnectSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListQueuesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Provides information about the queues for the specified Amazon Connect instance.
 *
 * If you do not specify a `QueueTypes` parameter, both standard and
 * agent queues are returned. This might cause an unexpected truncation of results if you have more than 1000 agents and
 * you limit the number of results of the API call in code.
 *
 * For more information about queues, see Queues: Standard and Agent in the
 * *Amazon Connect Administrator Guide*.
 */
export const listQueues: API.OperationMethod<
  ListQueuesRequest,
  ListQueuesResponse,
  ListQueuesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListQueuesRequest,
  ) => stream.Stream<
    ListQueuesResponse,
    ListQueuesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListQueuesRequest,
  ) => stream.Stream<
    QueueSummary,
    ListQueuesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListQueuesRequest,
  output: ListQueuesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "QueueSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListQuickConnectsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Provides information about the quick connects for the specified Amazon Connect instance.
 */
export const listQuickConnects: API.OperationMethod<
  ListQuickConnectsRequest,
  ListQuickConnectsResponse,
  ListQuickConnectsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListQuickConnectsRequest,
  ) => stream.Stream<
    ListQuickConnectsResponse,
    ListQuickConnectsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListQuickConnectsRequest,
  ) => stream.Stream<
    QuickConnectSummary,
    ListQuickConnectsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListQuickConnectsRequest,
  output: ListQuickConnectsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "QuickConnectSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListRealtimeContactAnalysisSegmentsV2Error =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | OutputTypeNotFoundException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Provides a list of analysis segments for a real-time chat analysis session. This API supports CHAT channels
 * only.
 *
 * This API does not support VOICE. If you attempt to use it for VOICE, an `InvalidRequestException`
 * occurs.
 */
export const listRealtimeContactAnalysisSegmentsV2: API.OperationMethod<
  ListRealtimeContactAnalysisSegmentsV2Request,
  ListRealtimeContactAnalysisSegmentsV2Response,
  ListRealtimeContactAnalysisSegmentsV2Error,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListRealtimeContactAnalysisSegmentsV2Request,
  ) => stream.Stream<
    ListRealtimeContactAnalysisSegmentsV2Response,
    ListRealtimeContactAnalysisSegmentsV2Error,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListRealtimeContactAnalysisSegmentsV2Request,
  ) => stream.Stream<
    unknown,
    ListRealtimeContactAnalysisSegmentsV2Error,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListRealtimeContactAnalysisSegmentsV2Request,
  output: ListRealtimeContactAnalysisSegmentsV2Response,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    OutputTypeNotFoundException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    pageSize: "MaxResults",
  } as const,
}));
export type ListRoutingProfileManualAssignmentQueuesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists the manual assignment queues associated with a routing profile.
 *
 * **Use cases**
 *
 * Following are common uses cases for this API:
 *
 * - This API returns list of queues where contacts can be manually assigned or picked by an agent who has access
 * to the Worklist app. The user can additionally filter on queues, if they have access to those queues (otherwise a
 * invalid request exception will be thrown).
 *
 * For information about how manual contact assignment works in the agent workspace, see the Access the Worklist app in the Amazon Connect agent workspace in the *Amazon Connect Administrator Guide*.
 *
 * **Important things to know**
 *
 * - This API only returns the manual assignment queues associated with a routing profile. Use the
 * ListRoutingProfileQueues API to list the auto assignment queues for the routing profile.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const listRoutingProfileManualAssignmentQueues: API.OperationMethod<
  ListRoutingProfileManualAssignmentQueuesRequest,
  ListRoutingProfileManualAssignmentQueuesResponse,
  ListRoutingProfileManualAssignmentQueuesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListRoutingProfileManualAssignmentQueuesRequest,
  ) => stream.Stream<
    ListRoutingProfileManualAssignmentQueuesResponse,
    ListRoutingProfileManualAssignmentQueuesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListRoutingProfileManualAssignmentQueuesRequest,
  ) => stream.Stream<
    RoutingProfileManualAssignmentQueueConfigSummary,
    ListRoutingProfileManualAssignmentQueuesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListRoutingProfileManualAssignmentQueuesRequest,
  output: ListRoutingProfileManualAssignmentQueuesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "RoutingProfileManualAssignmentQueueConfigSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListRoutingProfileQueuesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists the queues associated with a routing profile.
 */
export const listRoutingProfileQueues: API.OperationMethod<
  ListRoutingProfileQueuesRequest,
  ListRoutingProfileQueuesResponse,
  ListRoutingProfileQueuesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListRoutingProfileQueuesRequest,
  ) => stream.Stream<
    ListRoutingProfileQueuesResponse,
    ListRoutingProfileQueuesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListRoutingProfileQueuesRequest,
  ) => stream.Stream<
    RoutingProfileQueueConfigSummary,
    ListRoutingProfileQueuesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListRoutingProfileQueuesRequest,
  output: ListRoutingProfileQueuesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "RoutingProfileQueueConfigSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListRoutingProfilesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Provides summary information about the routing profiles for the specified Amazon Connect instance.
 *
 * For more information about routing profiles, see Routing Profiles and Create a Routing Profile in the *Amazon Connect Administrator Guide*.
 */
export const listRoutingProfiles: API.OperationMethod<
  ListRoutingProfilesRequest,
  ListRoutingProfilesResponse,
  ListRoutingProfilesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListRoutingProfilesRequest,
  ) => stream.Stream<
    ListRoutingProfilesResponse,
    ListRoutingProfilesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListRoutingProfilesRequest,
  ) => stream.Stream<
    RoutingProfileSummary,
    ListRoutingProfilesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListRoutingProfilesRequest,
  output: ListRoutingProfilesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "RoutingProfileSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListRulesError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * List all rules for the specified Amazon Connect instance.
 */
export const listRules: API.OperationMethod<
  ListRulesRequest,
  ListRulesResponse,
  ListRulesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListRulesRequest,
  ) => stream.Stream<
    ListRulesResponse,
    ListRulesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListRulesRequest,
  ) => stream.Stream<
    RuleSummary,
    ListRulesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListRulesRequest,
  output: ListRulesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "RuleSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListSecurityKeysError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Returns a paginated list of all security keys associated with the instance.
 */
export const listSecurityKeys: API.OperationMethod<
  ListSecurityKeysRequest,
  ListSecurityKeysResponse,
  ListSecurityKeysError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListSecurityKeysRequest,
  ) => stream.Stream<
    ListSecurityKeysResponse,
    ListSecurityKeysError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListSecurityKeysRequest,
  ) => stream.Stream<
    SecurityKey,
    ListSecurityKeysError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListSecurityKeysRequest,
  output: ListSecurityKeysResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SecurityKeys",
    pageSize: "MaxResults",
  } as const,
}));
export type ListSecurityProfileApplicationsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Returns a list of third-party applications or MCP Servers in a specific security profile.
 */
export const listSecurityProfileApplications: API.OperationMethod<
  ListSecurityProfileApplicationsRequest,
  ListSecurityProfileApplicationsResponse,
  ListSecurityProfileApplicationsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListSecurityProfileApplicationsRequest,
  ) => stream.Stream<
    ListSecurityProfileApplicationsResponse,
    ListSecurityProfileApplicationsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListSecurityProfileApplicationsRequest,
  ) => stream.Stream<
    Application,
    ListSecurityProfileApplicationsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListSecurityProfileApplicationsRequest,
  output: ListSecurityProfileApplicationsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Applications",
    pageSize: "MaxResults",
  } as const,
}));
export type ListSecurityProfileFlowModulesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * A list of Flow Modules an AI Agent can invoke as a tool
 */
export const listSecurityProfileFlowModules: API.OperationMethod<
  ListSecurityProfileFlowModulesRequest,
  ListSecurityProfileFlowModulesResponse,
  ListSecurityProfileFlowModulesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListSecurityProfileFlowModulesRequest,
  ) => stream.Stream<
    ListSecurityProfileFlowModulesResponse,
    ListSecurityProfileFlowModulesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListSecurityProfileFlowModulesRequest,
  ) => stream.Stream<
    FlowModule,
    ListSecurityProfileFlowModulesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListSecurityProfileFlowModulesRequest,
  output: ListSecurityProfileFlowModulesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AllowedFlowModules",
    pageSize: "MaxResults",
  } as const,
}));
export type ListSecurityProfilePermissionsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists the permissions granted to a security profile.
 *
 * For information about security profiles, see Security Profiles in the *Amazon Connect Administrator Guide*. For a mapping of the API name and user interface name of the security
 * profile permissions, see List
 * of security profile permissions.
 */
export const listSecurityProfilePermissions: API.OperationMethod<
  ListSecurityProfilePermissionsRequest,
  ListSecurityProfilePermissionsResponse,
  ListSecurityProfilePermissionsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListSecurityProfilePermissionsRequest,
  ) => stream.Stream<
    ListSecurityProfilePermissionsResponse,
    ListSecurityProfilePermissionsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListSecurityProfilePermissionsRequest,
  ) => stream.Stream<
    SecurityProfilePermission,
    ListSecurityProfilePermissionsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListSecurityProfilePermissionsRequest,
  output: ListSecurityProfilePermissionsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Permissions",
    pageSize: "MaxResults",
  } as const,
}));
export type ListSecurityProfilesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Provides summary information about the security profiles for the specified Amazon Connect instance.
 *
 * For more information about security profiles, see Security Profiles in the *Amazon Connect Administrator Guide*. For a mapping of the API name and user interface name of the security
 * profile permissions, see List
 * of security profile permissions.
 */
export const listSecurityProfiles: API.OperationMethod<
  ListSecurityProfilesRequest,
  ListSecurityProfilesResponse,
  ListSecurityProfilesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListSecurityProfilesRequest,
  ) => stream.Stream<
    ListSecurityProfilesResponse,
    ListSecurityProfilesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListSecurityProfilesRequest,
  ) => stream.Stream<
    SecurityProfileSummary,
    ListSecurityProfilesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListSecurityProfilesRequest,
  output: ListSecurityProfilesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SecurityProfileSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListTagsForResourceError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists the tags for the specified resource.
 *
 * For sample policies that use tags, see Amazon Connect Identity-Based Policy
 * Examples in the *Amazon Connect Administrator Guide*.
 */
export const listTagsForResource: API.OperationMethod<
  ListTagsForResourceRequest,
  ListTagsForResourceResponse,
  ListTagsForResourceError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListTagsForResourceRequest,
  output: ListTagsForResourceResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type ListTaskTemplatesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists task templates for the specified Amazon Connect instance.
 */
export const listTaskTemplates: API.OperationMethod<
  ListTaskTemplatesRequest,
  ListTaskTemplatesResponse,
  ListTaskTemplatesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListTaskTemplatesRequest,
  ) => stream.Stream<
    ListTaskTemplatesResponse,
    ListTaskTemplatesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListTaskTemplatesRequest,
  ) => stream.Stream<
    TaskTemplateMetadata,
    ListTaskTemplatesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListTaskTemplatesRequest,
  output: ListTaskTemplatesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TaskTemplates",
    pageSize: "MaxResults",
  } as const,
}));
export type ListTestCaseExecutionRecordsError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists detailed steps of test case execution that includes all observations along with actions taken and data associated in the specified Amazon Connect instance.
 */
export const listTestCaseExecutionRecords: API.OperationMethod<
  ListTestCaseExecutionRecordsRequest,
  ListTestCaseExecutionRecordsResponse,
  ListTestCaseExecutionRecordsError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListTestCaseExecutionRecordsRequest,
  output: ListTestCaseExecutionRecordsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type ListTestCaseExecutionsError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists all test case executions and allows filtering by test case id, test case name, start time, end time or status of the execution for the specified Amazon Connect instance.
 */
export const listTestCaseExecutions: API.OperationMethod<
  ListTestCaseExecutionsRequest,
  ListTestCaseExecutionsResponse,
  ListTestCaseExecutionsError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListTestCaseExecutionsRequest,
  output: ListTestCaseExecutionsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type ListTestCasesError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists the test cases present in the specific Amazon Connect instance.
 */
export const listTestCases: API.OperationMethod<
  ListTestCasesRequest,
  ListTestCasesResponse,
  ListTestCasesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListTestCasesRequest,
  ) => stream.Stream<
    ListTestCasesResponse,
    ListTestCasesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListTestCasesRequest,
  ) => stream.Stream<
    TestCaseSummary,
    ListTestCasesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListTestCasesRequest,
  output: ListTestCasesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TestCaseSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListTrafficDistributionGroupsError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists traffic distribution groups.
 */
export const listTrafficDistributionGroups: API.OperationMethod<
  ListTrafficDistributionGroupsRequest,
  ListTrafficDistributionGroupsResponse,
  ListTrafficDistributionGroupsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListTrafficDistributionGroupsRequest,
  ) => stream.Stream<
    ListTrafficDistributionGroupsResponse,
    ListTrafficDistributionGroupsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListTrafficDistributionGroupsRequest,
  ) => stream.Stream<
    TrafficDistributionGroupSummary,
    ListTrafficDistributionGroupsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListTrafficDistributionGroupsRequest,
  output: ListTrafficDistributionGroupsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TrafficDistributionGroupSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListTrafficDistributionGroupUsersError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists traffic distribution group users.
 */
export const listTrafficDistributionGroupUsers: API.OperationMethod<
  ListTrafficDistributionGroupUsersRequest,
  ListTrafficDistributionGroupUsersResponse,
  ListTrafficDistributionGroupUsersError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListTrafficDistributionGroupUsersRequest,
  ) => stream.Stream<
    ListTrafficDistributionGroupUsersResponse,
    ListTrafficDistributionGroupUsersError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListTrafficDistributionGroupUsersRequest,
  ) => stream.Stream<
    TrafficDistributionGroupUserSummary,
    ListTrafficDistributionGroupUsersError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListTrafficDistributionGroupUsersRequest,
  output: ListTrafficDistributionGroupUsersResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TrafficDistributionGroupUserSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListUseCasesError =
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists the use cases for the integration association.
 */
export const listUseCases: API.OperationMethod<
  ListUseCasesRequest,
  ListUseCasesResponse,
  ListUseCasesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListUseCasesRequest,
  ) => stream.Stream<
    ListUseCasesResponse,
    ListUseCasesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListUseCasesRequest,
  ) => stream.Stream<
    UseCase,
    ListUseCasesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListUseCasesRequest,
  output: ListUseCasesResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "UseCaseSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListUserHierarchyGroupsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Provides summary information about the hierarchy groups for the specified Amazon Connect instance.
 *
 * For more information about agent hierarchies, see Set Up Agent Hierarchies in the *Amazon Connect Administrator Guide*.
 */
export const listUserHierarchyGroups: API.OperationMethod<
  ListUserHierarchyGroupsRequest,
  ListUserHierarchyGroupsResponse,
  ListUserHierarchyGroupsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListUserHierarchyGroupsRequest,
  ) => stream.Stream<
    ListUserHierarchyGroupsResponse,
    ListUserHierarchyGroupsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListUserHierarchyGroupsRequest,
  ) => stream.Stream<
    HierarchyGroupSummary,
    ListUserHierarchyGroupsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListUserHierarchyGroupsRequest,
  output: ListUserHierarchyGroupsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "UserHierarchyGroupSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListUserNotificationsError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Retrieves a paginated list of notifications for a specific user, including the notification status for that user.
 */
export const listUserNotifications: API.OperationMethod<
  ListUserNotificationsRequest,
  ListUserNotificationsResponse,
  ListUserNotificationsError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListUserNotificationsRequest,
  output: ListUserNotificationsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type ListUserProficienciesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists proficiencies associated with a user.
 */
export const listUserProficiencies: API.OperationMethod<
  ListUserProficienciesRequest,
  ListUserProficienciesResponse,
  ListUserProficienciesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListUserProficienciesRequest,
  ) => stream.Stream<
    ListUserProficienciesResponse,
    ListUserProficienciesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListUserProficienciesRequest,
  ) => stream.Stream<
    UserProficiency,
    ListUserProficienciesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListUserProficienciesRequest,
  output: ListUserProficienciesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "UserProficiencyList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListUsersError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Provides summary information about the users for the specified Amazon Connect instance.
 */
export const listUsers: API.OperationMethod<
  ListUsersRequest,
  ListUsersResponse,
  ListUsersError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListUsersRequest,
  ) => stream.Stream<
    ListUsersResponse,
    ListUsersError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListUsersRequest,
  ) => stream.Stream<
    UserSummary,
    ListUsersError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListUsersRequest,
  output: ListUsersResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "UserSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListViewsError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | TooManyRequestsException
  | CommonErrors;
/**
 * Returns views in the given instance.
 *
 * Results are sorted primarily by type, and secondarily by name.
 */
export const listViews: API.OperationMethod<
  ListViewsRequest,
  ListViewsResponse,
  ListViewsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListViewsRequest,
  ) => stream.Stream<
    ListViewsResponse,
    ListViewsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListViewsRequest,
  ) => stream.Stream<
    ViewSummary,
    ListViewsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListViewsRequest,
  output: ListViewsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    TooManyRequestsException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ViewsSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListViewVersionsError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | TooManyRequestsException
  | CommonErrors;
/**
 * Returns all the available versions for the specified Amazon Connect instance and view identifier.
 *
 * Results will be sorted from highest to lowest.
 */
export const listViewVersions: API.OperationMethod<
  ListViewVersionsRequest,
  ListViewVersionsResponse,
  ListViewVersionsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListViewVersionsRequest,
  ) => stream.Stream<
    ListViewVersionsResponse,
    ListViewVersionsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListViewVersionsRequest,
  ) => stream.Stream<
    ViewVersionSummary,
    ListViewVersionsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListViewVersionsRequest,
  output: ListViewVersionsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    TooManyRequestsException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ViewVersionSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListWorkspaceMediaError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists media assets (such as logos) associated with a workspace.
 */
export const listWorkspaceMedia: API.OperationMethod<
  ListWorkspaceMediaRequest,
  ListWorkspaceMediaResponse,
  ListWorkspaceMediaError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListWorkspaceMediaRequest,
  output: ListWorkspaceMediaResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type ListWorkspacePagesError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists the page configurations in a workspace, including the views assigned to each page.
 */
export const listWorkspacePages: API.OperationMethod<
  ListWorkspacePagesRequest,
  ListWorkspacePagesResponse,
  ListWorkspacePagesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListWorkspacePagesRequest,
  ) => stream.Stream<
    ListWorkspacePagesResponse,
    ListWorkspacePagesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListWorkspacePagesRequest,
  ) => stream.Stream<
    WorkspacePage,
    ListWorkspacePagesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListWorkspacePagesRequest,
  output: ListWorkspacePagesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "WorkspacePageList",
    pageSize: "MaxResults",
  } as const,
}));
export type ListWorkspacesError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Lists the workspaces in an Amazon Connect instance.
 */
export const listWorkspaces: API.OperationMethod<
  ListWorkspacesRequest,
  ListWorkspacesResponse,
  ListWorkspacesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: ListWorkspacesRequest,
  ) => stream.Stream<
    ListWorkspacesResponse,
    ListWorkspacesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListWorkspacesRequest,
  ) => stream.Stream<
    WorkspaceSummary,
    ListWorkspacesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListWorkspacesRequest,
  output: ListWorkspacesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "WorkspaceSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type MonitorContactError =
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Initiates silent monitoring of a contact. The Contact Control Panel (CCP) of the user specified by
 * *userId* will be set to silent monitoring mode on the contact.
 */
export const monitorContact: API.OperationMethod<
  MonitorContactRequest,
  MonitorContactResponse,
  MonitorContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: MonitorContactRequest,
  output: MonitorContactResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type PauseContactError =
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Allows pausing an ongoing task contact.
 */
export const pauseContact: API.OperationMethod<
  PauseContactRequest,
  PauseContactResponse,
  PauseContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: PauseContactRequest,
  output: PauseContactResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type PutUserStatusError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Changes the current status of a user or agent in Amazon Connect. If the agent is currently handling a
 * contact, this sets the agent's next status.
 *
 * For more information, see Agent status and Set your
 * next status in the *Amazon Connect Administrator Guide*.
 */
export const putUserStatus: API.OperationMethod<
  PutUserStatusRequest,
  PutUserStatusResponse,
  PutUserStatusError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: PutUserStatusRequest,
  output: PutUserStatusResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type ReleasePhoneNumberError =
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Releases a phone number previously claimed to an Amazon Connect instance or traffic distribution group. You can call this API
 * only in the Amazon Web Services Region where the number was claimed.
 *
 * To release phone numbers from a traffic distribution group, use the `ReleasePhoneNumber` API, not the Amazon Connect admin website.
 *
 * After releasing a phone number, the phone number enters into a cooldown period for up to 180 days. It cannot be
 * searched for or claimed again until the period has ended. If you accidentally release a phone number, contact
 * Amazon Web Services Support.
 *
 * If you plan to claim and release numbers frequently,
 * contact us for a service quota exception. Otherwise, it is possible you will be blocked from
 * claiming and releasing any more numbers until up to 180 days past the oldest number
 * released has expired.
 *
 * By default you can claim and release up to 200% of your maximum number of active
 * phone numbers. If you claim and release phone numbers using
 * the UI or API during a rolling 180 day cycle that exceeds 200% of your phone number
 * service level quota, you will be blocked from claiming any more numbers until 180
 * days past the oldest number released has expired.
 *
 * For example, if you already have 99 claimed numbers and a service level quota of 99 phone numbers, and in any 180
 * day period you release 99, claim 99, and then release 99, you will have exceeded the
 * 200% limit. At that point you are blocked from claiming any more numbers until you
 * open an Amazon Web Services support ticket.
 */
export const releasePhoneNumber: API.OperationMethod<
  ReleasePhoneNumberRequest,
  ReleasePhoneNumberResponse,
  ReleasePhoneNumberError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ReleasePhoneNumberRequest,
  output: ReleasePhoneNumberResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type ReplicateInstanceError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ResourceNotReadyException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Replicates an Amazon Connect instance in the specified Amazon Web Services Region and copies configuration
 * information for Amazon Connect resources across Amazon Web Services Regions.
 *
 * For more information about replicating an Amazon Connect instance, see Create a replica of your existing Amazon Connect
 * instance in the *Amazon Connect Administrator Guide*.
 */
export const replicateInstance: API.OperationMethod<
  ReplicateInstanceRequest,
  ReplicateInstanceResponse,
  ReplicateInstanceError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ReplicateInstanceRequest,
  output: ReplicateInstanceResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ResourceNotReadyException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type ResumeContactError =
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Allows resuming a task contact in a paused state.
 */
export const resumeContact: API.OperationMethod<
  ResumeContactRequest,
  ResumeContactResponse,
  ResumeContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ResumeContactRequest,
  output: ResumeContactResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type ResumeContactRecordingError =
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors;
/**
 * When a contact is being recorded, and the recording has been suspended using SuspendContactRecording, this API
 * resumes recording whatever recording is selected in the flow configuration: call, screen, or both. If only call
 * recording or only screen recording is enabled, then it would resume.
 *
 * Voice and screen recordings are supported.
 */
export const resumeContactRecording: API.OperationMethod<
  ResumeContactRecordingRequest,
  ResumeContactRecordingResponse,
  ResumeContactRecordingError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ResumeContactRecordingRequest,
  output: ResumeContactRecordingResponse,
  errors: [
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
export type SearchAgentStatusesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches AgentStatuses in an Amazon Connect instance, with optional filtering.
 */
export const searchAgentStatuses: API.OperationMethod<
  SearchAgentStatusesRequest,
  SearchAgentStatusesResponse,
  SearchAgentStatusesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchAgentStatusesRequest,
  ) => stream.Stream<
    SearchAgentStatusesResponse,
    SearchAgentStatusesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchAgentStatusesRequest,
  ) => stream.Stream<
    AgentStatus,
    SearchAgentStatusesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchAgentStatusesRequest,
  output: SearchAgentStatusesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AgentStatuses",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchAvailablePhoneNumbersError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches for available phone numbers that you can claim to your Amazon Connect instance or traffic distribution group. If the
 * provided `TargetArn` is a traffic distribution group, you can call this API in both Amazon Web Services Regions associated with
 * the traffic distribution group.
 */
export const searchAvailablePhoneNumbers: API.OperationMethod<
  SearchAvailablePhoneNumbersRequest,
  SearchAvailablePhoneNumbersResponse,
  SearchAvailablePhoneNumbersError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchAvailablePhoneNumbersRequest,
  ) => stream.Stream<
    SearchAvailablePhoneNumbersResponse,
    SearchAvailablePhoneNumbersError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchAvailablePhoneNumbersRequest,
  ) => stream.Stream<
    AvailableNumberSummary,
    SearchAvailablePhoneNumbersError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchAvailablePhoneNumbersRequest,
  output: SearchAvailablePhoneNumbersResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AvailableNumbersList",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchContactEvaluationsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches contact evaluations in an Amazon Connect instance, with optional filtering.
 *
 * **Use cases**
 *
 * Following are common uses cases for this API:
 *
 * - Find contact evaluations by using specific search criteria.
 *
 * - Find contact evaluations that are tagged with a specific set of tags.
 *
 * **Important things to know**
 *
 * - A Search operation, unlike a List operation, takes time to index changes to resource (create, update or
 * delete). If you don't see updated information for recently changed contact evaluations, try calling the API again
 * in a few seconds. Contact Evaluations may not be fully backfilled with historical data in all regions yet, however
 * all recently created Contact Evaluations should be available for search.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const searchContactEvaluations: API.OperationMethod<
  SearchContactEvaluationsRequest,
  SearchContactEvaluationsResponse,
  SearchContactEvaluationsError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SearchContactEvaluationsRequest,
  output: SearchContactEvaluationsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type SearchContactFlowModulesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches the flow modules in an Amazon Connect instance, with optional filtering.
 */
export const searchContactFlowModules: API.OperationMethod<
  SearchContactFlowModulesRequest,
  SearchContactFlowModulesResponse,
  SearchContactFlowModulesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchContactFlowModulesRequest,
  ) => stream.Stream<
    SearchContactFlowModulesResponse,
    SearchContactFlowModulesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchContactFlowModulesRequest,
  ) => stream.Stream<
    ContactFlowModule,
    SearchContactFlowModulesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchContactFlowModulesRequest,
  output: SearchContactFlowModulesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ContactFlowModules",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchContactFlowsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches the flows in an Amazon Connect instance, with optional filtering.
 */
export const searchContactFlows: API.OperationMethod<
  SearchContactFlowsRequest,
  SearchContactFlowsResponse,
  SearchContactFlowsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchContactFlowsRequest,
  ) => stream.Stream<
    SearchContactFlowsResponse,
    SearchContactFlowsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchContactFlowsRequest,
  ) => stream.Stream<
    ContactFlow,
    SearchContactFlowsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchContactFlowsRequest,
  output: SearchContactFlowsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ContactFlows",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchContactsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches contacts in an Amazon Connect instance.
 */
export const searchContacts: API.OperationMethod<
  SearchContactsRequest,
  SearchContactsResponse,
  SearchContactsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchContactsRequest,
  ) => stream.Stream<
    SearchContactsResponse,
    SearchContactsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchContactsRequest,
  ) => stream.Stream<
    ContactSearchSummary,
    SearchContactsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchContactsRequest,
  output: SearchContactsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Contacts",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchDataTablesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches for data tables based on the table's ID, name, and description. In the future, this operation can
 * support searching on attribute names and possibly primary values. Follows other search operations closely and
 * supports both search criteria and filters.
 */
export const searchDataTables: API.OperationMethod<
  SearchDataTablesRequest,
  SearchDataTablesResponse,
  SearchDataTablesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchDataTablesRequest,
  ) => stream.Stream<
    SearchDataTablesResponse,
    SearchDataTablesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchDataTablesRequest,
  ) => stream.Stream<
    DataTable,
    SearchDataTablesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchDataTablesRequest,
  output: SearchDataTablesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "DataTables",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchEmailAddressesError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches email address in an instance, with optional filtering.
 */
export const searchEmailAddresses: API.OperationMethod<
  SearchEmailAddressesRequest,
  SearchEmailAddressesResponse,
  SearchEmailAddressesError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SearchEmailAddressesRequest,
  output: SearchEmailAddressesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type SearchEvaluationFormsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches evaluation forms in an Amazon Connect instance, with optional filtering.
 *
 * **Use cases**
 *
 * Following are common uses cases for this API:
 *
 * - List all evaluation forms in an instance.
 *
 * - Find all evaluation forms that meet specific criteria, such as Title, Description, Status, and more.
 *
 * - Find all evaluation forms that are tagged with a specific set of tags.
 *
 * **Important things to know**
 *
 * - A Search operation, unlike a List operation, takes time to index changes to resource (create, update or
 * delete). If you don't see updated information for recently changed contact evaluations, try calling the API again
 * in a few seconds.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const searchEvaluationForms: API.OperationMethod<
  SearchEvaluationFormsRequest,
  SearchEvaluationFormsResponse,
  SearchEvaluationFormsError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SearchEvaluationFormsRequest,
  output: SearchEvaluationFormsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type SearchHoursOfOperationOverridesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches the hours of operation overrides.
 */
export const searchHoursOfOperationOverrides: API.OperationMethod<
  SearchHoursOfOperationOverridesRequest,
  SearchHoursOfOperationOverridesResponse,
  SearchHoursOfOperationOverridesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchHoursOfOperationOverridesRequest,
  ) => stream.Stream<
    SearchHoursOfOperationOverridesResponse,
    SearchHoursOfOperationOverridesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchHoursOfOperationOverridesRequest,
  ) => stream.Stream<
    HoursOfOperationOverride,
    SearchHoursOfOperationOverridesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchHoursOfOperationOverridesRequest,
  output: SearchHoursOfOperationOverridesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "HoursOfOperationOverrides",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchHoursOfOperationsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches the hours of operation in an Amazon Connect instance, with optional filtering.
 */
export const searchHoursOfOperations: API.OperationMethod<
  SearchHoursOfOperationsRequest,
  SearchHoursOfOperationsResponse,
  SearchHoursOfOperationsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchHoursOfOperationsRequest,
  ) => stream.Stream<
    SearchHoursOfOperationsResponse,
    SearchHoursOfOperationsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchHoursOfOperationsRequest,
  ) => stream.Stream<
    HoursOfOperation,
    SearchHoursOfOperationsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchHoursOfOperationsRequest,
  output: SearchHoursOfOperationsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "HoursOfOperations",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchNotificationsError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches for notifications based on specified criteria and filters. Returns a paginated list of notifications matching the search parameters, ordered by descending creation time. Supports filtering by content and tags.
 */
export const searchNotifications: API.OperationMethod<
  SearchNotificationsRequest,
  SearchNotificationsResponse,
  SearchNotificationsError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SearchNotificationsRequest,
  output: SearchNotificationsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type SearchPredefinedAttributesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches predefined attributes that meet certain criteria. A *predefined attribute* is made
 * up of a name and a value. You can use predefined attributes for:
 *
 * - Routing proficiency (for example, agent certification) that has predefined values (for example, a list of
 * possible certifications). For more information, see Create predefined attributes for routing contacts to
 * agents.
 *
 * - Contact information that varies between transfers or conferences, such as the name of the business unit
 * handling the contact. For more information, see Use contact segment attributes.
 *
 * For the predefined attributes per instance quota, see Amazon Connect
 * quotas.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const searchPredefinedAttributes: API.OperationMethod<
  SearchPredefinedAttributesRequest,
  SearchPredefinedAttributesResponse,
  SearchPredefinedAttributesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchPredefinedAttributesRequest,
  ) => stream.Stream<
    SearchPredefinedAttributesResponse,
    SearchPredefinedAttributesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchPredefinedAttributesRequest,
  ) => stream.Stream<
    PredefinedAttribute,
    SearchPredefinedAttributesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchPredefinedAttributesRequest,
  output: SearchPredefinedAttributesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PredefinedAttributes",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchPromptsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches prompts in an Amazon Connect instance, with optional filtering.
 */
export const searchPrompts: API.OperationMethod<
  SearchPromptsRequest,
  SearchPromptsResponse,
  SearchPromptsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchPromptsRequest,
  ) => stream.Stream<
    SearchPromptsResponse,
    SearchPromptsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchPromptsRequest,
  ) => stream.Stream<
    Prompt,
    SearchPromptsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchPromptsRequest,
  output: SearchPromptsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Prompts",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchQueuesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches queues in an Amazon Connect instance, with optional filtering.
 */
export const searchQueues: API.OperationMethod<
  SearchQueuesRequest,
  SearchQueuesResponse,
  SearchQueuesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchQueuesRequest,
  ) => stream.Stream<
    SearchQueuesResponse,
    SearchQueuesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchQueuesRequest,
  ) => stream.Stream<
    Queue,
    SearchQueuesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchQueuesRequest,
  output: SearchQueuesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Queues",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchQuickConnectsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches quick connects in an Amazon Connect instance, with optional filtering.
 */
export const searchQuickConnects: API.OperationMethod<
  SearchQuickConnectsRequest,
  SearchQuickConnectsResponse,
  SearchQuickConnectsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchQuickConnectsRequest,
  ) => stream.Stream<
    SearchQuickConnectsResponse,
    SearchQuickConnectsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchQuickConnectsRequest,
  ) => stream.Stream<
    QuickConnect,
    SearchQuickConnectsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchQuickConnectsRequest,
  output: SearchQuickConnectsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "QuickConnects",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchResourceTagsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | MaximumResultReturnedException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches tags used in an Amazon Connect instance using optional search criteria.
 */
export const searchResourceTags: API.OperationMethod<
  SearchResourceTagsRequest,
  SearchResourceTagsResponse,
  SearchResourceTagsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchResourceTagsRequest,
  ) => stream.Stream<
    SearchResourceTagsResponse,
    SearchResourceTagsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchResourceTagsRequest,
  ) => stream.Stream<
    TagSet,
    SearchResourceTagsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchResourceTagsRequest,
  output: SearchResourceTagsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    MaximumResultReturnedException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Tags",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchRoutingProfilesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches routing profiles in an Amazon Connect instance, with optional filtering.
 *
 * `SearchRoutingProfiles` does not populate LastModifiedRegion, LastModifiedTime,
 * MediaConcurrencies.CrossChannelBehavior, and AgentAvailabilityTimer in its response, but DescribeRoutingProfile does.
 */
export const searchRoutingProfiles: API.OperationMethod<
  SearchRoutingProfilesRequest,
  SearchRoutingProfilesResponse,
  SearchRoutingProfilesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchRoutingProfilesRequest,
  ) => stream.Stream<
    SearchRoutingProfilesResponse,
    SearchRoutingProfilesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchRoutingProfilesRequest,
  ) => stream.Stream<
    RoutingProfile,
    SearchRoutingProfilesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchRoutingProfilesRequest,
  output: SearchRoutingProfilesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "RoutingProfiles",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchSecurityProfilesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches security profiles in an Amazon Connect instance, with optional filtering.
 *
 * For information about security profiles, see Security Profiles in the *Amazon Connect Administrator Guide*. For a mapping of the API name and user interface name of the security
 * profile permissions, see List
 * of security profile permissions.
 */
export const searchSecurityProfiles: API.OperationMethod<
  SearchSecurityProfilesRequest,
  SearchSecurityProfilesResponse,
  SearchSecurityProfilesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchSecurityProfilesRequest,
  ) => stream.Stream<
    SearchSecurityProfilesResponse,
    SearchSecurityProfilesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchSecurityProfilesRequest,
  ) => stream.Stream<
    SecurityProfileSearchSummary,
    SearchSecurityProfilesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchSecurityProfilesRequest,
  output: SearchSecurityProfilesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SecurityProfiles",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchTestCasesError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches for test cases in the specified Amazon Connect instance, with optional filtering.
 */
export const searchTestCases: API.OperationMethod<
  SearchTestCasesRequest,
  SearchTestCasesResponse,
  SearchTestCasesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchTestCasesRequest,
  ) => stream.Stream<
    SearchTestCasesResponse,
    SearchTestCasesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchTestCasesRequest,
  ) => stream.Stream<
    TestCase,
    SearchTestCasesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchTestCasesRequest,
  output: SearchTestCasesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TestCases",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchUserHierarchyGroupsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches UserHierarchyGroups in an Amazon Connect instance, with optional filtering.
 *
 * The UserHierarchyGroup with `"LevelId": "0"` is the foundation for building levels on top of an
 * instance. It is not user-definable, nor is it visible in the UI.
 */
export const searchUserHierarchyGroups: API.OperationMethod<
  SearchUserHierarchyGroupsRequest,
  SearchUserHierarchyGroupsResponse,
  SearchUserHierarchyGroupsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchUserHierarchyGroupsRequest,
  ) => stream.Stream<
    SearchUserHierarchyGroupsResponse,
    SearchUserHierarchyGroupsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchUserHierarchyGroupsRequest,
  ) => stream.Stream<
    HierarchyGroup,
    SearchUserHierarchyGroupsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchUserHierarchyGroupsRequest,
  output: SearchUserHierarchyGroupsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "UserHierarchyGroups",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchUsersError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches users in an Amazon Connect instance, with optional filtering.
 *
 * `AfterContactWorkTimeLimit` is returned in milliseconds.
 */
export const searchUsers: API.OperationMethod<
  SearchUsersRequest,
  SearchUsersResponse,
  SearchUsersError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchUsersRequest,
  ) => stream.Stream<
    SearchUsersResponse,
    SearchUsersError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchUsersRequest,
  ) => stream.Stream<
    UserSearchSummary,
    SearchUsersError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchUsersRequest,
  output: SearchUsersResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Users",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchViewsError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches views based on name, description, or tags.
 */
export const searchViews: API.OperationMethod<
  SearchViewsRequest,
  SearchViewsResponse,
  SearchViewsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchViewsRequest,
  ) => stream.Stream<
    SearchViewsResponse,
    SearchViewsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchViewsRequest,
  ) => stream.Stream<
    View,
    SearchViewsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchViewsRequest,
  output: SearchViewsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Views",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchVocabulariesError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches for vocabularies within a specific Amazon Connect instance using `State`,
 * `NameStartsWith`, and `LanguageCode`.
 */
export const searchVocabularies: API.OperationMethod<
  SearchVocabulariesRequest,
  SearchVocabulariesResponse,
  SearchVocabulariesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchVocabulariesRequest,
  ) => stream.Stream<
    SearchVocabulariesResponse,
    SearchVocabulariesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchVocabulariesRequest,
  ) => stream.Stream<
    VocabularySummary,
    SearchVocabulariesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchVocabulariesRequest,
  output: SearchVocabulariesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "VocabularySummaryList",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchWorkspaceAssociationsError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches for workspace associations with users or routing profiles based on various criteria.
 */
export const searchWorkspaceAssociations: API.OperationMethod<
  SearchWorkspaceAssociationsRequest,
  SearchWorkspaceAssociationsResponse,
  SearchWorkspaceAssociationsError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchWorkspaceAssociationsRequest,
  ) => stream.Stream<
    SearchWorkspaceAssociationsResponse,
    SearchWorkspaceAssociationsError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchWorkspaceAssociationsRequest,
  ) => stream.Stream<
    WorkspaceAssociationSearchSummary,
    SearchWorkspaceAssociationsError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchWorkspaceAssociationsRequest,
  output: SearchWorkspaceAssociationsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "WorkspaceAssociations",
    pageSize: "MaxResults",
  } as const,
}));
export type SearchWorkspacesError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Searches workspaces based on name, description, visibility, or tags.
 */
export const searchWorkspaces: API.OperationMethod<
  SearchWorkspacesRequest,
  SearchWorkspacesResponse,
  SearchWorkspacesError,
  Creds | Region | HttpClient.HttpClient
> & {
  pages: (
    input: SearchWorkspacesRequest,
  ) => stream.Stream<
    SearchWorkspacesResponse,
    SearchWorkspacesError,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchWorkspacesRequest,
  ) => stream.Stream<
    WorkspaceSearchSummary,
    SearchWorkspacesError,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchWorkspacesRequest,
  output: SearchWorkspacesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Workspaces",
    pageSize: "MaxResults",
  } as const,
}));
export type SendChatIntegrationEventError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Processes chat integration events from Amazon Web Services or external integrations to Amazon Connect. A chat
 * integration event includes:
 *
 * - SourceId, DestinationId, and Subtype: a set of identifiers, uniquely representing a chat
 *
 * - ChatEvent: details of the chat action to perform such as sending a message, event, or disconnecting from a
 * chat
 *
 * When a chat integration event is sent with chat identifiers that do not map to an active chat contact, a new
 * chat contact is also created before handling chat action.
 *
 * Access to this API is currently restricted to Amazon Web Services End User Messaging for supporting SMS
 * integration.
 */
export const sendChatIntegrationEvent: API.OperationMethod<
  SendChatIntegrationEventRequest,
  SendChatIntegrationEventResponse,
  SendChatIntegrationEventError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SendChatIntegrationEventRequest,
  output: SendChatIntegrationEventResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type SendOutboundEmailError =
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Send outbound email for outbound campaigns. For more information about outbound campaigns, see Set up Amazon Connect
 * outbound campaigns.
 *
 * Only the Amazon Connect outbound campaigns service principal is allowed to assume a role in your account
 * and call this API.
 */
export const sendOutboundEmail: API.OperationMethod<
  SendOutboundEmailRequest,
  SendOutboundEmailResponse,
  SendOutboundEmailError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SendOutboundEmailRequest,
  output: SendOutboundEmailResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type StartAttachedFileUploadError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceConflictException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Provides a pre-signed Amazon S3 URL in response for uploading your content.
 *
 * You may only use this API to upload attachments to an Amazon Connect Case or Amazon Connect Email.
 */
export const startAttachedFileUpload: API.OperationMethod<
  StartAttachedFileUploadRequest,
  StartAttachedFileUploadResponse,
  StartAttachedFileUploadError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartAttachedFileUploadRequest,
  output: StartAttachedFileUploadResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceConflictException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type StartChatContactError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | CommonErrors;
/**
 * Initiates a flow to start a new chat for the customer. Response of this API provides a token required to obtain
 * credentials from the CreateParticipantConnection API in the Amazon Connect Participant Service.
 *
 * When a new chat contact is successfully created, clients must subscribe to the participants connection for the
 * created chat within 5 minutes. This is achieved by invoking CreateParticipantConnection with WEBSOCKET and CONNECTION_CREDENTIALS.
 *
 * A 429 error occurs in the following situations:
 *
 * - API rate limit is exceeded. API TPS throttling returns a `TooManyRequests` exception.
 *
 * - The quota for
 * concurrent active chats is exceeded. Active chat throttling returns a
 * `LimitExceededException`.
 *
 * If you use the `ChatDurationInMinutes` parameter and receive a 400 error, your account may not
 * support the ability to configure custom chat durations. For more information, contact Amazon Web Services Support.
 *
 * For more information about chat, see the following topics in the Amazon Connect
 * Administrator Guide:
 *
 * - Concepts: Web and mobile messaging capabilities in Amazon Connect
 *
 * - Amazon Connect Chat security best practices
 */
export const startChatContact: API.OperationMethod<
  StartChatContactRequest,
  StartChatContactResponse,
  StartChatContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartChatContactRequest,
  output: StartChatContactResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
  ],
}));
export type StartContactEvaluationError =
  | InternalServiceException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Starts an empty evaluation in the specified Amazon Connect instance, using the given evaluation form for the
 * particular contact. The evaluation form version used for the contact evaluation corresponds to the currently
 * activated version. If no version is activated for the evaluation form, the contact evaluation cannot be started.
 *
 * Evaluations created through the public API do not contain answer values suggested from automation.
 */
export const startContactEvaluation: API.OperationMethod<
  StartContactEvaluationRequest,
  StartContactEvaluationResponse,
  StartContactEvaluationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartContactEvaluationRequest,
  output: StartContactEvaluationResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type StartContactMediaProcessingError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | CommonErrors;
/**
 * Enables in-flight message processing for an ongoing chat session. Message processing will stay active for the
 * rest of the chat, even if an individual contact segment ends.
 */
export const startContactMediaProcessing: API.OperationMethod<
  StartContactMediaProcessingRequest,
  StartContactMediaProcessingResponse,
  StartContactMediaProcessingError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartContactMediaProcessingRequest,
  output: StartContactMediaProcessingResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
  ],
}));
export type StartContactRecordingError =
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors;
/**
 * Starts recording the contact:
 *
 * - If the API is called *before* the agent joins the call, recording starts when the agent
 * joins the call.
 *
 * - If the API is called *after* the agent joins the call, recording starts at the time of the
 * API call.
 *
 * StartContactRecording is a one-time action. For example, if you use StopContactRecording to stop recording an
 * ongoing call, you can't use StartContactRecording to restart it. For scenarios where the recording has started and
 * you want to suspend and resume it, such as when collecting sensitive information (for example, a credit card number),
 * use SuspendContactRecording and ResumeContactRecording.
 *
 * You can use this API to override the recording behavior configured in the Set recording behavior block.
 *
 * Only voice recordings are supported at this time.
 */
export const startContactRecording: API.OperationMethod<
  StartContactRecordingRequest,
  StartContactRecordingResponse,
  StartContactRecordingError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartContactRecordingRequest,
  output: StartContactRecordingResponse,
  errors: [
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
export type StartContactStreamingError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | CommonErrors;
/**
 * Initiates real-time message streaming for a new chat contact.
 *
 * For more information about message streaming, see Enable real-time chat message streaming in the
 * *Amazon Connect Administrator Guide*.
 *
 * For more information about chat, see the following topics in the Amazon Connect
 * Administrator Guide:
 *
 * - Concepts: Web and mobile messaging capabilities in Amazon Connect
 *
 * - Amazon Connect Chat security best practices
 */
export const startContactStreaming: API.OperationMethod<
  StartContactStreamingRequest,
  StartContactStreamingResponse,
  StartContactStreamingError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartContactStreamingRequest,
  output: StartContactStreamingResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
  ],
}));
export type StartEmailContactError =
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Creates an inbound email contact and initiates a flow to start the email contact for the customer. Response of
 * this API provides the ContactId of the email contact created.
 */
export const startEmailContact: API.OperationMethod<
  StartEmailContactRequest,
  StartEmailContactResponse,
  StartEmailContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartEmailContactRequest,
  output: StartEmailContactResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type StartOutboundChatContactError =
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Initiates a new outbound SMS or WhatsApp contact to a customer. Response of this API provides the
 * `ContactId` of the outbound SMS or WhatsApp contact created.
 *
 * **SourceEndpoint** only supports Endpoints with
 * `CONNECT_PHONENUMBER_ARN` as Type and **DestinationEndpoint** only supports
 * Endpoints with `TELEPHONE_NUMBER` as Type. **ContactFlowId** initiates the
 * flow to manage the new contact created.
 *
 * This API can be used to initiate outbound SMS or WhatsApp contacts for an agent, or it can also deflect
 * an ongoing contact to an outbound SMS or WhatsApp contact by using the StartOutboundChatContact Flow
 * Action.
 *
 * For more information about using SMS or WhatsApp in Amazon Connect, see the following topics in
 * the *Amazon Connect Administrator Guide*:
 *
 * - Set up SMS
 * messaging
 *
 * - Request an SMS-enabled phone
 * number through Amazon Web Services End User Messaging SMS
 *
 * - Set up WhatsApp
 * Business messaging
 */
export const startOutboundChatContact: API.OperationMethod<
  StartOutboundChatContactRequest,
  StartOutboundChatContactResponse,
  StartOutboundChatContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartOutboundChatContactRequest,
  output: StartOutboundChatContactResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type StartOutboundEmailContactError =
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Initiates a flow to send an agent reply or outbound email contact (created from the CreateContact API) to a
 * customer.
 */
export const startOutboundEmailContact: API.OperationMethod<
  StartOutboundEmailContactRequest,
  StartOutboundEmailContactResponse,
  StartOutboundEmailContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartOutboundEmailContactRequest,
  output: StartOutboundEmailContactResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type StartOutboundVoiceContactError =
  | DestinationNotAllowedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | OutboundContactNotPermittedException
  | ResourceNotFoundException
  | CommonErrors;
/**
 * Places an outbound call to a contact, and then initiates the flow. It performs the actions in the flow that's
 * specified (in `ContactFlowId`).
 *
 * Agents do not initiate the outbound API, which means that they do not dial the contact. If the flow places an
 * outbound call to a contact, and then puts the contact in queue, the call is then routed to the agent, like any other
 * inbound case.
 *
 * Dialing timeout for this operation can be configured with the RingTimeoutInSeconds parameter. If not
 * specified, the default dialing timeout will be 60 seconds which means if the call is not connected within 60 seconds,
 * it fails.
 *
 * UK numbers with a 447 prefix are not allowed by default. Before you can dial these UK mobile numbers, you must
 * submit a service quota increase request. For more information, see Amazon Connect Service Quotas in the
 * *Amazon Connect Administrator Guide*.
 *
 * Campaign calls are not allowed by default. Before you can make a call with `TrafficType` =
 * `CAMPAIGN`, you must submit a service quota increase request to the quota Amazon Connect campaigns.
 *
 * For Preview dialing mode, only the Amazon Connect outbound campaigns service principal is allowed to assume a
 * role in your account and call this API with OutboundStrategy.
 */
export const startOutboundVoiceContact: API.OperationMethod<
  StartOutboundVoiceContactRequest,
  StartOutboundVoiceContactResponse,
  StartOutboundVoiceContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartOutboundVoiceContactRequest,
  output: StartOutboundVoiceContactResponse,
  errors: [
    DestinationNotAllowedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    OutboundContactNotPermittedException,
    ResourceNotFoundException,
  ],
}));
export type StartScreenSharingError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Starts screen sharing for a contact. For more information about screen sharing, see Set up in-app, web, video calling, and screen sharing
 * capabilities in the *Amazon Connect Administrator Guide*.
 */
export const startScreenSharing: API.OperationMethod<
  StartScreenSharingRequest,
  StartScreenSharingResponse,
  StartScreenSharingError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartScreenSharingRequest,
  output: StartScreenSharingResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type StartTaskContactError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Initiates a flow to start a new task contact. For more information about task contacts, see Concepts: Tasks in Amazon Connect in the
 * *Amazon Connect Administrator Guide*.
 *
 * When using `PreviousContactId` and `RelatedContactId` input parameters, note the
 * following:
 *
 * - `PreviousContactId`
 *
 * - Any updates to user-defined task contact attributes on any contact linked through the same
 * `PreviousContactId` will affect every contact in the chain.
 *
 * - There can be a maximum of 12 linked task contacts in a chain. That is, 12 task contacts can be created that
 * share the same `PreviousContactId`.
 *
 * - `RelatedContactId`
 *
 * - Copies contact attributes from the related task contact to the new contact.
 *
 * - Any update on attributes in a new task contact does not update attributes on previous contact.
 *
 * - Theres no limit on the number of task contacts that can be created that use the same
 * `RelatedContactId`.
 *
 * In addition, when calling StartTaskContact include only one of these parameters: `ContactFlowID`,
 * `QuickConnectID`, or `TaskTemplateID`. Only one parameter is required as long as the task
 * template has a flow configured to run it. If more than one parameter is specified, or only the
 * `TaskTemplateID` is specified but it does not have a flow configured, the request returns an error
 * because Amazon Connect cannot identify the unique flow to run when the task is created.
 *
 * A `ServiceQuotaExceededException` occurs when the number of open tasks exceeds the active tasks quota
 * or there are already 12 tasks referencing the same `PreviousContactId`. For more information about service
 * quotas for task contacts, see Amazon Connect service quotas in the
 * *Amazon Connect Administrator Guide*.
 */
export const startTaskContact: API.OperationMethod<
  StartTaskContactRequest,
  StartTaskContactResponse,
  StartTaskContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartTaskContactRequest,
  output: StartTaskContactResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type StartTestCaseExecutionError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Starts executing a published test case.
 */
export const startTestCaseExecution: API.OperationMethod<
  StartTestCaseExecutionRequest,
  StartTestCaseExecutionResponse,
  StartTestCaseExecutionError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartTestCaseExecutionRequest,
  output: StartTestCaseExecutionResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type StartWebRTCContactError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | CommonErrors;
/**
 * Places an inbound in-app, web, or video call to a contact, and then initiates the flow. It performs the actions
 * in the flow that are specified (in ContactFlowId) and present in the Amazon Connect instance (specified as
 * InstanceId).
 */
export const startWebRTCContact: API.OperationMethod<
  StartWebRTCContactRequest,
  StartWebRTCContactResponse,
  StartWebRTCContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartWebRTCContactRequest,
  output: StartWebRTCContactResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
  ],
}));
export type StopContactError =
  | ContactNotFoundException
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors;
/**
 * Ends the specified contact. Use this API to stop queued callbacks. It does not work for voice contacts that use
 * the following initiation methods:
 *
 * - DISCONNECT
 *
 * - TRANSFER
 *
 * - QUEUE_TRANSFER
 *
 * - EXTERNAL_OUTBOUND
 *
 * - MONITOR
 *
 * Chat and task contacts can be terminated in any state, regardless of initiation method.
 */
export const stopContact: API.OperationMethod<
  StopContactRequest,
  StopContactResponse,
  StopContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopContactRequest,
  output: StopContactResponse,
  errors: [
    ContactNotFoundException,
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
export type StopContactMediaProcessingError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | CommonErrors;
/**
 * Stops in-flight message processing for an ongoing chat session.
 */
export const stopContactMediaProcessing: API.OperationMethod<
  StopContactMediaProcessingRequest,
  StopContactMediaProcessingResponse,
  StopContactMediaProcessingError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopContactMediaProcessingRequest,
  output: StopContactMediaProcessingResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
  ],
}));
export type StopContactRecordingError =
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors;
/**
 * Stops recording a call when a contact is being recorded. StopContactRecording is a one-time action. If you use
 * StopContactRecording to stop recording an ongoing call, you can't use StartContactRecording to restart it. For
 * scenarios where the recording has started and you want to suspend it for sensitive information (for example, to
 * collect a credit card number), and then restart it, use SuspendContactRecording and ResumeContactRecording.
 *
 * Only voice recordings are supported at this time.
 */
export const stopContactRecording: API.OperationMethod<
  StopContactRecordingRequest,
  StopContactRecordingResponse,
  StopContactRecordingError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopContactRecordingRequest,
  output: StopContactRecordingResponse,
  errors: [
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
export type StopContactStreamingError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors;
/**
 * Ends message streaming on a specified contact. To restart message streaming on that contact, call the StartContactStreaming
 * API.
 */
export const stopContactStreaming: API.OperationMethod<
  StopContactStreamingRequest,
  StopContactStreamingResponse,
  StopContactStreamingError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopContactStreamingRequest,
  output: StopContactStreamingResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
export type StopTestCaseExecutionError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Stops a running test execution.
 */
export const stopTestCaseExecution: API.OperationMethod<
  StopTestCaseExecutionRequest,
  StopTestCaseExecutionResponse,
  StopTestCaseExecutionError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopTestCaseExecutionRequest,
  output: StopTestCaseExecutionResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type SubmitContactEvaluationError =
  | InternalServiceException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Submits a contact evaluation in the specified Amazon Connect instance. Answers included in the request are
 * merged with existing answers for the given evaluation. If no answers or notes are passed, the evaluation is submitted
 * with the existing answers and notes. You can delete an answer or note by passing an empty object (`{}`) to
 * the question identifier.
 *
 * If a contact evaluation is already in submitted state, this operation will trigger a resubmission.
 */
export const submitContactEvaluation: API.OperationMethod<
  SubmitContactEvaluationRequest,
  SubmitContactEvaluationResponse,
  SubmitContactEvaluationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SubmitContactEvaluationRequest,
  output: SubmitContactEvaluationResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type SuspendContactRecordingError =
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors;
/**
 * When a contact is being recorded, this API suspends recording whatever is selected in the flow configuration:
 * call (IVR or agent), screen, or both. If only call recording or only screen recording is enabled, then it would be
 * suspended. For example, you might suspend the screen recording while collecting sensitive information, such as a
 * credit card number. Then use ResumeContactRecording to restart
 * recording the screen.
 *
 * The period of time that the recording is suspended is filled with silence in the final recording.
 *
 * Voice (IVR, agent) and screen recordings are supported.
 */
export const suspendContactRecording: API.OperationMethod<
  SuspendContactRecordingRequest,
  SuspendContactRecordingResponse,
  SuspendContactRecordingError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SuspendContactRecordingRequest,
  output: SuspendContactRecordingResponse,
  errors: [
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
export type TagContactError =
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Adds the specified tags to the contact resource. For more information about this API is used, see Set up granular billing for a detailed
 * view of your Amazon Connect usage.
 */
export const tagContact: API.OperationMethod<
  TagContactRequest,
  TagContactResponse,
  TagContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: TagContactRequest,
  output: TagContactResponse,
  errors: [
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type TagResourceError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Adds the specified tags to the specified resource.
 *
 * Some of the supported resource types are agents, routing profiles, queues, quick connects, flows, agent
 * statuses, hours of operation, phone numbers, security profiles, and task templates. For a complete list, see Tagging resources in Amazon Connect.
 *
 * For sample policies that use tags, see Amazon Connect Identity-Based Policy
 * Examples in the *Amazon Connect Administrator Guide*.
 */
export const tagResource: API.OperationMethod<
  TagResourceRequest,
  TagResourceResponse,
  TagResourceError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: TagResourceRequest,
  output: TagResourceResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type TransferContactError =
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Transfers `TASK` or `EMAIL`
 * contacts from one agent or queue to another agent or queue at any point after a contact is
 * created. You can transfer a contact to another queue by providing the flow which orchestrates the contact to the
 * destination queue. This gives you more control over contact handling and helps you adhere to the service level
 * agreement (SLA) guaranteed to your customers.
 *
 * Note the following requirements:
 *
 * - Transfer is only supported for `TASK` and `EMAIL` contacts.
 *
 * - Do not use both `QueueId` and `UserId` in the same call.
 *
 * - The following flow types are supported: Inbound flow, Transfer to agent flow, and Transfer to queue
 * flow.
 *
 * - The `TransferContact` API can be called only on active contacts.
 *
 * - A contact cannot be transferred more than 11 times.
 */
export const transferContact: API.OperationMethod<
  TransferContactRequest,
  TransferContactResponse,
  TransferContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: TransferContactRequest,
  output: TransferContactResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type UntagContactError =
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Removes the specified tags from the contact resource. For more information about this API is used, see Set up granular billing for a detailed
 * view of your Amazon Connect usage.
 */
export const untagContact: API.OperationMethod<
  UntagContactRequest,
  UntagContactResponse,
  UntagContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UntagContactRequest,
  output: UntagContactResponse,
  errors: [
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UntagResourceError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Removes the specified tags from the specified resource.
 */
export const untagResource: API.OperationMethod<
  UntagResourceRequest,
  UntagResourceResponse,
  UntagResourceError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UntagResourceRequest,
  output: UntagResourceResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateAgentStatusError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates agent status.
 */
export const updateAgentStatus: API.OperationMethod<
  UpdateAgentStatusRequest,
  UpdateAgentStatusResponse,
  UpdateAgentStatusError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateAgentStatusRequest,
  output: UpdateAgentStatusResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateAuthenticationProfileError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change. To
 * request access to this API, contact Amazon Web Services Support.
 *
 * Updates the selected authentication profile.
 */
export const updateAuthenticationProfile: API.OperationMethod<
  UpdateAuthenticationProfileRequest,
  UpdateAuthenticationProfileResponse,
  UpdateAuthenticationProfileError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateAuthenticationProfileRequest,
  output: UpdateAuthenticationProfileResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateContactError =
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Adds or updates user-defined contact information associated with the specified contact. At least one field to be
 * updated must be present in the request.
 *
 * You can add or update user-defined contact information for both ongoing and completed contacts.
 */
export const updateContact: API.OperationMethod<
  UpdateContactRequest,
  UpdateContactResponse,
  UpdateContactError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactRequest,
  output: UpdateContactResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateContactAttributesError =
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors;
/**
 * Creates or updates user-defined contact
 * attributes associated with the specified contact.
 *
 * You can create or update user-defined attributes for both ongoing and completed contacts. For example, while the
 * call is active, you can update the customer's name or the reason the customer called. You can add notes about steps
 * that the agent took during the call that display to the next agent that takes the call. You can also update
 * attributes for a contact using data from your CRM application and save the data with the contact in Amazon Connect. You could also flag calls for additional analysis, such as legal review or to identify abusive callers.
 *
 * Contact attributes are available in Amazon Connect for 24 months, and are then deleted. For information
 * about contact record retention and the maximum size of the contact record attributes section, see Feature
 * specifications in the *Amazon Connect Administrator Guide*.
 */
export const updateContactAttributes: API.OperationMethod<
  UpdateContactAttributesRequest,
  UpdateContactAttributesResponse,
  UpdateContactAttributesError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactAttributesRequest,
  output: UpdateContactAttributesResponse,
  errors: [
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
export type UpdateContactEvaluationError =
  | InternalServiceException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates details about a contact evaluation in the specified Amazon Connect instance. A contact evaluation
 * must be in draft state. Answers included in the request are merged with existing answers for the given evaluation. An
 * answer or note can be deleted by passing an empty object (`{}`) to the question identifier.
 */
export const updateContactEvaluation: API.OperationMethod<
  UpdateContactEvaluationRequest,
  UpdateContactEvaluationResponse,
  UpdateContactEvaluationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactEvaluationRequest,
  output: UpdateContactEvaluationResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateContactFlowContentError =
  | InternalServiceException
  | InvalidContactFlowException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the specified flow.
 *
 * You can also create and update flows using the Amazon Connect
 * Flow language.
 *
 * Use the `$SAVED` alias in the request to describe the `SAVED` content of a Flow. For
 * example, `arn:aws:.../contact-flow/{id}:$SAVED`. After a flow is published, `$SAVED` needs to
 * be supplied to view saved content that has not been published.
 */
export const updateContactFlowContent: API.OperationMethod<
  UpdateContactFlowContentRequest,
  UpdateContactFlowContentResponse,
  UpdateContactFlowContentError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactFlowContentRequest,
  output: UpdateContactFlowContentResponse,
  errors: [
    InternalServiceException,
    InvalidContactFlowException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateContactFlowMetadataError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates metadata about specified flow.
 */
export const updateContactFlowMetadata: API.OperationMethod<
  UpdateContactFlowMetadataRequest,
  UpdateContactFlowMetadataResponse,
  UpdateContactFlowMetadataError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactFlowMetadataRequest,
  output: UpdateContactFlowMetadataResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateContactFlowModuleAliasError =
  | AccessDeniedException
  | ConditionalOperationFailedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates a specific Aliases metadata, including the version its tied to, its name, and description.
 */
export const updateContactFlowModuleAlias: API.OperationMethod<
  UpdateContactFlowModuleAliasRequest,
  UpdateContactFlowModuleAliasResponse,
  UpdateContactFlowModuleAliasError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactFlowModuleAliasRequest,
  output: UpdateContactFlowModuleAliasResponse,
  errors: [
    AccessDeniedException,
    ConditionalOperationFailedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateContactFlowModuleContentError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidContactFlowModuleException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates specified flow module for the specified Amazon Connect instance.
 *
 * Use the `$SAVED` alias in the request to describe the `SAVED` content of a Flow. For
 * example, `arn:aws:.../contact-flow/{id}:$SAVED`. After a flow is published, `$SAVED` needs to
 * be supplied to view saved content that has not been published.
 */
export const updateContactFlowModuleContent: API.OperationMethod<
  UpdateContactFlowModuleContentRequest,
  UpdateContactFlowModuleContentResponse,
  UpdateContactFlowModuleContentError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactFlowModuleContentRequest,
  output: UpdateContactFlowModuleContentResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidContactFlowModuleException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateContactFlowModuleMetadataError =
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates metadata about specified flow module.
 */
export const updateContactFlowModuleMetadata: API.OperationMethod<
  UpdateContactFlowModuleMetadataRequest,
  UpdateContactFlowModuleMetadataResponse,
  UpdateContactFlowModuleMetadataError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactFlowModuleMetadataRequest,
  output: UpdateContactFlowModuleMetadataResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateContactFlowNameError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * The name of the flow.
 *
 * You can also create and update flows using the Amazon Connect
 * Flow language.
 */
export const updateContactFlowName: API.OperationMethod<
  UpdateContactFlowNameRequest,
  UpdateContactFlowNameResponse,
  UpdateContactFlowNameError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactFlowNameRequest,
  output: UpdateContactFlowNameResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateContactRoutingDataError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates routing priority and age on the contact (**QueuePriority** and **QueueTimeAdjustmentInSeconds**). These properties can be used to change a customer's position
 * in the queue. For example, you can move a contact to the back of the queue by setting a lower routing priority
 * relative to other contacts in queue; or you can move a contact to the front of the queue by increasing the routing
 * age which will make the contact look artificially older and therefore higher up in the first-in-first-out routing
 * order. Note that adjusting the routing age of a contact affects only its position in queue, and not its actual queue
 * wait time as reported through metrics. These properties can also be updated by using the Set routing priority / age flow
 * block.
 *
 * Either **QueuePriority** or **QueueTimeAdjustmentInSeconds** should be provided within the request body, but not both.
 */
export const updateContactRoutingData: API.OperationMethod<
  UpdateContactRoutingDataRequest,
  UpdateContactRoutingDataResponse,
  UpdateContactRoutingDataError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactRoutingDataRequest,
  output: UpdateContactRoutingDataResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateContactScheduleError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the scheduled time of a task contact that is already scheduled.
 */
export const updateContactSchedule: API.OperationMethod<
  UpdateContactScheduleRequest,
  UpdateContactScheduleResponse,
  UpdateContactScheduleError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactScheduleRequest,
  output: UpdateContactScheduleResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateDataTableAttributeError =
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates all properties for an attribute using all properties from CreateDataTableAttribute. There are no other
 * granular update endpoints. It does not act as a patch operation - all properties must be provided. System managed
 * attributes are not mutable by customers. Changing an attribute's validation does not invalidate existing values since
 * validation only runs when values are created or updated.
 */
export const updateDataTableAttribute: API.OperationMethod<
  UpdateDataTableAttributeRequest,
  UpdateDataTableAttributeResponse,
  UpdateDataTableAttributeError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDataTableAttributeRequest,
  output: UpdateDataTableAttributeResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type UpdateDataTableMetadataError =
  | AccessDeniedException
  | ConflictException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the metadata properties of a data table. Accepts all fields similar to CreateDataTable, except for
 * fields and tags. There are no other granular update endpoints. It does not act as a patch operation - all properties
 * must be provided or defaults will be used. Fields follow the same requirements as CreateDataTable.
 */
export const updateDataTableMetadata: API.OperationMethod<
  UpdateDataTableMetadataRequest,
  UpdateDataTableMetadataResponse,
  UpdateDataTableMetadataError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDataTableMetadataRequest,
  output: UpdateDataTableMetadataResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateDataTablePrimaryValuesError =
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the primary values for a record. This operation affects all existing values that are currently
 * associated to the record and its primary values. Users that have restrictions on attributes and/or primary values are
 * not authorized to use this endpoint. The combination of new primary values must be unique within the table.
 */
export const updateDataTablePrimaryValues: API.OperationMethod<
  UpdateDataTablePrimaryValuesRequest,
  UpdateDataTablePrimaryValuesResponse,
  UpdateDataTablePrimaryValuesError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDataTablePrimaryValuesRequest,
  output: UpdateDataTablePrimaryValuesResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateEmailAddressMetadataError =
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates an email address metadata. For more information about email addresses, see Create email addresses in the Amazon Connect
 * Administrator Guide.
 */
export const updateEmailAddressMetadata: API.OperationMethod<
  UpdateEmailAddressMetadataRequest,
  UpdateEmailAddressMetadataResponse,
  UpdateEmailAddressMetadataError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateEmailAddressMetadataRequest,
  output: UpdateEmailAddressMetadataResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateEvaluationFormError =
  | InternalServiceException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates details about a specific evaluation form version in the specified Amazon Connect instance. Question
 * and section identifiers cannot be duplicated within the same evaluation form.
 *
 * This operation does not support partial updates. Instead it does a full update of evaluation form
 * content.
 */
export const updateEvaluationForm: API.OperationMethod<
  UpdateEvaluationFormRequest,
  UpdateEvaluationFormResponse,
  UpdateEvaluationFormError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateEvaluationFormRequest,
  output: UpdateEvaluationFormResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type UpdateHoursOfOperationError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the hours of operation.
 */
export const updateHoursOfOperation: API.OperationMethod<
  UpdateHoursOfOperationRequest,
  UpdateHoursOfOperationResponse,
  UpdateHoursOfOperationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateHoursOfOperationRequest,
  output: UpdateHoursOfOperationResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateHoursOfOperationOverrideError =
  | ConditionalOperationFailedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Update the hours of operation override.
 */
export const updateHoursOfOperationOverride: API.OperationMethod<
  UpdateHoursOfOperationOverrideRequest,
  UpdateHoursOfOperationOverrideResponse,
  UpdateHoursOfOperationOverrideError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateHoursOfOperationOverrideRequest,
  output: UpdateHoursOfOperationOverrideResponse,
  errors: [
    ConditionalOperationFailedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateInstanceAttributeError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Updates the value for the specified attribute type.
 */
export const updateInstanceAttribute: API.OperationMethod<
  UpdateInstanceAttributeRequest,
  UpdateInstanceAttributeResponse,
  UpdateInstanceAttributeError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateInstanceAttributeRequest,
  output: UpdateInstanceAttributeResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateInstanceStorageConfigError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Updates an existing configuration for a resource type. This API is idempotent.
 */
export const updateInstanceStorageConfig: API.OperationMethod<
  UpdateInstanceStorageConfigRequest,
  UpdateInstanceStorageConfigResponse,
  UpdateInstanceStorageConfigError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateInstanceStorageConfigRequest,
  output: UpdateInstanceStorageConfigResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateNotificationContentError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the localized content of an existing notification. This operation applies to all users for whom the notification was sent.
 */
export const updateNotificationContent: API.OperationMethod<
  UpdateNotificationContentRequest,
  UpdateNotificationContentResponse,
  UpdateNotificationContentError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateNotificationContentRequest,
  output: UpdateNotificationContentResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateParticipantAuthenticationError =
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ThrottlingException
  | CommonErrors;
/**
 * Instructs Amazon Connect to resume the authentication process. The subsequent actions depend on the request
 * body contents:
 *
 * - **If a code is provided**: Connect retrieves the identity information from Amazon
 * Cognito and imports it into Connect Customer Profiles.
 *
 * - **If an error is provided**: The error branch of the Authenticate Customer block
 * is executed.
 *
 * The API returns a success response to acknowledge the request. However, the interaction and exchange of
 * identity information occur asynchronously after the response is returned.
 */
export const updateParticipantAuthentication: API.OperationMethod<
  UpdateParticipantAuthenticationRequest,
  UpdateParticipantAuthenticationResponse,
  UpdateParticipantAuthenticationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateParticipantAuthenticationRequest,
  output: UpdateParticipantAuthenticationResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ThrottlingException,
  ],
}));
export type UpdateParticipantRoleConfigError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates timeouts for when human chat participants are to be considered idle, and when agents are automatically
 * disconnected from a chat due to idleness. You can set four timers:
 *
 * - Customer idle timeout
 *
 * - Customer auto-disconnect timeout
 *
 * - Agent idle timeout
 *
 * - Agent auto-disconnect timeout
 *
 * For more information about how chat timeouts work, see
 * Set up chat timeouts for human participants.
 */
export const updateParticipantRoleConfig: API.OperationMethod<
  UpdateParticipantRoleConfigRequest,
  UpdateParticipantRoleConfigResponse,
  UpdateParticipantRoleConfigError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateParticipantRoleConfigRequest,
  output: UpdateParticipantRoleConfigResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdatePhoneNumberError =
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates your claimed phone number from its current Amazon Connect instance or traffic distribution group to another Amazon Connect instance or traffic distribution group in the same Amazon Web Services Region.
 *
 * After using this API, you must verify that the phone number is attached to the correct flow in the target
 * instance or traffic distribution group. You need to do this because the API switches only the phone number to a new
 * instance or traffic distribution group. It doesn't migrate the flow configuration of the phone number, too.
 *
 * You can call DescribePhoneNumber API to verify the status of a previous UpdatePhoneNumber operation.
 */
export const updatePhoneNumber: API.OperationMethod<
  UpdatePhoneNumberRequest,
  UpdatePhoneNumberResponse,
  UpdatePhoneNumberError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdatePhoneNumberRequest,
  output: UpdatePhoneNumberResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdatePhoneNumberMetadataError =
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates a phone numbers metadata.
 *
 * To verify the status of a previous UpdatePhoneNumberMetadata operation, call the DescribePhoneNumber API.
 */
export const updatePhoneNumberMetadata: API.OperationMethod<
  UpdatePhoneNumberMetadataRequest,
  UpdatePhoneNumberMetadataResponse,
  UpdatePhoneNumberMetadataError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdatePhoneNumberMetadataRequest,
  output: UpdatePhoneNumberMetadataResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdatePredefinedAttributeError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates a predefined attribute for the specified Amazon Connect instance. A *predefined attribute* is
 * made up of a name and a value.
 *
 * For the predefined attributes per instance quota, see Amazon Connect
 * quotas.
 *
 * **Use cases**
 *
 * Following are common uses cases for this API:
 *
 * - Update routing proficiency (for example, agent certification) that has predefined values (for example, a list
 * of possible certifications). For more information, see Create predefined attributes for routing contacts to
 * agents.
 *
 * - Update an attribute for business unit name that has a list of predefined business unit names used in your
 * organization. This is a use case where information for a contact varies between transfers or conferences. For more
 * information, see Use contact segment attributes.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const updatePredefinedAttribute: API.OperationMethod<
  UpdatePredefinedAttributeRequest,
  UpdatePredefinedAttributeResponse,
  UpdatePredefinedAttributeError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdatePredefinedAttributeRequest,
  output: UpdatePredefinedAttributeResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdatePromptError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates a prompt.
 */
export const updatePrompt: API.OperationMethod<
  UpdatePromptRequest,
  UpdatePromptResponse,
  UpdatePromptError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdatePromptRequest,
  output: UpdatePromptResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateQueueHoursOfOperationError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the hours of operation for the specified queue.
 */
export const updateQueueHoursOfOperation: API.OperationMethod<
  UpdateQueueHoursOfOperationRequest,
  UpdateQueueHoursOfOperationResponse,
  UpdateQueueHoursOfOperationError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateQueueHoursOfOperationRequest,
  output: UpdateQueueHoursOfOperationResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateQueueMaxContactsError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the maximum number of contacts allowed in a queue before it is considered full.
 */
export const updateQueueMaxContacts: API.OperationMethod<
  UpdateQueueMaxContactsRequest,
  UpdateQueueMaxContactsResponse,
  UpdateQueueMaxContactsError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateQueueMaxContactsRequest,
  output: UpdateQueueMaxContactsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateQueueNameError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the name and description of a queue. At least `Name` or `Description` must be provided.
 */
export const updateQueueName: API.OperationMethod<
  UpdateQueueNameRequest,
  UpdateQueueNameResponse,
  UpdateQueueNameError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateQueueNameRequest,
  output: UpdateQueueNameResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateQueueOutboundCallerConfigError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the outbound caller ID name, number, and outbound whisper flow for a specified queue.
 *
 * - If the phone number is claimed to a traffic distribution group that was created in the
 * same Region as the Amazon Connect instance where you are calling this API, then you can use a
 * full phone number ARN or a UUID for `OutboundCallerIdNumberId`. However, if the phone number is claimed
 * to a traffic distribution group that is in one Region, and you are calling this API from an instance in another Amazon Web Services Region that is associated with the traffic distribution group, you must provide a full phone number ARN. If a
 * UUID is provided in this scenario, you will receive a
 * `ResourceNotFoundException`.
 *
 * - Only use the phone number ARN format that doesn't contain `instance` in the path, for example,
 * `arn:aws:connect:us-east-1:1234567890:phone-number/uuid`. This is the same ARN format that is returned
 * when you call the ListPhoneNumbersV2 API.
 *
 * - If you plan to use IAM policies to allow/deny access to this API for phone number resources
 * claimed to a traffic distribution group, see Allow or Deny queue API actions for phone numbers in a replica Region.
 */
export const updateQueueOutboundCallerConfig: API.OperationMethod<
  UpdateQueueOutboundCallerConfigRequest,
  UpdateQueueOutboundCallerConfigResponse,
  UpdateQueueOutboundCallerConfigError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateQueueOutboundCallerConfigRequest,
  output: UpdateQueueOutboundCallerConfigResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateQueueOutboundEmailConfigError =
  | AccessDeniedException
  | ConditionalOperationFailedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the outbound email address Id for a specified queue.
 */
export const updateQueueOutboundEmailConfig: API.OperationMethod<
  UpdateQueueOutboundEmailConfigRequest,
  UpdateQueueOutboundEmailConfigResponse,
  UpdateQueueOutboundEmailConfigError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateQueueOutboundEmailConfigRequest,
  output: UpdateQueueOutboundEmailConfigResponse,
  errors: [
    AccessDeniedException,
    ConditionalOperationFailedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateQueueStatusError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the status of the queue.
 */
export const updateQueueStatus: API.OperationMethod<
  UpdateQueueStatusRequest,
  UpdateQueueStatusResponse,
  UpdateQueueStatusError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateQueueStatusRequest,
  output: UpdateQueueStatusResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateQuickConnectConfigError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the configuration settings for the specified quick connect.
 */
export const updateQuickConnectConfig: API.OperationMethod<
  UpdateQuickConnectConfigRequest,
  UpdateQuickConnectConfigResponse,
  UpdateQuickConnectConfigError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateQuickConnectConfigRequest,
  output: UpdateQuickConnectConfigResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateQuickConnectNameError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the name and description of a quick connect. The request accepts the following data in JSON format. At least `Name` or `Description` must be provided.
 */
export const updateQuickConnectName: API.OperationMethod<
  UpdateQuickConnectNameRequest,
  UpdateQuickConnectNameResponse,
  UpdateQuickConnectNameError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateQuickConnectNameRequest,
  output: UpdateQuickConnectNameResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateRoutingProfileAgentAvailabilityTimerError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Whether agents with this routing profile will have their routing order calculated based on time since
 * their last inbound contact or *longest idle time*.
 */
export const updateRoutingProfileAgentAvailabilityTimer: API.OperationMethod<
  UpdateRoutingProfileAgentAvailabilityTimerRequest,
  UpdateRoutingProfileAgentAvailabilityTimerResponse,
  UpdateRoutingProfileAgentAvailabilityTimerError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateRoutingProfileAgentAvailabilityTimerRequest,
  output: UpdateRoutingProfileAgentAvailabilityTimerResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateRoutingProfileConcurrencyError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the channels that agents can handle in the Contact Control Panel (CCP) for a routing profile.
 */
export const updateRoutingProfileConcurrency: API.OperationMethod<
  UpdateRoutingProfileConcurrencyRequest,
  UpdateRoutingProfileConcurrencyResponse,
  UpdateRoutingProfileConcurrencyError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateRoutingProfileConcurrencyRequest,
  output: UpdateRoutingProfileConcurrencyResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateRoutingProfileDefaultOutboundQueueError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the default outbound queue of a routing profile.
 */
export const updateRoutingProfileDefaultOutboundQueue: API.OperationMethod<
  UpdateRoutingProfileDefaultOutboundQueueRequest,
  UpdateRoutingProfileDefaultOutboundQueueResponse,
  UpdateRoutingProfileDefaultOutboundQueueError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateRoutingProfileDefaultOutboundQueueRequest,
  output: UpdateRoutingProfileDefaultOutboundQueueResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateRoutingProfileNameError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the name and description of a routing profile. The request accepts the following data in JSON format. At least `Name` or `Description` must be provided.
 */
export const updateRoutingProfileName: API.OperationMethod<
  UpdateRoutingProfileNameRequest,
  UpdateRoutingProfileNameResponse,
  UpdateRoutingProfileNameError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateRoutingProfileNameRequest,
  output: UpdateRoutingProfileNameResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateRoutingProfileQueuesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the properties associated with a set of queues for a routing profile.
 */
export const updateRoutingProfileQueues: API.OperationMethod<
  UpdateRoutingProfileQueuesRequest,
  UpdateRoutingProfileQueuesResponse,
  UpdateRoutingProfileQueuesError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateRoutingProfileQueuesRequest,
  output: UpdateRoutingProfileQueuesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateRuleError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates a rule for the specified Amazon Connect instance.
 *
 * Use the Rules Function
 * language to code conditions for the rule.
 */
export const updateRule: API.OperationMethod<
  UpdateRuleRequest,
  UpdateRuleResponse,
  UpdateRuleError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateRuleRequest,
  output: UpdateRuleResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateSecurityProfileError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates a security profile.
 *
 * For information about security profiles, see Security Profiles in the *Amazon Connect Administrator Guide*. For a mapping of the API name and user interface name of the security
 * profile permissions, see List
 * of security profile permissions.
 */
export const updateSecurityProfile: API.OperationMethod<
  UpdateSecurityProfileRequest,
  UpdateSecurityProfileResponse,
  UpdateSecurityProfileError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateSecurityProfileRequest,
  output: UpdateSecurityProfileResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateTaskTemplateError =
  | InternalServiceException
  | InvalidParameterException
  | PropertyValidationException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates details about a specific task template in the specified Amazon Connect instance. This operation does
 * not support partial updates. Instead it does a full update of template content.
 */
export const updateTaskTemplate: API.OperationMethod<
  UpdateTaskTemplateRequest,
  UpdateTaskTemplateResponse,
  UpdateTaskTemplateError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateTaskTemplateRequest,
  output: UpdateTaskTemplateResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    PropertyValidationException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
export type UpdateTestCaseError =
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | InvalidTestCaseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates any of the metadata for a test case, such as the name, description, and status or content of an existing test case. This API doesn't allow customers to update the tags of the test case resource for the specified Amazon Connect instance.
 */
export const updateTestCase: API.OperationMethod<
  UpdateTestCaseRequest,
  UpdateTestCaseResponse,
  UpdateTestCaseError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateTestCaseRequest,
  output: UpdateTestCaseResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    InvalidTestCaseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateTrafficDistributionError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the traffic distribution for a given traffic distribution group.
 *
 * When you shift telephony traffic, also shift agents and/or agent sign-ins to ensure they can handle the calls
 * in the other Region. If you don't shift the agents, voice calls will go to the shifted Region but there won't be any
 * agents available to receive the calls.
 *
 * The `SignInConfig` distribution is available only on a
 * default `TrafficDistributionGroup` (see the `IsDefault` parameter in the
 * TrafficDistributionGroup
 * data type). If you call
 * `UpdateTrafficDistribution` with a modified `SignInConfig` and a non-default `TrafficDistributionGroup`,
 * an `InvalidRequestException` is returned.
 *
 * For more information about updating a traffic distribution group, see Update telephony traffic distribution
 * across Amazon Web Services Regions
 * in the *Amazon Connect Administrator Guide*.
 */
export const updateTrafficDistribution: API.OperationMethod<
  UpdateTrafficDistributionRequest,
  UpdateTrafficDistributionResponse,
  UpdateTrafficDistributionError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateTrafficDistributionRequest,
  output: UpdateTrafficDistributionResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateUserConfigError =
  | ConditionalOperationFailedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the configuration settings for the specified user, including per-channel auto-accept and after contact work (ACW) timeout settings.
 *
 * This operation replaces the UpdateUserPhoneConfig API. While UpdateUserPhoneConfig applies the same ACW timeout to all channels, UpdateUserConfig allows you to set different auto-accept and ACW timeout values for each channel type.
 */
export const updateUserConfig: API.OperationMethod<
  UpdateUserConfigRequest,
  UpdateUserConfigResponse,
  UpdateUserConfigError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserConfigRequest,
  output: UpdateUserConfigResponse,
  errors: [
    ConditionalOperationFailedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateUserHierarchyError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Assigns the specified hierarchy group to the specified user.
 */
export const updateUserHierarchy: API.OperationMethod<
  UpdateUserHierarchyRequest,
  UpdateUserHierarchyResponse,
  UpdateUserHierarchyError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserHierarchyRequest,
  output: UpdateUserHierarchyResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateUserHierarchyGroupNameError =
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the name of the user hierarchy group.
 */
export const updateUserHierarchyGroupName: API.OperationMethod<
  UpdateUserHierarchyGroupNameRequest,
  UpdateUserHierarchyGroupNameResponse,
  UpdateUserHierarchyGroupNameError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserHierarchyGroupNameRequest,
  output: UpdateUserHierarchyGroupNameResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateUserHierarchyStructureError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the user hierarchy structure: add, remove, and rename user hierarchy levels.
 */
export const updateUserHierarchyStructure: API.OperationMethod<
  UpdateUserHierarchyStructureRequest,
  UpdateUserHierarchyStructureResponse,
  UpdateUserHierarchyStructureError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserHierarchyStructureRequest,
  output: UpdateUserHierarchyStructureResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateUserIdentityInfoError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the identity information for the specified user.
 *
 * We strongly recommend limiting who has the ability to invoke `UpdateUserIdentityInfo`. Someone with
 * that ability can change the login credentials of other users by changing their email address. This poses a security
 * risk to your organization. They can change the email address of a user to the attacker's email address, and then
 * reset the password through email. For more information, see Best Practices for Security Profiles
 * in the *Amazon Connect Administrator Guide*.
 */
export const updateUserIdentityInfo: API.OperationMethod<
  UpdateUserIdentityInfoRequest,
  UpdateUserIdentityInfoResponse,
  UpdateUserIdentityInfoError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserIdentityInfoRequest,
  output: UpdateUserIdentityInfoResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateUserNotificationStatusError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the status of a notification for a specific user, such as marking it as read or hidden. Users can only update notification status for notifications that have been sent to them. READ status deprioritizes the notification and greys it out, while HIDDEN status removes it from the notification widget.
 */
export const updateUserNotificationStatus: API.OperationMethod<
  UpdateUserNotificationStatusRequest,
  UpdateUserNotificationStatusResponse,
  UpdateUserNotificationStatusError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserNotificationStatusRequest,
  output: UpdateUserNotificationStatusResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateUserPhoneConfigError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the phone configuration settings for the specified user.
 *
 * We recommend using the UpdateUserConfig API, which supports additional functionality that is not available in the UpdateUserPhoneConfig API, such as voice enhancement settings and per-channel configuration for auto-accept and After Contact Work (ACW) timeouts. In comparison, the UpdateUserPhoneConfig API will always set the same ACW timeouts to all channels the user handles.
 */
export const updateUserPhoneConfig: API.OperationMethod<
  UpdateUserPhoneConfigRequest,
  UpdateUserPhoneConfigResponse,
  UpdateUserPhoneConfigError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserPhoneConfigRequest,
  output: UpdateUserPhoneConfigResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateUserProficienciesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the properties associated with the proficiencies of a user.
 */
export const updateUserProficiencies: API.OperationMethod<
  UpdateUserProficienciesRequest,
  UpdateUserProficienciesResponse,
  UpdateUserProficienciesError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserProficienciesRequest,
  output: UpdateUserProficienciesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateUserRoutingProfileError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Assigns the specified routing profile to the specified user.
 */
export const updateUserRoutingProfile: API.OperationMethod<
  UpdateUserRoutingProfileRequest,
  UpdateUserRoutingProfileResponse,
  UpdateUserRoutingProfileError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserRoutingProfileRequest,
  output: UpdateUserRoutingProfileResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateUserSecurityProfilesError =
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Assigns the specified security profiles to the specified user.
 */
export const updateUserSecurityProfiles: API.OperationMethod<
  UpdateUserSecurityProfilesRequest,
  UpdateUserSecurityProfilesResponse,
  UpdateUserSecurityProfilesError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserSecurityProfilesRequest,
  output: UpdateUserSecurityProfilesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateViewContentError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | TooManyRequestsException
  | CommonErrors;
/**
 * Updates the view content of the given view identifier in the specified Amazon Connect instance.
 *
 * It performs content validation if `Status` is set to `SAVED` and performs full content
 * validation if `Status` is `PUBLISHED`. Note that the `$SAVED` alias' content will
 * always be updated, but the `$LATEST` alias' content will only be updated if `Status` is
 * `PUBLISHED`.
 */
export const updateViewContent: API.OperationMethod<
  UpdateViewContentRequest,
  UpdateViewContentResponse,
  UpdateViewContentError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateViewContentRequest,
  output: UpdateViewContentResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    TooManyRequestsException,
  ],
}));
export type UpdateViewMetadataError =
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | TooManyRequestsException
  | CommonErrors;
/**
 * Updates the view metadata. Note that either `Name` or `Description` must be
 * provided.
 */
export const updateViewMetadata: API.OperationMethod<
  UpdateViewMetadataRequest,
  UpdateViewMetadataResponse,
  UpdateViewMetadataError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateViewMetadataRequest,
  output: UpdateViewMetadataResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    TooManyRequestsException,
  ],
}));
export type UpdateWorkspaceMetadataError =
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the metadata of a workspace, such as its name and description.
 */
export const updateWorkspaceMetadata: API.OperationMethod<
  UpdateWorkspaceMetadataRequest,
  UpdateWorkspaceMetadataResponse,
  UpdateWorkspaceMetadataError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateWorkspaceMetadataRequest,
  output: UpdateWorkspaceMetadataResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateWorkspacePageError =
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the configuration of a page in a workspace, including the associated view and input data.
 */
export const updateWorkspacePage: API.OperationMethod<
  UpdateWorkspacePageRequest,
  UpdateWorkspacePageResponse,
  UpdateWorkspacePageError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateWorkspacePageRequest,
  output: UpdateWorkspacePageResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateWorkspaceThemeError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the theme configuration for a workspace, including colors and styling.
 */
export const updateWorkspaceTheme: API.OperationMethod<
  UpdateWorkspaceThemeRequest,
  UpdateWorkspaceThemeResponse,
  UpdateWorkspaceThemeError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateWorkspaceThemeRequest,
  output: UpdateWorkspaceThemeResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
export type UpdateWorkspaceVisibilityError =
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors;
/**
 * Updates the visibility setting of a workspace, controlling whether it is available to all users, assigned users
 * only, or none.
 */
export const updateWorkspaceVisibility: API.OperationMethod<
  UpdateWorkspaceVisibilityRequest,
  UpdateWorkspaceVisibilityResponse,
  UpdateWorkspaceVisibilityError,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateWorkspaceVisibilityRequest,
  output: UpdateWorkspaceVisibilityResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
