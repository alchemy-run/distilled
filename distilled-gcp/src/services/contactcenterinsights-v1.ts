// ==========================================================================
// Contact Center AI Insights API (contactcenterinsights v1)
// DO NOT EDIT - Generated from GCP Discovery Document
// ==========================================================================

import * as Schema from "effect/Schema";
import * as API from "../client/api.ts";
import * as T from "../traits.ts";
import * as C from "../category.ts";
import type { GCPAuth } from "../auth.ts";
import type { CommonErrors } from "../errors.ts";
import type * as HttpClient from "effect/unstable/http/HttpClient";

// Service metadata
const svc = T.Service({
  name: "contactcenterinsights",
  version: "v1",
  rootUrl: "https://contactcenterinsights.googleapis.com/",
  servicePath: "",
});

// ==========================================================================
// Schemas
// ==========================================================================

export interface GoogleRpcStatus {
  /** The status code, which should be an enum value of google.rpc.Code. */
  code?: number;
  /** A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client. */
  message?: string;
  /** A list of messages that carry the error details. There is a common set of message types for APIs to use. */
  details?: Array<Record<string, unknown>>;
}

export const GoogleRpcStatus: Schema.Schema<GoogleRpcStatus> = Schema.suspend(() => Schema.Struct({
  code: Schema.optional(Schema.Number),
  message: Schema.optional(Schema.String),
  details: Schema.optional(Schema.Array(Schema.Record(Schema.String, Schema.Unknown))),
})).annotate({ identifier: "GoogleRpcStatus" }) as any as Schema.Schema<GoogleRpcStatus>;

export interface GoogleLongrunningOperation {
  /** The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`. */
  name?: string;
  /** Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any. */
  metadata?: Record<string, unknown>;
  /** If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available. */
  done?: boolean;
  /** The error result of the operation in case of failure or cancellation. */
  error?: GoogleRpcStatus;
  /** The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`. */
  response?: Record<string, unknown>;
}

export const GoogleLongrunningOperation: Schema.Schema<GoogleLongrunningOperation> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.Unknown)),
  done: Schema.optional(Schema.Boolean),
  error: Schema.optional(GoogleRpcStatus),
  response: Schema.optional(Schema.Record(Schema.String, Schema.Unknown)),
})).annotate({ identifier: "GoogleLongrunningOperation" }) as any as Schema.Schema<GoogleLongrunningOperation>;

export interface GoogleLongrunningListOperationsResponse {
  /** A list of operations that matches the specified filter in the request. */
  operations?: Array<GoogleLongrunningOperation>;
  /** The standard List next-page token. */
  nextPageToken?: string;
  /** Unordered list. Unreachable resources. Populated when the request sets `ListOperationsRequest.return_partial_success` and reads across collections. For example, when attempting to list all resources across all supported locations. */
  unreachable?: Array<string>;
}

export const GoogleLongrunningListOperationsResponse: Schema.Schema<GoogleLongrunningListOperationsResponse> = Schema.suspend(() => Schema.Struct({
  operations: Schema.optional(Schema.Array(GoogleLongrunningOperation)),
  nextPageToken: Schema.optional(Schema.String),
  unreachable: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleLongrunningListOperationsResponse" }) as any as Schema.Schema<GoogleLongrunningListOperationsResponse>;

export interface GoogleProtobufEmpty {
}

export const GoogleProtobufEmpty: Schema.Schema<GoogleProtobufEmpty> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleProtobufEmpty" }) as any as Schema.Schema<GoogleProtobufEmpty>;

export interface GoogleTypeExpr {
  /** Textual representation of an expression in Common Expression Language syntax. */
  expression?: string;
  /** Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression. */
  title?: string;
  /** Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI. */
  description?: string;
  /** Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file. */
  location?: string;
}

export const GoogleTypeExpr: Schema.Schema<GoogleTypeExpr> = Schema.suspend(() => Schema.Struct({
  expression: Schema.optional(Schema.String),
  title: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  location: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleTypeExpr" }) as any as Schema.Schema<GoogleTypeExpr>;

export interface GoogleIamV1Binding {
  /** Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`. For an overview of the IAM roles and permissions, see the [IAM documentation](https://cloud.google.com/iam/docs/roles-overview). For a list of the available pre-defined roles, see [here](https://cloud.google.com/iam/docs/understanding-roles). */
  role?: string;
  /** Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workforce identity pool. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`: All workforce identities in a group. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All workforce identities with a specific attribute value. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/*`: All identities in a workforce identity pool. * `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workload identity pool. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`: A workload identity pool group. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All identities in a workload identity pool with a certain attribute. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/*`: All identities in a workload identity pool. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: Deleted single identity in a workforce identity pool. For example, `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`. */
  members?: Array<string>;
  /** The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). */
  condition?: GoogleTypeExpr;
}

export const GoogleIamV1Binding: Schema.Schema<GoogleIamV1Binding> = Schema.suspend(() => Schema.Struct({
  role: Schema.optional(Schema.String),
  members: Schema.optional(Schema.Array(Schema.String)),
  condition: Schema.optional(GoogleTypeExpr),
})).annotate({ identifier: "GoogleIamV1Binding" }) as any as Schema.Schema<GoogleIamV1Binding>;

export interface GoogleIamV1AuditLogConfig {
  /** The log type that this config enables. */
  logType?: "LOG_TYPE_UNSPECIFIED" | "ADMIN_READ" | "DATA_WRITE" | "DATA_READ" | (string & {});
  /** Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members. */
  exemptedMembers?: Array<string>;
}

export const GoogleIamV1AuditLogConfig: Schema.Schema<GoogleIamV1AuditLogConfig> = Schema.suspend(() => Schema.Struct({
  logType: Schema.optional(Schema.String),
  exemptedMembers: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleIamV1AuditLogConfig" }) as any as Schema.Schema<GoogleIamV1AuditLogConfig>;

export interface GoogleIamV1AuditConfig {
  /** Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services. */
  service?: string;
  /** The configuration for logging of each type of permission. */
  auditLogConfigs?: Array<GoogleIamV1AuditLogConfig>;
}

export const GoogleIamV1AuditConfig: Schema.Schema<GoogleIamV1AuditConfig> = Schema.suspend(() => Schema.Struct({
  service: Schema.optional(Schema.String),
  auditLogConfigs: Schema.optional(Schema.Array(GoogleIamV1AuditLogConfig)),
})).annotate({ identifier: "GoogleIamV1AuditConfig" }) as any as Schema.Schema<GoogleIamV1AuditConfig>;

export interface GoogleIamV1Policy {
  /** Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). */
  version?: number;
  /** Associates a list of `members`, or principals, with a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one principal. The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of these principals can be Google groups. Each occurrence of a principal counts towards these limits. For example, if the `bindings` grant 50 different roles to `user:alice@example.com`, and not to any other principal, then you can add another 1,450 principals to the `bindings` in the `Policy`. */
  bindings?: Array<GoogleIamV1Binding>;
  /** Specifies cloud audit logging configuration for this policy. */
  auditConfigs?: Array<GoogleIamV1AuditConfig>;
  /** `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. */
  etag?: string;
}

export const GoogleIamV1Policy: Schema.Schema<GoogleIamV1Policy> = Schema.suspend(() => Schema.Struct({
  version: Schema.optional(Schema.Number),
  bindings: Schema.optional(Schema.Array(GoogleIamV1Binding)),
  auditConfigs: Schema.optional(Schema.Array(GoogleIamV1AuditConfig)),
  etag: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleIamV1Policy" }) as any as Schema.Schema<GoogleIamV1Policy>;

export interface GoogleIamV1SetIamPolicyRequest {
  /** REQUIRED: The complete policy to be applied to the `resource`. The size of the policy is limited to a few 10s of KB. An empty policy is a valid policy but certain Google Cloud services (such as Projects) might reject them. */
  policy?: GoogleIamV1Policy;
  /** OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only the fields in the mask will be modified. If no mask is provided, the following default mask is used: `paths: "bindings, etag"` */
  updateMask?: string;
}

export const GoogleIamV1SetIamPolicyRequest: Schema.Schema<GoogleIamV1SetIamPolicyRequest> = Schema.suspend(() => Schema.Struct({
  policy: Schema.optional(GoogleIamV1Policy),
  updateMask: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleIamV1SetIamPolicyRequest" }) as any as Schema.Schema<GoogleIamV1SetIamPolicyRequest>;

export interface GoogleIamV1TestIamPermissionsRequest {
  /** The set of permissions to check for the `resource`. Permissions with wildcards (such as `*` or `storage.*`) are not allowed. For more information see [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions). */
  permissions?: Array<string>;
}

export const GoogleIamV1TestIamPermissionsRequest: Schema.Schema<GoogleIamV1TestIamPermissionsRequest> = Schema.suspend(() => Schema.Struct({
  permissions: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleIamV1TestIamPermissionsRequest" }) as any as Schema.Schema<GoogleIamV1TestIamPermissionsRequest>;

export interface GoogleIamV1TestIamPermissionsResponse {
  /** A subset of `TestPermissionsRequest.permissions` that the caller is allowed. */
  permissions?: Array<string>;
}

export const GoogleIamV1TestIamPermissionsResponse: Schema.Schema<GoogleIamV1TestIamPermissionsResponse> = Schema.suspend(() => Schema.Struct({
  permissions: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleIamV1TestIamPermissionsResponse" }) as any as Schema.Schema<GoogleIamV1TestIamPermissionsResponse>;

export interface GoogleCloudContactcenterinsightsV1ConversationCallMetadata {
  /** The audio channel that contains the customer. */
  customerChannel?: number;
  /** The audio channel that contains the agent. */
  agentChannel?: number;
}

export const GoogleCloudContactcenterinsightsV1ConversationCallMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationCallMetadata> = Schema.suspend(() => Schema.Struct({
  customerChannel: Schema.optional(Schema.Number),
  agentChannel: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConversationCallMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationCallMetadata>;

export interface GoogleCloudContactcenterinsightsV1GcsSource {
  /** Cloud Storage URI that points to a file that contains the conversation audio. */
  audioUri?: string;
  /** Immutable. Cloud Storage URI that points to a file that contains the conversation transcript. */
  transcriptUri?: string;
}

export const GoogleCloudContactcenterinsightsV1GcsSource: Schema.Schema<GoogleCloudContactcenterinsightsV1GcsSource> = Schema.suspend(() => Schema.Struct({
  audioUri: Schema.optional(Schema.String),
  transcriptUri: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GcsSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GcsSource>;

export interface GoogleCloudContactcenterinsightsV1DialogflowSource {
  /** Output only. The name of the Dialogflow conversation that this conversation resource is derived from. Format: projects/{project}/locations/{location}/conversations/{conversation} */
  dialogflowConversation?: string;
  /** Cloud Storage URI that points to a file that contains the conversation audio. */
  audioUri?: string;
}

export const GoogleCloudContactcenterinsightsV1DialogflowSource: Schema.Schema<GoogleCloudContactcenterinsightsV1DialogflowSource> = Schema.suspend(() => Schema.Struct({
  dialogflowConversation: Schema.optional(Schema.String),
  audioUri: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DialogflowSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DialogflowSource>;

export interface GoogleCloudContactcenterinsightsV1ConversationDataSource {
  /** A Cloud Storage location specification for the audio and transcript. */
  gcsSource?: GoogleCloudContactcenterinsightsV1GcsSource;
  /** The source when the conversation comes from Dialogflow. */
  dialogflowSource?: GoogleCloudContactcenterinsightsV1DialogflowSource;
  /** Cloud Storage URI that points to a file that contains the conversation metadata. */
  metadataUri?: string;
}

export const GoogleCloudContactcenterinsightsV1ConversationDataSource: Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationDataSource> = Schema.suspend(() => Schema.Struct({
  gcsSource: Schema.optional(GoogleCloudContactcenterinsightsV1GcsSource),
  dialogflowSource: Schema.optional(GoogleCloudContactcenterinsightsV1DialogflowSource),
  metadataUri: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConversationDataSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationDataSource>;

export interface GoogleCloudContactcenterinsightsV1ConversationQualityMetadataAgentInfo {
  /** A user-specified string representing the agent. */
  agentId?: string;
  /** The agent's name. */
  displayName?: string;
  /** A user-specified string representing the agent's team. Deprecated in favor of the `teams` field. */
  team?: string;
  /** User-specified strings representing the agent's teams. */
  teams?: Array<string>;
  /** A user-provided string indicating the outcome of the agent's segment of the call. */
  dispositionCode?: string;
  /** The agent type, e.g. HUMAN_AGENT. */
  agentType?: "ROLE_UNSPECIFIED" | "HUMAN_AGENT" | "AUTOMATED_AGENT" | "END_USER" | "ANY_AGENT" | (string & {});
  /** The agent's location. */
  location?: string;
  /** The agent's deployment ID. Only applicable to automated agents. */
  deploymentId?: string;
  /** The agent's deployment display name. Only applicable to automated agents. */
  deploymentDisplayName?: string;
  /** The agent's version ID. Only applicable to automated agents. */
  versionId?: string;
  /** The agent's version display name. Only applicable to automated agents. */
  versionDisplayName?: string;
}

export const GoogleCloudContactcenterinsightsV1ConversationQualityMetadataAgentInfo: Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationQualityMetadataAgentInfo> = Schema.suspend(() => Schema.Struct({
  agentId: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  team: Schema.optional(Schema.String),
  teams: Schema.optional(Schema.Array(Schema.String)),
  dispositionCode: Schema.optional(Schema.String),
  agentType: Schema.optional(Schema.String),
  location: Schema.optional(Schema.String),
  deploymentId: Schema.optional(Schema.String),
  deploymentDisplayName: Schema.optional(Schema.String),
  versionId: Schema.optional(Schema.String),
  versionDisplayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConversationQualityMetadataAgentInfo" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationQualityMetadataAgentInfo>;

export interface GoogleCloudContactcenterinsightsV1QaAnswerAnswerValue {
  /** String value. */
  strValue?: string;
  /** Numerical value. */
  numValue?: number;
  /** Boolean value. */
  boolValue?: boolean;
  /** A value of "Not Applicable (N/A)". Should only ever be `true`. */
  naValue?: boolean;
  /** Output only. A value of "Skip". If provided, this field may only be set to `true`. If a question receives this answer, it will be excluded from any score calculations. This would mean that the question was not evaluated. */
  skipValue?: boolean;
  /** A short string used as an identifier. Matches the value used in QaQuestion.AnswerChoice.key. */
  key?: string;
  /** Output only. Numerical score of the answer. */
  score?: number;
  /** Output only. The maximum potential score of the question. */
  potentialScore?: number;
  /** Output only. Normalized score of the questions. Calculated as score / potential_score. */
  normalizedScore?: number;
}

export const GoogleCloudContactcenterinsightsV1QaAnswerAnswerValue: Schema.Schema<GoogleCloudContactcenterinsightsV1QaAnswerAnswerValue> = Schema.suspend(() => Schema.Struct({
  strValue: Schema.optional(Schema.String),
  numValue: Schema.optional(Schema.Number),
  boolValue: Schema.optional(Schema.Boolean),
  naValue: Schema.optional(Schema.Boolean),
  skipValue: Schema.optional(Schema.Boolean),
  key: Schema.optional(Schema.String),
  score: Schema.optional(Schema.Number),
  potentialScore: Schema.optional(Schema.Number),
  normalizedScore: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QaAnswerAnswerValue" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QaAnswerAnswerValue>;

export interface GoogleCloudContactcenterinsightsV1FeedbackLabel {
  /** String label used for Topic Modeling. */
  label?: string;
  /** QaAnswer label used for Quality AI example conversations. */
  qaAnswerLabel?: GoogleCloudContactcenterinsightsV1QaAnswerAnswerValue;
  /** Immutable. Resource name of the FeedbackLabel. Format: projects/{project}/locations/{location}/conversations/{conversation}/feedbackLabels/{feedback_label} */
  name?: string;
  /** Name of the resource to be labeled. Supported resources are: * `projects/{project}/locations/{location}/qaScorecards/{scorecard}/revisions/{revision}/qaQuestions/{question}` * `projects/{project}/locations/{location}/issueModels/{issue_model}` * `projects/{project}/locations/{location}/generators/{generator_id}` */
  labeledResource?: string;
  /** Output only. Create time of the label. */
  createTime?: string;
  /** Output only. Update time of the label. */
  updateTime?: string;
}

export const GoogleCloudContactcenterinsightsV1FeedbackLabel: Schema.Schema<GoogleCloudContactcenterinsightsV1FeedbackLabel> = Schema.suspend(() => Schema.Struct({
  label: Schema.optional(Schema.String),
  qaAnswerLabel: Schema.optional(GoogleCloudContactcenterinsightsV1QaAnswerAnswerValue),
  name: Schema.optional(Schema.String),
  labeledResource: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1FeedbackLabel" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1FeedbackLabel>;

export interface GoogleCloudContactcenterinsightsV1ConversationQualityMetadata {
  /** An arbitrary integer value indicating the customer's satisfaction rating. */
  customerSatisfactionRating?: number;
  /** The amount of time the customer waited to connect with an agent. */
  waitDuration?: string;
  /** An arbitrary string value specifying the menu path the customer took. */
  menuPath?: string;
  /** Information about agents involved in the call. */
  agentInfo?: Array<GoogleCloudContactcenterinsightsV1ConversationQualityMetadataAgentInfo>;
  /** Input only. The feedback labels associated with the conversation. */
  feedbackLabels?: Array<GoogleCloudContactcenterinsightsV1FeedbackLabel>;
}

export const GoogleCloudContactcenterinsightsV1ConversationQualityMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationQualityMetadata> = Schema.suspend(() => Schema.Struct({
  customerSatisfactionRating: Schema.optional(Schema.Number),
  waitDuration: Schema.optional(Schema.String),
  menuPath: Schema.optional(Schema.String),
  agentInfo: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1ConversationQualityMetadataAgentInfo)),
  feedbackLabels: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1FeedbackLabel)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConversationQualityMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationQualityMetadata>;

export interface GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegmentWordInfo {
  /** Time offset of the start of this word relative to the beginning of the total conversation. */
  startOffset?: string;
  /** Time offset of the end of this word relative to the beginning of the total conversation. */
  endOffset?: string;
  /** The word itself. Includes punctuation marks that surround the word. */
  word?: string;
  /** A confidence estimate between 0.0 and 1.0 of the fidelity of this word. A default value of 0.0 indicates that the value is unset. */
  confidence?: number;
}

export const GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegmentWordInfo: Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegmentWordInfo> = Schema.suspend(() => Schema.Struct({
  startOffset: Schema.optional(Schema.String),
  endOffset: Schema.optional(Schema.String),
  word: Schema.optional(Schema.String),
  confidence: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegmentWordInfo" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegmentWordInfo>;

export interface GoogleCloudContactcenterinsightsV1ConversationParticipant {
  /** The name of the participant provided by Dialogflow. Format: projects/{project}/locations/{location}/conversations/{conversation}/participants/{participant} */
  dialogflowParticipantName?: string;
  /** A user-specified ID representing the participant. */
  userId?: string;
  /** Deprecated. Use `dialogflow_participant_name` instead. The name of the Dialogflow participant. Format: projects/{project}/locations/{location}/conversations/{conversation}/participants/{participant} */
  dialogflowParticipant?: string;
  /** Obfuscated user ID from Dialogflow. */
  obfuscatedExternalUserId?: string;
  /** The role of the participant. */
  role?: "ROLE_UNSPECIFIED" | "HUMAN_AGENT" | "AUTOMATED_AGENT" | "END_USER" | "ANY_AGENT" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1ConversationParticipant: Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationParticipant> = Schema.suspend(() => Schema.Struct({
  dialogflowParticipantName: Schema.optional(Schema.String),
  userId: Schema.optional(Schema.String),
  dialogflowParticipant: Schema.optional(Schema.String),
  obfuscatedExternalUserId: Schema.optional(Schema.String),
  role: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConversationParticipant" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationParticipant>;

export interface GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata {
  /** Whether the transcript segment was covered under the configured smart reply allowlist in Agent Assist. */
  smartReplyAllowlistCovered?: boolean;
}

export const GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata> = Schema.suspend(() => Schema.Struct({
  smartReplyAllowlistCovered: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata>;

export interface GoogleCloudContactcenterinsightsV1SentimentData {
  /** A non-negative number from 0 to infinity which represents the absolute magnitude of sentiment regardless of score. */
  magnitude?: number;
  /** The sentiment score between -1.0 (negative) and 1.0 (positive). */
  score?: number;
}

export const GoogleCloudContactcenterinsightsV1SentimentData: Schema.Schema<GoogleCloudContactcenterinsightsV1SentimentData> = Schema.suspend(() => Schema.Struct({
  magnitude: Schema.optional(Schema.Number),
  score: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1SentimentData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1SentimentData>;

export interface GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegment {
  /** The time that the message occurred, if provided. */
  messageTime?: string;
  /** The text of this segment. */
  text?: string;
  /** A confidence estimate between 0.0 and 1.0 of the fidelity of this segment. A default value of 0.0 indicates that the value is unset. */
  confidence?: number;
  /** A list of the word-specific information for each word in the segment. */
  words?: Array<GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegmentWordInfo>;
  /** The language code of this segment as a [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag. Example: "en-US". */
  languageCode?: string;
  /** For conversations derived from multi-channel audio, this is the channel number corresponding to the audio from that channel. For audioChannelCount = N, its output values can range from '1' to 'N'. A channel tag of 0 indicates that the audio is mono. */
  channelTag?: number;
  /** The participant of this segment. */
  segmentParticipant?: GoogleCloudContactcenterinsightsV1ConversationParticipant;
  /** CCAI metadata relating to the current transcript segment. */
  dialogflowSegmentMetadata?: GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata;
  /** The sentiment for this transcript segment. */
  sentiment?: GoogleCloudContactcenterinsightsV1SentimentData;
}

export const GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegment: Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegment> = Schema.suspend(() => Schema.Struct({
  messageTime: Schema.optional(Schema.String),
  text: Schema.optional(Schema.String),
  confidence: Schema.optional(Schema.Number),
  words: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegmentWordInfo)),
  languageCode: Schema.optional(Schema.String),
  channelTag: Schema.optional(Schema.Number),
  segmentParticipant: Schema.optional(GoogleCloudContactcenterinsightsV1ConversationParticipant),
  dialogflowSegmentMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata),
  sentiment: Schema.optional(GoogleCloudContactcenterinsightsV1SentimentData),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegment" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegment>;

export interface GoogleCloudContactcenterinsightsV1ConversationTranscript {
  /** A list of sequential transcript segments that comprise the conversation. */
  transcriptSegments?: Array<GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegment>;
}

export const GoogleCloudContactcenterinsightsV1ConversationTranscript: Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationTranscript> = Schema.suspend(() => Schema.Struct({
  transcriptSegments: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1ConversationTranscriptTranscriptSegment)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConversationTranscript" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationTranscript>;

export interface GoogleCloudContactcenterinsightsV1InterruptionData {
}

export const GoogleCloudContactcenterinsightsV1InterruptionData: Schema.Schema<GoogleCloudContactcenterinsightsV1InterruptionData> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1InterruptionData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1InterruptionData>;

export interface GoogleCloudContactcenterinsightsV1SilenceData {
}

export const GoogleCloudContactcenterinsightsV1SilenceData: Schema.Schema<GoogleCloudContactcenterinsightsV1SilenceData> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1SilenceData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1SilenceData>;

export interface GoogleCloudContactcenterinsightsV1HoldData {
}

export const GoogleCloudContactcenterinsightsV1HoldData: Schema.Schema<GoogleCloudContactcenterinsightsV1HoldData> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1HoldData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1HoldData>;

export interface GoogleCloudContactcenterinsightsV1EntityMentionData {
  /** The key of this entity in conversation entities. Can be used to retrieve the exact `Entity` this mention is attached to. */
  entityUniqueId?: string;
  /** The type of the entity mention. */
  type?: "MENTION_TYPE_UNSPECIFIED" | "PROPER" | "COMMON" | (string & {});
  /** Sentiment expressed for this mention of the entity. */
  sentiment?: GoogleCloudContactcenterinsightsV1SentimentData;
}

export const GoogleCloudContactcenterinsightsV1EntityMentionData: Schema.Schema<GoogleCloudContactcenterinsightsV1EntityMentionData> = Schema.suspend(() => Schema.Struct({
  entityUniqueId: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  sentiment: Schema.optional(GoogleCloudContactcenterinsightsV1SentimentData),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1EntityMentionData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1EntityMentionData>;

export interface GoogleCloudContactcenterinsightsV1IntentMatchData {
  /** The id of the matched intent. Can be used to retrieve the corresponding intent information. */
  intentUniqueId?: string;
}

export const GoogleCloudContactcenterinsightsV1IntentMatchData: Schema.Schema<GoogleCloudContactcenterinsightsV1IntentMatchData> = Schema.suspend(() => Schema.Struct({
  intentUniqueId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1IntentMatchData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1IntentMatchData>;

export interface GoogleCloudContactcenterinsightsV1PhraseMatchData {
  /** The unique identifier (the resource name) of the phrase matcher. */
  phraseMatcher?: string;
  /** The human-readable name of the phrase matcher. */
  displayName?: string;
}

export const GoogleCloudContactcenterinsightsV1PhraseMatchData: Schema.Schema<GoogleCloudContactcenterinsightsV1PhraseMatchData> = Schema.suspend(() => Schema.Struct({
  phraseMatcher: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1PhraseMatchData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1PhraseMatchData>;

export interface GoogleCloudContactcenterinsightsV1IssueAssignment {
  /** Resource name of the assigned issue. */
  issue?: string;
  /** Score indicating the likelihood of the issue assignment. currently bounded on [0,1]. */
  score?: number;
  /** Immutable. Display name of the assigned issue. This field is set at time of analysis and immutable since then. */
  displayName?: string;
}

export const GoogleCloudContactcenterinsightsV1IssueAssignment: Schema.Schema<GoogleCloudContactcenterinsightsV1IssueAssignment> = Schema.suspend(() => Schema.Struct({
  issue: Schema.optional(Schema.String),
  score: Schema.optional(Schema.Number),
  displayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1IssueAssignment" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1IssueAssignment>;

export interface GoogleCloudContactcenterinsightsV1IssueMatchData {
  /** Information about the issue's assignment. */
  issueAssignment?: GoogleCloudContactcenterinsightsV1IssueAssignment;
}

export const GoogleCloudContactcenterinsightsV1IssueMatchData: Schema.Schema<GoogleCloudContactcenterinsightsV1IssueMatchData> = Schema.suspend(() => Schema.Struct({
  issueAssignment: Schema.optional(GoogleCloudContactcenterinsightsV1IssueAssignment),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1IssueMatchData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1IssueMatchData>;

export interface GoogleCloudContactcenterinsightsV1AnnotationBoundary {
  /** The word index of this boundary with respect to the first word in the transcript piece. This index starts at zero. */
  wordIndex?: number;
  /** The index in the sequence of transcribed pieces of the conversation where the boundary is located. This index starts at zero. */
  transcriptIndex?: number;
}

export const GoogleCloudContactcenterinsightsV1AnnotationBoundary: Schema.Schema<GoogleCloudContactcenterinsightsV1AnnotationBoundary> = Schema.suspend(() => Schema.Struct({
  wordIndex: Schema.optional(Schema.Number),
  transcriptIndex: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1AnnotationBoundary" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1AnnotationBoundary>;

export interface GoogleCloudContactcenterinsightsV1CallAnnotation {
  /** Data specifying an interruption. */
  interruptionData?: GoogleCloudContactcenterinsightsV1InterruptionData;
  /** Data specifying sentiment. */
  sentimentData?: GoogleCloudContactcenterinsightsV1SentimentData;
  /** Data specifying silence. */
  silenceData?: GoogleCloudContactcenterinsightsV1SilenceData;
  /** Data specifying a hold. */
  holdData?: GoogleCloudContactcenterinsightsV1HoldData;
  /** Data specifying an entity mention. */
  entityMentionData?: GoogleCloudContactcenterinsightsV1EntityMentionData;
  /** Data specifying an intent match. */
  intentMatchData?: GoogleCloudContactcenterinsightsV1IntentMatchData;
  /** Data specifying a phrase match. */
  phraseMatchData?: GoogleCloudContactcenterinsightsV1PhraseMatchData;
  /** Data specifying an issue match. */
  issueMatchData?: GoogleCloudContactcenterinsightsV1IssueMatchData;
  /** The channel of the audio where the annotation occurs. For single-channel audio, this field is not populated. */
  channelTag?: number;
  /** The boundary in the conversation where the annotation starts, inclusive. */
  annotationStartBoundary?: GoogleCloudContactcenterinsightsV1AnnotationBoundary;
  /** The boundary in the conversation where the annotation ends, inclusive. */
  annotationEndBoundary?: GoogleCloudContactcenterinsightsV1AnnotationBoundary;
}

export const GoogleCloudContactcenterinsightsV1CallAnnotation: Schema.Schema<GoogleCloudContactcenterinsightsV1CallAnnotation> = Schema.suspend(() => Schema.Struct({
  interruptionData: Schema.optional(GoogleCloudContactcenterinsightsV1InterruptionData),
  sentimentData: Schema.optional(GoogleCloudContactcenterinsightsV1SentimentData),
  silenceData: Schema.optional(GoogleCloudContactcenterinsightsV1SilenceData),
  holdData: Schema.optional(GoogleCloudContactcenterinsightsV1HoldData),
  entityMentionData: Schema.optional(GoogleCloudContactcenterinsightsV1EntityMentionData),
  intentMatchData: Schema.optional(GoogleCloudContactcenterinsightsV1IntentMatchData),
  phraseMatchData: Schema.optional(GoogleCloudContactcenterinsightsV1PhraseMatchData),
  issueMatchData: Schema.optional(GoogleCloudContactcenterinsightsV1IssueMatchData),
  channelTag: Schema.optional(Schema.Number),
  annotationStartBoundary: Schema.optional(GoogleCloudContactcenterinsightsV1AnnotationBoundary),
  annotationEndBoundary: Schema.optional(GoogleCloudContactcenterinsightsV1AnnotationBoundary),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1CallAnnotation" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1CallAnnotation>;

export interface GoogleCloudContactcenterinsightsV1Entity {
  /** The representative name for the entity. */
  displayName?: string;
  /** The entity type. */
  type?: "TYPE_UNSPECIFIED" | "PERSON" | "LOCATION" | "ORGANIZATION" | "EVENT" | "WORK_OF_ART" | "CONSUMER_GOOD" | "OTHER" | "PHONE_NUMBER" | "ADDRESS" | "DATE" | "NUMBER" | "PRICE" | (string & {});
  /** Metadata associated with the entity. For most entity types, the metadata is a Wikipedia URL (`wikipedia_url`) and Knowledge Graph MID (`mid`), if they are available. For the metadata associated with other entity types, see the Type table below. */
  metadata?: Record<string, string>;
  /** The salience score associated with the entity in the [0, 1.0] range. The salience score for an entity provides information about the importance or centrality of that entity to the entire document text. Scores closer to 0 are less salient, while scores closer to 1.0 are highly salient. */
  salience?: number;
  /** The aggregate sentiment expressed for this entity in the conversation. */
  sentiment?: GoogleCloudContactcenterinsightsV1SentimentData;
}

export const GoogleCloudContactcenterinsightsV1Entity: Schema.Schema<GoogleCloudContactcenterinsightsV1Entity> = Schema.suspend(() => Schema.Struct({
  displayName: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  salience: Schema.optional(Schema.Number),
  sentiment: Schema.optional(GoogleCloudContactcenterinsightsV1SentimentData),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1Entity" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1Entity>;

export interface GoogleCloudContactcenterinsightsV1ConversationLevelSentiment {
  /** The channel of the audio that the data applies to. */
  channelTag?: number;
  /** Data specifying sentiment. */
  sentimentData?: GoogleCloudContactcenterinsightsV1SentimentData;
}

export const GoogleCloudContactcenterinsightsV1ConversationLevelSentiment: Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationLevelSentiment> = Schema.suspend(() => Schema.Struct({
  channelTag: Schema.optional(Schema.Number),
  sentimentData: Schema.optional(GoogleCloudContactcenterinsightsV1SentimentData),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConversationLevelSentiment" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationLevelSentiment>;

export interface GoogleCloudContactcenterinsightsV1ConversationLevelSilence {
  /** Amount of time calculated to be in silence. */
  silenceDuration?: string;
  /** Percentage of the total conversation spent in silence. */
  silencePercentage?: number;
}

export const GoogleCloudContactcenterinsightsV1ConversationLevelSilence: Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationLevelSilence> = Schema.suspend(() => Schema.Struct({
  silenceDuration: Schema.optional(Schema.String),
  silencePercentage: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConversationLevelSilence" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationLevelSilence>;

export interface GoogleCloudContactcenterinsightsV1Intent {
  /** The unique identifier of the intent. */
  id?: string;
  /** The human-readable name of the intent. */
  displayName?: string;
}

export const GoogleCloudContactcenterinsightsV1Intent: Schema.Schema<GoogleCloudContactcenterinsightsV1Intent> = Schema.suspend(() => Schema.Struct({
  id: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1Intent" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1Intent>;

export interface GoogleCloudContactcenterinsightsV1IssueModelResult {
  /** Issue model that generates the result. Format: projects/{project}/locations/{location}/issueModels/{issue_model} */
  issueModel?: string;
  /** All the matched issues. */
  issues?: Array<GoogleCloudContactcenterinsightsV1IssueAssignment>;
}

export const GoogleCloudContactcenterinsightsV1IssueModelResult: Schema.Schema<GoogleCloudContactcenterinsightsV1IssueModelResult> = Schema.suspend(() => Schema.Struct({
  issueModel: Schema.optional(Schema.String),
  issues: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1IssueAssignment)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1IssueModelResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1IssueModelResult>;

export interface GoogleCloudContactcenterinsightsV1QaAnswerAnswerSource {
  /** What created the answer. */
  sourceType?: "SOURCE_TYPE_UNSPECIFIED" | "SYSTEM_GENERATED" | "MANUAL_EDIT" | (string & {});
  /** The answer value from this source. This field is populated by default, unless the question has a selection strategy configured to return multiple answer values, in which case `answer_values` will be populated instead. */
  answerValue?: GoogleCloudContactcenterinsightsV1QaAnswerAnswerValue;
}

export const GoogleCloudContactcenterinsightsV1QaAnswerAnswerSource: Schema.Schema<GoogleCloudContactcenterinsightsV1QaAnswerAnswerSource> = Schema.suspend(() => Schema.Struct({
  sourceType: Schema.optional(Schema.String),
  answerValue: Schema.optional(GoogleCloudContactcenterinsightsV1QaAnswerAnswerValue),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QaAnswerAnswerSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QaAnswerAnswerSource>;

export interface GoogleCloudContactcenterinsightsV1QaAnswer {
  /** The QaQuestion answered by this answer. */
  qaQuestion?: string;
  /** The conversation the answer applies to. */
  conversation?: string;
  /** Question text. E.g., "Did the agent greet the customer?" */
  questionBody?: string;
  /** The answer value from this source. This field is populated by default, unless the question has a selection strategy configured to return multiple answer values, in which case `answer_values` will be populated instead. */
  answerValue?: GoogleCloudContactcenterinsightsV1QaAnswerAnswerValue;
  /** User-defined list of arbitrary tags. Matches the value from QaScorecard.ScorecardQuestion.tags. Used for grouping/organization and for weighting the score of each answer. */
  tags?: Array<string>;
  /** Lists all answer sources containing one or more answer values of a specific source type, e.g., all system-generated answer sources, or all manual edit answer sources. */
  answerSources?: Array<GoogleCloudContactcenterinsightsV1QaAnswerAnswerSource>;
}

export const GoogleCloudContactcenterinsightsV1QaAnswer: Schema.Schema<GoogleCloudContactcenterinsightsV1QaAnswer> = Schema.suspend(() => Schema.Struct({
  qaQuestion: Schema.optional(Schema.String),
  conversation: Schema.optional(Schema.String),
  questionBody: Schema.optional(Schema.String),
  answerValue: Schema.optional(GoogleCloudContactcenterinsightsV1QaAnswerAnswerValue),
  tags: Schema.optional(Schema.Array(Schema.String)),
  answerSources: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1QaAnswerAnswerSource)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QaAnswer" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QaAnswer>;

export interface GoogleCloudContactcenterinsightsV1QaScorecardResultQaTagResult {
  /** The tag the score applies to. */
  tag?: string;
  /** The score the tag applies to. */
  score?: number;
  /** The potential score the tag applies to. */
  potentialScore?: number;
  /** The normalized score the tag applies to. */
  normalizedScore?: number;
}

export const GoogleCloudContactcenterinsightsV1QaScorecardResultQaTagResult: Schema.Schema<GoogleCloudContactcenterinsightsV1QaScorecardResultQaTagResult> = Schema.suspend(() => Schema.Struct({
  tag: Schema.optional(Schema.String),
  score: Schema.optional(Schema.Number),
  potentialScore: Schema.optional(Schema.Number),
  normalizedScore: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QaScorecardResultQaTagResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QaScorecardResultQaTagResult>;

export interface GoogleCloudContactcenterinsightsV1QaScorecardResultScoreSource {
  /** What created the score. */
  sourceType?: "SOURCE_TYPE_UNSPECIFIED" | "SYSTEM_GENERATED_ONLY" | "INCLUDES_MANUAL_EDITS" | (string & {});
  /** The overall numerical score of the result. */
  score?: number;
  /** The maximum potential overall score of the scorecard. Any questions answered using `na_value` are excluded from this calculation. */
  potentialScore?: number;
  /** The normalized score, which is the score divided by the potential score. */
  normalizedScore?: number;
  /** Collection of tags and their scores. */
  qaTagResults?: Array<GoogleCloudContactcenterinsightsV1QaScorecardResultQaTagResult>;
}

export const GoogleCloudContactcenterinsightsV1QaScorecardResultScoreSource: Schema.Schema<GoogleCloudContactcenterinsightsV1QaScorecardResultScoreSource> = Schema.suspend(() => Schema.Struct({
  sourceType: Schema.optional(Schema.String),
  score: Schema.optional(Schema.Number),
  potentialScore: Schema.optional(Schema.Number),
  normalizedScore: Schema.optional(Schema.Number),
  qaTagResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1QaScorecardResultQaTagResult)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QaScorecardResultScoreSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QaScorecardResultScoreSource>;

export interface GoogleCloudContactcenterinsightsV1QaScorecardResult {
  /** Identifier. The name of the scorecard result. Format: projects/{project}/locations/{location}/qaScorecardResults/{qa_scorecard_result} */
  name?: string;
  /** The QaScorecardRevision scored by this result. */
  qaScorecardRevision?: string;
  /** The conversation scored by this result. */
  conversation?: string;
  /** Output only. The timestamp that the revision was created. */
  createTime?: string;
  /** ID of the agent that handled the conversation. */
  agentId?: string;
  /** Set of QaAnswers represented in the result. */
  qaAnswers?: Array<GoogleCloudContactcenterinsightsV1QaAnswer>;
  /** The overall numerical score of the result, incorporating any manual edits if they exist. */
  score?: number;
  /** The maximum potential overall score of the scorecard. Any questions answered using `na_value` are excluded from this calculation. */
  potentialScore?: number;
  /** The normalized score, which is the score divided by the potential score. Any manual edits are included if they exist. */
  normalizedScore?: number;
  /** Collection of tags and their scores. */
  qaTagResults?: Array<GoogleCloudContactcenterinsightsV1QaScorecardResultQaTagResult>;
  /** List of all individual score sets. */
  scoreSources?: Array<GoogleCloudContactcenterinsightsV1QaScorecardResultScoreSource>;
}

export const GoogleCloudContactcenterinsightsV1QaScorecardResult: Schema.Schema<GoogleCloudContactcenterinsightsV1QaScorecardResult> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  qaScorecardRevision: Schema.optional(Schema.String),
  conversation: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  agentId: Schema.optional(Schema.String),
  qaAnswers: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1QaAnswer)),
  score: Schema.optional(Schema.Number),
  potentialScore: Schema.optional(Schema.Number),
  normalizedScore: Schema.optional(Schema.Number),
  qaTagResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1QaScorecardResultQaTagResult)),
  scoreSources: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1QaScorecardResultScoreSource)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QaScorecardResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QaScorecardResult>;

export interface GoogleCloudContactcenterinsightsV1AnalysisResultCallAnalysisMetadata {
  /** A list of call annotations that apply to this call. */
  annotations?: Array<GoogleCloudContactcenterinsightsV1CallAnnotation>;
  /** All the entities in the call. */
  entities?: Record<string, GoogleCloudContactcenterinsightsV1Entity>;
  /** Overall conversation-level sentiment for each channel of the call. */
  sentiments?: Array<GoogleCloudContactcenterinsightsV1ConversationLevelSentiment>;
  /** Overall conversation-level silence during the call. */
  silence?: GoogleCloudContactcenterinsightsV1ConversationLevelSilence;
  /** All the matched intents in the call. */
  intents?: Record<string, GoogleCloudContactcenterinsightsV1Intent>;
  /** All the matched phrase matchers in the call. */
  phraseMatchers?: Record<string, GoogleCloudContactcenterinsightsV1PhraseMatchData>;
  /** Overall conversation-level issue modeling result. */
  issueModelResult?: GoogleCloudContactcenterinsightsV1IssueModelResult;
  /** Results of scoring QaScorecards. */
  qaScorecardResults?: Array<GoogleCloudContactcenterinsightsV1QaScorecardResult>;
}

export const GoogleCloudContactcenterinsightsV1AnalysisResultCallAnalysisMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1AnalysisResultCallAnalysisMetadata> = Schema.suspend(() => Schema.Struct({
  annotations: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1CallAnnotation)),
  entities: Schema.optional(Schema.Record(Schema.String, GoogleCloudContactcenterinsightsV1Entity)),
  sentiments: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1ConversationLevelSentiment)),
  silence: Schema.optional(GoogleCloudContactcenterinsightsV1ConversationLevelSilence),
  intents: Schema.optional(Schema.Record(Schema.String, GoogleCloudContactcenterinsightsV1Intent)),
  phraseMatchers: Schema.optional(Schema.Record(Schema.String, GoogleCloudContactcenterinsightsV1PhraseMatchData)),
  issueModelResult: Schema.optional(GoogleCloudContactcenterinsightsV1IssueModelResult),
  qaScorecardResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1QaScorecardResult)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1AnalysisResultCallAnalysisMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1AnalysisResultCallAnalysisMetadata>;

export interface GoogleCloudContactcenterinsightsV1AnalysisResult {
  /** Call-specific metadata created by the analysis. */
  callAnalysisMetadata?: GoogleCloudContactcenterinsightsV1AnalysisResultCallAnalysisMetadata;
  /** The time at which the analysis ended. */
  endTime?: string;
}

export const GoogleCloudContactcenterinsightsV1AnalysisResult: Schema.Schema<GoogleCloudContactcenterinsightsV1AnalysisResult> = Schema.suspend(() => Schema.Struct({
  callAnalysisMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1AnalysisResultCallAnalysisMetadata),
  endTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1AnalysisResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1AnalysisResult>;

export interface GoogleCloudContactcenterinsightsV1AnnotatorSelectorSummarizationConfig {
  /** Resource name of the Dialogflow conversation profile. Format: projects/{project}/locations/{location}/conversationProfiles/{conversation_profile} */
  conversationProfile?: string;
  /** Default summarization model to be used. */
  summarizationModel?: "SUMMARIZATION_MODEL_UNSPECIFIED" | "BASELINE_MODEL" | "BASELINE_MODEL_V2_0" | (string & {});
  /** The resource name of the existing created generator. Format: projects//locations//generators/ */
  generator?: string;
}

export const GoogleCloudContactcenterinsightsV1AnnotatorSelectorSummarizationConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1AnnotatorSelectorSummarizationConfig> = Schema.suspend(() => Schema.Struct({
  conversationProfile: Schema.optional(Schema.String),
  summarizationModel: Schema.optional(Schema.String),
  generator: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1AnnotatorSelectorSummarizationConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1AnnotatorSelectorSummarizationConfig>;

export interface GoogleCloudContactcenterinsightsV1AnnotatorSelectorQaConfigScorecardList {
  /** List of QaScorecardRevisions. */
  qaScorecardRevisions?: Array<string>;
}

export const GoogleCloudContactcenterinsightsV1AnnotatorSelectorQaConfigScorecardList: Schema.Schema<GoogleCloudContactcenterinsightsV1AnnotatorSelectorQaConfigScorecardList> = Schema.suspend(() => Schema.Struct({
  qaScorecardRevisions: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1AnnotatorSelectorQaConfigScorecardList" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1AnnotatorSelectorQaConfigScorecardList>;

export interface GoogleCloudContactcenterinsightsV1AnnotatorSelectorQaConfig {
  /** A manual list of scorecards to score. */
  scorecardList?: GoogleCloudContactcenterinsightsV1AnnotatorSelectorQaConfigScorecardList;
}

export const GoogleCloudContactcenterinsightsV1AnnotatorSelectorQaConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1AnnotatorSelectorQaConfig> = Schema.suspend(() => Schema.Struct({
  scorecardList: Schema.optional(GoogleCloudContactcenterinsightsV1AnnotatorSelectorQaConfigScorecardList),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1AnnotatorSelectorQaConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1AnnotatorSelectorQaConfig>;

export interface GoogleCloudContactcenterinsightsV1AnnotatorSelector {
  /** Whether to run the interruption annotator. */
  runInterruptionAnnotator?: boolean;
  /** Whether to run the silence annotator. */
  runSilenceAnnotator?: boolean;
  /** Whether to run the active phrase matcher annotator(s). */
  runPhraseMatcherAnnotator?: boolean;
  /** The list of phrase matchers to run. If not provided, all active phrase matchers will be used. If inactive phrase matchers are provided, they will not be used. Phrase matchers will be run only if run_phrase_matcher_annotator is set to true. Format: projects/{project}/locations/{location}/phraseMatchers/{phrase_matcher} */
  phraseMatchers?: Array<string>;
  /** Whether to run the sentiment annotator. */
  runSentimentAnnotator?: boolean;
  /** Whether to run the entity annotator. */
  runEntityAnnotator?: boolean;
  /** Whether to run the intent annotator. */
  runIntentAnnotator?: boolean;
  /** Whether to run the issue model annotator. A model should have already been deployed for this to take effect. */
  runIssueModelAnnotator?: boolean;
  /** The issue model to run. If not provided, the most recently deployed topic model will be used. The provided issue model will only be used for inference if the issue model is deployed and if run_issue_model_annotator is set to true. If more than one issue model is provided, only the first provided issue model will be used for inference. */
  issueModels?: Array<string>;
  /** Whether to run the summarization annotator. */
  runSummarizationAnnotator?: boolean;
  /** Configuration for the summarization annotator. */
  summarizationConfig?: GoogleCloudContactcenterinsightsV1AnnotatorSelectorSummarizationConfig;
  /** Whether to run the QA annotator. */
  runQaAnnotator?: boolean;
  /** Configuration for the QA annotator. */
  qaConfig?: GoogleCloudContactcenterinsightsV1AnnotatorSelectorQaConfig;
}

export const GoogleCloudContactcenterinsightsV1AnnotatorSelector: Schema.Schema<GoogleCloudContactcenterinsightsV1AnnotatorSelector> = Schema.suspend(() => Schema.Struct({
  runInterruptionAnnotator: Schema.optional(Schema.Boolean),
  runSilenceAnnotator: Schema.optional(Schema.Boolean),
  runPhraseMatcherAnnotator: Schema.optional(Schema.Boolean),
  phraseMatchers: Schema.optional(Schema.Array(Schema.String)),
  runSentimentAnnotator: Schema.optional(Schema.Boolean),
  runEntityAnnotator: Schema.optional(Schema.Boolean),
  runIntentAnnotator: Schema.optional(Schema.Boolean),
  runIssueModelAnnotator: Schema.optional(Schema.Boolean),
  issueModels: Schema.optional(Schema.Array(Schema.String)),
  runSummarizationAnnotator: Schema.optional(Schema.Boolean),
  summarizationConfig: Schema.optional(GoogleCloudContactcenterinsightsV1AnnotatorSelectorSummarizationConfig),
  runQaAnnotator: Schema.optional(Schema.Boolean),
  qaConfig: Schema.optional(GoogleCloudContactcenterinsightsV1AnnotatorSelectorQaConfig),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1AnnotatorSelector" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1AnnotatorSelector>;

export interface GoogleCloudContactcenterinsightsV1Analysis {
  /** Immutable. The resource name of the analysis. Format: projects/{project}/locations/{location}/conversations/{conversation}/analyses/{analysis} */
  name?: string;
  /** Output only. The time at which the analysis was requested. */
  requestTime?: string;
  /** Output only. The time at which the analysis was created, which occurs when the long-running operation completes. */
  createTime?: string;
  /** Output only. The result of the analysis, which is populated when the analysis finishes. */
  analysisResult?: GoogleCloudContactcenterinsightsV1AnalysisResult;
  /** To select the annotators to run and the phrase matchers to use (if any). If not specified, all annotators will be run. */
  annotatorSelector?: GoogleCloudContactcenterinsightsV1AnnotatorSelector;
}

export const GoogleCloudContactcenterinsightsV1Analysis: Schema.Schema<GoogleCloudContactcenterinsightsV1Analysis> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  requestTime: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  analysisResult: Schema.optional(GoogleCloudContactcenterinsightsV1AnalysisResult),
  annotatorSelector: Schema.optional(GoogleCloudContactcenterinsightsV1AnnotatorSelector),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1Analysis" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1Analysis>;

export interface GoogleCloudContactcenterinsightsV1ConversationSummarizationSuggestionData {
  /** The summarization content that is concatenated into one string. */
  text?: string;
  /** The summarization content that is divided into sections. The key is the section's name and the value is the section's content. There is no specific format for the key or value. */
  textSections?: Record<string, string>;
  /** The confidence score of the summarization. */
  confidence?: number;
  /** A map that contains metadata about the summarization and the document from which it originates. */
  metadata?: Record<string, string>;
  /** The name of the answer record. Format: projects/{project}/locations/{location}/answerRecords/{answer_record} */
  answerRecord?: string;
  /** The name of the model that generates this summary. Format: projects/{project}/locations/{location}/conversationModels/{conversation_model} */
  conversationModel?: string;
  /** Agent Assist generator ID. */
  generatorId?: string;
}

export const GoogleCloudContactcenterinsightsV1ConversationSummarizationSuggestionData: Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationSummarizationSuggestionData> = Schema.suspend(() => Schema.Struct({
  text: Schema.optional(Schema.String),
  textSections: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  confidence: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  answerRecord: Schema.optional(Schema.String),
  conversationModel: Schema.optional(Schema.String),
  generatorId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConversationSummarizationSuggestionData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationSummarizationSuggestionData>;

export interface GoogleCloudContactcenterinsightsV1ArticleSuggestionData {
  /** Article title. */
  title?: string;
  /** Article URI. */
  uri?: string;
  /** The system's confidence score that this article is a good match for this conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely certain). */
  confidenceScore?: number;
  /** Map that contains metadata about the Article Suggestion and the document that it originates from. */
  metadata?: Record<string, string>;
  /** The name of the answer record. Format: projects/{project}/locations/{location}/answerRecords/{answer_record} */
  queryRecord?: string;
  /** The knowledge document that this answer was extracted from. Format: projects/{project}/knowledgeBases/{knowledge_base}/documents/{document} */
  source?: string;
}

export const GoogleCloudContactcenterinsightsV1ArticleSuggestionData: Schema.Schema<GoogleCloudContactcenterinsightsV1ArticleSuggestionData> = Schema.suspend(() => Schema.Struct({
  title: Schema.optional(Schema.String),
  uri: Schema.optional(Schema.String),
  confidenceScore: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  queryRecord: Schema.optional(Schema.String),
  source: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ArticleSuggestionData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ArticleSuggestionData>;

export interface GoogleCloudContactcenterinsightsV1FaqAnswerData {
  /** The piece of text from the `source` knowledge base document. */
  answer?: string;
  /** The system's confidence score that this answer is a good match for this conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely certain). */
  confidenceScore?: number;
  /** The corresponding FAQ question. */
  question?: string;
  /** Map that contains metadata about the FAQ answer and the document that it originates from. */
  metadata?: Record<string, string>;
  /** The name of the answer record. Format: projects/{project}/locations/{location}/answerRecords/{answer_record} */
  queryRecord?: string;
  /** The knowledge document that this answer was extracted from. Format: projects/{project}/knowledgeBases/{knowledge_base}/documents/{document}. */
  source?: string;
}

export const GoogleCloudContactcenterinsightsV1FaqAnswerData: Schema.Schema<GoogleCloudContactcenterinsightsV1FaqAnswerData> = Schema.suspend(() => Schema.Struct({
  answer: Schema.optional(Schema.String),
  confidenceScore: Schema.optional(Schema.Number),
  question: Schema.optional(Schema.String),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  queryRecord: Schema.optional(Schema.String),
  source: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1FaqAnswerData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1FaqAnswerData>;

export interface GoogleCloudContactcenterinsightsV1SmartReplyData {
  /** The content of the reply. */
  reply?: string;
  /** The system's confidence score that this reply is a good match for this conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely certain). */
  confidenceScore?: number;
  /** Map that contains metadata about the Smart Reply and the document from which it originates. */
  metadata?: Record<string, string>;
  /** The name of the answer record. Format: projects/{project}/locations/{location}/answerRecords/{answer_record} */
  queryRecord?: string;
}

export const GoogleCloudContactcenterinsightsV1SmartReplyData: Schema.Schema<GoogleCloudContactcenterinsightsV1SmartReplyData> = Schema.suspend(() => Schema.Struct({
  reply: Schema.optional(Schema.String),
  confidenceScore: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  queryRecord: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1SmartReplyData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1SmartReplyData>;

export interface GoogleCloudContactcenterinsightsV1SmartComposeSuggestionData {
  /** The content of the suggestion. */
  suggestion?: string;
  /** The system's confidence score that this suggestion is a good match for this conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely certain). */
  confidenceScore?: number;
  /** Map that contains metadata about the Smart Compose suggestion and the document from which it originates. */
  metadata?: Record<string, string>;
  /** The name of the answer record. Format: projects/{project}/locations/{location}/answerRecords/{answer_record} */
  queryRecord?: string;
}

export const GoogleCloudContactcenterinsightsV1SmartComposeSuggestionData: Schema.Schema<GoogleCloudContactcenterinsightsV1SmartComposeSuggestionData> = Schema.suspend(() => Schema.Struct({
  suggestion: Schema.optional(Schema.String),
  confidenceScore: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  queryRecord: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1SmartComposeSuggestionData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1SmartComposeSuggestionData>;

export interface GoogleCloudContactcenterinsightsV1DialogflowInteractionData {
  /** The Dialogflow intent resource path. Format: projects/{project}/agent/{agent}/intents/{intent} */
  dialogflowIntentId?: string;
  /** The confidence of the match ranging from 0.0 (completely uncertain) to 1.0 (completely certain). */
  confidence?: number;
}

export const GoogleCloudContactcenterinsightsV1DialogflowInteractionData: Schema.Schema<GoogleCloudContactcenterinsightsV1DialogflowInteractionData> = Schema.suspend(() => Schema.Struct({
  dialogflowIntentId: Schema.optional(Schema.String),
  confidence: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DialogflowInteractionData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DialogflowInteractionData>;

export interface GoogleCloudContactcenterinsightsV1AnswerFeedback {
  /** The correctness level of an answer. */
  correctnessLevel?: "CORRECTNESS_LEVEL_UNSPECIFIED" | "NOT_CORRECT" | "PARTIALLY_CORRECT" | "FULLY_CORRECT" | (string & {});
  /** Indicates whether an answer or item was clicked by the human agent. */
  clicked?: boolean;
  /** Indicates whether an answer or item was displayed to the human agent in the agent desktop UI. */
  displayed?: boolean;
}

export const GoogleCloudContactcenterinsightsV1AnswerFeedback: Schema.Schema<GoogleCloudContactcenterinsightsV1AnswerFeedback> = Schema.suspend(() => Schema.Struct({
  correctnessLevel: Schema.optional(Schema.String),
  clicked: Schema.optional(Schema.Boolean),
  displayed: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1AnswerFeedback" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1AnswerFeedback>;

export interface GoogleCloudContactcenterinsightsV1RuntimeAnnotationUserInput {
  /** Query text. Article Search uses this to store the input query used to generate the search results. */
  query?: string;
  /** The resource name of associated generator. Format: `projects//locations//generators/` */
  generatorName?: string;
  /** Query source for the answer. */
  querySource?: "QUERY_SOURCE_UNSPECIFIED" | "AGENT_QUERY" | "SUGGESTED_QUERY" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1RuntimeAnnotationUserInput: Schema.Schema<GoogleCloudContactcenterinsightsV1RuntimeAnnotationUserInput> = Schema.suspend(() => Schema.Struct({
  query: Schema.optional(Schema.String),
  generatorName: Schema.optional(Schema.String),
  querySource: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1RuntimeAnnotationUserInput" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1RuntimeAnnotationUserInput>;

export interface GoogleCloudContactcenterinsightsV1RuntimeAnnotation {
  /** Agent Assist Article Suggestion data. */
  articleSuggestion?: GoogleCloudContactcenterinsightsV1ArticleSuggestionData;
  /** Agent Assist FAQ answer data. */
  faqAnswer?: GoogleCloudContactcenterinsightsV1FaqAnswerData;
  /** Agent Assist Smart Reply data. */
  smartReply?: GoogleCloudContactcenterinsightsV1SmartReplyData;
  /** Agent Assist Smart Compose suggestion data. */
  smartComposeSuggestion?: GoogleCloudContactcenterinsightsV1SmartComposeSuggestionData;
  /** Dialogflow interaction data. */
  dialogflowInteraction?: GoogleCloudContactcenterinsightsV1DialogflowInteractionData;
  /** Conversation summarization suggestion data. */
  conversationSummarizationSuggestion?: GoogleCloudContactcenterinsightsV1ConversationSummarizationSuggestionData;
  /** The unique identifier of the annotation. Format: projects/{project}/locations/{location}/conversationDatasets/{dataset}/conversationDataItems/{data_item}/conversationAnnotations/{annotation} */
  annotationId?: string;
  /** The time at which this annotation was created. */
  createTime?: string;
  /** The boundary in the conversation where the annotation starts, inclusive. */
  startBoundary?: GoogleCloudContactcenterinsightsV1AnnotationBoundary;
  /** The boundary in the conversation where the annotation ends, inclusive. */
  endBoundary?: GoogleCloudContactcenterinsightsV1AnnotationBoundary;
  /** The feedback that the customer has about the answer in `data`. */
  answerFeedback?: GoogleCloudContactcenterinsightsV1AnswerFeedback;
  /** Explicit input used for generating the answer */
  userInput?: GoogleCloudContactcenterinsightsV1RuntimeAnnotationUserInput;
}

export const GoogleCloudContactcenterinsightsV1RuntimeAnnotation: Schema.Schema<GoogleCloudContactcenterinsightsV1RuntimeAnnotation> = Schema.suspend(() => Schema.Struct({
  articleSuggestion: Schema.optional(GoogleCloudContactcenterinsightsV1ArticleSuggestionData),
  faqAnswer: Schema.optional(GoogleCloudContactcenterinsightsV1FaqAnswerData),
  smartReply: Schema.optional(GoogleCloudContactcenterinsightsV1SmartReplyData),
  smartComposeSuggestion: Schema.optional(GoogleCloudContactcenterinsightsV1SmartComposeSuggestionData),
  dialogflowInteraction: Schema.optional(GoogleCloudContactcenterinsightsV1DialogflowInteractionData),
  conversationSummarizationSuggestion: Schema.optional(GoogleCloudContactcenterinsightsV1ConversationSummarizationSuggestionData),
  annotationId: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  startBoundary: Schema.optional(GoogleCloudContactcenterinsightsV1AnnotationBoundary),
  endBoundary: Schema.optional(GoogleCloudContactcenterinsightsV1AnnotationBoundary),
  answerFeedback: Schema.optional(GoogleCloudContactcenterinsightsV1AnswerFeedback),
  userInput: Schema.optional(GoogleCloudContactcenterinsightsV1RuntimeAnnotationUserInput),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1RuntimeAnnotation" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1RuntimeAnnotation>;

export interface GoogleCloudContactcenterinsightsV1DialogflowIntent {
  /** The human-readable name of the intent. */
  displayName?: string;
}

export const GoogleCloudContactcenterinsightsV1DialogflowIntent: Schema.Schema<GoogleCloudContactcenterinsightsV1DialogflowIntent> = Schema.suspend(() => Schema.Struct({
  displayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DialogflowIntent" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DialogflowIntent>;

export interface GoogleCloudContactcenterinsightsV1ConversationCorrelationInfo {
  /** Output only. The full conversation correlation id this conversation is a segment of. */
  fullConversationCorrelationId?: string;
  /** Output only. The full conversation correlation id this conversation is a merged conversation of. */
  mergedFullConversationCorrelationId?: string;
  /** Output only. The correlation types of this conversation. A single conversation can have multiple correlation types. For example a conversation that only has a single segment is both a SEGMENT and a FULL_CONVERSATION. */
  correlationTypes?: Array<"CORRELATION_TYPE_UNSPECIFIED" | "SEGMENT" | "PARTIAL" | "FULL" | "SYNTHETIC" | (string & {})>;
}

export const GoogleCloudContactcenterinsightsV1ConversationCorrelationInfo: Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationCorrelationInfo> = Schema.suspend(() => Schema.Struct({
  fullConversationCorrelationId: Schema.optional(Schema.String),
  mergedFullConversationCorrelationId: Schema.optional(Schema.String),
  correlationTypes: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConversationCorrelationInfo" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationCorrelationInfo>;

export interface GoogleCloudContactcenterinsightsV1Conversation {
  /** Call-specific metadata. */
  callMetadata?: GoogleCloudContactcenterinsightsV1ConversationCallMetadata;
  /** The time at which this conversation should expire. After this time, the conversation data and any associated analyses will be deleted. */
  expireTime?: string;
  /** Input only. The TTL for this resource. If specified, then this TTL will be used to calculate the expire time. */
  ttl?: string;
  /** Immutable. The resource name of the conversation. Format: projects/{project}/locations/{location}/conversations/{conversation} */
  name?: string;
  /** The source of the audio and transcription for the conversation. */
  dataSource?: GoogleCloudContactcenterinsightsV1ConversationDataSource;
  /** Output only. The time at which the conversation was created. */
  createTime?: string;
  /** Output only. The most recent time at which the conversation was updated. */
  updateTime?: string;
  /** The time at which the conversation started. */
  startTime?: string;
  /** A user-specified language code for the conversation. */
  languageCode?: string;
  /** An opaque, user-specified string representing the human agent who handled the conversation. */
  agentId?: string;
  /** A map for the user to specify any custom fields. A maximum of 100 labels per conversation is allowed, with a maximum of 256 characters per entry. */
  labels?: Record<string, string>;
  /** Conversation metadata related to quality management. */
  qualityMetadata?: GoogleCloudContactcenterinsightsV1ConversationQualityMetadata;
  /** Input only. JSON metadata encoded as a string. This field is primarily used by Insights integrations with various telephony systems and must be in one of Insight's supported formats. */
  metadataJson?: string;
  /** Output only. The conversation transcript. */
  transcript?: GoogleCloudContactcenterinsightsV1ConversationTranscript;
  /** Immutable. The conversation medium. */
  medium?: "MEDIUM_UNSPECIFIED" | "PHONE_CALL" | "CHAT" | (string & {});
  /** Output only. The duration of the conversation. */
  duration?: string;
  /** Output only. The number of turns in the conversation. */
  turnCount?: number;
  /** Output only. The conversation's latest analysis, if one exists. */
  latestAnalysis?: GoogleCloudContactcenterinsightsV1Analysis;
  /** Output only. Latest summary of the conversation. */
  latestSummary?: GoogleCloudContactcenterinsightsV1ConversationSummarizationSuggestionData;
  /** Output only. The annotations that were generated during the customer and agent interaction. */
  runtimeAnnotations?: Array<GoogleCloudContactcenterinsightsV1RuntimeAnnotation>;
  /** Output only. All the matched Dialogflow intents in the call. The key corresponds to a Dialogflow intent, format: projects/{project}/agent/{agent}/intents/{intent} */
  dialogflowIntents?: Record<string, GoogleCloudContactcenterinsightsV1DialogflowIntent>;
  /** Obfuscated user ID which the customer sent to us. */
  obfuscatedUserId?: string;
  /** Output only. Info for correlating across conversations. */
  correlationInfo?: GoogleCloudContactcenterinsightsV1ConversationCorrelationInfo;
}

export const GoogleCloudContactcenterinsightsV1Conversation: Schema.Schema<GoogleCloudContactcenterinsightsV1Conversation> = Schema.suspend(() => Schema.Struct({
  callMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1ConversationCallMetadata),
  expireTime: Schema.optional(Schema.String),
  ttl: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  dataSource: Schema.optional(GoogleCloudContactcenterinsightsV1ConversationDataSource),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  startTime: Schema.optional(Schema.String),
  languageCode: Schema.optional(Schema.String),
  agentId: Schema.optional(Schema.String),
  labels: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  qualityMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1ConversationQualityMetadata),
  metadataJson: Schema.optional(Schema.String),
  transcript: Schema.optional(GoogleCloudContactcenterinsightsV1ConversationTranscript),
  medium: Schema.optional(Schema.String),
  duration: Schema.optional(Schema.String),
  turnCount: Schema.optional(Schema.Number),
  latestAnalysis: Schema.optional(GoogleCloudContactcenterinsightsV1Analysis),
  latestSummary: Schema.optional(GoogleCloudContactcenterinsightsV1ConversationSummarizationSuggestionData),
  runtimeAnnotations: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1RuntimeAnnotation)),
  dialogflowIntents: Schema.optional(Schema.Record(Schema.String, GoogleCloudContactcenterinsightsV1DialogflowIntent)),
  obfuscatedUserId: Schema.optional(Schema.String),
  correlationInfo: Schema.optional(GoogleCloudContactcenterinsightsV1ConversationCorrelationInfo),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1Conversation" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1Conversation>;

export interface GoogleCloudContactcenterinsightsV1RedactionConfig {
  /** The fully-qualified DLP deidentify template resource name. Format: `projects/{project}/deidentifyTemplates/{template}` */
  deidentifyTemplate?: string;
  /** The fully-qualified DLP inspect template resource name. Format: `projects/{project}/locations/{location}/inspectTemplates/{template}` */
  inspectTemplate?: string;
}

export const GoogleCloudContactcenterinsightsV1RedactionConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1RedactionConfig> = Schema.suspend(() => Schema.Struct({
  deidentifyTemplate: Schema.optional(Schema.String),
  inspectTemplate: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1RedactionConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1RedactionConfig>;

export interface GoogleCloudContactcenterinsightsV1SpeechConfig {
  /** The fully-qualified Speech Recognizer resource name. Format: `projects/{project_id}/locations/{location}/recognizer/{recognizer}` */
  speechRecognizer?: string;
  /** Whether to disable word time offsets. If true, the `enable_word_time_offsets` field in the recognition config will be set to false. */
  disableWordTimeOffsets?: boolean;
}

export const GoogleCloudContactcenterinsightsV1SpeechConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1SpeechConfig> = Schema.suspend(() => Schema.Struct({
  speechRecognizer: Schema.optional(Schema.String),
  disableWordTimeOffsets: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1SpeechConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1SpeechConfig>;

export interface GoogleCloudContactcenterinsightsV1UploadConversationRequest {
  /** Required. The parent resource of the conversation. */
  parent?: string;
  /** Required. The conversation resource to create. */
  conversation?: GoogleCloudContactcenterinsightsV1Conversation;
  /** Optional. A unique ID for the new conversation. This ID will become the final component of the conversation's resource name. If no ID is specified, a server-generated ID will be used. This value should be 4-64 characters and must match the regular expression `^[a-z0-9-]{4,64}$`. Valid characters are `a-z-` */
  conversationId?: string;
  /** Optional. DLP settings for transcript redaction. Will default to the config specified in Settings. */
  redactionConfig?: GoogleCloudContactcenterinsightsV1RedactionConfig;
  /** Optional. Speech-to-Text configuration. Will default to the config specified in Settings. */
  speechConfig?: GoogleCloudContactcenterinsightsV1SpeechConfig;
}

export const GoogleCloudContactcenterinsightsV1UploadConversationRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1UploadConversationRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  conversation: Schema.optional(GoogleCloudContactcenterinsightsV1Conversation),
  conversationId: Schema.optional(Schema.String),
  redactionConfig: Schema.optional(GoogleCloudContactcenterinsightsV1RedactionConfig),
  speechConfig: Schema.optional(GoogleCloudContactcenterinsightsV1SpeechConfig),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1UploadConversationRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1UploadConversationRequest>;

export interface GoogleCloudContactcenterinsightsV1ListConversationsResponse {
  /** The conversations that match the request. */
  conversations?: Array<GoogleCloudContactcenterinsightsV1Conversation>;
  /** A token which can be sent as `page_token` to retrieve the next page. If this field is set, it means there is another page available. If it is not set, it means no other pages are available. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListConversationsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListConversationsResponse> = Schema.suspend(() => Schema.Struct({
  conversations: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1Conversation)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListConversationsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListConversationsResponse>;

export interface GoogleCloudContactcenterinsightsV1ConversationDataSourceTurnLevelAudio {
  /** The Cloud Storage URI of the audio for any given turn. */
  audioGcsUri?: string;
  /** The duration of the audio. */
  audioDuration?: string;
}

export const GoogleCloudContactcenterinsightsV1ConversationDataSourceTurnLevelAudio: Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationDataSourceTurnLevelAudio> = Schema.suspend(() => Schema.Struct({
  audioGcsUri: Schema.optional(Schema.String),
  audioDuration: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConversationDataSourceTurnLevelAudio" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationDataSourceTurnLevelAudio>;

export interface GoogleCloudContactcenterinsightsV1SignedAudioUris {
  /** The signed URI for the audio from the Cloud Storage conversation source. */
  signedGcsAudioUri?: string;
  /** The signed URI for the audio from the Dialogflow conversation source. */
  signedDialogflowAudioUri?: string;
  /** The signed URI for the audio corresponding to each turn in the conversation. */
  signedTurnLevelAudios?: Array<GoogleCloudContactcenterinsightsV1ConversationDataSourceTurnLevelAudio>;
}

export const GoogleCloudContactcenterinsightsV1SignedAudioUris: Schema.Schema<GoogleCloudContactcenterinsightsV1SignedAudioUris> = Schema.suspend(() => Schema.Struct({
  signedGcsAudioUri: Schema.optional(Schema.String),
  signedDialogflowAudioUri: Schema.optional(Schema.String),
  signedTurnLevelAudios: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1ConversationDataSourceTurnLevelAudio)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1SignedAudioUris" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1SignedAudioUris>;

export interface GoogleCloudContactcenterinsightsV1GenerateConversationSignedAudioResponse {
  /** The signed uris for the audio. */
  signedAudioUris?: GoogleCloudContactcenterinsightsV1SignedAudioUris;
}

export const GoogleCloudContactcenterinsightsV1GenerateConversationSignedAudioResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerateConversationSignedAudioResponse> = Schema.suspend(() => Schema.Struct({
  signedAudioUris: Schema.optional(GoogleCloudContactcenterinsightsV1SignedAudioUris),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerateConversationSignedAudioResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerateConversationSignedAudioResponse>;

export interface GoogleCloudContactcenterinsightsV1Dataset {
  /** Immutable. Identifier. Resource name of the dataset. Format: projects/{project}/locations/{location}/datasets/{dataset} */
  name?: string;
  /** Display name for the dataaset */
  displayName?: string;
  /** Dataset description. */
  description?: string;
  /** Dataset usage type. */
  type?: "TYPE_UNSPECIFIED" | "EVAL" | "LIVE" | (string & {});
  /** Optional. Option TTL for the dataset. */
  ttl?: string;
  /** Output only. Dataset create time. */
  createTime?: string;
  /** Output only. Dataset update time. */
  updateTime?: string;
}

export const GoogleCloudContactcenterinsightsV1Dataset: Schema.Schema<GoogleCloudContactcenterinsightsV1Dataset> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  ttl: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1Dataset" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1Dataset>;

export interface GoogleCloudContactcenterinsightsV1ListDatasetsResponse {
  /** The datasets that match the request. */
  datasets?: Array<GoogleCloudContactcenterinsightsV1Dataset>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListDatasetsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListDatasetsResponse> = Schema.suspend(() => Schema.Struct({
  datasets: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1Dataset)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListDatasetsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListDatasetsResponse>;

export interface GoogleCloudContactcenterinsightsV1SampleRule {
  /** Percentage of conversations that we should sample based on the dimension between [0, 100]. */
  samplePercentage?: number;
  /** Number of the conversations that we should sample based on the dimension. */
  sampleRow?: string;
  /** Optional. Group by dimension to sample the conversation. If no dimension is provided, the sampling will be applied to the project level. Current supported dimensions is 'quality_metadata.agent_info.agent_id'. */
  dimension?: string;
  /** To specify the filter for the conversions that should apply this sample rule. An empty filter means this sample rule applies to all conversations. */
  conversationFilter?: string;
}

export const GoogleCloudContactcenterinsightsV1SampleRule: Schema.Schema<GoogleCloudContactcenterinsightsV1SampleRule> = Schema.suspend(() => Schema.Struct({
  samplePercentage: Schema.optional(Schema.Number),
  sampleRow: Schema.optional(Schema.String),
  dimension: Schema.optional(Schema.String),
  conversationFilter: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1SampleRule" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1SampleRule>;

export interface GoogleCloudContactcenterinsightsV1SampleConversationsRequest {
  /** The dataset resource to copy the sampled conversations to. */
  destinationDataset?: GoogleCloudContactcenterinsightsV1Dataset;
  /** Required. The parent resource of the dataset. */
  parent?: string;
  /** Optional. The sample rule used for sampling conversations. */
  sampleRule?: GoogleCloudContactcenterinsightsV1SampleRule;
}

export const GoogleCloudContactcenterinsightsV1SampleConversationsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1SampleConversationsRequest> = Schema.suspend(() => Schema.Struct({
  destinationDataset: Schema.optional(GoogleCloudContactcenterinsightsV1Dataset),
  parent: Schema.optional(Schema.String),
  sampleRule: Schema.optional(GoogleCloudContactcenterinsightsV1SampleRule),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1SampleConversationsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1SampleConversationsRequest>;

export interface GoogleCloudContactcenterinsightsV1ListAnalysesResponse {
  /** The analyses that match the request. */
  analyses?: Array<GoogleCloudContactcenterinsightsV1Analysis>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListAnalysesResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListAnalysesResponse> = Schema.suspend(() => Schema.Struct({
  analyses: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1Analysis)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListAnalysesResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListAnalysesResponse>;

export interface GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsRequest {
  /** Required. The parent resource to create analyses in. */
  parent?: string;
  /** Required. Filter used to select the subset of conversations to analyze. */
  filter?: string;
  /** Required. Percentage of selected conversation to analyze, between [0, 100]. */
  analysisPercentage?: number;
  /** To select the annotators to run and the phrase matchers to use (if any). If not specified, all annotators will be run. */
  annotatorSelector?: GoogleCloudContactcenterinsightsV1AnnotatorSelector;
}

export const GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
  analysisPercentage: Schema.optional(Schema.Number),
  annotatorSelector: Schema.optional(GoogleCloudContactcenterinsightsV1AnnotatorSelector),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsRequest>;

export interface GoogleCloudContactcenterinsightsV1BulkDeleteConversationsRequest {
  /** Required. The parent resource to delete conversations from. Format: projects/{project}/locations/{location} */
  parent?: string;
  /** Filter used to select the subset of conversations to delete. */
  filter?: string;
  /** Maximum number of conversations to delete. */
  maxDeleteCount?: number;
  /** If set to true, all of this conversation's analyses will also be deleted. Otherwise, the request will only succeed if the conversation has no analyses. */
  force?: boolean;
}

export const GoogleCloudContactcenterinsightsV1BulkDeleteConversationsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDeleteConversationsRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
  maxDeleteCount: Schema.optional(Schema.Number),
  force: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1BulkDeleteConversationsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDeleteConversationsRequest>;

export interface GoogleCloudContactcenterinsightsV1IngestConversationsRequestGcsSource {
  /** Optional. The Cloud Storage bucket containing source objects. Avoid passing this. Pass this through one of `transcript_bucket_uri` or `audio_bucket_uri`. */
  bucketUri?: string;
  /** Optional. Specifies the type of the objects in `bucket_uri`. Avoid passing this. This is inferred from the `transcript_bucket_uri`, `audio_bucket_uri`. */
  bucketObjectType?: "BUCKET_OBJECT_TYPE_UNSPECIFIED" | "TRANSCRIPT" | "AUDIO" | (string & {});
  /** Optional. The Cloud Storage path to the conversation transcripts. Note that: [1] Transcript files are expected to be in JSON format. [2] Transcript, audio, metadata files must be in separate buckets / folders. [3] A source file and its corresponding metadata file must share the same name to be properly ingested, E.g. `gs://bucket/audio/conversation1.mp3` and `gs://bucket/metadata/conversation1.json`. */
  transcriptBucketUri?: string;
  /** Optional. The Cloud Storage path to the conversation audio file. Note that: [1] Audio files will be transcribed if not already. [2] Audio files and transcript files must be in separate buckets / folders. [3] A source file and its corresponding audio file must share the same name to be properly ingested, E.g. `gs://bucket/transcript/conversation1.json` and `gs://bucket/audio/conversation1.mp3`. */
  audioBucketUri?: string;
  /** Optional. The Cloud Storage path to the conversation metadata. Note that: [1] Metadata files are expected to be in JSON format. [2] Metadata and source files (transcripts or audio) must be in separate buckets / folders. [3] A source file and its corresponding metadata file must share the same name to be properly ingested, E.g. `gs://bucket/audio/conversation1.mp3` and `gs://bucket/metadata/conversation1.json`. */
  metadataBucketUri?: string;
  /** Optional. Custom keys to extract as conversation labels from metadata files in `metadata_bucket_uri`. Keys not included in this field will be ignored. Note that there is a limit of 100 labels per conversation. */
  customMetadataKeys?: Array<string>;
}

export const GoogleCloudContactcenterinsightsV1IngestConversationsRequestGcsSource: Schema.Schema<GoogleCloudContactcenterinsightsV1IngestConversationsRequestGcsSource> = Schema.suspend(() => Schema.Struct({
  bucketUri: Schema.optional(Schema.String),
  bucketObjectType: Schema.optional(Schema.String),
  transcriptBucketUri: Schema.optional(Schema.String),
  audioBucketUri: Schema.optional(Schema.String),
  metadataBucketUri: Schema.optional(Schema.String),
  customMetadataKeys: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1IngestConversationsRequestGcsSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1IngestConversationsRequestGcsSource>;

export interface GoogleCloudContactcenterinsightsV1IngestConversationsRequestTranscriptObjectConfig {
  /** Required. The medium transcript objects represent. */
  medium?: "MEDIUM_UNSPECIFIED" | "PHONE_CALL" | "CHAT" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1IngestConversationsRequestTranscriptObjectConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1IngestConversationsRequestTranscriptObjectConfig> = Schema.suspend(() => Schema.Struct({
  medium: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1IngestConversationsRequestTranscriptObjectConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1IngestConversationsRequestTranscriptObjectConfig>;

export interface GoogleCloudContactcenterinsightsV1IngestConversationsRequestConversationConfig {
  /** Optional. An opaque, user-specified string representing a human agent who handled all conversations in the import. Note that this will be overridden if per-conversation metadata is provided through the `metadata_bucket_uri`. */
  agentId?: string;
  /** Optional. Indicates which of the channels, 1 or 2, contains the agent. Note that this must be set for conversations to be properly displayed and analyzed. */
  agentChannel?: number;
  /** Optional. Indicates which of the channels, 1 or 2, contains the agent. Note that this must be set for conversations to be properly displayed and analyzed. */
  customerChannel?: number;
}

export const GoogleCloudContactcenterinsightsV1IngestConversationsRequestConversationConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1IngestConversationsRequestConversationConfig> = Schema.suspend(() => Schema.Struct({
  agentId: Schema.optional(Schema.String),
  agentChannel: Schema.optional(Schema.Number),
  customerChannel: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1IngestConversationsRequestConversationConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1IngestConversationsRequestConversationConfig>;

export interface GoogleCloudContactcenterinsightsV1IngestConversationsRequest {
  /** A cloud storage bucket source. Note that any previously ingested objects from the source will be skipped to avoid duplication. */
  gcsSource?: GoogleCloudContactcenterinsightsV1IngestConversationsRequestGcsSource;
  /** Configuration for when `source` contains conversation transcripts. */
  transcriptObjectConfig?: GoogleCloudContactcenterinsightsV1IngestConversationsRequestTranscriptObjectConfig;
  /** Required. The parent resource for new conversations. */
  parent?: string;
  /** Configuration that applies to all conversations. */
  conversationConfig?: GoogleCloudContactcenterinsightsV1IngestConversationsRequestConversationConfig;
  /** Optional. DLP settings for transcript redaction. Optional, will default to the config specified in Settings. */
  redactionConfig?: GoogleCloudContactcenterinsightsV1RedactionConfig;
  /** Optional. Default Speech-to-Text configuration. Optional, will default to the config specified in Settings. */
  speechConfig?: GoogleCloudContactcenterinsightsV1SpeechConfig;
  /** Optional. If set, this fields indicates the number of objects to ingest from the Cloud Storage bucket. If empty, the entire bucket will be ingested. Unless they are first deleted, conversations produced through sampling won't be ingested by subsequent ingest requests. */
  sampleSize?: number;
}

export const GoogleCloudContactcenterinsightsV1IngestConversationsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1IngestConversationsRequest> = Schema.suspend(() => Schema.Struct({
  gcsSource: Schema.optional(GoogleCloudContactcenterinsightsV1IngestConversationsRequestGcsSource),
  transcriptObjectConfig: Schema.optional(GoogleCloudContactcenterinsightsV1IngestConversationsRequestTranscriptObjectConfig),
  parent: Schema.optional(Schema.String),
  conversationConfig: Schema.optional(GoogleCloudContactcenterinsightsV1IngestConversationsRequestConversationConfig),
  redactionConfig: Schema.optional(GoogleCloudContactcenterinsightsV1RedactionConfig),
  speechConfig: Schema.optional(GoogleCloudContactcenterinsightsV1SpeechConfig),
  sampleSize: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1IngestConversationsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1IngestConversationsRequest>;

export interface GoogleCloudContactcenterinsightsV1ExportInsightsDataRequestBigQueryDestination {
  /** A project ID or number. If specified, then export will attempt to write data to this project instead of the resource project. Otherwise, the resource project will be used. */
  projectId?: string;
  /** Required. The name of the BigQuery dataset that the snapshot result should be exported to. If this dataset does not exist, the export call returns an INVALID_ARGUMENT error. */
  dataset?: string;
  /** The BigQuery table name to which the insights data should be written. If this table does not exist, the export call returns an INVALID_ARGUMENT error. */
  table?: string;
}

export const GoogleCloudContactcenterinsightsV1ExportInsightsDataRequestBigQueryDestination: Schema.Schema<GoogleCloudContactcenterinsightsV1ExportInsightsDataRequestBigQueryDestination> = Schema.suspend(() => Schema.Struct({
  projectId: Schema.optional(Schema.String),
  dataset: Schema.optional(Schema.String),
  table: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ExportInsightsDataRequestBigQueryDestination" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ExportInsightsDataRequestBigQueryDestination>;

export interface GoogleCloudContactcenterinsightsV1ExportInsightsDataRequest {
  /** Specified if sink is a BigQuery table. */
  bigQueryDestination?: GoogleCloudContactcenterinsightsV1ExportInsightsDataRequestBigQueryDestination;
  /** Required. The parent resource to export data from. */
  parent?: string;
  /** A filter to reduce results to a specific subset. Useful for exporting conversations with specific properties. */
  filter?: string;
  /** A fully qualified KMS key name for BigQuery tables protected by CMEK. Format: projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{key}/cryptoKeyVersions/{version} */
  kmsKey?: string;
  /** Options for what to do if the destination table already exists. */
  writeDisposition?: "WRITE_DISPOSITION_UNSPECIFIED" | "WRITE_TRUNCATE" | "WRITE_APPEND" | (string & {});
  /** Optional. Version of the export schema. */
  exportSchemaVersion?: "EXPORT_SCHEMA_VERSION_UNSPECIFIED" | "EXPORT_V1" | "EXPORT_V2" | "EXPORT_V3" | "EXPORT_V4" | "EXPORT_V5" | "EXPORT_V6" | "EXPORT_V7" | "EXPORT_V8" | "EXPORT_V9" | "EXPORT_V10" | "EXPORT_V11" | "EXPORT_V12" | "EXPORT_V13" | "EXPORT_V14" | "EXPORT_V15" | "EXPORT_V16" | "EXPORT_V17" | "EXPORT_VERSION_LATEST_AVAILABLE" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1ExportInsightsDataRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1ExportInsightsDataRequest> = Schema.suspend(() => Schema.Struct({
  bigQueryDestination: Schema.optional(GoogleCloudContactcenterinsightsV1ExportInsightsDataRequestBigQueryDestination),
  parent: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
  kmsKey: Schema.optional(Schema.String),
  writeDisposition: Schema.optional(Schema.String),
  exportSchemaVersion: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ExportInsightsDataRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ExportInsightsDataRequest>;

export interface GoogleCloudContactcenterinsightsV1IssueModelInputDataConfig {
  /** Medium of conversations used in training data. This field is being deprecated. To specify the medium to be used in training a new issue model, set the `medium` field on `filter`. */
  medium?: "MEDIUM_UNSPECIFIED" | "PHONE_CALL" | "CHAT" | (string & {});
  /** Output only. Number of conversations used in training. Output only. */
  trainingConversationsCount?: string;
  /** A filter to reduce the conversations used for training the model to a specific subset. Refer to https://cloud.google.com/contact-center/insights/docs/filtering for details. */
  filter?: string;
}

export const GoogleCloudContactcenterinsightsV1IssueModelInputDataConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1IssueModelInputDataConfig> = Schema.suspend(() => Schema.Struct({
  medium: Schema.optional(Schema.String),
  trainingConversationsCount: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1IssueModelInputDataConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1IssueModelInputDataConfig>;

export interface GoogleCloudContactcenterinsightsV1IssueModelLabelStatsIssueStats {
  /** Issue resource. Format: projects/{project}/locations/{location}/issueModels/{issue_model}/issues/{issue} */
  issue?: string;
  /** Number of conversations attached to the issue at this point in time. */
  labeledConversationsCount?: string;
  /** Display name of the issue. */
  displayName?: string;
}

export const GoogleCloudContactcenterinsightsV1IssueModelLabelStatsIssueStats: Schema.Schema<GoogleCloudContactcenterinsightsV1IssueModelLabelStatsIssueStats> = Schema.suspend(() => Schema.Struct({
  issue: Schema.optional(Schema.String),
  labeledConversationsCount: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1IssueModelLabelStatsIssueStats" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1IssueModelLabelStatsIssueStats>;

export interface GoogleCloudContactcenterinsightsV1IssueModelLabelStats {
  /** Number of conversations the issue model has analyzed at this point in time. */
  analyzedConversationsCount?: string;
  /** Number of analyzed conversations for which no issue was applicable at this point in time. */
  unclassifiedConversationsCount?: string;
  /** Statistics on each issue. Key is the issue's resource name. */
  issueStats?: Record<string, GoogleCloudContactcenterinsightsV1IssueModelLabelStatsIssueStats>;
}

export const GoogleCloudContactcenterinsightsV1IssueModelLabelStats: Schema.Schema<GoogleCloudContactcenterinsightsV1IssueModelLabelStats> = Schema.suspend(() => Schema.Struct({
  analyzedConversationsCount: Schema.optional(Schema.String),
  unclassifiedConversationsCount: Schema.optional(Schema.String),
  issueStats: Schema.optional(Schema.Record(Schema.String, GoogleCloudContactcenterinsightsV1IssueModelLabelStatsIssueStats)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1IssueModelLabelStats" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1IssueModelLabelStats>;

export interface GoogleCloudContactcenterinsightsV1IssueModel {
  /** Immutable. The resource name of the issue model. Format: projects/{project}/locations/{location}/issueModels/{issue_model} */
  name?: string;
  /** The representative name for the issue model. */
  displayName?: string;
  /** Output only. The time at which this issue model was created. */
  createTime?: string;
  /** Output only. The most recent time at which the issue model was updated. */
  updateTime?: string;
  /** Output only. Number of issues in this issue model. */
  issueCount?: string;
  /** Output only. State of the model. */
  state?: "STATE_UNSPECIFIED" | "UNDEPLOYED" | "DEPLOYING" | "DEPLOYED" | "UNDEPLOYING" | "DELETING" | (string & {});
  /** Configs for the input data that used to create the issue model. */
  inputDataConfig?: GoogleCloudContactcenterinsightsV1IssueModelInputDataConfig;
  /** Output only. Immutable. The issue model's label statistics on its training data. */
  trainingStats?: GoogleCloudContactcenterinsightsV1IssueModelLabelStats;
  /** Type of the model. */
  modelType?: "MODEL_TYPE_UNSPECIFIED" | "TYPE_V1" | "TYPE_V2" | (string & {});
  /** Language of the model. */
  languageCode?: string;
}

export const GoogleCloudContactcenterinsightsV1IssueModel: Schema.Schema<GoogleCloudContactcenterinsightsV1IssueModel> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  issueCount: Schema.optional(Schema.String),
  state: Schema.optional(Schema.String),
  inputDataConfig: Schema.optional(GoogleCloudContactcenterinsightsV1IssueModelInputDataConfig),
  trainingStats: Schema.optional(GoogleCloudContactcenterinsightsV1IssueModelLabelStats),
  modelType: Schema.optional(Schema.String),
  languageCode: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1IssueModel" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1IssueModel>;

export interface GoogleCloudContactcenterinsightsV1ListIssueModelsResponse {
  /** The issue models that match the request. */
  issueModels?: Array<GoogleCloudContactcenterinsightsV1IssueModel>;
}

export const GoogleCloudContactcenterinsightsV1ListIssueModelsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListIssueModelsResponse> = Schema.suspend(() => Schema.Struct({
  issueModels: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1IssueModel)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListIssueModelsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListIssueModelsResponse>;

export interface GoogleCloudContactcenterinsightsV1DeployIssueModelRequest {
  /** Required. The issue model to deploy. */
  name?: string;
}

export const GoogleCloudContactcenterinsightsV1DeployIssueModelRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1DeployIssueModelRequest> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DeployIssueModelRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DeployIssueModelRequest>;

export interface GoogleCloudContactcenterinsightsV1UndeployIssueModelRequest {
  /** Required. The issue model to undeploy. */
  name?: string;
}

export const GoogleCloudContactcenterinsightsV1UndeployIssueModelRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1UndeployIssueModelRequest> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1UndeployIssueModelRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1UndeployIssueModelRequest>;

export interface GoogleCloudContactcenterinsightsV1ExportIssueModelRequestGcsDestination {
  /** Required. Format: `gs:///` */
  objectUri?: string;
}

export const GoogleCloudContactcenterinsightsV1ExportIssueModelRequestGcsDestination: Schema.Schema<GoogleCloudContactcenterinsightsV1ExportIssueModelRequestGcsDestination> = Schema.suspend(() => Schema.Struct({
  objectUri: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ExportIssueModelRequestGcsDestination" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ExportIssueModelRequestGcsDestination>;

export interface GoogleCloudContactcenterinsightsV1ExportIssueModelRequest {
  /** Google Cloud Storage URI to export the issue model to. */
  gcsDestination?: GoogleCloudContactcenterinsightsV1ExportIssueModelRequestGcsDestination;
  /** Required. The issue model to export. */
  name?: string;
}

export const GoogleCloudContactcenterinsightsV1ExportIssueModelRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1ExportIssueModelRequest> = Schema.suspend(() => Schema.Struct({
  gcsDestination: Schema.optional(GoogleCloudContactcenterinsightsV1ExportIssueModelRequestGcsDestination),
  name: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ExportIssueModelRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ExportIssueModelRequest>;

export interface GoogleCloudContactcenterinsightsV1ImportIssueModelRequestGcsSource {
  /** Required. Format: `gs:///` */
  objectUri?: string;
}

export const GoogleCloudContactcenterinsightsV1ImportIssueModelRequestGcsSource: Schema.Schema<GoogleCloudContactcenterinsightsV1ImportIssueModelRequestGcsSource> = Schema.suspend(() => Schema.Struct({
  objectUri: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ImportIssueModelRequestGcsSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ImportIssueModelRequestGcsSource>;

export interface GoogleCloudContactcenterinsightsV1ImportIssueModelRequest {
  /** Google Cloud Storage source message. */
  gcsSource?: GoogleCloudContactcenterinsightsV1ImportIssueModelRequestGcsSource;
  /** Required. The parent resource of the issue model. */
  parent?: string;
  /** Optional. If set to true, will create an issue model from the imported file with randomly generated IDs for the issue model and corresponding issues. Otherwise, replaces an existing model with the same ID as the file. */
  createNewModel?: boolean;
}

export const GoogleCloudContactcenterinsightsV1ImportIssueModelRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1ImportIssueModelRequest> = Schema.suspend(() => Schema.Struct({
  gcsSource: Schema.optional(GoogleCloudContactcenterinsightsV1ImportIssueModelRequestGcsSource),
  parent: Schema.optional(Schema.String),
  createNewModel: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ImportIssueModelRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ImportIssueModelRequest>;

export interface GoogleCloudContactcenterinsightsV1Issue {
  /** Immutable. The resource name of the issue. Format: projects/{project}/locations/{location}/issueModels/{issue_model}/issues/{issue} */
  name?: string;
  /** The representative name for the issue. */
  displayName?: string;
  /** Output only. The time at which this issue was created. */
  createTime?: string;
  /** Output only. The most recent time that this issue was updated. */
  updateTime?: string;
  /** Output only. Resource names of the sample representative utterances that match to this issue. */
  sampleUtterances?: Array<string>;
  /** Representative description of the issue. */
  displayDescription?: string;
}

export const GoogleCloudContactcenterinsightsV1Issue: Schema.Schema<GoogleCloudContactcenterinsightsV1Issue> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  sampleUtterances: Schema.optional(Schema.Array(Schema.String)),
  displayDescription: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1Issue" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1Issue>;

export interface GoogleCloudContactcenterinsightsV1ListIssuesResponse {
  /** The issues that match the request. */
  issues?: Array<GoogleCloudContactcenterinsightsV1Issue>;
}

export const GoogleCloudContactcenterinsightsV1ListIssuesResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListIssuesResponse> = Schema.suspend(() => Schema.Struct({
  issues: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1Issue)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListIssuesResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListIssuesResponse>;

export interface GoogleCloudContactcenterinsightsV1CalculateIssueModelStatsResponse {
  /** The latest label statistics for the queried issue model. Includes results on both training data and data labeled after deployment. */
  currentStats?: GoogleCloudContactcenterinsightsV1IssueModelLabelStats;
}

export const GoogleCloudContactcenterinsightsV1CalculateIssueModelStatsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1CalculateIssueModelStatsResponse> = Schema.suspend(() => Schema.Struct({
  currentStats: Schema.optional(GoogleCloudContactcenterinsightsV1IssueModelLabelStats),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1CalculateIssueModelStatsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1CalculateIssueModelStatsResponse>;

export interface GoogleCloudContactcenterinsightsV1ExactMatchConfig {
  /** Whether to consider case sensitivity when performing an exact match. */
  caseSensitive?: boolean;
}

export const GoogleCloudContactcenterinsightsV1ExactMatchConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1ExactMatchConfig> = Schema.suspend(() => Schema.Struct({
  caseSensitive: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ExactMatchConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ExactMatchConfig>;

export interface GoogleCloudContactcenterinsightsV1RegexMatchConfig {
}

export const GoogleCloudContactcenterinsightsV1RegexMatchConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1RegexMatchConfig> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1RegexMatchConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1RegexMatchConfig>;

export interface GoogleCloudContactcenterinsightsV1PhraseMatchRuleConfig {
  /** The configuration for the exact match rule. */
  exactMatchConfig?: GoogleCloudContactcenterinsightsV1ExactMatchConfig;
  /** The configuration for the regex match rule. */
  regexMatchConfig?: GoogleCloudContactcenterinsightsV1RegexMatchConfig;
}

export const GoogleCloudContactcenterinsightsV1PhraseMatchRuleConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1PhraseMatchRuleConfig> = Schema.suspend(() => Schema.Struct({
  exactMatchConfig: Schema.optional(GoogleCloudContactcenterinsightsV1ExactMatchConfig),
  regexMatchConfig: Schema.optional(GoogleCloudContactcenterinsightsV1RegexMatchConfig),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1PhraseMatchRuleConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1PhraseMatchRuleConfig>;

export interface GoogleCloudContactcenterinsightsV1PhraseMatchRule {
  /** Required. The phrase to be matched. */
  query?: string;
  /** Specifies whether the phrase must be missing from the transcript segment or present in the transcript segment. */
  negated?: boolean;
  /** Provides additional information about the rule that specifies how to apply the rule. */
  config?: GoogleCloudContactcenterinsightsV1PhraseMatchRuleConfig;
}

export const GoogleCloudContactcenterinsightsV1PhraseMatchRule: Schema.Schema<GoogleCloudContactcenterinsightsV1PhraseMatchRule> = Schema.suspend(() => Schema.Struct({
  query: Schema.optional(Schema.String),
  negated: Schema.optional(Schema.Boolean),
  config: Schema.optional(GoogleCloudContactcenterinsightsV1PhraseMatchRuleConfig),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1PhraseMatchRule" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1PhraseMatchRule>;

export interface GoogleCloudContactcenterinsightsV1PhraseMatchRuleGroup {
  /** Required. The type of this phrase match rule group. */
  type?: "PHRASE_MATCH_RULE_GROUP_TYPE_UNSPECIFIED" | "ALL_OF" | "ANY_OF" | (string & {});
  /** A list of phrase match rules that are included in this group. */
  phraseMatchRules?: Array<GoogleCloudContactcenterinsightsV1PhraseMatchRule>;
}

export const GoogleCloudContactcenterinsightsV1PhraseMatchRuleGroup: Schema.Schema<GoogleCloudContactcenterinsightsV1PhraseMatchRuleGroup> = Schema.suspend(() => Schema.Struct({
  type: Schema.optional(Schema.String),
  phraseMatchRules: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1PhraseMatchRule)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1PhraseMatchRuleGroup" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1PhraseMatchRuleGroup>;

export interface GoogleCloudContactcenterinsightsV1PhraseMatcher {
  /** The resource name of the phrase matcher. Format: projects/{project}/locations/{location}/phraseMatchers/{phrase_matcher} */
  name?: string;
  /** Output only. Immutable. The revision ID of the phrase matcher. A new revision is committed whenever the matcher is changed, except when it is activated or deactivated. A server generated random ID will be used. Example: locations/global/phraseMatchers/my-first-matcher@1234567 */
  revisionId?: string;
  /** The customized version tag to use for the phrase matcher. If not specified, it will default to `revision_id`. */
  versionTag?: string;
  /** Output only. The timestamp of when the revision was created. It is also the create time when a new matcher is added. */
  revisionCreateTime?: string;
  /** The human-readable name of the phrase matcher. */
  displayName?: string;
  /** Required. The type of this phrase matcher. */
  type?: "PHRASE_MATCHER_TYPE_UNSPECIFIED" | "ALL_OF" | "ANY_OF" | (string & {});
  /** Applies the phrase matcher only when it is active. */
  active?: boolean;
  /** A list of phase match rule groups that are included in this matcher. */
  phraseMatchRuleGroups?: Array<GoogleCloudContactcenterinsightsV1PhraseMatchRuleGroup>;
  /** Output only. The most recent time at which the activation status was updated. */
  activationUpdateTime?: string;
  /** The role whose utterances the phrase matcher should be matched against. If the role is ROLE_UNSPECIFIED it will be matched against any utterances in the transcript. */
  roleMatch?: "ROLE_UNSPECIFIED" | "HUMAN_AGENT" | "AUTOMATED_AGENT" | "END_USER" | "ANY_AGENT" | (string & {});
  /** Output only. The most recent time at which the phrase matcher was updated. */
  updateTime?: string;
}

export const GoogleCloudContactcenterinsightsV1PhraseMatcher: Schema.Schema<GoogleCloudContactcenterinsightsV1PhraseMatcher> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  revisionId: Schema.optional(Schema.String),
  versionTag: Schema.optional(Schema.String),
  revisionCreateTime: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  active: Schema.optional(Schema.Boolean),
  phraseMatchRuleGroups: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1PhraseMatchRuleGroup)),
  activationUpdateTime: Schema.optional(Schema.String),
  roleMatch: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1PhraseMatcher" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1PhraseMatcher>;

export interface GoogleCloudContactcenterinsightsV1ListPhraseMatchersResponse {
  /** The phrase matchers that match the request. */
  phraseMatchers?: Array<GoogleCloudContactcenterinsightsV1PhraseMatcher>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListPhraseMatchersResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListPhraseMatchersResponse> = Schema.suspend(() => Schema.Struct({
  phraseMatchers: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1PhraseMatcher)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListPhraseMatchersResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListPhraseMatchersResponse>;

export interface GoogleCloudContactcenterinsightsV1CalculateStatsResponseTimeSeriesInterval {
  /** The start time of this interval. */
  startTime?: string;
  /** The number of conversations created in this interval. */
  conversationCount?: number;
}

export const GoogleCloudContactcenterinsightsV1CalculateStatsResponseTimeSeriesInterval: Schema.Schema<GoogleCloudContactcenterinsightsV1CalculateStatsResponseTimeSeriesInterval> = Schema.suspend(() => Schema.Struct({
  startTime: Schema.optional(Schema.String),
  conversationCount: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1CalculateStatsResponseTimeSeriesInterval" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1CalculateStatsResponseTimeSeriesInterval>;

export interface GoogleCloudContactcenterinsightsV1CalculateStatsResponseTimeSeries {
  /** The duration of each interval. */
  intervalDuration?: string;
  /** An ordered list of intervals from earliest to latest, where each interval represents the number of conversations that transpired during the time window. */
  points?: Array<GoogleCloudContactcenterinsightsV1CalculateStatsResponseTimeSeriesInterval>;
}

export const GoogleCloudContactcenterinsightsV1CalculateStatsResponseTimeSeries: Schema.Schema<GoogleCloudContactcenterinsightsV1CalculateStatsResponseTimeSeries> = Schema.suspend(() => Schema.Struct({
  intervalDuration: Schema.optional(Schema.String),
  points: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1CalculateStatsResponseTimeSeriesInterval)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1CalculateStatsResponseTimeSeries" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1CalculateStatsResponseTimeSeries>;

export interface GoogleCloudContactcenterinsightsV1CalculateStatsResponse {
  /** The average duration of all conversations. The average is calculated using only conversations that have a time duration. */
  averageDuration?: string;
  /** The average number of turns per conversation. */
  averageTurnCount?: number;
  /** The total number of conversations. */
  conversationCount?: number;
  /** A map associating each smart highlighter display name with its respective number of matches in the set of conversations. */
  smartHighlighterMatches?: Record<string, number>;
  /** A map associating each custom highlighter resource name with its respective number of matches in the set of conversations. */
  customHighlighterMatches?: Record<string, number>;
  /** A map associating each issue resource name with its respective number of matches in the set of conversations. Key has the format: `projects//locations//issueModels//issues/` Deprecated, use `issue_matches_stats` field instead. */
  issueMatches?: Record<string, number>;
  /** A map associating each issue resource name with its respective number of matches in the set of conversations. Key has the format: `projects//locations//issueModels//issues/` */
  issueMatchesStats?: Record<string, GoogleCloudContactcenterinsightsV1IssueModelLabelStatsIssueStats>;
  /** A time series representing the count of conversations created over time that match that requested filter criteria. */
  conversationCountTimeSeries?: GoogleCloudContactcenterinsightsV1CalculateStatsResponseTimeSeries;
}

export const GoogleCloudContactcenterinsightsV1CalculateStatsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1CalculateStatsResponse> = Schema.suspend(() => Schema.Struct({
  averageDuration: Schema.optional(Schema.String),
  averageTurnCount: Schema.optional(Schema.Number),
  conversationCount: Schema.optional(Schema.Number),
  smartHighlighterMatches: Schema.optional(Schema.Record(Schema.String, Schema.Number)),
  customHighlighterMatches: Schema.optional(Schema.Record(Schema.String, Schema.Number)),
  issueMatches: Schema.optional(Schema.Record(Schema.String, Schema.Number)),
  issueMatchesStats: Schema.optional(Schema.Record(Schema.String, GoogleCloudContactcenterinsightsV1IssueModelLabelStatsIssueStats)),
  conversationCountTimeSeries: Schema.optional(GoogleCloudContactcenterinsightsV1CalculateStatsResponseTimeSeries),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1CalculateStatsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1CalculateStatsResponse>;

export interface GoogleCloudContactcenterinsightsV1CalculateStatsRequest {
  /** A filter to reduce results to a specific subset. This field is useful for getting statistics about conversations with specific properties. */
  filter?: string;
}

export const GoogleCloudContactcenterinsightsV1CalculateStatsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1CalculateStatsRequest> = Schema.suspend(() => Schema.Struct({
  filter: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1CalculateStatsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1CalculateStatsRequest>;

export interface GoogleCloudContactcenterinsightsV1CorrelationRule {
  /** Required. The unique identifier of the rule. */
  ruleId?: string;
  /** Optional. Whether the config is active to be evaluated. */
  active?: boolean;
  /** Optional. A cel expression (go/cel) to be evaluated as a string value. This string value will be used as the join key for the correlation. */
  joinKeyExpression?: string;
  /** Optional. A cel expression (go/cel) to be evaluated as a boolean value. Two variables conversation_a and conversation_b will be available for evaluation. This expression should evaluate to true if conversation_a and conversation_b should be joined. This is used as an extra constraint on top of the join_key_expression to further refine the group of conversations that are joined together and will be evaluated in both directions. for two conversations c1 and c2 and the result will be OR'd. We will evaluate: f(c1, c2) OR f(c2, c1) */
  constraintExpression?: string;
}

export const GoogleCloudContactcenterinsightsV1CorrelationRule: Schema.Schema<GoogleCloudContactcenterinsightsV1CorrelationRule> = Schema.suspend(() => Schema.Struct({
  ruleId: Schema.optional(Schema.String),
  active: Schema.optional(Schema.Boolean),
  joinKeyExpression: Schema.optional(Schema.String),
  constraintExpression: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1CorrelationRule" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1CorrelationRule>;

export interface GoogleCloudContactcenterinsightsV1CorrelationTypeConfig {
  /** A list of correlation rules to be evaluated for correlation. */
  correlationRules?: Array<GoogleCloudContactcenterinsightsV1CorrelationRule>;
}

export const GoogleCloudContactcenterinsightsV1CorrelationTypeConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1CorrelationTypeConfig> = Schema.suspend(() => Schema.Struct({
  correlationRules: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1CorrelationRule)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1CorrelationTypeConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1CorrelationTypeConfig>;

export interface GoogleCloudContactcenterinsightsV1CorrelationConfig {
  /** Immutable. Identifier. The resource name of the correlation config. Format: projects/{project}/locations/{location}/correlationConfig */
  name?: string;
  /** Output only. The time at which the correlation config was created. */
  createTime?: string;
  /** Output only. The time at which the correlation config was last updated. */
  updateTime?: string;
  /** The correlation type config for full conversations. */
  fullConversationConfig?: GoogleCloudContactcenterinsightsV1CorrelationTypeConfig;
}

export const GoogleCloudContactcenterinsightsV1CorrelationConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1CorrelationConfig> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  fullConversationConfig: Schema.optional(GoogleCloudContactcenterinsightsV1CorrelationTypeConfig),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1CorrelationConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1CorrelationConfig>;

export interface GoogleCloudContactcenterinsightsV1TestCorrelationConfigRequestConversations {
  /** Optional. The conversations. */
  conversations?: Array<GoogleCloudContactcenterinsightsV1Conversation>;
}

export const GoogleCloudContactcenterinsightsV1TestCorrelationConfigRequestConversations: Schema.Schema<GoogleCloudContactcenterinsightsV1TestCorrelationConfigRequestConversations> = Schema.suspend(() => Schema.Struct({
  conversations: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1Conversation)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1TestCorrelationConfigRequestConversations" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1TestCorrelationConfigRequestConversations>;

export interface GoogleCloudContactcenterinsightsV1TestCorrelationConfigRequest {
  /** Optional. Filter to select conversations to test correlation against. Conversations matching this filter will be sampled based on start time. The most recent `max_sample_count` conversations will be selected. If no conversations match the filter, the request will fail with an `INVALID_ARGUMENT` error. */
  filter?: string;
  /** Optional. A list of conversations to test against. */
  conversations?: GoogleCloudContactcenterinsightsV1TestCorrelationConfigRequestConversations;
  /** Required. The correlation config to test. */
  correlationConfig?: GoogleCloudContactcenterinsightsV1CorrelationConfig;
  /** Optional. The maximum number of conversations to sample when using the `filter`. If not set, defaults to 1000. Values greater than 1000 are coerced to 1000. This field is ignored if `conversations` is provided. */
  maxSampleCount?: number;
}

export const GoogleCloudContactcenterinsightsV1TestCorrelationConfigRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1TestCorrelationConfigRequest> = Schema.suspend(() => Schema.Struct({
  filter: Schema.optional(Schema.String),
  conversations: Schema.optional(GoogleCloudContactcenterinsightsV1TestCorrelationConfigRequestConversations),
  correlationConfig: Schema.optional(GoogleCloudContactcenterinsightsV1CorrelationConfig),
  maxSampleCount: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1TestCorrelationConfigRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1TestCorrelationConfigRequest>;

export interface GoogleCloudContactcenterinsightsV1SettingsAnalysisConfig {
  /** Percentage of conversations created using Dialogflow runtime integration to analyze automatically, between [0, 100]. */
  runtimeIntegrationAnalysisPercentage?: number;
  /** Percentage of conversations created using the UploadConversation endpoint to analyze automatically, between [0, 100]. */
  uploadConversationAnalysisPercentage?: number;
  /** To select the annotators to run and the phrase matchers to use (if any). If not specified, all annotators will be run. */
  annotatorSelector?: GoogleCloudContactcenterinsightsV1AnnotatorSelector;
}

export const GoogleCloudContactcenterinsightsV1SettingsAnalysisConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1SettingsAnalysisConfig> = Schema.suspend(() => Schema.Struct({
  runtimeIntegrationAnalysisPercentage: Schema.optional(Schema.Number),
  uploadConversationAnalysisPercentage: Schema.optional(Schema.Number),
  annotatorSelector: Schema.optional(GoogleCloudContactcenterinsightsV1AnnotatorSelector),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1SettingsAnalysisConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1SettingsAnalysisConfig>;

export interface GoogleCloudContactcenterinsightsV1Settings {
  /** Immutable. The resource name of the settings resource. Format: projects/{project}/locations/{location}/settings */
  name?: string;
  /** Output only. The time at which the settings was created. */
  createTime?: string;
  /** Output only. The time at which the settings were last updated. */
  updateTime?: string;
  /** A language code to be applied to each transcript segment unless the segment already specifies a language code. Language code defaults to "en-US" if it is neither specified on the segment nor here. */
  languageCode?: string;
  /** The default TTL for newly-created conversations. If a conversation has a specified expiration, that value will be used instead. Changing this value will not change the expiration of existing conversations. Conversations with no expire time persist until they are deleted. */
  conversationTtl?: string;
  /** A map that maps a notification trigger to a Pub/Sub topic. Each time a specified trigger occurs, Insights will notify the corresponding Pub/Sub topic. Keys are notification triggers. Supported keys are: * "all-triggers": Notify each time any of the supported triggers occurs. * "create-analysis": Notify each time an analysis is created. * "create-conversation": Notify each time a conversation is created. * "export-insights-data": Notify each time an export is complete. * "ingest-conversations": Notify each time an IngestConversations LRO is complete. * "update-conversation": Notify each time a conversation is updated via UpdateConversation. * "upload-conversation": Notify when an UploadConversation LRO is complete. * "update-or-analyze-conversation": Notify when an analysis for a conversation is completed or when the conversation is updated. The message will contain the conversation with transcript, analysis and other metadata. Values are Pub/Sub topics. The format of each Pub/Sub topic is: projects/{project}/topics/{topic} */
  pubsubNotificationSettings?: Record<string, string>;
  /** Default analysis settings. */
  analysisConfig?: GoogleCloudContactcenterinsightsV1SettingsAnalysisConfig;
  /** Default DLP redaction resources to be applied while ingesting conversations. This applies to conversations ingested from the `UploadConversation` and `IngestConversations` endpoints, including conversations coming from CCAI Platform. */
  redactionConfig?: GoogleCloudContactcenterinsightsV1RedactionConfig;
  /** Optional. Default Speech-to-Text resources to use while ingesting audio files. Optional, CCAI Insights will create a default if not provided. This applies to conversations ingested from the `UploadConversation` and `IngestConversations` endpoints, including conversations coming from CCAI Platform. */
  speechConfig?: GoogleCloudContactcenterinsightsV1SpeechConfig;
  /** Optional. The path to a Cloud Storage bucket containing conversation screen recordings. If provided, Insights will search in the bucket for a screen recording file matching the conversation data source object name prefix. If matches are found, these file URIs will be stored in the conversation screen recordings field. */
  screenRecordingBucketUri?: string;
}

export const GoogleCloudContactcenterinsightsV1Settings: Schema.Schema<GoogleCloudContactcenterinsightsV1Settings> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  languageCode: Schema.optional(Schema.String),
  conversationTtl: Schema.optional(Schema.String),
  pubsubNotificationSettings: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  analysisConfig: Schema.optional(GoogleCloudContactcenterinsightsV1SettingsAnalysisConfig),
  redactionConfig: Schema.optional(GoogleCloudContactcenterinsightsV1RedactionConfig),
  speechConfig: Schema.optional(GoogleCloudContactcenterinsightsV1SpeechConfig),
  screenRecordingBucketUri: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1Settings" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1Settings>;

export interface GoogleCloudContactcenterinsightsV1AnalysisRule {
  /** Identifier. The resource name of the analysis rule. Format: projects/{project}/locations/{location}/analysisRules/{analysis_rule} */
  name?: string;
  /** Output only. The time at which this analysis rule was created. */
  createTime?: string;
  /** Output only. The most recent time at which this analysis rule was updated. */
  updateTime?: string;
  /** Display Name of the analysis rule. */
  displayName?: string;
  /** Filter for the conversations that should apply this analysis rule. An empty filter means this analysis rule applies to all conversations. Refer to https://cloud.google.com/contact-center/insights/docs/filtering for details. */
  conversationFilter?: string;
  /** Selector of annotators to run and the phrase matchers to use for conversations that matches the conversation_filter. If not specified, NO annotators will be run. */
  annotatorSelector?: GoogleCloudContactcenterinsightsV1AnnotatorSelector;
  /** Percentage of conversations that we should apply this analysis setting automatically, between [0, 1]. For example, 0.1 means 10%. Conversations are sampled in a determenestic way. The original runtime_percentage & upload percentage will be replaced by defining filters on the conversation. */
  analysisPercentage?: number;
  /** If true, apply this rule to conversations. Otherwise, this rule is inactive and saved as a draft. */
  active?: boolean;
}

export const GoogleCloudContactcenterinsightsV1AnalysisRule: Schema.Schema<GoogleCloudContactcenterinsightsV1AnalysisRule> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  conversationFilter: Schema.optional(Schema.String),
  annotatorSelector: Schema.optional(GoogleCloudContactcenterinsightsV1AnnotatorSelector),
  analysisPercentage: Schema.optional(Schema.Number),
  active: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1AnalysisRule" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1AnalysisRule>;

export interface GoogleCloudContactcenterinsightsV1ListAnalysisRulesResponse {
  /** The analysis_rule that match the request. */
  analysisRules?: Array<GoogleCloudContactcenterinsightsV1AnalysisRule>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListAnalysisRulesResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListAnalysisRulesResponse> = Schema.suspend(() => Schema.Struct({
  analysisRules: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1AnalysisRule)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListAnalysisRulesResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListAnalysisRulesResponse>;

export interface GoogleCloudContactcenterinsightsV1AutoLabelingRuleLabelingCondition {
  /** A optional CEL expression to be evaluated as a boolean value. Once evaluated as true, then we will proceed with the value evaluation. An empty condition will be auto evaluated as true. */
  condition?: string;
  /** CEL expression to be evaluated as the value. */
  value?: string;
}

export const GoogleCloudContactcenterinsightsV1AutoLabelingRuleLabelingCondition: Schema.Schema<GoogleCloudContactcenterinsightsV1AutoLabelingRuleLabelingCondition> = Schema.suspend(() => Schema.Struct({
  condition: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1AutoLabelingRuleLabelingCondition" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1AutoLabelingRuleLabelingCondition>;

export interface GoogleCloudContactcenterinsightsV1AutoLabelingRule {
  /** Identifier. The resource name of the auto-labeling rule. Format: projects/{project}/locations/{location}/autoLabelingRules/{auto_labeling_rule} */
  name?: string;
  /** Whether the rule is active. */
  active?: boolean;
  /** The user-provided display name of the rule. */
  displayName?: string;
  /** The description of the rule. */
  description?: string;
  /** The type of the label key. */
  labelKeyType?: "LABEL_KEY_TYPE_UNSPECIFIED" | "LABEL_KEY_TYPE_CUSTOM" | (string & {});
  /** The label key. This is also the {auto_labeling_rule} in the resource name. Only settable if label_key_type is LABEL_KEY_TYPE_CUSTOM. */
  labelKey?: string;
  /** Conditions to apply for auto-labeling the label_key. Representing sequential block of if .. else if .. else statements. The value of the first matching condition will be used. */
  conditions?: Array<GoogleCloudContactcenterinsightsV1AutoLabelingRuleLabelingCondition>;
  /** Output only. The time at which this rule was created. */
  createTime?: string;
  /** Output only. The most recent time at which the rule was updated. */
  updateTime?: string;
}

export const GoogleCloudContactcenterinsightsV1AutoLabelingRule: Schema.Schema<GoogleCloudContactcenterinsightsV1AutoLabelingRule> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  active: Schema.optional(Schema.Boolean),
  displayName: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  labelKeyType: Schema.optional(Schema.String),
  labelKey: Schema.optional(Schema.String),
  conditions: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1AutoLabelingRuleLabelingCondition)),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1AutoLabelingRule" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1AutoLabelingRule>;

export interface GoogleCloudContactcenterinsightsV1ListAutoLabelingRulesResponse {
  /** The auto labeling rules. */
  autoLabelingRules?: Array<GoogleCloudContactcenterinsightsV1AutoLabelingRule>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListAutoLabelingRulesResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListAutoLabelingRulesResponse> = Schema.suspend(() => Schema.Struct({
  autoLabelingRules: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1AutoLabelingRule)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListAutoLabelingRulesResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListAutoLabelingRulesResponse>;

export interface GoogleCloudContactcenterinsightsV1TestAutoLabelingRuleRequest {
  /** Required. Conversation data to test rules against. */
  conversation?: GoogleCloudContactcenterinsightsV1Conversation;
  /** Required. The auto labeling rule to test. */
  autoLabelingRule?: GoogleCloudContactcenterinsightsV1AutoLabelingRule;
}

export const GoogleCloudContactcenterinsightsV1TestAutoLabelingRuleRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1TestAutoLabelingRuleRequest> = Schema.suspend(() => Schema.Struct({
  conversation: Schema.optional(GoogleCloudContactcenterinsightsV1Conversation),
  autoLabelingRule: Schema.optional(GoogleCloudContactcenterinsightsV1AutoLabelingRule),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1TestAutoLabelingRuleRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1TestAutoLabelingRuleRequest>;

export interface GoogleCloudContactcenterinsightsV1TestAutoLabelingRuleResponse {
  /** The result of the test auto labeling rule. */
  labelResult?: string;
}

export const GoogleCloudContactcenterinsightsV1TestAutoLabelingRuleResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1TestAutoLabelingRuleResponse> = Schema.suspend(() => Schema.Struct({
  labelResult: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1TestAutoLabelingRuleResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1TestAutoLabelingRuleResponse>;

export interface GoogleCloudContactcenterinsightsV1ScheduleInfo {
  /** Start time of the schedule. If not specified, will start as soon as the schedule is created. */
  startTime?: string;
  /** End time of the schedule. If not specified, will keep scheduling new pipelines for execution util the schedule is no longer active or deleted. */
  endTime?: string;
  /** The groc expression. Format: `every number [synchronized]` Time units can be: minutes, hours Synchronized is optional and indicates that the schedule should be synchronized to the start of the interval: every 5 minutes synchronized means 00:00, 00:05 ... Otherwise the start time is random within the interval. Example: `every 5 minutes` could be 00:02, 00:07, 00:12, ... */
  schedule?: string;
  /** The timezone to use for the groc expression. If not specified, defaults to UTC. */
  timeZone?: string;
}

export const GoogleCloudContactcenterinsightsV1ScheduleInfo: Schema.Schema<GoogleCloudContactcenterinsightsV1ScheduleInfo> = Schema.suspend(() => Schema.Struct({
  startTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  schedule: Schema.optional(Schema.String),
  timeZone: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ScheduleInfo" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ScheduleInfo>;

export interface GoogleCloudContactcenterinsightsV1AssessmentRule {
  /** Identifier. The resource name of the assessment rule. Format: projects/{project}/locations/{location}/assessmentRules/{assessment_rule} */
  name?: string;
  /** Output only. The time at which this assessment rule was created. */
  createTime?: string;
  /** Output only. The most recent time at which this assessment rule was updated. */
  updateTime?: string;
  /** If true, apply this rule to conversations. Otherwise, this rule is inactive. */
  active?: boolean;
  /** Display Name of the assessment rule. */
  displayName?: string;
  /** The sample rule for the assessment rule. */
  sampleRule?: GoogleCloudContactcenterinsightsV1SampleRule;
  /** Schedule info for the assessment rule. */
  scheduleInfo?: GoogleCloudContactcenterinsightsV1ScheduleInfo;
}

export const GoogleCloudContactcenterinsightsV1AssessmentRule: Schema.Schema<GoogleCloudContactcenterinsightsV1AssessmentRule> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  active: Schema.optional(Schema.Boolean),
  displayName: Schema.optional(Schema.String),
  sampleRule: Schema.optional(GoogleCloudContactcenterinsightsV1SampleRule),
  scheduleInfo: Schema.optional(GoogleCloudContactcenterinsightsV1ScheduleInfo),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1AssessmentRule" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1AssessmentRule>;

export interface GoogleCloudContactcenterinsightsV1ListAssessmentRulesResponse {
  /** The assessment rules that match the request. */
  assessmentRules?: Array<GoogleCloudContactcenterinsightsV1AssessmentRule>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListAssessmentRulesResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListAssessmentRulesResponse> = Schema.suspend(() => Schema.Struct({
  assessmentRules: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1AssessmentRule)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListAssessmentRulesResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListAssessmentRulesResponse>;

export interface GoogleCloudContactcenterinsightsV1EncryptionSpec {
  /** Immutable. The resource name of the encryption key specification resource. Format: projects/{project}/locations/{location}/encryptionSpec */
  name?: string;
  /** Required. The name of customer-managed encryption key that is used to secure a resource and its sub-resources. If empty, the resource is secured by our default encryption key. Only the key in the same location as this resource is allowed to be used for encryption. Format: `projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key}` */
  kmsKey?: string;
}

export const GoogleCloudContactcenterinsightsV1EncryptionSpec: Schema.Schema<GoogleCloudContactcenterinsightsV1EncryptionSpec> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  kmsKey: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1EncryptionSpec" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1EncryptionSpec>;

export interface GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecRequest {
  /** Required. The encryption spec used for CMEK encryption. It is required that the kms key is in the same region as the endpoint. The same key will be used for all provisioned resources, if encryption is available. If the `kms_key_name` field is left empty, no encryption will be enforced. */
  encryptionSpec?: GoogleCloudContactcenterinsightsV1EncryptionSpec;
}

export const GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecRequest> = Schema.suspend(() => Schema.Struct({
  encryptionSpec: Schema.optional(GoogleCloudContactcenterinsightsV1EncryptionSpec),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecRequest>;

export interface GoogleCloudContactcenterinsightsV1View {
  /** Immutable. The resource name of the view. Format: projects/{project}/locations/{location}/views/{view} */
  name?: string;
  /** The human-readable display name of the view. */
  displayName?: string;
  /** Output only. The time at which this view was created. */
  createTime?: string;
  /** Output only. The most recent time at which the view was updated. */
  updateTime?: string;
  /** A filter to reduce conversation results to a specific subset. Refer to https://cloud.google.com/contact-center/insights/docs/filtering for details. */
  value?: string;
}

export const GoogleCloudContactcenterinsightsV1View: Schema.Schema<GoogleCloudContactcenterinsightsV1View> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1View" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1View>;

export interface GoogleCloudContactcenterinsightsV1ListViewsResponse {
  /** The views that match the request. */
  views?: Array<GoogleCloudContactcenterinsightsV1View>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListViewsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListViewsResponse> = Schema.suspend(() => Schema.Struct({
  views: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1View)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListViewsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListViewsResponse>;

export interface GoogleCloudContactcenterinsightsV1DimensionIssueDimensionMetadata {
  /** The issue ID. */
  issueId?: string;
  /** The issue display name. */
  issueDisplayName?: string;
  /** The parent issue model ID. */
  issueModelId?: string;
}

export const GoogleCloudContactcenterinsightsV1DimensionIssueDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionIssueDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  issueId: Schema.optional(Schema.String),
  issueDisplayName: Schema.optional(Schema.String),
  issueModelId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DimensionIssueDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionIssueDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1DimensionAgentDimensionMetadata {
  /** Optional. A user-specified string representing the agent. This will be populated for AGENT, AGENT_TEAM, AGENT_VERSION_ID, and AGENT_DEPLOYMENT_ID dimensions. */
  agentId?: string;
  /** Optional. The agent's name This will be populated for AGENT, AGENT_TEAM, AGENT_VERSION_ID, and AGENT_DEPLOYMENT_ID dimensions. */
  agentDisplayName?: string;
  /** Optional. A user-specified string representing the agent's team. */
  agentTeam?: string;
  /** Optional. The agent's version display name. Only applicable to automated agents. This will be populated for AGENT_VERSION_ID, and AGENT_DEPLOYMENT_ID dimensions. */
  agentVersionDisplayName?: string;
  /** Optional. The agent's version ID. Only applicable to automated agents. This will be populated for AGENT_VERSION_ID, and AGENT_DEPLOYMENT_ID dimensions. */
  agentVersionId?: string;
  /** Optional. The agent's deployment display name. Only applicable to automated agents. This will be populated for AGENT_DEPLOYMENT_ID dimensions. */
  agentDeploymentDisplayName?: string;
  /** Optional. The agent's deployment ID. Only applicable to automated agents. This will be populated for AGENT and AGENT_DEPLOYMENT_ID dimensions. */
  agentDeploymentId?: string;
}

export const GoogleCloudContactcenterinsightsV1DimensionAgentDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionAgentDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  agentId: Schema.optional(Schema.String),
  agentDisplayName: Schema.optional(Schema.String),
  agentTeam: Schema.optional(Schema.String),
  agentVersionDisplayName: Schema.optional(Schema.String),
  agentVersionId: Schema.optional(Schema.String),
  agentDeploymentDisplayName: Schema.optional(Schema.String),
  agentDeploymentId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DimensionAgentDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionAgentDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1DimensionQaQuestionDimensionMetadata {
  /** Optional. The QA scorecard ID. */
  qaScorecardId?: string;
  /** Optional. The QA question ID. */
  qaQuestionId?: string;
  /** Optional. The full body of the question. */
  questionBody?: string;
}

export const GoogleCloudContactcenterinsightsV1DimensionQaQuestionDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionQaQuestionDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  qaScorecardId: Schema.optional(Schema.String),
  qaQuestionId: Schema.optional(Schema.String),
  questionBody: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DimensionQaQuestionDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionQaQuestionDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1DimensionQaQuestionAnswerDimensionMetadata {
  /** Optional. The QA scorecard ID. */
  qaScorecardId?: string;
  /** Optional. The QA question ID. */
  qaQuestionId?: string;
  /** Optional. The full body of the question. */
  questionBody?: string;
  /** Optional. The full body of the question. */
  answerValue?: string;
}

export const GoogleCloudContactcenterinsightsV1DimensionQaQuestionAnswerDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionQaQuestionAnswerDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  qaScorecardId: Schema.optional(Schema.String),
  qaQuestionId: Schema.optional(Schema.String),
  questionBody: Schema.optional(Schema.String),
  answerValue: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DimensionQaQuestionAnswerDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionQaQuestionAnswerDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1DimensionQaScorecardDimensionMetadata {
  /** Optional. The QA scorecard ID. */
  qaScorecardId?: string;
}

export const GoogleCloudContactcenterinsightsV1DimensionQaScorecardDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionQaScorecardDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  qaScorecardId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DimensionQaScorecardDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionQaScorecardDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1DimensionConversationProfileDimensionMetadata {
  /** Optional. The conversation profile ID. */
  conversationProfileId?: string;
}

export const GoogleCloudContactcenterinsightsV1DimensionConversationProfileDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionConversationProfileDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  conversationProfileId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DimensionConversationProfileDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionConversationProfileDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1DimensionMediumDimensionMetadata {
  /** Optional. The conversation medium. Currently supports : PHONE_CALL, CHAT. */
  medium?: string;
}

export const GoogleCloudContactcenterinsightsV1DimensionMediumDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionMediumDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  medium: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DimensionMediumDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionMediumDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1DimensionConversationalAgentsPlaybookDimensionMetadata {
  /** Optional. The dialogflow playbook ID. */
  playbookId?: string;
  /** Optional. The dialogflow playbook display name. */
  playbookDisplayName?: string;
}

export const GoogleCloudContactcenterinsightsV1DimensionConversationalAgentsPlaybookDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionConversationalAgentsPlaybookDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  playbookId: Schema.optional(Schema.String),
  playbookDisplayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DimensionConversationalAgentsPlaybookDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionConversationalAgentsPlaybookDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1DimensionConversationalAgentsToolDimensionMetadata {
  /** Optional. The dialogflow tool ID. */
  toolId?: string;
  /** Optional. The dialogflow tool display name. */
  toolDisplayName?: string;
}

export const GoogleCloudContactcenterinsightsV1DimensionConversationalAgentsToolDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionConversationalAgentsToolDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  toolId: Schema.optional(Schema.String),
  toolDisplayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DimensionConversationalAgentsToolDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionConversationalAgentsToolDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1DimensionClientSentimentCategoryDimensionMetadata {
  /** Optional. The client sentiment category. */
  sentimentCategory?: string;
}

export const GoogleCloudContactcenterinsightsV1DimensionClientSentimentCategoryDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionClientSentimentCategoryDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  sentimentCategory: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DimensionClientSentimentCategoryDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionClientSentimentCategoryDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1DimensionLabelDimensionMetadata {
  /** Optional. The label key. */
  labelKey?: string;
  /** Optional. The label value. */
  labelValue?: string;
}

export const GoogleCloudContactcenterinsightsV1DimensionLabelDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionLabelDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  labelKey: Schema.optional(Schema.String),
  labelValue: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DimensionLabelDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DimensionLabelDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1Dimension {
  /** Output only. Metadata about the issue dimension. */
  issueDimensionMetadata?: GoogleCloudContactcenterinsightsV1DimensionIssueDimensionMetadata;
  /** Output only. Metadata about the agent dimension. */
  agentDimensionMetadata?: GoogleCloudContactcenterinsightsV1DimensionAgentDimensionMetadata;
  /** Output only. Metadata about the QA question dimension. */
  qaQuestionDimensionMetadata?: GoogleCloudContactcenterinsightsV1DimensionQaQuestionDimensionMetadata;
  /** Output only. Metadata about the QA question-answer dimension. */
  qaQuestionAnswerDimensionMetadata?: GoogleCloudContactcenterinsightsV1DimensionQaQuestionAnswerDimensionMetadata;
  /** Output only. Metadata about the QA scorecard dimension. */
  qaScorecardDimensionMetadata?: GoogleCloudContactcenterinsightsV1DimensionQaScorecardDimensionMetadata;
  /** Output only. Metadata about the conversation profile dimension. */
  conversationProfileDimensionMetadata?: GoogleCloudContactcenterinsightsV1DimensionConversationProfileDimensionMetadata;
  /** Output only. Metadata about the conversation medium dimension. */
  mediumDimensionMetadata?: GoogleCloudContactcenterinsightsV1DimensionMediumDimensionMetadata;
  /** Output only. Metadata about the Conversational Agents playbook dimension. */
  conversationalAgentsPlaybookDimensionMetadata?: GoogleCloudContactcenterinsightsV1DimensionConversationalAgentsPlaybookDimensionMetadata;
  /** Output only. Metadata about the Conversational Agents tool dimension. */
  conversationalAgentsToolDimensionMetadata?: GoogleCloudContactcenterinsightsV1DimensionConversationalAgentsToolDimensionMetadata;
  /** Output only. Metadata about the client sentiment category dimension. */
  clientSentimentCategoryDimensionMetadata?: GoogleCloudContactcenterinsightsV1DimensionClientSentimentCategoryDimensionMetadata;
  /** Output only. Metadata about conversation labels. */
  labelDimensionMetadata?: GoogleCloudContactcenterinsightsV1DimensionLabelDimensionMetadata;
  /** The key of the dimension. */
  dimensionKey?: "DIMENSION_KEY_UNSPECIFIED" | "ISSUE" | "ISSUE_NAME" | "AGENT" | "AGENT_TEAM" | "QA_QUESTION_ID" | "QA_QUESTION_ANSWER_VALUE" | "QA_SCORECARD_ID" | "CONVERSATION_PROFILE_ID" | "MEDIUM" | "CONVERSATIONAL_AGENTS_PLAYBOOK_ID" | "CONVERSATIONAL_AGENTS_PLAYBOOK_NAME" | "CONVERSATIONAL_AGENTS_TOOL_ID" | "CONVERSATIONAL_AGENTS_TOOL_NAME" | "CLIENT_SENTIMENT_CATEGORY" | "AGENT_VERSION_ID" | "AGENT_DEPLOYMENT_ID" | "AGENT_ASSIST_SUPERVISOR_ID" | "LABEL_KEY" | "LABEL_VALUE" | "LABEL_KEY_AND_VALUE" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1Dimension: Schema.Schema<GoogleCloudContactcenterinsightsV1Dimension> = Schema.suspend(() => Schema.Struct({
  issueDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1DimensionIssueDimensionMetadata),
  agentDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1DimensionAgentDimensionMetadata),
  qaQuestionDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1DimensionQaQuestionDimensionMetadata),
  qaQuestionAnswerDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1DimensionQaQuestionAnswerDimensionMetadata),
  qaScorecardDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1DimensionQaScorecardDimensionMetadata),
  conversationProfileDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1DimensionConversationProfileDimensionMetadata),
  mediumDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1DimensionMediumDimensionMetadata),
  conversationalAgentsPlaybookDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1DimensionConversationalAgentsPlaybookDimensionMetadata),
  conversationalAgentsToolDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1DimensionConversationalAgentsToolDimensionMetadata),
  clientSentimentCategoryDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1DimensionClientSentimentCategoryDimensionMetadata),
  labelDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1DimensionLabelDimensionMetadata),
  dimensionKey: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1Dimension" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1Dimension>;

export interface GoogleCloudContactcenterinsightsV1QueryMetricsRequest {
  /** Required. Filter to select a subset of conversations to compute the metrics. Must specify a window of the conversation create time to compute the metrics. The returned metrics will be from the range [DATE(starting create time), DATE(ending create time)). */
  filter?: string;
  /** The time granularity of each data point in the time series. Defaults to NONE if this field is unspecified. */
  timeGranularity?: "TIME_GRANULARITY_UNSPECIFIED" | "NONE" | "DAILY" | "HOURLY" | "PER_MINUTE" | "PER_5_MINUTES" | "MONTHLY" | (string & {});
  /** The dimensions that determine the grouping key for the query. Defaults to no dimension if this field is unspecified. If a dimension is specified, its key must also be specified. Each dimension's key must be unique. If a time granularity is also specified, metric values in the dimension will be bucketed by this granularity. Up to one dimension is supported for now. */
  dimensions?: Array<GoogleCloudContactcenterinsightsV1Dimension>;
  /** Measures to return. Defaults to all measures if this field is unspecified. A valid mask should traverse from the `measure` field from the response. For example, a path from a measure mask to get the conversation count is "conversation_measure.count". */
  measureMask?: string;
}

export const GoogleCloudContactcenterinsightsV1QueryMetricsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsRequest> = Schema.suspend(() => Schema.Struct({
  filter: Schema.optional(Schema.String),
  timeGranularity: Schema.optional(Schema.String),
  dimensions: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1Dimension)),
  measureMask: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QueryMetricsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsRequest>;

export interface GoogleCloudContactcenterinsightsV1GenerativeInsightsRequest {
  /** The natural language query specified by the user. If this field is specified, `sql_query` will be ignored. */
  naturalLanguageQuery?: string;
  /** The full name of the chart resource this request corresponds to. Format: projects/{project}/locations/{location}/dashboards/{dashboard}/charts/{chart} */
  chart?: string;
  /** Filter for the data that can be specified in addition to the natural language query. Users are encouraged to use this field to populate time-windows. */
  filter?: string;
  /** Optional. Filter for the data that can be specified in addition to the natural language query. This `filter` is specifically used for charts where comparisons are possible. For example, "compare to last month" or "compare to previous quarter". */
  comparisonFilter?: string;
  /** Optional. The SQL query specified by the user. This query must be in BigQuery SQL dialect. The `filter` field will also be ignored, as it is assumed that any filtering is already included in the SQL query. */
  sqlQuery?: string;
  /** Optional. For charts with comparison, this key will determine the metric that will be compared between the current and another dataset. */
  sqlComparisonKey?: string;
  /** Optional. The session id of the conversation. If the session id is not specified, backend will generate a random session id. If the session id is specified, will associate user-provided user_query with the provided session id. */
  sessionId?: string;
  /** Optional. The revision id that maps to the state of the chart state revision. When specified, the backend will reload the chart with the sql and visual spec from that revision. */
  revisionId?: string;
  /** Optional. The user provided chart spec for the chart. This will be used to override the visual spec generated by the LLM. */
  userProvidedChartSpec?: Record<string, unknown>;
}

export const GoogleCloudContactcenterinsightsV1GenerativeInsightsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsRequest> = Schema.suspend(() => Schema.Struct({
  naturalLanguageQuery: Schema.optional(Schema.String),
  chart: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
  comparisonFilter: Schema.optional(Schema.String),
  sqlQuery: Schema.optional(Schema.String),
  sqlComparisonKey: Schema.optional(Schema.String),
  sessionId: Schema.optional(Schema.String),
  revisionId: Schema.optional(Schema.String),
  userProvidedChartSpec: Schema.optional(Schema.Record(Schema.String, Schema.Unknown)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerativeInsightsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsRequest>;

export interface GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewRequestAgentSource {
  /** Required. Agent id to query performance overview for. */
  agentId?: string;
}

export const GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewRequestAgentSource: Schema.Schema<GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewRequestAgentSource> = Schema.suspend(() => Schema.Struct({
  agentId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewRequestAgentSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewRequestAgentSource>;

export interface GoogleCloudContactcenterinsightsV1QueryInterval {
  /** Required. The start time of the time window. */
  startTime?: string;
  /** Required. The end time of the time window. */
  endTime?: string;
}

export const GoogleCloudContactcenterinsightsV1QueryInterval: Schema.Schema<GoogleCloudContactcenterinsightsV1QueryInterval> = Schema.suspend(() => Schema.Struct({
  startTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QueryInterval" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QueryInterval>;

export interface GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewRequest {
  /** Conversations are from a single agent. */
  agentPerformanceSource?: GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewRequestAgentSource;
  /** Optional. Filter to select a subset of conversations to compute the performance overview. Supports the same filters as the filter field in QueryMetricsRequest. The source and query interval/comparison query interval should not be included here. */
  filter?: string;
  /** Required. The time window of the conversations to derive performance stats from. */
  queryInterval?: GoogleCloudContactcenterinsightsV1QueryInterval;
  /** The time window of the conversations to compare the performance to. */
  comparisonQueryInterval?: GoogleCloudContactcenterinsightsV1QueryInterval;
}

export const GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewRequest> = Schema.suspend(() => Schema.Struct({
  agentPerformanceSource: Schema.optional(GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewRequestAgentSource),
  filter: Schema.optional(Schema.String),
  queryInterval: Schema.optional(GoogleCloudContactcenterinsightsV1QueryInterval),
  comparisonQueryInterval: Schema.optional(GoogleCloudContactcenterinsightsV1QueryInterval),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewRequest>;

export interface GoogleCloudContactcenterinsightsV1ConversationDataOptions {
  /** Whether to include the per turn Dialogflow interaction data in conversation transcript. */
  includeDialogflowInteractionData?: boolean;
}

export const GoogleCloudContactcenterinsightsV1ConversationDataOptions: Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationDataOptions> = Schema.suspend(() => Schema.Struct({
  includeDialogflowInteractionData: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConversationDataOptions" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationDataOptions>;

export interface GoogleCloudContactcenterinsightsV1QaQuestionQaQuestionDataOptions {
  /** Options for configuring the conversation data used to generate the QA question. */
  conversationDataOptions?: GoogleCloudContactcenterinsightsV1ConversationDataOptions;
}

export const GoogleCloudContactcenterinsightsV1QaQuestionQaQuestionDataOptions: Schema.Schema<GoogleCloudContactcenterinsightsV1QaQuestionQaQuestionDataOptions> = Schema.suspend(() => Schema.Struct({
  conversationDataOptions: Schema.optional(GoogleCloudContactcenterinsightsV1ConversationDataOptions),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QaQuestionQaQuestionDataOptions" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QaQuestionQaQuestionDataOptions>;

export interface GoogleCloudContactcenterinsightsV1QaQuestionPredefinedQuestionConfig {
  /** The type of the predefined question. */
  type?: "PREDEFINED_QUESTION_TYPE_UNSPECIFIED" | "CONVERSATION_OUTCOME" | "CONVERSATION_OUTCOME_ESCALATION_INITIATOR_ROLE" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1QaQuestionPredefinedQuestionConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1QaQuestionPredefinedQuestionConfig> = Schema.suspend(() => Schema.Struct({
  type: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QaQuestionPredefinedQuestionConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QaQuestionPredefinedQuestionConfig>;

export interface GoogleCloudContactcenterinsightsV1QaQuestionAnswerChoice {
  /** String value. */
  strValue?: string;
  /** Numerical value. */
  numValue?: number;
  /** Boolean value. */
  boolValue?: boolean;
  /** A value of "Not Applicable (N/A)". If provided, this field may only be set to `true`. If a question receives this answer, it will be excluded from any score calculations. */
  naValue?: boolean;
  /** A short string used as an identifier. */
  key?: string;
  /** Numerical score of the answer, used for generating the overall score of a QaScorecardResult. If the answer uses na_value, this field is unused. */
  score?: number;
}

export const GoogleCloudContactcenterinsightsV1QaQuestionAnswerChoice: Schema.Schema<GoogleCloudContactcenterinsightsV1QaQuestionAnswerChoice> = Schema.suspend(() => Schema.Struct({
  strValue: Schema.optional(Schema.String),
  numValue: Schema.optional(Schema.Number),
  boolValue: Schema.optional(Schema.Boolean),
  naValue: Schema.optional(Schema.Boolean),
  key: Schema.optional(Schema.String),
  score: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QaQuestionAnswerChoice" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QaQuestionAnswerChoice>;

export interface GoogleCloudContactcenterinsightsV1QaQuestionMetrics {
  /** Output only. Accuracy of the model. Measures the percentage of correct answers the model gave on the test set. */
  accuracy?: number;
}

export const GoogleCloudContactcenterinsightsV1QaQuestionMetrics: Schema.Schema<GoogleCloudContactcenterinsightsV1QaQuestionMetrics> = Schema.suspend(() => Schema.Struct({
  accuracy: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QaQuestionMetrics" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QaQuestionMetrics>;

export interface GoogleCloudContactcenterinsightsV1QaQuestionTuningMetadata {
  /** Total number of valid labels provided for the question at the time of tuining. */
  totalValidLabelCount?: string;
  /** A list of any applicable data validation warnings about the question's feedback labels. */
  datasetValidationWarnings?: Array<"DATASET_VALIDATION_WARNING_UNSPECIFIED" | "TOO_MANY_INVALID_FEEDBACK_LABELS" | "INSUFFICIENT_FEEDBACK_LABELS" | "INSUFFICIENT_FEEDBACK_LABELS_PER_ANSWER" | "ALL_FEEDBACK_LABELS_HAVE_THE_SAME_ANSWER" | (string & {})>;
  /** Error status of the tuning operation for the question. Will only be set if the tuning operation failed. */
  tuningError?: string;
}

export const GoogleCloudContactcenterinsightsV1QaQuestionTuningMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1QaQuestionTuningMetadata> = Schema.suspend(() => Schema.Struct({
  totalValidLabelCount: Schema.optional(Schema.String),
  datasetValidationWarnings: Schema.optional(Schema.Array(Schema.String)),
  tuningError: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QaQuestionTuningMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QaQuestionTuningMetadata>;

export interface GoogleCloudContactcenterinsightsV1QaQuestion {
  /** Identifier. The resource name of the question. Format: projects/{project}/locations/{location}/qaScorecards/{qa_scorecard}/revisions/{revision}/qaQuestions/{qa_question} */
  name?: string;
  /** Short, descriptive string, used in the UI where it's not practical to display the full question body. E.g., "Greeting". */
  abbreviation?: string;
  /** Output only. The time at which this question was created. */
  createTime?: string;
  /** Output only. The most recent time at which the question was updated. */
  updateTime?: string;
  /** The type of question. */
  questionType?: "QA_QUESTION_TYPE_UNSPECIFIED" | "CUSTOMIZABLE" | "PREDEFINED" | (string & {});
  /** Options for configuring the data used to generate the QA question. */
  qaQuestionDataOptions?: GoogleCloudContactcenterinsightsV1QaQuestionQaQuestionDataOptions;
  /** The configuration of the predefined question. This field will only be set if the Question Type is predefined. */
  predefinedQuestionConfig?: GoogleCloudContactcenterinsightsV1QaQuestionPredefinedQuestionConfig;
  /** Question text. E.g., "Did the agent greet the customer?" */
  questionBody?: string;
  /** Instructions describing how to determine the answer. */
  answerInstructions?: string;
  /** A list of valid answers to the question, which the LLM must choose from. */
  answerChoices?: Array<GoogleCloudContactcenterinsightsV1QaQuestionAnswerChoice>;
  /** Questions are tagged for categorization and scoring. Tags can either be: - Default Tags: These are predefined categories. They are identified by their string value (e.g., "BUSINESS", "COMPLIANCE", and "CUSTOMER"). - Custom Tags: These are user-defined categories. They are identified by their full resource name (e.g., projects/{project}/locations/{location}/qaQuestionTags/{qa_question_tag}). Both default and custom tags are used to group questions and to influence the scoring of each question. */
  tags?: Array<string>;
  /** Defines the order of the question within its parent scorecard revision. */
  order?: number;
  /** Metrics of the underlying tuned LLM over a holdout/test set while fine tuning the underlying LLM for the given question. This field will only be populated if and only if the question is part of a scorecard revision that has been tuned. */
  metrics?: GoogleCloudContactcenterinsightsV1QaQuestionMetrics;
  /** Metadata about the tuning operation for the question.This field will only be populated if and only if the question is part of a scorecard revision that has been tuned. */
  tuningMetadata?: GoogleCloudContactcenterinsightsV1QaQuestionTuningMetadata;
}

export const GoogleCloudContactcenterinsightsV1QaQuestion: Schema.Schema<GoogleCloudContactcenterinsightsV1QaQuestion> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  abbreviation: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  questionType: Schema.optional(Schema.String),
  qaQuestionDataOptions: Schema.optional(GoogleCloudContactcenterinsightsV1QaQuestionQaQuestionDataOptions),
  predefinedQuestionConfig: Schema.optional(GoogleCloudContactcenterinsightsV1QaQuestionPredefinedQuestionConfig),
  questionBody: Schema.optional(Schema.String),
  answerInstructions: Schema.optional(Schema.String),
  answerChoices: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1QaQuestionAnswerChoice)),
  tags: Schema.optional(Schema.Array(Schema.String)),
  order: Schema.optional(Schema.Number),
  metrics: Schema.optional(GoogleCloudContactcenterinsightsV1QaQuestionMetrics),
  tuningMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1QaQuestionTuningMetadata),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QaQuestion" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QaQuestion>;

export interface GoogleCloudContactcenterinsightsV1ListQaQuestionsResponse {
  /** The QaQuestions under the parent. */
  qaQuestions?: Array<GoogleCloudContactcenterinsightsV1QaQuestion>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListQaQuestionsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListQaQuestionsResponse> = Schema.suspend(() => Schema.Struct({
  qaQuestions: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1QaQuestion)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListQaQuestionsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListQaQuestionsResponse>;

export interface GoogleCloudContactcenterinsightsV1QaQuestionTag {
  /** Identifier. Resource name for the QaQuestionTag Format projects/{project}/locations/{location}/qaQuestionTags/{qa_question_tag} In the above format, the last segment, i.e., qa_question_tag, is a server-generated ID corresponding to the tag resource. */
  name?: string;
  /** Required. A user-specified display name for the tag. */
  displayName?: string;
  /** Optional. The list of Scorecard Question IDs that the tag applies to. Each QaQuestionId is represented as a full resource name containing the Question ID. Lastly, Since a tag may not necessarily be referenced by any Scorecard Questions, we treat this field as optional. */
  qaQuestionIds?: Array<string>;
  /** Output only. The time at which the question tag was created. */
  createTime?: string;
  /** Output only. The most recent time at which the question tag was updated. */
  updateTime?: string;
}

export const GoogleCloudContactcenterinsightsV1QaQuestionTag: Schema.Schema<GoogleCloudContactcenterinsightsV1QaQuestionTag> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  qaQuestionIds: Schema.optional(Schema.Array(Schema.String)),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QaQuestionTag" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QaQuestionTag>;

export interface GoogleCloudContactcenterinsightsV1ListQaQuestionTagsResponse {
  /** The parent resource of the questions. */
  qaQuestionTags?: Array<GoogleCloudContactcenterinsightsV1QaQuestionTag>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListQaQuestionTagsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListQaQuestionTagsResponse> = Schema.suspend(() => Schema.Struct({
  qaQuestionTags: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1QaQuestionTag)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListQaQuestionTagsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListQaQuestionTagsResponse>;

export interface GoogleCloudContactcenterinsightsV1QaScorecard {
  /** Identifier. The scorecard name. Format: projects/{project}/locations/{location}/qaScorecards/{qa_scorecard} */
  name?: string;
  /** The user-specified display name of the scorecard. */
  displayName?: string;
  /** A text description explaining the intent of the scorecard. */
  description?: string;
  /** Output only. The time at which this scorecard was created. */
  createTime?: string;
  /** Output only. The most recent time at which the scorecard was updated. */
  updateTime?: string;
  /** Whether the scorecard is the default one for the project. A default scorecard cannot be deleted and will always appear first in scorecard selector. */
  isDefault?: boolean;
  /** Output only. The source of the scorecard. */
  source?: "QA_SCORECARD_SOURCE_UNSPECIFIED" | "QA_SCORECARD_SOURCE_CUSTOMER_DEFINED" | "QA_SCORECARD_SOURCE_DISCOVERY_ENGINE" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1QaScorecard: Schema.Schema<GoogleCloudContactcenterinsightsV1QaScorecard> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  isDefault: Schema.optional(Schema.Boolean),
  source: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QaScorecard" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QaScorecard>;

export interface GoogleCloudContactcenterinsightsV1ListQaScorecardsResponse {
  /** The QaScorecards under the parent. */
  qaScorecards?: Array<GoogleCloudContactcenterinsightsV1QaScorecard>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListQaScorecardsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListQaScorecardsResponse> = Schema.suspend(() => Schema.Struct({
  qaScorecards: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1QaScorecard)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListQaScorecardsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListQaScorecardsResponse>;

export interface GoogleCloudContactcenterinsightsV1QaScorecardRevision {
  /** Identifier. The name of the scorecard revision. Format: projects/{project}/locations/{location}/qaScorecards/{qa_scorecard}/revisions/{revision} */
  name?: string;
  /** The snapshot of the scorecard at the time of this revision's creation. */
  snapshot?: GoogleCloudContactcenterinsightsV1QaScorecard;
  /** Output only. The timestamp that the revision was created. */
  createTime?: string;
  /** Output only. Alternative IDs for this revision of the scorecard, e.g., `latest`. */
  alternateIds?: Array<string>;
  /** Output only. State of the scorecard revision, indicating whether it's ready to be used in analysis. */
  state?: "STATE_UNSPECIFIED" | "EDITABLE" | "TRAINING" | "TRAINING_FAILED" | "READY" | "DELETING" | "TRAINING_CANCELLED" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1QaScorecardRevision: Schema.Schema<GoogleCloudContactcenterinsightsV1QaScorecardRevision> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  snapshot: Schema.optional(GoogleCloudContactcenterinsightsV1QaScorecard),
  createTime: Schema.optional(Schema.String),
  alternateIds: Schema.optional(Schema.Array(Schema.String)),
  state: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QaScorecardRevision" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QaScorecardRevision>;

export interface GoogleCloudContactcenterinsightsV1TuneQaScorecardRevisionRequest {
  /** Required. Filter for selecting the feedback labels that needs to be used for training. This filter can be used to limit the feedback labels used for tuning to a feedback labels created or updated for a specific time-window etc. */
  filter?: string;
  /** Optional. Run in validate only mode, no fine tuning will actually run. Data quality validations like training data distributions will run. Even when set to false, the data quality validations will still run but once the validations complete we will proceed with the fine tune, if applicable. */
  validateOnly?: boolean;
}

export const GoogleCloudContactcenterinsightsV1TuneQaScorecardRevisionRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1TuneQaScorecardRevisionRequest> = Schema.suspend(() => Schema.Struct({
  filter: Schema.optional(Schema.String),
  validateOnly: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1TuneQaScorecardRevisionRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1TuneQaScorecardRevisionRequest>;

export interface GoogleCloudContactcenterinsightsV1DeployQaScorecardRevisionRequest {
}

export const GoogleCloudContactcenterinsightsV1DeployQaScorecardRevisionRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1DeployQaScorecardRevisionRequest> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DeployQaScorecardRevisionRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DeployQaScorecardRevisionRequest>;

export interface GoogleCloudContactcenterinsightsV1UndeployQaScorecardRevisionRequest {
}

export const GoogleCloudContactcenterinsightsV1UndeployQaScorecardRevisionRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1UndeployQaScorecardRevisionRequest> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1UndeployQaScorecardRevisionRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1UndeployQaScorecardRevisionRequest>;

export interface GoogleCloudContactcenterinsightsV1ListQaScorecardRevisionsResponse {
  /** The QaScorecards under the parent. */
  qaScorecardRevisions?: Array<GoogleCloudContactcenterinsightsV1QaScorecardRevision>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListQaScorecardRevisionsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListQaScorecardRevisionsResponse> = Schema.suspend(() => Schema.Struct({
  qaScorecardRevisions: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1QaScorecardRevision)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListQaScorecardRevisionsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListQaScorecardRevisionsResponse>;

export interface GoogleCloudContactcenterinsightsV1ListFeedbackLabelsResponse {
  /** The feedback labels that match the request. */
  feedbackLabels?: Array<GoogleCloudContactcenterinsightsV1FeedbackLabel>;
  /** The next page token. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListFeedbackLabelsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListFeedbackLabelsResponse> = Schema.suspend(() => Schema.Struct({
  feedbackLabels: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1FeedbackLabel)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListFeedbackLabelsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListFeedbackLabelsResponse>;

export interface GoogleCloudContactcenterinsightsV1ListAllFeedbackLabelsResponse {
  /** The feedback labels that match the request. */
  feedbackLabels?: Array<GoogleCloudContactcenterinsightsV1FeedbackLabel>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListAllFeedbackLabelsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListAllFeedbackLabelsResponse> = Schema.suspend(() => Schema.Struct({
  feedbackLabels: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1FeedbackLabel)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListAllFeedbackLabelsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListAllFeedbackLabelsResponse>;

export interface GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequestGcsSource {
  /** Required. File format which will be ingested. */
  format?: "FORMAT_UNSPECIFIED" | "CSV" | "JSON" | (string & {});
  /** Required. The Google Cloud Storage URI of the file to import. Format: `gs://bucket_name/object_name` */
  objectUri?: string;
}

export const GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequestGcsSource: Schema.Schema<GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequestGcsSource> = Schema.suspend(() => Schema.Struct({
  format: Schema.optional(Schema.String),
  objectUri: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequestGcsSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequestGcsSource>;

export interface GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequestSheetsSource {
  /** Required. The Google Sheets document to write the feedback labels to. Retrieved from Google Sheets URI. E.g. `https://docs.google.com/spreadsheets/d/1234567890` The spreadsheet must be shared with the Insights P4SA. */
  spreadsheetUri?: string;
}

export const GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequestSheetsSource: Schema.Schema<GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequestSheetsSource> = Schema.suspend(() => Schema.Struct({
  spreadsheetUri: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequestSheetsSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequestSheetsSource>;

export interface GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequest {
  /** A cloud storage bucket source. */
  gcsSource?: GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequestGcsSource;
  /** A sheets document source. */
  sheetsSource?: GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequestSheetsSource;
  /** Optional. If set, upload will not happen and the labels will be validated. If not set, then default behavior will be to upload the labels after validation is complete. */
  validateOnly?: boolean;
}

export const GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequest> = Schema.suspend(() => Schema.Struct({
  gcsSource: Schema.optional(GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequestGcsSource),
  sheetsSource: Schema.optional(GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequestSheetsSource),
  validateOnly: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequest>;

export interface GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequestGcsDestination {
  /** Required. File format in which the labels will be exported. */
  format?: "FORMAT_UNSPECIFIED" | "CSV" | "JSON" | (string & {});
  /** Required. The Google Cloud Storage URI to write the feedback labels to. The file name will be used as a prefix for the files written to the bucket if the output needs to be split across multiple files, otherwise it will be used as is. The file extension will be appended to the file name based on the format selected. E.g. `gs://bucket_name/object_uri_prefix` */
  objectUri?: string;
  /** Optional. Add whitespace to the JSON file. Makes easier to read, but increases file size. Only applicable for JSON format. */
  addWhitespace?: boolean;
  /** Optional. Always print fields with no presence. This is useful for printing fields that are not set, like implicit 0 value or empty lists/maps. Only applicable for JSON format. */
  alwaysPrintEmptyFields?: boolean;
  /** Optional. The number of records per file. Applicable for either format. */
  recordsPerFileCount?: string;
}

export const GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequestGcsDestination: Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequestGcsDestination> = Schema.suspend(() => Schema.Struct({
  format: Schema.optional(Schema.String),
  objectUri: Schema.optional(Schema.String),
  addWhitespace: Schema.optional(Schema.Boolean),
  alwaysPrintEmptyFields: Schema.optional(Schema.Boolean),
  recordsPerFileCount: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequestGcsDestination" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequestGcsDestination>;

export interface GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequestSheetsDestination {
  /** Required. The Google Sheets document to write the feedback labels to. Retrieved from Google Sheets URI. E.g. `https://docs.google.com/spreadsheets/d/1234567890` The spreadsheet must be shared with the Insights P4SA. The spreadsheet ID written to will be returned as `file_names` in the BulkDownloadFeedbackLabelsMetadata. */
  spreadsheetUri?: string;
  /** Optional. The title of the new sheet to write the feedback labels to. */
  sheetTitle?: string;
}

export const GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequestSheetsDestination: Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequestSheetsDestination> = Schema.suspend(() => Schema.Struct({
  spreadsheetUri: Schema.optional(Schema.String),
  sheetTitle: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequestSheetsDestination" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequestSheetsDestination>;

export interface GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequest {
  /** A cloud storage bucket destination. */
  gcsDestination?: GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequestGcsDestination;
  /** A sheets document destination. */
  sheetsDestination?: GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequestSheetsDestination;
  /** Required. The parent resource for new feedback labels. */
  parent?: string;
  /** Optional. A filter to reduce results to a specific subset. Supports disjunctions (OR) and conjunctions (AND). Supported fields: * `issue_model_id` * `qa_question_id` * `qa_scorecard_id` * `min_create_time` * `max_create_time` * `min_update_time` * `max_update_time` * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING */
  filter?: string;
  /** Optional. Limits the maximum number of feedback labels that will be downloaded. The first `N` feedback labels will be downloaded. */
  maxDownloadCount?: number;
  /** Optional. The type of feedback labels that will be downloaded. */
  feedbackLabelType?: "FEEDBACK_LABEL_TYPE_UNSPECIFIED" | "QUALITY_AI" | "TOPIC_MODELING" | "AGENT_ASSIST_SUMMARY" | (string & {});
  /** Optional. Filter parent conversations to download feedback labels for. When specified, the feedback labels will be downloaded for the conversations that match the filter. If `template_qa_scorecard_id` is set, all the conversations that match the filter will be paired with the questions under the scorecard for labeling. */
  conversationFilter?: string;
  /** Optional. If set, a template for labeling conversations and scorecard questions will be created from the conversation_filter and the questions under the scorecard(s). The feedback label `filter` will be ignored. */
  templateQaScorecardId?: Array<string>;
}

export const GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequest> = Schema.suspend(() => Schema.Struct({
  gcsDestination: Schema.optional(GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequestGcsDestination),
  sheetsDestination: Schema.optional(GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequestSheetsDestination),
  parent: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
  maxDownloadCount: Schema.optional(Schema.Number),
  feedbackLabelType: Schema.optional(Schema.String),
  conversationFilter: Schema.optional(Schema.String),
  templateQaScorecardId: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequest>;

export interface GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsRequest {
  /** Required. The parent resource for new feedback labels. */
  parent?: string;
  /** Optional. A filter to reduce results to a specific subset. Supports disjunctions (OR) and conjunctions (AND). Supported fields: * `issue_model_id` * `qa_question_id` * `qa_scorecard_id` * `min_create_time` * `max_create_time` * `min_update_time` * `max_update_time` * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING */
  filter?: string;
}

export const GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsRequest>;

export interface GoogleCloudContactcenterinsightsV1AuthorizedViewSet {
  /** Identifier. The resource name of the AuthorizedViewSet. Format: projects/{project}/locations/{location}/authorizedViewSets/{authorized_view_set} */
  name?: string;
  /** Display Name. Limit 64 characters. */
  displayName?: string;
  /** Output only. Create time. */
  createTime?: string;
  /** Output only. Update time. */
  updateTime?: string;
}

export const GoogleCloudContactcenterinsightsV1AuthorizedViewSet: Schema.Schema<GoogleCloudContactcenterinsightsV1AuthorizedViewSet> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1AuthorizedViewSet" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1AuthorizedViewSet>;

export interface GoogleCloudContactcenterinsightsV1ListAuthorizedViewSetsResponse {
  /** The AuthorizedViewSets under the parent. */
  authorizedViewSets?: Array<GoogleCloudContactcenterinsightsV1AuthorizedViewSet>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListAuthorizedViewSetsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListAuthorizedViewSetsResponse> = Schema.suspend(() => Schema.Struct({
  authorizedViewSets: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1AuthorizedViewSet)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListAuthorizedViewSetsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListAuthorizedViewSetsResponse>;

export interface GoogleCloudContactcenterinsightsV1AuthorizedView {
  /** Identifier. The resource name of the AuthorizedView. Format: projects/{project}/locations/{location}/authorizedViewSets/{authorized_view_set}/authorizedViews/{authorized_view} */
  name?: string;
  /** Display Name. Limit 64 characters. */
  displayName?: string;
  /** A filter to reduce conversation results to a specific subset. The AuthorizedView's assigned permission (read/write) could be applied to the subset of conversations. If conversation_filter is empty, there is no restriction on the conversations that the AuthorizedView can access. Having *authorizedViews.get* access to the AuthorizedView means having the same read/write access to the Conversations (as well as metadata/annotations linked to the conversation) that this AuthorizedView has. */
  conversationFilter?: string;
  /** Output only. The time at which the authorized view was created. */
  createTime?: string;
  /** Output only. The most recent time at which the authorized view was updated. */
  updateTime?: string;
}

export const GoogleCloudContactcenterinsightsV1AuthorizedView: Schema.Schema<GoogleCloudContactcenterinsightsV1AuthorizedView> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  conversationFilter: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1AuthorizedView" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1AuthorizedView>;

export interface GoogleCloudContactcenterinsightsV1ListAuthorizedViewsResponse {
  /** The AuthorizedViews under the parent. */
  authorizedViews?: Array<GoogleCloudContactcenterinsightsV1AuthorizedView>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListAuthorizedViewsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListAuthorizedViewsResponse> = Schema.suspend(() => Schema.Struct({
  authorizedViews: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1AuthorizedView)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListAuthorizedViewsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListAuthorizedViewsResponse>;

export interface GoogleCloudContactcenterinsightsV1SearchAuthorizedViewsResponse {
  /** The AuthorizedViews under the parent. */
  authorizedViews?: Array<GoogleCloudContactcenterinsightsV1AuthorizedView>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1SearchAuthorizedViewsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1SearchAuthorizedViewsResponse> = Schema.suspend(() => Schema.Struct({
  authorizedViews: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1AuthorizedView)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1SearchAuthorizedViewsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1SearchAuthorizedViewsResponse>;

export interface GoogleCloudContactcenterinsightsV1Assessment {
  /** Identifier. The resource name of the assessment. Format: projects/{project}/locations/{location}/conversations/{conversation}/assessments/{assessment} */
  name?: string;
  /** Output only. The time at which the assessment was created. */
  createTime?: string;
  /** Output only. The time at which the assessment was last updated. */
  updateTime?: string;
  /** Output only. The state of the assessment. */
  state?: "STATE_UNSPECIFIED" | "DRAFT" | "PUBLISHED" | "APPEALED" | "FINALIZED" | (string & {});
  /** Information about the agent the assessment is for. */
  agentInfo?: GoogleCloudContactcenterinsightsV1ConversationQualityMetadataAgentInfo;
}

export const GoogleCloudContactcenterinsightsV1Assessment: Schema.Schema<GoogleCloudContactcenterinsightsV1Assessment> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  state: Schema.optional(Schema.String),
  agentInfo: Schema.optional(GoogleCloudContactcenterinsightsV1ConversationQualityMetadataAgentInfo),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1Assessment" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1Assessment>;

export interface GoogleCloudContactcenterinsightsV1ListAssessmentsResponse {
  /** The assessments that match the request. */
  assessments?: Array<GoogleCloudContactcenterinsightsV1Assessment>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListAssessmentsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListAssessmentsResponse> = Schema.suspend(() => Schema.Struct({
  assessments: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1Assessment)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListAssessmentsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListAssessmentsResponse>;

export interface GoogleCloudContactcenterinsightsV1PublishAssessmentRequest {
}

export const GoogleCloudContactcenterinsightsV1PublishAssessmentRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1PublishAssessmentRequest> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1PublishAssessmentRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1PublishAssessmentRequest>;

export interface GoogleCloudContactcenterinsightsV1AppealAssessmentRequest {
}

export const GoogleCloudContactcenterinsightsV1AppealAssessmentRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1AppealAssessmentRequest> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1AppealAssessmentRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1AppealAssessmentRequest>;

export interface GoogleCloudContactcenterinsightsV1FinalizeAssessmentRequest {
}

export const GoogleCloudContactcenterinsightsV1FinalizeAssessmentRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1FinalizeAssessmentRequest> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1FinalizeAssessmentRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1FinalizeAssessmentRequest>;

export interface GoogleCloudContactcenterinsightsV1NoteConversationTurnNote {
  /** The conversation turn index that the note is associated with. */
  turnIndex?: number;
}

export const GoogleCloudContactcenterinsightsV1NoteConversationTurnNote: Schema.Schema<GoogleCloudContactcenterinsightsV1NoteConversationTurnNote> = Schema.suspend(() => Schema.Struct({
  turnIndex: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1NoteConversationTurnNote" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1NoteConversationTurnNote>;

export interface GoogleCloudContactcenterinsightsV1NoteQaQuestionNote {
  /** The question resource that the note is associated with. */
  qaQuestion?: string;
}

export const GoogleCloudContactcenterinsightsV1NoteQaQuestionNote: Schema.Schema<GoogleCloudContactcenterinsightsV1NoteQaQuestionNote> = Schema.suspend(() => Schema.Struct({
  qaQuestion: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1NoteQaQuestionNote" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1NoteQaQuestionNote>;

export interface GoogleCloudContactcenterinsightsV1NoteAssessmentNote {
}

export const GoogleCloudContactcenterinsightsV1NoteAssessmentNote: Schema.Schema<GoogleCloudContactcenterinsightsV1NoteAssessmentNote> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1NoteAssessmentNote" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1NoteAssessmentNote>;

export interface GoogleCloudContactcenterinsightsV1UserInfo {
  /** The user's username. */
  username?: string;
}

export const GoogleCloudContactcenterinsightsV1UserInfo: Schema.Schema<GoogleCloudContactcenterinsightsV1UserInfo> = Schema.suspend(() => Schema.Struct({
  username: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1UserInfo" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1UserInfo>;

export interface GoogleCloudContactcenterinsightsV1Note {
  /** The note is associated with a conversation turn. */
  conversationTurnNote?: GoogleCloudContactcenterinsightsV1NoteConversationTurnNote;
  /** The note is associated with a QA question in one of the conversation's scorecard results. */
  qaQuestionNote?: GoogleCloudContactcenterinsightsV1NoteQaQuestionNote;
  /** The note is associated to the entire parent assessment. */
  assessmentNote?: GoogleCloudContactcenterinsightsV1NoteAssessmentNote;
  /** Identifier. The resource name of the note. Format: projects/{project}/locations/{location}/conversations/{conversation}/assessments/{assessment}/notes/{note} */
  name?: string;
  /** Output only. The time at which the note was created. */
  createTime?: string;
  /** Output only. The time at which the note was last updated. */
  updateTime?: string;
  /** Output only. The user that created the note. */
  noteCreator?: GoogleCloudContactcenterinsightsV1UserInfo;
  /** The note content. */
  content?: string;
}

export const GoogleCloudContactcenterinsightsV1Note: Schema.Schema<GoogleCloudContactcenterinsightsV1Note> = Schema.suspend(() => Schema.Struct({
  conversationTurnNote: Schema.optional(GoogleCloudContactcenterinsightsV1NoteConversationTurnNote),
  qaQuestionNote: Schema.optional(GoogleCloudContactcenterinsightsV1NoteQaQuestionNote),
  assessmentNote: Schema.optional(GoogleCloudContactcenterinsightsV1NoteAssessmentNote),
  name: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  noteCreator: Schema.optional(GoogleCloudContactcenterinsightsV1UserInfo),
  content: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1Note" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1Note>;

export interface GoogleCloudContactcenterinsightsV1ListNotesResponse {
  /** The notes that match the request. */
  notes?: Array<GoogleCloudContactcenterinsightsV1Note>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListNotesResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListNotesResponse> = Schema.suspend(() => Schema.Struct({
  notes: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1Note)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListNotesResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListNotesResponse>;

export interface GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageUserMessage {
  /** A message from the user that is interacting with the system. */
  text?: string;
}

export const GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageUserMessage: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageUserMessage> = Schema.suspend(() => Schema.Struct({
  text: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageUserMessage" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageUserMessage>;

export interface GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageSystemMessageTextOutput {
  /** The parts of the message. */
  texts?: Array<string>;
  /** The type of the text message. */
  type?: "TYPE_UNSPECIFIED" | "THOUGHT" | "FINAL_RESPONSE" | "PROGRESS" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageSystemMessageTextOutput: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageSystemMessageTextOutput> = Schema.suspend(() => Schema.Struct({
  texts: Schema.optional(Schema.Array(Schema.String)),
  type: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageSystemMessageTextOutput" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageSystemMessageTextOutput>;

export interface GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageSystemMessage {
  /** A direct natural language response to the user message. */
  textOutput?: GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageSystemMessageTextOutput;
  /** Raw SQL from LLM, before templatization */
  generatedSqlQuery?: string;
  /** Chart spec from LLM */
  chartSpec?: Record<string, unknown>;
}

export const GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageSystemMessage: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageSystemMessage> = Schema.suspend(() => Schema.Struct({
  textOutput: Schema.optional(GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageSystemMessageTextOutput),
  generatedSqlQuery: Schema.optional(Schema.String),
  chartSpec: Schema.optional(Schema.Record(Schema.String, Schema.Unknown)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageSystemMessage" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageSystemMessage>;

export interface GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessage {
  /** A message from the user that is interacting with the system. */
  userMessage?: GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageUserMessage;
  /** A message from the system in response to the user. */
  systemMessage?: GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageSystemMessage;
  /** The message id of the message. */
  messageId?: string;
  /** For user messages, this is the time at which the system received the message. For system messages, this is the time at which the system generated the message. */
  createTime?: string;
}

export const GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessage: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessage> = Schema.suspend(() => Schema.Struct({
  userMessage: Schema.optional(GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageUserMessage),
  systemMessage: Schema.optional(GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessageSystemMessage),
  messageId: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessage" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessage>;

export interface GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversation {
  /** The conversation id of the chart. */
  conversationId?: string;
  /** The create time of the conversation. */
  createTime?: string;
  /** The update time of the conversation. */
  updateTime?: string;
  /** Ordered list of messages, including user inputs and system responses. */
  messages?: Array<GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessage>;
}

export const GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversation: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversation> = Schema.suspend(() => Schema.Struct({
  conversationId: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  messages: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversationMessage)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversation" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversation>;

export interface GoogleCloudContactcenterinsightsV1GenerativeInsightsChartCheckpoint {
  /** The session id of the chart. */
  sessionId?: string;
  /** The revision id of the chart. */
  revisionId?: string;
}

export const GoogleCloudContactcenterinsightsV1GenerativeInsightsChartCheckpoint: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsChartCheckpoint> = Schema.suspend(() => Schema.Struct({
  sessionId: Schema.optional(Schema.String),
  revisionId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerativeInsightsChartCheckpoint" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsChartCheckpoint>;

export interface GoogleCloudContactcenterinsightsV1GenerativeInsights {
  request?: Record<string, unknown>;
  /** Chart spec for the chart. */
  chartSpec?: Record<string, unknown>;
  /** SQL query used to generate the chart. */
  sqlQuery?: string;
  /** Optional. For charts with comparison, this key will determine the metric that will be compared between the current and another dataset. */
  sqlComparisonKey?: string;
  /** Output only. The chart conversations used to generate the chart. */
  chartConversations?: Array<GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversation>;
  /** The chart checkpoint used to generate the chart. */
  chartCheckpoint?: GoogleCloudContactcenterinsightsV1GenerativeInsightsChartCheckpoint;
}

export const GoogleCloudContactcenterinsightsV1GenerativeInsights: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsights> = Schema.suspend(() => Schema.Struct({
  request: Schema.optional(Schema.Record(Schema.String, Schema.Unknown)),
  chartSpec: Schema.optional(Schema.Record(Schema.String, Schema.Unknown)),
  sqlQuery: Schema.optional(Schema.String),
  sqlComparisonKey: Schema.optional(Schema.String),
  chartConversations: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1GenerativeInsightsChartConversation)),
  chartCheckpoint: Schema.optional(GoogleCloudContactcenterinsightsV1GenerativeInsightsChartCheckpoint),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerativeInsights" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsights>;

export interface GoogleCloudContactcenterinsightsV1QueryMetrics {
  request?: Record<string, unknown>;
}

export const GoogleCloudContactcenterinsightsV1QueryMetrics: Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetrics> = Schema.suspend(() => Schema.Struct({
  request: Schema.optional(Schema.Record(Schema.String, Schema.Unknown)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QueryMetrics" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetrics>;

export interface GoogleCloudContactcenterinsightsV1ChartDataSource {
  /** Use natural language query to generate the chart. */
  generativeInsights?: GoogleCloudContactcenterinsightsV1GenerativeInsights;
  /** Use the existing QueryMetrics to generate the chart. */
  queryMetrics?: GoogleCloudContactcenterinsightsV1QueryMetrics;
}

export const GoogleCloudContactcenterinsightsV1ChartDataSource: Schema.Schema<GoogleCloudContactcenterinsightsV1ChartDataSource> = Schema.suspend(() => Schema.Struct({
  generativeInsights: Schema.optional(GoogleCloudContactcenterinsightsV1GenerativeInsights),
  queryMetrics: Schema.optional(GoogleCloudContactcenterinsightsV1QueryMetrics),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ChartDataSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ChartDataSource>;

export interface GoogleCloudContactcenterinsightsV1DateRangeConfigRelativeDateRange {
  /** Required. The quantity of units in the past. */
  quantity?: string;
  /** Required. The unit of time. */
  unit?: "TIME_UNIT_UNSPECIFIED" | "DAY" | "WEEK" | "MONTH" | "QUARTER" | "YEAR" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1DateRangeConfigRelativeDateRange: Schema.Schema<GoogleCloudContactcenterinsightsV1DateRangeConfigRelativeDateRange> = Schema.suspend(() => Schema.Struct({
  quantity: Schema.optional(Schema.String),
  unit: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DateRangeConfigRelativeDateRange" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DateRangeConfigRelativeDateRange>;

export interface GoogleCloudContactcenterinsightsV1DateRangeConfig {
  /** A relative date range. */
  relativeDateRange?: GoogleCloudContactcenterinsightsV1DateRangeConfigRelativeDateRange;
  /** An absolute date range. */
  absoluteDateRange?: GoogleCloudContactcenterinsightsV1QueryInterval;
}

export const GoogleCloudContactcenterinsightsV1DateRangeConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1DateRangeConfig> = Schema.suspend(() => Schema.Struct({
  relativeDateRange: Schema.optional(GoogleCloudContactcenterinsightsV1DateRangeConfigRelativeDateRange),
  absoluteDateRange: Schema.optional(GoogleCloudContactcenterinsightsV1QueryInterval),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DateRangeConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DateRangeConfig>;

export interface GoogleCloudContactcenterinsightsV1Chart {
  /** Identifier. Chart resource name. Format: projects/{project}/locations/{location}/dashboards/{dashboard}/charts/{chart} */
  name?: string;
  /** User provided display name of the chart. */
  displayName?: string;
  /** Chart description */
  description?: string;
  /** Chart visualization type. */
  chartVisualizationType?: "CHART_VISUALIZATION_TYPE_UNSPECIFIED" | "BAR" | "LINE" | "AREA" | "PIE" | "SCATTER" | "TABLE" | "SCORE_CARD" | "SUNBURST" | "GAUGE" | "SANKEY" | (string & {});
  /** The width of the chart in grid units. */
  width?: number;
  /** The height of the chart in grid units. */
  height?: number;
  /** Output only. Chart create time. */
  createTime?: string;
  /** Output only. Chart last update time. */
  updateTime?: string;
  /** Output only. Chart type. */
  chartType?: "CHART_TYPE_UNSPECIFIED" | "SYSTEM_DEFINED" | "USER_DEFINED" | (string & {});
  dataSource?: GoogleCloudContactcenterinsightsV1ChartDataSource;
  /** Filter applied to all charts in the container. Should support scope later. */
  filter?: string;
  /** Date range config applied to the chart. */
  dateRangeConfig?: GoogleCloudContactcenterinsightsV1DateRangeConfig;
}

export const GoogleCloudContactcenterinsightsV1Chart: Schema.Schema<GoogleCloudContactcenterinsightsV1Chart> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  chartVisualizationType: Schema.optional(Schema.String),
  width: Schema.optional(Schema.Number),
  height: Schema.optional(Schema.Number),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  chartType: Schema.optional(Schema.String),
  dataSource: Schema.optional(GoogleCloudContactcenterinsightsV1ChartDataSource),
  filter: Schema.optional(Schema.String),
  dateRangeConfig: Schema.optional(GoogleCloudContactcenterinsightsV1DateRangeConfig),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1Chart" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1Chart>;

export interface GoogleCloudContactcenterinsightsV1Widget {
  /** A container widget. */
  container?: GoogleCloudContactcenterinsightsV1Container;
  /** A chart widget. */
  chart?: GoogleCloudContactcenterinsightsV1Chart;
  /** A reference to a chart widget. Format: projects/{project}/locations/{location}/dashboards/{dashboard}/charts/{chart} */
  chartReference?: string;
  /** Filter applied to all charts in the container. Should support scope later. */
  filter?: string;
}

export const GoogleCloudContactcenterinsightsV1Widget: Schema.Schema<GoogleCloudContactcenterinsightsV1Widget> = Schema.suspend(() => Schema.Struct({
  container: Schema.optional(GoogleCloudContactcenterinsightsV1Container),
  chart: Schema.optional(GoogleCloudContactcenterinsightsV1Chart),
  chartReference: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1Widget" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1Widget>;

export interface GoogleCloudContactcenterinsightsV1Container {
  /** User provided display name of the Container. */
  displayName?: string;
  /** Widgets in the Container. */
  widgets?: Array<GoogleCloudContactcenterinsightsV1Widget>;
  /** Container description */
  description?: string;
  /** Filter applied to all charts in the container. Should support scope later. */
  filter?: string;
  /** The width of the container in grid units. */
  width?: number;
  /** The height of the container in grid units. */
  height?: number;
  /** Output only. Unique ID for the container. */
  containerId?: string;
  /** Date range config applied to all charts in the container. */
  dateRangeConfig?: GoogleCloudContactcenterinsightsV1DateRangeConfig;
}

export const GoogleCloudContactcenterinsightsV1Container: Schema.Schema<GoogleCloudContactcenterinsightsV1Container> = Schema.suspend(() => Schema.Struct({
  displayName: Schema.optional(Schema.String),
  widgets: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1Widget)),
  description: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
  width: Schema.optional(Schema.Number),
  height: Schema.optional(Schema.Number),
  containerId: Schema.optional(Schema.String),
  dateRangeConfig: Schema.optional(GoogleCloudContactcenterinsightsV1DateRangeConfig),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1Container" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1Container>;

export interface GoogleCloudContactcenterinsightsV1Dashboard {
  /** Identifier. Dashboard resource name. Format: projects/{project}/locations/{location}/dashboards/{dashboard} */
  name?: string;
  /** User provided display name of the dashboard. */
  displayName?: string;
  /** The dashboard's root widget container. We want to display the dashboard layout in a tree-like structure, where the root container contains other widgets (containers or charts) as children. */
  rootContainer?: GoogleCloudContactcenterinsightsV1Container;
  /** Dashboard description */
  description?: string;
  /** Output only. Dashboard creation time. */
  createTime?: string;
  /** Output only. Dashboard last update time. */
  updateTime?: string;
  /** Filter applied to all charts in the dashboard. Should support scope later. */
  filter?: string;
  /** Date range config applied to all charts in the dashboard. */
  dateRangeConfig?: GoogleCloudContactcenterinsightsV1DateRangeConfig;
  /** Output only. Whether the dashboard is read-only. All predefined dashboards are read-only and cannot be modified by the user. */
  readOnly?: boolean;
}

export const GoogleCloudContactcenterinsightsV1Dashboard: Schema.Schema<GoogleCloudContactcenterinsightsV1Dashboard> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  rootContainer: Schema.optional(GoogleCloudContactcenterinsightsV1Container),
  description: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
  dateRangeConfig: Schema.optional(GoogleCloudContactcenterinsightsV1DateRangeConfig),
  readOnly: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1Dashboard" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1Dashboard>;

export interface GoogleCloudContactcenterinsightsV1ListDashboardsResponse {
  /** The dashboards under the parent. */
  dashboards?: Array<GoogleCloudContactcenterinsightsV1Dashboard>;
  /** The value returned by the last `ListDashboardsResponse`. This value indicates that this is a continuation of a prior `ListDashboards` call and that the system should return the next page of data. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListDashboardsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListDashboardsResponse> = Schema.suspend(() => Schema.Struct({
  dashboards: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1Dashboard)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListDashboardsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListDashboardsResponse>;

export interface GoogleCloudContactcenterinsightsV1ListChartsResponse {
  /** The charts under the parent. */
  charts?: Array<GoogleCloudContactcenterinsightsV1Chart>;
  /** The value returned by the last `ListChartsResponse`. This value indicates that this is a continuation of a prior `ListCharts` call and that the system should return the next page of data. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1ListChartsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ListChartsResponse> = Schema.suspend(() => Schema.Struct({
  charts: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1Chart)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ListChartsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ListChartsResponse>;

export interface GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsMetadata {
  /** The time the operation was created. */
  createTime?: string;
  /** The time the operation finished running. */
  endTime?: string;
  /** The original request for bulk analyze. */
  request?: GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsRequest;
  /** The number of requested analyses that have completed successfully so far. */
  completedAnalysesCount?: number;
  /** The number of requested analyses that have failed so far. */
  failedAnalysesCount?: number;
  /** Total number of analyses requested. Computed by the number of conversations returned by `filter` multiplied by `analysis_percentage` in the request. */
  totalRequestedAnalysesCount?: number;
  /** Output only. Partial errors during bulk analyze operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
}

export const GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsRequest),
  completedAnalysesCount: Schema.optional(Schema.Number),
  failedAnalysesCount: Schema.optional(Schema.Number),
  totalRequestedAnalysesCount: Schema.optional(Schema.Number),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsMetadata>;

export interface GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsResponse {
  /** Count of successful analyses. */
  successfulAnalysisCount?: number;
  /** Count of failed analyses. */
  failedAnalysisCount?: number;
}

export const GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsResponse> = Schema.suspend(() => Schema.Struct({
  successfulAnalysisCount: Schema.optional(Schema.Number),
  failedAnalysisCount: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsResponse>;

export interface GoogleCloudContactcenterinsightsV1BulkDeleteConversationsMetadata {
  /** The time the operation was created. */
  createTime?: string;
  /** The time the operation finished running. */
  endTime?: string;
  /** The original request for bulk delete. */
  request?: GoogleCloudContactcenterinsightsV1BulkDeleteConversationsRequest;
  /** Partial errors during bulk delete conversations operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
}

export const GoogleCloudContactcenterinsightsV1BulkDeleteConversationsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDeleteConversationsMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1BulkDeleteConversationsRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1BulkDeleteConversationsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDeleteConversationsMetadata>;

export interface GoogleCloudContactcenterinsightsV1BulkDeleteConversationsResponse {
}

export const GoogleCloudContactcenterinsightsV1BulkDeleteConversationsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDeleteConversationsResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1BulkDeleteConversationsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDeleteConversationsResponse>;

export interface GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsMetadata {
  /** Output only. The original request for delete. */
  request?: GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsRequest;
  /** Partial errors during deletion operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
}

export const GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsMetadata> = Schema.suspend(() => Schema.Struct({
  request: Schema.optional(GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsMetadata>;

export interface GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsResponse {
}

export const GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsResponse>;

export interface GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsMetadataDownloadStats {
  /** The number of objects processed during the download operation. */
  processedObjectCount?: number;
  /** The number of new feedback labels downloaded during this operation. Different from "processed" because some labels might not be downloaded because an error. */
  successfulDownloadCount?: number;
  /** Total number of files written to the provided Cloud Storage bucket. */
  totalFilesWritten?: number;
  /** Output only. Full name of the files written to Cloud storage. */
  fileNames?: Array<string>;
}

export const GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsMetadataDownloadStats: Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsMetadataDownloadStats> = Schema.suspend(() => Schema.Struct({
  processedObjectCount: Schema.optional(Schema.Number),
  successfulDownloadCount: Schema.optional(Schema.Number),
  totalFilesWritten: Schema.optional(Schema.Number),
  fileNames: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsMetadataDownloadStats" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsMetadataDownloadStats>;

export interface GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request for download. */
  request?: GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequest;
  /** Partial errors during ingest operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
  /** Output only. Statistics for BulkDownloadFeedbackLabels operation. */
  downloadStats?: GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsMetadataDownloadStats;
}

export const GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
  downloadStats: Schema.optional(GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsMetadataDownloadStats),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsMetadata>;

export interface GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsResponse {
}

export const GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsResponse>;

export interface GoogleCloudContactcenterinsightsV1CreateAnalysisOperationMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The Conversation that this Analysis Operation belongs to. */
  conversation?: string;
  /** Output only. The annotator selector used for the analysis (if any). */
  annotatorSelector?: GoogleCloudContactcenterinsightsV1AnnotatorSelector;
}

export const GoogleCloudContactcenterinsightsV1CreateAnalysisOperationMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1CreateAnalysisOperationMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  conversation: Schema.optional(Schema.String),
  annotatorSelector: Schema.optional(GoogleCloudContactcenterinsightsV1AnnotatorSelector),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1CreateAnalysisOperationMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1CreateAnalysisOperationMetadata>;

export interface GoogleCloudContactcenterinsightsV1CreateIssueRequest {
  /** Required. The parent resource of the issue. */
  parent?: string;
  /** Required. The values for the new issue. */
  issue?: GoogleCloudContactcenterinsightsV1Issue;
}

export const GoogleCloudContactcenterinsightsV1CreateIssueRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1CreateIssueRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  issue: Schema.optional(GoogleCloudContactcenterinsightsV1Issue),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1CreateIssueRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1CreateIssueRequest>;

export interface GoogleCloudContactcenterinsightsV1CreateIssueMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** The original request for creation. */
  request?: GoogleCloudContactcenterinsightsV1CreateIssueRequest;
}

export const GoogleCloudContactcenterinsightsV1CreateIssueMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1CreateIssueMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1CreateIssueRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1CreateIssueMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1CreateIssueMetadata>;

export interface GoogleCloudContactcenterinsightsV1CreateIssueModelRequest {
  /** Required. The parent resource of the issue model. */
  parent?: string;
  /** Required. The issue model to create. */
  issueModel?: GoogleCloudContactcenterinsightsV1IssueModel;
}

export const GoogleCloudContactcenterinsightsV1CreateIssueModelRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1CreateIssueModelRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  issueModel: Schema.optional(GoogleCloudContactcenterinsightsV1IssueModel),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1CreateIssueModelRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1CreateIssueModelRequest>;

export interface GoogleCloudContactcenterinsightsV1CreateIssueModelMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** The original request for creation. */
  request?: GoogleCloudContactcenterinsightsV1CreateIssueModelRequest;
}

export const GoogleCloudContactcenterinsightsV1CreateIssueModelMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1CreateIssueModelMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1CreateIssueModelRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1CreateIssueModelMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1CreateIssueModelMetadata>;

export interface GoogleCloudContactcenterinsightsV1DeleteIssueModelRequest {
  /** Required. The name of the issue model to delete. */
  name?: string;
}

export const GoogleCloudContactcenterinsightsV1DeleteIssueModelRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1DeleteIssueModelRequest> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DeleteIssueModelRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DeleteIssueModelRequest>;

export interface GoogleCloudContactcenterinsightsV1DeleteIssueModelMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** The original request for deletion. */
  request?: GoogleCloudContactcenterinsightsV1DeleteIssueModelRequest;
}

export const GoogleCloudContactcenterinsightsV1DeleteIssueModelMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1DeleteIssueModelMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1DeleteIssueModelRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DeleteIssueModelMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DeleteIssueModelMetadata>;

export interface GoogleCloudContactcenterinsightsV1DeleteQaQuestionTagRequest {
  /** Required. The name of the QaQuestionTag to delete. */
  name?: string;
}

export const GoogleCloudContactcenterinsightsV1DeleteQaQuestionTagRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1DeleteQaQuestionTagRequest> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DeleteQaQuestionTagRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DeleteQaQuestionTagRequest>;

export interface GoogleCloudContactcenterinsightsV1DeleteQaQuestionTagMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request. */
  request?: GoogleCloudContactcenterinsightsV1DeleteQaQuestionTagRequest;
}

export const GoogleCloudContactcenterinsightsV1DeleteQaQuestionTagMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1DeleteQaQuestionTagMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1DeleteQaQuestionTagRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DeleteQaQuestionTagMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DeleteQaQuestionTagMetadata>;

export interface GoogleCloudContactcenterinsightsV1DeployIssueModelMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** The original request for deployment. */
  request?: GoogleCloudContactcenterinsightsV1DeployIssueModelRequest;
}

export const GoogleCloudContactcenterinsightsV1DeployIssueModelMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1DeployIssueModelMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1DeployIssueModelRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DeployIssueModelMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DeployIssueModelMetadata>;

export interface GoogleCloudContactcenterinsightsV1DeployIssueModelResponse {
}

export const GoogleCloudContactcenterinsightsV1DeployIssueModelResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1DeployIssueModelResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1DeployIssueModelResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1DeployIssueModelResponse>;

export interface GoogleCloudContactcenterinsightsV1ExportInsightsDataMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** The original request for export. */
  request?: GoogleCloudContactcenterinsightsV1ExportInsightsDataRequest;
  /** Partial errors during export operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
  /** The number of conversations that were exported successfully. */
  completedExportCount?: number;
  /** The number of conversations that failed to be exported. */
  failedExportCount?: number;
}

export const GoogleCloudContactcenterinsightsV1ExportInsightsDataMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1ExportInsightsDataMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1ExportInsightsDataRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
  completedExportCount: Schema.optional(Schema.Number),
  failedExportCount: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ExportInsightsDataMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ExportInsightsDataMetadata>;

export interface GoogleCloudContactcenterinsightsV1ExportInsightsDataResponse {
}

export const GoogleCloudContactcenterinsightsV1ExportInsightsDataResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ExportInsightsDataResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ExportInsightsDataResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ExportInsightsDataResponse>;

export interface GoogleCloudContactcenterinsightsV1ExportIssueModelMetadata {
  /** The time the operation was created. */
  createTime?: string;
  /** The time the operation finished running. */
  endTime?: string;
  /** The original export request. */
  request?: GoogleCloudContactcenterinsightsV1ExportIssueModelRequest;
}

export const GoogleCloudContactcenterinsightsV1ExportIssueModelMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1ExportIssueModelMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1ExportIssueModelRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ExportIssueModelMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ExportIssueModelMetadata>;

export interface GoogleCloudContactcenterinsightsV1ExportIssueModelResponse {
}

export const GoogleCloudContactcenterinsightsV1ExportIssueModelResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ExportIssueModelResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ExportIssueModelResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ExportIssueModelResponse>;

export interface GoogleCloudContactcenterinsightsV1GenerativeInsightsMetadata {
  /** The error message when the generative insights request fails. */
  errorMessages?: Array<GoogleRpcStatus>;
}

export const GoogleCloudContactcenterinsightsV1GenerativeInsightsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsMetadata> = Schema.suspend(() => Schema.Struct({
  errorMessages: Schema.optional(Schema.Array(GoogleRpcStatus)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerativeInsightsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsMetadata>;

export interface GoogleCloudContactcenterinsightsV1GenerativeInsightsResponseGenerativeResponseTextOutput {
  /** The text output from the LLM. */
  text?: Array<string>;
  /** The type of text output. */
  textType?: "TYPE_UNSPECIFIED" | "THOUGHT" | "FINAL_RESPONSE" | "PROGRESS" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1GenerativeInsightsResponseGenerativeResponseTextOutput: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsResponseGenerativeResponseTextOutput> = Schema.suspend(() => Schema.Struct({
  text: Schema.optional(Schema.Array(Schema.String)),
  textType: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerativeInsightsResponseGenerativeResponseTextOutput" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsResponseGenerativeResponseTextOutput>;

export interface GoogleCloudContactcenterinsightsV1GenerativeInsightsResponseGenerativeResponse {
  /** The text output from the LLM. Will be populated during the chart building phase. For a reloaded chart, this will NOT be populated. May contain THOUGHT or a FINAL response or some in-progress response. */
  textOutput?: string;
  /** The generated SQL query from the LLM. Will be populated during the chart building phase. The generated SQL will be cached in the corresponding chart resource. */
  generatedSqlQuery?: string;
  /** The chart spec for the data. This will be specified in the vega-lite or vega format. */
  chartSpec?: Record<string, unknown>;
  /** The text output from the LLM. Will be populated during the chart building phase. For a reloaded chart, this will NOT be populated. May contain THOUGHT or a FINAL response or some in-progress response. */
  textMessage?: GoogleCloudContactcenterinsightsV1GenerativeInsightsResponseGenerativeResponseTextOutput;
}

export const GoogleCloudContactcenterinsightsV1GenerativeInsightsResponseGenerativeResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsResponseGenerativeResponse> = Schema.suspend(() => Schema.Struct({
  textOutput: Schema.optional(Schema.String),
  generatedSqlQuery: Schema.optional(Schema.String),
  chartSpec: Schema.optional(Schema.Record(Schema.String, Schema.Unknown)),
  textMessage: Schema.optional(GoogleCloudContactcenterinsightsV1GenerativeInsightsResponseGenerativeResponseTextOutput),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerativeInsightsResponseGenerativeResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsResponseGenerativeResponse>;

export interface GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageUserMessage {
  /** A message from the user that is interacting with the system. */
  text?: string;
}

export const GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageUserMessage: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageUserMessage> = Schema.suspend(() => Schema.Struct({
  text: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageUserMessage" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageUserMessage>;

export interface GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessageTextOutput {
  /** The parts of the message. */
  text?: Array<string>;
  /** The type of the text message. */
  textType?: "TYPE_UNSPECIFIED" | "THOUGHT" | "FINAL_RESPONSE" | "PROGRESS" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessageTextOutput: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessageTextOutput> = Schema.suspend(() => Schema.Struct({
  text: Schema.optional(Schema.Array(Schema.String)),
  textType: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessageTextOutput" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessageTextOutput>;

export interface GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessage {
  /** A direct natural language response to the user message. */
  textMessage?: GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessageTextOutput;
  /** Raw SQL from LLM, before templatization */
  generatedSqlQuery?: string;
  /** Chart spec from LLM */
  chartSpec?: Record<string, unknown>;
  /** Optional. User provided SQL query */
  userProvidedSqlQuery?: string;
  /** Optional. User provided chart spec */
  userProvidedChartSpec?: Record<string, unknown>;
}

export const GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessage: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessage> = Schema.suspend(() => Schema.Struct({
  textMessage: Schema.optional(GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessageTextOutput),
  generatedSqlQuery: Schema.optional(Schema.String),
  chartSpec: Schema.optional(Schema.Record(Schema.String, Schema.Unknown)),
  userProvidedSqlQuery: Schema.optional(Schema.String),
  userProvidedChartSpec: Schema.optional(Schema.Record(Schema.String, Schema.Unknown)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessage" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessage>;

export interface GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessages {
  /** A message from the system in response to the user. */
  systemMessages?: Array<GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessage>;
}

export const GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessages: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessages> = Schema.suspend(() => Schema.Struct({
  systemMessages: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessage)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessages" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessages>;

export interface GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessage {
  /** A message from the user that is interacting with the system. */
  userMessage?: GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageUserMessage;
  /** A wrapper for system messages per turn. */
  systemMessageWrapper?: GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessages;
  /** The message id of the message. */
  messageId?: string;
  /** Output only. For user messages, this is the time at which the system received the message. For system messages, this is the time at which the system generated the message. */
  createTime?: string;
}

export const GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessage: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessage> = Schema.suspend(() => Schema.Struct({
  userMessage: Schema.optional(GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageUserMessage),
  systemMessageWrapper: Schema.optional(GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessageSystemMessages),
  messageId: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessage" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessage>;

export interface GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscript {
  /** The conversation id of the chart. */
  conversationId?: string;
  /** Output only. The create time of the conversation. */
  createTime?: string;
  /** Output only. The update time of the conversation. */
  updateTime?: string;
  /** Ordered list of messages, including user inputs and system responses. */
  messages?: Array<GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessage>;
}

export const GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscript: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscript> = Schema.suspend(() => Schema.Struct({
  conversationId: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  messages: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscriptMessage)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscript" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscript>;

export interface GoogleCloudContactcenterinsightsV1GenerativeInsightsResponse {
  /** The full list of generative responses. Each response is ordered by time. */
  generativeResponses?: Array<GoogleCloudContactcenterinsightsV1GenerativeInsightsResponseGenerativeResponse>;
  /** The transcript of the generative insights conversation. */
  transcript?: GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscript;
}

export const GoogleCloudContactcenterinsightsV1GenerativeInsightsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsResponse> = Schema.suspend(() => Schema.Struct({
  generativeResponses: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1GenerativeInsightsResponseGenerativeResponse)),
  transcript: Schema.optional(GoogleCloudContactcenterinsightsV1GenerativeInsightConversationTranscript),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1GenerativeInsightsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1GenerativeInsightsResponse>;

export interface GoogleCloudContactcenterinsightsV1ImportIssueModelMetadata {
  /** The time the operation was created. */
  createTime?: string;
  /** The time the operation finished running. */
  endTime?: string;
  /** The original import request. */
  request?: GoogleCloudContactcenterinsightsV1ImportIssueModelRequest;
}

export const GoogleCloudContactcenterinsightsV1ImportIssueModelMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1ImportIssueModelMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1ImportIssueModelRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ImportIssueModelMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ImportIssueModelMetadata>;

export interface GoogleCloudContactcenterinsightsV1ImportIssueModelResponse {
  /** The issue model that was imported. */
  issueModel?: GoogleCloudContactcenterinsightsV1IssueModel;
}

export const GoogleCloudContactcenterinsightsV1ImportIssueModelResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1ImportIssueModelResponse> = Schema.suspend(() => Schema.Struct({
  issueModel: Schema.optional(GoogleCloudContactcenterinsightsV1IssueModel),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ImportIssueModelResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ImportIssueModelResponse>;

export interface GoogleCloudContactcenterinsightsV1IngestConversationsMetadataIngestConversationsStats {
  /** Output only. The number of objects processed during the ingest operation. */
  processedObjectCount?: number;
  /** Output only. The number of objects skipped because another conversation with the same transcript uri had already been ingested. */
  duplicatesSkippedCount?: number;
  /** Output only. The number of new conversations added during this ingest operation. */
  successfulIngestCount?: number;
  /** Output only. The number of objects which were unable to be ingested due to errors. The errors are populated in the partial_errors field. */
  failedIngestCount?: number;
}

export const GoogleCloudContactcenterinsightsV1IngestConversationsMetadataIngestConversationsStats: Schema.Schema<GoogleCloudContactcenterinsightsV1IngestConversationsMetadataIngestConversationsStats> = Schema.suspend(() => Schema.Struct({
  processedObjectCount: Schema.optional(Schema.Number),
  duplicatesSkippedCount: Schema.optional(Schema.Number),
  successfulIngestCount: Schema.optional(Schema.Number),
  failedIngestCount: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1IngestConversationsMetadataIngestConversationsStats" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1IngestConversationsMetadataIngestConversationsStats>;

export interface GoogleCloudContactcenterinsightsV1IngestConversationsMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request for ingest. */
  request?: GoogleCloudContactcenterinsightsV1IngestConversationsRequest;
  /** Output only. Partial errors during ingest operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
  /** Output only. Statistics for IngestConversations operation. */
  ingestConversationsStats?: GoogleCloudContactcenterinsightsV1IngestConversationsMetadataIngestConversationsStats;
  /** Output only. Stores the conversation resources produced by ingest sampling operations. */
  sampledConversations?: Array<string>;
}

export const GoogleCloudContactcenterinsightsV1IngestConversationsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1IngestConversationsMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1IngestConversationsRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
  ingestConversationsStats: Schema.optional(GoogleCloudContactcenterinsightsV1IngestConversationsMetadataIngestConversationsStats),
  sampledConversations: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1IngestConversationsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1IngestConversationsMetadata>;

export interface GoogleCloudContactcenterinsightsV1IngestConversationsResponse {
}

export const GoogleCloudContactcenterinsightsV1IngestConversationsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1IngestConversationsResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1IngestConversationsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1IngestConversationsResponse>;

export interface GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request for initialization. */
  request?: GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecRequest;
  /** Partial errors during initializing operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
}

export const GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecMetadata>;

export interface GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecResponse {
}

export const GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecResponse>;

export interface GoogleCloudContactcenterinsightsV1QueryMetricsMetadata {
  /** Whether the result rows were truncated because the result row size is too large to materialize. */
  resultIsTruncated?: boolean;
}

export const GoogleCloudContactcenterinsightsV1QueryMetricsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsMetadata> = Schema.suspend(() => Schema.Struct({
  resultIsTruncated: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QueryMetricsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsMetadata>;

export interface GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointConversationMeasureQaTagScore {
  /** Tag name. */
  tag?: string;
  /** Average tag normalized score per tag. */
  averageTagNormalizedScore?: number;
}

export const GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointConversationMeasureQaTagScore: Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointConversationMeasureQaTagScore> = Schema.suspend(() => Schema.Struct({
  tag: Schema.optional(Schema.String),
  averageTagNormalizedScore: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointConversationMeasureQaTagScore" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointConversationMeasureQaTagScore>;

export interface GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointConversationMeasure {
  /** The conversation count. */
  conversationCount?: number;
  /** The average silence percentage. */
  averageSilencePercentage?: number;
  /** The average duration. */
  averageDuration?: string;
  /** The average turn count. */
  averageTurnCount?: number;
  /** The average agent's sentiment score. */
  averageAgentSentimentScore?: number;
  /** The average client's sentiment score. */
  averageClientSentimentScore?: number;
  /** The average customer satisfaction rating. */
  averageCustomerSatisfactionRating?: number;
  /** The average normalized QA score for a scorecard. When computing the average across a set of conversations, if a conversation has been evaluated with multiple revisions of a scorecard, only the latest revision results will be used. Will exclude 0's in average calculation. Will be only populated if the request specifies a dimension of QA_SCORECARD_ID. */
  averageQaNormalizedScore?: number;
  /** Average QA normalized score for all the tags. */
  qaTagScores?: Array<GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointConversationMeasureQaTagScore>;
  /** Average QA normalized score averaged for questions averaged across all revisions of the parent scorecard. Will be only populated if the request specifies a dimension of QA_QUESTION_ID. */
  averageQaQuestionNormalizedScore?: number;
  /** Count of knowledge search results (Generative Knowledge Assist) shown to the user. */
  knowledgeSearchResultCount?: number;
  /** Proportion of knowledge search (Generative Knowledge Assist) queries made by the agent compared to the total number of knowledge search queries made. */
  knowledgeSearchAgentQuerySourceRatio?: number;
  /** Proportion of knowledge search (Generative Knowledge Assist) queries suggested compared to the total number of knowledge search queries made. */
  knowledgeSearchSuggestedQuerySourceRatio?: number;
  /** Count of knowledge assist results (Proactive Generative Knowledge Assist) shown to the user. */
  knowledgeAssistResultCount?: number;
  /** Proportion of knowledge search (Generative Knowledge Assist) queries that had a URL clicked. */
  knowledgeSearchUriClickRatio?: number;
  /** Proportion of knowledge assist (Proactive Generative Knowledge Assist) queries that had a URL clicked. */
  knowledgeAssistUriClickRatio?: number;
  /** Proportion of knowledge search (Generative Knowledge Assist) queries that had positive feedback. */
  knowledgeSearchPositiveFeedbackRatio?: number;
  /** Proportion of knowledge search (Generative Knowledge Assist) queries that had negative feedback. */
  knowledgeSearchNegativeFeedbackRatio?: number;
  /** Proportion of knowledge assist (Proactive Generative Knowledge Assist) queries that had positive feedback. */
  knowledgeAssistPositiveFeedbackRatio?: number;
  /** Proportion of knowledge assist (Proactive Generative Knowledge Assist) queries that had negative feedback. */
  knowledgeAssistNegativeFeedbackRatio?: number;
  /** Proportion of summarization suggestions that were manually edited. */
  summarizationSuggestionEditRatio?: number;
  /** Average edit distance of the summarization suggestions. Edit distance (also called as levenshtein distance) is calculated by summing up number of insertions, deletions and substitutions required to transform the summization feedback to the original summary suggestion. */
  averageSummarizationSuggestionEditDistance?: number;
  /** Normalized Average edit distance of the summarization suggestions. Edit distance (also called as levenshtein distance) is calculated by summing up number of insertions, deletions and substitutions required to transform the summization feedback to the original summary suggestion. Normalized edit distance is the average of (edit distance / summary length). */
  averageSummarizationSuggestionNormalizedEditDistance?: number;
  /** Proportion of conversations that had a suggested summary. */
  conversationSuggestedSummaryRatio?: number;
  /** Count of summarization suggestions results. */
  summarizationSuggestionResultCount?: number;
  /** Proportion of dialogflow interactions that has no intent match for the input. */
  dialogflowInteractionsNoMatchRatio?: number;
  /** Proportion of dialogflow interactions that has empty input. */
  dialogflowInteractionsNoInputRatio?: number;
  /** Proportion of dialogflow webhook calls that failed. */
  dialogflowWebhookFailureRatio?: number;
  /** Proportion of dialogflow webhook calls that timed out. */
  dialogflowWebhookTimeoutRatio?: number;
  /** Average latency of dialogflow webhook calls. */
  dialogflowAverageWebhookLatency?: number;
  /** Proportion of conversations that was handed off from virtual agent to human agent. */
  dialogflowConversationsEscalationRatio?: number;
  /** count of conversations that was handed off from virtual agent to human agent. */
  dialogflowConversationsEscalationCount?: number;
  /** The macro average latency of conversational agents' TTS latency per interaction. This is computed as the average of the all the interactions' TTS latencies in a conversation and averaged across conversations. */
  conversationalAgentsAverageTtsLatency?: number;
  /** The average latency of conversational agents' LLM call latency per interaction. This is computed as the average of the all the interactions LLM call latencies in a conversation and averaged across conversations. */
  conversationalAgentsAverageLlmCallLatency?: number;
  /** The average latency of conversational agents' audio in audio out latency per interaction. This is computed as the average of the all the interactions' audio in audio out latencies in a conversation and averaged across conversations. */
  conversationalAgentsAverageAudioInAudioOutLatency?: number;
  /** Proportion of conversations that has Ai Coach Suggestions. */
  conversationAiCoachSuggestionRatio?: number;
  /** Proportion of Ai Coach Suggestion that has been used by agents. */
  aiCoachSuggestionAgentUsageRatio?: number;
  /** Proportion of customer messages that triggered an Ai Coach Suggestion. */
  aiCoachSuggestionCustomerMessageTriggerRatio?: number;
  /** The average latency of conversational agents' latency per interaction. This is computed as the average of the all the iteractions' end to end latencies in a conversation and averaged across conversations. The e2e latency is the time between the end of the user utterance and the start of the agent utterance on the interaction level. */
  conversationalAgentsAverageEndToEndLatency?: number;
  /** Count of conversations that has Ai Coach Suggestions. */
  conversationAiCoachSuggestionCount?: number;
  /** Count of Ai Coach Suggestion that has been used by agents. */
  aiCoachSuggestionAgentUsageCount?: number;
  /** Count of customer messages that triggered an Ai Coach Suggestion. */
  aiCoachSuggestionCustomerMessageTriggerCount?: number;
  /** Count of agent messages that triggered an Ai Coach Suggestion. */
  aiCoachSuggestionAgentMessageTriggerCount?: number;
  /** The customer message count. */
  conversationTotalCustomerMessageCount?: number;
  /** The agent message count. */
  conversationTotalAgentMessageCount?: number;
  /** The number of conversations scanned by the AA human supervisor. */
  aaSupervisorMonitoredConversationsCount?: number;
  /** The number of conversations that were escalated to an AA human supervisor for intervention. */
  aaSupervisorEscalatedConversationsCount?: number;
  /** The number of conversations that were assigned to an AA human supervisor. */
  aaSupervisorAssignedConversationsCount?: number;
  /** The number of conversations that were dropped, i.e. escalated but not assigned to an AA human supervisor. */
  aaSupervisorDroppedConversationsCount?: number;
  /** The number of conversations transferred to a human agent. */
  aaSupervisorTransferredToHumanAgentConvCount?: number;
  /** The exponential moving average of the sentiment score of client turns in the conversation. */
  avgConversationClientTurnSentimentEma?: number;
  /** Proportion of end_of_utterance trigger event messages that triggered an Ai Coach Suggestion. */
  aiCoachSuggestionMessageTriggerRatio?: number;
  /** Count of end_of_utterance trigger event messages that triggered an Ai Coach Suggestion. */
  aiCoachSuggestionMessageTriggerCount?: number;
  /** The number of conversations that were contained. */
  containedConversationCount?: number;
  /** The percentage of conversations that were contained. */
  containedConversationRatio?: number;
}

export const GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointConversationMeasure: Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointConversationMeasure> = Schema.suspend(() => Schema.Struct({
  conversationCount: Schema.optional(Schema.Number),
  averageSilencePercentage: Schema.optional(Schema.Number),
  averageDuration: Schema.optional(Schema.String),
  averageTurnCount: Schema.optional(Schema.Number),
  averageAgentSentimentScore: Schema.optional(Schema.Number),
  averageClientSentimentScore: Schema.optional(Schema.Number),
  averageCustomerSatisfactionRating: Schema.optional(Schema.Number),
  averageQaNormalizedScore: Schema.optional(Schema.Number),
  qaTagScores: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointConversationMeasureQaTagScore)),
  averageQaQuestionNormalizedScore: Schema.optional(Schema.Number),
  knowledgeSearchResultCount: Schema.optional(Schema.Number),
  knowledgeSearchAgentQuerySourceRatio: Schema.optional(Schema.Number),
  knowledgeSearchSuggestedQuerySourceRatio: Schema.optional(Schema.Number),
  knowledgeAssistResultCount: Schema.optional(Schema.Number),
  knowledgeSearchUriClickRatio: Schema.optional(Schema.Number),
  knowledgeAssistUriClickRatio: Schema.optional(Schema.Number),
  knowledgeSearchPositiveFeedbackRatio: Schema.optional(Schema.Number),
  knowledgeSearchNegativeFeedbackRatio: Schema.optional(Schema.Number),
  knowledgeAssistPositiveFeedbackRatio: Schema.optional(Schema.Number),
  knowledgeAssistNegativeFeedbackRatio: Schema.optional(Schema.Number),
  summarizationSuggestionEditRatio: Schema.optional(Schema.Number),
  averageSummarizationSuggestionEditDistance: Schema.optional(Schema.Number),
  averageSummarizationSuggestionNormalizedEditDistance: Schema.optional(Schema.Number),
  conversationSuggestedSummaryRatio: Schema.optional(Schema.Number),
  summarizationSuggestionResultCount: Schema.optional(Schema.Number),
  dialogflowInteractionsNoMatchRatio: Schema.optional(Schema.Number),
  dialogflowInteractionsNoInputRatio: Schema.optional(Schema.Number),
  dialogflowWebhookFailureRatio: Schema.optional(Schema.Number),
  dialogflowWebhookTimeoutRatio: Schema.optional(Schema.Number),
  dialogflowAverageWebhookLatency: Schema.optional(Schema.Number),
  dialogflowConversationsEscalationRatio: Schema.optional(Schema.Number),
  dialogflowConversationsEscalationCount: Schema.optional(Schema.Number),
  conversationalAgentsAverageTtsLatency: Schema.optional(Schema.Number),
  conversationalAgentsAverageLlmCallLatency: Schema.optional(Schema.Number),
  conversationalAgentsAverageAudioInAudioOutLatency: Schema.optional(Schema.Number),
  conversationAiCoachSuggestionRatio: Schema.optional(Schema.Number),
  aiCoachSuggestionAgentUsageRatio: Schema.optional(Schema.Number),
  aiCoachSuggestionCustomerMessageTriggerRatio: Schema.optional(Schema.Number),
  conversationalAgentsAverageEndToEndLatency: Schema.optional(Schema.Number),
  conversationAiCoachSuggestionCount: Schema.optional(Schema.Number),
  aiCoachSuggestionAgentUsageCount: Schema.optional(Schema.Number),
  aiCoachSuggestionCustomerMessageTriggerCount: Schema.optional(Schema.Number),
  aiCoachSuggestionAgentMessageTriggerCount: Schema.optional(Schema.Number),
  conversationTotalCustomerMessageCount: Schema.optional(Schema.Number),
  conversationTotalAgentMessageCount: Schema.optional(Schema.Number),
  aaSupervisorMonitoredConversationsCount: Schema.optional(Schema.Number),
  aaSupervisorEscalatedConversationsCount: Schema.optional(Schema.Number),
  aaSupervisorAssignedConversationsCount: Schema.optional(Schema.Number),
  aaSupervisorDroppedConversationsCount: Schema.optional(Schema.Number),
  aaSupervisorTransferredToHumanAgentConvCount: Schema.optional(Schema.Number),
  avgConversationClientTurnSentimentEma: Schema.optional(Schema.Number),
  aiCoachSuggestionMessageTriggerRatio: Schema.optional(Schema.Number),
  aiCoachSuggestionMessageTriggerCount: Schema.optional(Schema.Number),
  containedConversationCount: Schema.optional(Schema.Number),
  containedConversationRatio: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointConversationMeasure" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointConversationMeasure>;

export interface GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointPercentileResult {
  /** The 50th percentile value. */
  p50?: number;
  /** The 90th percentile value. */
  p90?: number;
  /** The 99th percentile value. */
  p99?: number;
}

export const GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointPercentileResult: Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointPercentileResult> = Schema.suspend(() => Schema.Struct({
  p50: Schema.optional(Schema.Number),
  p90: Schema.optional(Schema.Number),
  p99: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointPercentileResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointPercentileResult>;

export interface GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointDialogflowInteractionMeasure {
  /** The percentile result for audio in audio out latency in milliseconds per dialogflow interaction level. */
  percentileAudioInAudioOutLatency?: GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointPercentileResult;
  /** The percentile result for LLM latency in milliseconds per dialogflow interaction level. */
  percentileLlmCallLatency?: GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointPercentileResult;
  /** The percentile result for TTS latency in milliseconds per dialogflow interaction level. */
  percentileTtsLatency?: GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointPercentileResult;
  /** The percentile result for tool use latency in milliseconds per dialogflow interaction level. */
  percentileToolUseLatency?: GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointPercentileResult;
  /** The percentile result for end to end chat latency in milliseconds per dialogflow interaction level. */
  percentileEndToEndLatency?: GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointPercentileResult;
}

export const GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointDialogflowInteractionMeasure: Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointDialogflowInteractionMeasure> = Schema.suspend(() => Schema.Struct({
  percentileAudioInAudioOutLatency: Schema.optional(GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointPercentileResult),
  percentileLlmCallLatency: Schema.optional(GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointPercentileResult),
  percentileTtsLatency: Schema.optional(GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointPercentileResult),
  percentileToolUseLatency: Schema.optional(GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointPercentileResult),
  percentileEndToEndLatency: Schema.optional(GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointPercentileResult),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointDialogflowInteractionMeasure" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointDialogflowInteractionMeasure>;

export interface GoogleTypeInterval {
  /** Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start. */
  startTime?: string;
  /** Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end. */
  endTime?: string;
}

export const GoogleTypeInterval: Schema.Schema<GoogleTypeInterval> = Schema.suspend(() => Schema.Struct({
  startTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleTypeInterval" }) as any as Schema.Schema<GoogleTypeInterval>;

export interface GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPoint {
  /** The measure related to conversations. */
  conversationMeasure?: GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointConversationMeasure;
  /** The measure related to dialogflow interactions. */
  dialogflowInteractionMeasure?: GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointDialogflowInteractionMeasure;
  /** The interval that this data point represents. * If this is the total data point, the interval is [starting create time, ending create time) from the request. * If this a data point from the time series, the interval is [time, time + time granularity from the request). */
  interval?: GoogleTypeInterval;
}

export const GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPoint: Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPoint> = Schema.suspend(() => Schema.Struct({
  conversationMeasure: Schema.optional(GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointConversationMeasure),
  dialogflowInteractionMeasure: Schema.optional(GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPointDialogflowInteractionMeasure),
  interval: Schema.optional(GoogleTypeInterval),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPoint" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPoint>;

export interface GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceTimeSeries {
  /** The data points that make up the time series . */
  dataPoints?: Array<GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPoint>;
}

export const GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceTimeSeries: Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceTimeSeries> = Schema.suspend(() => Schema.Struct({
  dataPoints: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPoint)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceTimeSeries" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceTimeSeries>;

export interface GoogleCloudContactcenterinsightsV1QueryMetricsResponseSlice {
  /** A unique combination of dimensions that this slice represents. */
  dimensions?: Array<GoogleCloudContactcenterinsightsV1Dimension>;
  /** The total metric value. The interval of this data point is [starting create time, ending create time) from the request. */
  total?: GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPoint;
  /** A time series of metric values. This is only populated if the request specifies a time granularity other than NONE. */
  timeSeries?: GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceTimeSeries;
}

export const GoogleCloudContactcenterinsightsV1QueryMetricsResponseSlice: Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsResponseSlice> = Schema.suspend(() => Schema.Struct({
  dimensions: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1Dimension)),
  total: Schema.optional(GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceDataPoint),
  timeSeries: Schema.optional(GoogleCloudContactcenterinsightsV1QueryMetricsResponseSliceTimeSeries),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QueryMetricsResponseSlice" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsResponseSlice>;

export interface GoogleCloudContactcenterinsightsV1QueryMetricsResponse {
  /** Required. The location of the data. "projects/{project}/locations/{location}" */
  location?: string;
  /** The metrics last update time. */
  updateTime?: string;
  /** A slice contains a total and (if the request specified a time granularity) a time series of metric values. Each slice contains a unique combination of the cardinality of dimensions from the request. */
  slices?: Array<GoogleCloudContactcenterinsightsV1QueryMetricsResponseSlice>;
  /** The macro average slice contains aggregated averages across all selected dimensions. i.e. if group_by agent and scorecard_id is specified, this field will contain the average across all agents and all scorecards. This field is only populated if the request specifies a Dimension. */
  macroAverageSlice?: GoogleCloudContactcenterinsightsV1QueryMetricsResponseSlice;
}

export const GoogleCloudContactcenterinsightsV1QueryMetricsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsResponse> = Schema.suspend(() => Schema.Struct({
  location: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  slices: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1QueryMetricsResponseSlice)),
  macroAverageSlice: Schema.optional(GoogleCloudContactcenterinsightsV1QueryMetricsResponseSlice),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QueryMetricsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QueryMetricsResponse>;

export interface GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewMetadata {
}

export const GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewMetadata> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewMetadata>;

export interface GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewResponse {
  /** The summary text of the performance. */
  summaryText?: string;
}

export const GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewResponse> = Schema.suspend(() => Schema.Struct({
  summaryText: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewResponse>;

export interface GoogleCloudContactcenterinsightsV1SampleConversationsMetadataSampleConversationsStats {
  /** Output only. The number of new conversations added during this sample operation. */
  successfulSampleCount?: number;
  /** Output only. The number of objects which were unable to be sampled due to errors. The errors are populated in the partial_errors field. */
  failedSampleCount?: number;
}

export const GoogleCloudContactcenterinsightsV1SampleConversationsMetadataSampleConversationsStats: Schema.Schema<GoogleCloudContactcenterinsightsV1SampleConversationsMetadataSampleConversationsStats> = Schema.suspend(() => Schema.Struct({
  successfulSampleCount: Schema.optional(Schema.Number),
  failedSampleCount: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1SampleConversationsMetadataSampleConversationsStats" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1SampleConversationsMetadataSampleConversationsStats>;

export interface GoogleCloudContactcenterinsightsV1SampleConversationsMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request for sample conversations to dataset. */
  request?: GoogleCloudContactcenterinsightsV1SampleConversationsRequest;
  /** Output only. Partial errors during sample conversations operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
  /** Output only. Statistics for SampleConversations operation. */
  sampleConversationsStats?: GoogleCloudContactcenterinsightsV1SampleConversationsMetadataSampleConversationsStats;
}

export const GoogleCloudContactcenterinsightsV1SampleConversationsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1SampleConversationsMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1SampleConversationsRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
  sampleConversationsStats: Schema.optional(GoogleCloudContactcenterinsightsV1SampleConversationsMetadataSampleConversationsStats),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1SampleConversationsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1SampleConversationsMetadata>;

export interface GoogleCloudContactcenterinsightsV1SampleConversationsResponse {
}

export const GoogleCloudContactcenterinsightsV1SampleConversationsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1SampleConversationsResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1SampleConversationsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1SampleConversationsResponse>;

export interface GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError {
  /** The conversation resource name that had an error during correlation. */
  conversation?: string;
  /** The error status. */
  status?: GoogleRpcStatus;
}

export const GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError: Schema.Schema<GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError> = Schema.suspend(() => Schema.Struct({
  conversation: Schema.optional(Schema.String),
  status: Schema.optional(GoogleRpcStatus),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError>;

export interface GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadataFullConversationCorrelationStats {
  /** The number of conversations sampled. */
  sampledConversationsCount?: number;
  /** The number of conversations correlated. */
  correlatedConversationsCount?: number;
  /** The number of conversations that failed correlation. */
  failedConversationsCount?: number;
  /** Partial errors during test correlation config operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
  /** A list of errors that occurred during correlation, one for each conversation that failed. */
  conversationCorrelationErrors?: Array<GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError>;
}

export const GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadataFullConversationCorrelationStats: Schema.Schema<GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadataFullConversationCorrelationStats> = Schema.suspend(() => Schema.Struct({
  sampledConversationsCount: Schema.optional(Schema.Number),
  correlatedConversationsCount: Schema.optional(Schema.Number),
  failedConversationsCount: Schema.optional(Schema.Number),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
  conversationCorrelationErrors: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadataFullConversationCorrelationStats" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadataFullConversationCorrelationStats>;

export interface GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** The dataset used for sampling conversations. */
  dataset?: string;
  /** The statistics for the operation. */
  stats?: GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadataFullConversationCorrelationStats;
}

export const GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  dataset: Schema.optional(Schema.String),
  stats: Schema.optional(GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadataFullConversationCorrelationStats),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1TestCorrelationConfigMetadata>;

export interface GoogleCloudContactcenterinsightsV1ConversationCorrelationResultRuleCorrelationResult {
  /** The correlation ID generated by the join key expression. */
  correlationId?: string;
  /** The error status if the join key expression failed to evaluate. */
  error?: GoogleRpcStatus;
  /** The rule ID. */
  ruleId?: string;
}

export const GoogleCloudContactcenterinsightsV1ConversationCorrelationResultRuleCorrelationResult: Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationCorrelationResultRuleCorrelationResult> = Schema.suspend(() => Schema.Struct({
  correlationId: Schema.optional(Schema.String),
  error: Schema.optional(GoogleRpcStatus),
  ruleId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConversationCorrelationResultRuleCorrelationResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationCorrelationResultRuleCorrelationResult>;

export interface GoogleCloudContactcenterinsightsV1ConversationCorrelationResult {
  /** The conversation resource name. */
  conversation?: string;
  /** The results for each correlation rule. */
  ruleResults?: Array<GoogleCloudContactcenterinsightsV1ConversationCorrelationResultRuleCorrelationResult>;
}

export const GoogleCloudContactcenterinsightsV1ConversationCorrelationResult: Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationCorrelationResult> = Schema.suspend(() => Schema.Struct({
  conversation: Schema.optional(Schema.String),
  ruleResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1ConversationCorrelationResultRuleCorrelationResult)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConversationCorrelationResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConversationCorrelationResult>;

export interface GoogleCloudContactcenterinsightsV1ConstraintEvaluationResultRuleConstraintResult {
  /** Whether the constraint expression evaluated to true for (A, B) or (B, A). */
  constraintMet?: boolean;
  /** The error status if the constraint expression failed to evaluate. */
  error?: GoogleRpcStatus;
  /** The rule ID. */
  ruleId?: string;
}

export const GoogleCloudContactcenterinsightsV1ConstraintEvaluationResultRuleConstraintResult: Schema.Schema<GoogleCloudContactcenterinsightsV1ConstraintEvaluationResultRuleConstraintResult> = Schema.suspend(() => Schema.Struct({
  constraintMet: Schema.optional(Schema.Boolean),
  error: Schema.optional(GoogleRpcStatus),
  ruleId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConstraintEvaluationResultRuleConstraintResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConstraintEvaluationResultRuleConstraintResult>;

export interface GoogleCloudContactcenterinsightsV1ConstraintEvaluationResult {
  /** The first conversation resource name. */
  conversationA?: string;
  /** The second conversation resource name. */
  conversationB?: string;
  /** The results for each applicable constraint rule. */
  ruleConstraintResults?: Array<GoogleCloudContactcenterinsightsV1ConstraintEvaluationResultRuleConstraintResult>;
}

export const GoogleCloudContactcenterinsightsV1ConstraintEvaluationResult: Schema.Schema<GoogleCloudContactcenterinsightsV1ConstraintEvaluationResult> = Schema.suspend(() => Schema.Struct({
  conversationA: Schema.optional(Schema.String),
  conversationB: Schema.optional(Schema.String),
  ruleConstraintResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1ConstraintEvaluationResultRuleConstraintResult)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1ConstraintEvaluationResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1ConstraintEvaluationResult>;

export interface GoogleCloudContactcenterinsightsV1TestCorrelationConfigResponseDetailedCorrelationResults {
  /** A list of join key correlation results for each conversation tested. */
  joinKeyResults?: Array<GoogleCloudContactcenterinsightsV1ConversationCorrelationResult>;
  /** A list of constraint evaluation results for each pair of conversations. */
  constraintResults?: Array<GoogleCloudContactcenterinsightsV1ConstraintEvaluationResult>;
}

export const GoogleCloudContactcenterinsightsV1TestCorrelationConfigResponseDetailedCorrelationResults: Schema.Schema<GoogleCloudContactcenterinsightsV1TestCorrelationConfigResponseDetailedCorrelationResults> = Schema.suspend(() => Schema.Struct({
  joinKeyResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1ConversationCorrelationResult)),
  constraintResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1ConstraintEvaluationResult)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1TestCorrelationConfigResponseDetailedCorrelationResults" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1TestCorrelationConfigResponseDetailedCorrelationResults>;

export interface GoogleCloudContactcenterinsightsV1TestCorrelationConfigResponse {
  /** Results for the DETAILED_SYNC execution mode. */
  detailedResults?: GoogleCloudContactcenterinsightsV1TestCorrelationConfigResponseDetailedCorrelationResults;
  /** Partial errors during test correlation config operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
}

export const GoogleCloudContactcenterinsightsV1TestCorrelationConfigResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1TestCorrelationConfigResponse> = Schema.suspend(() => Schema.Struct({
  detailedResults: Schema.optional(GoogleCloudContactcenterinsightsV1TestCorrelationConfigResponseDetailedCorrelationResults),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1TestCorrelationConfigResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1TestCorrelationConfigResponse>;

export interface GoogleCloudContactcenterinsightsV1UndeployIssueModelMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** The original request for undeployment. */
  request?: GoogleCloudContactcenterinsightsV1UndeployIssueModelRequest;
}

export const GoogleCloudContactcenterinsightsV1UndeployIssueModelMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1UndeployIssueModelMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1UndeployIssueModelRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1UndeployIssueModelMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1UndeployIssueModelMetadata>;

export interface GoogleCloudContactcenterinsightsV1UndeployIssueModelResponse {
}

export const GoogleCloudContactcenterinsightsV1UndeployIssueModelResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1UndeployIssueModelResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1UndeployIssueModelResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1UndeployIssueModelResponse>;

export interface GoogleCloudContactcenterinsightsV1UpdateQaQuestionTagRequest {
  /** Required. The QaQuestionTag to update. */
  qaQuestionTag?: GoogleCloudContactcenterinsightsV1QaQuestionTag;
  /** Optional. The list of fields to be updated. All possible fields can be updated by passing `*`, or a subset of the following updateable fields can be provided: * `qa_question_tag_name` - the name of the tag * `qa_question_ids` - the list of questions the tag applies to */
  updateMask?: string;
}

export const GoogleCloudContactcenterinsightsV1UpdateQaQuestionTagRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1UpdateQaQuestionTagRequest> = Schema.suspend(() => Schema.Struct({
  qaQuestionTag: Schema.optional(GoogleCloudContactcenterinsightsV1QaQuestionTag),
  updateMask: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1UpdateQaQuestionTagRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1UpdateQaQuestionTagRequest>;

export interface GoogleCloudContactcenterinsightsV1UpdateQaQuestionTagMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request. */
  request?: GoogleCloudContactcenterinsightsV1UpdateQaQuestionTagRequest;
}

export const GoogleCloudContactcenterinsightsV1UpdateQaQuestionTagMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1UpdateQaQuestionTagMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1UpdateQaQuestionTagRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1UpdateQaQuestionTagMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1UpdateQaQuestionTagMetadata>;

export interface GoogleCloudContactcenterinsightsV1UploadConversationMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request. */
  request?: GoogleCloudContactcenterinsightsV1UploadConversationRequest;
  /** Output only. The operation name for a successfully created analysis operation, if any. */
  analysisOperation?: string;
  /** Output only. The redaction config applied to the uploaded conversation. */
  appliedRedactionConfig?: GoogleCloudContactcenterinsightsV1RedactionConfig;
}

export const GoogleCloudContactcenterinsightsV1UploadConversationMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1UploadConversationMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1UploadConversationRequest),
  analysisOperation: Schema.optional(Schema.String),
  appliedRedactionConfig: Schema.optional(GoogleCloudContactcenterinsightsV1RedactionConfig),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1UploadConversationMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1UploadConversationMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorSummarizationConfig {
  /** Resource name of the Dialogflow conversation profile. Format: projects/{project}/locations/{location}/conversationProfiles/{conversation_profile} */
  conversationProfile?: string;
  /** Default summarization model to be used. */
  summarizationModel?: "SUMMARIZATION_MODEL_UNSPECIFIED" | "BASELINE_MODEL" | "BASELINE_MODEL_V2_0" | (string & {});
  /** The resource name of the existing created generator. Format: projects//locations//generators/ */
  generator?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorSummarizationConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorSummarizationConfig> = Schema.suspend(() => Schema.Struct({
  conversationProfile: Schema.optional(Schema.String),
  summarizationModel: Schema.optional(Schema.String),
  generator: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorSummarizationConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorSummarizationConfig>;

export interface GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorQaConfigScorecardList {
  /** List of QaScorecardRevisions. */
  qaScorecardRevisions?: Array<string>;
}

export const GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorQaConfigScorecardList: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorQaConfigScorecardList> = Schema.suspend(() => Schema.Struct({
  qaScorecardRevisions: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorQaConfigScorecardList" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorQaConfigScorecardList>;

export interface GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorQaConfig {
  /** A manual list of scorecards to score. */
  scorecardList?: GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorQaConfigScorecardList;
}

export const GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorQaConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorQaConfig> = Schema.suspend(() => Schema.Struct({
  scorecardList: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorQaConfigScorecardList),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorQaConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorQaConfig>;

export interface GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelector {
  /** Whether to run the interruption annotator. */
  runInterruptionAnnotator?: boolean;
  /** Whether to run the silence annotator. */
  runSilenceAnnotator?: boolean;
  /** Whether to run the active phrase matcher annotator(s). */
  runPhraseMatcherAnnotator?: boolean;
  /** The list of phrase matchers to run. If not provided, all active phrase matchers will be used. If inactive phrase matchers are provided, they will not be used. Phrase matchers will be run only if run_phrase_matcher_annotator is set to true. Format: projects/{project}/locations/{location}/phraseMatchers/{phrase_matcher} */
  phraseMatchers?: Array<string>;
  /** Whether to run the sentiment annotator. */
  runSentimentAnnotator?: boolean;
  /** Whether to run the entity annotator. */
  runEntityAnnotator?: boolean;
  /** Whether to run the intent annotator. */
  runIntentAnnotator?: boolean;
  /** Whether to run the issue model annotator. A model should have already been deployed for this to take effect. */
  runIssueModelAnnotator?: boolean;
  /** The issue model to run. If not provided, the most recently deployed topic model will be used. The provided issue model will only be used for inference if the issue model is deployed and if run_issue_model_annotator is set to true. If more than one issue model is provided, only the first provided issue model will be used for inference. */
  issueModels?: Array<string>;
  /** Whether to run the summarization annotator. */
  runSummarizationAnnotator?: boolean;
  /** Configuration for the summarization annotator. */
  summarizationConfig?: GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorSummarizationConfig;
  /** Whether to run the QA annotator. */
  runQaAnnotator?: boolean;
  /** Configuration for the QA annotator. */
  qaConfig?: GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorQaConfig;
}

export const GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelector: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelector> = Schema.suspend(() => Schema.Struct({
  runInterruptionAnnotator: Schema.optional(Schema.Boolean),
  runSilenceAnnotator: Schema.optional(Schema.Boolean),
  runPhraseMatcherAnnotator: Schema.optional(Schema.Boolean),
  phraseMatchers: Schema.optional(Schema.Array(Schema.String)),
  runSentimentAnnotator: Schema.optional(Schema.Boolean),
  runEntityAnnotator: Schema.optional(Schema.Boolean),
  runIntentAnnotator: Schema.optional(Schema.Boolean),
  runIssueModelAnnotator: Schema.optional(Schema.Boolean),
  issueModels: Schema.optional(Schema.Array(Schema.String)),
  runSummarizationAnnotator: Schema.optional(Schema.Boolean),
  summarizationConfig: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorSummarizationConfig),
  runQaAnnotator: Schema.optional(Schema.Boolean),
  qaConfig: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelectorQaConfig),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelector" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelector>;

export interface GoogleCloudContactcenterinsightsV1alpha1BulkAnalyzeConversationsRequest {
  /** Required. The parent resource to create analyses in. */
  parent?: string;
  /** Required. Filter used to select the subset of conversations to analyze. */
  filter?: string;
  /** Required. Percentage of selected conversation to analyze, between [0, 100]. */
  analysisPercentage?: number;
  /** To select the annotators to run and the phrase matchers to use (if any). If not specified, all annotators will be run. */
  annotatorSelector?: GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelector;
}

export const GoogleCloudContactcenterinsightsV1alpha1BulkAnalyzeConversationsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1BulkAnalyzeConversationsRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
  analysisPercentage: Schema.optional(Schema.Number),
  annotatorSelector: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelector),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1BulkAnalyzeConversationsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1BulkAnalyzeConversationsRequest>;

export interface GoogleCloudContactcenterinsightsV1alpha1BulkAnalyzeConversationsMetadata {
  /** The time the operation was created. */
  createTime?: string;
  /** The time the operation finished running. */
  endTime?: string;
  /** The original request for bulk analyze. */
  request?: GoogleCloudContactcenterinsightsV1alpha1BulkAnalyzeConversationsRequest;
  /** The number of requested analyses that have completed successfully so far. */
  completedAnalysesCount?: number;
  /** The number of requested analyses that have failed so far. */
  failedAnalysesCount?: number;
  /** Total number of analyses requested. Computed by the number of conversations returned by `filter` multiplied by `analysis_percentage` in the request. */
  totalRequestedAnalysesCount?: number;
  /** Output only. Partial errors during bulk analyze operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
}

export const GoogleCloudContactcenterinsightsV1alpha1BulkAnalyzeConversationsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1BulkAnalyzeConversationsMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1BulkAnalyzeConversationsRequest),
  completedAnalysesCount: Schema.optional(Schema.Number),
  failedAnalysesCount: Schema.optional(Schema.Number),
  totalRequestedAnalysesCount: Schema.optional(Schema.Number),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1BulkAnalyzeConversationsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1BulkAnalyzeConversationsMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1BulkAnalyzeConversationsResponse {
  /** Count of successful analyses. */
  successfulAnalysisCount?: number;
  /** Count of failed analyses. */
  failedAnalysisCount?: number;
}

export const GoogleCloudContactcenterinsightsV1alpha1BulkAnalyzeConversationsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1BulkAnalyzeConversationsResponse> = Schema.suspend(() => Schema.Struct({
  successfulAnalysisCount: Schema.optional(Schema.Number),
  failedAnalysisCount: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1BulkAnalyzeConversationsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1BulkAnalyzeConversationsResponse>;

export interface GoogleCloudContactcenterinsightsV1alpha1BulkDeleteConversationsRequest {
  /** Required. The parent resource to delete conversations from. Format: projects/{project}/locations/{location} */
  parent?: string;
  /** Filter used to select the subset of conversations to delete. */
  filter?: string;
  /** Maximum number of conversations to delete. */
  maxDeleteCount?: number;
  /** If set to true, all of this conversation's analyses will also be deleted. Otherwise, the request will only succeed if the conversation has no analyses. */
  force?: boolean;
}

export const GoogleCloudContactcenterinsightsV1alpha1BulkDeleteConversationsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1BulkDeleteConversationsRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
  maxDeleteCount: Schema.optional(Schema.Number),
  force: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1BulkDeleteConversationsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1BulkDeleteConversationsRequest>;

export interface GoogleCloudContactcenterinsightsV1alpha1BulkDeleteConversationsMetadata {
  /** The time the operation was created. */
  createTime?: string;
  /** The time the operation finished running. */
  endTime?: string;
  /** The original request for bulk delete. */
  request?: GoogleCloudContactcenterinsightsV1alpha1BulkDeleteConversationsRequest;
  /** Partial errors during bulk delete conversations operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
}

export const GoogleCloudContactcenterinsightsV1alpha1BulkDeleteConversationsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1BulkDeleteConversationsMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1BulkDeleteConversationsRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1BulkDeleteConversationsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1BulkDeleteConversationsMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1BulkDeleteConversationsResponse {
}

export const GoogleCloudContactcenterinsightsV1alpha1BulkDeleteConversationsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1BulkDeleteConversationsResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1BulkDeleteConversationsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1BulkDeleteConversationsResponse>;

export interface GoogleCloudContactcenterinsightsV1alpha1BulkDeleteFeedbackLabelsRequest {
  /** Required. The parent resource for new feedback labels. */
  parent?: string;
  /** Optional. A filter to reduce results to a specific subset. Supports disjunctions (OR) and conjunctions (AND). Supported fields: * `issue_model_id` * `qa_question_id` * `qa_scorecard_id` * `min_create_time` * `max_create_time` * `min_update_time` * `max_update_time` * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING */
  filter?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1BulkDeleteFeedbackLabelsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1BulkDeleteFeedbackLabelsRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1BulkDeleteFeedbackLabelsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1BulkDeleteFeedbackLabelsRequest>;

export interface GoogleCloudContactcenterinsightsV1alpha1BulkDeleteFeedbackLabelsMetadata {
  /** Output only. The original request for delete. */
  request?: GoogleCloudContactcenterinsightsV1alpha1BulkDeleteFeedbackLabelsRequest;
  /** Partial errors during deletion operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
}

export const GoogleCloudContactcenterinsightsV1alpha1BulkDeleteFeedbackLabelsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1BulkDeleteFeedbackLabelsMetadata> = Schema.suspend(() => Schema.Struct({
  request: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1BulkDeleteFeedbackLabelsRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1BulkDeleteFeedbackLabelsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1BulkDeleteFeedbackLabelsMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1BulkDeleteFeedbackLabelsResponse {
}

export const GoogleCloudContactcenterinsightsV1alpha1BulkDeleteFeedbackLabelsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1BulkDeleteFeedbackLabelsResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1BulkDeleteFeedbackLabelsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1BulkDeleteFeedbackLabelsResponse>;

export interface GoogleCloudContactcenterinsightsV1alpha1CreateAnalysisOperationMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The Conversation that this Analysis Operation belongs to. */
  conversation?: string;
  /** Output only. The annotator selector used for the analysis (if any). */
  annotatorSelector?: GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelector;
}

export const GoogleCloudContactcenterinsightsV1alpha1CreateAnalysisOperationMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1CreateAnalysisOperationMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  conversation: Schema.optional(Schema.String),
  annotatorSelector: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelector),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1CreateAnalysisOperationMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1CreateAnalysisOperationMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1Issue {
  /** Immutable. The resource name of the issue. Format: projects/{project}/locations/{location}/issueModels/{issue_model}/issues/{issue} */
  name?: string;
  /** The representative name for the issue. */
  displayName?: string;
  /** Output only. The time at which this issue was created. */
  createTime?: string;
  /** Output only. The most recent time that this issue was updated. */
  updateTime?: string;
  /** Output only. Resource names of the sample representative utterances that match to this issue. */
  sampleUtterances?: Array<string>;
  /** Representative description of the issue. */
  displayDescription?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1Issue: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1Issue> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  sampleUtterances: Schema.optional(Schema.Array(Schema.String)),
  displayDescription: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1Issue" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1Issue>;

export interface GoogleCloudContactcenterinsightsV1alpha1CreateIssueRequest {
  /** Required. The parent resource of the issue. */
  parent?: string;
  /** Required. The values for the new issue. */
  issue?: GoogleCloudContactcenterinsightsV1alpha1Issue;
}

export const GoogleCloudContactcenterinsightsV1alpha1CreateIssueRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1CreateIssueRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  issue: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1Issue),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1CreateIssueRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1CreateIssueRequest>;

export interface GoogleCloudContactcenterinsightsV1alpha1CreateIssueMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** The original request for creation. */
  request?: GoogleCloudContactcenterinsightsV1alpha1CreateIssueRequest;
}

export const GoogleCloudContactcenterinsightsV1alpha1CreateIssueMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1CreateIssueMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1CreateIssueRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1CreateIssueMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1CreateIssueMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1IssueModelInputDataConfig {
  /** Medium of conversations used in training data. This field is being deprecated. To specify the medium to be used in training a new issue model, set the `medium` field on `filter`. */
  medium?: "MEDIUM_UNSPECIFIED" | "PHONE_CALL" | "CHAT" | (string & {});
  /** Output only. Number of conversations used in training. Output only. */
  trainingConversationsCount?: string;
  /** A filter to reduce the conversations used for training the model to a specific subset. Refer to https://cloud.google.com/contact-center/insights/docs/filtering for details. */
  filter?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1IssueModelInputDataConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IssueModelInputDataConfig> = Schema.suspend(() => Schema.Struct({
  medium: Schema.optional(Schema.String),
  trainingConversationsCount: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1IssueModelInputDataConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IssueModelInputDataConfig>;

export interface GoogleCloudContactcenterinsightsV1alpha1IssueModelLabelStatsIssueStats {
  /** Issue resource. Format: projects/{project}/locations/{location}/issueModels/{issue_model}/issues/{issue} */
  issue?: string;
  /** Number of conversations attached to the issue at this point in time. */
  labeledConversationsCount?: string;
  /** Display name of the issue. */
  displayName?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1IssueModelLabelStatsIssueStats: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IssueModelLabelStatsIssueStats> = Schema.suspend(() => Schema.Struct({
  issue: Schema.optional(Schema.String),
  labeledConversationsCount: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1IssueModelLabelStatsIssueStats" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IssueModelLabelStatsIssueStats>;

export interface GoogleCloudContactcenterinsightsV1alpha1IssueModelLabelStats {
  /** Number of conversations the issue model has analyzed at this point in time. */
  analyzedConversationsCount?: string;
  /** Number of analyzed conversations for which no issue was applicable at this point in time. */
  unclassifiedConversationsCount?: string;
  /** Statistics on each issue. Key is the issue's resource name. */
  issueStats?: Record<string, GoogleCloudContactcenterinsightsV1alpha1IssueModelLabelStatsIssueStats>;
}

export const GoogleCloudContactcenterinsightsV1alpha1IssueModelLabelStats: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IssueModelLabelStats> = Schema.suspend(() => Schema.Struct({
  analyzedConversationsCount: Schema.optional(Schema.String),
  unclassifiedConversationsCount: Schema.optional(Schema.String),
  issueStats: Schema.optional(Schema.Record(Schema.String, GoogleCloudContactcenterinsightsV1alpha1IssueModelLabelStatsIssueStats)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1IssueModelLabelStats" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IssueModelLabelStats>;

export interface GoogleCloudContactcenterinsightsV1alpha1IssueModel {
  /** Immutable. The resource name of the issue model. Format: projects/{project}/locations/{location}/issueModels/{issue_model} */
  name?: string;
  /** The representative name for the issue model. */
  displayName?: string;
  /** Output only. The time at which this issue model was created. */
  createTime?: string;
  /** Output only. The most recent time at which the issue model was updated. */
  updateTime?: string;
  /** Output only. Number of issues in this issue model. */
  issueCount?: string;
  /** Output only. State of the model. */
  state?: "STATE_UNSPECIFIED" | "UNDEPLOYED" | "DEPLOYING" | "DEPLOYED" | "UNDEPLOYING" | "DELETING" | (string & {});
  /** Configs for the input data that used to create the issue model. */
  inputDataConfig?: GoogleCloudContactcenterinsightsV1alpha1IssueModelInputDataConfig;
  /** Output only. Immutable. The issue model's label statistics on its training data. */
  trainingStats?: GoogleCloudContactcenterinsightsV1alpha1IssueModelLabelStats;
  /** Type of the model. */
  modelType?: "MODEL_TYPE_UNSPECIFIED" | "TYPE_V1" | "TYPE_V2" | (string & {});
  /** Language of the model. */
  languageCode?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1IssueModel: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IssueModel> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  issueCount: Schema.optional(Schema.String),
  state: Schema.optional(Schema.String),
  inputDataConfig: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1IssueModelInputDataConfig),
  trainingStats: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1IssueModelLabelStats),
  modelType: Schema.optional(Schema.String),
  languageCode: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1IssueModel" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IssueModel>;

export interface GoogleCloudContactcenterinsightsV1alpha1CreateIssueModelRequest {
  /** Required. The parent resource of the issue model. */
  parent?: string;
  /** Required. The issue model to create. */
  issueModel?: GoogleCloudContactcenterinsightsV1alpha1IssueModel;
}

export const GoogleCloudContactcenterinsightsV1alpha1CreateIssueModelRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1CreateIssueModelRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  issueModel: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1IssueModel),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1CreateIssueModelRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1CreateIssueModelRequest>;

export interface GoogleCloudContactcenterinsightsV1alpha1CreateIssueModelMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** The original request for creation. */
  request?: GoogleCloudContactcenterinsightsV1alpha1CreateIssueModelRequest;
}

export const GoogleCloudContactcenterinsightsV1alpha1CreateIssueModelMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1CreateIssueModelMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1CreateIssueModelRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1CreateIssueModelMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1CreateIssueModelMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1DeleteIssueModelRequest {
  /** Required. The name of the issue model to delete. */
  name?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1DeleteIssueModelRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DeleteIssueModelRequest> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DeleteIssueModelRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DeleteIssueModelRequest>;

export interface GoogleCloudContactcenterinsightsV1alpha1DeleteIssueModelMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** The original request for deletion. */
  request?: GoogleCloudContactcenterinsightsV1alpha1DeleteIssueModelRequest;
}

export const GoogleCloudContactcenterinsightsV1alpha1DeleteIssueModelMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DeleteIssueModelMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1DeleteIssueModelRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DeleteIssueModelMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DeleteIssueModelMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1DeleteQaQuestionTagRequest {
  /** Required. The name of the QaQuestionTag to delete. */
  name?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1DeleteQaQuestionTagRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DeleteQaQuestionTagRequest> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DeleteQaQuestionTagRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DeleteQaQuestionTagRequest>;

export interface GoogleCloudContactcenterinsightsV1alpha1DeleteQaQuestionTagMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request. */
  request?: GoogleCloudContactcenterinsightsV1alpha1DeleteQaQuestionTagRequest;
}

export const GoogleCloudContactcenterinsightsV1alpha1DeleteQaQuestionTagMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DeleteQaQuestionTagMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1DeleteQaQuestionTagRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DeleteQaQuestionTagMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DeleteQaQuestionTagMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1DeployIssueModelRequest {
  /** Required. The issue model to deploy. */
  name?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1DeployIssueModelRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DeployIssueModelRequest> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DeployIssueModelRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DeployIssueModelRequest>;

export interface GoogleCloudContactcenterinsightsV1alpha1DeployIssueModelMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** The original request for deployment. */
  request?: GoogleCloudContactcenterinsightsV1alpha1DeployIssueModelRequest;
}

export const GoogleCloudContactcenterinsightsV1alpha1DeployIssueModelMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DeployIssueModelMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1DeployIssueModelRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DeployIssueModelMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DeployIssueModelMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1DeployIssueModelResponse {
}

export const GoogleCloudContactcenterinsightsV1alpha1DeployIssueModelResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DeployIssueModelResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DeployIssueModelResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DeployIssueModelResponse>;

export interface GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataRequestBigQueryDestination {
  /** A project ID or number. If specified, then export will attempt to write data to this project instead of the resource project. Otherwise, the resource project will be used. */
  projectId?: string;
  /** Required. The name of the BigQuery dataset that the snapshot result should be exported to. If this dataset does not exist, the export call returns an INVALID_ARGUMENT error. */
  dataset?: string;
  /** The BigQuery table name to which the insights data should be written. If this table does not exist, the export call returns an INVALID_ARGUMENT error. */
  table?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataRequestBigQueryDestination: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataRequestBigQueryDestination> = Schema.suspend(() => Schema.Struct({
  projectId: Schema.optional(Schema.String),
  dataset: Schema.optional(Schema.String),
  table: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataRequestBigQueryDestination" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataRequestBigQueryDestination>;

export interface GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataRequest {
  /** Specified if sink is a BigQuery table. */
  bigQueryDestination?: GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataRequestBigQueryDestination;
  /** Required. The parent resource to export data from. */
  parent?: string;
  /** A filter to reduce results to a specific subset. Useful for exporting conversations with specific properties. */
  filter?: string;
  /** A fully qualified KMS key name for BigQuery tables protected by CMEK. Format: projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{key}/cryptoKeyVersions/{version} */
  kmsKey?: string;
  /** Options for what to do if the destination table already exists. */
  writeDisposition?: "WRITE_DISPOSITION_UNSPECIFIED" | "WRITE_TRUNCATE" | "WRITE_APPEND" | (string & {});
  /** Optional. Version of the export schema. */
  exportSchemaVersion?: "EXPORT_SCHEMA_VERSION_UNSPECIFIED" | "EXPORT_V1" | "EXPORT_V2" | "EXPORT_V3" | "EXPORT_V4" | "EXPORT_V5" | "EXPORT_V6" | "EXPORT_V7" | "EXPORT_V8" | "EXPORT_V9" | "EXPORT_V10" | "EXPORT_V11" | "EXPORT_V12" | "EXPORT_V13" | "EXPORT_V14" | "EXPORT_V15" | "EXPORT_V16" | "EXPORT_V17" | "EXPORT_VERSION_LATEST_AVAILABLE" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataRequest> = Schema.suspend(() => Schema.Struct({
  bigQueryDestination: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataRequestBigQueryDestination),
  parent: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
  kmsKey: Schema.optional(Schema.String),
  writeDisposition: Schema.optional(Schema.String),
  exportSchemaVersion: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataRequest>;

export interface GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** The original request for export. */
  request?: GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataRequest;
  /** Partial errors during export operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
  /** The number of conversations that were exported successfully. */
  completedExportCount?: number;
  /** The number of conversations that failed to be exported. */
  failedExportCount?: number;
}

export const GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
  completedExportCount: Schema.optional(Schema.Number),
  failedExportCount: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataResponse {
}

export const GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ExportInsightsDataResponse>;

export interface GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelRequestGcsDestination {
  /** Required. Format: `gs:///` */
  objectUri?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelRequestGcsDestination: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelRequestGcsDestination> = Schema.suspend(() => Schema.Struct({
  objectUri: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelRequestGcsDestination" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelRequestGcsDestination>;

export interface GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelRequest {
  /** Google Cloud Storage URI to export the issue model to. */
  gcsDestination?: GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelRequestGcsDestination;
  /** Required. The issue model to export. */
  name?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelRequest> = Schema.suspend(() => Schema.Struct({
  gcsDestination: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelRequestGcsDestination),
  name: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelRequest>;

export interface GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelMetadata {
  /** The time the operation was created. */
  createTime?: string;
  /** The time the operation finished running. */
  endTime?: string;
  /** The original export request. */
  request?: GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelRequest;
}

export const GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelResponse {
}

export const GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ExportIssueModelResponse>;

export interface GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsMetadata {
  /** The error message when the generative insights request fails. */
  errorMessages?: Array<GoogleRpcStatus>;
}

export const GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsMetadata> = Schema.suspend(() => Schema.Struct({
  errorMessages: Schema.optional(Schema.Array(GoogleRpcStatus)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponseGenerativeResponseTextOutput {
  /** The text output from the LLM. */
  text?: Array<string>;
  /** The type of text output. */
  textType?: "TYPE_UNSPECIFIED" | "THOUGHT" | "FINAL_RESPONSE" | "PROGRESS" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponseGenerativeResponseTextOutput: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponseGenerativeResponseTextOutput> = Schema.suspend(() => Schema.Struct({
  text: Schema.optional(Schema.Array(Schema.String)),
  textType: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponseGenerativeResponseTextOutput" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponseGenerativeResponseTextOutput>;

export interface GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponseGenerativeResponse {
  /** The text output from the LLM. Will be populated during the chart building phase. For a reloaded chart, this will NOT be populated. May contain THOUGHT or a FINAL response or some in-progress response. */
  textOutput?: string;
  /** The generated SQL query from the LLM. Will be populated during the chart building phase. The generated SQL will be cached in the corresponding chart resource. */
  generatedSqlQuery?: string;
  /** The chart spec for the data. This will be specified in the vega-lite or vega format. */
  chartSpec?: Record<string, unknown>;
  /** The text output from the LLM. Will be populated during the chart building phase. For a reloaded chart, this will NOT be populated. May contain THOUGHT or a FINAL response or some in-progress response. */
  textMessage?: GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponseGenerativeResponseTextOutput;
}

export const GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponseGenerativeResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponseGenerativeResponse> = Schema.suspend(() => Schema.Struct({
  textOutput: Schema.optional(Schema.String),
  generatedSqlQuery: Schema.optional(Schema.String),
  chartSpec: Schema.optional(Schema.Record(Schema.String, Schema.Unknown)),
  textMessage: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponseGenerativeResponseTextOutput),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponseGenerativeResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponseGenerativeResponse>;

export interface GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageUserMessage {
  /** A message from the user that is interacting with the system. */
  text?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageUserMessage: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageUserMessage> = Schema.suspend(() => Schema.Struct({
  text: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageUserMessage" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageUserMessage>;

export interface GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessageTextOutput {
  /** The parts of the message. */
  text?: Array<string>;
  /** The type of the text message. */
  textType?: "TYPE_UNSPECIFIED" | "THOUGHT" | "FINAL_RESPONSE" | "PROGRESS" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessageTextOutput: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessageTextOutput> = Schema.suspend(() => Schema.Struct({
  text: Schema.optional(Schema.Array(Schema.String)),
  textType: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessageTextOutput" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessageTextOutput>;

export interface GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessage {
  /** A direct natural language response to the user message. */
  textMessage?: GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessageTextOutput;
  /** Raw SQL from LLM, before templatization */
  generatedSqlQuery?: string;
  /** Chart spec from LLM */
  chartSpec?: Record<string, unknown>;
  /** Optional. User provided SQL query */
  userProvidedSqlQuery?: string;
  /** Optional. User provided chart spec */
  userProvidedChartSpec?: Record<string, unknown>;
}

export const GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessage: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessage> = Schema.suspend(() => Schema.Struct({
  textMessage: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessageTextOutput),
  generatedSqlQuery: Schema.optional(Schema.String),
  chartSpec: Schema.optional(Schema.Record(Schema.String, Schema.Unknown)),
  userProvidedSqlQuery: Schema.optional(Schema.String),
  userProvidedChartSpec: Schema.optional(Schema.Record(Schema.String, Schema.Unknown)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessage" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessage>;

export interface GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessages {
  /** A message from the system in response to the user. */
  systemMessages?: Array<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessage>;
}

export const GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessages: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessages> = Schema.suspend(() => Schema.Struct({
  systemMessages: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessage)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessages" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessages>;

export interface GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessage {
  /** A message from the user that is interacting with the system. */
  userMessage?: GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageUserMessage;
  /** A wrapper for system messages per turn. */
  systemMessageWrapper?: GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessages;
  /** The message id of the message. */
  messageId?: string;
  /** Output only. For user messages, this is the time at which the system received the message. For system messages, this is the time at which the system generated the message. */
  createTime?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessage: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessage> = Schema.suspend(() => Schema.Struct({
  userMessage: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageUserMessage),
  systemMessageWrapper: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessageSystemMessages),
  messageId: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessage" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessage>;

export interface GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscript {
  /** The conversation id of the chart. */
  conversationId?: string;
  /** Output only. The create time of the conversation. */
  createTime?: string;
  /** Output only. The update time of the conversation. */
  updateTime?: string;
  /** Ordered list of messages, including user inputs and system responses. */
  messages?: Array<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessage>;
}

export const GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscript: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscript> = Schema.suspend(() => Schema.Struct({
  conversationId: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  messages: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscriptMessage)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscript" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscript>;

export interface GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponse {
  /** The full list of generative responses. Each response is ordered by time. */
  generativeResponses?: Array<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponseGenerativeResponse>;
  /** The transcript of the generative insights conversation. */
  transcript?: GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscript;
}

export const GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponse> = Schema.suspend(() => Schema.Struct({
  generativeResponses: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponseGenerativeResponse)),
  transcript: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightConversationTranscript),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GenerativeInsightsResponse>;

export interface GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelRequestGcsSource {
  /** Required. Format: `gs:///` */
  objectUri?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelRequestGcsSource: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelRequestGcsSource> = Schema.suspend(() => Schema.Struct({
  objectUri: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelRequestGcsSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelRequestGcsSource>;

export interface GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelRequest {
  /** Google Cloud Storage source message. */
  gcsSource?: GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelRequestGcsSource;
  /** Required. The parent resource of the issue model. */
  parent?: string;
  /** Optional. If set to true, will create an issue model from the imported file with randomly generated IDs for the issue model and corresponding issues. Otherwise, replaces an existing model with the same ID as the file. */
  createNewModel?: boolean;
}

export const GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelRequest> = Schema.suspend(() => Schema.Struct({
  gcsSource: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelRequestGcsSource),
  parent: Schema.optional(Schema.String),
  createNewModel: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelRequest>;

export interface GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelMetadata {
  /** The time the operation was created. */
  createTime?: string;
  /** The time the operation finished running. */
  endTime?: string;
  /** The original import request. */
  request?: GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelRequest;
}

export const GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelResponse {
  /** The issue model that was imported. */
  issueModel?: GoogleCloudContactcenterinsightsV1alpha1IssueModel;
}

export const GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelResponse> = Schema.suspend(() => Schema.Struct({
  issueModel: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1IssueModel),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ImportIssueModelResponse>;

export interface GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestGcsSource {
  /** Optional. The Cloud Storage bucket containing source objects. Avoid passing this. Pass this through one of `transcript_bucket_uri` or `audio_bucket_uri`. */
  bucketUri?: string;
  /** Optional. Specifies the type of the objects in `bucket_uri`. Avoid passing this. This is inferred from the `transcript_bucket_uri`, `audio_bucket_uri`. */
  bucketObjectType?: "BUCKET_OBJECT_TYPE_UNSPECIFIED" | "TRANSCRIPT" | "AUDIO" | (string & {});
  /** Optional. The Cloud Storage path to the conversation transcripts. Note that: [1] Transcript files are expected to be in JSON format. [2] Transcript, audio, metadata files must be in separate buckets / folders. [3] A source file and its corresponding metadata file must share the same name to be properly ingested, E.g. `gs://bucket/audio/conversation1.mp3` and `gs://bucket/metadata/conversation1.json`. */
  transcriptBucketUri?: string;
  /** Optional. The Cloud Storage path to the conversation audio file. Note that: [1] Audio files will be transcribed if not already. [2] Audio files and transcript files must be in separate buckets / folders. [3] A source file and its corresponding audio file must share the same name to be properly ingested, E.g. `gs://bucket/transcript/conversation1.json` and `gs://bucket/audio/conversation1.mp3`. */
  audioBucketUri?: string;
  /** Optional. The Cloud Storage path to the conversation metadata. Note that: [1] Metadata files are expected to be in JSON format. [2] Metadata and source files (transcripts or audio) must be in separate buckets / folders. [3] A source file and its corresponding metadata file must share the same name to be properly ingested, E.g. `gs://bucket/audio/conversation1.mp3` and `gs://bucket/metadata/conversation1.json`. */
  metadataBucketUri?: string;
  /** Optional. Custom keys to extract as conversation labels from metadata files in `metadata_bucket_uri`. Keys not included in this field will be ignored. Note that there is a limit of 100 labels per conversation. */
  customMetadataKeys?: Array<string>;
}

export const GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestGcsSource: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestGcsSource> = Schema.suspend(() => Schema.Struct({
  bucketUri: Schema.optional(Schema.String),
  bucketObjectType: Schema.optional(Schema.String),
  transcriptBucketUri: Schema.optional(Schema.String),
  audioBucketUri: Schema.optional(Schema.String),
  metadataBucketUri: Schema.optional(Schema.String),
  customMetadataKeys: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestGcsSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestGcsSource>;

export interface GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestTranscriptObjectConfig {
  /** Required. The medium transcript objects represent. */
  medium?: "MEDIUM_UNSPECIFIED" | "PHONE_CALL" | "CHAT" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestTranscriptObjectConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestTranscriptObjectConfig> = Schema.suspend(() => Schema.Struct({
  medium: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestTranscriptObjectConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestTranscriptObjectConfig>;

export interface GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestConversationConfig {
  /** Optional. An opaque, user-specified string representing a human agent who handled all conversations in the import. Note that this will be overridden if per-conversation metadata is provided through the `metadata_bucket_uri`. */
  agentId?: string;
  /** Optional. Indicates which of the channels, 1 or 2, contains the agent. Note that this must be set for conversations to be properly displayed and analyzed. */
  agentChannel?: number;
  /** Optional. Indicates which of the channels, 1 or 2, contains the agent. Note that this must be set for conversations to be properly displayed and analyzed. */
  customerChannel?: number;
}

export const GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestConversationConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestConversationConfig> = Schema.suspend(() => Schema.Struct({
  agentId: Schema.optional(Schema.String),
  agentChannel: Schema.optional(Schema.Number),
  customerChannel: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestConversationConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestConversationConfig>;

export interface GoogleCloudContactcenterinsightsV1alpha1RedactionConfig {
  /** The fully-qualified DLP deidentify template resource name. Format: `projects/{project}/deidentifyTemplates/{template}` */
  deidentifyTemplate?: string;
  /** The fully-qualified DLP inspect template resource name. Format: `projects/{project}/locations/{location}/inspectTemplates/{template}` */
  inspectTemplate?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1RedactionConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1RedactionConfig> = Schema.suspend(() => Schema.Struct({
  deidentifyTemplate: Schema.optional(Schema.String),
  inspectTemplate: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1RedactionConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1RedactionConfig>;

export interface GoogleCloudContactcenterinsightsV1alpha1SpeechConfig {
  /** The fully-qualified Speech Recognizer resource name. Format: `projects/{project_id}/locations/{location}/recognizer/{recognizer}` */
  speechRecognizer?: string;
  /** Whether to disable word time offsets. If true, the `enable_word_time_offsets` field in the recognition config will be set to false. */
  disableWordTimeOffsets?: boolean;
}

export const GoogleCloudContactcenterinsightsV1alpha1SpeechConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SpeechConfig> = Schema.suspend(() => Schema.Struct({
  speechRecognizer: Schema.optional(Schema.String),
  disableWordTimeOffsets: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1SpeechConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SpeechConfig>;

export interface GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequest {
  /** A cloud storage bucket source. Note that any previously ingested objects from the source will be skipped to avoid duplication. */
  gcsSource?: GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestGcsSource;
  /** Configuration for when `source` contains conversation transcripts. */
  transcriptObjectConfig?: GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestTranscriptObjectConfig;
  /** Required. The parent resource for new conversations. */
  parent?: string;
  /** Configuration that applies to all conversations. */
  conversationConfig?: GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestConversationConfig;
  /** Optional. DLP settings for transcript redaction. Optional, will default to the config specified in Settings. */
  redactionConfig?: GoogleCloudContactcenterinsightsV1alpha1RedactionConfig;
  /** Optional. Default Speech-to-Text configuration. Optional, will default to the config specified in Settings. */
  speechConfig?: GoogleCloudContactcenterinsightsV1alpha1SpeechConfig;
  /** Optional. If set, this fields indicates the number of objects to ingest from the Cloud Storage bucket. If empty, the entire bucket will be ingested. Unless they are first deleted, conversations produced through sampling won't be ingested by subsequent ingest requests. */
  sampleSize?: number;
}

export const GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequest> = Schema.suspend(() => Schema.Struct({
  gcsSource: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestGcsSource),
  transcriptObjectConfig: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestTranscriptObjectConfig),
  parent: Schema.optional(Schema.String),
  conversationConfig: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequestConversationConfig),
  redactionConfig: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1RedactionConfig),
  speechConfig: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1SpeechConfig),
  sampleSize: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequest>;

export interface GoogleCloudContactcenterinsightsV1alpha1IngestConversationsMetadataIngestConversationsStats {
  /** Output only. The number of objects processed during the ingest operation. */
  processedObjectCount?: number;
  /** Output only. The number of objects skipped because another conversation with the same transcript uri had already been ingested. */
  duplicatesSkippedCount?: number;
  /** Output only. The number of new conversations added during this ingest operation. */
  successfulIngestCount?: number;
  /** Output only. The number of objects which were unable to be ingested due to errors. The errors are populated in the partial_errors field. */
  failedIngestCount?: number;
}

export const GoogleCloudContactcenterinsightsV1alpha1IngestConversationsMetadataIngestConversationsStats: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IngestConversationsMetadataIngestConversationsStats> = Schema.suspend(() => Schema.Struct({
  processedObjectCount: Schema.optional(Schema.Number),
  duplicatesSkippedCount: Schema.optional(Schema.Number),
  successfulIngestCount: Schema.optional(Schema.Number),
  failedIngestCount: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1IngestConversationsMetadataIngestConversationsStats" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IngestConversationsMetadataIngestConversationsStats>;

export interface GoogleCloudContactcenterinsightsV1alpha1IngestConversationsMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request for ingest. */
  request?: GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequest;
  /** Output only. Partial errors during ingest operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
  /** Output only. Statistics for IngestConversations operation. */
  ingestConversationsStats?: GoogleCloudContactcenterinsightsV1alpha1IngestConversationsMetadataIngestConversationsStats;
  /** Output only. Stores the conversation resources produced by ingest sampling operations. */
  sampledConversations?: Array<string>;
}

export const GoogleCloudContactcenterinsightsV1alpha1IngestConversationsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IngestConversationsMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1IngestConversationsRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
  ingestConversationsStats: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1IngestConversationsMetadataIngestConversationsStats),
  sampledConversations: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1IngestConversationsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IngestConversationsMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1IngestConversationsResponse {
}

export const GoogleCloudContactcenterinsightsV1alpha1IngestConversationsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IngestConversationsResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1IngestConversationsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IngestConversationsResponse>;

export interface GoogleCloudContactcenterinsightsV1alpha1EncryptionSpec {
  /** Immutable. The resource name of the encryption key specification resource. Format: projects/{project}/locations/{location}/encryptionSpec */
  name?: string;
  /** Required. The name of customer-managed encryption key that is used to secure a resource and its sub-resources. If empty, the resource is secured by our default encryption key. Only the key in the same location as this resource is allowed to be used for encryption. Format: `projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key}` */
  kmsKey?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1EncryptionSpec: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1EncryptionSpec> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  kmsKey: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1EncryptionSpec" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1EncryptionSpec>;

export interface GoogleCloudContactcenterinsightsV1alpha1InitializeEncryptionSpecRequest {
  /** Required. The encryption spec used for CMEK encryption. It is required that the kms key is in the same region as the endpoint. The same key will be used for all provisioned resources, if encryption is available. If the `kms_key_name` field is left empty, no encryption will be enforced. */
  encryptionSpec?: GoogleCloudContactcenterinsightsV1alpha1EncryptionSpec;
}

export const GoogleCloudContactcenterinsightsV1alpha1InitializeEncryptionSpecRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1InitializeEncryptionSpecRequest> = Schema.suspend(() => Schema.Struct({
  encryptionSpec: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1EncryptionSpec),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1InitializeEncryptionSpecRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1InitializeEncryptionSpecRequest>;

export interface GoogleCloudContactcenterinsightsV1alpha1InitializeEncryptionSpecMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request for initialization. */
  request?: GoogleCloudContactcenterinsightsV1alpha1InitializeEncryptionSpecRequest;
  /** Partial errors during initializing operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
}

export const GoogleCloudContactcenterinsightsV1alpha1InitializeEncryptionSpecMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1InitializeEncryptionSpecMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1InitializeEncryptionSpecRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1InitializeEncryptionSpecMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1InitializeEncryptionSpecMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1InitializeEncryptionSpecResponse {
}

export const GoogleCloudContactcenterinsightsV1alpha1InitializeEncryptionSpecResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1InitializeEncryptionSpecResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1InitializeEncryptionSpecResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1InitializeEncryptionSpecResponse>;

export interface GoogleCloudContactcenterinsightsV1alpha1QaAnswerAnswerValue {
  /** String value. */
  strValue?: string;
  /** Numerical value. */
  numValue?: number;
  /** Boolean value. */
  boolValue?: boolean;
  /** A value of "Not Applicable (N/A)". Should only ever be `true`. */
  naValue?: boolean;
  /** Output only. A value of "Skip". If provided, this field may only be set to `true`. If a question receives this answer, it will be excluded from any score calculations. This would mean that the question was not evaluated. */
  skipValue?: boolean;
  /** A short string used as an identifier. Matches the value used in QaQuestion.AnswerChoice.key. */
  key?: string;
  /** Output only. Numerical score of the answer. */
  score?: number;
  /** Output only. The maximum potential score of the question. */
  potentialScore?: number;
  /** Output only. Normalized score of the questions. Calculated as score / potential_score. */
  normalizedScore?: number;
}

export const GoogleCloudContactcenterinsightsV1alpha1QaAnswerAnswerValue: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QaAnswerAnswerValue> = Schema.suspend(() => Schema.Struct({
  strValue: Schema.optional(Schema.String),
  numValue: Schema.optional(Schema.Number),
  boolValue: Schema.optional(Schema.Boolean),
  naValue: Schema.optional(Schema.Boolean),
  skipValue: Schema.optional(Schema.Boolean),
  key: Schema.optional(Schema.String),
  score: Schema.optional(Schema.Number),
  potentialScore: Schema.optional(Schema.Number),
  normalizedScore: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1QaAnswerAnswerValue" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QaAnswerAnswerValue>;

export interface GoogleCloudContactcenterinsightsV1alpha1FeedbackLabel {
  /** String label used for Topic Modeling. */
  label?: string;
  /** QaAnswer label used for Quality AI example conversations. */
  qaAnswerLabel?: GoogleCloudContactcenterinsightsV1alpha1QaAnswerAnswerValue;
  /** Immutable. Resource name of the FeedbackLabel. Format: projects/{project}/locations/{location}/conversations/{conversation}/feedbackLabels/{feedback_label} */
  name?: string;
  /** Name of the resource to be labeled. Supported resources are: * `projects/{project}/locations/{location}/qaScorecards/{scorecard}/revisions/{revision}/qaQuestions/{question}` * `projects/{project}/locations/{location}/issueModels/{issue_model}` * `projects/{project}/locations/{location}/generators/{generator_id}` */
  labeledResource?: string;
  /** Output only. Create time of the label. */
  createTime?: string;
  /** Output only. Update time of the label. */
  updateTime?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1FeedbackLabel: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1FeedbackLabel> = Schema.suspend(() => Schema.Struct({
  label: Schema.optional(Schema.String),
  qaAnswerLabel: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1QaAnswerAnswerValue),
  name: Schema.optional(Schema.String),
  labeledResource: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1FeedbackLabel" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1FeedbackLabel>;

export interface GoogleCloudContactcenterinsightsV1alpha1ListAllFeedbackLabelsResponse {
  /** The feedback labels that match the request. */
  feedbackLabels?: Array<GoogleCloudContactcenterinsightsV1alpha1FeedbackLabel>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1ListAllFeedbackLabelsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ListAllFeedbackLabelsResponse> = Schema.suspend(() => Schema.Struct({
  feedbackLabels: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1FeedbackLabel)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ListAllFeedbackLabelsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ListAllFeedbackLabelsResponse>;

export interface GoogleCloudContactcenterinsightsV1alpha1ListFeedbackLabelsResponse {
  /** The feedback labels that match the request. */
  feedbackLabels?: Array<GoogleCloudContactcenterinsightsV1alpha1FeedbackLabel>;
  /** The next page token. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1ListFeedbackLabelsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ListFeedbackLabelsResponse> = Schema.suspend(() => Schema.Struct({
  feedbackLabels: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1FeedbackLabel)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ListFeedbackLabelsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ListFeedbackLabelsResponse>;

export interface GoogleCloudContactcenterinsightsV1alpha1QueryMetricsMetadata {
  /** Whether the result rows were truncated because the result row size is too large to materialize. */
  resultIsTruncated?: boolean;
}

export const GoogleCloudContactcenterinsightsV1alpha1QueryMetricsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsMetadata> = Schema.suspend(() => Schema.Struct({
  resultIsTruncated: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1QueryMetricsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1DimensionIssueDimensionMetadata {
  /** The issue ID. */
  issueId?: string;
  /** The issue display name. */
  issueDisplayName?: string;
  /** The parent issue model ID. */
  issueModelId?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1DimensionIssueDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionIssueDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  issueId: Schema.optional(Schema.String),
  issueDisplayName: Schema.optional(Schema.String),
  issueModelId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DimensionIssueDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionIssueDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1DimensionAgentDimensionMetadata {
  /** Optional. A user-specified string representing the agent. This will be populated for AGENT, AGENT_TEAM, AGENT_VERSION_ID, and AGENT_DEPLOYMENT_ID dimensions. */
  agentId?: string;
  /** Optional. The agent's name This will be populated for AGENT, AGENT_TEAM, AGENT_VERSION_ID, and AGENT_DEPLOYMENT_ID dimensions. */
  agentDisplayName?: string;
  /** Optional. A user-specified string representing the agent's team. */
  agentTeam?: string;
  /** Optional. The agent's version display name. Only applicable to automated agents. This will be populated for AGENT_VERSION_ID, and AGENT_DEPLOYMENT_ID dimensions. */
  agentVersionDisplayName?: string;
  /** Optional. The agent's version ID. Only applicable to automated agents. This will be populated for AGENT_VERSION_ID, and AGENT_DEPLOYMENT_ID dimensions. */
  agentVersionId?: string;
  /** Optional. The agent's deployment display name. Only applicable to automated agents. This will be populated for AGENT_DEPLOYMENT_ID dimensions. */
  agentDeploymentDisplayName?: string;
  /** Optional. The agent's deployment ID. Only applicable to automated agents. This will be populated for AGENT and AGENT_DEPLOYMENT_ID dimensions. */
  agentDeploymentId?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1DimensionAgentDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionAgentDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  agentId: Schema.optional(Schema.String),
  agentDisplayName: Schema.optional(Schema.String),
  agentTeam: Schema.optional(Schema.String),
  agentVersionDisplayName: Schema.optional(Schema.String),
  agentVersionId: Schema.optional(Schema.String),
  agentDeploymentDisplayName: Schema.optional(Schema.String),
  agentDeploymentId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DimensionAgentDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionAgentDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1DimensionQaQuestionDimensionMetadata {
  /** Optional. The QA scorecard ID. */
  qaScorecardId?: string;
  /** Optional. The QA question ID. */
  qaQuestionId?: string;
  /** Optional. The full body of the question. */
  questionBody?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1DimensionQaQuestionDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionQaQuestionDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  qaScorecardId: Schema.optional(Schema.String),
  qaQuestionId: Schema.optional(Schema.String),
  questionBody: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DimensionQaQuestionDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionQaQuestionDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1DimensionQaQuestionAnswerDimensionMetadata {
  /** Optional. The QA scorecard ID. */
  qaScorecardId?: string;
  /** Optional. The QA question ID. */
  qaQuestionId?: string;
  /** Optional. The full body of the question. */
  questionBody?: string;
  /** Optional. The full body of the question. */
  answerValue?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1DimensionQaQuestionAnswerDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionQaQuestionAnswerDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  qaScorecardId: Schema.optional(Schema.String),
  qaQuestionId: Schema.optional(Schema.String),
  questionBody: Schema.optional(Schema.String),
  answerValue: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DimensionQaQuestionAnswerDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionQaQuestionAnswerDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1DimensionQaScorecardDimensionMetadata {
  /** Optional. The QA scorecard ID. */
  qaScorecardId?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1DimensionQaScorecardDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionQaScorecardDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  qaScorecardId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DimensionQaScorecardDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionQaScorecardDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1DimensionConversationProfileDimensionMetadata {
  /** Optional. The conversation profile ID. */
  conversationProfileId?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1DimensionConversationProfileDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionConversationProfileDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  conversationProfileId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DimensionConversationProfileDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionConversationProfileDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1DimensionMediumDimensionMetadata {
  /** Optional. The conversation medium. Currently supports : PHONE_CALL, CHAT. */
  medium?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1DimensionMediumDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionMediumDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  medium: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DimensionMediumDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionMediumDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1DimensionConversationalAgentsPlaybookDimensionMetadata {
  /** Optional. The dialogflow playbook ID. */
  playbookId?: string;
  /** Optional. The dialogflow playbook display name. */
  playbookDisplayName?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1DimensionConversationalAgentsPlaybookDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionConversationalAgentsPlaybookDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  playbookId: Schema.optional(Schema.String),
  playbookDisplayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DimensionConversationalAgentsPlaybookDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionConversationalAgentsPlaybookDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1DimensionConversationalAgentsToolDimensionMetadata {
  /** Optional. The dialogflow tool ID. */
  toolId?: string;
  /** Optional. The dialogflow tool display name. */
  toolDisplayName?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1DimensionConversationalAgentsToolDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionConversationalAgentsToolDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  toolId: Schema.optional(Schema.String),
  toolDisplayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DimensionConversationalAgentsToolDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionConversationalAgentsToolDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1DimensionClientSentimentCategoryDimensionMetadata {
  /** Optional. The client sentiment category. */
  sentimentCategory?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1DimensionClientSentimentCategoryDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionClientSentimentCategoryDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  sentimentCategory: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DimensionClientSentimentCategoryDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionClientSentimentCategoryDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1DimensionLabelDimensionMetadata {
  /** Optional. The label key. */
  labelKey?: string;
  /** Optional. The label value. */
  labelValue?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1DimensionLabelDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionLabelDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  labelKey: Schema.optional(Schema.String),
  labelValue: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DimensionLabelDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DimensionLabelDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1Dimension {
  /** Output only. Metadata about the issue dimension. */
  issueDimensionMetadata?: GoogleCloudContactcenterinsightsV1alpha1DimensionIssueDimensionMetadata;
  /** Output only. Metadata about the agent dimension. */
  agentDimensionMetadata?: GoogleCloudContactcenterinsightsV1alpha1DimensionAgentDimensionMetadata;
  /** Output only. Metadata about the QA question dimension. */
  qaQuestionDimensionMetadata?: GoogleCloudContactcenterinsightsV1alpha1DimensionQaQuestionDimensionMetadata;
  /** Output only. Metadata about the QA question-answer dimension. */
  qaQuestionAnswerDimensionMetadata?: GoogleCloudContactcenterinsightsV1alpha1DimensionQaQuestionAnswerDimensionMetadata;
  /** Output only. Metadata about the QA scorecard dimension. */
  qaScorecardDimensionMetadata?: GoogleCloudContactcenterinsightsV1alpha1DimensionQaScorecardDimensionMetadata;
  /** Output only. Metadata about the conversation profile dimension. */
  conversationProfileDimensionMetadata?: GoogleCloudContactcenterinsightsV1alpha1DimensionConversationProfileDimensionMetadata;
  /** Output only. Metadata about the conversation medium dimension. */
  mediumDimensionMetadata?: GoogleCloudContactcenterinsightsV1alpha1DimensionMediumDimensionMetadata;
  /** Output only. Metadata about the Conversational Agents playbook dimension. */
  conversationalAgentsPlaybookDimensionMetadata?: GoogleCloudContactcenterinsightsV1alpha1DimensionConversationalAgentsPlaybookDimensionMetadata;
  /** Output only. Metadata about the Conversational Agents tool dimension. */
  conversationalAgentsToolDimensionMetadata?: GoogleCloudContactcenterinsightsV1alpha1DimensionConversationalAgentsToolDimensionMetadata;
  /** Output only. Metadata about the client sentiment category dimension. */
  clientSentimentCategoryDimensionMetadata?: GoogleCloudContactcenterinsightsV1alpha1DimensionClientSentimentCategoryDimensionMetadata;
  /** Output only. Metadata about conversation labels. */
  labelDimensionMetadata?: GoogleCloudContactcenterinsightsV1alpha1DimensionLabelDimensionMetadata;
  /** The key of the dimension. */
  dimensionKey?: "DIMENSION_KEY_UNSPECIFIED" | "ISSUE" | "ISSUE_NAME" | "AGENT" | "AGENT_TEAM" | "QA_QUESTION_ID" | "QA_QUESTION_ANSWER_VALUE" | "QA_SCORECARD_ID" | "CONVERSATION_PROFILE_ID" | "MEDIUM" | "CONVERSATIONAL_AGENTS_PLAYBOOK_ID" | "CONVERSATIONAL_AGENTS_PLAYBOOK_NAME" | "CONVERSATIONAL_AGENTS_TOOL_ID" | "CONVERSATIONAL_AGENTS_TOOL_NAME" | "CLIENT_SENTIMENT_CATEGORY" | "AGENT_VERSION_ID" | "AGENT_DEPLOYMENT_ID" | "AGENT_ASSIST_SUPERVISOR_ID" | "LABEL_KEY" | "LABEL_VALUE" | "LABEL_KEY_AND_VALUE" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1alpha1Dimension: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1Dimension> = Schema.suspend(() => Schema.Struct({
  issueDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1DimensionIssueDimensionMetadata),
  agentDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1DimensionAgentDimensionMetadata),
  qaQuestionDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1DimensionQaQuestionDimensionMetadata),
  qaQuestionAnswerDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1DimensionQaQuestionAnswerDimensionMetadata),
  qaScorecardDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1DimensionQaScorecardDimensionMetadata),
  conversationProfileDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1DimensionConversationProfileDimensionMetadata),
  mediumDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1DimensionMediumDimensionMetadata),
  conversationalAgentsPlaybookDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1DimensionConversationalAgentsPlaybookDimensionMetadata),
  conversationalAgentsToolDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1DimensionConversationalAgentsToolDimensionMetadata),
  clientSentimentCategoryDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1DimensionClientSentimentCategoryDimensionMetadata),
  labelDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1DimensionLabelDimensionMetadata),
  dimensionKey: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1Dimension" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1Dimension>;

export interface GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointConversationMeasureQaTagScore {
  /** Tag name. */
  tag?: string;
  /** Average tag normalized score per tag. */
  averageTagNormalizedScore?: number;
}

export const GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointConversationMeasureQaTagScore: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointConversationMeasureQaTagScore> = Schema.suspend(() => Schema.Struct({
  tag: Schema.optional(Schema.String),
  averageTagNormalizedScore: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointConversationMeasureQaTagScore" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointConversationMeasureQaTagScore>;

export interface GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointConversationMeasure {
  /** The conversation count. */
  conversationCount?: number;
  /** The average silence percentage. */
  averageSilencePercentage?: number;
  /** The average duration. */
  averageDuration?: string;
  /** The average turn count. */
  averageTurnCount?: number;
  /** The average agent's sentiment score. */
  averageAgentSentimentScore?: number;
  /** The average client's sentiment score. */
  averageClientSentimentScore?: number;
  /** The average customer satisfaction rating. */
  averageCustomerSatisfactionRating?: number;
  /** The average normalized QA score for a scorecard. When computing the average across a set of conversations, if a conversation has been evaluated with multiple revisions of a scorecard, only the latest revision results will be used. Will exclude 0's in average calculation. Will be only populated if the request specifies a dimension of QA_SCORECARD_ID. */
  averageQaNormalizedScore?: number;
  /** Average QA normalized score for all the tags. */
  qaTagScores?: Array<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointConversationMeasureQaTagScore>;
  /** Average QA normalized score averaged for questions averaged across all revisions of the parent scorecard. Will be only populated if the request specifies a dimension of QA_QUESTION_ID. */
  averageQaQuestionNormalizedScore?: number;
  /** Count of knowledge search results (Generative Knowledge Assist) shown to the user. */
  knowledgeSearchResultCount?: number;
  /** Proportion of knowledge search (Generative Knowledge Assist) queries made by the agent compared to the total number of knowledge search queries made. */
  knowledgeSearchAgentQuerySourceRatio?: number;
  /** Proportion of knowledge search (Generative Knowledge Assist) queries suggested compared to the total number of knowledge search queries made. */
  knowledgeSearchSuggestedQuerySourceRatio?: number;
  /** Count of knowledge assist results (Proactive Generative Knowledge Assist) shown to the user. */
  knowledgeAssistResultCount?: number;
  /** Proportion of knowledge search (Generative Knowledge Assist) queries that had a URL clicked. */
  knowledgeSearchUriClickRatio?: number;
  /** Proportion of knowledge assist (Proactive Generative Knowledge Assist) queries that had a URL clicked. */
  knowledgeAssistUriClickRatio?: number;
  /** Proportion of knowledge search (Generative Knowledge Assist) queries that had positive feedback. */
  knowledgeSearchPositiveFeedbackRatio?: number;
  /** Proportion of knowledge search (Generative Knowledge Assist) queries that had negative feedback. */
  knowledgeSearchNegativeFeedbackRatio?: number;
  /** Proportion of knowledge assist (Proactive Generative Knowledge Assist) queries that had positive feedback. */
  knowledgeAssistPositiveFeedbackRatio?: number;
  /** Proportion of knowledge assist (Proactive Generative Knowledge Assist) queries that had negative feedback. */
  knowledgeAssistNegativeFeedbackRatio?: number;
  /** Proportion of summarization suggestions that were manually edited. */
  summarizationSuggestionEditRatio?: number;
  /** Average edit distance of the summarization suggestions. Edit distance (also called as levenshtein distance) is calculated by summing up number of insertions, deletions and substitutions required to transform the summization feedback to the original summary suggestion. */
  averageSummarizationSuggestionEditDistance?: number;
  /** Normalized Average edit distance of the summarization suggestions. Edit distance (also called as levenshtein distance) is calculated by summing up number of insertions, deletions and substitutions required to transform the summization feedback to the original summary suggestion. Normalized edit distance is the average of (edit distance / summary length). */
  averageSummarizationSuggestionNormalizedEditDistance?: number;
  /** Proportion of conversations that had a suggested summary. */
  conversationSuggestedSummaryRatio?: number;
  /** Count of summarization suggestions results. */
  summarizationSuggestionResultCount?: number;
  /** Proportion of dialogflow interactions that has no intent match for the input. */
  dialogflowInteractionsNoMatchRatio?: number;
  /** Proportion of dialogflow interactions that has empty input. */
  dialogflowInteractionsNoInputRatio?: number;
  /** Proportion of dialogflow webhook calls that failed. */
  dialogflowWebhookFailureRatio?: number;
  /** Proportion of dialogflow webhook calls that timed out. */
  dialogflowWebhookTimeoutRatio?: number;
  /** Average latency of dialogflow webhook calls. */
  dialogflowAverageWebhookLatency?: number;
  /** Proportion of conversations that was handed off from virtual agent to human agent. */
  dialogflowConversationsEscalationRatio?: number;
  /** count of conversations that was handed off from virtual agent to human agent. */
  dialogflowConversationsEscalationCount?: number;
  /** The macro average latency of conversational agents' TTS latency per interaction. This is computed as the average of the all the interactions' TTS latencies in a conversation and averaged across conversations. */
  conversationalAgentsAverageTtsLatency?: number;
  /** The average latency of conversational agents' LLM call latency per interaction. This is computed as the average of the all the interactions LLM call latencies in a conversation and averaged across conversations. */
  conversationalAgentsAverageLlmCallLatency?: number;
  /** The average latency of conversational agents' audio in audio out latency per interaction. This is computed as the average of the all the interactions' audio in audio out latencies in a conversation and averaged across conversations. */
  conversationalAgentsAverageAudioInAudioOutLatency?: number;
  /** Proportion of conversations that has Ai Coach Suggestions. */
  conversationAiCoachSuggestionRatio?: number;
  /** Proportion of Ai Coach Suggestion that has been used by agents. */
  aiCoachSuggestionAgentUsageRatio?: number;
  /** Proportion of customer messages that triggered an Ai Coach Suggestion. */
  aiCoachSuggestionCustomerMessageTriggerRatio?: number;
  /** The average latency of conversational agents' latency per interaction. This is computed as the average of the all the iteractions' end to end latencies in a conversation and averaged across conversations. The e2e latency is the time between the end of the user utterance and the start of the agent utterance on the interaction level. */
  conversationalAgentsAverageEndToEndLatency?: number;
  /** Count of conversations that has Ai Coach Suggestions. */
  conversationAiCoachSuggestionCount?: number;
  /** Count of Ai Coach Suggestion that has been used by agents. */
  aiCoachSuggestionAgentUsageCount?: number;
  /** Count of customer messages that triggered an Ai Coach Suggestion. */
  aiCoachSuggestionCustomerMessageTriggerCount?: number;
  /** Count of agent messages that triggered an Ai Coach Suggestion. */
  aiCoachSuggestionAgentMessageTriggerCount?: number;
  /** The customer message count. */
  conversationTotalCustomerMessageCount?: number;
  /** The agent message count. */
  conversationTotalAgentMessageCount?: number;
  /** The number of conversations scanned by the AA human supervisor. */
  aaSupervisorMonitoredConversationsCount?: number;
  /** The number of conversations that were escalated to an AA human supervisor for intervention. */
  aaSupervisorEscalatedConversationsCount?: number;
  /** The number of conversations that were assigned to an AA human supervisor. */
  aaSupervisorAssignedConversationsCount?: number;
  /** The number of conversations that were dropped, i.e. escalated but not assigned to an AA human supervisor. */
  aaSupervisorDroppedConversationsCount?: number;
  /** The number of conversations transferred to a human agent. */
  aaSupervisorTransferredToHumanAgentConvCount?: number;
  /** The exponential moving average of the sentiment score of client turns in the conversation. */
  avgConversationClientTurnSentimentEma?: number;
  /** Proportion of end_of_utterance trigger event messages that triggered an Ai Coach Suggestion. */
  aiCoachSuggestionMessageTriggerRatio?: number;
  /** Count of end_of_utterance trigger event messages that triggered an Ai Coach Suggestion. */
  aiCoachSuggestionMessageTriggerCount?: number;
  /** The number of conversations that were contained. */
  containedConversationCount?: number;
  /** The percentage of conversations that were contained. */
  containedConversationRatio?: number;
}

export const GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointConversationMeasure: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointConversationMeasure> = Schema.suspend(() => Schema.Struct({
  conversationCount: Schema.optional(Schema.Number),
  averageSilencePercentage: Schema.optional(Schema.Number),
  averageDuration: Schema.optional(Schema.String),
  averageTurnCount: Schema.optional(Schema.Number),
  averageAgentSentimentScore: Schema.optional(Schema.Number),
  averageClientSentimentScore: Schema.optional(Schema.Number),
  averageCustomerSatisfactionRating: Schema.optional(Schema.Number),
  averageQaNormalizedScore: Schema.optional(Schema.Number),
  qaTagScores: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointConversationMeasureQaTagScore)),
  averageQaQuestionNormalizedScore: Schema.optional(Schema.Number),
  knowledgeSearchResultCount: Schema.optional(Schema.Number),
  knowledgeSearchAgentQuerySourceRatio: Schema.optional(Schema.Number),
  knowledgeSearchSuggestedQuerySourceRatio: Schema.optional(Schema.Number),
  knowledgeAssistResultCount: Schema.optional(Schema.Number),
  knowledgeSearchUriClickRatio: Schema.optional(Schema.Number),
  knowledgeAssistUriClickRatio: Schema.optional(Schema.Number),
  knowledgeSearchPositiveFeedbackRatio: Schema.optional(Schema.Number),
  knowledgeSearchNegativeFeedbackRatio: Schema.optional(Schema.Number),
  knowledgeAssistPositiveFeedbackRatio: Schema.optional(Schema.Number),
  knowledgeAssistNegativeFeedbackRatio: Schema.optional(Schema.Number),
  summarizationSuggestionEditRatio: Schema.optional(Schema.Number),
  averageSummarizationSuggestionEditDistance: Schema.optional(Schema.Number),
  averageSummarizationSuggestionNormalizedEditDistance: Schema.optional(Schema.Number),
  conversationSuggestedSummaryRatio: Schema.optional(Schema.Number),
  summarizationSuggestionResultCount: Schema.optional(Schema.Number),
  dialogflowInteractionsNoMatchRatio: Schema.optional(Schema.Number),
  dialogflowInteractionsNoInputRatio: Schema.optional(Schema.Number),
  dialogflowWebhookFailureRatio: Schema.optional(Schema.Number),
  dialogflowWebhookTimeoutRatio: Schema.optional(Schema.Number),
  dialogflowAverageWebhookLatency: Schema.optional(Schema.Number),
  dialogflowConversationsEscalationRatio: Schema.optional(Schema.Number),
  dialogflowConversationsEscalationCount: Schema.optional(Schema.Number),
  conversationalAgentsAverageTtsLatency: Schema.optional(Schema.Number),
  conversationalAgentsAverageLlmCallLatency: Schema.optional(Schema.Number),
  conversationalAgentsAverageAudioInAudioOutLatency: Schema.optional(Schema.Number),
  conversationAiCoachSuggestionRatio: Schema.optional(Schema.Number),
  aiCoachSuggestionAgentUsageRatio: Schema.optional(Schema.Number),
  aiCoachSuggestionCustomerMessageTriggerRatio: Schema.optional(Schema.Number),
  conversationalAgentsAverageEndToEndLatency: Schema.optional(Schema.Number),
  conversationAiCoachSuggestionCount: Schema.optional(Schema.Number),
  aiCoachSuggestionAgentUsageCount: Schema.optional(Schema.Number),
  aiCoachSuggestionCustomerMessageTriggerCount: Schema.optional(Schema.Number),
  aiCoachSuggestionAgentMessageTriggerCount: Schema.optional(Schema.Number),
  conversationTotalCustomerMessageCount: Schema.optional(Schema.Number),
  conversationTotalAgentMessageCount: Schema.optional(Schema.Number),
  aaSupervisorMonitoredConversationsCount: Schema.optional(Schema.Number),
  aaSupervisorEscalatedConversationsCount: Schema.optional(Schema.Number),
  aaSupervisorAssignedConversationsCount: Schema.optional(Schema.Number),
  aaSupervisorDroppedConversationsCount: Schema.optional(Schema.Number),
  aaSupervisorTransferredToHumanAgentConvCount: Schema.optional(Schema.Number),
  avgConversationClientTurnSentimentEma: Schema.optional(Schema.Number),
  aiCoachSuggestionMessageTriggerRatio: Schema.optional(Schema.Number),
  aiCoachSuggestionMessageTriggerCount: Schema.optional(Schema.Number),
  containedConversationCount: Schema.optional(Schema.Number),
  containedConversationRatio: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointConversationMeasure" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointConversationMeasure>;

export interface GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointPercentileResult {
  /** The 50th percentile value. */
  p50?: number;
  /** The 90th percentile value. */
  p90?: number;
  /** The 99th percentile value. */
  p99?: number;
}

export const GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointPercentileResult: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointPercentileResult> = Schema.suspend(() => Schema.Struct({
  p50: Schema.optional(Schema.Number),
  p90: Schema.optional(Schema.Number),
  p99: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointPercentileResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointPercentileResult>;

export interface GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointDialogflowInteractionMeasure {
  /** The percentile result for audio in audio out latency in milliseconds per dialogflow interaction level. */
  percentileAudioInAudioOutLatency?: GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointPercentileResult;
  /** The percentile result for LLM latency in milliseconds per dialogflow interaction level. */
  percentileLlmCallLatency?: GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointPercentileResult;
  /** The percentile result for TTS latency in milliseconds per dialogflow interaction level. */
  percentileTtsLatency?: GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointPercentileResult;
  /** The percentile result for tool use latency in milliseconds per dialogflow interaction level. */
  percentileToolUseLatency?: GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointPercentileResult;
  /** The percentile result for end to end chat latency in milliseconds per dialogflow interaction level. */
  percentileEndToEndLatency?: GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointPercentileResult;
}

export const GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointDialogflowInteractionMeasure: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointDialogflowInteractionMeasure> = Schema.suspend(() => Schema.Struct({
  percentileAudioInAudioOutLatency: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointPercentileResult),
  percentileLlmCallLatency: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointPercentileResult),
  percentileTtsLatency: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointPercentileResult),
  percentileToolUseLatency: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointPercentileResult),
  percentileEndToEndLatency: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointPercentileResult),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointDialogflowInteractionMeasure" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointDialogflowInteractionMeasure>;

export interface GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPoint {
  /** The measure related to conversations. */
  conversationMeasure?: GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointConversationMeasure;
  /** The measure related to dialogflow interactions. */
  dialogflowInteractionMeasure?: GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointDialogflowInteractionMeasure;
  /** The interval that this data point represents. * If this is the total data point, the interval is [starting create time, ending create time) from the request. * If this a data point from the time series, the interval is [time, time + time granularity from the request). */
  interval?: GoogleTypeInterval;
}

export const GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPoint: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPoint> = Schema.suspend(() => Schema.Struct({
  conversationMeasure: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointConversationMeasure),
  dialogflowInteractionMeasure: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPointDialogflowInteractionMeasure),
  interval: Schema.optional(GoogleTypeInterval),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPoint" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPoint>;

export interface GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceTimeSeries {
  /** The data points that make up the time series . */
  dataPoints?: Array<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPoint>;
}

export const GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceTimeSeries: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceTimeSeries> = Schema.suspend(() => Schema.Struct({
  dataPoints: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPoint)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceTimeSeries" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceTimeSeries>;

export interface GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSlice {
  /** A unique combination of dimensions that this slice represents. */
  dimensions?: Array<GoogleCloudContactcenterinsightsV1alpha1Dimension>;
  /** The total metric value. The interval of this data point is [starting create time, ending create time) from the request. */
  total?: GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPoint;
  /** A time series of metric values. This is only populated if the request specifies a time granularity other than NONE. */
  timeSeries?: GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceTimeSeries;
}

export const GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSlice: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSlice> = Schema.suspend(() => Schema.Struct({
  dimensions: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1Dimension)),
  total: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceDataPoint),
  timeSeries: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSliceTimeSeries),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSlice" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSlice>;

export interface GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponse {
  /** Required. The location of the data. "projects/{project}/locations/{location}" */
  location?: string;
  /** The metrics last update time. */
  updateTime?: string;
  /** A slice contains a total and (if the request specified a time granularity) a time series of metric values. Each slice contains a unique combination of the cardinality of dimensions from the request. */
  slices?: Array<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSlice>;
  /** The macro average slice contains aggregated averages across all selected dimensions. i.e. if group_by agent and scorecard_id is specified, this field will contain the average across all agents and all scorecards. This field is only populated if the request specifies a Dimension. */
  macroAverageSlice?: GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSlice;
}

export const GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponse> = Schema.suspend(() => Schema.Struct({
  location: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  slices: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSlice)),
  macroAverageSlice: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponseSlice),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryMetricsResponse>;

export interface GoogleCloudContactcenterinsightsV1alpha1QueryPerformanceOverviewMetadata {
}

export const GoogleCloudContactcenterinsightsV1alpha1QueryPerformanceOverviewMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryPerformanceOverviewMetadata> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1QueryPerformanceOverviewMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryPerformanceOverviewMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1QueryPerformanceOverviewResponse {
  /** The summary text of the performance. */
  summaryText?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1QueryPerformanceOverviewResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryPerformanceOverviewResponse> = Schema.suspend(() => Schema.Struct({
  summaryText: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1QueryPerformanceOverviewResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QueryPerformanceOverviewResponse>;

export interface GoogleCloudContactcenterinsightsV1alpha1Dataset {
  /** Immutable. Identifier. Resource name of the dataset. Format: projects/{project}/locations/{location}/datasets/{dataset} */
  name?: string;
  /** Display name for the dataaset */
  displayName?: string;
  /** Dataset description. */
  description?: string;
  /** Dataset usage type. */
  type?: "TYPE_UNSPECIFIED" | "EVAL" | "LIVE" | (string & {});
  /** Optional. Option TTL for the dataset. */
  ttl?: string;
  /** Output only. Dataset create time. */
  createTime?: string;
  /** Output only. Dataset update time. */
  updateTime?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1Dataset: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1Dataset> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  ttl: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1Dataset" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1Dataset>;

export interface GoogleCloudContactcenterinsightsV1alpha1SampleRule {
  /** Percentage of conversations that we should sample based on the dimension between [0, 100]. */
  samplePercentage?: number;
  /** Number of the conversations that we should sample based on the dimension. */
  sampleRow?: string;
  /** Optional. Group by dimension to sample the conversation. If no dimension is provided, the sampling will be applied to the project level. Current supported dimensions is 'quality_metadata.agent_info.agent_id'. */
  dimension?: string;
  /** To specify the filter for the conversions that should apply this sample rule. An empty filter means this sample rule applies to all conversations. */
  conversationFilter?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1SampleRule: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SampleRule> = Schema.suspend(() => Schema.Struct({
  samplePercentage: Schema.optional(Schema.Number),
  sampleRow: Schema.optional(Schema.String),
  dimension: Schema.optional(Schema.String),
  conversationFilter: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1SampleRule" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SampleRule>;

export interface GoogleCloudContactcenterinsightsV1alpha1SampleConversationsRequest {
  /** The dataset resource to copy the sampled conversations to. */
  destinationDataset?: GoogleCloudContactcenterinsightsV1alpha1Dataset;
  /** Required. The parent resource of the dataset. */
  parent?: string;
  /** Optional. The sample rule used for sampling conversations. */
  sampleRule?: GoogleCloudContactcenterinsightsV1alpha1SampleRule;
}

export const GoogleCloudContactcenterinsightsV1alpha1SampleConversationsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SampleConversationsRequest> = Schema.suspend(() => Schema.Struct({
  destinationDataset: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1Dataset),
  parent: Schema.optional(Schema.String),
  sampleRule: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1SampleRule),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1SampleConversationsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SampleConversationsRequest>;

export interface GoogleCloudContactcenterinsightsV1alpha1SampleConversationsMetadataSampleConversationsStats {
  /** Output only. The number of new conversations added during this sample operation. */
  successfulSampleCount?: number;
  /** Output only. The number of objects which were unable to be sampled due to errors. The errors are populated in the partial_errors field. */
  failedSampleCount?: number;
}

export const GoogleCloudContactcenterinsightsV1alpha1SampleConversationsMetadataSampleConversationsStats: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SampleConversationsMetadataSampleConversationsStats> = Schema.suspend(() => Schema.Struct({
  successfulSampleCount: Schema.optional(Schema.Number),
  failedSampleCount: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1SampleConversationsMetadataSampleConversationsStats" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SampleConversationsMetadataSampleConversationsStats>;

export interface GoogleCloudContactcenterinsightsV1alpha1SampleConversationsMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request for sample conversations to dataset. */
  request?: GoogleCloudContactcenterinsightsV1alpha1SampleConversationsRequest;
  /** Output only. Partial errors during sample conversations operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
  /** Output only. Statistics for SampleConversations operation. */
  sampleConversationsStats?: GoogleCloudContactcenterinsightsV1alpha1SampleConversationsMetadataSampleConversationsStats;
}

export const GoogleCloudContactcenterinsightsV1alpha1SampleConversationsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SampleConversationsMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1SampleConversationsRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
  sampleConversationsStats: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1SampleConversationsMetadataSampleConversationsStats),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1SampleConversationsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SampleConversationsMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1SampleConversationsResponse {
}

export const GoogleCloudContactcenterinsightsV1alpha1SampleConversationsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SampleConversationsResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1SampleConversationsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SampleConversationsResponse>;

export interface GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError {
  /** The conversation resource name that had an error during correlation. */
  conversation?: string;
  /** The error status. */
  status?: GoogleRpcStatus;
}

export const GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError> = Schema.suspend(() => Schema.Struct({
  conversation: Schema.optional(Schema.String),
  status: Schema.optional(GoogleRpcStatus),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError>;

export interface GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadataFullConversationCorrelationStats {
  /** The number of conversations sampled. */
  sampledConversationsCount?: number;
  /** The number of conversations correlated. */
  correlatedConversationsCount?: number;
  /** The number of conversations that failed correlation. */
  failedConversationsCount?: number;
  /** Partial errors during test correlation config operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
  /** A list of errors that occurred during correlation, one for each conversation that failed. */
  conversationCorrelationErrors?: Array<GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError>;
}

export const GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadataFullConversationCorrelationStats: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadataFullConversationCorrelationStats> = Schema.suspend(() => Schema.Struct({
  sampledConversationsCount: Schema.optional(Schema.Number),
  correlatedConversationsCount: Schema.optional(Schema.Number),
  failedConversationsCount: Schema.optional(Schema.Number),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
  conversationCorrelationErrors: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadataFullConversationCorrelationStats" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadataFullConversationCorrelationStats>;

export interface GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** The dataset used for sampling conversations. */
  dataset?: string;
  /** The statistics for the operation. */
  stats?: GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadataFullConversationCorrelationStats;
}

export const GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  dataset: Schema.optional(Schema.String),
  stats: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadataFullConversationCorrelationStats),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationResultRuleCorrelationResult {
  /** The correlation ID generated by the join key expression. */
  correlationId?: string;
  /** The error status if the join key expression failed to evaluate. */
  error?: GoogleRpcStatus;
  /** The rule ID. */
  ruleId?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationResultRuleCorrelationResult: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationResultRuleCorrelationResult> = Schema.suspend(() => Schema.Struct({
  correlationId: Schema.optional(Schema.String),
  error: Schema.optional(GoogleRpcStatus),
  ruleId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationResultRuleCorrelationResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationResultRuleCorrelationResult>;

export interface GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationResult {
  /** The conversation resource name. */
  conversation?: string;
  /** The results for each correlation rule. */
  ruleResults?: Array<GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationResultRuleCorrelationResult>;
}

export const GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationResult: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationResult> = Schema.suspend(() => Schema.Struct({
  conversation: Schema.optional(Schema.String),
  ruleResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationResultRuleCorrelationResult)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationResult>;

export interface GoogleCloudContactcenterinsightsV1alpha1ConstraintEvaluationResultRuleConstraintResult {
  /** Whether the constraint expression evaluated to true for (A, B) or (B, A). */
  constraintMet?: boolean;
  /** The error status if the constraint expression failed to evaluate. */
  error?: GoogleRpcStatus;
  /** The rule ID. */
  ruleId?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1ConstraintEvaluationResultRuleConstraintResult: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConstraintEvaluationResultRuleConstraintResult> = Schema.suspend(() => Schema.Struct({
  constraintMet: Schema.optional(Schema.Boolean),
  error: Schema.optional(GoogleRpcStatus),
  ruleId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ConstraintEvaluationResultRuleConstraintResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConstraintEvaluationResultRuleConstraintResult>;

export interface GoogleCloudContactcenterinsightsV1alpha1ConstraintEvaluationResult {
  /** The first conversation resource name. */
  conversationA?: string;
  /** The second conversation resource name. */
  conversationB?: string;
  /** The results for each applicable constraint rule. */
  ruleConstraintResults?: Array<GoogleCloudContactcenterinsightsV1alpha1ConstraintEvaluationResultRuleConstraintResult>;
}

export const GoogleCloudContactcenterinsightsV1alpha1ConstraintEvaluationResult: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConstraintEvaluationResult> = Schema.suspend(() => Schema.Struct({
  conversationA: Schema.optional(Schema.String),
  conversationB: Schema.optional(Schema.String),
  ruleConstraintResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1ConstraintEvaluationResultRuleConstraintResult)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ConstraintEvaluationResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConstraintEvaluationResult>;

export interface GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigResponseDetailedCorrelationResults {
  /** A list of join key correlation results for each conversation tested. */
  joinKeyResults?: Array<GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationResult>;
  /** A list of constraint evaluation results for each pair of conversations. */
  constraintResults?: Array<GoogleCloudContactcenterinsightsV1alpha1ConstraintEvaluationResult>;
}

export const GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigResponseDetailedCorrelationResults: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigResponseDetailedCorrelationResults> = Schema.suspend(() => Schema.Struct({
  joinKeyResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationResult)),
  constraintResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1ConstraintEvaluationResult)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigResponseDetailedCorrelationResults" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigResponseDetailedCorrelationResults>;

export interface GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigResponse {
  /** Results for the DETAILED_SYNC execution mode. */
  detailedResults?: GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigResponseDetailedCorrelationResults;
  /** Partial errors during test correlation config operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
}

export const GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigResponse> = Schema.suspend(() => Schema.Struct({
  detailedResults: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigResponseDetailedCorrelationResults),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1TestCorrelationConfigResponse>;

export interface GoogleCloudContactcenterinsightsV1alpha1UndeployIssueModelRequest {
  /** Required. The issue model to undeploy. */
  name?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1UndeployIssueModelRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1UndeployIssueModelRequest> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1UndeployIssueModelRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1UndeployIssueModelRequest>;

export interface GoogleCloudContactcenterinsightsV1alpha1UndeployIssueModelMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** The original request for undeployment. */
  request?: GoogleCloudContactcenterinsightsV1alpha1UndeployIssueModelRequest;
}

export const GoogleCloudContactcenterinsightsV1alpha1UndeployIssueModelMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1UndeployIssueModelMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1UndeployIssueModelRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1UndeployIssueModelMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1UndeployIssueModelMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1UndeployIssueModelResponse {
}

export const GoogleCloudContactcenterinsightsV1alpha1UndeployIssueModelResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1UndeployIssueModelResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1UndeployIssueModelResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1UndeployIssueModelResponse>;

export interface GoogleCloudContactcenterinsightsV1alpha1QaQuestionTag {
  /** Identifier. Resource name for the QaQuestionTag Format projects/{project}/locations/{location}/qaQuestionTags/{qa_question_tag} In the above format, the last segment, i.e., qa_question_tag, is a server-generated ID corresponding to the tag resource. */
  name?: string;
  /** Required. A user-specified display name for the tag. */
  displayName?: string;
  /** Optional. The list of Scorecard Question IDs that the tag applies to. Each QaQuestionId is represented as a full resource name containing the Question ID. Lastly, Since a tag may not necessarily be referenced by any Scorecard Questions, we treat this field as optional. */
  qaQuestionIds?: Array<string>;
  /** Output only. The time at which the question tag was created. */
  createTime?: string;
  /** Output only. The most recent time at which the question tag was updated. */
  updateTime?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1QaQuestionTag: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QaQuestionTag> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  qaQuestionIds: Schema.optional(Schema.Array(Schema.String)),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1QaQuestionTag" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QaQuestionTag>;

export interface GoogleCloudContactcenterinsightsV1alpha1UpdateQaQuestionTagRequest {
  /** Required. The QaQuestionTag to update. */
  qaQuestionTag?: GoogleCloudContactcenterinsightsV1alpha1QaQuestionTag;
  /** Optional. The list of fields to be updated. All possible fields can be updated by passing `*`, or a subset of the following updateable fields can be provided: * `qa_question_tag_name` - the name of the tag * `qa_question_ids` - the list of questions the tag applies to */
  updateMask?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1UpdateQaQuestionTagRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1UpdateQaQuestionTagRequest> = Schema.suspend(() => Schema.Struct({
  qaQuestionTag: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1QaQuestionTag),
  updateMask: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1UpdateQaQuestionTagRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1UpdateQaQuestionTagRequest>;

export interface GoogleCloudContactcenterinsightsV1alpha1UpdateQaQuestionTagMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request. */
  request?: GoogleCloudContactcenterinsightsV1alpha1UpdateQaQuestionTagRequest;
}

export const GoogleCloudContactcenterinsightsV1alpha1UpdateQaQuestionTagMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1UpdateQaQuestionTagMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1UpdateQaQuestionTagRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1UpdateQaQuestionTagMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1UpdateQaQuestionTagMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1ConversationCallMetadata {
  /** The audio channel that contains the customer. */
  customerChannel?: number;
  /** The audio channel that contains the agent. */
  agentChannel?: number;
}

export const GoogleCloudContactcenterinsightsV1alpha1ConversationCallMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationCallMetadata> = Schema.suspend(() => Schema.Struct({
  customerChannel: Schema.optional(Schema.Number),
  agentChannel: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ConversationCallMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationCallMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1GcsSource {
  /** Cloud Storage URI that points to a file that contains the conversation audio. */
  audioUri?: string;
  /** Immutable. Cloud Storage URI that points to a file that contains the conversation transcript. */
  transcriptUri?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1GcsSource: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GcsSource> = Schema.suspend(() => Schema.Struct({
  audioUri: Schema.optional(Schema.String),
  transcriptUri: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1GcsSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1GcsSource>;

export interface GoogleCloudContactcenterinsightsV1alpha1DialogflowSource {
  /** Output only. The name of the Dialogflow conversation that this conversation resource is derived from. Format: projects/{project}/locations/{location}/conversations/{conversation} */
  dialogflowConversation?: string;
  /** Cloud Storage URI that points to a file that contains the conversation audio. */
  audioUri?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1DialogflowSource: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DialogflowSource> = Schema.suspend(() => Schema.Struct({
  dialogflowConversation: Schema.optional(Schema.String),
  audioUri: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DialogflowSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DialogflowSource>;

export interface GoogleCloudContactcenterinsightsV1alpha1ConversationDataSource {
  /** A Cloud Storage location specification for the audio and transcript. */
  gcsSource?: GoogleCloudContactcenterinsightsV1alpha1GcsSource;
  /** The source when the conversation comes from Dialogflow. */
  dialogflowSource?: GoogleCloudContactcenterinsightsV1alpha1DialogflowSource;
  /** Cloud Storage URI that points to a file that contains the conversation metadata. */
  metadataUri?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1ConversationDataSource: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationDataSource> = Schema.suspend(() => Schema.Struct({
  gcsSource: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1GcsSource),
  dialogflowSource: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1DialogflowSource),
  metadataUri: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ConversationDataSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationDataSource>;

export interface GoogleCloudContactcenterinsightsV1alpha1ConversationQualityMetadataAgentInfo {
  /** A user-specified string representing the agent. */
  agentId?: string;
  /** The agent's name. */
  displayName?: string;
  /** A user-specified string representing the agent's team. Deprecated in favor of the `teams` field. */
  team?: string;
  /** User-specified strings representing the agent's teams. */
  teams?: Array<string>;
  /** A user-provided string indicating the outcome of the agent's segment of the call. */
  dispositionCode?: string;
  /** The agent type, e.g. HUMAN_AGENT. */
  agentType?: "ROLE_UNSPECIFIED" | "HUMAN_AGENT" | "AUTOMATED_AGENT" | "END_USER" | "ANY_AGENT" | (string & {});
  /** The agent's location. */
  location?: string;
  /** The agent's deployment ID. Only applicable to automated agents. */
  deploymentId?: string;
  /** The agent's deployment display name. Only applicable to automated agents. */
  deploymentDisplayName?: string;
  /** The agent's version ID. Only applicable to automated agents. */
  versionId?: string;
  /** The agent's version display name. Only applicable to automated agents. */
  versionDisplayName?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1ConversationQualityMetadataAgentInfo: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationQualityMetadataAgentInfo> = Schema.suspend(() => Schema.Struct({
  agentId: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  team: Schema.optional(Schema.String),
  teams: Schema.optional(Schema.Array(Schema.String)),
  dispositionCode: Schema.optional(Schema.String),
  agentType: Schema.optional(Schema.String),
  location: Schema.optional(Schema.String),
  deploymentId: Schema.optional(Schema.String),
  deploymentDisplayName: Schema.optional(Schema.String),
  versionId: Schema.optional(Schema.String),
  versionDisplayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ConversationQualityMetadataAgentInfo" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationQualityMetadataAgentInfo>;

export interface GoogleCloudContactcenterinsightsV1alpha1ConversationQualityMetadata {
  /** An arbitrary integer value indicating the customer's satisfaction rating. */
  customerSatisfactionRating?: number;
  /** The amount of time the customer waited to connect with an agent. */
  waitDuration?: string;
  /** An arbitrary string value specifying the menu path the customer took. */
  menuPath?: string;
  /** Information about agents involved in the call. */
  agentInfo?: Array<GoogleCloudContactcenterinsightsV1alpha1ConversationQualityMetadataAgentInfo>;
  /** Input only. The feedback labels associated with the conversation. */
  feedbackLabels?: Array<GoogleCloudContactcenterinsightsV1alpha1FeedbackLabel>;
}

export const GoogleCloudContactcenterinsightsV1alpha1ConversationQualityMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationQualityMetadata> = Schema.suspend(() => Schema.Struct({
  customerSatisfactionRating: Schema.optional(Schema.Number),
  waitDuration: Schema.optional(Schema.String),
  menuPath: Schema.optional(Schema.String),
  agentInfo: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1ConversationQualityMetadataAgentInfo)),
  feedbackLabels: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1FeedbackLabel)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ConversationQualityMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationQualityMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegmentWordInfo {
  /** Time offset of the start of this word relative to the beginning of the total conversation. */
  startOffset?: string;
  /** Time offset of the end of this word relative to the beginning of the total conversation. */
  endOffset?: string;
  /** The word itself. Includes punctuation marks that surround the word. */
  word?: string;
  /** A confidence estimate between 0.0 and 1.0 of the fidelity of this word. A default value of 0.0 indicates that the value is unset. */
  confidence?: number;
}

export const GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegmentWordInfo: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegmentWordInfo> = Schema.suspend(() => Schema.Struct({
  startOffset: Schema.optional(Schema.String),
  endOffset: Schema.optional(Schema.String),
  word: Schema.optional(Schema.String),
  confidence: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegmentWordInfo" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegmentWordInfo>;

export interface GoogleCloudContactcenterinsightsV1alpha1ConversationParticipant {
  /** The name of the participant provided by Dialogflow. Format: projects/{project}/locations/{location}/conversations/{conversation}/participants/{participant} */
  dialogflowParticipantName?: string;
  /** A user-specified ID representing the participant. */
  userId?: string;
  /** Deprecated. Use `dialogflow_participant_name` instead. The name of the Dialogflow participant. Format: projects/{project}/locations/{location}/conversations/{conversation}/participants/{participant} */
  dialogflowParticipant?: string;
  /** Obfuscated user ID from Dialogflow. */
  obfuscatedExternalUserId?: string;
  /** The role of the participant. */
  role?: "ROLE_UNSPECIFIED" | "HUMAN_AGENT" | "AUTOMATED_AGENT" | "END_USER" | "ANY_AGENT" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1alpha1ConversationParticipant: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationParticipant> = Schema.suspend(() => Schema.Struct({
  dialogflowParticipantName: Schema.optional(Schema.String),
  userId: Schema.optional(Schema.String),
  dialogflowParticipant: Schema.optional(Schema.String),
  obfuscatedExternalUserId: Schema.optional(Schema.String),
  role: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ConversationParticipant" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationParticipant>;

export interface GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata {
  /** Whether the transcript segment was covered under the configured smart reply allowlist in Agent Assist. */
  smartReplyAllowlistCovered?: boolean;
}

export const GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata> = Schema.suspend(() => Schema.Struct({
  smartReplyAllowlistCovered: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1SentimentData {
  /** A non-negative number from 0 to infinity which represents the absolute magnitude of sentiment regardless of score. */
  magnitude?: number;
  /** The sentiment score between -1.0 (negative) and 1.0 (positive). */
  score?: number;
}

export const GoogleCloudContactcenterinsightsV1alpha1SentimentData: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SentimentData> = Schema.suspend(() => Schema.Struct({
  magnitude: Schema.optional(Schema.Number),
  score: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1SentimentData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SentimentData>;

export interface GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegment {
  /** The time that the message occurred, if provided. */
  messageTime?: string;
  /** The text of this segment. */
  text?: string;
  /** A confidence estimate between 0.0 and 1.0 of the fidelity of this segment. A default value of 0.0 indicates that the value is unset. */
  confidence?: number;
  /** A list of the word-specific information for each word in the segment. */
  words?: Array<GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegmentWordInfo>;
  /** The language code of this segment as a [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag. Example: "en-US". */
  languageCode?: string;
  /** For conversations derived from multi-channel audio, this is the channel number corresponding to the audio from that channel. For audioChannelCount = N, its output values can range from '1' to 'N'. A channel tag of 0 indicates that the audio is mono. */
  channelTag?: number;
  /** The participant of this segment. */
  segmentParticipant?: GoogleCloudContactcenterinsightsV1alpha1ConversationParticipant;
  /** CCAI metadata relating to the current transcript segment. */
  dialogflowSegmentMetadata?: GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata;
  /** The sentiment for this transcript segment. */
  sentiment?: GoogleCloudContactcenterinsightsV1alpha1SentimentData;
}

export const GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegment: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegment> = Schema.suspend(() => Schema.Struct({
  messageTime: Schema.optional(Schema.String),
  text: Schema.optional(Schema.String),
  confidence: Schema.optional(Schema.Number),
  words: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegmentWordInfo)),
  languageCode: Schema.optional(Schema.String),
  channelTag: Schema.optional(Schema.Number),
  segmentParticipant: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1ConversationParticipant),
  dialogflowSegmentMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata),
  sentiment: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1SentimentData),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegment" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegment>;

export interface GoogleCloudContactcenterinsightsV1alpha1ConversationTranscript {
  /** A list of sequential transcript segments that comprise the conversation. */
  transcriptSegments?: Array<GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegment>;
}

export const GoogleCloudContactcenterinsightsV1alpha1ConversationTranscript: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationTranscript> = Schema.suspend(() => Schema.Struct({
  transcriptSegments: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1ConversationTranscriptTranscriptSegment)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ConversationTranscript" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationTranscript>;

export interface GoogleCloudContactcenterinsightsV1alpha1InterruptionData {
}

export const GoogleCloudContactcenterinsightsV1alpha1InterruptionData: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1InterruptionData> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1InterruptionData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1InterruptionData>;

export interface GoogleCloudContactcenterinsightsV1alpha1SilenceData {
}

export const GoogleCloudContactcenterinsightsV1alpha1SilenceData: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SilenceData> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1SilenceData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SilenceData>;

export interface GoogleCloudContactcenterinsightsV1alpha1HoldData {
}

export const GoogleCloudContactcenterinsightsV1alpha1HoldData: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1HoldData> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1HoldData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1HoldData>;

export interface GoogleCloudContactcenterinsightsV1alpha1EntityMentionData {
  /** The key of this entity in conversation entities. Can be used to retrieve the exact `Entity` this mention is attached to. */
  entityUniqueId?: string;
  /** The type of the entity mention. */
  type?: "MENTION_TYPE_UNSPECIFIED" | "PROPER" | "COMMON" | (string & {});
  /** Sentiment expressed for this mention of the entity. */
  sentiment?: GoogleCloudContactcenterinsightsV1alpha1SentimentData;
}

export const GoogleCloudContactcenterinsightsV1alpha1EntityMentionData: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1EntityMentionData> = Schema.suspend(() => Schema.Struct({
  entityUniqueId: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  sentiment: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1SentimentData),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1EntityMentionData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1EntityMentionData>;

export interface GoogleCloudContactcenterinsightsV1alpha1IntentMatchData {
  /** The id of the matched intent. Can be used to retrieve the corresponding intent information. */
  intentUniqueId?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1IntentMatchData: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IntentMatchData> = Schema.suspend(() => Schema.Struct({
  intentUniqueId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1IntentMatchData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IntentMatchData>;

export interface GoogleCloudContactcenterinsightsV1alpha1PhraseMatchData {
  /** The unique identifier (the resource name) of the phrase matcher. */
  phraseMatcher?: string;
  /** The human-readable name of the phrase matcher. */
  displayName?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1PhraseMatchData: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1PhraseMatchData> = Schema.suspend(() => Schema.Struct({
  phraseMatcher: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1PhraseMatchData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1PhraseMatchData>;

export interface GoogleCloudContactcenterinsightsV1alpha1IssueAssignment {
  /** Resource name of the assigned issue. */
  issue?: string;
  /** Score indicating the likelihood of the issue assignment. currently bounded on [0,1]. */
  score?: number;
  /** Immutable. Display name of the assigned issue. This field is set at time of analysis and immutable since then. */
  displayName?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1IssueAssignment: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IssueAssignment> = Schema.suspend(() => Schema.Struct({
  issue: Schema.optional(Schema.String),
  score: Schema.optional(Schema.Number),
  displayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1IssueAssignment" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IssueAssignment>;

export interface GoogleCloudContactcenterinsightsV1alpha1IssueMatchData {
  /** Information about the issue's assignment. */
  issueAssignment?: GoogleCloudContactcenterinsightsV1alpha1IssueAssignment;
}

export const GoogleCloudContactcenterinsightsV1alpha1IssueMatchData: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IssueMatchData> = Schema.suspend(() => Schema.Struct({
  issueAssignment: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1IssueAssignment),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1IssueMatchData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IssueMatchData>;

export interface GoogleCloudContactcenterinsightsV1alpha1AnnotationBoundary {
  /** The word index of this boundary with respect to the first word in the transcript piece. This index starts at zero. */
  wordIndex?: number;
  /** The index in the sequence of transcribed pieces of the conversation where the boundary is located. This index starts at zero. */
  transcriptIndex?: number;
}

export const GoogleCloudContactcenterinsightsV1alpha1AnnotationBoundary: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1AnnotationBoundary> = Schema.suspend(() => Schema.Struct({
  wordIndex: Schema.optional(Schema.Number),
  transcriptIndex: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1AnnotationBoundary" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1AnnotationBoundary>;

export interface GoogleCloudContactcenterinsightsV1alpha1CallAnnotation {
  /** Data specifying an interruption. */
  interruptionData?: GoogleCloudContactcenterinsightsV1alpha1InterruptionData;
  /** Data specifying sentiment. */
  sentimentData?: GoogleCloudContactcenterinsightsV1alpha1SentimentData;
  /** Data specifying silence. */
  silenceData?: GoogleCloudContactcenterinsightsV1alpha1SilenceData;
  /** Data specifying a hold. */
  holdData?: GoogleCloudContactcenterinsightsV1alpha1HoldData;
  /** Data specifying an entity mention. */
  entityMentionData?: GoogleCloudContactcenterinsightsV1alpha1EntityMentionData;
  /** Data specifying an intent match. */
  intentMatchData?: GoogleCloudContactcenterinsightsV1alpha1IntentMatchData;
  /** Data specifying a phrase match. */
  phraseMatchData?: GoogleCloudContactcenterinsightsV1alpha1PhraseMatchData;
  /** Data specifying an issue match. */
  issueMatchData?: GoogleCloudContactcenterinsightsV1alpha1IssueMatchData;
  /** The channel of the audio where the annotation occurs. For single-channel audio, this field is not populated. */
  channelTag?: number;
  /** The boundary in the conversation where the annotation starts, inclusive. */
  annotationStartBoundary?: GoogleCloudContactcenterinsightsV1alpha1AnnotationBoundary;
  /** The boundary in the conversation where the annotation ends, inclusive. */
  annotationEndBoundary?: GoogleCloudContactcenterinsightsV1alpha1AnnotationBoundary;
}

export const GoogleCloudContactcenterinsightsV1alpha1CallAnnotation: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1CallAnnotation> = Schema.suspend(() => Schema.Struct({
  interruptionData: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1InterruptionData),
  sentimentData: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1SentimentData),
  silenceData: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1SilenceData),
  holdData: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1HoldData),
  entityMentionData: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1EntityMentionData),
  intentMatchData: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1IntentMatchData),
  phraseMatchData: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1PhraseMatchData),
  issueMatchData: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1IssueMatchData),
  channelTag: Schema.optional(Schema.Number),
  annotationStartBoundary: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1AnnotationBoundary),
  annotationEndBoundary: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1AnnotationBoundary),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1CallAnnotation" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1CallAnnotation>;

export interface GoogleCloudContactcenterinsightsV1alpha1Entity {
  /** The representative name for the entity. */
  displayName?: string;
  /** The entity type. */
  type?: "TYPE_UNSPECIFIED" | "PERSON" | "LOCATION" | "ORGANIZATION" | "EVENT" | "WORK_OF_ART" | "CONSUMER_GOOD" | "OTHER" | "PHONE_NUMBER" | "ADDRESS" | "DATE" | "NUMBER" | "PRICE" | (string & {});
  /** Metadata associated with the entity. For most entity types, the metadata is a Wikipedia URL (`wikipedia_url`) and Knowledge Graph MID (`mid`), if they are available. For the metadata associated with other entity types, see the Type table below. */
  metadata?: Record<string, string>;
  /** The salience score associated with the entity in the [0, 1.0] range. The salience score for an entity provides information about the importance or centrality of that entity to the entire document text. Scores closer to 0 are less salient, while scores closer to 1.0 are highly salient. */
  salience?: number;
  /** The aggregate sentiment expressed for this entity in the conversation. */
  sentiment?: GoogleCloudContactcenterinsightsV1alpha1SentimentData;
}

export const GoogleCloudContactcenterinsightsV1alpha1Entity: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1Entity> = Schema.suspend(() => Schema.Struct({
  displayName: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  salience: Schema.optional(Schema.Number),
  sentiment: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1SentimentData),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1Entity" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1Entity>;

export interface GoogleCloudContactcenterinsightsV1alpha1ConversationLevelSentiment {
  /** The channel of the audio that the data applies to. */
  channelTag?: number;
  /** Data specifying sentiment. */
  sentimentData?: GoogleCloudContactcenterinsightsV1alpha1SentimentData;
}

export const GoogleCloudContactcenterinsightsV1alpha1ConversationLevelSentiment: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationLevelSentiment> = Schema.suspend(() => Schema.Struct({
  channelTag: Schema.optional(Schema.Number),
  sentimentData: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1SentimentData),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ConversationLevelSentiment" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationLevelSentiment>;

export interface GoogleCloudContactcenterinsightsV1alpha1ConversationLevelSilence {
  /** Amount of time calculated to be in silence. */
  silenceDuration?: string;
  /** Percentage of the total conversation spent in silence. */
  silencePercentage?: number;
}

export const GoogleCloudContactcenterinsightsV1alpha1ConversationLevelSilence: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationLevelSilence> = Schema.suspend(() => Schema.Struct({
  silenceDuration: Schema.optional(Schema.String),
  silencePercentage: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ConversationLevelSilence" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationLevelSilence>;

export interface GoogleCloudContactcenterinsightsV1alpha1Intent {
  /** The unique identifier of the intent. */
  id?: string;
  /** The human-readable name of the intent. */
  displayName?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1Intent: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1Intent> = Schema.suspend(() => Schema.Struct({
  id: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1Intent" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1Intent>;

export interface GoogleCloudContactcenterinsightsV1alpha1IssueModelResult {
  /** Issue model that generates the result. Format: projects/{project}/locations/{location}/issueModels/{issue_model} */
  issueModel?: string;
  /** All the matched issues. */
  issues?: Array<GoogleCloudContactcenterinsightsV1alpha1IssueAssignment>;
}

export const GoogleCloudContactcenterinsightsV1alpha1IssueModelResult: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IssueModelResult> = Schema.suspend(() => Schema.Struct({
  issueModel: Schema.optional(Schema.String),
  issues: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1IssueAssignment)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1IssueModelResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1IssueModelResult>;

export interface GoogleCloudContactcenterinsightsV1alpha1QaAnswerAnswerSource {
  /** What created the answer. */
  sourceType?: "SOURCE_TYPE_UNSPECIFIED" | "SYSTEM_GENERATED" | "MANUAL_EDIT" | (string & {});
  /** The answer value from this source. This field is populated by default, unless the question has a selection strategy configured to return multiple answer values, in which case `answer_values` will be populated instead. */
  answerValue?: GoogleCloudContactcenterinsightsV1alpha1QaAnswerAnswerValue;
}

export const GoogleCloudContactcenterinsightsV1alpha1QaAnswerAnswerSource: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QaAnswerAnswerSource> = Schema.suspend(() => Schema.Struct({
  sourceType: Schema.optional(Schema.String),
  answerValue: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1QaAnswerAnswerValue),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1QaAnswerAnswerSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QaAnswerAnswerSource>;

export interface GoogleCloudContactcenterinsightsV1alpha1QaAnswer {
  /** The QaQuestion answered by this answer. */
  qaQuestion?: string;
  /** The conversation the answer applies to. */
  conversation?: string;
  /** Question text. E.g., "Did the agent greet the customer?" */
  questionBody?: string;
  /** The answer value from this source. This field is populated by default, unless the question has a selection strategy configured to return multiple answer values, in which case `answer_values` will be populated instead. */
  answerValue?: GoogleCloudContactcenterinsightsV1alpha1QaAnswerAnswerValue;
  /** User-defined list of arbitrary tags. Matches the value from QaScorecard.ScorecardQuestion.tags. Used for grouping/organization and for weighting the score of each answer. */
  tags?: Array<string>;
  /** Lists all answer sources containing one or more answer values of a specific source type, e.g., all system-generated answer sources, or all manual edit answer sources. */
  answerSources?: Array<GoogleCloudContactcenterinsightsV1alpha1QaAnswerAnswerSource>;
}

export const GoogleCloudContactcenterinsightsV1alpha1QaAnswer: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QaAnswer> = Schema.suspend(() => Schema.Struct({
  qaQuestion: Schema.optional(Schema.String),
  conversation: Schema.optional(Schema.String),
  questionBody: Schema.optional(Schema.String),
  answerValue: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1QaAnswerAnswerValue),
  tags: Schema.optional(Schema.Array(Schema.String)),
  answerSources: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1QaAnswerAnswerSource)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1QaAnswer" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QaAnswer>;

export interface GoogleCloudContactcenterinsightsV1alpha1QaScorecardResultQaTagResult {
  /** The tag the score applies to. */
  tag?: string;
  /** The score the tag applies to. */
  score?: number;
  /** The potential score the tag applies to. */
  potentialScore?: number;
  /** The normalized score the tag applies to. */
  normalizedScore?: number;
}

export const GoogleCloudContactcenterinsightsV1alpha1QaScorecardResultQaTagResult: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QaScorecardResultQaTagResult> = Schema.suspend(() => Schema.Struct({
  tag: Schema.optional(Schema.String),
  score: Schema.optional(Schema.Number),
  potentialScore: Schema.optional(Schema.Number),
  normalizedScore: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1QaScorecardResultQaTagResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QaScorecardResultQaTagResult>;

export interface GoogleCloudContactcenterinsightsV1alpha1QaScorecardResultScoreSource {
  /** What created the score. */
  sourceType?: "SOURCE_TYPE_UNSPECIFIED" | "SYSTEM_GENERATED_ONLY" | "INCLUDES_MANUAL_EDITS" | (string & {});
  /** The overall numerical score of the result. */
  score?: number;
  /** The maximum potential overall score of the scorecard. Any questions answered using `na_value` are excluded from this calculation. */
  potentialScore?: number;
  /** The normalized score, which is the score divided by the potential score. */
  normalizedScore?: number;
  /** Collection of tags and their scores. */
  qaTagResults?: Array<GoogleCloudContactcenterinsightsV1alpha1QaScorecardResultQaTagResult>;
}

export const GoogleCloudContactcenterinsightsV1alpha1QaScorecardResultScoreSource: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QaScorecardResultScoreSource> = Schema.suspend(() => Schema.Struct({
  sourceType: Schema.optional(Schema.String),
  score: Schema.optional(Schema.Number),
  potentialScore: Schema.optional(Schema.Number),
  normalizedScore: Schema.optional(Schema.Number),
  qaTagResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1QaScorecardResultQaTagResult)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1QaScorecardResultScoreSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QaScorecardResultScoreSource>;

export interface GoogleCloudContactcenterinsightsV1alpha1QaScorecardResult {
  /** Identifier. The name of the scorecard result. Format: projects/{project}/locations/{location}/qaScorecardResults/{qa_scorecard_result} */
  name?: string;
  /** The QaScorecardRevision scored by this result. */
  qaScorecardRevision?: string;
  /** The conversation scored by this result. */
  conversation?: string;
  /** Output only. The timestamp that the revision was created. */
  createTime?: string;
  /** ID of the agent that handled the conversation. */
  agentId?: string;
  /** Set of QaAnswers represented in the result. */
  qaAnswers?: Array<GoogleCloudContactcenterinsightsV1alpha1QaAnswer>;
  /** The overall numerical score of the result, incorporating any manual edits if they exist. */
  score?: number;
  /** The maximum potential overall score of the scorecard. Any questions answered using `na_value` are excluded from this calculation. */
  potentialScore?: number;
  /** The normalized score, which is the score divided by the potential score. Any manual edits are included if they exist. */
  normalizedScore?: number;
  /** Collection of tags and their scores. */
  qaTagResults?: Array<GoogleCloudContactcenterinsightsV1alpha1QaScorecardResultQaTagResult>;
  /** List of all individual score sets. */
  scoreSources?: Array<GoogleCloudContactcenterinsightsV1alpha1QaScorecardResultScoreSource>;
}

export const GoogleCloudContactcenterinsightsV1alpha1QaScorecardResult: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QaScorecardResult> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  qaScorecardRevision: Schema.optional(Schema.String),
  conversation: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  agentId: Schema.optional(Schema.String),
  qaAnswers: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1QaAnswer)),
  score: Schema.optional(Schema.Number),
  potentialScore: Schema.optional(Schema.Number),
  normalizedScore: Schema.optional(Schema.Number),
  qaTagResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1QaScorecardResultQaTagResult)),
  scoreSources: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1QaScorecardResultScoreSource)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1QaScorecardResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1QaScorecardResult>;

export interface GoogleCloudContactcenterinsightsV1alpha1AnalysisResultCallAnalysisMetadata {
  /** A list of call annotations that apply to this call. */
  annotations?: Array<GoogleCloudContactcenterinsightsV1alpha1CallAnnotation>;
  /** All the entities in the call. */
  entities?: Record<string, GoogleCloudContactcenterinsightsV1alpha1Entity>;
  /** Overall conversation-level sentiment for each channel of the call. */
  sentiments?: Array<GoogleCloudContactcenterinsightsV1alpha1ConversationLevelSentiment>;
  /** Overall conversation-level silence during the call. */
  silence?: GoogleCloudContactcenterinsightsV1alpha1ConversationLevelSilence;
  /** All the matched intents in the call. */
  intents?: Record<string, GoogleCloudContactcenterinsightsV1alpha1Intent>;
  /** All the matched phrase matchers in the call. */
  phraseMatchers?: Record<string, GoogleCloudContactcenterinsightsV1alpha1PhraseMatchData>;
  /** Overall conversation-level issue modeling result. */
  issueModelResult?: GoogleCloudContactcenterinsightsV1alpha1IssueModelResult;
  /** Results of scoring QaScorecards. */
  qaScorecardResults?: Array<GoogleCloudContactcenterinsightsV1alpha1QaScorecardResult>;
}

export const GoogleCloudContactcenterinsightsV1alpha1AnalysisResultCallAnalysisMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1AnalysisResultCallAnalysisMetadata> = Schema.suspend(() => Schema.Struct({
  annotations: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1CallAnnotation)),
  entities: Schema.optional(Schema.Record(Schema.String, GoogleCloudContactcenterinsightsV1alpha1Entity)),
  sentiments: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1ConversationLevelSentiment)),
  silence: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1ConversationLevelSilence),
  intents: Schema.optional(Schema.Record(Schema.String, GoogleCloudContactcenterinsightsV1alpha1Intent)),
  phraseMatchers: Schema.optional(Schema.Record(Schema.String, GoogleCloudContactcenterinsightsV1alpha1PhraseMatchData)),
  issueModelResult: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1IssueModelResult),
  qaScorecardResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1QaScorecardResult)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1AnalysisResultCallAnalysisMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1AnalysisResultCallAnalysisMetadata>;

export interface GoogleCloudContactcenterinsightsV1alpha1AnalysisResult {
  /** Call-specific metadata created by the analysis. */
  callAnalysisMetadata?: GoogleCloudContactcenterinsightsV1alpha1AnalysisResultCallAnalysisMetadata;
  /** The time at which the analysis ended. */
  endTime?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1AnalysisResult: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1AnalysisResult> = Schema.suspend(() => Schema.Struct({
  callAnalysisMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1AnalysisResultCallAnalysisMetadata),
  endTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1AnalysisResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1AnalysisResult>;

export interface GoogleCloudContactcenterinsightsV1alpha1Analysis {
  /** Immutable. The resource name of the analysis. Format: projects/{project}/locations/{location}/conversations/{conversation}/analyses/{analysis} */
  name?: string;
  /** Output only. The time at which the analysis was requested. */
  requestTime?: string;
  /** Output only. The time at which the analysis was created, which occurs when the long-running operation completes. */
  createTime?: string;
  /** Output only. The result of the analysis, which is populated when the analysis finishes. */
  analysisResult?: GoogleCloudContactcenterinsightsV1alpha1AnalysisResult;
  /** To select the annotators to run and the phrase matchers to use (if any). If not specified, all annotators will be run. */
  annotatorSelector?: GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelector;
}

export const GoogleCloudContactcenterinsightsV1alpha1Analysis: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1Analysis> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  requestTime: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  analysisResult: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1AnalysisResult),
  annotatorSelector: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1AnnotatorSelector),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1Analysis" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1Analysis>;

export interface GoogleCloudContactcenterinsightsV1alpha1ConversationSummarizationSuggestionData {
  /** The summarization content that is concatenated into one string. */
  text?: string;
  /** The summarization content that is divided into sections. The key is the section's name and the value is the section's content. There is no specific format for the key or value. */
  textSections?: Record<string, string>;
  /** The confidence score of the summarization. */
  confidence?: number;
  /** A map that contains metadata about the summarization and the document from which it originates. */
  metadata?: Record<string, string>;
  /** The name of the answer record. Format: projects/{project}/locations/{location}/answerRecords/{answer_record} */
  answerRecord?: string;
  /** The name of the model that generates this summary. Format: projects/{project}/locations/{location}/conversationModels/{conversation_model} */
  conversationModel?: string;
  /** Agent Assist generator ID. */
  generatorId?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1ConversationSummarizationSuggestionData: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationSummarizationSuggestionData> = Schema.suspend(() => Schema.Struct({
  text: Schema.optional(Schema.String),
  textSections: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  confidence: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  answerRecord: Schema.optional(Schema.String),
  conversationModel: Schema.optional(Schema.String),
  generatorId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ConversationSummarizationSuggestionData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationSummarizationSuggestionData>;

export interface GoogleCloudContactcenterinsightsV1alpha1ArticleSuggestionData {
  /** Article title. */
  title?: string;
  /** Article URI. */
  uri?: string;
  /** The system's confidence score that this article is a good match for this conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely certain). */
  confidenceScore?: number;
  /** Map that contains metadata about the Article Suggestion and the document that it originates from. */
  metadata?: Record<string, string>;
  /** The name of the answer record. Format: projects/{project}/locations/{location}/answerRecords/{answer_record} */
  queryRecord?: string;
  /** The knowledge document that this answer was extracted from. Format: projects/{project}/knowledgeBases/{knowledge_base}/documents/{document} */
  source?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1ArticleSuggestionData: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ArticleSuggestionData> = Schema.suspend(() => Schema.Struct({
  title: Schema.optional(Schema.String),
  uri: Schema.optional(Schema.String),
  confidenceScore: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  queryRecord: Schema.optional(Schema.String),
  source: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ArticleSuggestionData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ArticleSuggestionData>;

export interface GoogleCloudContactcenterinsightsV1alpha1FaqAnswerData {
  /** The piece of text from the `source` knowledge base document. */
  answer?: string;
  /** The system's confidence score that this answer is a good match for this conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely certain). */
  confidenceScore?: number;
  /** The corresponding FAQ question. */
  question?: string;
  /** Map that contains metadata about the FAQ answer and the document that it originates from. */
  metadata?: Record<string, string>;
  /** The name of the answer record. Format: projects/{project}/locations/{location}/answerRecords/{answer_record} */
  queryRecord?: string;
  /** The knowledge document that this answer was extracted from. Format: projects/{project}/knowledgeBases/{knowledge_base}/documents/{document}. */
  source?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1FaqAnswerData: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1FaqAnswerData> = Schema.suspend(() => Schema.Struct({
  answer: Schema.optional(Schema.String),
  confidenceScore: Schema.optional(Schema.Number),
  question: Schema.optional(Schema.String),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  queryRecord: Schema.optional(Schema.String),
  source: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1FaqAnswerData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1FaqAnswerData>;

export interface GoogleCloudContactcenterinsightsV1alpha1SmartReplyData {
  /** The content of the reply. */
  reply?: string;
  /** The system's confidence score that this reply is a good match for this conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely certain). */
  confidenceScore?: number;
  /** Map that contains metadata about the Smart Reply and the document from which it originates. */
  metadata?: Record<string, string>;
  /** The name of the answer record. Format: projects/{project}/locations/{location}/answerRecords/{answer_record} */
  queryRecord?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1SmartReplyData: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SmartReplyData> = Schema.suspend(() => Schema.Struct({
  reply: Schema.optional(Schema.String),
  confidenceScore: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  queryRecord: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1SmartReplyData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SmartReplyData>;

export interface GoogleCloudContactcenterinsightsV1alpha1SmartComposeSuggestionData {
  /** The content of the suggestion. */
  suggestion?: string;
  /** The system's confidence score that this suggestion is a good match for this conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely certain). */
  confidenceScore?: number;
  /** Map that contains metadata about the Smart Compose suggestion and the document from which it originates. */
  metadata?: Record<string, string>;
  /** The name of the answer record. Format: projects/{project}/locations/{location}/answerRecords/{answer_record} */
  queryRecord?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1SmartComposeSuggestionData: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SmartComposeSuggestionData> = Schema.suspend(() => Schema.Struct({
  suggestion: Schema.optional(Schema.String),
  confidenceScore: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  queryRecord: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1SmartComposeSuggestionData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1SmartComposeSuggestionData>;

export interface GoogleCloudContactcenterinsightsV1alpha1DialogflowInteractionData {
  /** The Dialogflow intent resource path. Format: projects/{project}/agent/{agent}/intents/{intent} */
  dialogflowIntentId?: string;
  /** The confidence of the match ranging from 0.0 (completely uncertain) to 1.0 (completely certain). */
  confidence?: number;
}

export const GoogleCloudContactcenterinsightsV1alpha1DialogflowInteractionData: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DialogflowInteractionData> = Schema.suspend(() => Schema.Struct({
  dialogflowIntentId: Schema.optional(Schema.String),
  confidence: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DialogflowInteractionData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DialogflowInteractionData>;

export interface GoogleCloudContactcenterinsightsV1alpha1AnswerFeedback {
  /** The correctness level of an answer. */
  correctnessLevel?: "CORRECTNESS_LEVEL_UNSPECIFIED" | "NOT_CORRECT" | "PARTIALLY_CORRECT" | "FULLY_CORRECT" | (string & {});
  /** Indicates whether an answer or item was clicked by the human agent. */
  clicked?: boolean;
  /** Indicates whether an answer or item was displayed to the human agent in the agent desktop UI. */
  displayed?: boolean;
}

export const GoogleCloudContactcenterinsightsV1alpha1AnswerFeedback: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1AnswerFeedback> = Schema.suspend(() => Schema.Struct({
  correctnessLevel: Schema.optional(Schema.String),
  clicked: Schema.optional(Schema.Boolean),
  displayed: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1AnswerFeedback" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1AnswerFeedback>;

export interface GoogleCloudContactcenterinsightsV1alpha1RuntimeAnnotationUserInput {
  /** Query text. Article Search uses this to store the input query used to generate the search results. */
  query?: string;
  /** The resource name of associated generator. Format: `projects//locations//generators/` */
  generatorName?: string;
  /** Query source for the answer. */
  querySource?: "QUERY_SOURCE_UNSPECIFIED" | "AGENT_QUERY" | "SUGGESTED_QUERY" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1alpha1RuntimeAnnotationUserInput: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1RuntimeAnnotationUserInput> = Schema.suspend(() => Schema.Struct({
  query: Schema.optional(Schema.String),
  generatorName: Schema.optional(Schema.String),
  querySource: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1RuntimeAnnotationUserInput" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1RuntimeAnnotationUserInput>;

export interface GoogleCloudContactcenterinsightsV1alpha1RuntimeAnnotation {
  /** Agent Assist Article Suggestion data. */
  articleSuggestion?: GoogleCloudContactcenterinsightsV1alpha1ArticleSuggestionData;
  /** Agent Assist FAQ answer data. */
  faqAnswer?: GoogleCloudContactcenterinsightsV1alpha1FaqAnswerData;
  /** Agent Assist Smart Reply data. */
  smartReply?: GoogleCloudContactcenterinsightsV1alpha1SmartReplyData;
  /** Agent Assist Smart Compose suggestion data. */
  smartComposeSuggestion?: GoogleCloudContactcenterinsightsV1alpha1SmartComposeSuggestionData;
  /** Dialogflow interaction data. */
  dialogflowInteraction?: GoogleCloudContactcenterinsightsV1alpha1DialogflowInteractionData;
  /** Conversation summarization suggestion data. */
  conversationSummarizationSuggestion?: GoogleCloudContactcenterinsightsV1alpha1ConversationSummarizationSuggestionData;
  /** The unique identifier of the annotation. Format: projects/{project}/locations/{location}/conversationDatasets/{dataset}/conversationDataItems/{data_item}/conversationAnnotations/{annotation} */
  annotationId?: string;
  /** The time at which this annotation was created. */
  createTime?: string;
  /** The boundary in the conversation where the annotation starts, inclusive. */
  startBoundary?: GoogleCloudContactcenterinsightsV1alpha1AnnotationBoundary;
  /** The boundary in the conversation where the annotation ends, inclusive. */
  endBoundary?: GoogleCloudContactcenterinsightsV1alpha1AnnotationBoundary;
  /** The feedback that the customer has about the answer in `data`. */
  answerFeedback?: GoogleCloudContactcenterinsightsV1alpha1AnswerFeedback;
  /** Explicit input used for generating the answer */
  userInput?: GoogleCloudContactcenterinsightsV1alpha1RuntimeAnnotationUserInput;
}

export const GoogleCloudContactcenterinsightsV1alpha1RuntimeAnnotation: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1RuntimeAnnotation> = Schema.suspend(() => Schema.Struct({
  articleSuggestion: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1ArticleSuggestionData),
  faqAnswer: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1FaqAnswerData),
  smartReply: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1SmartReplyData),
  smartComposeSuggestion: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1SmartComposeSuggestionData),
  dialogflowInteraction: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1DialogflowInteractionData),
  conversationSummarizationSuggestion: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1ConversationSummarizationSuggestionData),
  annotationId: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  startBoundary: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1AnnotationBoundary),
  endBoundary: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1AnnotationBoundary),
  answerFeedback: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1AnswerFeedback),
  userInput: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1RuntimeAnnotationUserInput),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1RuntimeAnnotation" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1RuntimeAnnotation>;

export interface GoogleCloudContactcenterinsightsV1alpha1DialogflowIntent {
  /** The human-readable name of the intent. */
  displayName?: string;
}

export const GoogleCloudContactcenterinsightsV1alpha1DialogflowIntent: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DialogflowIntent> = Schema.suspend(() => Schema.Struct({
  displayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1DialogflowIntent" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1DialogflowIntent>;

export interface GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationInfo {
  /** Output only. The full conversation correlation id this conversation is a segment of. */
  fullConversationCorrelationId?: string;
  /** Output only. The full conversation correlation id this conversation is a merged conversation of. */
  mergedFullConversationCorrelationId?: string;
  /** Output only. The correlation types of this conversation. A single conversation can have multiple correlation types. For example a conversation that only has a single segment is both a SEGMENT and a FULL_CONVERSATION. */
  correlationTypes?: Array<"CORRELATION_TYPE_UNSPECIFIED" | "SEGMENT" | "PARTIAL" | "FULL" | "SYNTHETIC" | (string & {})>;
}

export const GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationInfo: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationInfo> = Schema.suspend(() => Schema.Struct({
  fullConversationCorrelationId: Schema.optional(Schema.String),
  mergedFullConversationCorrelationId: Schema.optional(Schema.String),
  correlationTypes: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationInfo" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationInfo>;

export interface GoogleCloudContactcenterinsightsV1alpha1Conversation {
  /** Call-specific metadata. */
  callMetadata?: GoogleCloudContactcenterinsightsV1alpha1ConversationCallMetadata;
  /** The time at which this conversation should expire. After this time, the conversation data and any associated analyses will be deleted. */
  expireTime?: string;
  /** Input only. The TTL for this resource. If specified, then this TTL will be used to calculate the expire time. */
  ttl?: string;
  /** Immutable. The resource name of the conversation. Format: projects/{project}/locations/{location}/conversations/{conversation} */
  name?: string;
  /** The source of the audio and transcription for the conversation. */
  dataSource?: GoogleCloudContactcenterinsightsV1alpha1ConversationDataSource;
  /** Output only. The time at which the conversation was created. */
  createTime?: string;
  /** Output only. The most recent time at which the conversation was updated. */
  updateTime?: string;
  /** The time at which the conversation started. */
  startTime?: string;
  /** A user-specified language code for the conversation. */
  languageCode?: string;
  /** An opaque, user-specified string representing the human agent who handled the conversation. */
  agentId?: string;
  /** A map for the user to specify any custom fields. A maximum of 100 labels per conversation is allowed, with a maximum of 256 characters per entry. */
  labels?: Record<string, string>;
  /** Conversation metadata related to quality management. */
  qualityMetadata?: GoogleCloudContactcenterinsightsV1alpha1ConversationQualityMetadata;
  /** Input only. JSON metadata encoded as a string. This field is primarily used by Insights integrations with various telephony systems and must be in one of Insight's supported formats. */
  metadataJson?: string;
  /** Output only. The conversation transcript. */
  transcript?: GoogleCloudContactcenterinsightsV1alpha1ConversationTranscript;
  /** Immutable. The conversation medium. */
  medium?: "MEDIUM_UNSPECIFIED" | "PHONE_CALL" | "CHAT" | (string & {});
  /** Output only. The duration of the conversation. */
  duration?: string;
  /** Output only. The number of turns in the conversation. */
  turnCount?: number;
  /** Output only. The conversation's latest analysis, if one exists. */
  latestAnalysis?: GoogleCloudContactcenterinsightsV1alpha1Analysis;
  /** Output only. Latest summary of the conversation. */
  latestSummary?: GoogleCloudContactcenterinsightsV1alpha1ConversationSummarizationSuggestionData;
  /** Output only. The annotations that were generated during the customer and agent interaction. */
  runtimeAnnotations?: Array<GoogleCloudContactcenterinsightsV1alpha1RuntimeAnnotation>;
  /** Output only. All the matched Dialogflow intents in the call. The key corresponds to a Dialogflow intent, format: projects/{project}/agent/{agent}/intents/{intent} */
  dialogflowIntents?: Record<string, GoogleCloudContactcenterinsightsV1alpha1DialogflowIntent>;
  /** Obfuscated user ID which the customer sent to us. */
  obfuscatedUserId?: string;
  /** Output only. Info for correlating across conversations. */
  correlationInfo?: GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationInfo;
}

export const GoogleCloudContactcenterinsightsV1alpha1Conversation: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1Conversation> = Schema.suspend(() => Schema.Struct({
  callMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1ConversationCallMetadata),
  expireTime: Schema.optional(Schema.String),
  ttl: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  dataSource: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1ConversationDataSource),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  startTime: Schema.optional(Schema.String),
  languageCode: Schema.optional(Schema.String),
  agentId: Schema.optional(Schema.String),
  labels: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  qualityMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1ConversationQualityMetadata),
  metadataJson: Schema.optional(Schema.String),
  transcript: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1ConversationTranscript),
  medium: Schema.optional(Schema.String),
  duration: Schema.optional(Schema.String),
  turnCount: Schema.optional(Schema.Number),
  latestAnalysis: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1Analysis),
  latestSummary: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1ConversationSummarizationSuggestionData),
  runtimeAnnotations: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1alpha1RuntimeAnnotation)),
  dialogflowIntents: Schema.optional(Schema.Record(Schema.String, GoogleCloudContactcenterinsightsV1alpha1DialogflowIntent)),
  obfuscatedUserId: Schema.optional(Schema.String),
  correlationInfo: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1ConversationCorrelationInfo),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1Conversation" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1Conversation>;

export interface GoogleCloudContactcenterinsightsV1alpha1UploadConversationRequest {
  /** Required. The parent resource of the conversation. */
  parent?: string;
  /** Required. The conversation resource to create. */
  conversation?: GoogleCloudContactcenterinsightsV1alpha1Conversation;
  /** Optional. A unique ID for the new conversation. This ID will become the final component of the conversation's resource name. If no ID is specified, a server-generated ID will be used. This value should be 4-64 characters and must match the regular expression `^[a-z0-9-]{4,64}$`. Valid characters are `a-z-` */
  conversationId?: string;
  /** Optional. DLP settings for transcript redaction. Will default to the config specified in Settings. */
  redactionConfig?: GoogleCloudContactcenterinsightsV1alpha1RedactionConfig;
  /** Optional. Speech-to-Text configuration. Will default to the config specified in Settings. */
  speechConfig?: GoogleCloudContactcenterinsightsV1alpha1SpeechConfig;
}

export const GoogleCloudContactcenterinsightsV1alpha1UploadConversationRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1UploadConversationRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  conversation: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1Conversation),
  conversationId: Schema.optional(Schema.String),
  redactionConfig: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1RedactionConfig),
  speechConfig: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1SpeechConfig),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1UploadConversationRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1UploadConversationRequest>;

export interface GoogleCloudContactcenterinsightsV1alpha1UploadConversationMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request. */
  request?: GoogleCloudContactcenterinsightsV1alpha1UploadConversationRequest;
  /** Output only. The operation name for a successfully created analysis operation, if any. */
  analysisOperation?: string;
  /** Output only. The redaction config applied to the uploaded conversation. */
  appliedRedactionConfig?: GoogleCloudContactcenterinsightsV1alpha1RedactionConfig;
}

export const GoogleCloudContactcenterinsightsV1alpha1UploadConversationMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1UploadConversationMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1UploadConversationRequest),
  analysisOperation: Schema.optional(Schema.String),
  appliedRedactionConfig: Schema.optional(GoogleCloudContactcenterinsightsV1alpha1RedactionConfig),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1alpha1UploadConversationMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1alpha1UploadConversationMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorSummarizationConfig {
  /** Resource name of the Dialogflow conversation profile. Format: projects/{project}/locations/{location}/conversationProfiles/{conversation_profile} */
  conversationProfile?: string;
  /** Default summarization model to be used. */
  summarizationModel?: "SUMMARIZATION_MODEL_UNSPECIFIED" | "BASELINE_MODEL" | "BASELINE_MODEL_V2_0" | (string & {});
  /** The resource name of the existing created generator. Format: projects//locations//generators/ */
  generator?: string;
}

export const GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorSummarizationConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorSummarizationConfig> = Schema.suspend(() => Schema.Struct({
  conversationProfile: Schema.optional(Schema.String),
  summarizationModel: Schema.optional(Schema.String),
  generator: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorSummarizationConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorSummarizationConfig>;

export interface GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorQaConfigScorecardList {
  /** List of QaScorecardRevisions. */
  qaScorecardRevisions?: Array<string>;
}

export const GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorQaConfigScorecardList: Schema.Schema<GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorQaConfigScorecardList> = Schema.suspend(() => Schema.Struct({
  qaScorecardRevisions: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorQaConfigScorecardList" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorQaConfigScorecardList>;

export interface GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorQaConfig {
  /** A manual list of scorecards to score. */
  scorecardList?: GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorQaConfigScorecardList;
}

export const GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorQaConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorQaConfig> = Schema.suspend(() => Schema.Struct({
  scorecardList: Schema.optional(GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorQaConfigScorecardList),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorQaConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorQaConfig>;

export interface GoogleCloudContactcenterinsightsV1mainAnnotatorSelector {
  /** Whether to run the interruption annotator. */
  runInterruptionAnnotator?: boolean;
  /** Whether to run the silence annotator. */
  runSilenceAnnotator?: boolean;
  /** Whether to run the active phrase matcher annotator(s). */
  runPhraseMatcherAnnotator?: boolean;
  /** The list of phrase matchers to run. If not provided, all active phrase matchers will be used. If inactive phrase matchers are provided, they will not be used. Phrase matchers will be run only if run_phrase_matcher_annotator is set to true. Format: projects/{project}/locations/{location}/phraseMatchers/{phrase_matcher} */
  phraseMatchers?: Array<string>;
  /** Whether to run the sentiment annotator. */
  runSentimentAnnotator?: boolean;
  /** Whether to run the entity annotator. */
  runEntityAnnotator?: boolean;
  /** Whether to run the intent annotator. */
  runIntentAnnotator?: boolean;
  /** Whether to run the issue model annotator. A model should have already been deployed for this to take effect. */
  runIssueModelAnnotator?: boolean;
  /** The issue model to run. If not provided, the most recently deployed topic model will be used. The provided issue model will only be used for inference if the issue model is deployed and if run_issue_model_annotator is set to true. If more than one issue model is provided, only the first provided issue model will be used for inference. */
  issueModels?: Array<string>;
  /** Whether to run the summarization annotator. */
  runSummarizationAnnotator?: boolean;
  /** Configuration for the summarization annotator. */
  summarizationConfig?: GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorSummarizationConfig;
  /** Whether to run the QA annotator. */
  runQaAnnotator?: boolean;
  /** Configuration for the QA annotator. */
  qaConfig?: GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorQaConfig;
}

export const GoogleCloudContactcenterinsightsV1mainAnnotatorSelector: Schema.Schema<GoogleCloudContactcenterinsightsV1mainAnnotatorSelector> = Schema.suspend(() => Schema.Struct({
  runInterruptionAnnotator: Schema.optional(Schema.Boolean),
  runSilenceAnnotator: Schema.optional(Schema.Boolean),
  runPhraseMatcherAnnotator: Schema.optional(Schema.Boolean),
  phraseMatchers: Schema.optional(Schema.Array(Schema.String)),
  runSentimentAnnotator: Schema.optional(Schema.Boolean),
  runEntityAnnotator: Schema.optional(Schema.Boolean),
  runIntentAnnotator: Schema.optional(Schema.Boolean),
  runIssueModelAnnotator: Schema.optional(Schema.Boolean),
  issueModels: Schema.optional(Schema.Array(Schema.String)),
  runSummarizationAnnotator: Schema.optional(Schema.Boolean),
  summarizationConfig: Schema.optional(GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorSummarizationConfig),
  runQaAnnotator: Schema.optional(Schema.Boolean),
  qaConfig: Schema.optional(GoogleCloudContactcenterinsightsV1mainAnnotatorSelectorQaConfig),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainAnnotatorSelector" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainAnnotatorSelector>;

export interface GoogleCloudContactcenterinsightsV1mainBulkAnalyzeConversationsRequest {
  /** Required. The parent resource to create analyses in. */
  parent?: string;
  /** Required. Filter used to select the subset of conversations to analyze. */
  filter?: string;
  /** Required. Percentage of selected conversation to analyze, between [0, 100]. */
  analysisPercentage?: number;
  /** To select the annotators to run and the phrase matchers to use (if any). If not specified, all annotators will be run. */
  annotatorSelector?: GoogleCloudContactcenterinsightsV1mainAnnotatorSelector;
}

export const GoogleCloudContactcenterinsightsV1mainBulkAnalyzeConversationsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkAnalyzeConversationsRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
  analysisPercentage: Schema.optional(Schema.Number),
  annotatorSelector: Schema.optional(GoogleCloudContactcenterinsightsV1mainAnnotatorSelector),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainBulkAnalyzeConversationsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkAnalyzeConversationsRequest>;

export interface GoogleCloudContactcenterinsightsV1mainBulkAnalyzeConversationsMetadata {
  /** The time the operation was created. */
  createTime?: string;
  /** The time the operation finished running. */
  endTime?: string;
  /** The original request for bulk analyze. */
  request?: GoogleCloudContactcenterinsightsV1mainBulkAnalyzeConversationsRequest;
  /** The number of requested analyses that have completed successfully so far. */
  completedAnalysesCount?: number;
  /** The number of requested analyses that have failed so far. */
  failedAnalysesCount?: number;
  /** Total number of analyses requested. Computed by the number of conversations returned by `filter` multiplied by `analysis_percentage` in the request. */
  totalRequestedAnalysesCount?: number;
  /** Output only. Partial errors during bulk analyze operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
}

export const GoogleCloudContactcenterinsightsV1mainBulkAnalyzeConversationsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkAnalyzeConversationsMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1mainBulkAnalyzeConversationsRequest),
  completedAnalysesCount: Schema.optional(Schema.Number),
  failedAnalysesCount: Schema.optional(Schema.Number),
  totalRequestedAnalysesCount: Schema.optional(Schema.Number),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainBulkAnalyzeConversationsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkAnalyzeConversationsMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainBulkAnalyzeConversationsResponse {
  /** Count of successful analyses. */
  successfulAnalysisCount?: number;
  /** Count of failed analyses. */
  failedAnalysisCount?: number;
}

export const GoogleCloudContactcenterinsightsV1mainBulkAnalyzeConversationsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkAnalyzeConversationsResponse> = Schema.suspend(() => Schema.Struct({
  successfulAnalysisCount: Schema.optional(Schema.Number),
  failedAnalysisCount: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainBulkAnalyzeConversationsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkAnalyzeConversationsResponse>;

export interface GoogleCloudContactcenterinsightsV1mainBulkDeleteConversationsRequest {
  /** Required. The parent resource to delete conversations from. Format: projects/{project}/locations/{location} */
  parent?: string;
  /** Filter used to select the subset of conversations to delete. */
  filter?: string;
  /** Maximum number of conversations to delete. */
  maxDeleteCount?: number;
  /** If set to true, all of this conversation's analyses will also be deleted. Otherwise, the request will only succeed if the conversation has no analyses. */
  force?: boolean;
}

export const GoogleCloudContactcenterinsightsV1mainBulkDeleteConversationsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDeleteConversationsRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
  maxDeleteCount: Schema.optional(Schema.Number),
  force: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainBulkDeleteConversationsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDeleteConversationsRequest>;

export interface GoogleCloudContactcenterinsightsV1mainBulkDeleteConversationsMetadata {
  /** The time the operation was created. */
  createTime?: string;
  /** The time the operation finished running. */
  endTime?: string;
  /** The original request for bulk delete. */
  request?: GoogleCloudContactcenterinsightsV1mainBulkDeleteConversationsRequest;
  /** Partial errors during bulk delete conversations operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
}

export const GoogleCloudContactcenterinsightsV1mainBulkDeleteConversationsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDeleteConversationsMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1mainBulkDeleteConversationsRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainBulkDeleteConversationsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDeleteConversationsMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainBulkDeleteConversationsResponse {
}

export const GoogleCloudContactcenterinsightsV1mainBulkDeleteConversationsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDeleteConversationsResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainBulkDeleteConversationsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDeleteConversationsResponse>;

export interface GoogleCloudContactcenterinsightsV1mainBulkDeleteFeedbackLabelsRequest {
  /** Required. The parent resource for new feedback labels. */
  parent?: string;
  /** Optional. A filter to reduce results to a specific subset. Supports disjunctions (OR) and conjunctions (AND). Supported fields: * `issue_model_id` * `qa_question_id` * `qa_scorecard_id` * `min_create_time` * `max_create_time` * `min_update_time` * `max_update_time` * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING */
  filter?: string;
}

export const GoogleCloudContactcenterinsightsV1mainBulkDeleteFeedbackLabelsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDeleteFeedbackLabelsRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainBulkDeleteFeedbackLabelsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDeleteFeedbackLabelsRequest>;

export interface GoogleCloudContactcenterinsightsV1mainBulkDeleteFeedbackLabelsMetadata {
  /** Output only. The original request for delete. */
  request?: GoogleCloudContactcenterinsightsV1mainBulkDeleteFeedbackLabelsRequest;
  /** Partial errors during deletion operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
}

export const GoogleCloudContactcenterinsightsV1mainBulkDeleteFeedbackLabelsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDeleteFeedbackLabelsMetadata> = Schema.suspend(() => Schema.Struct({
  request: Schema.optional(GoogleCloudContactcenterinsightsV1mainBulkDeleteFeedbackLabelsRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainBulkDeleteFeedbackLabelsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDeleteFeedbackLabelsMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainBulkDeleteFeedbackLabelsResponse {
}

export const GoogleCloudContactcenterinsightsV1mainBulkDeleteFeedbackLabelsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDeleteFeedbackLabelsResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainBulkDeleteFeedbackLabelsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDeleteFeedbackLabelsResponse>;

export interface GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequestGcsDestination {
  /** Required. File format in which the labels will be exported. */
  format?: "FORMAT_UNSPECIFIED" | "CSV" | "JSON" | (string & {});
  /** Required. The Google Cloud Storage URI to write the feedback labels to. The file name will be used as a prefix for the files written to the bucket if the output needs to be split across multiple files, otherwise it will be used as is. The file extension will be appended to the file name based on the format selected. E.g. `gs://bucket_name/object_uri_prefix` */
  objectUri?: string;
  /** Optional. Add whitespace to the JSON file. Makes easier to read, but increases file size. Only applicable for JSON format. */
  addWhitespace?: boolean;
  /** Optional. Always print fields with no presence. This is useful for printing fields that are not set, like implicit 0 value or empty lists/maps. Only applicable for JSON format. */
  alwaysPrintEmptyFields?: boolean;
  /** Optional. The number of records per file. Applicable for either format. */
  recordsPerFileCount?: string;
}

export const GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequestGcsDestination: Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequestGcsDestination> = Schema.suspend(() => Schema.Struct({
  format: Schema.optional(Schema.String),
  objectUri: Schema.optional(Schema.String),
  addWhitespace: Schema.optional(Schema.Boolean),
  alwaysPrintEmptyFields: Schema.optional(Schema.Boolean),
  recordsPerFileCount: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequestGcsDestination" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequestGcsDestination>;

export interface GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequestSheetsDestination {
  /** Required. The Google Sheets document to write the feedback labels to. Retrieved from Google Sheets URI. E.g. `https://docs.google.com/spreadsheets/d/1234567890` The spreadsheet must be shared with the Insights P4SA. The spreadsheet ID written to will be returned as `file_names` in the BulkDownloadFeedbackLabelsMetadata. */
  spreadsheetUri?: string;
  /** Optional. The title of the new sheet to write the feedback labels to. */
  sheetTitle?: string;
}

export const GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequestSheetsDestination: Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequestSheetsDestination> = Schema.suspend(() => Schema.Struct({
  spreadsheetUri: Schema.optional(Schema.String),
  sheetTitle: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequestSheetsDestination" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequestSheetsDestination>;

export interface GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequest {
  /** Required. The parent resource for new feedback labels. */
  parent?: string;
  /** Optional. A filter to reduce results to a specific subset. Supports disjunctions (OR) and conjunctions (AND). Supported fields: * `issue_model_id` * `qa_question_id` * `qa_scorecard_id` * `min_create_time` * `max_create_time` * `min_update_time` * `max_update_time` * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING */
  filter?: string;
  /** A cloud storage bucket destination. */
  gcsDestination?: GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequestGcsDestination;
  /** A sheets document destination. */
  sheetsDestination?: GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequestSheetsDestination;
  /** Optional. Limits the maximum number of feedback labels that will be downloaded. The first `N` feedback labels will be downloaded. */
  maxDownloadCount?: number;
  /** Optional. The type of feedback labels that will be downloaded. */
  feedbackLabelType?: "FEEDBACK_LABEL_TYPE_UNSPECIFIED" | "QUALITY_AI" | "TOPIC_MODELING" | "AGENT_ASSIST_SUMMARY" | (string & {});
  /** Optional. Filter parent conversations to download feedback labels for. When specified, the feedback labels will be downloaded for the conversations that match the filter. If `template_qa_scorecard_id` is set, all the conversations that match the filter will be paired with the questions under the scorecard for labeling. */
  conversationFilter?: string;
  /** Optional. If set, a template for labeling conversations and scorecard questions will be created from the conversation_filter and the questions under the scorecard(s). The feedback label `filter` will be ignored. */
  templateQaScorecardId?: Array<string>;
}

export const GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
  gcsDestination: Schema.optional(GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequestGcsDestination),
  sheetsDestination: Schema.optional(GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequestSheetsDestination),
  maxDownloadCount: Schema.optional(Schema.Number),
  feedbackLabelType: Schema.optional(Schema.String),
  conversationFilter: Schema.optional(Schema.String),
  templateQaScorecardId: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequest>;

export interface GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsMetadataDownloadStats {
  /** The number of objects processed during the download operation. */
  processedObjectCount?: number;
  /** The number of new feedback labels downloaded during this operation. Different from "processed" because some labels might not be downloaded because an error. */
  successfulDownloadCount?: number;
  /** Total number of files written to the provided Cloud Storage bucket. */
  totalFilesWritten?: number;
  /** Output only. Full name of the files written to Cloud storage. */
  fileNames?: Array<string>;
}

export const GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsMetadataDownloadStats: Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsMetadataDownloadStats> = Schema.suspend(() => Schema.Struct({
  processedObjectCount: Schema.optional(Schema.Number),
  successfulDownloadCount: Schema.optional(Schema.Number),
  totalFilesWritten: Schema.optional(Schema.Number),
  fileNames: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsMetadataDownloadStats" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsMetadataDownloadStats>;

export interface GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request for download. */
  request?: GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequest;
  /** Partial errors during ingest operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
  /** Output only. Statistics for BulkDownloadFeedbackLabels operation. */
  downloadStats?: GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsMetadataDownloadStats;
}

export const GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
  downloadStats: Schema.optional(GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsMetadataDownloadStats),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsResponse {
}

export const GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainBulkDownloadFeedbackLabelsResponse>;

export interface GoogleCloudContactcenterinsightsV1mainCreateAnalysisOperationMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The Conversation that this Analysis Operation belongs to. */
  conversation?: string;
  /** Output only. The annotator selector used for the analysis (if any). */
  annotatorSelector?: GoogleCloudContactcenterinsightsV1mainAnnotatorSelector;
}

export const GoogleCloudContactcenterinsightsV1mainCreateAnalysisOperationMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainCreateAnalysisOperationMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  conversation: Schema.optional(Schema.String),
  annotatorSelector: Schema.optional(GoogleCloudContactcenterinsightsV1mainAnnotatorSelector),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainCreateAnalysisOperationMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainCreateAnalysisOperationMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainIssue {
  /** Immutable. The resource name of the issue. Format: projects/{project}/locations/{location}/issueModels/{issue_model}/issues/{issue} */
  name?: string;
  /** The representative name for the issue. */
  displayName?: string;
  /** Output only. The time at which this issue was created. */
  createTime?: string;
  /** Output only. The most recent time that this issue was updated. */
  updateTime?: string;
  /** Output only. Resource names of the sample representative utterances that match to this issue. */
  sampleUtterances?: Array<string>;
  /** Representative description of the issue. */
  displayDescription?: string;
}

export const GoogleCloudContactcenterinsightsV1mainIssue: Schema.Schema<GoogleCloudContactcenterinsightsV1mainIssue> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  sampleUtterances: Schema.optional(Schema.Array(Schema.String)),
  displayDescription: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainIssue" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainIssue>;

export interface GoogleCloudContactcenterinsightsV1mainCreateIssueRequest {
  /** Required. The parent resource of the issue. */
  parent?: string;
  /** Required. The values for the new issue. */
  issue?: GoogleCloudContactcenterinsightsV1mainIssue;
}

export const GoogleCloudContactcenterinsightsV1mainCreateIssueRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1mainCreateIssueRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  issue: Schema.optional(GoogleCloudContactcenterinsightsV1mainIssue),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainCreateIssueRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainCreateIssueRequest>;

export interface GoogleCloudContactcenterinsightsV1mainCreateIssueMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** The original request for creation. */
  request?: GoogleCloudContactcenterinsightsV1mainCreateIssueRequest;
}

export const GoogleCloudContactcenterinsightsV1mainCreateIssueMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainCreateIssueMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1mainCreateIssueRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainCreateIssueMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainCreateIssueMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainIssueModelInputDataConfig {
  /** Medium of conversations used in training data. This field is being deprecated. To specify the medium to be used in training a new issue model, set the `medium` field on `filter`. */
  medium?: "MEDIUM_UNSPECIFIED" | "PHONE_CALL" | "CHAT" | (string & {});
  /** Output only. Number of conversations used in training. Output only. */
  trainingConversationsCount?: string;
  /** A filter to reduce the conversations used for training the model to a specific subset. Refer to https://cloud.google.com/contact-center/insights/docs/filtering for details. */
  filter?: string;
}

export const GoogleCloudContactcenterinsightsV1mainIssueModelInputDataConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1mainIssueModelInputDataConfig> = Schema.suspend(() => Schema.Struct({
  medium: Schema.optional(Schema.String),
  trainingConversationsCount: Schema.optional(Schema.String),
  filter: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainIssueModelInputDataConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainIssueModelInputDataConfig>;

export interface GoogleCloudContactcenterinsightsV1mainIssueModelLabelStatsIssueStats {
  /** Issue resource. Format: projects/{project}/locations/{location}/issueModels/{issue_model}/issues/{issue} */
  issue?: string;
  /** Number of conversations attached to the issue at this point in time. */
  labeledConversationsCount?: string;
  /** Display name of the issue. */
  displayName?: string;
}

export const GoogleCloudContactcenterinsightsV1mainIssueModelLabelStatsIssueStats: Schema.Schema<GoogleCloudContactcenterinsightsV1mainIssueModelLabelStatsIssueStats> = Schema.suspend(() => Schema.Struct({
  issue: Schema.optional(Schema.String),
  labeledConversationsCount: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainIssueModelLabelStatsIssueStats" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainIssueModelLabelStatsIssueStats>;

export interface GoogleCloudContactcenterinsightsV1mainIssueModelLabelStats {
  /** Number of conversations the issue model has analyzed at this point in time. */
  analyzedConversationsCount?: string;
  /** Number of analyzed conversations for which no issue was applicable at this point in time. */
  unclassifiedConversationsCount?: string;
  /** Statistics on each issue. Key is the issue's resource name. */
  issueStats?: Record<string, GoogleCloudContactcenterinsightsV1mainIssueModelLabelStatsIssueStats>;
}

export const GoogleCloudContactcenterinsightsV1mainIssueModelLabelStats: Schema.Schema<GoogleCloudContactcenterinsightsV1mainIssueModelLabelStats> = Schema.suspend(() => Schema.Struct({
  analyzedConversationsCount: Schema.optional(Schema.String),
  unclassifiedConversationsCount: Schema.optional(Schema.String),
  issueStats: Schema.optional(Schema.Record(Schema.String, GoogleCloudContactcenterinsightsV1mainIssueModelLabelStatsIssueStats)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainIssueModelLabelStats" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainIssueModelLabelStats>;

export interface GoogleCloudContactcenterinsightsV1mainIssueModel {
  /** Immutable. The resource name of the issue model. Format: projects/{project}/locations/{location}/issueModels/{issue_model} */
  name?: string;
  /** The representative name for the issue model. */
  displayName?: string;
  /** Output only. The time at which this issue model was created. */
  createTime?: string;
  /** Output only. The most recent time at which the issue model was updated. */
  updateTime?: string;
  /** Output only. Number of issues in this issue model. */
  issueCount?: string;
  /** Output only. State of the model. */
  state?: "STATE_UNSPECIFIED" | "UNDEPLOYED" | "DEPLOYING" | "DEPLOYED" | "UNDEPLOYING" | "DELETING" | (string & {});
  /** Configs for the input data that used to create the issue model. */
  inputDataConfig?: GoogleCloudContactcenterinsightsV1mainIssueModelInputDataConfig;
  /** Output only. Immutable. The issue model's label statistics on its training data. */
  trainingStats?: GoogleCloudContactcenterinsightsV1mainIssueModelLabelStats;
  /** Type of the model. */
  modelType?: "MODEL_TYPE_UNSPECIFIED" | "TYPE_V1" | "TYPE_V2" | (string & {});
  /** Language of the model. */
  languageCode?: string;
}

export const GoogleCloudContactcenterinsightsV1mainIssueModel: Schema.Schema<GoogleCloudContactcenterinsightsV1mainIssueModel> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  issueCount: Schema.optional(Schema.String),
  state: Schema.optional(Schema.String),
  inputDataConfig: Schema.optional(GoogleCloudContactcenterinsightsV1mainIssueModelInputDataConfig),
  trainingStats: Schema.optional(GoogleCloudContactcenterinsightsV1mainIssueModelLabelStats),
  modelType: Schema.optional(Schema.String),
  languageCode: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainIssueModel" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainIssueModel>;

export interface GoogleCloudContactcenterinsightsV1mainCreateIssueModelRequest {
  /** Required. The parent resource of the issue model. */
  parent?: string;
  /** Required. The issue model to create. */
  issueModel?: GoogleCloudContactcenterinsightsV1mainIssueModel;
}

export const GoogleCloudContactcenterinsightsV1mainCreateIssueModelRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1mainCreateIssueModelRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  issueModel: Schema.optional(GoogleCloudContactcenterinsightsV1mainIssueModel),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainCreateIssueModelRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainCreateIssueModelRequest>;

export interface GoogleCloudContactcenterinsightsV1mainCreateIssueModelMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** The original request for creation. */
  request?: GoogleCloudContactcenterinsightsV1mainCreateIssueModelRequest;
}

export const GoogleCloudContactcenterinsightsV1mainCreateIssueModelMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainCreateIssueModelMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1mainCreateIssueModelRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainCreateIssueModelMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainCreateIssueModelMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainDeleteIssueModelRequest {
  /** Required. The name of the issue model to delete. */
  name?: string;
}

export const GoogleCloudContactcenterinsightsV1mainDeleteIssueModelRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDeleteIssueModelRequest> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDeleteIssueModelRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDeleteIssueModelRequest>;

export interface GoogleCloudContactcenterinsightsV1mainDeleteIssueModelMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** The original request for deletion. */
  request?: GoogleCloudContactcenterinsightsV1mainDeleteIssueModelRequest;
}

export const GoogleCloudContactcenterinsightsV1mainDeleteIssueModelMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDeleteIssueModelMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1mainDeleteIssueModelRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDeleteIssueModelMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDeleteIssueModelMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainDeleteQaQuestionTagRequest {
  /** Required. The name of the QaQuestionTag to delete. */
  name?: string;
}

export const GoogleCloudContactcenterinsightsV1mainDeleteQaQuestionTagRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDeleteQaQuestionTagRequest> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDeleteQaQuestionTagRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDeleteQaQuestionTagRequest>;

export interface GoogleCloudContactcenterinsightsV1mainDeleteQaQuestionTagMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request. */
  request?: GoogleCloudContactcenterinsightsV1mainDeleteQaQuestionTagRequest;
}

export const GoogleCloudContactcenterinsightsV1mainDeleteQaQuestionTagMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDeleteQaQuestionTagMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1mainDeleteQaQuestionTagRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDeleteQaQuestionTagMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDeleteQaQuestionTagMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainDeployIssueModelRequest {
  /** Required. The issue model to deploy. */
  name?: string;
}

export const GoogleCloudContactcenterinsightsV1mainDeployIssueModelRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDeployIssueModelRequest> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDeployIssueModelRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDeployIssueModelRequest>;

export interface GoogleCloudContactcenterinsightsV1mainDeployIssueModelMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** The original request for deployment. */
  request?: GoogleCloudContactcenterinsightsV1mainDeployIssueModelRequest;
}

export const GoogleCloudContactcenterinsightsV1mainDeployIssueModelMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDeployIssueModelMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1mainDeployIssueModelRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDeployIssueModelMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDeployIssueModelMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainDeployIssueModelResponse {
}

export const GoogleCloudContactcenterinsightsV1mainDeployIssueModelResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDeployIssueModelResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDeployIssueModelResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDeployIssueModelResponse>;

export interface GoogleCloudContactcenterinsightsV1mainExportInsightsDataRequestBigQueryDestination {
  /** A project ID or number. If specified, then export will attempt to write data to this project instead of the resource project. Otherwise, the resource project will be used. */
  projectId?: string;
  /** Required. The name of the BigQuery dataset that the snapshot result should be exported to. If this dataset does not exist, the export call returns an INVALID_ARGUMENT error. */
  dataset?: string;
  /** The BigQuery table name to which the insights data should be written. If this table does not exist, the export call returns an INVALID_ARGUMENT error. */
  table?: string;
}

export const GoogleCloudContactcenterinsightsV1mainExportInsightsDataRequestBigQueryDestination: Schema.Schema<GoogleCloudContactcenterinsightsV1mainExportInsightsDataRequestBigQueryDestination> = Schema.suspend(() => Schema.Struct({
  projectId: Schema.optional(Schema.String),
  dataset: Schema.optional(Schema.String),
  table: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainExportInsightsDataRequestBigQueryDestination" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainExportInsightsDataRequestBigQueryDestination>;

export interface GoogleCloudContactcenterinsightsV1mainExportInsightsDataRequest {
  /** Required. The parent resource to export data from. */
  parent?: string;
  /** Specified if sink is a BigQuery table. */
  bigQueryDestination?: GoogleCloudContactcenterinsightsV1mainExportInsightsDataRequestBigQueryDestination;
  /** A filter to reduce results to a specific subset. Useful for exporting conversations with specific properties. */
  filter?: string;
  /** A fully qualified KMS key name for BigQuery tables protected by CMEK. Format: projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{key}/cryptoKeyVersions/{version} */
  kmsKey?: string;
  /** Options for what to do if the destination table already exists. */
  writeDisposition?: "WRITE_DISPOSITION_UNSPECIFIED" | "WRITE_TRUNCATE" | "WRITE_APPEND" | (string & {});
  /** Optional. Version of the export schema. */
  exportSchemaVersion?: "EXPORT_SCHEMA_VERSION_UNSPECIFIED" | "EXPORT_V1" | "EXPORT_V2" | "EXPORT_V3" | "EXPORT_V4" | "EXPORT_V5" | "EXPORT_V6" | "EXPORT_V7" | "EXPORT_V8" | "EXPORT_V9" | "EXPORT_V10" | "EXPORT_V11" | "EXPORT_V12" | "EXPORT_V13" | "EXPORT_V14" | "EXPORT_V15" | "EXPORT_V16" | "EXPORT_V17" | "EXPORT_VERSION_LATEST_AVAILABLE" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1mainExportInsightsDataRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1mainExportInsightsDataRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  bigQueryDestination: Schema.optional(GoogleCloudContactcenterinsightsV1mainExportInsightsDataRequestBigQueryDestination),
  filter: Schema.optional(Schema.String),
  kmsKey: Schema.optional(Schema.String),
  writeDisposition: Schema.optional(Schema.String),
  exportSchemaVersion: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainExportInsightsDataRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainExportInsightsDataRequest>;

export interface GoogleCloudContactcenterinsightsV1mainExportInsightsDataMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** The original request for export. */
  request?: GoogleCloudContactcenterinsightsV1mainExportInsightsDataRequest;
  /** Partial errors during export operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
  /** The number of conversations that were exported successfully. */
  completedExportCount?: number;
  /** The number of conversations that failed to be exported. */
  failedExportCount?: number;
}

export const GoogleCloudContactcenterinsightsV1mainExportInsightsDataMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainExportInsightsDataMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1mainExportInsightsDataRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
  completedExportCount: Schema.optional(Schema.Number),
  failedExportCount: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainExportInsightsDataMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainExportInsightsDataMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainExportInsightsDataResponse {
}

export const GoogleCloudContactcenterinsightsV1mainExportInsightsDataResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainExportInsightsDataResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainExportInsightsDataResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainExportInsightsDataResponse>;

export interface GoogleCloudContactcenterinsightsV1mainExportIssueModelRequestGcsDestination {
  /** Required. Format: `gs:///` */
  objectUri?: string;
}

export const GoogleCloudContactcenterinsightsV1mainExportIssueModelRequestGcsDestination: Schema.Schema<GoogleCloudContactcenterinsightsV1mainExportIssueModelRequestGcsDestination> = Schema.suspend(() => Schema.Struct({
  objectUri: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainExportIssueModelRequestGcsDestination" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainExportIssueModelRequestGcsDestination>;

export interface GoogleCloudContactcenterinsightsV1mainExportIssueModelRequest {
  /** Required. The issue model to export. */
  name?: string;
  /** Google Cloud Storage URI to export the issue model to. */
  gcsDestination?: GoogleCloudContactcenterinsightsV1mainExportIssueModelRequestGcsDestination;
}

export const GoogleCloudContactcenterinsightsV1mainExportIssueModelRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1mainExportIssueModelRequest> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  gcsDestination: Schema.optional(GoogleCloudContactcenterinsightsV1mainExportIssueModelRequestGcsDestination),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainExportIssueModelRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainExportIssueModelRequest>;

export interface GoogleCloudContactcenterinsightsV1mainExportIssueModelMetadata {
  /** The time the operation was created. */
  createTime?: string;
  /** The time the operation finished running. */
  endTime?: string;
  /** The original export request. */
  request?: GoogleCloudContactcenterinsightsV1mainExportIssueModelRequest;
}

export const GoogleCloudContactcenterinsightsV1mainExportIssueModelMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainExportIssueModelMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1mainExportIssueModelRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainExportIssueModelMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainExportIssueModelMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainExportIssueModelResponse {
}

export const GoogleCloudContactcenterinsightsV1mainExportIssueModelResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainExportIssueModelResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainExportIssueModelResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainExportIssueModelResponse>;

export interface GoogleCloudContactcenterinsightsV1mainGenerativeInsightsMetadata {
  /** The error message when the generative insights request fails. */
  errorMessages?: Array<GoogleRpcStatus>;
}

export const GoogleCloudContactcenterinsightsV1mainGenerativeInsightsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightsMetadata> = Schema.suspend(() => Schema.Struct({
  errorMessages: Schema.optional(Schema.Array(GoogleRpcStatus)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainGenerativeInsightsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightsMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponseGenerativeResponseTextOutput {
  /** The text output from the LLM. */
  text?: Array<string>;
  /** The type of text output. */
  textType?: "TYPE_UNSPECIFIED" | "THOUGHT" | "FINAL_RESPONSE" | "PROGRESS" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponseGenerativeResponseTextOutput: Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponseGenerativeResponseTextOutput> = Schema.suspend(() => Schema.Struct({
  text: Schema.optional(Schema.Array(Schema.String)),
  textType: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponseGenerativeResponseTextOutput" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponseGenerativeResponseTextOutput>;

export interface GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponseGenerativeResponse {
  /** The text output from the LLM. Will be populated during the chart building phase. For a reloaded chart, this will NOT be populated. May contain THOUGHT or a FINAL response or some in-progress response. */
  textOutput?: string;
  /** The generated SQL query from the LLM. Will be populated during the chart building phase. The generated SQL will be cached in the corresponding chart resource. */
  generatedSqlQuery?: string;
  /** The chart spec for the data. This will be specified in the vega-lite or vega format. */
  chartSpec?: Record<string, unknown>;
  /** The text output from the LLM. Will be populated during the chart building phase. For a reloaded chart, this will NOT be populated. May contain THOUGHT or a FINAL response or some in-progress response. */
  textMessage?: GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponseGenerativeResponseTextOutput;
}

export const GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponseGenerativeResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponseGenerativeResponse> = Schema.suspend(() => Schema.Struct({
  textOutput: Schema.optional(Schema.String),
  generatedSqlQuery: Schema.optional(Schema.String),
  chartSpec: Schema.optional(Schema.Record(Schema.String, Schema.Unknown)),
  textMessage: Schema.optional(GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponseGenerativeResponseTextOutput),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponseGenerativeResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponseGenerativeResponse>;

export interface GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageUserMessage {
  /** A message from the user that is interacting with the system. */
  text?: string;
}

export const GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageUserMessage: Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageUserMessage> = Schema.suspend(() => Schema.Struct({
  text: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageUserMessage" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageUserMessage>;

export interface GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessageTextOutput {
  /** The parts of the message. */
  text?: Array<string>;
  /** The type of the text message. */
  textType?: "TYPE_UNSPECIFIED" | "THOUGHT" | "FINAL_RESPONSE" | "PROGRESS" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessageTextOutput: Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessageTextOutput> = Schema.suspend(() => Schema.Struct({
  text: Schema.optional(Schema.Array(Schema.String)),
  textType: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessageTextOutput" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessageTextOutput>;

export interface GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessage {
  /** A direct natural language response to the user message. */
  textMessage?: GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessageTextOutput;
  /** Raw SQL from LLM, before templatization */
  generatedSqlQuery?: string;
  /** Chart spec from LLM */
  chartSpec?: Record<string, unknown>;
  /** Optional. User provided SQL query */
  userProvidedSqlQuery?: string;
  /** Optional. User provided chart spec */
  userProvidedChartSpec?: Record<string, unknown>;
}

export const GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessage: Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessage> = Schema.suspend(() => Schema.Struct({
  textMessage: Schema.optional(GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessageTextOutput),
  generatedSqlQuery: Schema.optional(Schema.String),
  chartSpec: Schema.optional(Schema.Record(Schema.String, Schema.Unknown)),
  userProvidedSqlQuery: Schema.optional(Schema.String),
  userProvidedChartSpec: Schema.optional(Schema.Record(Schema.String, Schema.Unknown)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessage" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessage>;

export interface GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessages {
  /** A message from the system in response to the user. */
  systemMessages?: Array<GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessage>;
}

export const GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessages: Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessages> = Schema.suspend(() => Schema.Struct({
  systemMessages: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessage)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessages" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessages>;

export interface GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessage {
  /** The message id of the message. */
  messageId?: string;
  /** Output only. For user messages, this is the time at which the system received the message. For system messages, this is the time at which the system generated the message. */
  createTime?: string;
  /** A message from the user that is interacting with the system. */
  userMessage?: GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageUserMessage;
  /** A wrapper for system messages per turn. */
  systemMessageWrapper?: GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessages;
}

export const GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessage: Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessage> = Schema.suspend(() => Schema.Struct({
  messageId: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  userMessage: Schema.optional(GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageUserMessage),
  systemMessageWrapper: Schema.optional(GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessageSystemMessages),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessage" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessage>;

export interface GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscript {
  /** The conversation id of the chart. */
  conversationId?: string;
  /** Output only. The create time of the conversation. */
  createTime?: string;
  /** Output only. The update time of the conversation. */
  updateTime?: string;
  /** Ordered list of messages, including user inputs and system responses. */
  messages?: Array<GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessage>;
}

export const GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscript: Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscript> = Schema.suspend(() => Schema.Struct({
  conversationId: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  messages: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscriptMessage)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscript" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscript>;

export interface GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponse {
  /** The full list of generative responses. Each response is ordered by time. */
  generativeResponses?: Array<GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponseGenerativeResponse>;
  /** The transcript of the generative insights conversation. */
  transcript?: GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscript;
}

export const GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponse> = Schema.suspend(() => Schema.Struct({
  generativeResponses: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponseGenerativeResponse)),
  transcript: Schema.optional(GoogleCloudContactcenterinsightsV1mainGenerativeInsightConversationTranscript),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainGenerativeInsightsResponse>;

export interface GoogleCloudContactcenterinsightsV1mainImportIssueModelRequestGcsSource {
  /** Required. Format: `gs:///` */
  objectUri?: string;
}

export const GoogleCloudContactcenterinsightsV1mainImportIssueModelRequestGcsSource: Schema.Schema<GoogleCloudContactcenterinsightsV1mainImportIssueModelRequestGcsSource> = Schema.suspend(() => Schema.Struct({
  objectUri: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainImportIssueModelRequestGcsSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainImportIssueModelRequestGcsSource>;

export interface GoogleCloudContactcenterinsightsV1mainImportIssueModelRequest {
  /** Required. The parent resource of the issue model. */
  parent?: string;
  /** Google Cloud Storage source message. */
  gcsSource?: GoogleCloudContactcenterinsightsV1mainImportIssueModelRequestGcsSource;
  /** Optional. If set to true, will create an issue model from the imported file with randomly generated IDs for the issue model and corresponding issues. Otherwise, replaces an existing model with the same ID as the file. */
  createNewModel?: boolean;
}

export const GoogleCloudContactcenterinsightsV1mainImportIssueModelRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1mainImportIssueModelRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  gcsSource: Schema.optional(GoogleCloudContactcenterinsightsV1mainImportIssueModelRequestGcsSource),
  createNewModel: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainImportIssueModelRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainImportIssueModelRequest>;

export interface GoogleCloudContactcenterinsightsV1mainImportIssueModelMetadata {
  /** The time the operation was created. */
  createTime?: string;
  /** The time the operation finished running. */
  endTime?: string;
  /** The original import request. */
  request?: GoogleCloudContactcenterinsightsV1mainImportIssueModelRequest;
}

export const GoogleCloudContactcenterinsightsV1mainImportIssueModelMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainImportIssueModelMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1mainImportIssueModelRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainImportIssueModelMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainImportIssueModelMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainImportIssueModelResponse {
  /** The issue model that was imported. */
  issueModel?: GoogleCloudContactcenterinsightsV1mainIssueModel;
}

export const GoogleCloudContactcenterinsightsV1mainImportIssueModelResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainImportIssueModelResponse> = Schema.suspend(() => Schema.Struct({
  issueModel: Schema.optional(GoogleCloudContactcenterinsightsV1mainIssueModel),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainImportIssueModelResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainImportIssueModelResponse>;

export interface GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestGcsSource {
  /** Optional. The Cloud Storage bucket containing source objects. Avoid passing this. Pass this through one of `transcript_bucket_uri` or `audio_bucket_uri`. */
  bucketUri?: string;
  /** Optional. Specifies the type of the objects in `bucket_uri`. Avoid passing this. This is inferred from the `transcript_bucket_uri`, `audio_bucket_uri`. */
  bucketObjectType?: "BUCKET_OBJECT_TYPE_UNSPECIFIED" | "TRANSCRIPT" | "AUDIO" | (string & {});
  /** Optional. The Cloud Storage path to the conversation transcripts. Note that: [1] Transcript files are expected to be in JSON format. [2] Transcript, audio, metadata files must be in separate buckets / folders. [3] A source file and its corresponding metadata file must share the same name to be properly ingested, E.g. `gs://bucket/audio/conversation1.mp3` and `gs://bucket/metadata/conversation1.json`. */
  transcriptBucketUri?: string;
  /** Optional. The Cloud Storage path to the conversation audio file. Note that: [1] Audio files will be transcribed if not already. [2] Audio files and transcript files must be in separate buckets / folders. [3] A source file and its corresponding audio file must share the same name to be properly ingested, E.g. `gs://bucket/transcript/conversation1.json` and `gs://bucket/audio/conversation1.mp3`. */
  audioBucketUri?: string;
  /** Optional. The Cloud Storage path to the conversation metadata. Note that: [1] Metadata files are expected to be in JSON format. [2] Metadata and source files (transcripts or audio) must be in separate buckets / folders. [3] A source file and its corresponding metadata file must share the same name to be properly ingested, E.g. `gs://bucket/audio/conversation1.mp3` and `gs://bucket/metadata/conversation1.json`. */
  metadataBucketUri?: string;
  /** Optional. Custom keys to extract as conversation labels from metadata files in `metadata_bucket_uri`. Keys not included in this field will be ignored. Note that there is a limit of 100 labels per conversation. */
  customMetadataKeys?: Array<string>;
}

export const GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestGcsSource: Schema.Schema<GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestGcsSource> = Schema.suspend(() => Schema.Struct({
  bucketUri: Schema.optional(Schema.String),
  bucketObjectType: Schema.optional(Schema.String),
  transcriptBucketUri: Schema.optional(Schema.String),
  audioBucketUri: Schema.optional(Schema.String),
  metadataBucketUri: Schema.optional(Schema.String),
  customMetadataKeys: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestGcsSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestGcsSource>;

export interface GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestTranscriptObjectConfig {
  /** Required. The medium transcript objects represent. */
  medium?: "MEDIUM_UNSPECIFIED" | "PHONE_CALL" | "CHAT" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestTranscriptObjectConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestTranscriptObjectConfig> = Schema.suspend(() => Schema.Struct({
  medium: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestTranscriptObjectConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestTranscriptObjectConfig>;

export interface GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestConversationConfig {
  /** Optional. An opaque, user-specified string representing a human agent who handled all conversations in the import. Note that this will be overridden if per-conversation metadata is provided through the `metadata_bucket_uri`. */
  agentId?: string;
  /** Optional. Indicates which of the channels, 1 or 2, contains the agent. Note that this must be set for conversations to be properly displayed and analyzed. */
  agentChannel?: number;
  /** Optional. Indicates which of the channels, 1 or 2, contains the agent. Note that this must be set for conversations to be properly displayed and analyzed. */
  customerChannel?: number;
}

export const GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestConversationConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestConversationConfig> = Schema.suspend(() => Schema.Struct({
  agentId: Schema.optional(Schema.String),
  agentChannel: Schema.optional(Schema.Number),
  customerChannel: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestConversationConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestConversationConfig>;

export interface GoogleCloudContactcenterinsightsV1mainRedactionConfig {
  /** The fully-qualified DLP deidentify template resource name. Format: `projects/{project}/deidentifyTemplates/{template}` */
  deidentifyTemplate?: string;
  /** The fully-qualified DLP inspect template resource name. Format: `projects/{project}/locations/{location}/inspectTemplates/{template}` */
  inspectTemplate?: string;
}

export const GoogleCloudContactcenterinsightsV1mainRedactionConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1mainRedactionConfig> = Schema.suspend(() => Schema.Struct({
  deidentifyTemplate: Schema.optional(Schema.String),
  inspectTemplate: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainRedactionConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainRedactionConfig>;

export interface GoogleCloudContactcenterinsightsV1mainSpeechConfig {
  /** The fully-qualified Speech Recognizer resource name. Format: `projects/{project_id}/locations/{location}/recognizer/{recognizer}` */
  speechRecognizer?: string;
  /** Whether to disable word time offsets. If true, the `enable_word_time_offsets` field in the recognition config will be set to false. */
  disableWordTimeOffsets?: boolean;
}

export const GoogleCloudContactcenterinsightsV1mainSpeechConfig: Schema.Schema<GoogleCloudContactcenterinsightsV1mainSpeechConfig> = Schema.suspend(() => Schema.Struct({
  speechRecognizer: Schema.optional(Schema.String),
  disableWordTimeOffsets: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainSpeechConfig" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainSpeechConfig>;

export interface GoogleCloudContactcenterinsightsV1mainIngestConversationsRequest {
  /** Required. The parent resource for new conversations. */
  parent?: string;
  /** A cloud storage bucket source. Note that any previously ingested objects from the source will be skipped to avoid duplication. */
  gcsSource?: GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestGcsSource;
  /** Configuration for when `source` contains conversation transcripts. */
  transcriptObjectConfig?: GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestTranscriptObjectConfig;
  /** Configuration that applies to all conversations. */
  conversationConfig?: GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestConversationConfig;
  /** Optional. DLP settings for transcript redaction. Optional, will default to the config specified in Settings. */
  redactionConfig?: GoogleCloudContactcenterinsightsV1mainRedactionConfig;
  /** Optional. Default Speech-to-Text configuration. Optional, will default to the config specified in Settings. */
  speechConfig?: GoogleCloudContactcenterinsightsV1mainSpeechConfig;
  /** Optional. If set, this fields indicates the number of objects to ingest from the Cloud Storage bucket. If empty, the entire bucket will be ingested. Unless they are first deleted, conversations produced through sampling won't be ingested by subsequent ingest requests. */
  sampleSize?: number;
}

export const GoogleCloudContactcenterinsightsV1mainIngestConversationsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1mainIngestConversationsRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  gcsSource: Schema.optional(GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestGcsSource),
  transcriptObjectConfig: Schema.optional(GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestTranscriptObjectConfig),
  conversationConfig: Schema.optional(GoogleCloudContactcenterinsightsV1mainIngestConversationsRequestConversationConfig),
  redactionConfig: Schema.optional(GoogleCloudContactcenterinsightsV1mainRedactionConfig),
  speechConfig: Schema.optional(GoogleCloudContactcenterinsightsV1mainSpeechConfig),
  sampleSize: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainIngestConversationsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainIngestConversationsRequest>;

export interface GoogleCloudContactcenterinsightsV1mainIngestConversationsMetadataIngestConversationsStats {
  /** Output only. The number of objects processed during the ingest operation. */
  processedObjectCount?: number;
  /** Output only. The number of objects skipped because another conversation with the same transcript uri had already been ingested. */
  duplicatesSkippedCount?: number;
  /** Output only. The number of new conversations added during this ingest operation. */
  successfulIngestCount?: number;
  /** Output only. The number of objects which were unable to be ingested due to errors. The errors are populated in the partial_errors field. */
  failedIngestCount?: number;
}

export const GoogleCloudContactcenterinsightsV1mainIngestConversationsMetadataIngestConversationsStats: Schema.Schema<GoogleCloudContactcenterinsightsV1mainIngestConversationsMetadataIngestConversationsStats> = Schema.suspend(() => Schema.Struct({
  processedObjectCount: Schema.optional(Schema.Number),
  duplicatesSkippedCount: Schema.optional(Schema.Number),
  successfulIngestCount: Schema.optional(Schema.Number),
  failedIngestCount: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainIngestConversationsMetadataIngestConversationsStats" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainIngestConversationsMetadataIngestConversationsStats>;

export interface GoogleCloudContactcenterinsightsV1mainIngestConversationsMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request for ingest. */
  request?: GoogleCloudContactcenterinsightsV1mainIngestConversationsRequest;
  /** Output only. Partial errors during ingest operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
  /** Output only. Statistics for IngestConversations operation. */
  ingestConversationsStats?: GoogleCloudContactcenterinsightsV1mainIngestConversationsMetadataIngestConversationsStats;
  /** Output only. Stores the conversation resources produced by ingest sampling operations. */
  sampledConversations?: Array<string>;
}

export const GoogleCloudContactcenterinsightsV1mainIngestConversationsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainIngestConversationsMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1mainIngestConversationsRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
  ingestConversationsStats: Schema.optional(GoogleCloudContactcenterinsightsV1mainIngestConversationsMetadataIngestConversationsStats),
  sampledConversations: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainIngestConversationsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainIngestConversationsMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainIngestConversationsResponse {
}

export const GoogleCloudContactcenterinsightsV1mainIngestConversationsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainIngestConversationsResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainIngestConversationsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainIngestConversationsResponse>;

export interface GoogleCloudContactcenterinsightsV1mainEncryptionSpec {
  /** Immutable. The resource name of the encryption key specification resource. Format: projects/{project}/locations/{location}/encryptionSpec */
  name?: string;
  /** Required. The name of customer-managed encryption key that is used to secure a resource and its sub-resources. If empty, the resource is secured by our default encryption key. Only the key in the same location as this resource is allowed to be used for encryption. Format: `projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key}` */
  kmsKey?: string;
}

export const GoogleCloudContactcenterinsightsV1mainEncryptionSpec: Schema.Schema<GoogleCloudContactcenterinsightsV1mainEncryptionSpec> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  kmsKey: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainEncryptionSpec" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainEncryptionSpec>;

export interface GoogleCloudContactcenterinsightsV1mainInitializeEncryptionSpecRequest {
  /** Required. The encryption spec used for CMEK encryption. It is required that the kms key is in the same region as the endpoint. The same key will be used for all provisioned resources, if encryption is available. If the `kms_key_name` field is left empty, no encryption will be enforced. */
  encryptionSpec?: GoogleCloudContactcenterinsightsV1mainEncryptionSpec;
}

export const GoogleCloudContactcenterinsightsV1mainInitializeEncryptionSpecRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1mainInitializeEncryptionSpecRequest> = Schema.suspend(() => Schema.Struct({
  encryptionSpec: Schema.optional(GoogleCloudContactcenterinsightsV1mainEncryptionSpec),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainInitializeEncryptionSpecRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainInitializeEncryptionSpecRequest>;

export interface GoogleCloudContactcenterinsightsV1mainInitializeEncryptionSpecMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request for initialization. */
  request?: GoogleCloudContactcenterinsightsV1mainInitializeEncryptionSpecRequest;
  /** Partial errors during initializing operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
}

export const GoogleCloudContactcenterinsightsV1mainInitializeEncryptionSpecMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainInitializeEncryptionSpecMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1mainInitializeEncryptionSpecRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainInitializeEncryptionSpecMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainInitializeEncryptionSpecMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainInitializeEncryptionSpecResponse {
}

export const GoogleCloudContactcenterinsightsV1mainInitializeEncryptionSpecResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainInitializeEncryptionSpecResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainInitializeEncryptionSpecResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainInitializeEncryptionSpecResponse>;

export interface GoogleCloudContactcenterinsightsV1mainQaAnswerAnswerValue {
  /** A short string used as an identifier. Matches the value used in QaQuestion.AnswerChoice.key. */
  key?: string;
  /** String value. */
  strValue?: string;
  /** Numerical value. */
  numValue?: number;
  /** Boolean value. */
  boolValue?: boolean;
  /** A value of "Not Applicable (N/A)". Should only ever be `true`. */
  naValue?: boolean;
  /** Output only. A value of "Skip". If provided, this field may only be set to `true`. If a question receives this answer, it will be excluded from any score calculations. This would mean that the question was not evaluated. */
  skipValue?: boolean;
  /** Output only. Numerical score of the answer. */
  score?: number;
  /** Output only. The maximum potential score of the question. */
  potentialScore?: number;
  /** Output only. Normalized score of the questions. Calculated as score / potential_score. */
  normalizedScore?: number;
}

export const GoogleCloudContactcenterinsightsV1mainQaAnswerAnswerValue: Schema.Schema<GoogleCloudContactcenterinsightsV1mainQaAnswerAnswerValue> = Schema.suspend(() => Schema.Struct({
  key: Schema.optional(Schema.String),
  strValue: Schema.optional(Schema.String),
  numValue: Schema.optional(Schema.Number),
  boolValue: Schema.optional(Schema.Boolean),
  naValue: Schema.optional(Schema.Boolean),
  skipValue: Schema.optional(Schema.Boolean),
  score: Schema.optional(Schema.Number),
  potentialScore: Schema.optional(Schema.Number),
  normalizedScore: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainQaAnswerAnswerValue" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainQaAnswerAnswerValue>;

export interface GoogleCloudContactcenterinsightsV1mainFeedbackLabel {
  /** Immutable. Resource name of the FeedbackLabel. Format: projects/{project}/locations/{location}/conversations/{conversation}/feedbackLabels/{feedback_label} */
  name?: string;
  /** Name of the resource to be labeled. Supported resources are: * `projects/{project}/locations/{location}/qaScorecards/{scorecard}/revisions/{revision}/qaQuestions/{question}` * `projects/{project}/locations/{location}/issueModels/{issue_model}` * `projects/{project}/locations/{location}/generators/{generator_id}` */
  labeledResource?: string;
  /** String label used for Topic Modeling. */
  label?: string;
  /** QaAnswer label used for Quality AI example conversations. */
  qaAnswerLabel?: GoogleCloudContactcenterinsightsV1mainQaAnswerAnswerValue;
  /** Output only. Create time of the label. */
  createTime?: string;
  /** Output only. Update time of the label. */
  updateTime?: string;
}

export const GoogleCloudContactcenterinsightsV1mainFeedbackLabel: Schema.Schema<GoogleCloudContactcenterinsightsV1mainFeedbackLabel> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  labeledResource: Schema.optional(Schema.String),
  label: Schema.optional(Schema.String),
  qaAnswerLabel: Schema.optional(GoogleCloudContactcenterinsightsV1mainQaAnswerAnswerValue),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainFeedbackLabel" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainFeedbackLabel>;

export interface GoogleCloudContactcenterinsightsV1mainListAllFeedbackLabelsResponse {
  /** The feedback labels that match the request. */
  feedbackLabels?: Array<GoogleCloudContactcenterinsightsV1mainFeedbackLabel>;
  /** A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1mainListAllFeedbackLabelsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainListAllFeedbackLabelsResponse> = Schema.suspend(() => Schema.Struct({
  feedbackLabels: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainFeedbackLabel)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainListAllFeedbackLabelsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainListAllFeedbackLabelsResponse>;

export interface GoogleCloudContactcenterinsightsV1mainListFeedbackLabelsResponse {
  /** The feedback labels that match the request. */
  feedbackLabels?: Array<GoogleCloudContactcenterinsightsV1mainFeedbackLabel>;
  /** The next page token. */
  nextPageToken?: string;
}

export const GoogleCloudContactcenterinsightsV1mainListFeedbackLabelsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainListFeedbackLabelsResponse> = Schema.suspend(() => Schema.Struct({
  feedbackLabels: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainFeedbackLabel)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainListFeedbackLabelsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainListFeedbackLabelsResponse>;

export interface GoogleCloudContactcenterinsightsV1mainQueryMetricsMetadata {
  /** Whether the result rows were truncated because the result row size is too large to materialize. */
  resultIsTruncated?: boolean;
}

export const GoogleCloudContactcenterinsightsV1mainQueryMetricsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryMetricsMetadata> = Schema.suspend(() => Schema.Struct({
  resultIsTruncated: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainQueryMetricsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryMetricsMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainDimensionIssueDimensionMetadata {
  /** The issue ID. */
  issueId?: string;
  /** The issue display name. */
  issueDisplayName?: string;
  /** The parent issue model ID. */
  issueModelId?: string;
}

export const GoogleCloudContactcenterinsightsV1mainDimensionIssueDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionIssueDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  issueId: Schema.optional(Schema.String),
  issueDisplayName: Schema.optional(Schema.String),
  issueModelId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDimensionIssueDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionIssueDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainDimensionAgentDimensionMetadata {
  /** Optional. A user-specified string representing the agent. This will be populated for AGENT, AGENT_TEAM, AGENT_VERSION_ID, and AGENT_DEPLOYMENT_ID dimensions. */
  agentId?: string;
  /** Optional. The agent's name This will be populated for AGENT, AGENT_TEAM, AGENT_VERSION_ID, and AGENT_DEPLOYMENT_ID dimensions. */
  agentDisplayName?: string;
  /** Optional. A user-specified string representing the agent's team. */
  agentTeam?: string;
  /** Optional. The agent's version display name. Only applicable to automated agents. This will be populated for AGENT_VERSION_ID, and AGENT_DEPLOYMENT_ID dimensions. */
  agentVersionDisplayName?: string;
  /** Optional. The agent's version ID. Only applicable to automated agents. This will be populated for AGENT_VERSION_ID, and AGENT_DEPLOYMENT_ID dimensions. */
  agentVersionId?: string;
  /** Optional. The agent's deployment display name. Only applicable to automated agents. This will be populated for AGENT_DEPLOYMENT_ID dimensions. */
  agentDeploymentDisplayName?: string;
  /** Optional. The agent's deployment ID. Only applicable to automated agents. This will be populated for AGENT and AGENT_DEPLOYMENT_ID dimensions. */
  agentDeploymentId?: string;
}

export const GoogleCloudContactcenterinsightsV1mainDimensionAgentDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionAgentDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  agentId: Schema.optional(Schema.String),
  agentDisplayName: Schema.optional(Schema.String),
  agentTeam: Schema.optional(Schema.String),
  agentVersionDisplayName: Schema.optional(Schema.String),
  agentVersionId: Schema.optional(Schema.String),
  agentDeploymentDisplayName: Schema.optional(Schema.String),
  agentDeploymentId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDimensionAgentDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionAgentDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainDimensionQaQuestionDimensionMetadata {
  /** Optional. The QA scorecard ID. */
  qaScorecardId?: string;
  /** Optional. The QA question ID. */
  qaQuestionId?: string;
  /** Optional. The full body of the question. */
  questionBody?: string;
}

export const GoogleCloudContactcenterinsightsV1mainDimensionQaQuestionDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionQaQuestionDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  qaScorecardId: Schema.optional(Schema.String),
  qaQuestionId: Schema.optional(Schema.String),
  questionBody: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDimensionQaQuestionDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionQaQuestionDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainDimensionQaQuestionAnswerDimensionMetadata {
  /** Optional. The QA scorecard ID. */
  qaScorecardId?: string;
  /** Optional. The QA question ID. */
  qaQuestionId?: string;
  /** Optional. The full body of the question. */
  questionBody?: string;
  /** Optional. The full body of the question. */
  answerValue?: string;
}

export const GoogleCloudContactcenterinsightsV1mainDimensionQaQuestionAnswerDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionQaQuestionAnswerDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  qaScorecardId: Schema.optional(Schema.String),
  qaQuestionId: Schema.optional(Schema.String),
  questionBody: Schema.optional(Schema.String),
  answerValue: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDimensionQaQuestionAnswerDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionQaQuestionAnswerDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainDimensionQaScorecardDimensionMetadata {
  /** Optional. The QA scorecard ID. */
  qaScorecardId?: string;
}

export const GoogleCloudContactcenterinsightsV1mainDimensionQaScorecardDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionQaScorecardDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  qaScorecardId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDimensionQaScorecardDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionQaScorecardDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainDimensionConversationProfileDimensionMetadata {
  /** Optional. The conversation profile ID. */
  conversationProfileId?: string;
}

export const GoogleCloudContactcenterinsightsV1mainDimensionConversationProfileDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionConversationProfileDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  conversationProfileId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDimensionConversationProfileDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionConversationProfileDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainDimensionMediumDimensionMetadata {
  /** Optional. The conversation medium. Currently supports : PHONE_CALL, CHAT. */
  medium?: string;
}

export const GoogleCloudContactcenterinsightsV1mainDimensionMediumDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionMediumDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  medium: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDimensionMediumDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionMediumDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainDimensionConversationalAgentsPlaybookDimensionMetadata {
  /** Optional. The dialogflow playbook ID. */
  playbookId?: string;
  /** Optional. The dialogflow playbook display name. */
  playbookDisplayName?: string;
}

export const GoogleCloudContactcenterinsightsV1mainDimensionConversationalAgentsPlaybookDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionConversationalAgentsPlaybookDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  playbookId: Schema.optional(Schema.String),
  playbookDisplayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDimensionConversationalAgentsPlaybookDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionConversationalAgentsPlaybookDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainDimensionConversationalAgentsToolDimensionMetadata {
  /** Optional. The dialogflow tool ID. */
  toolId?: string;
  /** Optional. The dialogflow tool display name. */
  toolDisplayName?: string;
}

export const GoogleCloudContactcenterinsightsV1mainDimensionConversationalAgentsToolDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionConversationalAgentsToolDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  toolId: Schema.optional(Schema.String),
  toolDisplayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDimensionConversationalAgentsToolDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionConversationalAgentsToolDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainDimensionClientSentimentCategoryDimensionMetadata {
  /** Optional. The client sentiment category. */
  sentimentCategory?: string;
}

export const GoogleCloudContactcenterinsightsV1mainDimensionClientSentimentCategoryDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionClientSentimentCategoryDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  sentimentCategory: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDimensionClientSentimentCategoryDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionClientSentimentCategoryDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainDimensionLabelDimensionMetadata {
  /** Optional. The label key. */
  labelKey?: string;
  /** Optional. The label value. */
  labelValue?: string;
}

export const GoogleCloudContactcenterinsightsV1mainDimensionLabelDimensionMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionLabelDimensionMetadata> = Schema.suspend(() => Schema.Struct({
  labelKey: Schema.optional(Schema.String),
  labelValue: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDimensionLabelDimensionMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimensionLabelDimensionMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainDimension {
  /** The key of the dimension. */
  dimensionKey?: "DIMENSION_KEY_UNSPECIFIED" | "ISSUE" | "ISSUE_NAME" | "AGENT" | "AGENT_TEAM" | "QA_QUESTION_ID" | "QA_QUESTION_ANSWER_VALUE" | "QA_SCORECARD_ID" | "CONVERSATION_PROFILE_ID" | "MEDIUM" | "CONVERSATIONAL_AGENTS_PLAYBOOK_ID" | "CONVERSATIONAL_AGENTS_PLAYBOOK_NAME" | "CONVERSATIONAL_AGENTS_TOOL_ID" | "CONVERSATIONAL_AGENTS_TOOL_NAME" | "CLIENT_SENTIMENT_CATEGORY" | "AGENT_VERSION_ID" | "AGENT_DEPLOYMENT_ID" | "AGENT_ASSIST_SUPERVISOR_ID" | "LABEL_KEY" | "LABEL_VALUE" | "LABEL_KEY_AND_VALUE" | (string & {});
  /** Output only. Metadata about the issue dimension. */
  issueDimensionMetadata?: GoogleCloudContactcenterinsightsV1mainDimensionIssueDimensionMetadata;
  /** Output only. Metadata about the agent dimension. */
  agentDimensionMetadata?: GoogleCloudContactcenterinsightsV1mainDimensionAgentDimensionMetadata;
  /** Output only. Metadata about the QA question dimension. */
  qaQuestionDimensionMetadata?: GoogleCloudContactcenterinsightsV1mainDimensionQaQuestionDimensionMetadata;
  /** Output only. Metadata about the QA question-answer dimension. */
  qaQuestionAnswerDimensionMetadata?: GoogleCloudContactcenterinsightsV1mainDimensionQaQuestionAnswerDimensionMetadata;
  /** Output only. Metadata about the QA scorecard dimension. */
  qaScorecardDimensionMetadata?: GoogleCloudContactcenterinsightsV1mainDimensionQaScorecardDimensionMetadata;
  /** Output only. Metadata about the conversation profile dimension. */
  conversationProfileDimensionMetadata?: GoogleCloudContactcenterinsightsV1mainDimensionConversationProfileDimensionMetadata;
  /** Output only. Metadata about the conversation medium dimension. */
  mediumDimensionMetadata?: GoogleCloudContactcenterinsightsV1mainDimensionMediumDimensionMetadata;
  /** Output only. Metadata about the Conversational Agents playbook dimension. */
  conversationalAgentsPlaybookDimensionMetadata?: GoogleCloudContactcenterinsightsV1mainDimensionConversationalAgentsPlaybookDimensionMetadata;
  /** Output only. Metadata about the Conversational Agents tool dimension. */
  conversationalAgentsToolDimensionMetadata?: GoogleCloudContactcenterinsightsV1mainDimensionConversationalAgentsToolDimensionMetadata;
  /** Output only. Metadata about the client sentiment category dimension. */
  clientSentimentCategoryDimensionMetadata?: GoogleCloudContactcenterinsightsV1mainDimensionClientSentimentCategoryDimensionMetadata;
  /** Output only. Metadata about conversation labels. */
  labelDimensionMetadata?: GoogleCloudContactcenterinsightsV1mainDimensionLabelDimensionMetadata;
}

export const GoogleCloudContactcenterinsightsV1mainDimension: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimension> = Schema.suspend(() => Schema.Struct({
  dimensionKey: Schema.optional(Schema.String),
  issueDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1mainDimensionIssueDimensionMetadata),
  agentDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1mainDimensionAgentDimensionMetadata),
  qaQuestionDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1mainDimensionQaQuestionDimensionMetadata),
  qaQuestionAnswerDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1mainDimensionQaQuestionAnswerDimensionMetadata),
  qaScorecardDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1mainDimensionQaScorecardDimensionMetadata),
  conversationProfileDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1mainDimensionConversationProfileDimensionMetadata),
  mediumDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1mainDimensionMediumDimensionMetadata),
  conversationalAgentsPlaybookDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1mainDimensionConversationalAgentsPlaybookDimensionMetadata),
  conversationalAgentsToolDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1mainDimensionConversationalAgentsToolDimensionMetadata),
  clientSentimentCategoryDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1mainDimensionClientSentimentCategoryDimensionMetadata),
  labelDimensionMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1mainDimensionLabelDimensionMetadata),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDimension" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDimension>;

export interface GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointConversationMeasureQaTagScore {
  /** Tag name. */
  tag?: string;
  /** Average tag normalized score per tag. */
  averageTagNormalizedScore?: number;
}

export const GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointConversationMeasureQaTagScore: Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointConversationMeasureQaTagScore> = Schema.suspend(() => Schema.Struct({
  tag: Schema.optional(Schema.String),
  averageTagNormalizedScore: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointConversationMeasureQaTagScore" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointConversationMeasureQaTagScore>;

export interface GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointConversationMeasure {
  /** The conversation count. */
  conversationCount?: number;
  /** The average silence percentage. */
  averageSilencePercentage?: number;
  /** The average duration. */
  averageDuration?: string;
  /** The average turn count. */
  averageTurnCount?: number;
  /** The average agent's sentiment score. */
  averageAgentSentimentScore?: number;
  /** The average client's sentiment score. */
  averageClientSentimentScore?: number;
  /** The average customer satisfaction rating. */
  averageCustomerSatisfactionRating?: number;
  /** The average normalized QA score for a scorecard. When computing the average across a set of conversations, if a conversation has been evaluated with multiple revisions of a scorecard, only the latest revision results will be used. Will exclude 0's in average calculation. Will be only populated if the request specifies a dimension of QA_SCORECARD_ID. */
  averageQaNormalizedScore?: number;
  /** Average QA normalized score for all the tags. */
  qaTagScores?: Array<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointConversationMeasureQaTagScore>;
  /** Average QA normalized score averaged for questions averaged across all revisions of the parent scorecard. Will be only populated if the request specifies a dimension of QA_QUESTION_ID. */
  averageQaQuestionNormalizedScore?: number;
  /** Count of knowledge search results (Generative Knowledge Assist) shown to the user. */
  knowledgeSearchResultCount?: number;
  /** Proportion of knowledge search (Generative Knowledge Assist) queries made by the agent compared to the total number of knowledge search queries made. */
  knowledgeSearchAgentQuerySourceRatio?: number;
  /** Proportion of knowledge search (Generative Knowledge Assist) queries suggested compared to the total number of knowledge search queries made. */
  knowledgeSearchSuggestedQuerySourceRatio?: number;
  /** Count of knowledge assist results (Proactive Generative Knowledge Assist) shown to the user. */
  knowledgeAssistResultCount?: number;
  /** Proportion of knowledge search (Generative Knowledge Assist) queries that had a URL clicked. */
  knowledgeSearchUriClickRatio?: number;
  /** Proportion of knowledge assist (Proactive Generative Knowledge Assist) queries that had a URL clicked. */
  knowledgeAssistUriClickRatio?: number;
  /** Proportion of knowledge search (Generative Knowledge Assist) queries that had positive feedback. */
  knowledgeSearchPositiveFeedbackRatio?: number;
  /** Proportion of knowledge search (Generative Knowledge Assist) queries that had negative feedback. */
  knowledgeSearchNegativeFeedbackRatio?: number;
  /** Proportion of knowledge assist (Proactive Generative Knowledge Assist) queries that had positive feedback. */
  knowledgeAssistPositiveFeedbackRatio?: number;
  /** Proportion of knowledge assist (Proactive Generative Knowledge Assist) queries that had negative feedback. */
  knowledgeAssistNegativeFeedbackRatio?: number;
  /** Proportion of summarization suggestions that were manually edited. */
  summarizationSuggestionEditRatio?: number;
  /** Average edit distance of the summarization suggestions. Edit distance (also called as levenshtein distance) is calculated by summing up number of insertions, deletions and substitutions required to transform the summization feedback to the original summary suggestion. */
  averageSummarizationSuggestionEditDistance?: number;
  /** Normalized Average edit distance of the summarization suggestions. Edit distance (also called as levenshtein distance) is calculated by summing up number of insertions, deletions and substitutions required to transform the summization feedback to the original summary suggestion. Normalized edit distance is the average of (edit distance / summary length). */
  averageSummarizationSuggestionNormalizedEditDistance?: number;
  /** Proportion of conversations that had a suggested summary. */
  conversationSuggestedSummaryRatio?: number;
  /** Count of summarization suggestions results. */
  summarizationSuggestionResultCount?: number;
  /** Proportion of dialogflow interactions that has no intent match for the input. */
  dialogflowInteractionsNoMatchRatio?: number;
  /** Proportion of dialogflow interactions that has empty input. */
  dialogflowInteractionsNoInputRatio?: number;
  /** Proportion of dialogflow webhook calls that failed. */
  dialogflowWebhookFailureRatio?: number;
  /** Proportion of dialogflow webhook calls that timed out. */
  dialogflowWebhookTimeoutRatio?: number;
  /** Average latency of dialogflow webhook calls. */
  dialogflowAverageWebhookLatency?: number;
  /** Proportion of conversations that was handed off from virtual agent to human agent. */
  dialogflowConversationsEscalationRatio?: number;
  /** count of conversations that was handed off from virtual agent to human agent. */
  dialogflowConversationsEscalationCount?: number;
  /** The macro average latency of conversational agents' TTS latency per interaction. This is computed as the average of the all the interactions' TTS latencies in a conversation and averaged across conversations. */
  conversationalAgentsAverageTtsLatency?: number;
  /** The average latency of conversational agents' LLM call latency per interaction. This is computed as the average of the all the interactions LLM call latencies in a conversation and averaged across conversations. */
  conversationalAgentsAverageLlmCallLatency?: number;
  /** The average latency of conversational agents' audio in audio out latency per interaction. This is computed as the average of the all the interactions' audio in audio out latencies in a conversation and averaged across conversations. */
  conversationalAgentsAverageAudioInAudioOutLatency?: number;
  /** Proportion of conversations that has Ai Coach Suggestions. */
  conversationAiCoachSuggestionRatio?: number;
  /** Proportion of Ai Coach Suggestion that has been used by agents. */
  aiCoachSuggestionAgentUsageRatio?: number;
  /** Proportion of customer messages that triggered an Ai Coach Suggestion. */
  aiCoachSuggestionCustomerMessageTriggerRatio?: number;
  /** The average latency of conversational agents' latency per interaction. This is computed as the average of the all the iteractions' end to end latencies in a conversation and averaged across conversations. The e2e latency is the time between the end of the user utterance and the start of the agent utterance on the interaction level. */
  conversationalAgentsAverageEndToEndLatency?: number;
  /** Count of conversations that has Ai Coach Suggestions. */
  conversationAiCoachSuggestionCount?: number;
  /** Count of Ai Coach Suggestion that has been used by agents. */
  aiCoachSuggestionAgentUsageCount?: number;
  /** Count of customer messages that triggered an Ai Coach Suggestion. */
  aiCoachSuggestionCustomerMessageTriggerCount?: number;
  /** Count of agent messages that triggered an Ai Coach Suggestion. */
  aiCoachSuggestionAgentMessageTriggerCount?: number;
  /** The customer message count. */
  conversationTotalCustomerMessageCount?: number;
  /** The agent message count. */
  conversationTotalAgentMessageCount?: number;
  /** The number of conversations scanned by the AA human supervisor. */
  aaSupervisorMonitoredConversationsCount?: number;
  /** The number of conversations that were escalated to an AA human supervisor for intervention. */
  aaSupervisorEscalatedConversationsCount?: number;
  /** The number of conversations that were assigned to an AA human supervisor. */
  aaSupervisorAssignedConversationsCount?: number;
  /** The number of conversations that were dropped, i.e. escalated but not assigned to an AA human supervisor. */
  aaSupervisorDroppedConversationsCount?: number;
  /** The number of conversations transferred to a human agent. */
  aaSupervisorTransferredToHumanAgentConvCount?: number;
  /** The exponential moving average of the sentiment score of client turns in the conversation. */
  avgConversationClientTurnSentimentEma?: number;
  /** Proportion of end_of_utterance trigger event messages that triggered an Ai Coach Suggestion. */
  aiCoachSuggestionMessageTriggerRatio?: number;
  /** Count of end_of_utterance trigger event messages that triggered an Ai Coach Suggestion. */
  aiCoachSuggestionMessageTriggerCount?: number;
  /** The number of conversations that were contained. */
  containedConversationCount?: number;
  /** The percentage of conversations that were contained. */
  containedConversationRatio?: number;
}

export const GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointConversationMeasure: Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointConversationMeasure> = Schema.suspend(() => Schema.Struct({
  conversationCount: Schema.optional(Schema.Number),
  averageSilencePercentage: Schema.optional(Schema.Number),
  averageDuration: Schema.optional(Schema.String),
  averageTurnCount: Schema.optional(Schema.Number),
  averageAgentSentimentScore: Schema.optional(Schema.Number),
  averageClientSentimentScore: Schema.optional(Schema.Number),
  averageCustomerSatisfactionRating: Schema.optional(Schema.Number),
  averageQaNormalizedScore: Schema.optional(Schema.Number),
  qaTagScores: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointConversationMeasureQaTagScore)),
  averageQaQuestionNormalizedScore: Schema.optional(Schema.Number),
  knowledgeSearchResultCount: Schema.optional(Schema.Number),
  knowledgeSearchAgentQuerySourceRatio: Schema.optional(Schema.Number),
  knowledgeSearchSuggestedQuerySourceRatio: Schema.optional(Schema.Number),
  knowledgeAssistResultCount: Schema.optional(Schema.Number),
  knowledgeSearchUriClickRatio: Schema.optional(Schema.Number),
  knowledgeAssistUriClickRatio: Schema.optional(Schema.Number),
  knowledgeSearchPositiveFeedbackRatio: Schema.optional(Schema.Number),
  knowledgeSearchNegativeFeedbackRatio: Schema.optional(Schema.Number),
  knowledgeAssistPositiveFeedbackRatio: Schema.optional(Schema.Number),
  knowledgeAssistNegativeFeedbackRatio: Schema.optional(Schema.Number),
  summarizationSuggestionEditRatio: Schema.optional(Schema.Number),
  averageSummarizationSuggestionEditDistance: Schema.optional(Schema.Number),
  averageSummarizationSuggestionNormalizedEditDistance: Schema.optional(Schema.Number),
  conversationSuggestedSummaryRatio: Schema.optional(Schema.Number),
  summarizationSuggestionResultCount: Schema.optional(Schema.Number),
  dialogflowInteractionsNoMatchRatio: Schema.optional(Schema.Number),
  dialogflowInteractionsNoInputRatio: Schema.optional(Schema.Number),
  dialogflowWebhookFailureRatio: Schema.optional(Schema.Number),
  dialogflowWebhookTimeoutRatio: Schema.optional(Schema.Number),
  dialogflowAverageWebhookLatency: Schema.optional(Schema.Number),
  dialogflowConversationsEscalationRatio: Schema.optional(Schema.Number),
  dialogflowConversationsEscalationCount: Schema.optional(Schema.Number),
  conversationalAgentsAverageTtsLatency: Schema.optional(Schema.Number),
  conversationalAgentsAverageLlmCallLatency: Schema.optional(Schema.Number),
  conversationalAgentsAverageAudioInAudioOutLatency: Schema.optional(Schema.Number),
  conversationAiCoachSuggestionRatio: Schema.optional(Schema.Number),
  aiCoachSuggestionAgentUsageRatio: Schema.optional(Schema.Number),
  aiCoachSuggestionCustomerMessageTriggerRatio: Schema.optional(Schema.Number),
  conversationalAgentsAverageEndToEndLatency: Schema.optional(Schema.Number),
  conversationAiCoachSuggestionCount: Schema.optional(Schema.Number),
  aiCoachSuggestionAgentUsageCount: Schema.optional(Schema.Number),
  aiCoachSuggestionCustomerMessageTriggerCount: Schema.optional(Schema.Number),
  aiCoachSuggestionAgentMessageTriggerCount: Schema.optional(Schema.Number),
  conversationTotalCustomerMessageCount: Schema.optional(Schema.Number),
  conversationTotalAgentMessageCount: Schema.optional(Schema.Number),
  aaSupervisorMonitoredConversationsCount: Schema.optional(Schema.Number),
  aaSupervisorEscalatedConversationsCount: Schema.optional(Schema.Number),
  aaSupervisorAssignedConversationsCount: Schema.optional(Schema.Number),
  aaSupervisorDroppedConversationsCount: Schema.optional(Schema.Number),
  aaSupervisorTransferredToHumanAgentConvCount: Schema.optional(Schema.Number),
  avgConversationClientTurnSentimentEma: Schema.optional(Schema.Number),
  aiCoachSuggestionMessageTriggerRatio: Schema.optional(Schema.Number),
  aiCoachSuggestionMessageTriggerCount: Schema.optional(Schema.Number),
  containedConversationCount: Schema.optional(Schema.Number),
  containedConversationRatio: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointConversationMeasure" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointConversationMeasure>;

export interface GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointPercentileResult {
  /** The 50th percentile value. */
  p50?: number;
  /** The 90th percentile value. */
  p90?: number;
  /** The 99th percentile value. */
  p99?: number;
}

export const GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointPercentileResult: Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointPercentileResult> = Schema.suspend(() => Schema.Struct({
  p50: Schema.optional(Schema.Number),
  p90: Schema.optional(Schema.Number),
  p99: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointPercentileResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointPercentileResult>;

export interface GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointDialogflowInteractionMeasure {
  /** The percentile result for audio in audio out latency in milliseconds per dialogflow interaction level. */
  percentileAudioInAudioOutLatency?: GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointPercentileResult;
  /** The percentile result for LLM latency in milliseconds per dialogflow interaction level. */
  percentileLlmCallLatency?: GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointPercentileResult;
  /** The percentile result for TTS latency in milliseconds per dialogflow interaction level. */
  percentileTtsLatency?: GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointPercentileResult;
  /** The percentile result for tool use latency in milliseconds per dialogflow interaction level. */
  percentileToolUseLatency?: GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointPercentileResult;
  /** The percentile result for end to end chat latency in milliseconds per dialogflow interaction level. */
  percentileEndToEndLatency?: GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointPercentileResult;
}

export const GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointDialogflowInteractionMeasure: Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointDialogflowInteractionMeasure> = Schema.suspend(() => Schema.Struct({
  percentileAudioInAudioOutLatency: Schema.optional(GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointPercentileResult),
  percentileLlmCallLatency: Schema.optional(GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointPercentileResult),
  percentileTtsLatency: Schema.optional(GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointPercentileResult),
  percentileToolUseLatency: Schema.optional(GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointPercentileResult),
  percentileEndToEndLatency: Schema.optional(GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointPercentileResult),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointDialogflowInteractionMeasure" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointDialogflowInteractionMeasure>;

export interface GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPoint {
  /** The interval that this data point represents. * If this is the total data point, the interval is [starting create time, ending create time) from the request. * If this a data point from the time series, the interval is [time, time + time granularity from the request). */
  interval?: GoogleTypeInterval;
  /** The measure related to conversations. */
  conversationMeasure?: GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointConversationMeasure;
  /** The measure related to dialogflow interactions. */
  dialogflowInteractionMeasure?: GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointDialogflowInteractionMeasure;
}

export const GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPoint: Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPoint> = Schema.suspend(() => Schema.Struct({
  interval: Schema.optional(GoogleTypeInterval),
  conversationMeasure: Schema.optional(GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointConversationMeasure),
  dialogflowInteractionMeasure: Schema.optional(GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPointDialogflowInteractionMeasure),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPoint" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPoint>;

export interface GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceTimeSeries {
  /** The data points that make up the time series . */
  dataPoints?: Array<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPoint>;
}

export const GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceTimeSeries: Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceTimeSeries> = Schema.suspend(() => Schema.Struct({
  dataPoints: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPoint)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceTimeSeries" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceTimeSeries>;

export interface GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSlice {
  /** A unique combination of dimensions that this slice represents. */
  dimensions?: Array<GoogleCloudContactcenterinsightsV1mainDimension>;
  /** The total metric value. The interval of this data point is [starting create time, ending create time) from the request. */
  total?: GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPoint;
  /** A time series of metric values. This is only populated if the request specifies a time granularity other than NONE. */
  timeSeries?: GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceTimeSeries;
}

export const GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSlice: Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSlice> = Schema.suspend(() => Schema.Struct({
  dimensions: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainDimension)),
  total: Schema.optional(GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceDataPoint),
  timeSeries: Schema.optional(GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSliceTimeSeries),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSlice" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSlice>;

export interface GoogleCloudContactcenterinsightsV1mainQueryMetricsResponse {
  /** Required. The location of the data. "projects/{project}/locations/{location}" */
  location?: string;
  /** The metrics last update time. */
  updateTime?: string;
  /** A slice contains a total and (if the request specified a time granularity) a time series of metric values. Each slice contains a unique combination of the cardinality of dimensions from the request. */
  slices?: Array<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSlice>;
  /** The macro average slice contains aggregated averages across all selected dimensions. i.e. if group_by agent and scorecard_id is specified, this field will contain the average across all agents and all scorecards. This field is only populated if the request specifies a Dimension. */
  macroAverageSlice?: GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSlice;
}

export const GoogleCloudContactcenterinsightsV1mainQueryMetricsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponse> = Schema.suspend(() => Schema.Struct({
  location: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  slices: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSlice)),
  macroAverageSlice: Schema.optional(GoogleCloudContactcenterinsightsV1mainQueryMetricsResponseSlice),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainQueryMetricsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryMetricsResponse>;

export interface GoogleCloudContactcenterinsightsV1mainQueryPerformanceOverviewMetadata {
}

export const GoogleCloudContactcenterinsightsV1mainQueryPerformanceOverviewMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryPerformanceOverviewMetadata> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainQueryPerformanceOverviewMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryPerformanceOverviewMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainQueryPerformanceOverviewResponse {
  /** The summary text of the performance. */
  summaryText?: string;
}

export const GoogleCloudContactcenterinsightsV1mainQueryPerformanceOverviewResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryPerformanceOverviewResponse> = Schema.suspend(() => Schema.Struct({
  summaryText: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainQueryPerformanceOverviewResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainQueryPerformanceOverviewResponse>;

export interface GoogleCloudContactcenterinsightsV1mainSampleRule {
  /** Percentage of conversations that we should sample based on the dimension between [0, 100]. */
  samplePercentage?: number;
  /** Number of the conversations that we should sample based on the dimension. */
  sampleRow?: string;
  /** Optional. Group by dimension to sample the conversation. If no dimension is provided, the sampling will be applied to the project level. Current supported dimensions is 'quality_metadata.agent_info.agent_id'. */
  dimension?: string;
  /** To specify the filter for the conversions that should apply this sample rule. An empty filter means this sample rule applies to all conversations. */
  conversationFilter?: string;
}

export const GoogleCloudContactcenterinsightsV1mainSampleRule: Schema.Schema<GoogleCloudContactcenterinsightsV1mainSampleRule> = Schema.suspend(() => Schema.Struct({
  samplePercentage: Schema.optional(Schema.Number),
  sampleRow: Schema.optional(Schema.String),
  dimension: Schema.optional(Schema.String),
  conversationFilter: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainSampleRule" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainSampleRule>;

export interface GoogleCloudContactcenterinsightsV1mainDataset {
  /** Immutable. Identifier. Resource name of the dataset. Format: projects/{project}/locations/{location}/datasets/{dataset} */
  name?: string;
  /** Display name for the dataaset */
  displayName?: string;
  /** Dataset description. */
  description?: string;
  /** Dataset usage type. */
  type?: "TYPE_UNSPECIFIED" | "EVAL" | "LIVE" | (string & {});
  /** Optional. Option TTL for the dataset. */
  ttl?: string;
  /** Output only. Dataset create time. */
  createTime?: string;
  /** Output only. Dataset update time. */
  updateTime?: string;
}

export const GoogleCloudContactcenterinsightsV1mainDataset: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDataset> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  ttl: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDataset" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDataset>;

export interface GoogleCloudContactcenterinsightsV1mainSampleConversationsRequest {
  /** Required. The parent resource of the dataset. */
  parent?: string;
  /** Optional. The sample rule used for sampling conversations. */
  sampleRule?: GoogleCloudContactcenterinsightsV1mainSampleRule;
  /** The dataset resource to copy the sampled conversations to. */
  destinationDataset?: GoogleCloudContactcenterinsightsV1mainDataset;
}

export const GoogleCloudContactcenterinsightsV1mainSampleConversationsRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1mainSampleConversationsRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  sampleRule: Schema.optional(GoogleCloudContactcenterinsightsV1mainSampleRule),
  destinationDataset: Schema.optional(GoogleCloudContactcenterinsightsV1mainDataset),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainSampleConversationsRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainSampleConversationsRequest>;

export interface GoogleCloudContactcenterinsightsV1mainSampleConversationsMetadataSampleConversationsStats {
  /** Output only. The number of new conversations added during this sample operation. */
  successfulSampleCount?: number;
  /** Output only. The number of objects which were unable to be sampled due to errors. The errors are populated in the partial_errors field. */
  failedSampleCount?: number;
}

export const GoogleCloudContactcenterinsightsV1mainSampleConversationsMetadataSampleConversationsStats: Schema.Schema<GoogleCloudContactcenterinsightsV1mainSampleConversationsMetadataSampleConversationsStats> = Schema.suspend(() => Schema.Struct({
  successfulSampleCount: Schema.optional(Schema.Number),
  failedSampleCount: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainSampleConversationsMetadataSampleConversationsStats" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainSampleConversationsMetadataSampleConversationsStats>;

export interface GoogleCloudContactcenterinsightsV1mainSampleConversationsMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request for sample conversations to dataset. */
  request?: GoogleCloudContactcenterinsightsV1mainSampleConversationsRequest;
  /** Output only. Partial errors during sample conversations operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
  /** Output only. Statistics for SampleConversations operation. */
  sampleConversationsStats?: GoogleCloudContactcenterinsightsV1mainSampleConversationsMetadataSampleConversationsStats;
}

export const GoogleCloudContactcenterinsightsV1mainSampleConversationsMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainSampleConversationsMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1mainSampleConversationsRequest),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
  sampleConversationsStats: Schema.optional(GoogleCloudContactcenterinsightsV1mainSampleConversationsMetadataSampleConversationsStats),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainSampleConversationsMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainSampleConversationsMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainSampleConversationsResponse {
}

export const GoogleCloudContactcenterinsightsV1mainSampleConversationsResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainSampleConversationsResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainSampleConversationsResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainSampleConversationsResponse>;

export interface GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError {
  /** The conversation resource name that had an error during correlation. */
  conversation?: string;
  /** The error status. */
  status?: GoogleRpcStatus;
}

export const GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError: Schema.Schema<GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError> = Schema.suspend(() => Schema.Struct({
  conversation: Schema.optional(Schema.String),
  status: Schema.optional(GoogleRpcStatus),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError>;

export interface GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadataFullConversationCorrelationStats {
  /** The number of conversations sampled. */
  sampledConversationsCount?: number;
  /** The number of conversations correlated. */
  correlatedConversationsCount?: number;
  /** The number of conversations that failed correlation. */
  failedConversationsCount?: number;
  /** Partial errors during test correlation config operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
  /** A list of errors that occurred during correlation, one for each conversation that failed. */
  conversationCorrelationErrors?: Array<GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError>;
}

export const GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadataFullConversationCorrelationStats: Schema.Schema<GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadataFullConversationCorrelationStats> = Schema.suspend(() => Schema.Struct({
  sampledConversationsCount: Schema.optional(Schema.Number),
  correlatedConversationsCount: Schema.optional(Schema.Number),
  failedConversationsCount: Schema.optional(Schema.Number),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
  conversationCorrelationErrors: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadataFullConversationCorrelationStatsConversationCorrelationError)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadataFullConversationCorrelationStats" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadataFullConversationCorrelationStats>;

export interface GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** The dataset used for sampling conversations. */
  dataset?: string;
  /** The statistics for the operation. */
  stats?: GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadataFullConversationCorrelationStats;
}

export const GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  dataset: Schema.optional(Schema.String),
  stats: Schema.optional(GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadataFullConversationCorrelationStats),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainConversationCorrelationResultRuleCorrelationResult {
  /** The rule ID. */
  ruleId?: string;
  /** The correlation ID generated by the join key expression. */
  correlationId?: string;
  /** The error status if the join key expression failed to evaluate. */
  error?: GoogleRpcStatus;
}

export const GoogleCloudContactcenterinsightsV1mainConversationCorrelationResultRuleCorrelationResult: Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationCorrelationResultRuleCorrelationResult> = Schema.suspend(() => Schema.Struct({
  ruleId: Schema.optional(Schema.String),
  correlationId: Schema.optional(Schema.String),
  error: Schema.optional(GoogleRpcStatus),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainConversationCorrelationResultRuleCorrelationResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationCorrelationResultRuleCorrelationResult>;

export interface GoogleCloudContactcenterinsightsV1mainConversationCorrelationResult {
  /** The conversation resource name. */
  conversation?: string;
  /** The results for each correlation rule. */
  ruleResults?: Array<GoogleCloudContactcenterinsightsV1mainConversationCorrelationResultRuleCorrelationResult>;
}

export const GoogleCloudContactcenterinsightsV1mainConversationCorrelationResult: Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationCorrelationResult> = Schema.suspend(() => Schema.Struct({
  conversation: Schema.optional(Schema.String),
  ruleResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainConversationCorrelationResultRuleCorrelationResult)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainConversationCorrelationResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationCorrelationResult>;

export interface GoogleCloudContactcenterinsightsV1mainConstraintEvaluationResultRuleConstraintResult {
  /** The rule ID. */
  ruleId?: string;
  /** Whether the constraint expression evaluated to true for (A, B) or (B, A). */
  constraintMet?: boolean;
  /** The error status if the constraint expression failed to evaluate. */
  error?: GoogleRpcStatus;
}

export const GoogleCloudContactcenterinsightsV1mainConstraintEvaluationResultRuleConstraintResult: Schema.Schema<GoogleCloudContactcenterinsightsV1mainConstraintEvaluationResultRuleConstraintResult> = Schema.suspend(() => Schema.Struct({
  ruleId: Schema.optional(Schema.String),
  constraintMet: Schema.optional(Schema.Boolean),
  error: Schema.optional(GoogleRpcStatus),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainConstraintEvaluationResultRuleConstraintResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainConstraintEvaluationResultRuleConstraintResult>;

export interface GoogleCloudContactcenterinsightsV1mainConstraintEvaluationResult {
  /** The first conversation resource name. */
  conversationA?: string;
  /** The second conversation resource name. */
  conversationB?: string;
  /** The results for each applicable constraint rule. */
  ruleConstraintResults?: Array<GoogleCloudContactcenterinsightsV1mainConstraintEvaluationResultRuleConstraintResult>;
}

export const GoogleCloudContactcenterinsightsV1mainConstraintEvaluationResult: Schema.Schema<GoogleCloudContactcenterinsightsV1mainConstraintEvaluationResult> = Schema.suspend(() => Schema.Struct({
  conversationA: Schema.optional(Schema.String),
  conversationB: Schema.optional(Schema.String),
  ruleConstraintResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainConstraintEvaluationResultRuleConstraintResult)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainConstraintEvaluationResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainConstraintEvaluationResult>;

export interface GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigResponseDetailedCorrelationResults {
  /** A list of join key correlation results for each conversation tested. */
  joinKeyResults?: Array<GoogleCloudContactcenterinsightsV1mainConversationCorrelationResult>;
  /** A list of constraint evaluation results for each pair of conversations. */
  constraintResults?: Array<GoogleCloudContactcenterinsightsV1mainConstraintEvaluationResult>;
}

export const GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigResponseDetailedCorrelationResults: Schema.Schema<GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigResponseDetailedCorrelationResults> = Schema.suspend(() => Schema.Struct({
  joinKeyResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainConversationCorrelationResult)),
  constraintResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainConstraintEvaluationResult)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigResponseDetailedCorrelationResults" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigResponseDetailedCorrelationResults>;

export interface GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigResponse {
  /** Results for the DETAILED_SYNC execution mode. */
  detailedResults?: GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigResponseDetailedCorrelationResults;
  /** Partial errors during test correlation config operation that might cause the operation output to be incomplete. */
  partialErrors?: Array<GoogleRpcStatus>;
}

export const GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigResponse> = Schema.suspend(() => Schema.Struct({
  detailedResults: Schema.optional(GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigResponseDetailedCorrelationResults),
  partialErrors: Schema.optional(Schema.Array(GoogleRpcStatus)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainTestCorrelationConfigResponse>;

export interface GoogleCloudContactcenterinsightsV1mainUndeployIssueModelRequest {
  /** Required. The issue model to undeploy. */
  name?: string;
}

export const GoogleCloudContactcenterinsightsV1mainUndeployIssueModelRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1mainUndeployIssueModelRequest> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainUndeployIssueModelRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainUndeployIssueModelRequest>;

export interface GoogleCloudContactcenterinsightsV1mainUndeployIssueModelMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** The original request for undeployment. */
  request?: GoogleCloudContactcenterinsightsV1mainUndeployIssueModelRequest;
}

export const GoogleCloudContactcenterinsightsV1mainUndeployIssueModelMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainUndeployIssueModelMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1mainUndeployIssueModelRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainUndeployIssueModelMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainUndeployIssueModelMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainUndeployIssueModelResponse {
}

export const GoogleCloudContactcenterinsightsV1mainUndeployIssueModelResponse: Schema.Schema<GoogleCloudContactcenterinsightsV1mainUndeployIssueModelResponse> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainUndeployIssueModelResponse" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainUndeployIssueModelResponse>;

export interface GoogleCloudContactcenterinsightsV1mainQaQuestionTag {
  /** Identifier. Resource name for the QaQuestionTag Format projects/{project}/locations/{location}/qaQuestionTags/{qa_question_tag} In the above format, the last segment, i.e., qa_question_tag, is a server-generated ID corresponding to the tag resource. */
  name?: string;
  /** Required. A user-specified display name for the tag. */
  displayName?: string;
  /** Optional. The list of Scorecard Question IDs that the tag applies to. Each QaQuestionId is represented as a full resource name containing the Question ID. Lastly, Since a tag may not necessarily be referenced by any Scorecard Questions, we treat this field as optional. */
  qaQuestionIds?: Array<string>;
  /** Output only. The time at which the question tag was created. */
  createTime?: string;
  /** Output only. The most recent time at which the question tag was updated. */
  updateTime?: string;
}

export const GoogleCloudContactcenterinsightsV1mainQaQuestionTag: Schema.Schema<GoogleCloudContactcenterinsightsV1mainQaQuestionTag> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  qaQuestionIds: Schema.optional(Schema.Array(Schema.String)),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainQaQuestionTag" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainQaQuestionTag>;

export interface GoogleCloudContactcenterinsightsV1mainUpdateQaQuestionTagRequest {
  /** Required. The QaQuestionTag to update. */
  qaQuestionTag?: GoogleCloudContactcenterinsightsV1mainQaQuestionTag;
  /** Optional. The list of fields to be updated. All possible fields can be updated by passing `*`, or a subset of the following updateable fields can be provided: * `qa_question_tag_name` - the name of the tag * `qa_question_ids` - the list of questions the tag applies to */
  updateMask?: string;
}

export const GoogleCloudContactcenterinsightsV1mainUpdateQaQuestionTagRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1mainUpdateQaQuestionTagRequest> = Schema.suspend(() => Schema.Struct({
  qaQuestionTag: Schema.optional(GoogleCloudContactcenterinsightsV1mainQaQuestionTag),
  updateMask: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainUpdateQaQuestionTagRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainUpdateQaQuestionTagRequest>;

export interface GoogleCloudContactcenterinsightsV1mainUpdateQaQuestionTagMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request. */
  request?: GoogleCloudContactcenterinsightsV1mainUpdateQaQuestionTagRequest;
}

export const GoogleCloudContactcenterinsightsV1mainUpdateQaQuestionTagMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainUpdateQaQuestionTagMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1mainUpdateQaQuestionTagRequest),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainUpdateQaQuestionTagMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainUpdateQaQuestionTagMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainGcsSource {
  /** Cloud Storage URI that points to a file that contains the conversation audio. */
  audioUri?: string;
  /** Immutable. Cloud Storage URI that points to a file that contains the conversation transcript. */
  transcriptUri?: string;
}

export const GoogleCloudContactcenterinsightsV1mainGcsSource: Schema.Schema<GoogleCloudContactcenterinsightsV1mainGcsSource> = Schema.suspend(() => Schema.Struct({
  audioUri: Schema.optional(Schema.String),
  transcriptUri: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainGcsSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainGcsSource>;

export interface GoogleCloudContactcenterinsightsV1mainDialogflowSource {
  /** Output only. The name of the Dialogflow conversation that this conversation resource is derived from. Format: projects/{project}/locations/{location}/conversations/{conversation} */
  dialogflowConversation?: string;
  /** Cloud Storage URI that points to a file that contains the conversation audio. */
  audioUri?: string;
}

export const GoogleCloudContactcenterinsightsV1mainDialogflowSource: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDialogflowSource> = Schema.suspend(() => Schema.Struct({
  dialogflowConversation: Schema.optional(Schema.String),
  audioUri: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDialogflowSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDialogflowSource>;

export interface GoogleCloudContactcenterinsightsV1mainConversationDataSource {
  /** A Cloud Storage location specification for the audio and transcript. */
  gcsSource?: GoogleCloudContactcenterinsightsV1mainGcsSource;
  /** The source when the conversation comes from Dialogflow. */
  dialogflowSource?: GoogleCloudContactcenterinsightsV1mainDialogflowSource;
  /** Cloud Storage URI that points to a file that contains the conversation metadata. */
  metadataUri?: string;
}

export const GoogleCloudContactcenterinsightsV1mainConversationDataSource: Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationDataSource> = Schema.suspend(() => Schema.Struct({
  gcsSource: Schema.optional(GoogleCloudContactcenterinsightsV1mainGcsSource),
  dialogflowSource: Schema.optional(GoogleCloudContactcenterinsightsV1mainDialogflowSource),
  metadataUri: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainConversationDataSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationDataSource>;

export interface GoogleCloudContactcenterinsightsV1mainConversationCallMetadata {
  /** The audio channel that contains the customer. */
  customerChannel?: number;
  /** The audio channel that contains the agent. */
  agentChannel?: number;
}

export const GoogleCloudContactcenterinsightsV1mainConversationCallMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationCallMetadata> = Schema.suspend(() => Schema.Struct({
  customerChannel: Schema.optional(Schema.Number),
  agentChannel: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainConversationCallMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationCallMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainConversationQualityMetadataAgentInfo {
  /** A user-specified string representing the agent. */
  agentId?: string;
  /** The agent's name. */
  displayName?: string;
  /** A user-specified string representing the agent's team. Deprecated in favor of the `teams` field. */
  team?: string;
  /** User-specified strings representing the agent's teams. */
  teams?: Array<string>;
  /** A user-provided string indicating the outcome of the agent's segment of the call. */
  dispositionCode?: string;
  /** The agent type, e.g. HUMAN_AGENT. */
  agentType?: "ROLE_UNSPECIFIED" | "HUMAN_AGENT" | "AUTOMATED_AGENT" | "END_USER" | "ANY_AGENT" | (string & {});
  /** The agent's location. */
  location?: string;
  /** The agent's deployment ID. Only applicable to automated agents. */
  deploymentId?: string;
  /** The agent's deployment display name. Only applicable to automated agents. */
  deploymentDisplayName?: string;
  /** The agent's version ID. Only applicable to automated agents. */
  versionId?: string;
  /** The agent's version display name. Only applicable to automated agents. */
  versionDisplayName?: string;
}

export const GoogleCloudContactcenterinsightsV1mainConversationQualityMetadataAgentInfo: Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationQualityMetadataAgentInfo> = Schema.suspend(() => Schema.Struct({
  agentId: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  team: Schema.optional(Schema.String),
  teams: Schema.optional(Schema.Array(Schema.String)),
  dispositionCode: Schema.optional(Schema.String),
  agentType: Schema.optional(Schema.String),
  location: Schema.optional(Schema.String),
  deploymentId: Schema.optional(Schema.String),
  deploymentDisplayName: Schema.optional(Schema.String),
  versionId: Schema.optional(Schema.String),
  versionDisplayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainConversationQualityMetadataAgentInfo" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationQualityMetadataAgentInfo>;

export interface GoogleCloudContactcenterinsightsV1mainConversationQualityMetadata {
  /** An arbitrary integer value indicating the customer's satisfaction rating. */
  customerSatisfactionRating?: number;
  /** The amount of time the customer waited to connect with an agent. */
  waitDuration?: string;
  /** An arbitrary string value specifying the menu path the customer took. */
  menuPath?: string;
  /** Information about agents involved in the call. */
  agentInfo?: Array<GoogleCloudContactcenterinsightsV1mainConversationQualityMetadataAgentInfo>;
  /** Input only. The feedback labels associated with the conversation. */
  feedbackLabels?: Array<GoogleCloudContactcenterinsightsV1mainFeedbackLabel>;
}

export const GoogleCloudContactcenterinsightsV1mainConversationQualityMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationQualityMetadata> = Schema.suspend(() => Schema.Struct({
  customerSatisfactionRating: Schema.optional(Schema.Number),
  waitDuration: Schema.optional(Schema.String),
  menuPath: Schema.optional(Schema.String),
  agentInfo: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainConversationQualityMetadataAgentInfo)),
  feedbackLabels: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainFeedbackLabel)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainConversationQualityMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationQualityMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegmentWordInfo {
  /** Time offset of the start of this word relative to the beginning of the total conversation. */
  startOffset?: string;
  /** Time offset of the end of this word relative to the beginning of the total conversation. */
  endOffset?: string;
  /** The word itself. Includes punctuation marks that surround the word. */
  word?: string;
  /** A confidence estimate between 0.0 and 1.0 of the fidelity of this word. A default value of 0.0 indicates that the value is unset. */
  confidence?: number;
}

export const GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegmentWordInfo: Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegmentWordInfo> = Schema.suspend(() => Schema.Struct({
  startOffset: Schema.optional(Schema.String),
  endOffset: Schema.optional(Schema.String),
  word: Schema.optional(Schema.String),
  confidence: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegmentWordInfo" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegmentWordInfo>;

export interface GoogleCloudContactcenterinsightsV1mainConversationParticipant {
  /** Deprecated. Use `dialogflow_participant_name` instead. The name of the Dialogflow participant. Format: projects/{project}/locations/{location}/conversations/{conversation}/participants/{participant} */
  dialogflowParticipant?: string;
  /** The name of the participant provided by Dialogflow. Format: projects/{project}/locations/{location}/conversations/{conversation}/participants/{participant} */
  dialogflowParticipantName?: string;
  /** A user-specified ID representing the participant. */
  userId?: string;
  /** Obfuscated user ID from Dialogflow. */
  obfuscatedExternalUserId?: string;
  /** The role of the participant. */
  role?: "ROLE_UNSPECIFIED" | "HUMAN_AGENT" | "AUTOMATED_AGENT" | "END_USER" | "ANY_AGENT" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1mainConversationParticipant: Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationParticipant> = Schema.suspend(() => Schema.Struct({
  dialogflowParticipant: Schema.optional(Schema.String),
  dialogflowParticipantName: Schema.optional(Schema.String),
  userId: Schema.optional(Schema.String),
  obfuscatedExternalUserId: Schema.optional(Schema.String),
  role: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainConversationParticipant" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationParticipant>;

export interface GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata {
  /** Whether the transcript segment was covered under the configured smart reply allowlist in Agent Assist. */
  smartReplyAllowlistCovered?: boolean;
}

export const GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata> = Schema.suspend(() => Schema.Struct({
  smartReplyAllowlistCovered: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainSentimentData {
  /** A non-negative number from 0 to infinity which represents the absolute magnitude of sentiment regardless of score. */
  magnitude?: number;
  /** The sentiment score between -1.0 (negative) and 1.0 (positive). */
  score?: number;
}

export const GoogleCloudContactcenterinsightsV1mainSentimentData: Schema.Schema<GoogleCloudContactcenterinsightsV1mainSentimentData> = Schema.suspend(() => Schema.Struct({
  magnitude: Schema.optional(Schema.Number),
  score: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainSentimentData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainSentimentData>;

export interface GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegment {
  /** The time that the message occurred, if provided. */
  messageTime?: string;
  /** The text of this segment. */
  text?: string;
  /** A confidence estimate between 0.0 and 1.0 of the fidelity of this segment. A default value of 0.0 indicates that the value is unset. */
  confidence?: number;
  /** A list of the word-specific information for each word in the segment. */
  words?: Array<GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegmentWordInfo>;
  /** The language code of this segment as a [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag. Example: "en-US". */
  languageCode?: string;
  /** For conversations derived from multi-channel audio, this is the channel number corresponding to the audio from that channel. For audioChannelCount = N, its output values can range from '1' to 'N'. A channel tag of 0 indicates that the audio is mono. */
  channelTag?: number;
  /** The participant of this segment. */
  segmentParticipant?: GoogleCloudContactcenterinsightsV1mainConversationParticipant;
  /** CCAI metadata relating to the current transcript segment. */
  dialogflowSegmentMetadata?: GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata;
  /** The sentiment for this transcript segment. */
  sentiment?: GoogleCloudContactcenterinsightsV1mainSentimentData;
}

export const GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegment: Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegment> = Schema.suspend(() => Schema.Struct({
  messageTime: Schema.optional(Schema.String),
  text: Schema.optional(Schema.String),
  confidence: Schema.optional(Schema.Number),
  words: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegmentWordInfo)),
  languageCode: Schema.optional(Schema.String),
  channelTag: Schema.optional(Schema.Number),
  segmentParticipant: Schema.optional(GoogleCloudContactcenterinsightsV1mainConversationParticipant),
  dialogflowSegmentMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegmentDialogflowSegmentMetadata),
  sentiment: Schema.optional(GoogleCloudContactcenterinsightsV1mainSentimentData),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegment" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegment>;

export interface GoogleCloudContactcenterinsightsV1mainConversationTranscript {
  /** A list of sequential transcript segments that comprise the conversation. */
  transcriptSegments?: Array<GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegment>;
}

export const GoogleCloudContactcenterinsightsV1mainConversationTranscript: Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationTranscript> = Schema.suspend(() => Schema.Struct({
  transcriptSegments: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainConversationTranscriptTranscriptSegment)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainConversationTranscript" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationTranscript>;

export interface GoogleCloudContactcenterinsightsV1mainAnnotationBoundary {
  /** The index in the sequence of transcribed pieces of the conversation where the boundary is located. This index starts at zero. */
  transcriptIndex?: number;
  /** The word index of this boundary with respect to the first word in the transcript piece. This index starts at zero. */
  wordIndex?: number;
}

export const GoogleCloudContactcenterinsightsV1mainAnnotationBoundary: Schema.Schema<GoogleCloudContactcenterinsightsV1mainAnnotationBoundary> = Schema.suspend(() => Schema.Struct({
  transcriptIndex: Schema.optional(Schema.Number),
  wordIndex: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainAnnotationBoundary" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainAnnotationBoundary>;

export interface GoogleCloudContactcenterinsightsV1mainInterruptionData {
}

export const GoogleCloudContactcenterinsightsV1mainInterruptionData: Schema.Schema<GoogleCloudContactcenterinsightsV1mainInterruptionData> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainInterruptionData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainInterruptionData>;

export interface GoogleCloudContactcenterinsightsV1mainSilenceData {
}

export const GoogleCloudContactcenterinsightsV1mainSilenceData: Schema.Schema<GoogleCloudContactcenterinsightsV1mainSilenceData> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainSilenceData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainSilenceData>;

export interface GoogleCloudContactcenterinsightsV1mainHoldData {
}

export const GoogleCloudContactcenterinsightsV1mainHoldData: Schema.Schema<GoogleCloudContactcenterinsightsV1mainHoldData> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainHoldData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainHoldData>;

export interface GoogleCloudContactcenterinsightsV1mainEntityMentionData {
  /** The key of this entity in conversation entities. Can be used to retrieve the exact `Entity` this mention is attached to. */
  entityUniqueId?: string;
  /** The type of the entity mention. */
  type?: "MENTION_TYPE_UNSPECIFIED" | "PROPER" | "COMMON" | (string & {});
  /** Sentiment expressed for this mention of the entity. */
  sentiment?: GoogleCloudContactcenterinsightsV1mainSentimentData;
}

export const GoogleCloudContactcenterinsightsV1mainEntityMentionData: Schema.Schema<GoogleCloudContactcenterinsightsV1mainEntityMentionData> = Schema.suspend(() => Schema.Struct({
  entityUniqueId: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  sentiment: Schema.optional(GoogleCloudContactcenterinsightsV1mainSentimentData),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainEntityMentionData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainEntityMentionData>;

export interface GoogleCloudContactcenterinsightsV1mainIntentMatchData {
  /** The id of the matched intent. Can be used to retrieve the corresponding intent information. */
  intentUniqueId?: string;
}

export const GoogleCloudContactcenterinsightsV1mainIntentMatchData: Schema.Schema<GoogleCloudContactcenterinsightsV1mainIntentMatchData> = Schema.suspend(() => Schema.Struct({
  intentUniqueId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainIntentMatchData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainIntentMatchData>;

export interface GoogleCloudContactcenterinsightsV1mainPhraseMatchData {
  /** The unique identifier (the resource name) of the phrase matcher. */
  phraseMatcher?: string;
  /** The human-readable name of the phrase matcher. */
  displayName?: string;
}

export const GoogleCloudContactcenterinsightsV1mainPhraseMatchData: Schema.Schema<GoogleCloudContactcenterinsightsV1mainPhraseMatchData> = Schema.suspend(() => Schema.Struct({
  phraseMatcher: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainPhraseMatchData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainPhraseMatchData>;

export interface GoogleCloudContactcenterinsightsV1mainIssueAssignment {
  /** Resource name of the assigned issue. */
  issue?: string;
  /** Score indicating the likelihood of the issue assignment. currently bounded on [0,1]. */
  score?: number;
  /** Immutable. Display name of the assigned issue. This field is set at time of analysis and immutable since then. */
  displayName?: string;
}

export const GoogleCloudContactcenterinsightsV1mainIssueAssignment: Schema.Schema<GoogleCloudContactcenterinsightsV1mainIssueAssignment> = Schema.suspend(() => Schema.Struct({
  issue: Schema.optional(Schema.String),
  score: Schema.optional(Schema.Number),
  displayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainIssueAssignment" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainIssueAssignment>;

export interface GoogleCloudContactcenterinsightsV1mainIssueMatchData {
  /** Information about the issue's assignment. */
  issueAssignment?: GoogleCloudContactcenterinsightsV1mainIssueAssignment;
}

export const GoogleCloudContactcenterinsightsV1mainIssueMatchData: Schema.Schema<GoogleCloudContactcenterinsightsV1mainIssueMatchData> = Schema.suspend(() => Schema.Struct({
  issueAssignment: Schema.optional(GoogleCloudContactcenterinsightsV1mainIssueAssignment),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainIssueMatchData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainIssueMatchData>;

export interface GoogleCloudContactcenterinsightsV1mainCallAnnotation {
  /** The channel of the audio where the annotation occurs. For single-channel audio, this field is not populated. */
  channelTag?: number;
  /** The boundary in the conversation where the annotation starts, inclusive. */
  annotationStartBoundary?: GoogleCloudContactcenterinsightsV1mainAnnotationBoundary;
  /** The boundary in the conversation where the annotation ends, inclusive. */
  annotationEndBoundary?: GoogleCloudContactcenterinsightsV1mainAnnotationBoundary;
  /** Data specifying an interruption. */
  interruptionData?: GoogleCloudContactcenterinsightsV1mainInterruptionData;
  /** Data specifying sentiment. */
  sentimentData?: GoogleCloudContactcenterinsightsV1mainSentimentData;
  /** Data specifying silence. */
  silenceData?: GoogleCloudContactcenterinsightsV1mainSilenceData;
  /** Data specifying a hold. */
  holdData?: GoogleCloudContactcenterinsightsV1mainHoldData;
  /** Data specifying an entity mention. */
  entityMentionData?: GoogleCloudContactcenterinsightsV1mainEntityMentionData;
  /** Data specifying an intent match. */
  intentMatchData?: GoogleCloudContactcenterinsightsV1mainIntentMatchData;
  /** Data specifying a phrase match. */
  phraseMatchData?: GoogleCloudContactcenterinsightsV1mainPhraseMatchData;
  /** Data specifying an issue match. */
  issueMatchData?: GoogleCloudContactcenterinsightsV1mainIssueMatchData;
}

export const GoogleCloudContactcenterinsightsV1mainCallAnnotation: Schema.Schema<GoogleCloudContactcenterinsightsV1mainCallAnnotation> = Schema.suspend(() => Schema.Struct({
  channelTag: Schema.optional(Schema.Number),
  annotationStartBoundary: Schema.optional(GoogleCloudContactcenterinsightsV1mainAnnotationBoundary),
  annotationEndBoundary: Schema.optional(GoogleCloudContactcenterinsightsV1mainAnnotationBoundary),
  interruptionData: Schema.optional(GoogleCloudContactcenterinsightsV1mainInterruptionData),
  sentimentData: Schema.optional(GoogleCloudContactcenterinsightsV1mainSentimentData),
  silenceData: Schema.optional(GoogleCloudContactcenterinsightsV1mainSilenceData),
  holdData: Schema.optional(GoogleCloudContactcenterinsightsV1mainHoldData),
  entityMentionData: Schema.optional(GoogleCloudContactcenterinsightsV1mainEntityMentionData),
  intentMatchData: Schema.optional(GoogleCloudContactcenterinsightsV1mainIntentMatchData),
  phraseMatchData: Schema.optional(GoogleCloudContactcenterinsightsV1mainPhraseMatchData),
  issueMatchData: Schema.optional(GoogleCloudContactcenterinsightsV1mainIssueMatchData),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainCallAnnotation" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainCallAnnotation>;

export interface GoogleCloudContactcenterinsightsV1mainEntity {
  /** The representative name for the entity. */
  displayName?: string;
  /** The entity type. */
  type?: "TYPE_UNSPECIFIED" | "PERSON" | "LOCATION" | "ORGANIZATION" | "EVENT" | "WORK_OF_ART" | "CONSUMER_GOOD" | "OTHER" | "PHONE_NUMBER" | "ADDRESS" | "DATE" | "NUMBER" | "PRICE" | (string & {});
  /** Metadata associated with the entity. For most entity types, the metadata is a Wikipedia URL (`wikipedia_url`) and Knowledge Graph MID (`mid`), if they are available. For the metadata associated with other entity types, see the Type table below. */
  metadata?: Record<string, string>;
  /** The salience score associated with the entity in the [0, 1.0] range. The salience score for an entity provides information about the importance or centrality of that entity to the entire document text. Scores closer to 0 are less salient, while scores closer to 1.0 are highly salient. */
  salience?: number;
  /** The aggregate sentiment expressed for this entity in the conversation. */
  sentiment?: GoogleCloudContactcenterinsightsV1mainSentimentData;
}

export const GoogleCloudContactcenterinsightsV1mainEntity: Schema.Schema<GoogleCloudContactcenterinsightsV1mainEntity> = Schema.suspend(() => Schema.Struct({
  displayName: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  salience: Schema.optional(Schema.Number),
  sentiment: Schema.optional(GoogleCloudContactcenterinsightsV1mainSentimentData),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainEntity" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainEntity>;

export interface GoogleCloudContactcenterinsightsV1mainConversationLevelSentiment {
  /** The channel of the audio that the data applies to. */
  channelTag?: number;
  /** Data specifying sentiment. */
  sentimentData?: GoogleCloudContactcenterinsightsV1mainSentimentData;
}

export const GoogleCloudContactcenterinsightsV1mainConversationLevelSentiment: Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationLevelSentiment> = Schema.suspend(() => Schema.Struct({
  channelTag: Schema.optional(Schema.Number),
  sentimentData: Schema.optional(GoogleCloudContactcenterinsightsV1mainSentimentData),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainConversationLevelSentiment" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationLevelSentiment>;

export interface GoogleCloudContactcenterinsightsV1mainConversationLevelSilence {
  /** Amount of time calculated to be in silence. */
  silenceDuration?: string;
  /** Percentage of the total conversation spent in silence. */
  silencePercentage?: number;
}

export const GoogleCloudContactcenterinsightsV1mainConversationLevelSilence: Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationLevelSilence> = Schema.suspend(() => Schema.Struct({
  silenceDuration: Schema.optional(Schema.String),
  silencePercentage: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainConversationLevelSilence" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationLevelSilence>;

export interface GoogleCloudContactcenterinsightsV1mainIntent {
  /** The unique identifier of the intent. */
  id?: string;
  /** The human-readable name of the intent. */
  displayName?: string;
}

export const GoogleCloudContactcenterinsightsV1mainIntent: Schema.Schema<GoogleCloudContactcenterinsightsV1mainIntent> = Schema.suspend(() => Schema.Struct({
  id: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainIntent" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainIntent>;

export interface GoogleCloudContactcenterinsightsV1mainIssueModelResult {
  /** Issue model that generates the result. Format: projects/{project}/locations/{location}/issueModels/{issue_model} */
  issueModel?: string;
  /** All the matched issues. */
  issues?: Array<GoogleCloudContactcenterinsightsV1mainIssueAssignment>;
}

export const GoogleCloudContactcenterinsightsV1mainIssueModelResult: Schema.Schema<GoogleCloudContactcenterinsightsV1mainIssueModelResult> = Schema.suspend(() => Schema.Struct({
  issueModel: Schema.optional(Schema.String),
  issues: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainIssueAssignment)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainIssueModelResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainIssueModelResult>;

export interface GoogleCloudContactcenterinsightsV1mainQaAnswerAnswerSource {
  /** What created the answer. */
  sourceType?: "SOURCE_TYPE_UNSPECIFIED" | "SYSTEM_GENERATED" | "MANUAL_EDIT" | (string & {});
  /** The answer value from this source. This field is populated by default, unless the question has a selection strategy configured to return multiple answer values, in which case `answer_values` will be populated instead. */
  answerValue?: GoogleCloudContactcenterinsightsV1mainQaAnswerAnswerValue;
}

export const GoogleCloudContactcenterinsightsV1mainQaAnswerAnswerSource: Schema.Schema<GoogleCloudContactcenterinsightsV1mainQaAnswerAnswerSource> = Schema.suspend(() => Schema.Struct({
  sourceType: Schema.optional(Schema.String),
  answerValue: Schema.optional(GoogleCloudContactcenterinsightsV1mainQaAnswerAnswerValue),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainQaAnswerAnswerSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainQaAnswerAnswerSource>;

export interface GoogleCloudContactcenterinsightsV1mainQaAnswer {
  /** The QaQuestion answered by this answer. */
  qaQuestion?: string;
  /** The conversation the answer applies to. */
  conversation?: string;
  /** Question text. E.g., "Did the agent greet the customer?" */
  questionBody?: string;
  /** The answer value from this source. This field is populated by default, unless the question has a selection strategy configured to return multiple answer values, in which case `answer_values` will be populated instead. */
  answerValue?: GoogleCloudContactcenterinsightsV1mainQaAnswerAnswerValue;
  /** User-defined list of arbitrary tags. Matches the value from QaScorecard.ScorecardQuestion.tags. Used for grouping/organization and for weighting the score of each answer. */
  tags?: Array<string>;
  /** Lists all answer sources containing one or more answer values of a specific source type, e.g., all system-generated answer sources, or all manual edit answer sources. */
  answerSources?: Array<GoogleCloudContactcenterinsightsV1mainQaAnswerAnswerSource>;
}

export const GoogleCloudContactcenterinsightsV1mainQaAnswer: Schema.Schema<GoogleCloudContactcenterinsightsV1mainQaAnswer> = Schema.suspend(() => Schema.Struct({
  qaQuestion: Schema.optional(Schema.String),
  conversation: Schema.optional(Schema.String),
  questionBody: Schema.optional(Schema.String),
  answerValue: Schema.optional(GoogleCloudContactcenterinsightsV1mainQaAnswerAnswerValue),
  tags: Schema.optional(Schema.Array(Schema.String)),
  answerSources: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainQaAnswerAnswerSource)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainQaAnswer" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainQaAnswer>;

export interface GoogleCloudContactcenterinsightsV1mainQaScorecardResultQaTagResult {
  /** The tag the score applies to. */
  tag?: string;
  /** The score the tag applies to. */
  score?: number;
  /** The potential score the tag applies to. */
  potentialScore?: number;
  /** The normalized score the tag applies to. */
  normalizedScore?: number;
}

export const GoogleCloudContactcenterinsightsV1mainQaScorecardResultQaTagResult: Schema.Schema<GoogleCloudContactcenterinsightsV1mainQaScorecardResultQaTagResult> = Schema.suspend(() => Schema.Struct({
  tag: Schema.optional(Schema.String),
  score: Schema.optional(Schema.Number),
  potentialScore: Schema.optional(Schema.Number),
  normalizedScore: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainQaScorecardResultQaTagResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainQaScorecardResultQaTagResult>;

export interface GoogleCloudContactcenterinsightsV1mainQaScorecardResultScoreSource {
  /** What created the score. */
  sourceType?: "SOURCE_TYPE_UNSPECIFIED" | "SYSTEM_GENERATED_ONLY" | "INCLUDES_MANUAL_EDITS" | (string & {});
  /** The overall numerical score of the result. */
  score?: number;
  /** The maximum potential overall score of the scorecard. Any questions answered using `na_value` are excluded from this calculation. */
  potentialScore?: number;
  /** The normalized score, which is the score divided by the potential score. */
  normalizedScore?: number;
  /** Collection of tags and their scores. */
  qaTagResults?: Array<GoogleCloudContactcenterinsightsV1mainQaScorecardResultQaTagResult>;
}

export const GoogleCloudContactcenterinsightsV1mainQaScorecardResultScoreSource: Schema.Schema<GoogleCloudContactcenterinsightsV1mainQaScorecardResultScoreSource> = Schema.suspend(() => Schema.Struct({
  sourceType: Schema.optional(Schema.String),
  score: Schema.optional(Schema.Number),
  potentialScore: Schema.optional(Schema.Number),
  normalizedScore: Schema.optional(Schema.Number),
  qaTagResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainQaScorecardResultQaTagResult)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainQaScorecardResultScoreSource" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainQaScorecardResultScoreSource>;

export interface GoogleCloudContactcenterinsightsV1mainQaScorecardResult {
  /** Identifier. The name of the scorecard result. Format: projects/{project}/locations/{location}/qaScorecardResults/{qa_scorecard_result} */
  name?: string;
  /** The QaScorecardRevision scored by this result. */
  qaScorecardRevision?: string;
  /** The conversation scored by this result. */
  conversation?: string;
  /** Output only. The timestamp that the revision was created. */
  createTime?: string;
  /** ID of the agent that handled the conversation. */
  agentId?: string;
  /** Set of QaAnswers represented in the result. */
  qaAnswers?: Array<GoogleCloudContactcenterinsightsV1mainQaAnswer>;
  /** The overall numerical score of the result, incorporating any manual edits if they exist. */
  score?: number;
  /** The maximum potential overall score of the scorecard. Any questions answered using `na_value` are excluded from this calculation. */
  potentialScore?: number;
  /** The normalized score, which is the score divided by the potential score. Any manual edits are included if they exist. */
  normalizedScore?: number;
  /** Collection of tags and their scores. */
  qaTagResults?: Array<GoogleCloudContactcenterinsightsV1mainQaScorecardResultQaTagResult>;
  /** List of all individual score sets. */
  scoreSources?: Array<GoogleCloudContactcenterinsightsV1mainQaScorecardResultScoreSource>;
}

export const GoogleCloudContactcenterinsightsV1mainQaScorecardResult: Schema.Schema<GoogleCloudContactcenterinsightsV1mainQaScorecardResult> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  qaScorecardRevision: Schema.optional(Schema.String),
  conversation: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  agentId: Schema.optional(Schema.String),
  qaAnswers: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainQaAnswer)),
  score: Schema.optional(Schema.Number),
  potentialScore: Schema.optional(Schema.Number),
  normalizedScore: Schema.optional(Schema.Number),
  qaTagResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainQaScorecardResultQaTagResult)),
  scoreSources: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainQaScorecardResultScoreSource)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainQaScorecardResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainQaScorecardResult>;

export interface GoogleCloudContactcenterinsightsV1mainAnalysisResultCallAnalysisMetadata {
  /** A list of call annotations that apply to this call. */
  annotations?: Array<GoogleCloudContactcenterinsightsV1mainCallAnnotation>;
  /** All the entities in the call. */
  entities?: Record<string, GoogleCloudContactcenterinsightsV1mainEntity>;
  /** Overall conversation-level sentiment for each channel of the call. */
  sentiments?: Array<GoogleCloudContactcenterinsightsV1mainConversationLevelSentiment>;
  /** Overall conversation-level silence during the call. */
  silence?: GoogleCloudContactcenterinsightsV1mainConversationLevelSilence;
  /** All the matched intents in the call. */
  intents?: Record<string, GoogleCloudContactcenterinsightsV1mainIntent>;
  /** All the matched phrase matchers in the call. */
  phraseMatchers?: Record<string, GoogleCloudContactcenterinsightsV1mainPhraseMatchData>;
  /** Overall conversation-level issue modeling result. */
  issueModelResult?: GoogleCloudContactcenterinsightsV1mainIssueModelResult;
  /** Results of scoring QaScorecards. */
  qaScorecardResults?: Array<GoogleCloudContactcenterinsightsV1mainQaScorecardResult>;
}

export const GoogleCloudContactcenterinsightsV1mainAnalysisResultCallAnalysisMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainAnalysisResultCallAnalysisMetadata> = Schema.suspend(() => Schema.Struct({
  annotations: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainCallAnnotation)),
  entities: Schema.optional(Schema.Record(Schema.String, GoogleCloudContactcenterinsightsV1mainEntity)),
  sentiments: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainConversationLevelSentiment)),
  silence: Schema.optional(GoogleCloudContactcenterinsightsV1mainConversationLevelSilence),
  intents: Schema.optional(Schema.Record(Schema.String, GoogleCloudContactcenterinsightsV1mainIntent)),
  phraseMatchers: Schema.optional(Schema.Record(Schema.String, GoogleCloudContactcenterinsightsV1mainPhraseMatchData)),
  issueModelResult: Schema.optional(GoogleCloudContactcenterinsightsV1mainIssueModelResult),
  qaScorecardResults: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainQaScorecardResult)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainAnalysisResultCallAnalysisMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainAnalysisResultCallAnalysisMetadata>;

export interface GoogleCloudContactcenterinsightsV1mainAnalysisResult {
  /** The time at which the analysis ended. */
  endTime?: string;
  /** Call-specific metadata created by the analysis. */
  callAnalysisMetadata?: GoogleCloudContactcenterinsightsV1mainAnalysisResultCallAnalysisMetadata;
}

export const GoogleCloudContactcenterinsightsV1mainAnalysisResult: Schema.Schema<GoogleCloudContactcenterinsightsV1mainAnalysisResult> = Schema.suspend(() => Schema.Struct({
  endTime: Schema.optional(Schema.String),
  callAnalysisMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1mainAnalysisResultCallAnalysisMetadata),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainAnalysisResult" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainAnalysisResult>;

export interface GoogleCloudContactcenterinsightsV1mainAnalysis {
  /** Immutable. The resource name of the analysis. Format: projects/{project}/locations/{location}/conversations/{conversation}/analyses/{analysis} */
  name?: string;
  /** Output only. The time at which the analysis was requested. */
  requestTime?: string;
  /** Output only. The time at which the analysis was created, which occurs when the long-running operation completes. */
  createTime?: string;
  /** Output only. The result of the analysis, which is populated when the analysis finishes. */
  analysisResult?: GoogleCloudContactcenterinsightsV1mainAnalysisResult;
  /** To select the annotators to run and the phrase matchers to use (if any). If not specified, all annotators will be run. */
  annotatorSelector?: GoogleCloudContactcenterinsightsV1mainAnnotatorSelector;
}

export const GoogleCloudContactcenterinsightsV1mainAnalysis: Schema.Schema<GoogleCloudContactcenterinsightsV1mainAnalysis> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  requestTime: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  analysisResult: Schema.optional(GoogleCloudContactcenterinsightsV1mainAnalysisResult),
  annotatorSelector: Schema.optional(GoogleCloudContactcenterinsightsV1mainAnnotatorSelector),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainAnalysis" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainAnalysis>;

export interface GoogleCloudContactcenterinsightsV1mainConversationSummarizationSuggestionData {
  /** The summarization content that is concatenated into one string. */
  text?: string;
  /** The summarization content that is divided into sections. The key is the section's name and the value is the section's content. There is no specific format for the key or value. */
  textSections?: Record<string, string>;
  /** The confidence score of the summarization. */
  confidence?: number;
  /** A map that contains metadata about the summarization and the document from which it originates. */
  metadata?: Record<string, string>;
  /** The name of the answer record. Format: projects/{project}/locations/{location}/answerRecords/{answer_record} */
  answerRecord?: string;
  /** The name of the model that generates this summary. Format: projects/{project}/locations/{location}/conversationModels/{conversation_model} */
  conversationModel?: string;
  /** Agent Assist generator ID. */
  generatorId?: string;
}

export const GoogleCloudContactcenterinsightsV1mainConversationSummarizationSuggestionData: Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationSummarizationSuggestionData> = Schema.suspend(() => Schema.Struct({
  text: Schema.optional(Schema.String),
  textSections: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  confidence: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  answerRecord: Schema.optional(Schema.String),
  conversationModel: Schema.optional(Schema.String),
  generatorId: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainConversationSummarizationSuggestionData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationSummarizationSuggestionData>;

export interface GoogleCloudContactcenterinsightsV1mainAnswerFeedback {
  /** The correctness level of an answer. */
  correctnessLevel?: "CORRECTNESS_LEVEL_UNSPECIFIED" | "NOT_CORRECT" | "PARTIALLY_CORRECT" | "FULLY_CORRECT" | (string & {});
  /** Indicates whether an answer or item was clicked by the human agent. */
  clicked?: boolean;
  /** Indicates whether an answer or item was displayed to the human agent in the agent desktop UI. */
  displayed?: boolean;
}

export const GoogleCloudContactcenterinsightsV1mainAnswerFeedback: Schema.Schema<GoogleCloudContactcenterinsightsV1mainAnswerFeedback> = Schema.suspend(() => Schema.Struct({
  correctnessLevel: Schema.optional(Schema.String),
  clicked: Schema.optional(Schema.Boolean),
  displayed: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainAnswerFeedback" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainAnswerFeedback>;

export interface GoogleCloudContactcenterinsightsV1mainArticleSuggestionData {
  /** Article title. */
  title?: string;
  /** Article URI. */
  uri?: string;
  /** The system's confidence score that this article is a good match for this conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely certain). */
  confidenceScore?: number;
  /** Map that contains metadata about the Article Suggestion and the document that it originates from. */
  metadata?: Record<string, string>;
  /** The name of the answer record. Format: projects/{project}/locations/{location}/answerRecords/{answer_record} */
  queryRecord?: string;
  /** The knowledge document that this answer was extracted from. Format: projects/{project}/knowledgeBases/{knowledge_base}/documents/{document} */
  source?: string;
}

export const GoogleCloudContactcenterinsightsV1mainArticleSuggestionData: Schema.Schema<GoogleCloudContactcenterinsightsV1mainArticleSuggestionData> = Schema.suspend(() => Schema.Struct({
  title: Schema.optional(Schema.String),
  uri: Schema.optional(Schema.String),
  confidenceScore: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  queryRecord: Schema.optional(Schema.String),
  source: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainArticleSuggestionData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainArticleSuggestionData>;

export interface GoogleCloudContactcenterinsightsV1mainFaqAnswerData {
  /** The piece of text from the `source` knowledge base document. */
  answer?: string;
  /** The system's confidence score that this answer is a good match for this conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely certain). */
  confidenceScore?: number;
  /** The corresponding FAQ question. */
  question?: string;
  /** Map that contains metadata about the FAQ answer and the document that it originates from. */
  metadata?: Record<string, string>;
  /** The name of the answer record. Format: projects/{project}/locations/{location}/answerRecords/{answer_record} */
  queryRecord?: string;
  /** The knowledge document that this answer was extracted from. Format: projects/{project}/knowledgeBases/{knowledge_base}/documents/{document}. */
  source?: string;
}

export const GoogleCloudContactcenterinsightsV1mainFaqAnswerData: Schema.Schema<GoogleCloudContactcenterinsightsV1mainFaqAnswerData> = Schema.suspend(() => Schema.Struct({
  answer: Schema.optional(Schema.String),
  confidenceScore: Schema.optional(Schema.Number),
  question: Schema.optional(Schema.String),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  queryRecord: Schema.optional(Schema.String),
  source: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainFaqAnswerData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainFaqAnswerData>;

export interface GoogleCloudContactcenterinsightsV1mainSmartReplyData {
  /** The content of the reply. */
  reply?: string;
  /** The system's confidence score that this reply is a good match for this conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely certain). */
  confidenceScore?: number;
  /** Map that contains metadata about the Smart Reply and the document from which it originates. */
  metadata?: Record<string, string>;
  /** The name of the answer record. Format: projects/{project}/locations/{location}/answerRecords/{answer_record} */
  queryRecord?: string;
}

export const GoogleCloudContactcenterinsightsV1mainSmartReplyData: Schema.Schema<GoogleCloudContactcenterinsightsV1mainSmartReplyData> = Schema.suspend(() => Schema.Struct({
  reply: Schema.optional(Schema.String),
  confidenceScore: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  queryRecord: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainSmartReplyData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainSmartReplyData>;

export interface GoogleCloudContactcenterinsightsV1mainSmartComposeSuggestionData {
  /** The content of the suggestion. */
  suggestion?: string;
  /** The system's confidence score that this suggestion is a good match for this conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely certain). */
  confidenceScore?: number;
  /** Map that contains metadata about the Smart Compose suggestion and the document from which it originates. */
  metadata?: Record<string, string>;
  /** The name of the answer record. Format: projects/{project}/locations/{location}/answerRecords/{answer_record} */
  queryRecord?: string;
}

export const GoogleCloudContactcenterinsightsV1mainSmartComposeSuggestionData: Schema.Schema<GoogleCloudContactcenterinsightsV1mainSmartComposeSuggestionData> = Schema.suspend(() => Schema.Struct({
  suggestion: Schema.optional(Schema.String),
  confidenceScore: Schema.optional(Schema.Number),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  queryRecord: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainSmartComposeSuggestionData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainSmartComposeSuggestionData>;

export interface GoogleCloudContactcenterinsightsV1mainDialogflowInteractionData {
  /** The Dialogflow intent resource path. Format: projects/{project}/agent/{agent}/intents/{intent} */
  dialogflowIntentId?: string;
  /** The confidence of the match ranging from 0.0 (completely uncertain) to 1.0 (completely certain). */
  confidence?: number;
}

export const GoogleCloudContactcenterinsightsV1mainDialogflowInteractionData: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDialogflowInteractionData> = Schema.suspend(() => Schema.Struct({
  dialogflowIntentId: Schema.optional(Schema.String),
  confidence: Schema.optional(Schema.Number),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDialogflowInteractionData" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDialogflowInteractionData>;

export interface GoogleCloudContactcenterinsightsV1mainRuntimeAnnotationUserInput {
  /** Query text. Article Search uses this to store the input query used to generate the search results. */
  query?: string;
  /** The resource name of associated generator. Format: `projects//locations//generators/` */
  generatorName?: string;
  /** Query source for the answer. */
  querySource?: "QUERY_SOURCE_UNSPECIFIED" | "AGENT_QUERY" | "SUGGESTED_QUERY" | (string & {});
}

export const GoogleCloudContactcenterinsightsV1mainRuntimeAnnotationUserInput: Schema.Schema<GoogleCloudContactcenterinsightsV1mainRuntimeAnnotationUserInput> = Schema.suspend(() => Schema.Struct({
  query: Schema.optional(Schema.String),
  generatorName: Schema.optional(Schema.String),
  querySource: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainRuntimeAnnotationUserInput" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainRuntimeAnnotationUserInput>;

export interface GoogleCloudContactcenterinsightsV1mainRuntimeAnnotation {
  /** The unique identifier of the annotation. Format: projects/{project}/locations/{location}/conversationDatasets/{dataset}/conversationDataItems/{data_item}/conversationAnnotations/{annotation} */
  annotationId?: string;
  /** The time at which this annotation was created. */
  createTime?: string;
  /** The boundary in the conversation where the annotation starts, inclusive. */
  startBoundary?: GoogleCloudContactcenterinsightsV1mainAnnotationBoundary;
  /** The boundary in the conversation where the annotation ends, inclusive. */
  endBoundary?: GoogleCloudContactcenterinsightsV1mainAnnotationBoundary;
  /** The feedback that the customer has about the answer in `data`. */
  answerFeedback?: GoogleCloudContactcenterinsightsV1mainAnswerFeedback;
  /** Agent Assist Article Suggestion data. */
  articleSuggestion?: GoogleCloudContactcenterinsightsV1mainArticleSuggestionData;
  /** Agent Assist FAQ answer data. */
  faqAnswer?: GoogleCloudContactcenterinsightsV1mainFaqAnswerData;
  /** Agent Assist Smart Reply data. */
  smartReply?: GoogleCloudContactcenterinsightsV1mainSmartReplyData;
  /** Agent Assist Smart Compose suggestion data. */
  smartComposeSuggestion?: GoogleCloudContactcenterinsightsV1mainSmartComposeSuggestionData;
  /** Dialogflow interaction data. */
  dialogflowInteraction?: GoogleCloudContactcenterinsightsV1mainDialogflowInteractionData;
  /** Conversation summarization suggestion data. */
  conversationSummarizationSuggestion?: GoogleCloudContactcenterinsightsV1mainConversationSummarizationSuggestionData;
  /** Explicit input used for generating the answer */
  userInput?: GoogleCloudContactcenterinsightsV1mainRuntimeAnnotationUserInput;
}

export const GoogleCloudContactcenterinsightsV1mainRuntimeAnnotation: Schema.Schema<GoogleCloudContactcenterinsightsV1mainRuntimeAnnotation> = Schema.suspend(() => Schema.Struct({
  annotationId: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  startBoundary: Schema.optional(GoogleCloudContactcenterinsightsV1mainAnnotationBoundary),
  endBoundary: Schema.optional(GoogleCloudContactcenterinsightsV1mainAnnotationBoundary),
  answerFeedback: Schema.optional(GoogleCloudContactcenterinsightsV1mainAnswerFeedback),
  articleSuggestion: Schema.optional(GoogleCloudContactcenterinsightsV1mainArticleSuggestionData),
  faqAnswer: Schema.optional(GoogleCloudContactcenterinsightsV1mainFaqAnswerData),
  smartReply: Schema.optional(GoogleCloudContactcenterinsightsV1mainSmartReplyData),
  smartComposeSuggestion: Schema.optional(GoogleCloudContactcenterinsightsV1mainSmartComposeSuggestionData),
  dialogflowInteraction: Schema.optional(GoogleCloudContactcenterinsightsV1mainDialogflowInteractionData),
  conversationSummarizationSuggestion: Schema.optional(GoogleCloudContactcenterinsightsV1mainConversationSummarizationSuggestionData),
  userInput: Schema.optional(GoogleCloudContactcenterinsightsV1mainRuntimeAnnotationUserInput),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainRuntimeAnnotation" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainRuntimeAnnotation>;

export interface GoogleCloudContactcenterinsightsV1mainDialogflowIntent {
  /** The human-readable name of the intent. */
  displayName?: string;
}

export const GoogleCloudContactcenterinsightsV1mainDialogflowIntent: Schema.Schema<GoogleCloudContactcenterinsightsV1mainDialogflowIntent> = Schema.suspend(() => Schema.Struct({
  displayName: Schema.optional(Schema.String),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainDialogflowIntent" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainDialogflowIntent>;

export interface GoogleCloudContactcenterinsightsV1mainConversationCorrelationInfo {
  /** Output only. The full conversation correlation id this conversation is a segment of. */
  fullConversationCorrelationId?: string;
  /** Output only. The full conversation correlation id this conversation is a merged conversation of. */
  mergedFullConversationCorrelationId?: string;
  /** Output only. The correlation types of this conversation. A single conversation can have multiple correlation types. For example a conversation that only has a single segment is both a SEGMENT and a FULL_CONVERSATION. */
  correlationTypes?: Array<"CORRELATION_TYPE_UNSPECIFIED" | "SEGMENT" | "PARTIAL" | "FULL" | "SYNTHETIC" | (string & {})>;
}

export const GoogleCloudContactcenterinsightsV1mainConversationCorrelationInfo: Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationCorrelationInfo> = Schema.suspend(() => Schema.Struct({
  fullConversationCorrelationId: Schema.optional(Schema.String),
  mergedFullConversationCorrelationId: Schema.optional(Schema.String),
  correlationTypes: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainConversationCorrelationInfo" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversationCorrelationInfo>;

export interface GoogleCloudContactcenterinsightsV1mainConversation {
  /** Immutable. The resource name of the conversation. Format: projects/{project}/locations/{location}/conversations/{conversation} */
  name?: string;
  /** The source of the audio and transcription for the conversation. */
  dataSource?: GoogleCloudContactcenterinsightsV1mainConversationDataSource;
  /** Output only. The time at which the conversation was created. */
  createTime?: string;
  /** Output only. The most recent time at which the conversation was updated. */
  updateTime?: string;
  /** The time at which the conversation started. */
  startTime?: string;
  /** A user-specified language code for the conversation. */
  languageCode?: string;
  /** An opaque, user-specified string representing the human agent who handled the conversation. */
  agentId?: string;
  /** A map for the user to specify any custom fields. A maximum of 100 labels per conversation is allowed, with a maximum of 256 characters per entry. */
  labels?: Record<string, string>;
  /** Call-specific metadata. */
  callMetadata?: GoogleCloudContactcenterinsightsV1mainConversationCallMetadata;
  /** Conversation metadata related to quality management. */
  qualityMetadata?: GoogleCloudContactcenterinsightsV1mainConversationQualityMetadata;
  /** Input only. JSON metadata encoded as a string. This field is primarily used by Insights integrations with various telephony systems and must be in one of Insight's supported formats. */
  metadataJson?: string;
  /** Output only. The conversation transcript. */
  transcript?: GoogleCloudContactcenterinsightsV1mainConversationTranscript;
  /** Immutable. The conversation medium. */
  medium?: "MEDIUM_UNSPECIFIED" | "PHONE_CALL" | "CHAT" | (string & {});
  /** Output only. The duration of the conversation. */
  duration?: string;
  /** Output only. The number of turns in the conversation. */
  turnCount?: number;
  /** Output only. The conversation's latest analysis, if one exists. */
  latestAnalysis?: GoogleCloudContactcenterinsightsV1mainAnalysis;
  /** Output only. Latest summary of the conversation. */
  latestSummary?: GoogleCloudContactcenterinsightsV1mainConversationSummarizationSuggestionData;
  /** Output only. The annotations that were generated during the customer and agent interaction. */
  runtimeAnnotations?: Array<GoogleCloudContactcenterinsightsV1mainRuntimeAnnotation>;
  /** The time at which this conversation should expire. After this time, the conversation data and any associated analyses will be deleted. */
  expireTime?: string;
  /** Input only. The TTL for this resource. If specified, then this TTL will be used to calculate the expire time. */
  ttl?: string;
  /** Output only. All the matched Dialogflow intents in the call. The key corresponds to a Dialogflow intent, format: projects/{project}/agent/{agent}/intents/{intent} */
  dialogflowIntents?: Record<string, GoogleCloudContactcenterinsightsV1mainDialogflowIntent>;
  /** Obfuscated user ID which the customer sent to us. */
  obfuscatedUserId?: string;
  /** Output only. Info for correlating across conversations. */
  correlationInfo?: GoogleCloudContactcenterinsightsV1mainConversationCorrelationInfo;
}

export const GoogleCloudContactcenterinsightsV1mainConversation: Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversation> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  dataSource: Schema.optional(GoogleCloudContactcenterinsightsV1mainConversationDataSource),
  createTime: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  startTime: Schema.optional(Schema.String),
  languageCode: Schema.optional(Schema.String),
  agentId: Schema.optional(Schema.String),
  labels: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  callMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1mainConversationCallMetadata),
  qualityMetadata: Schema.optional(GoogleCloudContactcenterinsightsV1mainConversationQualityMetadata),
  metadataJson: Schema.optional(Schema.String),
  transcript: Schema.optional(GoogleCloudContactcenterinsightsV1mainConversationTranscript),
  medium: Schema.optional(Schema.String),
  duration: Schema.optional(Schema.String),
  turnCount: Schema.optional(Schema.Number),
  latestAnalysis: Schema.optional(GoogleCloudContactcenterinsightsV1mainAnalysis),
  latestSummary: Schema.optional(GoogleCloudContactcenterinsightsV1mainConversationSummarizationSuggestionData),
  runtimeAnnotations: Schema.optional(Schema.Array(GoogleCloudContactcenterinsightsV1mainRuntimeAnnotation)),
  expireTime: Schema.optional(Schema.String),
  ttl: Schema.optional(Schema.String),
  dialogflowIntents: Schema.optional(Schema.Record(Schema.String, GoogleCloudContactcenterinsightsV1mainDialogflowIntent)),
  obfuscatedUserId: Schema.optional(Schema.String),
  correlationInfo: Schema.optional(GoogleCloudContactcenterinsightsV1mainConversationCorrelationInfo),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainConversation" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainConversation>;

export interface GoogleCloudContactcenterinsightsV1mainUploadConversationRequest {
  /** Required. The parent resource of the conversation. */
  parent?: string;
  /** Required. The conversation resource to create. */
  conversation?: GoogleCloudContactcenterinsightsV1mainConversation;
  /** Optional. A unique ID for the new conversation. This ID will become the final component of the conversation's resource name. If no ID is specified, a server-generated ID will be used. This value should be 4-64 characters and must match the regular expression `^[a-z0-9-]{4,64}$`. Valid characters are `a-z-` */
  conversationId?: string;
  /** Optional. DLP settings for transcript redaction. Will default to the config specified in Settings. */
  redactionConfig?: GoogleCloudContactcenterinsightsV1mainRedactionConfig;
  /** Optional. Speech-to-Text configuration. Will default to the config specified in Settings. */
  speechConfig?: GoogleCloudContactcenterinsightsV1mainSpeechConfig;
}

export const GoogleCloudContactcenterinsightsV1mainUploadConversationRequest: Schema.Schema<GoogleCloudContactcenterinsightsV1mainUploadConversationRequest> = Schema.suspend(() => Schema.Struct({
  parent: Schema.optional(Schema.String),
  conversation: Schema.optional(GoogleCloudContactcenterinsightsV1mainConversation),
  conversationId: Schema.optional(Schema.String),
  redactionConfig: Schema.optional(GoogleCloudContactcenterinsightsV1mainRedactionConfig),
  speechConfig: Schema.optional(GoogleCloudContactcenterinsightsV1mainSpeechConfig),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainUploadConversationRequest" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainUploadConversationRequest>;

export interface GoogleCloudContactcenterinsightsV1mainUploadConversationMetadata {
  /** Output only. The time the operation was created. */
  createTime?: string;
  /** Output only. The time the operation finished running. */
  endTime?: string;
  /** Output only. The original request. */
  request?: GoogleCloudContactcenterinsightsV1mainUploadConversationRequest;
  /** Output only. The operation name for a successfully created analysis operation, if any. */
  analysisOperation?: string;
  /** Output only. The redaction config applied to the uploaded conversation. */
  appliedRedactionConfig?: GoogleCloudContactcenterinsightsV1mainRedactionConfig;
}

export const GoogleCloudContactcenterinsightsV1mainUploadConversationMetadata: Schema.Schema<GoogleCloudContactcenterinsightsV1mainUploadConversationMetadata> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  endTime: Schema.optional(Schema.String),
  request: Schema.optional(GoogleCloudContactcenterinsightsV1mainUploadConversationRequest),
  analysisOperation: Schema.optional(Schema.String),
  appliedRedactionConfig: Schema.optional(GoogleCloudContactcenterinsightsV1mainRedactionConfig),
})).annotate({ identifier: "GoogleCloudContactcenterinsightsV1mainUploadConversationMetadata" }) as any as Schema.Schema<GoogleCloudContactcenterinsightsV1mainUploadConversationMetadata>;

// ==========================================================================
// Operations
// ==========================================================================

/** Gets correlation config. */
export interface GetCorrelationConfigProjectsLocationsRequest {
  /** Required. The name of the correlation config resource to get. Format: projects/{project}/locations/{location}/correlationConfig */
  name: string;
}

export const GetCorrelationConfigProjectsLocationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/correlationConfig" }),
  svc,
) as unknown as Schema.Schema<GetCorrelationConfigProjectsLocationsRequest>;

export type GetCorrelationConfigProjectsLocationsResponse = GoogleCloudContactcenterinsightsV1CorrelationConfig;
export const GetCorrelationConfigProjectsLocationsResponse = GoogleCloudContactcenterinsightsV1CorrelationConfig;

export type GetCorrelationConfigProjectsLocationsError = CommonErrors;

export const getCorrelationConfigProjectsLocations: API.OperationMethod<GetCorrelationConfigProjectsLocationsRequest, GetCorrelationConfigProjectsLocationsResponse, GetCorrelationConfigProjectsLocationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetCorrelationConfigProjectsLocationsRequest,
  output: GetCorrelationConfigProjectsLocationsResponse,
  errors: [],
}));

/** Updates correlation config. */
export interface UpdateCorrelationConfigProjectsLocationsRequest {
  /** Immutable. Identifier. The resource name of the correlation config. Format: projects/{project}/locations/{location}/correlationConfig */
  name: string;
  /** Optional. The list of fields to be updated. */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1CorrelationConfig;
}

export const UpdateCorrelationConfigProjectsLocationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1CorrelationConfig).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/correlationConfig", hasBody: true }),
  svc,
) as unknown as Schema.Schema<UpdateCorrelationConfigProjectsLocationsRequest>;

export type UpdateCorrelationConfigProjectsLocationsResponse = GoogleCloudContactcenterinsightsV1CorrelationConfig;
export const UpdateCorrelationConfigProjectsLocationsResponse = GoogleCloudContactcenterinsightsV1CorrelationConfig;

export type UpdateCorrelationConfigProjectsLocationsError = CommonErrors;

export const updateCorrelationConfigProjectsLocations: API.OperationMethod<UpdateCorrelationConfigProjectsLocationsRequest, UpdateCorrelationConfigProjectsLocationsResponse, UpdateCorrelationConfigProjectsLocationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: UpdateCorrelationConfigProjectsLocationsRequest,
  output: UpdateCorrelationConfigProjectsLocationsResponse,
  errors: [],
}));

/** Tests correlation config on a conversation. */
export interface TestCorrelationConfigProjectsLocationsRequest {
  /** Required. The location to test correlation config. Format: projects/{project}/locations/{location} */
  location: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1TestCorrelationConfigRequest;
}

export const TestCorrelationConfigProjectsLocationsRequest = Schema.Struct({
  location: Schema.String.pipe(T.HttpPath("location")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1TestCorrelationConfigRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}:testCorrelationConfig", hasBody: true }),
  svc,
) as unknown as Schema.Schema<TestCorrelationConfigProjectsLocationsRequest>;

export type TestCorrelationConfigProjectsLocationsResponse = GoogleLongrunningOperation;
export const TestCorrelationConfigProjectsLocationsResponse = GoogleLongrunningOperation;

export type TestCorrelationConfigProjectsLocationsError = CommonErrors;

export const testCorrelationConfigProjectsLocations: API.OperationMethod<TestCorrelationConfigProjectsLocationsRequest, TestCorrelationConfigProjectsLocationsResponse, TestCorrelationConfigProjectsLocationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: TestCorrelationConfigProjectsLocationsRequest,
  output: TestCorrelationConfigProjectsLocationsResponse,
  errors: [],
}));

/** Gets project-level settings. */
export interface GetSettingsProjectsLocationsRequest {
  /** Required. The name of the settings resource to get. */
  name: string;
}

export const GetSettingsProjectsLocationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/settings" }),
  svc,
) as unknown as Schema.Schema<GetSettingsProjectsLocationsRequest>;

export type GetSettingsProjectsLocationsResponse = GoogleCloudContactcenterinsightsV1Settings;
export const GetSettingsProjectsLocationsResponse = GoogleCloudContactcenterinsightsV1Settings;

export type GetSettingsProjectsLocationsError = CommonErrors;

export const getSettingsProjectsLocations: API.OperationMethod<GetSettingsProjectsLocationsRequest, GetSettingsProjectsLocationsResponse, GetSettingsProjectsLocationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetSettingsProjectsLocationsRequest,
  output: GetSettingsProjectsLocationsResponse,
  errors: [],
}));

/** Updates project-level settings. */
export interface UpdateSettingsProjectsLocationsRequest {
  /** Immutable. The resource name of the settings resource. Format: projects/{project}/locations/{location}/settings */
  name: string;
  /** Required. The list of fields to be updated. */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1Settings;
}

export const UpdateSettingsProjectsLocationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1Settings).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/settings", hasBody: true }),
  svc,
) as unknown as Schema.Schema<UpdateSettingsProjectsLocationsRequest>;

export type UpdateSettingsProjectsLocationsResponse = GoogleCloudContactcenterinsightsV1Settings;
export const UpdateSettingsProjectsLocationsResponse = GoogleCloudContactcenterinsightsV1Settings;

export type UpdateSettingsProjectsLocationsError = CommonErrors;

export const updateSettingsProjectsLocations: API.OperationMethod<UpdateSettingsProjectsLocationsRequest, UpdateSettingsProjectsLocationsResponse, UpdateSettingsProjectsLocationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: UpdateSettingsProjectsLocationsRequest,
  output: UpdateSettingsProjectsLocationsResponse,
  errors: [],
}));

/** Gets location-level encryption key specification. */
export interface GetEncryptionSpecProjectsLocationsRequest {
  /** Required. The name of the encryption spec resource to get. */
  name: string;
}

export const GetEncryptionSpecProjectsLocationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/encryptionSpec" }),
  svc,
) as unknown as Schema.Schema<GetEncryptionSpecProjectsLocationsRequest>;

export type GetEncryptionSpecProjectsLocationsResponse = GoogleCloudContactcenterinsightsV1EncryptionSpec;
export const GetEncryptionSpecProjectsLocationsResponse = GoogleCloudContactcenterinsightsV1EncryptionSpec;

export type GetEncryptionSpecProjectsLocationsError = CommonErrors;

export const getEncryptionSpecProjectsLocations: API.OperationMethod<GetEncryptionSpecProjectsLocationsRequest, GetEncryptionSpecProjectsLocationsResponse, GetEncryptionSpecProjectsLocationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetEncryptionSpecProjectsLocationsRequest,
  output: GetEncryptionSpecProjectsLocationsResponse,
  errors: [],
}));

/** Query metrics. */
export interface QueryMetricsProjectsLocationsRequest {
  /** Required. The location of the data. "projects/{project}/locations/{location}" */
  location: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1QueryMetricsRequest;
}

export const QueryMetricsProjectsLocationsRequest = Schema.Struct({
  location: Schema.String.pipe(T.HttpPath("location")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1QueryMetricsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}:queryMetrics", hasBody: true }),
  svc,
) as unknown as Schema.Schema<QueryMetricsProjectsLocationsRequest>;

export type QueryMetricsProjectsLocationsResponse = GoogleLongrunningOperation;
export const QueryMetricsProjectsLocationsResponse = GoogleLongrunningOperation;

export type QueryMetricsProjectsLocationsError = CommonErrors;

export const queryMetricsProjectsLocations: API.OperationMethod<QueryMetricsProjectsLocationsRequest, QueryMetricsProjectsLocationsResponse, QueryMetricsProjectsLocationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: QueryMetricsProjectsLocationsRequest,
  output: QueryMetricsProjectsLocationsResponse,
  errors: [],
}));

/** Natural language based Insights which powers the next generation of dashboards in Insights. Next generation of QueryMetrics. */
export interface GenerativeInsightsProjectsLocationsRequest {
  /** Required. The location of the data. "projects/{project}/locations/{location}" */
  location: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1GenerativeInsightsRequest;
}

export const GenerativeInsightsProjectsLocationsRequest = Schema.Struct({
  location: Schema.String.pipe(T.HttpPath("location")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1GenerativeInsightsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}:generativeInsights", hasBody: true }),
  svc,
) as unknown as Schema.Schema<GenerativeInsightsProjectsLocationsRequest>;

export type GenerativeInsightsProjectsLocationsResponse = GoogleLongrunningOperation;
export const GenerativeInsightsProjectsLocationsResponse = GoogleLongrunningOperation;

export type GenerativeInsightsProjectsLocationsError = CommonErrors;

export const generativeInsightsProjectsLocations: API.OperationMethod<GenerativeInsightsProjectsLocationsRequest, GenerativeInsightsProjectsLocationsResponse, GenerativeInsightsProjectsLocationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GenerativeInsightsProjectsLocationsRequest,
  output: GenerativeInsightsProjectsLocationsResponse,
  errors: [],
}));

/** Generates a summary of predefined performance metrics for a set of conversations. Conversations can be specified by specifying a time window and an agent id, for now. The summary includes a comparison of metrics computed for conversations in the previous time period, and also a comparison with peers in the same time period. */
export interface QueryPerformanceOverviewProjectsLocationsRequest {
  /** Required. The parent resource of the conversations to derive performance stats from. "projects/{project}/locations/{location}" */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewRequest;
}

export const QueryPerformanceOverviewProjectsLocationsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}:queryPerformanceOverview", hasBody: true }),
  svc,
) as unknown as Schema.Schema<QueryPerformanceOverviewProjectsLocationsRequest>;

export type QueryPerformanceOverviewProjectsLocationsResponse = GoogleLongrunningOperation;
export const QueryPerformanceOverviewProjectsLocationsResponse = GoogleLongrunningOperation;

export type QueryPerformanceOverviewProjectsLocationsError = CommonErrors;

export const queryPerformanceOverviewProjectsLocations: API.OperationMethod<QueryPerformanceOverviewProjectsLocationsRequest, QueryPerformanceOverviewProjectsLocationsResponse, QueryPerformanceOverviewProjectsLocationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: QueryPerformanceOverviewProjectsLocationsRequest,
  output: QueryPerformanceOverviewProjectsLocationsResponse,
  errors: [],
}));

/** List all feedback labels by project number. */
export interface ListAllFeedbackLabelsProjectsLocationsRequest {
  /** Required. The parent resource of all feedback labels per project. */
  parent: string;
  /** Optional. The maximum number of feedback labels to return in the response. A valid page size ranges from 0 to 100,000 inclusive. If the page size is zero or unspecified, a default page size of 100 will be chosen. Note that a call might return fewer results than the requested page size. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListAllFeedbackLabelsResponse`. This value indicates that this is a continuation of a prior `ListAllFeedbackLabels` call and that the system should return the next page of data. */
  pageToken?: string;
  /** Optional. A filter to reduce results to a specific subset in the entire project. Supports disjunctions (OR) and conjunctions (AND). Supported fields: * `issue_model_id` * `qa_question_id` * `min_create_time` * `max_create_time` * `min_update_time` * `max_update_time` * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING */
  filter?: string;
}

export const ListAllFeedbackLabelsProjectsLocationsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}:listAllFeedbackLabels" }),
  svc,
) as unknown as Schema.Schema<ListAllFeedbackLabelsProjectsLocationsRequest>;

export type ListAllFeedbackLabelsProjectsLocationsResponse = GoogleCloudContactcenterinsightsV1ListAllFeedbackLabelsResponse;
export const ListAllFeedbackLabelsProjectsLocationsResponse = GoogleCloudContactcenterinsightsV1ListAllFeedbackLabelsResponse;

export type ListAllFeedbackLabelsProjectsLocationsError = CommonErrors;

export const listAllFeedbackLabelsProjectsLocations = API.makePaginated(() => ({
  input: ListAllFeedbackLabelsProjectsLocationsRequest,
  output: ListAllFeedbackLabelsProjectsLocationsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Upload feedback labels from an external source in bulk. Currently supports labeling Quality AI example conversations. */
export interface BulkUploadFeedbackLabelsProjectsLocationsRequest {
  /** Required. The parent resource for new feedback labels. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequest;
}

export const BulkUploadFeedbackLabelsProjectsLocationsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}:bulkUploadFeedbackLabels", hasBody: true }),
  svc,
) as unknown as Schema.Schema<BulkUploadFeedbackLabelsProjectsLocationsRequest>;

export type BulkUploadFeedbackLabelsProjectsLocationsResponse = GoogleLongrunningOperation;
export const BulkUploadFeedbackLabelsProjectsLocationsResponse = GoogleLongrunningOperation;

export type BulkUploadFeedbackLabelsProjectsLocationsError = CommonErrors;

export const bulkUploadFeedbackLabelsProjectsLocations: API.OperationMethod<BulkUploadFeedbackLabelsProjectsLocationsRequest, BulkUploadFeedbackLabelsProjectsLocationsResponse, BulkUploadFeedbackLabelsProjectsLocationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: BulkUploadFeedbackLabelsProjectsLocationsRequest,
  output: BulkUploadFeedbackLabelsProjectsLocationsResponse,
  errors: [],
}));

/** Download feedback labels in bulk from an external source. Currently supports exporting Quality AI example conversations with transcripts and question bodies. */
export interface BulkDownloadFeedbackLabelsProjectsLocationsRequest {
  /** Required. The parent resource for new feedback labels. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequest;
}

export const BulkDownloadFeedbackLabelsProjectsLocationsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}:bulkDownloadFeedbackLabels", hasBody: true }),
  svc,
) as unknown as Schema.Schema<BulkDownloadFeedbackLabelsProjectsLocationsRequest>;

export type BulkDownloadFeedbackLabelsProjectsLocationsResponse = GoogleLongrunningOperation;
export const BulkDownloadFeedbackLabelsProjectsLocationsResponse = GoogleLongrunningOperation;

export type BulkDownloadFeedbackLabelsProjectsLocationsError = CommonErrors;

export const bulkDownloadFeedbackLabelsProjectsLocations: API.OperationMethod<BulkDownloadFeedbackLabelsProjectsLocationsRequest, BulkDownloadFeedbackLabelsProjectsLocationsResponse, BulkDownloadFeedbackLabelsProjectsLocationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: BulkDownloadFeedbackLabelsProjectsLocationsRequest,
  output: BulkDownloadFeedbackLabelsProjectsLocationsResponse,
  errors: [],
}));

/** Delete feedback labels in bulk using a filter. */
export interface BulkDeleteFeedbackLabelsProjectsLocationsRequest {
  /** Required. The parent resource for new feedback labels. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsRequest;
}

export const BulkDeleteFeedbackLabelsProjectsLocationsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}:bulkDeleteFeedbackLabels", hasBody: true }),
  svc,
) as unknown as Schema.Schema<BulkDeleteFeedbackLabelsProjectsLocationsRequest>;

export type BulkDeleteFeedbackLabelsProjectsLocationsResponse = GoogleLongrunningOperation;
export const BulkDeleteFeedbackLabelsProjectsLocationsResponse = GoogleLongrunningOperation;

export type BulkDeleteFeedbackLabelsProjectsLocationsError = CommonErrors;

export const bulkDeleteFeedbackLabelsProjectsLocations: API.OperationMethod<BulkDeleteFeedbackLabelsProjectsLocationsRequest, BulkDeleteFeedbackLabelsProjectsLocationsResponse, BulkDeleteFeedbackLabelsProjectsLocationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: BulkDeleteFeedbackLabelsProjectsLocationsRequest,
  output: BulkDeleteFeedbackLabelsProjectsLocationsResponse,
  errors: [],
}));

/** Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns `UNIMPLEMENTED`. */
export interface ListProjectsLocationsOperationsRequest {
  /** The name of the operation's parent resource. */
  name: string;
  /** The standard list filter. */
  filter?: string;
  /** The standard list page size. */
  pageSize?: number;
  /** The standard list page token. */
  pageToken?: string;
  /** When set to `true`, operations that are reachable are returned as normal, and those that are unreachable are returned in the ListOperationsResponse.unreachable field. This can only be `true` when reading across collections. For example, when `parent` is set to `"projects/example/locations/-"`. This field is not supported by default and will result in an `UNIMPLEMENTED` error if set unless explicitly documented otherwise in service or product specific documentation. */
  returnPartialSuccess?: boolean;
}

export const ListProjectsLocationsOperationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  returnPartialSuccess: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("returnPartialSuccess")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/operations" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsOperationsRequest>;

export type ListProjectsLocationsOperationsResponse = GoogleLongrunningListOperationsResponse;
export const ListProjectsLocationsOperationsResponse = GoogleLongrunningListOperationsResponse;

export type ListProjectsLocationsOperationsError = CommonErrors;

export const listProjectsLocationsOperations = API.makePaginated(() => ({
  input: ListProjectsLocationsOperationsRequest,
  output: ListProjectsLocationsOperationsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Gets the latest state of a long-running operation. Clients can use this method to poll the operation result at intervals as recommended by the API service. */
export interface GetProjectsLocationsOperationsRequest {
  /** The name of the operation resource. */
  name: string;
}

export const GetProjectsLocationsOperationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/operations/{operationsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsOperationsRequest>;

export type GetProjectsLocationsOperationsResponse = GoogleLongrunningOperation;
export const GetProjectsLocationsOperationsResponse = GoogleLongrunningOperation;

export type GetProjectsLocationsOperationsError = CommonErrors;

export const getProjectsLocationsOperations: API.OperationMethod<GetProjectsLocationsOperationsRequest, GetProjectsLocationsOperationsResponse, GetProjectsLocationsOperationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsOperationsRequest,
  output: GetProjectsLocationsOperationsResponse,
  errors: [],
}));

/** Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of `1`, corresponding to `Code.CANCELLED`. */
export interface CancelProjectsLocationsOperationsRequest {
  /** The name of the operation resource to be cancelled. */
  name: string;
}

export const CancelProjectsLocationsOperationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/operations/{operationsId}:cancel", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CancelProjectsLocationsOperationsRequest>;

export type CancelProjectsLocationsOperationsResponse = GoogleProtobufEmpty;
export const CancelProjectsLocationsOperationsResponse = GoogleProtobufEmpty;

export type CancelProjectsLocationsOperationsError = CommonErrors;

export const cancelProjectsLocationsOperations: API.OperationMethod<CancelProjectsLocationsOperationsRequest, CancelProjectsLocationsOperationsResponse, CancelProjectsLocationsOperationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CancelProjectsLocationsOperationsRequest,
  output: CancelProjectsLocationsOperationsResponse,
  errors: [],
}));

/** Creates a conversation. Note that this method does not support audio transcription or redaction. Use `conversations.upload` instead. */
export interface CreateProjectsLocationsConversationsRequest {
  /** Required. The parent resource of the conversation. */
  parent: string;
  /** A unique ID for the new conversation. This ID will become the final component of the conversation's resource name. If no ID is specified, a server-generated ID will be used. This value should be 4-64 characters and must match the regular expression `^[a-z0-9-]{4,64}$`. Valid characters are `a-z-` */
  conversationId?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1Conversation;
}

export const CreateProjectsLocationsConversationsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  conversationId: Schema.optional(Schema.String).pipe(T.HttpQuery("conversationId")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1Conversation).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsConversationsRequest>;

export type CreateProjectsLocationsConversationsResponse = GoogleCloudContactcenterinsightsV1Conversation;
export const CreateProjectsLocationsConversationsResponse = GoogleCloudContactcenterinsightsV1Conversation;

export type CreateProjectsLocationsConversationsError = CommonErrors;

export const createProjectsLocationsConversations: API.OperationMethod<CreateProjectsLocationsConversationsRequest, CreateProjectsLocationsConversationsResponse, CreateProjectsLocationsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsConversationsRequest,
  output: CreateProjectsLocationsConversationsResponse,
  errors: [],
}));

/** Create a long-running conversation upload operation. This method differs from `CreateConversation` by allowing audio transcription and optional DLP redaction. */
export interface UploadProjectsLocationsConversationsRequest {
  /** Required. The parent resource of the conversation. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1UploadConversationRequest;
}

export const UploadProjectsLocationsConversationsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1UploadConversationRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations:upload", hasBody: true }),
  svc,
) as unknown as Schema.Schema<UploadProjectsLocationsConversationsRequest>;

export type UploadProjectsLocationsConversationsResponse = GoogleLongrunningOperation;
export const UploadProjectsLocationsConversationsResponse = GoogleLongrunningOperation;

export type UploadProjectsLocationsConversationsError = CommonErrors;

export const uploadProjectsLocationsConversations: API.OperationMethod<UploadProjectsLocationsConversationsRequest, UploadProjectsLocationsConversationsResponse, UploadProjectsLocationsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: UploadProjectsLocationsConversationsRequest,
  output: UploadProjectsLocationsConversationsResponse,
  errors: [],
}));

/** Updates a conversation. */
export interface PatchProjectsLocationsConversationsRequest {
  /** Immutable. The resource name of the conversation. Format: projects/{project}/locations/{location}/conversations/{conversation} */
  name: string;
  /** The list of fields to be updated. All possible fields can be updated by passing `*`, or a subset of the following updateable fields can be provided: * `agent_id` * `language_code` * `labels` * `metadata` * `quality_metadata` * `call_metadata` * `start_time` * `expire_time` or `ttl` * `data_source.gcs_source.audio_uri` or * `data_source.dialogflow_source.audio_uri` * `data_source.screen_recordings` */
  updateMask?: string;
  /** Optional. Defaults to false. If set to true, and the conversation is not found, a new conversation will be created. In this situation, `update_mask` is ignored. */
  allowMissing?: boolean;
  /** Optional. If set to true, the conversation will be updated with auto labeling results. */
  "conversationAutoLabelingUpdateConfig.allowAutoLabelingUpdate"?: boolean;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1Conversation;
}

export const PatchProjectsLocationsConversationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  allowMissing: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("allowMissing")),
  "conversationAutoLabelingUpdateConfig.allowAutoLabelingUpdate": Schema.optional(Schema.Boolean).pipe(T.HttpQuery("conversationAutoLabelingUpdateConfig.allowAutoLabelingUpdate")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1Conversation).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsConversationsRequest>;

export type PatchProjectsLocationsConversationsResponse = GoogleCloudContactcenterinsightsV1Conversation;
export const PatchProjectsLocationsConversationsResponse = GoogleCloudContactcenterinsightsV1Conversation;

export type PatchProjectsLocationsConversationsError = CommonErrors;

export const patchProjectsLocationsConversations: API.OperationMethod<PatchProjectsLocationsConversationsRequest, PatchProjectsLocationsConversationsResponse, PatchProjectsLocationsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsConversationsRequest,
  output: PatchProjectsLocationsConversationsResponse,
  errors: [],
}));

/** Gets a conversation. */
export interface GetProjectsLocationsConversationsRequest {
  /** Required. The name of the conversation to get. */
  name: string;
  /** The level of details of the conversation. Default is `FULL`. */
  view?: "CONVERSATION_VIEW_UNSPECIFIED" | "FULL" | "BASIC" | (string & {});
}

export const GetProjectsLocationsConversationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  view: Schema.optional(Schema.String).pipe(T.HttpQuery("view")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsConversationsRequest>;

export type GetProjectsLocationsConversationsResponse = GoogleCloudContactcenterinsightsV1Conversation;
export const GetProjectsLocationsConversationsResponse = GoogleCloudContactcenterinsightsV1Conversation;

export type GetProjectsLocationsConversationsError = CommonErrors;

export const getProjectsLocationsConversations: API.OperationMethod<GetProjectsLocationsConversationsRequest, GetProjectsLocationsConversationsResponse, GetProjectsLocationsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsConversationsRequest,
  output: GetProjectsLocationsConversationsResponse,
  errors: [],
}));

/** Lists conversations. */
export interface ListProjectsLocationsConversationsRequest {
  /** Required. The parent resource of the conversation. */
  parent: string;
  /** The maximum number of conversations to return in the response. A valid page size ranges from 0 to 100,000 inclusive. If the page size is zero or unspecified, a default page size of 100 will be chosen. Note that a call might return fewer results than the requested page size. */
  pageSize?: number;
  /** The value returned by the last `ListConversationsResponse`. This value indicates that this is a continuation of a prior `ListConversations` call and that the system should return the next page of data. */
  pageToken?: string;
  /** A filter to reduce results to a specific subset. Useful for querying conversations with specific properties. */
  filter?: string;
  /** Optional. The attribute by which to order conversations in the response. If empty, conversations will be ordered by descending creation time. Supported values are one of the following: * create_time * customer_satisfaction_rating * duration * latest_analysis * start_time * turn_count The default sort order is ascending. To specify order, append `asc` or `desc` (`create_time desc`). For more details, see [Google AIPs Ordering](https://google.aip.dev/132#ordering). */
  orderBy?: string;
  /** The level of details of the conversation. Default is `BASIC`. */
  view?: "CONVERSATION_VIEW_UNSPECIFIED" | "FULL" | "BASIC" | (string & {});
}

export const ListProjectsLocationsConversationsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy")),
  view: Schema.optional(Schema.String).pipe(T.HttpQuery("view")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsConversationsRequest>;

export type ListProjectsLocationsConversationsResponse = GoogleCloudContactcenterinsightsV1ListConversationsResponse;
export const ListProjectsLocationsConversationsResponse = GoogleCloudContactcenterinsightsV1ListConversationsResponse;

export type ListProjectsLocationsConversationsError = CommonErrors;

export const listProjectsLocationsConversations = API.makePaginated(() => ({
  input: ListProjectsLocationsConversationsRequest,
  output: ListProjectsLocationsConversationsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Gets the signed URI for the audio for the given conversation. */
export interface GenerateSignedAudioProjectsLocationsConversationsRequest {
  /** Required. The name of the conversation to sign. */
  name: string;
}

export const GenerateSignedAudioProjectsLocationsConversationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}:generateSignedAudio" }),
  svc,
) as unknown as Schema.Schema<GenerateSignedAudioProjectsLocationsConversationsRequest>;

export type GenerateSignedAudioProjectsLocationsConversationsResponse = GoogleCloudContactcenterinsightsV1GenerateConversationSignedAudioResponse;
export const GenerateSignedAudioProjectsLocationsConversationsResponse = GoogleCloudContactcenterinsightsV1GenerateConversationSignedAudioResponse;

export type GenerateSignedAudioProjectsLocationsConversationsError = CommonErrors;

export const generateSignedAudioProjectsLocationsConversations: API.OperationMethod<GenerateSignedAudioProjectsLocationsConversationsRequest, GenerateSignedAudioProjectsLocationsConversationsResponse, GenerateSignedAudioProjectsLocationsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GenerateSignedAudioProjectsLocationsConversationsRequest,
  output: GenerateSignedAudioProjectsLocationsConversationsResponse,
  errors: [],
}));

/** Deletes a conversation. */
export interface DeleteProjectsLocationsConversationsRequest {
  /** Required. The name of the conversation to delete. */
  name: string;
  /** If set to true, all of this conversation's analyses will also be deleted. Otherwise, the request will only succeed if the conversation has no analyses. */
  force?: boolean;
}

export const DeleteProjectsLocationsConversationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  force: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("force")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsConversationsRequest>;

export type DeleteProjectsLocationsConversationsResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsConversationsResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsConversationsError = CommonErrors;

export const deleteProjectsLocationsConversations: API.OperationMethod<DeleteProjectsLocationsConversationsRequest, DeleteProjectsLocationsConversationsResponse, DeleteProjectsLocationsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsConversationsRequest,
  output: DeleteProjectsLocationsConversationsResponse,
  errors: [],
}));

/** Samples conversations based on user configuration and handles the sampled conversations for different use cases. */
export interface SampleProjectsLocationsConversationsRequest {
  /** Required. The parent resource of the dataset. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1SampleConversationsRequest;
}

export const SampleProjectsLocationsConversationsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1SampleConversationsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations:sample", hasBody: true }),
  svc,
) as unknown as Schema.Schema<SampleProjectsLocationsConversationsRequest>;

export type SampleProjectsLocationsConversationsResponse = GoogleLongrunningOperation;
export const SampleProjectsLocationsConversationsResponse = GoogleLongrunningOperation;

export type SampleProjectsLocationsConversationsError = CommonErrors;

export const sampleProjectsLocationsConversations: API.OperationMethod<SampleProjectsLocationsConversationsRequest, SampleProjectsLocationsConversationsResponse, SampleProjectsLocationsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: SampleProjectsLocationsConversationsRequest,
  output: SampleProjectsLocationsConversationsResponse,
  errors: [],
}));

/** Analyzes multiple conversations in a single request. */
export interface BulkAnalyzeProjectsLocationsConversationsRequest {
  /** Required. The parent resource to create analyses in. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsRequest;
}

export const BulkAnalyzeProjectsLocationsConversationsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations:bulkAnalyze", hasBody: true }),
  svc,
) as unknown as Schema.Schema<BulkAnalyzeProjectsLocationsConversationsRequest>;

export type BulkAnalyzeProjectsLocationsConversationsResponse = GoogleLongrunningOperation;
export const BulkAnalyzeProjectsLocationsConversationsResponse = GoogleLongrunningOperation;

export type BulkAnalyzeProjectsLocationsConversationsError = CommonErrors;

export const bulkAnalyzeProjectsLocationsConversations: API.OperationMethod<BulkAnalyzeProjectsLocationsConversationsRequest, BulkAnalyzeProjectsLocationsConversationsResponse, BulkAnalyzeProjectsLocationsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: BulkAnalyzeProjectsLocationsConversationsRequest,
  output: BulkAnalyzeProjectsLocationsConversationsResponse,
  errors: [],
}));

/** Deletes multiple conversations in a single request. */
export interface BulkDeleteProjectsLocationsConversationsRequest {
  /** Required. The parent resource to delete conversations from. Format: projects/{project}/locations/{location} */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1BulkDeleteConversationsRequest;
}

export const BulkDeleteProjectsLocationsConversationsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1BulkDeleteConversationsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations:bulkDelete", hasBody: true }),
  svc,
) as unknown as Schema.Schema<BulkDeleteProjectsLocationsConversationsRequest>;

export type BulkDeleteProjectsLocationsConversationsResponse = GoogleLongrunningOperation;
export const BulkDeleteProjectsLocationsConversationsResponse = GoogleLongrunningOperation;

export type BulkDeleteProjectsLocationsConversationsError = CommonErrors;

export const bulkDeleteProjectsLocationsConversations: API.OperationMethod<BulkDeleteProjectsLocationsConversationsRequest, BulkDeleteProjectsLocationsConversationsResponse, BulkDeleteProjectsLocationsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: BulkDeleteProjectsLocationsConversationsRequest,
  output: BulkDeleteProjectsLocationsConversationsResponse,
  errors: [],
}));

/** Imports conversations and processes them according to the user's configuration. */
export interface IngestProjectsLocationsConversationsRequest {
  /** Required. The parent resource for new conversations. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1IngestConversationsRequest;
}

export const IngestProjectsLocationsConversationsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1IngestConversationsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations:ingest", hasBody: true }),
  svc,
) as unknown as Schema.Schema<IngestProjectsLocationsConversationsRequest>;

export type IngestProjectsLocationsConversationsResponse = GoogleLongrunningOperation;
export const IngestProjectsLocationsConversationsResponse = GoogleLongrunningOperation;

export type IngestProjectsLocationsConversationsError = CommonErrors;

export const ingestProjectsLocationsConversations: API.OperationMethod<IngestProjectsLocationsConversationsRequest, IngestProjectsLocationsConversationsResponse, IngestProjectsLocationsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: IngestProjectsLocationsConversationsRequest,
  output: IngestProjectsLocationsConversationsResponse,
  errors: [],
}));

/** Gets conversation statistics. */
export interface CalculateStatsProjectsLocationsConversationsRequest {
  /** Required. The location of the conversations. */
  location: string;
  /** A filter to reduce results to a specific subset. This field is useful for getting statistics about conversations with specific properties. */
  filter?: string;
}

export const CalculateStatsProjectsLocationsConversationsRequest = Schema.Struct({
  location: Schema.String.pipe(T.HttpPath("location")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations:calculateStats" }),
  svc,
) as unknown as Schema.Schema<CalculateStatsProjectsLocationsConversationsRequest>;

export type CalculateStatsProjectsLocationsConversationsResponse = GoogleCloudContactcenterinsightsV1CalculateStatsResponse;
export const CalculateStatsProjectsLocationsConversationsResponse = GoogleCloudContactcenterinsightsV1CalculateStatsResponse;

export type CalculateStatsProjectsLocationsConversationsError = CommonErrors;

export const calculateStatsProjectsLocationsConversations: API.OperationMethod<CalculateStatsProjectsLocationsConversationsRequest, CalculateStatsProjectsLocationsConversationsResponse, CalculateStatsProjectsLocationsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CalculateStatsProjectsLocationsConversationsRequest,
  output: CalculateStatsProjectsLocationsConversationsResponse,
  errors: [],
}));

/** Creates an analysis. The long running operation is done when the analysis has completed. */
export interface CreateProjectsLocationsConversationsAnalysesRequest {
  /** Required. The parent resource of the analysis. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1Analysis;
}

export const CreateProjectsLocationsConversationsAnalysesRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1Analysis).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/analyses", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsConversationsAnalysesRequest>;

export type CreateProjectsLocationsConversationsAnalysesResponse = GoogleLongrunningOperation;
export const CreateProjectsLocationsConversationsAnalysesResponse = GoogleLongrunningOperation;

export type CreateProjectsLocationsConversationsAnalysesError = CommonErrors;

export const createProjectsLocationsConversationsAnalyses: API.OperationMethod<CreateProjectsLocationsConversationsAnalysesRequest, CreateProjectsLocationsConversationsAnalysesResponse, CreateProjectsLocationsConversationsAnalysesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsConversationsAnalysesRequest,
  output: CreateProjectsLocationsConversationsAnalysesResponse,
  errors: [],
}));

/** Gets an analysis. */
export interface GetProjectsLocationsConversationsAnalysesRequest {
  /** Required. The name of the analysis to get. */
  name: string;
}

export const GetProjectsLocationsConversationsAnalysesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/analyses/{analysesId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsConversationsAnalysesRequest>;

export type GetProjectsLocationsConversationsAnalysesResponse = GoogleCloudContactcenterinsightsV1Analysis;
export const GetProjectsLocationsConversationsAnalysesResponse = GoogleCloudContactcenterinsightsV1Analysis;

export type GetProjectsLocationsConversationsAnalysesError = CommonErrors;

export const getProjectsLocationsConversationsAnalyses: API.OperationMethod<GetProjectsLocationsConversationsAnalysesRequest, GetProjectsLocationsConversationsAnalysesResponse, GetProjectsLocationsConversationsAnalysesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsConversationsAnalysesRequest,
  output: GetProjectsLocationsConversationsAnalysesResponse,
  errors: [],
}));

/** Lists analyses. */
export interface ListProjectsLocationsConversationsAnalysesRequest {
  /** Required. The parent resource of the analyses. */
  parent: string;
  /** The maximum number of analyses to return in the response. If this value is zero, the service will select a default size. A call might return fewer objects than requested. A non-empty `next_page_token` in the response indicates that more data is available. */
  pageSize?: number;
  /** The value returned by the last `ListAnalysesResponse`; indicates that this is a continuation of a prior `ListAnalyses` call and the system should return the next page of data. */
  pageToken?: string;
  /** A filter to reduce results to a specific subset. Useful for querying conversations with specific properties. */
  filter?: string;
}

export const ListProjectsLocationsConversationsAnalysesRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/analyses" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsConversationsAnalysesRequest>;

export type ListProjectsLocationsConversationsAnalysesResponse = GoogleCloudContactcenterinsightsV1ListAnalysesResponse;
export const ListProjectsLocationsConversationsAnalysesResponse = GoogleCloudContactcenterinsightsV1ListAnalysesResponse;

export type ListProjectsLocationsConversationsAnalysesError = CommonErrors;

export const listProjectsLocationsConversationsAnalyses = API.makePaginated(() => ({
  input: ListProjectsLocationsConversationsAnalysesRequest,
  output: ListProjectsLocationsConversationsAnalysesResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Deletes an analysis. */
export interface DeleteProjectsLocationsConversationsAnalysesRequest {
  /** Required. The name of the analysis to delete. */
  name: string;
}

export const DeleteProjectsLocationsConversationsAnalysesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/analyses/{analysesId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsConversationsAnalysesRequest>;

export type DeleteProjectsLocationsConversationsAnalysesResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsConversationsAnalysesResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsConversationsAnalysesError = CommonErrors;

export const deleteProjectsLocationsConversationsAnalyses: API.OperationMethod<DeleteProjectsLocationsConversationsAnalysesRequest, DeleteProjectsLocationsConversationsAnalysesResponse, DeleteProjectsLocationsConversationsAnalysesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsConversationsAnalysesRequest,
  output: DeleteProjectsLocationsConversationsAnalysesResponse,
  errors: [],
}));

/** Analyzes multiple conversations in a single request. */
export interface BulkAnalyzeProjectsLocationsConversationsSegmentsRequest {
  /** Required. The parent resource to create analyses in. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsRequest;
}

export const BulkAnalyzeProjectsLocationsConversationsSegmentsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1BulkAnalyzeConversationsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/segments:bulkAnalyze", hasBody: true }),
  svc,
) as unknown as Schema.Schema<BulkAnalyzeProjectsLocationsConversationsSegmentsRequest>;

export type BulkAnalyzeProjectsLocationsConversationsSegmentsResponse = GoogleLongrunningOperation;
export const BulkAnalyzeProjectsLocationsConversationsSegmentsResponse = GoogleLongrunningOperation;

export type BulkAnalyzeProjectsLocationsConversationsSegmentsError = CommonErrors;

export const bulkAnalyzeProjectsLocationsConversationsSegments: API.OperationMethod<BulkAnalyzeProjectsLocationsConversationsSegmentsRequest, BulkAnalyzeProjectsLocationsConversationsSegmentsResponse, BulkAnalyzeProjectsLocationsConversationsSegmentsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: BulkAnalyzeProjectsLocationsConversationsSegmentsRequest,
  output: BulkAnalyzeProjectsLocationsConversationsSegmentsResponse,
  errors: [],
}));

/** Create feedback label. */
export interface CreateProjectsLocationsConversationsFeedbackLabelsRequest {
  /** Required. The parent resource of the feedback label. */
  parent: string;
  /** Optional. The ID of the feedback label to create. If one is not specified it will be generated by the server. */
  feedbackLabelId?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1FeedbackLabel;
}

export const CreateProjectsLocationsConversationsFeedbackLabelsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  feedbackLabelId: Schema.optional(Schema.String).pipe(T.HttpQuery("feedbackLabelId")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1FeedbackLabel).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/feedbackLabels", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsConversationsFeedbackLabelsRequest>;

export type CreateProjectsLocationsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1FeedbackLabel;
export const CreateProjectsLocationsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1FeedbackLabel;

export type CreateProjectsLocationsConversationsFeedbackLabelsError = CommonErrors;

export const createProjectsLocationsConversationsFeedbackLabels: API.OperationMethod<CreateProjectsLocationsConversationsFeedbackLabelsRequest, CreateProjectsLocationsConversationsFeedbackLabelsResponse, CreateProjectsLocationsConversationsFeedbackLabelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsConversationsFeedbackLabelsRequest,
  output: CreateProjectsLocationsConversationsFeedbackLabelsResponse,
  errors: [],
}));

/** List feedback labels. */
export interface ListProjectsLocationsConversationsFeedbackLabelsRequest {
  /** Required. The parent resource of the feedback labels. */
  parent: string;
  /** Optional. A filter to reduce results to a specific subset. Supports disjunctions (OR) and conjunctions (AND). Automatically sorts by conversation ID. To sort by all feedback labels in a project see ListAllFeedbackLabels. Supported fields: * `issue_model_id` * `qa_question_id` * `qa_scorecard_id` * `min_create_time` * `max_create_time` * `min_update_time` * `max_update_time` * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING */
  filter?: string;
  /** Optional. The maximum number of feedback labels to return in the response. A valid page size ranges from 0 to 100,000 inclusive. If the page size is zero or unspecified, a default page size of 100 will be chosen. Note that a call might return fewer results than the requested page size. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListFeedbackLabelsResponse`. This value indicates that this is a continuation of a prior `ListFeedbackLabels` call and that the system should return the next page of data. */
  pageToken?: string;
}

export const ListProjectsLocationsConversationsFeedbackLabelsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/feedbackLabels" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsConversationsFeedbackLabelsRequest>;

export type ListProjectsLocationsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1ListFeedbackLabelsResponse;
export const ListProjectsLocationsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1ListFeedbackLabelsResponse;

export type ListProjectsLocationsConversationsFeedbackLabelsError = CommonErrors;

export const listProjectsLocationsConversationsFeedbackLabels = API.makePaginated(() => ({
  input: ListProjectsLocationsConversationsFeedbackLabelsRequest,
  output: ListProjectsLocationsConversationsFeedbackLabelsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Get feedback label. */
export interface GetProjectsLocationsConversationsFeedbackLabelsRequest {
  /** Required. The name of the feedback label to get. */
  name: string;
}

export const GetProjectsLocationsConversationsFeedbackLabelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/feedbackLabels/{feedbackLabelsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsConversationsFeedbackLabelsRequest>;

export type GetProjectsLocationsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1FeedbackLabel;
export const GetProjectsLocationsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1FeedbackLabel;

export type GetProjectsLocationsConversationsFeedbackLabelsError = CommonErrors;

export const getProjectsLocationsConversationsFeedbackLabels: API.OperationMethod<GetProjectsLocationsConversationsFeedbackLabelsRequest, GetProjectsLocationsConversationsFeedbackLabelsResponse, GetProjectsLocationsConversationsFeedbackLabelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsConversationsFeedbackLabelsRequest,
  output: GetProjectsLocationsConversationsFeedbackLabelsResponse,
  errors: [],
}));

/** Update feedback label. */
export interface PatchProjectsLocationsConversationsFeedbackLabelsRequest {
  /** Immutable. Resource name of the FeedbackLabel. Format: projects/{project}/locations/{location}/conversations/{conversation}/feedbackLabels/{feedback_label} */
  name: string;
  /** Required. The list of fields to be updated. */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1FeedbackLabel;
}

export const PatchProjectsLocationsConversationsFeedbackLabelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1FeedbackLabel).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/feedbackLabels/{feedbackLabelsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsConversationsFeedbackLabelsRequest>;

export type PatchProjectsLocationsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1FeedbackLabel;
export const PatchProjectsLocationsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1FeedbackLabel;

export type PatchProjectsLocationsConversationsFeedbackLabelsError = CommonErrors;

export const patchProjectsLocationsConversationsFeedbackLabels: API.OperationMethod<PatchProjectsLocationsConversationsFeedbackLabelsRequest, PatchProjectsLocationsConversationsFeedbackLabelsResponse, PatchProjectsLocationsConversationsFeedbackLabelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsConversationsFeedbackLabelsRequest,
  output: PatchProjectsLocationsConversationsFeedbackLabelsResponse,
  errors: [],
}));

/** Delete feedback label. */
export interface DeleteProjectsLocationsConversationsFeedbackLabelsRequest {
  /** Required. The name of the feedback label to delete. */
  name: string;
}

export const DeleteProjectsLocationsConversationsFeedbackLabelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/feedbackLabels/{feedbackLabelsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsConversationsFeedbackLabelsRequest>;

export type DeleteProjectsLocationsConversationsFeedbackLabelsResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsConversationsFeedbackLabelsResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsConversationsFeedbackLabelsError = CommonErrors;

export const deleteProjectsLocationsConversationsFeedbackLabels: API.OperationMethod<DeleteProjectsLocationsConversationsFeedbackLabelsRequest, DeleteProjectsLocationsConversationsFeedbackLabelsResponse, DeleteProjectsLocationsConversationsFeedbackLabelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsConversationsFeedbackLabelsRequest,
  output: DeleteProjectsLocationsConversationsFeedbackLabelsResponse,
  errors: [],
}));

/** Create Assessment. */
export interface CreateProjectsLocationsConversationsAssessmentsRequest {
  /** Required. The parent resource of the assessment. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1Assessment;
}

export const CreateProjectsLocationsConversationsAssessmentsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1Assessment).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/assessments", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsConversationsAssessmentsRequest>;

export type CreateProjectsLocationsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;
export const CreateProjectsLocationsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;

export type CreateProjectsLocationsConversationsAssessmentsError = CommonErrors;

export const createProjectsLocationsConversationsAssessments: API.OperationMethod<CreateProjectsLocationsConversationsAssessmentsRequest, CreateProjectsLocationsConversationsAssessmentsResponse, CreateProjectsLocationsConversationsAssessmentsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsConversationsAssessmentsRequest,
  output: CreateProjectsLocationsConversationsAssessmentsResponse,
  errors: [],
}));

/** Get Assessment. */
export interface GetProjectsLocationsConversationsAssessmentsRequest {
  /** Required. The name of the assessment to get. */
  name: string;
}

export const GetProjectsLocationsConversationsAssessmentsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/assessments/{assessmentsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsConversationsAssessmentsRequest>;

export type GetProjectsLocationsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;
export const GetProjectsLocationsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;

export type GetProjectsLocationsConversationsAssessmentsError = CommonErrors;

export const getProjectsLocationsConversationsAssessments: API.OperationMethod<GetProjectsLocationsConversationsAssessmentsRequest, GetProjectsLocationsConversationsAssessmentsResponse, GetProjectsLocationsConversationsAssessmentsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsConversationsAssessmentsRequest,
  output: GetProjectsLocationsConversationsAssessmentsResponse,
  errors: [],
}));

/** List Assessments. */
export interface ListProjectsLocationsConversationsAssessmentsRequest {
  /** Required. The parent resource of the assessments. To list all assessments in a location, substitute the conversation ID with a '-' character. */
  parent: string;
  /** The maximum number of assessments to list. If zero, the service will select a default size. A call may return fewer objects than requested. A non-empty `next_page_token` in the response indicates that more data is available. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListAssessmentRulesResponse`; indicates that this is a continuation of a prior `ListAssessmentRules` call and the system should return the next page of data. */
  pageToken?: string;
  /** Optional. A filter to reduce results to a specific subset. Supported filters include: * `state` - The state of the assessment * `agent_info.agent_id` - The ID of the agent the assessment is for */
  filter?: string;
}

export const ListProjectsLocationsConversationsAssessmentsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/assessments" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsConversationsAssessmentsRequest>;

export type ListProjectsLocationsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1ListAssessmentsResponse;
export const ListProjectsLocationsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1ListAssessmentsResponse;

export type ListProjectsLocationsConversationsAssessmentsError = CommonErrors;

export const listProjectsLocationsConversationsAssessments = API.makePaginated(() => ({
  input: ListProjectsLocationsConversationsAssessmentsRequest,
  output: ListProjectsLocationsConversationsAssessmentsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Delete an Assessment. */
export interface DeleteProjectsLocationsConversationsAssessmentsRequest {
  /** Required. The name of the assessment to delete. */
  name: string;
  /** Optional. If set to true, all of this assessment's notes will also be deleted. Otherwise, the request will only succeed if it has no notes. */
  force?: boolean;
}

export const DeleteProjectsLocationsConversationsAssessmentsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  force: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("force")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/assessments/{assessmentsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsConversationsAssessmentsRequest>;

export type DeleteProjectsLocationsConversationsAssessmentsResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsConversationsAssessmentsResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsConversationsAssessmentsError = CommonErrors;

export const deleteProjectsLocationsConversationsAssessments: API.OperationMethod<DeleteProjectsLocationsConversationsAssessmentsRequest, DeleteProjectsLocationsConversationsAssessmentsResponse, DeleteProjectsLocationsConversationsAssessmentsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsConversationsAssessmentsRequest,
  output: DeleteProjectsLocationsConversationsAssessmentsResponse,
  errors: [],
}));

/** Publish an Assessment. */
export interface PublishProjectsLocationsConversationsAssessmentsRequest {
  /** Required. The name of the assessment to publish. */
  name: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1PublishAssessmentRequest;
}

export const PublishProjectsLocationsConversationsAssessmentsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1PublishAssessmentRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/assessments/{assessmentsId}:publish", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PublishProjectsLocationsConversationsAssessmentsRequest>;

export type PublishProjectsLocationsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;
export const PublishProjectsLocationsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;

export type PublishProjectsLocationsConversationsAssessmentsError = CommonErrors;

export const publishProjectsLocationsConversationsAssessments: API.OperationMethod<PublishProjectsLocationsConversationsAssessmentsRequest, PublishProjectsLocationsConversationsAssessmentsResponse, PublishProjectsLocationsConversationsAssessmentsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PublishProjectsLocationsConversationsAssessmentsRequest,
  output: PublishProjectsLocationsConversationsAssessmentsResponse,
  errors: [],
}));

/** Appeal an Assessment. */
export interface AppealProjectsLocationsConversationsAssessmentsRequest {
  /** Required. The name of the assessment to appeal. */
  name: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1AppealAssessmentRequest;
}

export const AppealProjectsLocationsConversationsAssessmentsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1AppealAssessmentRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/assessments/{assessmentsId}:appeal", hasBody: true }),
  svc,
) as unknown as Schema.Schema<AppealProjectsLocationsConversationsAssessmentsRequest>;

export type AppealProjectsLocationsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;
export const AppealProjectsLocationsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;

export type AppealProjectsLocationsConversationsAssessmentsError = CommonErrors;

export const appealProjectsLocationsConversationsAssessments: API.OperationMethod<AppealProjectsLocationsConversationsAssessmentsRequest, AppealProjectsLocationsConversationsAssessmentsResponse, AppealProjectsLocationsConversationsAssessmentsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: AppealProjectsLocationsConversationsAssessmentsRequest,
  output: AppealProjectsLocationsConversationsAssessmentsResponse,
  errors: [],
}));

/** Finalize an Assessment. */
export interface FinalizeProjectsLocationsConversationsAssessmentsRequest {
  /** Required. The name of the assessment to finalize. */
  name: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1FinalizeAssessmentRequest;
}

export const FinalizeProjectsLocationsConversationsAssessmentsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1FinalizeAssessmentRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/assessments/{assessmentsId}:finalize", hasBody: true }),
  svc,
) as unknown as Schema.Schema<FinalizeProjectsLocationsConversationsAssessmentsRequest>;

export type FinalizeProjectsLocationsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;
export const FinalizeProjectsLocationsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;

export type FinalizeProjectsLocationsConversationsAssessmentsError = CommonErrors;

export const finalizeProjectsLocationsConversationsAssessments: API.OperationMethod<FinalizeProjectsLocationsConversationsAssessmentsRequest, FinalizeProjectsLocationsConversationsAssessmentsResponse, FinalizeProjectsLocationsConversationsAssessmentsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: FinalizeProjectsLocationsConversationsAssessmentsRequest,
  output: FinalizeProjectsLocationsConversationsAssessmentsResponse,
  errors: [],
}));

/** Create Note. */
export interface CreateProjectsLocationsConversationsAssessmentsNotesRequest {
  /** Required. The parent resource of the note. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1Note;
}

export const CreateProjectsLocationsConversationsAssessmentsNotesRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1Note).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/assessments/{assessmentsId}/notes", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsConversationsAssessmentsNotesRequest>;

export type CreateProjectsLocationsConversationsAssessmentsNotesResponse = GoogleCloudContactcenterinsightsV1Note;
export const CreateProjectsLocationsConversationsAssessmentsNotesResponse = GoogleCloudContactcenterinsightsV1Note;

export type CreateProjectsLocationsConversationsAssessmentsNotesError = CommonErrors;

export const createProjectsLocationsConversationsAssessmentsNotes: API.OperationMethod<CreateProjectsLocationsConversationsAssessmentsNotesRequest, CreateProjectsLocationsConversationsAssessmentsNotesResponse, CreateProjectsLocationsConversationsAssessmentsNotesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsConversationsAssessmentsNotesRequest,
  output: CreateProjectsLocationsConversationsAssessmentsNotesResponse,
  errors: [],
}));

/** List Notes. */
export interface ListProjectsLocationsConversationsAssessmentsNotesRequest {
  /** Required. The parent resource of the notes. */
  parent: string;
  /** Optional. The maximum number of notes to return in the response. If zero the service will select a default size. A call might return fewer objects than requested. A non-empty `next_page_token` in the response indicates that more data is available. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListNotesResponse`. This value indicates that this is a continuation of a prior `ListNotes` call and that the system should return the next page of data. */
  pageToken?: string;
}

export const ListProjectsLocationsConversationsAssessmentsNotesRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/assessments/{assessmentsId}/notes" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsConversationsAssessmentsNotesRequest>;

export type ListProjectsLocationsConversationsAssessmentsNotesResponse = GoogleCloudContactcenterinsightsV1ListNotesResponse;
export const ListProjectsLocationsConversationsAssessmentsNotesResponse = GoogleCloudContactcenterinsightsV1ListNotesResponse;

export type ListProjectsLocationsConversationsAssessmentsNotesError = CommonErrors;

export const listProjectsLocationsConversationsAssessmentsNotes = API.makePaginated(() => ({
  input: ListProjectsLocationsConversationsAssessmentsNotesRequest,
  output: ListProjectsLocationsConversationsAssessmentsNotesResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Update Note. */
export interface PatchProjectsLocationsConversationsAssessmentsNotesRequest {
  /** Identifier. The resource name of the note. Format: projects/{project}/locations/{location}/conversations/{conversation}/assessments/{assessment}/notes/{note} */
  name: string;
  /** Optional. The list of fields to be updated. If the update_mask is empty, all updateable fields will be updated. Acceptable fields include: * `content` */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1Note;
}

export const PatchProjectsLocationsConversationsAssessmentsNotesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1Note).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/assessments/{assessmentsId}/notes/{notesId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsConversationsAssessmentsNotesRequest>;

export type PatchProjectsLocationsConversationsAssessmentsNotesResponse = GoogleCloudContactcenterinsightsV1Note;
export const PatchProjectsLocationsConversationsAssessmentsNotesResponse = GoogleCloudContactcenterinsightsV1Note;

export type PatchProjectsLocationsConversationsAssessmentsNotesError = CommonErrors;

export const patchProjectsLocationsConversationsAssessmentsNotes: API.OperationMethod<PatchProjectsLocationsConversationsAssessmentsNotesRequest, PatchProjectsLocationsConversationsAssessmentsNotesResponse, PatchProjectsLocationsConversationsAssessmentsNotesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsConversationsAssessmentsNotesRequest,
  output: PatchProjectsLocationsConversationsAssessmentsNotesResponse,
  errors: [],
}));

/** Deletes a Note. */
export interface DeleteProjectsLocationsConversationsAssessmentsNotesRequest {
  /** Required. The name of the note to delete. */
  name: string;
}

export const DeleteProjectsLocationsConversationsAssessmentsNotesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/conversations/{conversationsId}/assessments/{assessmentsId}/notes/{notesId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsConversationsAssessmentsNotesRequest>;

export type DeleteProjectsLocationsConversationsAssessmentsNotesResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsConversationsAssessmentsNotesResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsConversationsAssessmentsNotesError = CommonErrors;

export const deleteProjectsLocationsConversationsAssessmentsNotes: API.OperationMethod<DeleteProjectsLocationsConversationsAssessmentsNotesRequest, DeleteProjectsLocationsConversationsAssessmentsNotesResponse, DeleteProjectsLocationsConversationsAssessmentsNotesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsConversationsAssessmentsNotesRequest,
  output: DeleteProjectsLocationsConversationsAssessmentsNotesResponse,
  errors: [],
}));

/** Creates a dataset. */
export interface CreateProjectsLocationsDatasetsRequest {
  /** Required. The parent resource of the dataset. */
  parent: string;
  /** Optional. The ID to use for the dataset. */
  datasetId?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1Dataset;
}

export const CreateProjectsLocationsDatasetsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  datasetId: Schema.optional(Schema.String).pipe(T.HttpQuery("datasetId")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1Dataset).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsDatasetsRequest>;

export type CreateProjectsLocationsDatasetsResponse = GoogleCloudContactcenterinsightsV1Dataset;
export const CreateProjectsLocationsDatasetsResponse = GoogleCloudContactcenterinsightsV1Dataset;

export type CreateProjectsLocationsDatasetsError = CommonErrors;

export const createProjectsLocationsDatasets: API.OperationMethod<CreateProjectsLocationsDatasetsRequest, CreateProjectsLocationsDatasetsResponse, CreateProjectsLocationsDatasetsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsDatasetsRequest,
  output: CreateProjectsLocationsDatasetsResponse,
  errors: [],
}));

/** List datasets matching the input. */
export interface ListProjectsLocationsDatasetsRequest {
  /** Required. The parent resource of the dataset. */
  parent: string;
  /** Optional. The maximum number of datasets to return in the response. If this value is zero, the service will select a default size. A call might return fewer objects than requested. A non-empty `next_page_token` in the response indicates that more data is available. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListDatasetsResponse`; indicates that this is a continuation of a prior `ListDatasets` call and the system should return the next page of data. */
  pageToken?: string;
  /** Optional. A filter to reduce results to a specific subset. Useful for querying datasets with specific properties. Supported fields include, for Q2 though we only support list by project: - `type` - `description` - `project_number` */
  filter?: string;
}

export const ListProjectsLocationsDatasetsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsDatasetsRequest>;

export type ListProjectsLocationsDatasetsResponse = GoogleCloudContactcenterinsightsV1ListDatasetsResponse;
export const ListProjectsLocationsDatasetsResponse = GoogleCloudContactcenterinsightsV1ListDatasetsResponse;

export type ListProjectsLocationsDatasetsError = CommonErrors;

export const listProjectsLocationsDatasets = API.makePaginated(() => ({
  input: ListProjectsLocationsDatasetsRequest,
  output: ListProjectsLocationsDatasetsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Gets a dataset. */
export interface GetProjectsLocationsDatasetsRequest {
  /** Required. The name of the dataset to get. */
  name: string;
}

export const GetProjectsLocationsDatasetsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsDatasetsRequest>;

export type GetProjectsLocationsDatasetsResponse = GoogleCloudContactcenterinsightsV1Dataset;
export const GetProjectsLocationsDatasetsResponse = GoogleCloudContactcenterinsightsV1Dataset;

export type GetProjectsLocationsDatasetsError = CommonErrors;

export const getProjectsLocationsDatasets: API.OperationMethod<GetProjectsLocationsDatasetsRequest, GetProjectsLocationsDatasetsResponse, GetProjectsLocationsDatasetsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsDatasetsRequest,
  output: GetProjectsLocationsDatasetsResponse,
  errors: [],
}));

/** Updates a dataset. */
export interface PatchProjectsLocationsDatasetsRequest {
  /** Immutable. Identifier. Resource name of the dataset. Format: projects/{project}/locations/{location}/datasets/{dataset} */
  name: string;
  /** Optional. The list of fields to update. */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1Dataset;
}

export const PatchProjectsLocationsDatasetsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1Dataset).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsDatasetsRequest>;

export type PatchProjectsLocationsDatasetsResponse = GoogleCloudContactcenterinsightsV1Dataset;
export const PatchProjectsLocationsDatasetsResponse = GoogleCloudContactcenterinsightsV1Dataset;

export type PatchProjectsLocationsDatasetsError = CommonErrors;

export const patchProjectsLocationsDatasets: API.OperationMethod<PatchProjectsLocationsDatasetsRequest, PatchProjectsLocationsDatasetsResponse, PatchProjectsLocationsDatasetsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsDatasetsRequest,
  output: PatchProjectsLocationsDatasetsResponse,
  errors: [],
}));

/** Delete a dataset. */
export interface DeleteProjectsLocationsDatasetsRequest {
  /** Required. The name of the dataset to delete. */
  name: string;
}

export const DeleteProjectsLocationsDatasetsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsDatasetsRequest>;

export type DeleteProjectsLocationsDatasetsResponse = GoogleLongrunningOperation;
export const DeleteProjectsLocationsDatasetsResponse = GoogleLongrunningOperation;

export type DeleteProjectsLocationsDatasetsError = CommonErrors;

export const deleteProjectsLocationsDatasets: API.OperationMethod<DeleteProjectsLocationsDatasetsRequest, DeleteProjectsLocationsDatasetsResponse, DeleteProjectsLocationsDatasetsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsDatasetsRequest,
  output: DeleteProjectsLocationsDatasetsResponse,
  errors: [],
}));

/** List all feedback labels by project number. */
export interface ListAllFeedbackLabelsProjectsLocationsDatasetsRequest {
  /** Required. The parent resource of all feedback labels per project. */
  parent: string;
  /** Optional. The maximum number of feedback labels to return in the response. A valid page size ranges from 0 to 100,000 inclusive. If the page size is zero or unspecified, a default page size of 100 will be chosen. Note that a call might return fewer results than the requested page size. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListAllFeedbackLabelsResponse`. This value indicates that this is a continuation of a prior `ListAllFeedbackLabels` call and that the system should return the next page of data. */
  pageToken?: string;
  /** Optional. A filter to reduce results to a specific subset in the entire project. Supports disjunctions (OR) and conjunctions (AND). Supported fields: * `issue_model_id` * `qa_question_id` * `min_create_time` * `max_create_time` * `min_update_time` * `max_update_time` * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING */
  filter?: string;
}

export const ListAllFeedbackLabelsProjectsLocationsDatasetsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}:listAllFeedbackLabels" }),
  svc,
) as unknown as Schema.Schema<ListAllFeedbackLabelsProjectsLocationsDatasetsRequest>;

export type ListAllFeedbackLabelsProjectsLocationsDatasetsResponse = GoogleCloudContactcenterinsightsV1ListAllFeedbackLabelsResponse;
export const ListAllFeedbackLabelsProjectsLocationsDatasetsResponse = GoogleCloudContactcenterinsightsV1ListAllFeedbackLabelsResponse;

export type ListAllFeedbackLabelsProjectsLocationsDatasetsError = CommonErrors;

export const listAllFeedbackLabelsProjectsLocationsDatasets = API.makePaginated(() => ({
  input: ListAllFeedbackLabelsProjectsLocationsDatasetsRequest,
  output: ListAllFeedbackLabelsProjectsLocationsDatasetsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Upload feedback labels from an external source in bulk. Currently supports labeling Quality AI example conversations. */
export interface BulkUploadFeedbackLabelsProjectsLocationsDatasetsRequest {
  /** Required. The parent resource for new feedback labels. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequest;
}

export const BulkUploadFeedbackLabelsProjectsLocationsDatasetsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1BulkUploadFeedbackLabelsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}:bulkUploadFeedbackLabels", hasBody: true }),
  svc,
) as unknown as Schema.Schema<BulkUploadFeedbackLabelsProjectsLocationsDatasetsRequest>;

export type BulkUploadFeedbackLabelsProjectsLocationsDatasetsResponse = GoogleLongrunningOperation;
export const BulkUploadFeedbackLabelsProjectsLocationsDatasetsResponse = GoogleLongrunningOperation;

export type BulkUploadFeedbackLabelsProjectsLocationsDatasetsError = CommonErrors;

export const bulkUploadFeedbackLabelsProjectsLocationsDatasets: API.OperationMethod<BulkUploadFeedbackLabelsProjectsLocationsDatasetsRequest, BulkUploadFeedbackLabelsProjectsLocationsDatasetsResponse, BulkUploadFeedbackLabelsProjectsLocationsDatasetsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: BulkUploadFeedbackLabelsProjectsLocationsDatasetsRequest,
  output: BulkUploadFeedbackLabelsProjectsLocationsDatasetsResponse,
  errors: [],
}));

/** Download feedback labels in bulk from an external source. Currently supports exporting Quality AI example conversations with transcripts and question bodies. */
export interface BulkDownloadFeedbackLabelsProjectsLocationsDatasetsRequest {
  /** Required. The parent resource for new feedback labels. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequest;
}

export const BulkDownloadFeedbackLabelsProjectsLocationsDatasetsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1BulkDownloadFeedbackLabelsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}:bulkDownloadFeedbackLabels", hasBody: true }),
  svc,
) as unknown as Schema.Schema<BulkDownloadFeedbackLabelsProjectsLocationsDatasetsRequest>;

export type BulkDownloadFeedbackLabelsProjectsLocationsDatasetsResponse = GoogleLongrunningOperation;
export const BulkDownloadFeedbackLabelsProjectsLocationsDatasetsResponse = GoogleLongrunningOperation;

export type BulkDownloadFeedbackLabelsProjectsLocationsDatasetsError = CommonErrors;

export const bulkDownloadFeedbackLabelsProjectsLocationsDatasets: API.OperationMethod<BulkDownloadFeedbackLabelsProjectsLocationsDatasetsRequest, BulkDownloadFeedbackLabelsProjectsLocationsDatasetsResponse, BulkDownloadFeedbackLabelsProjectsLocationsDatasetsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: BulkDownloadFeedbackLabelsProjectsLocationsDatasetsRequest,
  output: BulkDownloadFeedbackLabelsProjectsLocationsDatasetsResponse,
  errors: [],
}));

/** Delete feedback labels in bulk using a filter. */
export interface BulkDeleteFeedbackLabelsProjectsLocationsDatasetsRequest {
  /** Required. The parent resource for new feedback labels. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsRequest;
}

export const BulkDeleteFeedbackLabelsProjectsLocationsDatasetsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1BulkDeleteFeedbackLabelsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}:bulkDeleteFeedbackLabels", hasBody: true }),
  svc,
) as unknown as Schema.Schema<BulkDeleteFeedbackLabelsProjectsLocationsDatasetsRequest>;

export type BulkDeleteFeedbackLabelsProjectsLocationsDatasetsResponse = GoogleLongrunningOperation;
export const BulkDeleteFeedbackLabelsProjectsLocationsDatasetsResponse = GoogleLongrunningOperation;

export type BulkDeleteFeedbackLabelsProjectsLocationsDatasetsError = CommonErrors;

export const bulkDeleteFeedbackLabelsProjectsLocationsDatasets: API.OperationMethod<BulkDeleteFeedbackLabelsProjectsLocationsDatasetsRequest, BulkDeleteFeedbackLabelsProjectsLocationsDatasetsResponse, BulkDeleteFeedbackLabelsProjectsLocationsDatasetsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: BulkDeleteFeedbackLabelsProjectsLocationsDatasetsRequest,
  output: BulkDeleteFeedbackLabelsProjectsLocationsDatasetsResponse,
  errors: [],
}));

/** Gets a conversation. */
export interface GetProjectsLocationsDatasetsConversationsRequest {
  /** Required. The name of the conversation to get. */
  name: string;
  /** The level of details of the conversation. Default is `FULL`. */
  view?: "CONVERSATION_VIEW_UNSPECIFIED" | "FULL" | "BASIC" | (string & {});
}

export const GetProjectsLocationsDatasetsConversationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  view: Schema.optional(Schema.String).pipe(T.HttpQuery("view")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}/conversations/{conversationsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsDatasetsConversationsRequest>;

export type GetProjectsLocationsDatasetsConversationsResponse = GoogleCloudContactcenterinsightsV1Conversation;
export const GetProjectsLocationsDatasetsConversationsResponse = GoogleCloudContactcenterinsightsV1Conversation;

export type GetProjectsLocationsDatasetsConversationsError = CommonErrors;

export const getProjectsLocationsDatasetsConversations: API.OperationMethod<GetProjectsLocationsDatasetsConversationsRequest, GetProjectsLocationsDatasetsConversationsResponse, GetProjectsLocationsDatasetsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsDatasetsConversationsRequest,
  output: GetProjectsLocationsDatasetsConversationsResponse,
  errors: [],
}));

/** Lists conversations. */
export interface ListProjectsLocationsDatasetsConversationsRequest {
  /** Required. The parent resource of the conversation. */
  parent: string;
  /** The maximum number of conversations to return in the response. A valid page size ranges from 0 to 100,000 inclusive. If the page size is zero or unspecified, a default page size of 100 will be chosen. Note that a call might return fewer results than the requested page size. */
  pageSize?: number;
  /** The value returned by the last `ListConversationsResponse`. This value indicates that this is a continuation of a prior `ListConversations` call and that the system should return the next page of data. */
  pageToken?: string;
  /** A filter to reduce results to a specific subset. Useful for querying conversations with specific properties. */
  filter?: string;
  /** Optional. The attribute by which to order conversations in the response. If empty, conversations will be ordered by descending creation time. Supported values are one of the following: * create_time * customer_satisfaction_rating * duration * latest_analysis * start_time * turn_count The default sort order is ascending. To specify order, append `asc` or `desc` (`create_time desc`). For more details, see [Google AIPs Ordering](https://google.aip.dev/132#ordering). */
  orderBy?: string;
  /** The level of details of the conversation. Default is `BASIC`. */
  view?: "CONVERSATION_VIEW_UNSPECIFIED" | "FULL" | "BASIC" | (string & {});
}

export const ListProjectsLocationsDatasetsConversationsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy")),
  view: Schema.optional(Schema.String).pipe(T.HttpQuery("view")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}/conversations" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsDatasetsConversationsRequest>;

export type ListProjectsLocationsDatasetsConversationsResponse = GoogleCloudContactcenterinsightsV1ListConversationsResponse;
export const ListProjectsLocationsDatasetsConversationsResponse = GoogleCloudContactcenterinsightsV1ListConversationsResponse;

export type ListProjectsLocationsDatasetsConversationsError = CommonErrors;

export const listProjectsLocationsDatasetsConversations = API.makePaginated(() => ({
  input: ListProjectsLocationsDatasetsConversationsRequest,
  output: ListProjectsLocationsDatasetsConversationsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Gets the signed URI for the audio for the given conversation. */
export interface GenerateSignedAudioProjectsLocationsDatasetsConversationsRequest {
  /** Required. The name of the conversation to sign. */
  name: string;
}

export const GenerateSignedAudioProjectsLocationsDatasetsConversationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}/conversations/{conversationsId}:generateSignedAudio" }),
  svc,
) as unknown as Schema.Schema<GenerateSignedAudioProjectsLocationsDatasetsConversationsRequest>;

export type GenerateSignedAudioProjectsLocationsDatasetsConversationsResponse = GoogleCloudContactcenterinsightsV1GenerateConversationSignedAudioResponse;
export const GenerateSignedAudioProjectsLocationsDatasetsConversationsResponse = GoogleCloudContactcenterinsightsV1GenerateConversationSignedAudioResponse;

export type GenerateSignedAudioProjectsLocationsDatasetsConversationsError = CommonErrors;

export const generateSignedAudioProjectsLocationsDatasetsConversations: API.OperationMethod<GenerateSignedAudioProjectsLocationsDatasetsConversationsRequest, GenerateSignedAudioProjectsLocationsDatasetsConversationsResponse, GenerateSignedAudioProjectsLocationsDatasetsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GenerateSignedAudioProjectsLocationsDatasetsConversationsRequest,
  output: GenerateSignedAudioProjectsLocationsDatasetsConversationsResponse,
  errors: [],
}));

/** Deletes a conversation. */
export interface DeleteProjectsLocationsDatasetsConversationsRequest {
  /** Required. The name of the conversation to delete. */
  name: string;
  /** If set to true, all of this conversation's analyses will also be deleted. Otherwise, the request will only succeed if the conversation has no analyses. */
  force?: boolean;
}

export const DeleteProjectsLocationsDatasetsConversationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  force: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("force")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}/conversations/{conversationsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsDatasetsConversationsRequest>;

export type DeleteProjectsLocationsDatasetsConversationsResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsDatasetsConversationsResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsDatasetsConversationsError = CommonErrors;

export const deleteProjectsLocationsDatasetsConversations: API.OperationMethod<DeleteProjectsLocationsDatasetsConversationsRequest, DeleteProjectsLocationsDatasetsConversationsResponse, DeleteProjectsLocationsDatasetsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsDatasetsConversationsRequest,
  output: DeleteProjectsLocationsDatasetsConversationsResponse,
  errors: [],
}));

/** Samples conversations based on user configuration and handles the sampled conversations for different use cases. */
export interface SampleProjectsLocationsDatasetsConversationsRequest {
  /** Required. The parent resource of the dataset. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1SampleConversationsRequest;
}

export const SampleProjectsLocationsDatasetsConversationsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1SampleConversationsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}/conversations:sample", hasBody: true }),
  svc,
) as unknown as Schema.Schema<SampleProjectsLocationsDatasetsConversationsRequest>;

export type SampleProjectsLocationsDatasetsConversationsResponse = GoogleLongrunningOperation;
export const SampleProjectsLocationsDatasetsConversationsResponse = GoogleLongrunningOperation;

export type SampleProjectsLocationsDatasetsConversationsError = CommonErrors;

export const sampleProjectsLocationsDatasetsConversations: API.OperationMethod<SampleProjectsLocationsDatasetsConversationsRequest, SampleProjectsLocationsDatasetsConversationsResponse, SampleProjectsLocationsDatasetsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: SampleProjectsLocationsDatasetsConversationsRequest,
  output: SampleProjectsLocationsDatasetsConversationsResponse,
  errors: [],
}));

/** Deletes multiple conversations in a single request. */
export interface BulkDeleteProjectsLocationsDatasetsConversationsRequest {
  /** Required. The parent resource to delete conversations from. Format: projects/{project}/locations/{location} */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1BulkDeleteConversationsRequest;
}

export const BulkDeleteProjectsLocationsDatasetsConversationsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1BulkDeleteConversationsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}/conversations:bulkDelete", hasBody: true }),
  svc,
) as unknown as Schema.Schema<BulkDeleteProjectsLocationsDatasetsConversationsRequest>;

export type BulkDeleteProjectsLocationsDatasetsConversationsResponse = GoogleLongrunningOperation;
export const BulkDeleteProjectsLocationsDatasetsConversationsResponse = GoogleLongrunningOperation;

export type BulkDeleteProjectsLocationsDatasetsConversationsError = CommonErrors;

export const bulkDeleteProjectsLocationsDatasetsConversations: API.OperationMethod<BulkDeleteProjectsLocationsDatasetsConversationsRequest, BulkDeleteProjectsLocationsDatasetsConversationsResponse, BulkDeleteProjectsLocationsDatasetsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: BulkDeleteProjectsLocationsDatasetsConversationsRequest,
  output: BulkDeleteProjectsLocationsDatasetsConversationsResponse,
  errors: [],
}));

/** Imports conversations and processes them according to the user's configuration. */
export interface IngestProjectsLocationsDatasetsConversationsRequest {
  /** Required. The parent resource for new conversations. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1IngestConversationsRequest;
}

export const IngestProjectsLocationsDatasetsConversationsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1IngestConversationsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}/conversations:ingest", hasBody: true }),
  svc,
) as unknown as Schema.Schema<IngestProjectsLocationsDatasetsConversationsRequest>;

export type IngestProjectsLocationsDatasetsConversationsResponse = GoogleLongrunningOperation;
export const IngestProjectsLocationsDatasetsConversationsResponse = GoogleLongrunningOperation;

export type IngestProjectsLocationsDatasetsConversationsError = CommonErrors;

export const ingestProjectsLocationsDatasetsConversations: API.OperationMethod<IngestProjectsLocationsDatasetsConversationsRequest, IngestProjectsLocationsDatasetsConversationsResponse, IngestProjectsLocationsDatasetsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: IngestProjectsLocationsDatasetsConversationsRequest,
  output: IngestProjectsLocationsDatasetsConversationsResponse,
  errors: [],
}));

/** Gets conversation statistics. */
export interface CalculateStatsProjectsLocationsDatasetsConversationsRequest {
  /** Required. The location of the conversations. */
  location: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1CalculateStatsRequest;
}

export const CalculateStatsProjectsLocationsDatasetsConversationsRequest = Schema.Struct({
  location: Schema.String.pipe(T.HttpPath("location")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1CalculateStatsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}/conversations:calculateStats", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CalculateStatsProjectsLocationsDatasetsConversationsRequest>;

export type CalculateStatsProjectsLocationsDatasetsConversationsResponse = GoogleCloudContactcenterinsightsV1CalculateStatsResponse;
export const CalculateStatsProjectsLocationsDatasetsConversationsResponse = GoogleCloudContactcenterinsightsV1CalculateStatsResponse;

export type CalculateStatsProjectsLocationsDatasetsConversationsError = CommonErrors;

export const calculateStatsProjectsLocationsDatasetsConversations: API.OperationMethod<CalculateStatsProjectsLocationsDatasetsConversationsRequest, CalculateStatsProjectsLocationsDatasetsConversationsResponse, CalculateStatsProjectsLocationsDatasetsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CalculateStatsProjectsLocationsDatasetsConversationsRequest,
  output: CalculateStatsProjectsLocationsDatasetsConversationsResponse,
  errors: [],
}));

/** Create feedback label. */
export interface CreateProjectsLocationsDatasetsConversationsFeedbackLabelsRequest {
  /** Required. The parent resource of the feedback label. */
  parent: string;
  /** Optional. The ID of the feedback label to create. If one is not specified it will be generated by the server. */
  feedbackLabelId?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1FeedbackLabel;
}

export const CreateProjectsLocationsDatasetsConversationsFeedbackLabelsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  feedbackLabelId: Schema.optional(Schema.String).pipe(T.HttpQuery("feedbackLabelId")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1FeedbackLabel).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}/conversations/{conversationsId}/feedbackLabels", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsDatasetsConversationsFeedbackLabelsRequest>;

export type CreateProjectsLocationsDatasetsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1FeedbackLabel;
export const CreateProjectsLocationsDatasetsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1FeedbackLabel;

export type CreateProjectsLocationsDatasetsConversationsFeedbackLabelsError = CommonErrors;

export const createProjectsLocationsDatasetsConversationsFeedbackLabels: API.OperationMethod<CreateProjectsLocationsDatasetsConversationsFeedbackLabelsRequest, CreateProjectsLocationsDatasetsConversationsFeedbackLabelsResponse, CreateProjectsLocationsDatasetsConversationsFeedbackLabelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsDatasetsConversationsFeedbackLabelsRequest,
  output: CreateProjectsLocationsDatasetsConversationsFeedbackLabelsResponse,
  errors: [],
}));

/** List feedback labels. */
export interface ListProjectsLocationsDatasetsConversationsFeedbackLabelsRequest {
  /** Required. The parent resource of the feedback labels. */
  parent: string;
  /** Optional. A filter to reduce results to a specific subset. Supports disjunctions (OR) and conjunctions (AND). Automatically sorts by conversation ID. To sort by all feedback labels in a project see ListAllFeedbackLabels. Supported fields: * `issue_model_id` * `qa_question_id` * `qa_scorecard_id` * `min_create_time` * `max_create_time` * `min_update_time` * `max_update_time` * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING */
  filter?: string;
  /** Optional. The maximum number of feedback labels to return in the response. A valid page size ranges from 0 to 100,000 inclusive. If the page size is zero or unspecified, a default page size of 100 will be chosen. Note that a call might return fewer results than the requested page size. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListFeedbackLabelsResponse`. This value indicates that this is a continuation of a prior `ListFeedbackLabels` call and that the system should return the next page of data. */
  pageToken?: string;
}

export const ListProjectsLocationsDatasetsConversationsFeedbackLabelsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}/conversations/{conversationsId}/feedbackLabels" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsDatasetsConversationsFeedbackLabelsRequest>;

export type ListProjectsLocationsDatasetsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1ListFeedbackLabelsResponse;
export const ListProjectsLocationsDatasetsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1ListFeedbackLabelsResponse;

export type ListProjectsLocationsDatasetsConversationsFeedbackLabelsError = CommonErrors;

export const listProjectsLocationsDatasetsConversationsFeedbackLabels = API.makePaginated(() => ({
  input: ListProjectsLocationsDatasetsConversationsFeedbackLabelsRequest,
  output: ListProjectsLocationsDatasetsConversationsFeedbackLabelsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Get feedback label. */
export interface GetProjectsLocationsDatasetsConversationsFeedbackLabelsRequest {
  /** Required. The name of the feedback label to get. */
  name: string;
}

export const GetProjectsLocationsDatasetsConversationsFeedbackLabelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}/conversations/{conversationsId}/feedbackLabels/{feedbackLabelsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsDatasetsConversationsFeedbackLabelsRequest>;

export type GetProjectsLocationsDatasetsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1FeedbackLabel;
export const GetProjectsLocationsDatasetsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1FeedbackLabel;

export type GetProjectsLocationsDatasetsConversationsFeedbackLabelsError = CommonErrors;

export const getProjectsLocationsDatasetsConversationsFeedbackLabels: API.OperationMethod<GetProjectsLocationsDatasetsConversationsFeedbackLabelsRequest, GetProjectsLocationsDatasetsConversationsFeedbackLabelsResponse, GetProjectsLocationsDatasetsConversationsFeedbackLabelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsDatasetsConversationsFeedbackLabelsRequest,
  output: GetProjectsLocationsDatasetsConversationsFeedbackLabelsResponse,
  errors: [],
}));

/** Update feedback label. */
export interface PatchProjectsLocationsDatasetsConversationsFeedbackLabelsRequest {
  /** Immutable. Resource name of the FeedbackLabel. Format: projects/{project}/locations/{location}/conversations/{conversation}/feedbackLabels/{feedback_label} */
  name: string;
  /** Required. The list of fields to be updated. */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1FeedbackLabel;
}

export const PatchProjectsLocationsDatasetsConversationsFeedbackLabelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1FeedbackLabel).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}/conversations/{conversationsId}/feedbackLabels/{feedbackLabelsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsDatasetsConversationsFeedbackLabelsRequest>;

export type PatchProjectsLocationsDatasetsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1FeedbackLabel;
export const PatchProjectsLocationsDatasetsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1FeedbackLabel;

export type PatchProjectsLocationsDatasetsConversationsFeedbackLabelsError = CommonErrors;

export const patchProjectsLocationsDatasetsConversationsFeedbackLabels: API.OperationMethod<PatchProjectsLocationsDatasetsConversationsFeedbackLabelsRequest, PatchProjectsLocationsDatasetsConversationsFeedbackLabelsResponse, PatchProjectsLocationsDatasetsConversationsFeedbackLabelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsDatasetsConversationsFeedbackLabelsRequest,
  output: PatchProjectsLocationsDatasetsConversationsFeedbackLabelsResponse,
  errors: [],
}));

/** Delete feedback label. */
export interface DeleteProjectsLocationsDatasetsConversationsFeedbackLabelsRequest {
  /** Required. The name of the feedback label to delete. */
  name: string;
}

export const DeleteProjectsLocationsDatasetsConversationsFeedbackLabelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}/conversations/{conversationsId}/feedbackLabels/{feedbackLabelsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsDatasetsConversationsFeedbackLabelsRequest>;

export type DeleteProjectsLocationsDatasetsConversationsFeedbackLabelsResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsDatasetsConversationsFeedbackLabelsResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsDatasetsConversationsFeedbackLabelsError = CommonErrors;

export const deleteProjectsLocationsDatasetsConversationsFeedbackLabels: API.OperationMethod<DeleteProjectsLocationsDatasetsConversationsFeedbackLabelsRequest, DeleteProjectsLocationsDatasetsConversationsFeedbackLabelsResponse, DeleteProjectsLocationsDatasetsConversationsFeedbackLabelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsDatasetsConversationsFeedbackLabelsRequest,
  output: DeleteProjectsLocationsDatasetsConversationsFeedbackLabelsResponse,
  errors: [],
}));

/** Export insights data to a destination defined in the request body. */
export interface ExportProjectsLocationsDatasetsInsightsdataRequest {
  /** Required. The parent resource to export data from. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1ExportInsightsDataRequest;
}

export const ExportProjectsLocationsDatasetsInsightsdataRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1ExportInsightsDataRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/datasets/{datasetsId}/insightsdata:export", hasBody: true }),
  svc,
) as unknown as Schema.Schema<ExportProjectsLocationsDatasetsInsightsdataRequest>;

export type ExportProjectsLocationsDatasetsInsightsdataResponse = GoogleLongrunningOperation;
export const ExportProjectsLocationsDatasetsInsightsdataResponse = GoogleLongrunningOperation;

export type ExportProjectsLocationsDatasetsInsightsdataError = CommonErrors;

export const exportProjectsLocationsDatasetsInsightsdata: API.OperationMethod<ExportProjectsLocationsDatasetsInsightsdataRequest, ExportProjectsLocationsDatasetsInsightsdataResponse, ExportProjectsLocationsDatasetsInsightsdataError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: ExportProjectsLocationsDatasetsInsightsdataRequest,
  output: ExportProjectsLocationsDatasetsInsightsdataResponse,
  errors: [],
}));

/** Export insights data to a destination defined in the request body. */
export interface ExportProjectsLocationsInsightsdataRequest {
  /** Required. The parent resource to export data from. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1ExportInsightsDataRequest;
}

export const ExportProjectsLocationsInsightsdataRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1ExportInsightsDataRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/insightsdata:export", hasBody: true }),
  svc,
) as unknown as Schema.Schema<ExportProjectsLocationsInsightsdataRequest>;

export type ExportProjectsLocationsInsightsdataResponse = GoogleLongrunningOperation;
export const ExportProjectsLocationsInsightsdataResponse = GoogleLongrunningOperation;

export type ExportProjectsLocationsInsightsdataError = CommonErrors;

export const exportProjectsLocationsInsightsdata: API.OperationMethod<ExportProjectsLocationsInsightsdataRequest, ExportProjectsLocationsInsightsdataResponse, ExportProjectsLocationsInsightsdataError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: ExportProjectsLocationsInsightsdataRequest,
  output: ExportProjectsLocationsInsightsdataResponse,
  errors: [],
}));

/** Creates an issue model. */
export interface CreateProjectsLocationsIssueModelsRequest {
  /** Required. The parent resource of the issue model. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1IssueModel;
}

export const CreateProjectsLocationsIssueModelsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1IssueModel).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/issueModels", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsIssueModelsRequest>;

export type CreateProjectsLocationsIssueModelsResponse = GoogleLongrunningOperation;
export const CreateProjectsLocationsIssueModelsResponse = GoogleLongrunningOperation;

export type CreateProjectsLocationsIssueModelsError = CommonErrors;

export const createProjectsLocationsIssueModels: API.OperationMethod<CreateProjectsLocationsIssueModelsRequest, CreateProjectsLocationsIssueModelsResponse, CreateProjectsLocationsIssueModelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsIssueModelsRequest,
  output: CreateProjectsLocationsIssueModelsResponse,
  errors: [],
}));

/** Updates an issue model. */
export interface PatchProjectsLocationsIssueModelsRequest {
  /** Immutable. The resource name of the issue model. Format: projects/{project}/locations/{location}/issueModels/{issue_model} */
  name: string;
  /** The list of fields to be updated. */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1IssueModel;
}

export const PatchProjectsLocationsIssueModelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1IssueModel).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/issueModels/{issueModelsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsIssueModelsRequest>;

export type PatchProjectsLocationsIssueModelsResponse = GoogleCloudContactcenterinsightsV1IssueModel;
export const PatchProjectsLocationsIssueModelsResponse = GoogleCloudContactcenterinsightsV1IssueModel;

export type PatchProjectsLocationsIssueModelsError = CommonErrors;

export const patchProjectsLocationsIssueModels: API.OperationMethod<PatchProjectsLocationsIssueModelsRequest, PatchProjectsLocationsIssueModelsResponse, PatchProjectsLocationsIssueModelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsIssueModelsRequest,
  output: PatchProjectsLocationsIssueModelsResponse,
  errors: [],
}));

/** Gets an issue model. */
export interface GetProjectsLocationsIssueModelsRequest {
  /** Required. The name of the issue model to get. */
  name: string;
}

export const GetProjectsLocationsIssueModelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/issueModels/{issueModelsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsIssueModelsRequest>;

export type GetProjectsLocationsIssueModelsResponse = GoogleCloudContactcenterinsightsV1IssueModel;
export const GetProjectsLocationsIssueModelsResponse = GoogleCloudContactcenterinsightsV1IssueModel;

export type GetProjectsLocationsIssueModelsError = CommonErrors;

export const getProjectsLocationsIssueModels: API.OperationMethod<GetProjectsLocationsIssueModelsRequest, GetProjectsLocationsIssueModelsResponse, GetProjectsLocationsIssueModelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsIssueModelsRequest,
  output: GetProjectsLocationsIssueModelsResponse,
  errors: [],
}));

/** Lists issue models. */
export interface ListProjectsLocationsIssueModelsRequest {
  /** Required. The parent resource of the issue model. */
  parent: string;
}

export const ListProjectsLocationsIssueModelsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/issueModels" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsIssueModelsRequest>;

export type ListProjectsLocationsIssueModelsResponse = GoogleCloudContactcenterinsightsV1ListIssueModelsResponse;
export const ListProjectsLocationsIssueModelsResponse = GoogleCloudContactcenterinsightsV1ListIssueModelsResponse;

export type ListProjectsLocationsIssueModelsError = CommonErrors;

export const listProjectsLocationsIssueModels: API.OperationMethod<ListProjectsLocationsIssueModelsRequest, ListProjectsLocationsIssueModelsResponse, ListProjectsLocationsIssueModelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: ListProjectsLocationsIssueModelsRequest,
  output: ListProjectsLocationsIssueModelsResponse,
  errors: [],
}));

/** Deletes an issue model. */
export interface DeleteProjectsLocationsIssueModelsRequest {
  /** Required. The name of the issue model to delete. */
  name: string;
}

export const DeleteProjectsLocationsIssueModelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/issueModels/{issueModelsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsIssueModelsRequest>;

export type DeleteProjectsLocationsIssueModelsResponse = GoogleLongrunningOperation;
export const DeleteProjectsLocationsIssueModelsResponse = GoogleLongrunningOperation;

export type DeleteProjectsLocationsIssueModelsError = CommonErrors;

export const deleteProjectsLocationsIssueModels: API.OperationMethod<DeleteProjectsLocationsIssueModelsRequest, DeleteProjectsLocationsIssueModelsResponse, DeleteProjectsLocationsIssueModelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsIssueModelsRequest,
  output: DeleteProjectsLocationsIssueModelsResponse,
  errors: [],
}));

/** Deploys an issue model. Returns an error if a model is already deployed. An issue model can only be used in analysis after it has been deployed. */
export interface DeployProjectsLocationsIssueModelsRequest {
  /** Required. The issue model to deploy. */
  name: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1DeployIssueModelRequest;
}

export const DeployProjectsLocationsIssueModelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1DeployIssueModelRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/issueModels/{issueModelsId}:deploy", hasBody: true }),
  svc,
) as unknown as Schema.Schema<DeployProjectsLocationsIssueModelsRequest>;

export type DeployProjectsLocationsIssueModelsResponse = GoogleLongrunningOperation;
export const DeployProjectsLocationsIssueModelsResponse = GoogleLongrunningOperation;

export type DeployProjectsLocationsIssueModelsError = CommonErrors;

export const deployProjectsLocationsIssueModels: API.OperationMethod<DeployProjectsLocationsIssueModelsRequest, DeployProjectsLocationsIssueModelsResponse, DeployProjectsLocationsIssueModelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeployProjectsLocationsIssueModelsRequest,
  output: DeployProjectsLocationsIssueModelsResponse,
  errors: [],
}));

/** Undeploys an issue model. An issue model can not be used in analysis after it has been undeployed. */
export interface UndeployProjectsLocationsIssueModelsRequest {
  /** Required. The issue model to undeploy. */
  name: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1UndeployIssueModelRequest;
}

export const UndeployProjectsLocationsIssueModelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1UndeployIssueModelRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/issueModels/{issueModelsId}:undeploy", hasBody: true }),
  svc,
) as unknown as Schema.Schema<UndeployProjectsLocationsIssueModelsRequest>;

export type UndeployProjectsLocationsIssueModelsResponse = GoogleLongrunningOperation;
export const UndeployProjectsLocationsIssueModelsResponse = GoogleLongrunningOperation;

export type UndeployProjectsLocationsIssueModelsError = CommonErrors;

export const undeployProjectsLocationsIssueModels: API.OperationMethod<UndeployProjectsLocationsIssueModelsRequest, UndeployProjectsLocationsIssueModelsResponse, UndeployProjectsLocationsIssueModelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: UndeployProjectsLocationsIssueModelsRequest,
  output: UndeployProjectsLocationsIssueModelsResponse,
  errors: [],
}));

/** Exports an issue model to the provided destination. */
export interface ExportProjectsLocationsIssueModelsRequest {
  /** Required. The issue model to export. */
  name: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1ExportIssueModelRequest;
}

export const ExportProjectsLocationsIssueModelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1ExportIssueModelRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/issueModels/{issueModelsId}:export", hasBody: true }),
  svc,
) as unknown as Schema.Schema<ExportProjectsLocationsIssueModelsRequest>;

export type ExportProjectsLocationsIssueModelsResponse = GoogleLongrunningOperation;
export const ExportProjectsLocationsIssueModelsResponse = GoogleLongrunningOperation;

export type ExportProjectsLocationsIssueModelsError = CommonErrors;

export const exportProjectsLocationsIssueModels: API.OperationMethod<ExportProjectsLocationsIssueModelsRequest, ExportProjectsLocationsIssueModelsResponse, ExportProjectsLocationsIssueModelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: ExportProjectsLocationsIssueModelsRequest,
  output: ExportProjectsLocationsIssueModelsResponse,
  errors: [],
}));

/** Imports an issue model from a Cloud Storage bucket. */
export interface ImportProjectsLocationsIssueModelsRequest {
  /** Required. The parent resource of the issue model. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1ImportIssueModelRequest;
}

export const ImportProjectsLocationsIssueModelsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1ImportIssueModelRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/issueModels:import", hasBody: true }),
  svc,
) as unknown as Schema.Schema<ImportProjectsLocationsIssueModelsRequest>;

export type ImportProjectsLocationsIssueModelsResponse = GoogleLongrunningOperation;
export const ImportProjectsLocationsIssueModelsResponse = GoogleLongrunningOperation;

export type ImportProjectsLocationsIssueModelsError = CommonErrors;

export const importProjectsLocationsIssueModels: API.OperationMethod<ImportProjectsLocationsIssueModelsRequest, ImportProjectsLocationsIssueModelsResponse, ImportProjectsLocationsIssueModelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: ImportProjectsLocationsIssueModelsRequest,
  output: ImportProjectsLocationsIssueModelsResponse,
  errors: [],
}));

/** Gets an issue model's statistics. */
export interface CalculateIssueModelStatsProjectsLocationsIssueModelsRequest {
  /** Required. The resource name of the issue model to query against. */
  issueModel: string;
}

export const CalculateIssueModelStatsProjectsLocationsIssueModelsRequest = Schema.Struct({
  issueModel: Schema.String.pipe(T.HttpPath("issueModel")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/issueModels/{issueModelsId}:calculateIssueModelStats" }),
  svc,
) as unknown as Schema.Schema<CalculateIssueModelStatsProjectsLocationsIssueModelsRequest>;

export type CalculateIssueModelStatsProjectsLocationsIssueModelsResponse = GoogleCloudContactcenterinsightsV1CalculateIssueModelStatsResponse;
export const CalculateIssueModelStatsProjectsLocationsIssueModelsResponse = GoogleCloudContactcenterinsightsV1CalculateIssueModelStatsResponse;

export type CalculateIssueModelStatsProjectsLocationsIssueModelsError = CommonErrors;

export const calculateIssueModelStatsProjectsLocationsIssueModels: API.OperationMethod<CalculateIssueModelStatsProjectsLocationsIssueModelsRequest, CalculateIssueModelStatsProjectsLocationsIssueModelsResponse, CalculateIssueModelStatsProjectsLocationsIssueModelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CalculateIssueModelStatsProjectsLocationsIssueModelsRequest,
  output: CalculateIssueModelStatsProjectsLocationsIssueModelsResponse,
  errors: [],
}));

/** Gets an issue. */
export interface GetProjectsLocationsIssueModelsIssuesRequest {
  /** Required. The name of the issue to get. */
  name: string;
}

export const GetProjectsLocationsIssueModelsIssuesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/issueModels/{issueModelsId}/issues/{issuesId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsIssueModelsIssuesRequest>;

export type GetProjectsLocationsIssueModelsIssuesResponse = GoogleCloudContactcenterinsightsV1Issue;
export const GetProjectsLocationsIssueModelsIssuesResponse = GoogleCloudContactcenterinsightsV1Issue;

export type GetProjectsLocationsIssueModelsIssuesError = CommonErrors;

export const getProjectsLocationsIssueModelsIssues: API.OperationMethod<GetProjectsLocationsIssueModelsIssuesRequest, GetProjectsLocationsIssueModelsIssuesResponse, GetProjectsLocationsIssueModelsIssuesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsIssueModelsIssuesRequest,
  output: GetProjectsLocationsIssueModelsIssuesResponse,
  errors: [],
}));

/** Lists issues. */
export interface ListProjectsLocationsIssueModelsIssuesRequest {
  /** Required. The parent resource of the issue. */
  parent: string;
}

export const ListProjectsLocationsIssueModelsIssuesRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/issueModels/{issueModelsId}/issues" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsIssueModelsIssuesRequest>;

export type ListProjectsLocationsIssueModelsIssuesResponse = GoogleCloudContactcenterinsightsV1ListIssuesResponse;
export const ListProjectsLocationsIssueModelsIssuesResponse = GoogleCloudContactcenterinsightsV1ListIssuesResponse;

export type ListProjectsLocationsIssueModelsIssuesError = CommonErrors;

export const listProjectsLocationsIssueModelsIssues: API.OperationMethod<ListProjectsLocationsIssueModelsIssuesRequest, ListProjectsLocationsIssueModelsIssuesResponse, ListProjectsLocationsIssueModelsIssuesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: ListProjectsLocationsIssueModelsIssuesRequest,
  output: ListProjectsLocationsIssueModelsIssuesResponse,
  errors: [],
}));

/** Updates an issue. */
export interface PatchProjectsLocationsIssueModelsIssuesRequest {
  /** Immutable. The resource name of the issue. Format: projects/{project}/locations/{location}/issueModels/{issue_model}/issues/{issue} */
  name: string;
  /** The list of fields to be updated. */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1Issue;
}

export const PatchProjectsLocationsIssueModelsIssuesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1Issue).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/issueModels/{issueModelsId}/issues/{issuesId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsIssueModelsIssuesRequest>;

export type PatchProjectsLocationsIssueModelsIssuesResponse = GoogleCloudContactcenterinsightsV1Issue;
export const PatchProjectsLocationsIssueModelsIssuesResponse = GoogleCloudContactcenterinsightsV1Issue;

export type PatchProjectsLocationsIssueModelsIssuesError = CommonErrors;

export const patchProjectsLocationsIssueModelsIssues: API.OperationMethod<PatchProjectsLocationsIssueModelsIssuesRequest, PatchProjectsLocationsIssueModelsIssuesResponse, PatchProjectsLocationsIssueModelsIssuesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsIssueModelsIssuesRequest,
  output: PatchProjectsLocationsIssueModelsIssuesResponse,
  errors: [],
}));

/** Creates an issue. */
export interface CreateProjectsLocationsIssueModelsIssuesRequest {
  /** Required. The parent resource of the issue. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1Issue;
}

export const CreateProjectsLocationsIssueModelsIssuesRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1Issue).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/issueModels/{issueModelsId}/issues", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsIssueModelsIssuesRequest>;

export type CreateProjectsLocationsIssueModelsIssuesResponse = GoogleLongrunningOperation;
export const CreateProjectsLocationsIssueModelsIssuesResponse = GoogleLongrunningOperation;

export type CreateProjectsLocationsIssueModelsIssuesError = CommonErrors;

export const createProjectsLocationsIssueModelsIssues: API.OperationMethod<CreateProjectsLocationsIssueModelsIssuesRequest, CreateProjectsLocationsIssueModelsIssuesResponse, CreateProjectsLocationsIssueModelsIssuesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsIssueModelsIssuesRequest,
  output: CreateProjectsLocationsIssueModelsIssuesResponse,
  errors: [],
}));

/** Deletes an issue. */
export interface DeleteProjectsLocationsIssueModelsIssuesRequest {
  /** Required. The name of the issue to delete. */
  name: string;
}

export const DeleteProjectsLocationsIssueModelsIssuesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/issueModels/{issueModelsId}/issues/{issuesId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsIssueModelsIssuesRequest>;

export type DeleteProjectsLocationsIssueModelsIssuesResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsIssueModelsIssuesResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsIssueModelsIssuesError = CommonErrors;

export const deleteProjectsLocationsIssueModelsIssues: API.OperationMethod<DeleteProjectsLocationsIssueModelsIssuesRequest, DeleteProjectsLocationsIssueModelsIssuesResponse, DeleteProjectsLocationsIssueModelsIssuesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsIssueModelsIssuesRequest,
  output: DeleteProjectsLocationsIssueModelsIssuesResponse,
  errors: [],
}));

/** Creates a phrase matcher. */
export interface CreateProjectsLocationsPhraseMatchersRequest {
  /** Required. The parent resource of the phrase matcher. Required. The location to create a phrase matcher for. Format: `projects//locations/` or `projects//locations/` */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1PhraseMatcher;
}

export const CreateProjectsLocationsPhraseMatchersRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1PhraseMatcher).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/phraseMatchers", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsPhraseMatchersRequest>;

export type CreateProjectsLocationsPhraseMatchersResponse = GoogleCloudContactcenterinsightsV1PhraseMatcher;
export const CreateProjectsLocationsPhraseMatchersResponse = GoogleCloudContactcenterinsightsV1PhraseMatcher;

export type CreateProjectsLocationsPhraseMatchersError = CommonErrors;

export const createProjectsLocationsPhraseMatchers: API.OperationMethod<CreateProjectsLocationsPhraseMatchersRequest, CreateProjectsLocationsPhraseMatchersResponse, CreateProjectsLocationsPhraseMatchersError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsPhraseMatchersRequest,
  output: CreateProjectsLocationsPhraseMatchersResponse,
  errors: [],
}));

/** Gets a phrase matcher. */
export interface GetProjectsLocationsPhraseMatchersRequest {
  /** Required. The name of the phrase matcher to get. */
  name: string;
}

export const GetProjectsLocationsPhraseMatchersRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/phraseMatchers/{phraseMatchersId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsPhraseMatchersRequest>;

export type GetProjectsLocationsPhraseMatchersResponse = GoogleCloudContactcenterinsightsV1PhraseMatcher;
export const GetProjectsLocationsPhraseMatchersResponse = GoogleCloudContactcenterinsightsV1PhraseMatcher;

export type GetProjectsLocationsPhraseMatchersError = CommonErrors;

export const getProjectsLocationsPhraseMatchers: API.OperationMethod<GetProjectsLocationsPhraseMatchersRequest, GetProjectsLocationsPhraseMatchersResponse, GetProjectsLocationsPhraseMatchersError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsPhraseMatchersRequest,
  output: GetProjectsLocationsPhraseMatchersResponse,
  errors: [],
}));

/** Lists phrase matchers. */
export interface ListProjectsLocationsPhraseMatchersRequest {
  /** Required. The parent resource of the phrase matcher. */
  parent: string;
  /** The maximum number of phrase matchers to return in the response. If this value is zero, the service will select a default size. A call might return fewer objects than requested. A non-empty `next_page_token` in the response indicates that more data is available. */
  pageSize?: number;
  /** The value returned by the last `ListPhraseMatchersResponse`. This value indicates that this is a continuation of a prior `ListPhraseMatchers` call and that the system should return the next page of data. */
  pageToken?: string;
  /** A filter to reduce results to a specific subset. Useful for querying phrase matchers with specific properties. */
  filter?: string;
}

export const ListProjectsLocationsPhraseMatchersRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/phraseMatchers" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsPhraseMatchersRequest>;

export type ListProjectsLocationsPhraseMatchersResponse = GoogleCloudContactcenterinsightsV1ListPhraseMatchersResponse;
export const ListProjectsLocationsPhraseMatchersResponse = GoogleCloudContactcenterinsightsV1ListPhraseMatchersResponse;

export type ListProjectsLocationsPhraseMatchersError = CommonErrors;

export const listProjectsLocationsPhraseMatchers = API.makePaginated(() => ({
  input: ListProjectsLocationsPhraseMatchersRequest,
  output: ListProjectsLocationsPhraseMatchersResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Deletes a phrase matcher. */
export interface DeleteProjectsLocationsPhraseMatchersRequest {
  /** Required. The name of the phrase matcher to delete. */
  name: string;
}

export const DeleteProjectsLocationsPhraseMatchersRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/phraseMatchers/{phraseMatchersId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsPhraseMatchersRequest>;

export type DeleteProjectsLocationsPhraseMatchersResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsPhraseMatchersResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsPhraseMatchersError = CommonErrors;

export const deleteProjectsLocationsPhraseMatchers: API.OperationMethod<DeleteProjectsLocationsPhraseMatchersRequest, DeleteProjectsLocationsPhraseMatchersResponse, DeleteProjectsLocationsPhraseMatchersError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsPhraseMatchersRequest,
  output: DeleteProjectsLocationsPhraseMatchersResponse,
  errors: [],
}));

/** Updates a phrase matcher. */
export interface PatchProjectsLocationsPhraseMatchersRequest {
  /** The resource name of the phrase matcher. Format: projects/{project}/locations/{location}/phraseMatchers/{phrase_matcher} */
  name: string;
  /** The list of fields to be updated. */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1PhraseMatcher;
}

export const PatchProjectsLocationsPhraseMatchersRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1PhraseMatcher).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/phraseMatchers/{phraseMatchersId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsPhraseMatchersRequest>;

export type PatchProjectsLocationsPhraseMatchersResponse = GoogleCloudContactcenterinsightsV1PhraseMatcher;
export const PatchProjectsLocationsPhraseMatchersResponse = GoogleCloudContactcenterinsightsV1PhraseMatcher;

export type PatchProjectsLocationsPhraseMatchersError = CommonErrors;

export const patchProjectsLocationsPhraseMatchers: API.OperationMethod<PatchProjectsLocationsPhraseMatchersRequest, PatchProjectsLocationsPhraseMatchersResponse, PatchProjectsLocationsPhraseMatchersError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsPhraseMatchersRequest,
  output: PatchProjectsLocationsPhraseMatchersResponse,
  errors: [],
}));

/** Creates a analysis rule. */
export interface CreateProjectsLocationsAnalysisRulesRequest {
  /** Required. The parent resource of the analysis rule. Required. The location to create a analysis rule for. Format: `projects//locations/` or `projects//locations/` */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1AnalysisRule;
}

export const CreateProjectsLocationsAnalysisRulesRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1AnalysisRule).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/analysisRules", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsAnalysisRulesRequest>;

export type CreateProjectsLocationsAnalysisRulesResponse = GoogleCloudContactcenterinsightsV1AnalysisRule;
export const CreateProjectsLocationsAnalysisRulesResponse = GoogleCloudContactcenterinsightsV1AnalysisRule;

export type CreateProjectsLocationsAnalysisRulesError = CommonErrors;

export const createProjectsLocationsAnalysisRules: API.OperationMethod<CreateProjectsLocationsAnalysisRulesRequest, CreateProjectsLocationsAnalysisRulesResponse, CreateProjectsLocationsAnalysisRulesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsAnalysisRulesRequest,
  output: CreateProjectsLocationsAnalysisRulesResponse,
  errors: [],
}));

/** Get a analysis rule. */
export interface GetProjectsLocationsAnalysisRulesRequest {
  /** Required. The name of the AnalysisRule to get. */
  name: string;
}

export const GetProjectsLocationsAnalysisRulesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/analysisRules/{analysisRulesId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsAnalysisRulesRequest>;

export type GetProjectsLocationsAnalysisRulesResponse = GoogleCloudContactcenterinsightsV1AnalysisRule;
export const GetProjectsLocationsAnalysisRulesResponse = GoogleCloudContactcenterinsightsV1AnalysisRule;

export type GetProjectsLocationsAnalysisRulesError = CommonErrors;

export const getProjectsLocationsAnalysisRules: API.OperationMethod<GetProjectsLocationsAnalysisRulesRequest, GetProjectsLocationsAnalysisRulesResponse, GetProjectsLocationsAnalysisRulesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsAnalysisRulesRequest,
  output: GetProjectsLocationsAnalysisRulesResponse,
  errors: [],
}));

/** Lists analysis rules. */
export interface ListProjectsLocationsAnalysisRulesRequest {
  /** Required. The parent resource of the analysis rules. */
  parent: string;
  /** Optional. The maximum number of analysis rule to return in the response. If this value is zero, the service will select a default size. A call may return fewer objects than requested. A non-empty `next_page_token` in the response indicates that more data is available. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListAnalysisRulesResponse`; indicates that this is a continuation of a prior `ListAnalysisRules` call and the system should return the next page of data. */
  pageToken?: string;
}

export const ListProjectsLocationsAnalysisRulesRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/analysisRules" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsAnalysisRulesRequest>;

export type ListProjectsLocationsAnalysisRulesResponse = GoogleCloudContactcenterinsightsV1ListAnalysisRulesResponse;
export const ListProjectsLocationsAnalysisRulesResponse = GoogleCloudContactcenterinsightsV1ListAnalysisRulesResponse;

export type ListProjectsLocationsAnalysisRulesError = CommonErrors;

export const listProjectsLocationsAnalysisRules = API.makePaginated(() => ({
  input: ListProjectsLocationsAnalysisRulesRequest,
  output: ListProjectsLocationsAnalysisRulesResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Updates a analysis rule. */
export interface PatchProjectsLocationsAnalysisRulesRequest {
  /** Identifier. The resource name of the analysis rule. Format: projects/{project}/locations/{location}/analysisRules/{analysis_rule} */
  name: string;
  /** Optional. The list of fields to be updated. If the update_mask is not provided, the update will be applied to all fields. */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1AnalysisRule;
}

export const PatchProjectsLocationsAnalysisRulesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1AnalysisRule).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/analysisRules/{analysisRulesId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsAnalysisRulesRequest>;

export type PatchProjectsLocationsAnalysisRulesResponse = GoogleCloudContactcenterinsightsV1AnalysisRule;
export const PatchProjectsLocationsAnalysisRulesResponse = GoogleCloudContactcenterinsightsV1AnalysisRule;

export type PatchProjectsLocationsAnalysisRulesError = CommonErrors;

export const patchProjectsLocationsAnalysisRules: API.OperationMethod<PatchProjectsLocationsAnalysisRulesRequest, PatchProjectsLocationsAnalysisRulesResponse, PatchProjectsLocationsAnalysisRulesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsAnalysisRulesRequest,
  output: PatchProjectsLocationsAnalysisRulesResponse,
  errors: [],
}));

/** Deletes a analysis rule. */
export interface DeleteProjectsLocationsAnalysisRulesRequest {
  /** Required. The name of the analysis rule to delete. */
  name: string;
}

export const DeleteProjectsLocationsAnalysisRulesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/analysisRules/{analysisRulesId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsAnalysisRulesRequest>;

export type DeleteProjectsLocationsAnalysisRulesResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsAnalysisRulesResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsAnalysisRulesError = CommonErrors;

export const deleteProjectsLocationsAnalysisRules: API.OperationMethod<DeleteProjectsLocationsAnalysisRulesRequest, DeleteProjectsLocationsAnalysisRulesResponse, DeleteProjectsLocationsAnalysisRulesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsAnalysisRulesRequest,
  output: DeleteProjectsLocationsAnalysisRulesResponse,
  errors: [],
}));

/** Lists auto labeling rules. */
export interface ListProjectsLocationsAutoLabelingRulesRequest {
  /** Required. The project and location to list auto labeling rules from. Format: projects/{project}/locations/{location} */
  parent: string;
  /** Optional. The maximum number of auto labeling rules to return in a single response. If unspecified, at most 100 rules will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000. */
  pageSize?: number;
  /** Optional. The next_page_token value returned from a previous List request, if any. */
  pageToken?: string;
}

export const ListProjectsLocationsAutoLabelingRulesRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/autoLabelingRules" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsAutoLabelingRulesRequest>;

export type ListProjectsLocationsAutoLabelingRulesResponse = GoogleCloudContactcenterinsightsV1ListAutoLabelingRulesResponse;
export const ListProjectsLocationsAutoLabelingRulesResponse = GoogleCloudContactcenterinsightsV1ListAutoLabelingRulesResponse;

export type ListProjectsLocationsAutoLabelingRulesError = CommonErrors;

export const listProjectsLocationsAutoLabelingRules = API.makePaginated(() => ({
  input: ListProjectsLocationsAutoLabelingRulesRequest,
  output: ListProjectsLocationsAutoLabelingRulesResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Gets an auto labeling rule. */
export interface GetProjectsLocationsAutoLabelingRulesRequest {
  /** Required. The name of the auto labeling rule to get. Format: projects/{project}/locations/{location}/autoLabelingRules/{auto_labeling_rule} */
  name: string;
}

export const GetProjectsLocationsAutoLabelingRulesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/autoLabelingRules/{autoLabelingRulesId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsAutoLabelingRulesRequest>;

export type GetProjectsLocationsAutoLabelingRulesResponse = GoogleCloudContactcenterinsightsV1AutoLabelingRule;
export const GetProjectsLocationsAutoLabelingRulesResponse = GoogleCloudContactcenterinsightsV1AutoLabelingRule;

export type GetProjectsLocationsAutoLabelingRulesError = CommonErrors;

export const getProjectsLocationsAutoLabelingRules: API.OperationMethod<GetProjectsLocationsAutoLabelingRulesRequest, GetProjectsLocationsAutoLabelingRulesResponse, GetProjectsLocationsAutoLabelingRulesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsAutoLabelingRulesRequest,
  output: GetProjectsLocationsAutoLabelingRulesResponse,
  errors: [],
}));

/** Creates an auto labeling rule. */
export interface CreateProjectsLocationsAutoLabelingRulesRequest {
  /** Required. The project and location to create the auto labeling rule in. Format: projects/{project}/locations/{location} */
  parent: string;
  /** Required. The ID to use for the auto labeling rule, which will become the final component of the auto labeling rule's resource name. */
  autoLabelingRuleId?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1AutoLabelingRule;
}

export const CreateProjectsLocationsAutoLabelingRulesRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  autoLabelingRuleId: Schema.optional(Schema.String).pipe(T.HttpQuery("autoLabelingRuleId")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1AutoLabelingRule).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/autoLabelingRules", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsAutoLabelingRulesRequest>;

export type CreateProjectsLocationsAutoLabelingRulesResponse = GoogleCloudContactcenterinsightsV1AutoLabelingRule;
export const CreateProjectsLocationsAutoLabelingRulesResponse = GoogleCloudContactcenterinsightsV1AutoLabelingRule;

export type CreateProjectsLocationsAutoLabelingRulesError = CommonErrors;

export const createProjectsLocationsAutoLabelingRules: API.OperationMethod<CreateProjectsLocationsAutoLabelingRulesRequest, CreateProjectsLocationsAutoLabelingRulesResponse, CreateProjectsLocationsAutoLabelingRulesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsAutoLabelingRulesRequest,
  output: CreateProjectsLocationsAutoLabelingRulesResponse,
  errors: [],
}));

/** Updates an auto labeling rule. */
export interface PatchProjectsLocationsAutoLabelingRulesRequest {
  /** Identifier. The resource name of the auto-labeling rule. Format: projects/{project}/locations/{location}/autoLabelingRules/{auto_labeling_rule} */
  name: string;
  /** Optional. The list of fields to be updated. */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1AutoLabelingRule;
}

export const PatchProjectsLocationsAutoLabelingRulesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1AutoLabelingRule).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/autoLabelingRules/{autoLabelingRulesId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsAutoLabelingRulesRequest>;

export type PatchProjectsLocationsAutoLabelingRulesResponse = GoogleCloudContactcenterinsightsV1AutoLabelingRule;
export const PatchProjectsLocationsAutoLabelingRulesResponse = GoogleCloudContactcenterinsightsV1AutoLabelingRule;

export type PatchProjectsLocationsAutoLabelingRulesError = CommonErrors;

export const patchProjectsLocationsAutoLabelingRules: API.OperationMethod<PatchProjectsLocationsAutoLabelingRulesRequest, PatchProjectsLocationsAutoLabelingRulesResponse, PatchProjectsLocationsAutoLabelingRulesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsAutoLabelingRulesRequest,
  output: PatchProjectsLocationsAutoLabelingRulesResponse,
  errors: [],
}));

/** Deletes an auto labeling rule. */
export interface DeleteProjectsLocationsAutoLabelingRulesRequest {
  /** Required. The name of the auto labeling rule to delete. Format: projects/{project}/locations/{location}/autoLabelingRules/{auto_labeling_rule} */
  name: string;
}

export const DeleteProjectsLocationsAutoLabelingRulesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/autoLabelingRules/{autoLabelingRulesId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsAutoLabelingRulesRequest>;

export type DeleteProjectsLocationsAutoLabelingRulesResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsAutoLabelingRulesResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsAutoLabelingRulesError = CommonErrors;

export const deleteProjectsLocationsAutoLabelingRules: API.OperationMethod<DeleteProjectsLocationsAutoLabelingRulesRequest, DeleteProjectsLocationsAutoLabelingRulesResponse, DeleteProjectsLocationsAutoLabelingRulesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsAutoLabelingRulesRequest,
  output: DeleteProjectsLocationsAutoLabelingRulesResponse,
  errors: [],
}));

/** Tests auto labeling rules against a conversation. */
export interface TestProjectsLocationsAutoLabelingRulesRequest {
  /** Required. The parent project and location. Format: projects/{project}/locations/{location} */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1TestAutoLabelingRuleRequest;
}

export const TestProjectsLocationsAutoLabelingRulesRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1TestAutoLabelingRuleRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/autoLabelingRules:test", hasBody: true }),
  svc,
) as unknown as Schema.Schema<TestProjectsLocationsAutoLabelingRulesRequest>;

export type TestProjectsLocationsAutoLabelingRulesResponse = GoogleCloudContactcenterinsightsV1TestAutoLabelingRuleResponse;
export const TestProjectsLocationsAutoLabelingRulesResponse = GoogleCloudContactcenterinsightsV1TestAutoLabelingRuleResponse;

export type TestProjectsLocationsAutoLabelingRulesError = CommonErrors;

export const testProjectsLocationsAutoLabelingRules: API.OperationMethod<TestProjectsLocationsAutoLabelingRulesRequest, TestProjectsLocationsAutoLabelingRulesResponse, TestProjectsLocationsAutoLabelingRulesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: TestProjectsLocationsAutoLabelingRulesRequest,
  output: TestProjectsLocationsAutoLabelingRulesResponse,
  errors: [],
}));

/** Creates an assessment rule. */
export interface CreateProjectsLocationsAssessmentRulesRequest {
  /** Required. The parent resource of the assessment rule. Required. The location to create a assessment rule for. Format: `projects//locations/` or `projects//locations/` */
  parent: string;
  /** Optional. A unique ID for the new AssessmentRule. This ID will become the final component of the AssessmentRule's resource name. If no ID is specified, a server-generated ID will be used. This value should be 4-64 characters and must match the regular expression `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`. */
  assessmentRuleId?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1AssessmentRule;
}

export const CreateProjectsLocationsAssessmentRulesRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  assessmentRuleId: Schema.optional(Schema.String).pipe(T.HttpQuery("assessmentRuleId")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1AssessmentRule).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/assessmentRules", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsAssessmentRulesRequest>;

export type CreateProjectsLocationsAssessmentRulesResponse = GoogleCloudContactcenterinsightsV1AssessmentRule;
export const CreateProjectsLocationsAssessmentRulesResponse = GoogleCloudContactcenterinsightsV1AssessmentRule;

export type CreateProjectsLocationsAssessmentRulesError = CommonErrors;

export const createProjectsLocationsAssessmentRules: API.OperationMethod<CreateProjectsLocationsAssessmentRulesRequest, CreateProjectsLocationsAssessmentRulesResponse, CreateProjectsLocationsAssessmentRulesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsAssessmentRulesRequest,
  output: CreateProjectsLocationsAssessmentRulesResponse,
  errors: [],
}));

/** Get an assessment rule. */
export interface GetProjectsLocationsAssessmentRulesRequest {
  /** Required. The name of the assessment rule to get. */
  name: string;
}

export const GetProjectsLocationsAssessmentRulesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/assessmentRules/{assessmentRulesId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsAssessmentRulesRequest>;

export type GetProjectsLocationsAssessmentRulesResponse = GoogleCloudContactcenterinsightsV1AssessmentRule;
export const GetProjectsLocationsAssessmentRulesResponse = GoogleCloudContactcenterinsightsV1AssessmentRule;

export type GetProjectsLocationsAssessmentRulesError = CommonErrors;

export const getProjectsLocationsAssessmentRules: API.OperationMethod<GetProjectsLocationsAssessmentRulesRequest, GetProjectsLocationsAssessmentRulesResponse, GetProjectsLocationsAssessmentRulesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsAssessmentRulesRequest,
  output: GetProjectsLocationsAssessmentRulesResponse,
  errors: [],
}));

/** Lists assessment rules. */
export interface ListProjectsLocationsAssessmentRulesRequest {
  /** Required. The parent resource of the assessment rules. */
  parent: string;
  /** Optional. The maximum number of assessment rule to return in the response. If this value is zero, the service will select a default size. A call may return fewer objects than requested. A non-empty `next_page_token` in the response indicates that more data is available. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListAssessmentRulesResponse`; indicates that this is a continuation of a prior `ListAssessmentRules` call and the system should return the next page of data. */
  pageToken?: string;
}

export const ListProjectsLocationsAssessmentRulesRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/assessmentRules" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsAssessmentRulesRequest>;

export type ListProjectsLocationsAssessmentRulesResponse = GoogleCloudContactcenterinsightsV1ListAssessmentRulesResponse;
export const ListProjectsLocationsAssessmentRulesResponse = GoogleCloudContactcenterinsightsV1ListAssessmentRulesResponse;

export type ListProjectsLocationsAssessmentRulesError = CommonErrors;

export const listProjectsLocationsAssessmentRules = API.makePaginated(() => ({
  input: ListProjectsLocationsAssessmentRulesRequest,
  output: ListProjectsLocationsAssessmentRulesResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Updates an assessment rule. */
export interface PatchProjectsLocationsAssessmentRulesRequest {
  /** Identifier. The resource name of the assessment rule. Format: projects/{project}/locations/{location}/assessmentRules/{assessment_rule} */
  name: string;
  /** Optional. The list of fields to be updated. If the update_mask is not provided, the update will be applied to all fields. */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1AssessmentRule;
}

export const PatchProjectsLocationsAssessmentRulesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1AssessmentRule).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/assessmentRules/{assessmentRulesId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsAssessmentRulesRequest>;

export type PatchProjectsLocationsAssessmentRulesResponse = GoogleCloudContactcenterinsightsV1AssessmentRule;
export const PatchProjectsLocationsAssessmentRulesResponse = GoogleCloudContactcenterinsightsV1AssessmentRule;

export type PatchProjectsLocationsAssessmentRulesError = CommonErrors;

export const patchProjectsLocationsAssessmentRules: API.OperationMethod<PatchProjectsLocationsAssessmentRulesRequest, PatchProjectsLocationsAssessmentRulesResponse, PatchProjectsLocationsAssessmentRulesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsAssessmentRulesRequest,
  output: PatchProjectsLocationsAssessmentRulesResponse,
  errors: [],
}));

/** Deletes an assessment rule. */
export interface DeleteProjectsLocationsAssessmentRulesRequest {
  /** Required. The name of the assessment rule to delete. */
  name: string;
}

export const DeleteProjectsLocationsAssessmentRulesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/assessmentRules/{assessmentRulesId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsAssessmentRulesRequest>;

export type DeleteProjectsLocationsAssessmentRulesResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsAssessmentRulesResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsAssessmentRulesError = CommonErrors;

export const deleteProjectsLocationsAssessmentRules: API.OperationMethod<DeleteProjectsLocationsAssessmentRulesRequest, DeleteProjectsLocationsAssessmentRulesResponse, DeleteProjectsLocationsAssessmentRulesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsAssessmentRulesRequest,
  output: DeleteProjectsLocationsAssessmentRulesResponse,
  errors: [],
}));

/** Initializes a location-level encryption key specification. An error will result if the location has resources already created before the initialization. After the encryption specification is initialized at a location, it is immutable and all newly created resources under the location will be encrypted with the existing specification. */
export interface InitializeProjectsLocationsEncryptionSpecRequest {
  /** Immutable. The resource name of the encryption key specification resource. Format: projects/{project}/locations/{location}/encryptionSpec */
  name: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecRequest;
}

export const InitializeProjectsLocationsEncryptionSpecRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1InitializeEncryptionSpecRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/encryptionSpec:initialize", hasBody: true }),
  svc,
) as unknown as Schema.Schema<InitializeProjectsLocationsEncryptionSpecRequest>;

export type InitializeProjectsLocationsEncryptionSpecResponse = GoogleLongrunningOperation;
export const InitializeProjectsLocationsEncryptionSpecResponse = GoogleLongrunningOperation;

export type InitializeProjectsLocationsEncryptionSpecError = CommonErrors;

export const initializeProjectsLocationsEncryptionSpec: API.OperationMethod<InitializeProjectsLocationsEncryptionSpecRequest, InitializeProjectsLocationsEncryptionSpecResponse, InitializeProjectsLocationsEncryptionSpecError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: InitializeProjectsLocationsEncryptionSpecRequest,
  output: InitializeProjectsLocationsEncryptionSpecResponse,
  errors: [],
}));

/** Creates a view. */
export interface CreateProjectsLocationsViewsRequest {
  /** Required. The parent resource of the view. Required. The location to create a view for. Format: `projects//locations/` or `projects//locations/` */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1View;
}

export const CreateProjectsLocationsViewsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1View).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/views", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsViewsRequest>;

export type CreateProjectsLocationsViewsResponse = GoogleCloudContactcenterinsightsV1View;
export const CreateProjectsLocationsViewsResponse = GoogleCloudContactcenterinsightsV1View;

export type CreateProjectsLocationsViewsError = CommonErrors;

export const createProjectsLocationsViews: API.OperationMethod<CreateProjectsLocationsViewsRequest, CreateProjectsLocationsViewsResponse, CreateProjectsLocationsViewsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsViewsRequest,
  output: CreateProjectsLocationsViewsResponse,
  errors: [],
}));

/** Gets a view. */
export interface GetProjectsLocationsViewsRequest {
  /** Required. The name of the view to get. */
  name: string;
}

export const GetProjectsLocationsViewsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/views/{viewsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsViewsRequest>;

export type GetProjectsLocationsViewsResponse = GoogleCloudContactcenterinsightsV1View;
export const GetProjectsLocationsViewsResponse = GoogleCloudContactcenterinsightsV1View;

export type GetProjectsLocationsViewsError = CommonErrors;

export const getProjectsLocationsViews: API.OperationMethod<GetProjectsLocationsViewsRequest, GetProjectsLocationsViewsResponse, GetProjectsLocationsViewsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsViewsRequest,
  output: GetProjectsLocationsViewsResponse,
  errors: [],
}));

/** Lists views. */
export interface ListProjectsLocationsViewsRequest {
  /** Required. The parent resource of the views. */
  parent: string;
  /** The maximum number of views to return in the response. If this value is zero, the service will select a default size. A call may return fewer objects than requested. A non-empty `next_page_token` in the response indicates that more data is available. */
  pageSize?: number;
  /** The value returned by the last `ListViewsResponse`; indicates that this is a continuation of a prior `ListViews` call and the system should return the next page of data. */
  pageToken?: string;
}

export const ListProjectsLocationsViewsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/views" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsViewsRequest>;

export type ListProjectsLocationsViewsResponse = GoogleCloudContactcenterinsightsV1ListViewsResponse;
export const ListProjectsLocationsViewsResponse = GoogleCloudContactcenterinsightsV1ListViewsResponse;

export type ListProjectsLocationsViewsError = CommonErrors;

export const listProjectsLocationsViews = API.makePaginated(() => ({
  input: ListProjectsLocationsViewsRequest,
  output: ListProjectsLocationsViewsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Updates a view. */
export interface PatchProjectsLocationsViewsRequest {
  /** Immutable. The resource name of the view. Format: projects/{project}/locations/{location}/views/{view} */
  name: string;
  /** The list of fields to be updated. */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1View;
}

export const PatchProjectsLocationsViewsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1View).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/views/{viewsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsViewsRequest>;

export type PatchProjectsLocationsViewsResponse = GoogleCloudContactcenterinsightsV1View;
export const PatchProjectsLocationsViewsResponse = GoogleCloudContactcenterinsightsV1View;

export type PatchProjectsLocationsViewsError = CommonErrors;

export const patchProjectsLocationsViews: API.OperationMethod<PatchProjectsLocationsViewsRequest, PatchProjectsLocationsViewsResponse, PatchProjectsLocationsViewsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsViewsRequest,
  output: PatchProjectsLocationsViewsResponse,
  errors: [],
}));

/** Deletes a view. */
export interface DeleteProjectsLocationsViewsRequest {
  /** Required. The name of the view to delete. */
  name: string;
}

export const DeleteProjectsLocationsViewsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/views/{viewsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsViewsRequest>;

export type DeleteProjectsLocationsViewsResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsViewsResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsViewsError = CommonErrors;

export const deleteProjectsLocationsViews: API.OperationMethod<DeleteProjectsLocationsViewsRequest, DeleteProjectsLocationsViewsResponse, DeleteProjectsLocationsViewsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsViewsRequest,
  output: DeleteProjectsLocationsViewsResponse,
  errors: [],
}));

/** Creates a QaQuestionTag. */
export interface CreateProjectsLocationsQaQuestionTagsRequest {
  /** Required. The parent resource of the QaQuestionTag. */
  parent: string;
  /** Optional. A unique ID for the new QaQuestionTag. This ID will become the final component of the QaQuestionTag's resource name. If no ID is specified, a server-generated ID will be used. This value should be 4-64 characters and must match the regular expression `^[a-z0-9-]{4,64}$`. Valid characters are `a-z-`. */
  qaQuestionTagId?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1QaQuestionTag;
}

export const CreateProjectsLocationsQaQuestionTagsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  qaQuestionTagId: Schema.optional(Schema.String).pipe(T.HttpQuery("qaQuestionTagId")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1QaQuestionTag).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/qaQuestionTags", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsQaQuestionTagsRequest>;

export type CreateProjectsLocationsQaQuestionTagsResponse = GoogleCloudContactcenterinsightsV1QaQuestionTag;
export const CreateProjectsLocationsQaQuestionTagsResponse = GoogleCloudContactcenterinsightsV1QaQuestionTag;

export type CreateProjectsLocationsQaQuestionTagsError = CommonErrors;

export const createProjectsLocationsQaQuestionTags: API.OperationMethod<CreateProjectsLocationsQaQuestionTagsRequest, CreateProjectsLocationsQaQuestionTagsResponse, CreateProjectsLocationsQaQuestionTagsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsQaQuestionTagsRequest,
  output: CreateProjectsLocationsQaQuestionTagsResponse,
  errors: [],
}));

/** Gets a QaQuestionTag. */
export interface GetProjectsLocationsQaQuestionTagsRequest {
  /** Required. The name of the QaQuestionTag to get. */
  name: string;
}

export const GetProjectsLocationsQaQuestionTagsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/qaQuestionTags/{qaQuestionTagsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsQaQuestionTagsRequest>;

export type GetProjectsLocationsQaQuestionTagsResponse = GoogleCloudContactcenterinsightsV1QaQuestionTag;
export const GetProjectsLocationsQaQuestionTagsResponse = GoogleCloudContactcenterinsightsV1QaQuestionTag;

export type GetProjectsLocationsQaQuestionTagsError = CommonErrors;

export const getProjectsLocationsQaQuestionTags: API.OperationMethod<GetProjectsLocationsQaQuestionTagsRequest, GetProjectsLocationsQaQuestionTagsResponse, GetProjectsLocationsQaQuestionTagsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsQaQuestionTagsRequest,
  output: GetProjectsLocationsQaQuestionTagsResponse,
  errors: [],
}));

/** Updates a QaQuestionTag. */
export interface PatchProjectsLocationsQaQuestionTagsRequest {
  /** Identifier. Resource name for the QaQuestionTag Format projects/{project}/locations/{location}/qaQuestionTags/{qa_question_tag} In the above format, the last segment, i.e., qa_question_tag, is a server-generated ID corresponding to the tag resource. */
  name: string;
  /** Optional. The list of fields to be updated. All possible fields can be updated by passing `*`, or a subset of the following updateable fields can be provided: * `qa_question_tag_name` - the name of the tag * `qa_question_ids` - the list of questions the tag applies to */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1QaQuestionTag;
}

export const PatchProjectsLocationsQaQuestionTagsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1QaQuestionTag).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/qaQuestionTags/{qaQuestionTagsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsQaQuestionTagsRequest>;

export type PatchProjectsLocationsQaQuestionTagsResponse = GoogleLongrunningOperation;
export const PatchProjectsLocationsQaQuestionTagsResponse = GoogleLongrunningOperation;

export type PatchProjectsLocationsQaQuestionTagsError = CommonErrors;

export const patchProjectsLocationsQaQuestionTags: API.OperationMethod<PatchProjectsLocationsQaQuestionTagsRequest, PatchProjectsLocationsQaQuestionTagsResponse, PatchProjectsLocationsQaQuestionTagsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsQaQuestionTagsRequest,
  output: PatchProjectsLocationsQaQuestionTagsResponse,
  errors: [],
}));

/** Deletes a QaQuestionTag. */
export interface DeleteProjectsLocationsQaQuestionTagsRequest {
  /** Required. The name of the QaQuestionTag to delete. */
  name: string;
}

export const DeleteProjectsLocationsQaQuestionTagsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/qaQuestionTags/{qaQuestionTagsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsQaQuestionTagsRequest>;

export type DeleteProjectsLocationsQaQuestionTagsResponse = GoogleLongrunningOperation;
export const DeleteProjectsLocationsQaQuestionTagsResponse = GoogleLongrunningOperation;

export type DeleteProjectsLocationsQaQuestionTagsError = CommonErrors;

export const deleteProjectsLocationsQaQuestionTags: API.OperationMethod<DeleteProjectsLocationsQaQuestionTagsRequest, DeleteProjectsLocationsQaQuestionTagsResponse, DeleteProjectsLocationsQaQuestionTagsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsQaQuestionTagsRequest,
  output: DeleteProjectsLocationsQaQuestionTagsResponse,
  errors: [],
}));

/** Lists the question tags. */
export interface ListProjectsLocationsQaQuestionTagsRequest {
  /** Required. The parent resource of the QaQuestionTags. */
  parent: string;
  /** Optional. A filter to reduce results to a specific subset. Supports conjunctions (ie. AND operators). Supported fields include the following: * `project_id` - id of the project to list tags for * `qa_scorecard_id` - id of the scorecard to list tags for * `revision_id` - id of the scorecard revision to list tags for` * `qa_question_id - id of the question to list tags for` */
  filter?: string;
}

export const ListProjectsLocationsQaQuestionTagsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/qaQuestionTags" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsQaQuestionTagsRequest>;

export type ListProjectsLocationsQaQuestionTagsResponse = GoogleCloudContactcenterinsightsV1ListQaQuestionTagsResponse;
export const ListProjectsLocationsQaQuestionTagsResponse = GoogleCloudContactcenterinsightsV1ListQaQuestionTagsResponse;

export type ListProjectsLocationsQaQuestionTagsError = CommonErrors;

export const listProjectsLocationsQaQuestionTags: API.OperationMethod<ListProjectsLocationsQaQuestionTagsRequest, ListProjectsLocationsQaQuestionTagsResponse, ListProjectsLocationsQaQuestionTagsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: ListProjectsLocationsQaQuestionTagsRequest,
  output: ListProjectsLocationsQaQuestionTagsResponse,
  errors: [],
}));

/** Create a QaScorecard. */
export interface CreateProjectsLocationsQaScorecardsRequest {
  /** Required. The parent resource of the QaScorecard. */
  parent: string;
  /** Optional. A unique ID for the new QaScorecard. This ID will become the final component of the QaScorecard's resource name. If no ID is specified, a server-generated ID will be used. This value should be 4-64 characters and must match the regular expression `^[a-z0-9-]{4,64}$`. Valid characters are `a-z-`. */
  qaScorecardId?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1QaScorecard;
}

export const CreateProjectsLocationsQaScorecardsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  qaScorecardId: Schema.optional(Schema.String).pipe(T.HttpQuery("qaScorecardId")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1QaScorecard).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/qaScorecards", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsQaScorecardsRequest>;

export type CreateProjectsLocationsQaScorecardsResponse = GoogleCloudContactcenterinsightsV1QaScorecard;
export const CreateProjectsLocationsQaScorecardsResponse = GoogleCloudContactcenterinsightsV1QaScorecard;

export type CreateProjectsLocationsQaScorecardsError = CommonErrors;

export const createProjectsLocationsQaScorecards: API.OperationMethod<CreateProjectsLocationsQaScorecardsRequest, CreateProjectsLocationsQaScorecardsResponse, CreateProjectsLocationsQaScorecardsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsQaScorecardsRequest,
  output: CreateProjectsLocationsQaScorecardsResponse,
  errors: [],
}));

/** Gets a QaScorecard. */
export interface GetProjectsLocationsQaScorecardsRequest {
  /** Required. The name of the QaScorecard to get. */
  name: string;
}

export const GetProjectsLocationsQaScorecardsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/qaScorecards/{qaScorecardsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsQaScorecardsRequest>;

export type GetProjectsLocationsQaScorecardsResponse = GoogleCloudContactcenterinsightsV1QaScorecard;
export const GetProjectsLocationsQaScorecardsResponse = GoogleCloudContactcenterinsightsV1QaScorecard;

export type GetProjectsLocationsQaScorecardsError = CommonErrors;

export const getProjectsLocationsQaScorecards: API.OperationMethod<GetProjectsLocationsQaScorecardsRequest, GetProjectsLocationsQaScorecardsResponse, GetProjectsLocationsQaScorecardsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsQaScorecardsRequest,
  output: GetProjectsLocationsQaScorecardsResponse,
  errors: [],
}));

/** Updates a QaScorecard. */
export interface PatchProjectsLocationsQaScorecardsRequest {
  /** Identifier. The scorecard name. Format: projects/{project}/locations/{location}/qaScorecards/{qa_scorecard} */
  name: string;
  /** Required. The list of fields to be updated. All possible fields can be updated by passing `*`, or a subset of the following updateable fields can be provided: * `description` * `display_name` */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1QaScorecard;
}

export const PatchProjectsLocationsQaScorecardsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1QaScorecard).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/qaScorecards/{qaScorecardsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsQaScorecardsRequest>;

export type PatchProjectsLocationsQaScorecardsResponse = GoogleCloudContactcenterinsightsV1QaScorecard;
export const PatchProjectsLocationsQaScorecardsResponse = GoogleCloudContactcenterinsightsV1QaScorecard;

export type PatchProjectsLocationsQaScorecardsError = CommonErrors;

export const patchProjectsLocationsQaScorecards: API.OperationMethod<PatchProjectsLocationsQaScorecardsRequest, PatchProjectsLocationsQaScorecardsResponse, PatchProjectsLocationsQaScorecardsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsQaScorecardsRequest,
  output: PatchProjectsLocationsQaScorecardsResponse,
  errors: [],
}));

/** Deletes a QaScorecard. */
export interface DeleteProjectsLocationsQaScorecardsRequest {
  /** Required. The name of the QaScorecard to delete. */
  name: string;
  /** Optional. If set to true, all of this QaScorecard's child resources will also be deleted. Otherwise, the request will only succeed if it has none. */
  force?: boolean;
}

export const DeleteProjectsLocationsQaScorecardsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  force: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("force")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/qaScorecards/{qaScorecardsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsQaScorecardsRequest>;

export type DeleteProjectsLocationsQaScorecardsResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsQaScorecardsResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsQaScorecardsError = CommonErrors;

export const deleteProjectsLocationsQaScorecards: API.OperationMethod<DeleteProjectsLocationsQaScorecardsRequest, DeleteProjectsLocationsQaScorecardsResponse, DeleteProjectsLocationsQaScorecardsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsQaScorecardsRequest,
  output: DeleteProjectsLocationsQaScorecardsResponse,
  errors: [],
}));

/** Lists QaScorecards. */
export interface ListProjectsLocationsQaScorecardsRequest {
  /** Required. The parent resource of the scorecards. */
  parent: string;
  /** Optional. The maximum number of scorecards to return in the response. If the value is zero, the service will select a default size. A call might return fewer objects than requested. A non-empty `next_page_token` in the response indicates that more data is available. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListQaScorecardsResponse`. This value indicates that this is a continuation of a prior `ListQaScorecards` call and that the system should return the next page of data. */
  pageToken?: string;
  /** Optional. The source of scorecards are based on how those Scorecards were created, e.g., a customer-defined scorecard, a predefined scorecard, etc. This field is used to retrieve Scorecards of one or more sources. */
  qaScorecardSources?: "QA_SCORECARD_SOURCE_UNSPECIFIED" | "QA_SCORECARD_SOURCE_CUSTOMER_DEFINED" | "QA_SCORECARD_SOURCE_DISCOVERY_ENGINE" | (string & {})[];
}

export const ListProjectsLocationsQaScorecardsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  qaScorecardSources: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("qaScorecardSources")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/qaScorecards" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsQaScorecardsRequest>;

export type ListProjectsLocationsQaScorecardsResponse = GoogleCloudContactcenterinsightsV1ListQaScorecardsResponse;
export const ListProjectsLocationsQaScorecardsResponse = GoogleCloudContactcenterinsightsV1ListQaScorecardsResponse;

export type ListProjectsLocationsQaScorecardsError = CommonErrors;

export const listProjectsLocationsQaScorecards = API.makePaginated(() => ({
  input: ListProjectsLocationsQaScorecardsRequest,
  output: ListProjectsLocationsQaScorecardsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Creates a QaScorecardRevision. */
export interface CreateProjectsLocationsQaScorecardsRevisionsRequest {
  /** Required. The parent resource of the QaScorecardRevision. */
  parent: string;
  /** Optional. A unique ID for the new QaScorecardRevision. This ID will become the final component of the QaScorecardRevision's resource name. If no ID is specified, a server-generated ID will be used. This value should be 4-64 characters and must match the regular expression `^[a-z0-9-]{4,64}$`. Valid characters are `a-z-`. */
  qaScorecardRevisionId?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1QaScorecardRevision;
}

export const CreateProjectsLocationsQaScorecardsRevisionsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  qaScorecardRevisionId: Schema.optional(Schema.String).pipe(T.HttpQuery("qaScorecardRevisionId")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1QaScorecardRevision).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/qaScorecards/{qaScorecardsId}/revisions", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsQaScorecardsRevisionsRequest>;

export type CreateProjectsLocationsQaScorecardsRevisionsResponse = GoogleCloudContactcenterinsightsV1QaScorecardRevision;
export const CreateProjectsLocationsQaScorecardsRevisionsResponse = GoogleCloudContactcenterinsightsV1QaScorecardRevision;

export type CreateProjectsLocationsQaScorecardsRevisionsError = CommonErrors;

export const createProjectsLocationsQaScorecardsRevisions: API.OperationMethod<CreateProjectsLocationsQaScorecardsRevisionsRequest, CreateProjectsLocationsQaScorecardsRevisionsResponse, CreateProjectsLocationsQaScorecardsRevisionsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsQaScorecardsRevisionsRequest,
  output: CreateProjectsLocationsQaScorecardsRevisionsResponse,
  errors: [],
}));

/** Gets a QaScorecardRevision. */
export interface GetProjectsLocationsQaScorecardsRevisionsRequest {
  /** Required. The name of the QaScorecardRevision to get. */
  name: string;
}

export const GetProjectsLocationsQaScorecardsRevisionsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/qaScorecards/{qaScorecardsId}/revisions/{revisionsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsQaScorecardsRevisionsRequest>;

export type GetProjectsLocationsQaScorecardsRevisionsResponse = GoogleCloudContactcenterinsightsV1QaScorecardRevision;
export const GetProjectsLocationsQaScorecardsRevisionsResponse = GoogleCloudContactcenterinsightsV1QaScorecardRevision;

export type GetProjectsLocationsQaScorecardsRevisionsError = CommonErrors;

export const getProjectsLocationsQaScorecardsRevisions: API.OperationMethod<GetProjectsLocationsQaScorecardsRevisionsRequest, GetProjectsLocationsQaScorecardsRevisionsResponse, GetProjectsLocationsQaScorecardsRevisionsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsQaScorecardsRevisionsRequest,
  output: GetProjectsLocationsQaScorecardsRevisionsResponse,
  errors: [],
}));

/** Fine tune one or more QaModels. */
export interface TuneQaScorecardRevisionProjectsLocationsQaScorecardsRevisionsRequest {
  /** Required. The parent resource for new fine tuning job instance. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1TuneQaScorecardRevisionRequest;
}

export const TuneQaScorecardRevisionProjectsLocationsQaScorecardsRevisionsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1TuneQaScorecardRevisionRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/qaScorecards/{qaScorecardsId}/revisions/{revisionsId}:tuneQaScorecardRevision", hasBody: true }),
  svc,
) as unknown as Schema.Schema<TuneQaScorecardRevisionProjectsLocationsQaScorecardsRevisionsRequest>;

export type TuneQaScorecardRevisionProjectsLocationsQaScorecardsRevisionsResponse = GoogleLongrunningOperation;
export const TuneQaScorecardRevisionProjectsLocationsQaScorecardsRevisionsResponse = GoogleLongrunningOperation;

export type TuneQaScorecardRevisionProjectsLocationsQaScorecardsRevisionsError = CommonErrors;

export const tuneQaScorecardRevisionProjectsLocationsQaScorecardsRevisions: API.OperationMethod<TuneQaScorecardRevisionProjectsLocationsQaScorecardsRevisionsRequest, TuneQaScorecardRevisionProjectsLocationsQaScorecardsRevisionsResponse, TuneQaScorecardRevisionProjectsLocationsQaScorecardsRevisionsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: TuneQaScorecardRevisionProjectsLocationsQaScorecardsRevisionsRequest,
  output: TuneQaScorecardRevisionProjectsLocationsQaScorecardsRevisionsResponse,
  errors: [],
}));

/** Deploy a QaScorecardRevision. */
export interface DeployProjectsLocationsQaScorecardsRevisionsRequest {
  /** Required. The name of the QaScorecardRevision to deploy. */
  name: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1DeployQaScorecardRevisionRequest;
}

export const DeployProjectsLocationsQaScorecardsRevisionsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1DeployQaScorecardRevisionRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/qaScorecards/{qaScorecardsId}/revisions/{revisionsId}:deploy", hasBody: true }),
  svc,
) as unknown as Schema.Schema<DeployProjectsLocationsQaScorecardsRevisionsRequest>;

export type DeployProjectsLocationsQaScorecardsRevisionsResponse = GoogleCloudContactcenterinsightsV1QaScorecardRevision;
export const DeployProjectsLocationsQaScorecardsRevisionsResponse = GoogleCloudContactcenterinsightsV1QaScorecardRevision;

export type DeployProjectsLocationsQaScorecardsRevisionsError = CommonErrors;

export const deployProjectsLocationsQaScorecardsRevisions: API.OperationMethod<DeployProjectsLocationsQaScorecardsRevisionsRequest, DeployProjectsLocationsQaScorecardsRevisionsResponse, DeployProjectsLocationsQaScorecardsRevisionsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeployProjectsLocationsQaScorecardsRevisionsRequest,
  output: DeployProjectsLocationsQaScorecardsRevisionsResponse,
  errors: [],
}));

/** Undeploy a QaScorecardRevision. */
export interface UndeployProjectsLocationsQaScorecardsRevisionsRequest {
  /** Required. The name of the QaScorecardRevision to undeploy. */
  name: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1UndeployQaScorecardRevisionRequest;
}

export const UndeployProjectsLocationsQaScorecardsRevisionsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1UndeployQaScorecardRevisionRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/qaScorecards/{qaScorecardsId}/revisions/{revisionsId}:undeploy", hasBody: true }),
  svc,
) as unknown as Schema.Schema<UndeployProjectsLocationsQaScorecardsRevisionsRequest>;

export type UndeployProjectsLocationsQaScorecardsRevisionsResponse = GoogleCloudContactcenterinsightsV1QaScorecardRevision;
export const UndeployProjectsLocationsQaScorecardsRevisionsResponse = GoogleCloudContactcenterinsightsV1QaScorecardRevision;

export type UndeployProjectsLocationsQaScorecardsRevisionsError = CommonErrors;

export const undeployProjectsLocationsQaScorecardsRevisions: API.OperationMethod<UndeployProjectsLocationsQaScorecardsRevisionsRequest, UndeployProjectsLocationsQaScorecardsRevisionsResponse, UndeployProjectsLocationsQaScorecardsRevisionsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: UndeployProjectsLocationsQaScorecardsRevisionsRequest,
  output: UndeployProjectsLocationsQaScorecardsRevisionsResponse,
  errors: [],
}));

/** Deletes a QaScorecardRevision. */
export interface DeleteProjectsLocationsQaScorecardsRevisionsRequest {
  /** Required. The name of the QaScorecardRevision to delete. */
  name: string;
  /** Optional. If set to true, all of this QaScorecardRevision's child resources will also be deleted. Otherwise, the request will only succeed if it has none. */
  force?: boolean;
}

export const DeleteProjectsLocationsQaScorecardsRevisionsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  force: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("force")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/qaScorecards/{qaScorecardsId}/revisions/{revisionsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsQaScorecardsRevisionsRequest>;

export type DeleteProjectsLocationsQaScorecardsRevisionsResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsQaScorecardsRevisionsResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsQaScorecardsRevisionsError = CommonErrors;

export const deleteProjectsLocationsQaScorecardsRevisions: API.OperationMethod<DeleteProjectsLocationsQaScorecardsRevisionsRequest, DeleteProjectsLocationsQaScorecardsRevisionsResponse, DeleteProjectsLocationsQaScorecardsRevisionsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsQaScorecardsRevisionsRequest,
  output: DeleteProjectsLocationsQaScorecardsRevisionsResponse,
  errors: [],
}));

/** Lists all revisions under the parent QaScorecard. */
export interface ListProjectsLocationsQaScorecardsRevisionsRequest {
  /** Required. The parent resource of the scorecard revisions. To list all revisions of all scorecards, substitute the QaScorecard ID with a '-' character. */
  parent: string;
  /** Optional. The maximum number of scorecard revisions to return in the response. If the value is zero, the service will select a default size. A call might return fewer objects than requested. A non-empty `next_page_token` in the response indicates that more data is available. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListQaScorecardRevisionsResponse`. This value indicates that this is a continuation of a prior `ListQaScorecardRevisions` call and that the system should return the next page of data. */
  pageToken?: string;
  /** Optional. A filter to reduce results to a specific subset. Useful for querying scorecard revisions with specific properties. */
  filter?: string;
  /** Optional. The source of scorecards are based on how those Scorecards were created, e.g., a customer-defined scorecard, a predefined scorecard, etc. This field is used to retrieve Scorecards Revisions from Scorecards of one or more sources. */
  qaScorecardSources?: "QA_SCORECARD_SOURCE_UNSPECIFIED" | "QA_SCORECARD_SOURCE_CUSTOMER_DEFINED" | "QA_SCORECARD_SOURCE_DISCOVERY_ENGINE" | (string & {})[];
}

export const ListProjectsLocationsQaScorecardsRevisionsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  qaScorecardSources: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("qaScorecardSources")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/qaScorecards/{qaScorecardsId}/revisions" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsQaScorecardsRevisionsRequest>;

export type ListProjectsLocationsQaScorecardsRevisionsResponse = GoogleCloudContactcenterinsightsV1ListQaScorecardRevisionsResponse;
export const ListProjectsLocationsQaScorecardsRevisionsResponse = GoogleCloudContactcenterinsightsV1ListQaScorecardRevisionsResponse;

export type ListProjectsLocationsQaScorecardsRevisionsError = CommonErrors;

export const listProjectsLocationsQaScorecardsRevisions = API.makePaginated(() => ({
  input: ListProjectsLocationsQaScorecardsRevisionsRequest,
  output: ListProjectsLocationsQaScorecardsRevisionsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Create a QaQuestion. */
export interface CreateProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest {
  /** Required. The parent resource of the QaQuestion. */
  parent: string;
  /** Optional. A unique ID for the new question. This ID will become the final component of the question's resource name. If no ID is specified, a server-generated ID will be used. This value should be 4-64 characters and must match the regular expression `^[a-z0-9-]{4,64}$`. Valid characters are `a-z-`. */
  qaQuestionId?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1QaQuestion;
}

export const CreateProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  qaQuestionId: Schema.optional(Schema.String).pipe(T.HttpQuery("qaQuestionId")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1QaQuestion).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/qaScorecards/{qaScorecardsId}/revisions/{revisionsId}/qaQuestions", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest>;

export type CreateProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse = GoogleCloudContactcenterinsightsV1QaQuestion;
export const CreateProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse = GoogleCloudContactcenterinsightsV1QaQuestion;

export type CreateProjectsLocationsQaScorecardsRevisionsQaQuestionsError = CommonErrors;

export const createProjectsLocationsQaScorecardsRevisionsQaQuestions: API.OperationMethod<CreateProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest, CreateProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse, CreateProjectsLocationsQaScorecardsRevisionsQaQuestionsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest,
  output: CreateProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse,
  errors: [],
}));

/** Gets a QaQuestion. */
export interface GetProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest {
  /** Required. The name of the QaQuestion to get. */
  name: string;
}

export const GetProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/qaScorecards/{qaScorecardsId}/revisions/{revisionsId}/qaQuestions/{qaQuestionsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest>;

export type GetProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse = GoogleCloudContactcenterinsightsV1QaQuestion;
export const GetProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse = GoogleCloudContactcenterinsightsV1QaQuestion;

export type GetProjectsLocationsQaScorecardsRevisionsQaQuestionsError = CommonErrors;

export const getProjectsLocationsQaScorecardsRevisionsQaQuestions: API.OperationMethod<GetProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest, GetProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse, GetProjectsLocationsQaScorecardsRevisionsQaQuestionsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest,
  output: GetProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse,
  errors: [],
}));

/** Updates a QaQuestion. */
export interface PatchProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest {
  /** Identifier. The resource name of the question. Format: projects/{project}/locations/{location}/qaScorecards/{qa_scorecard}/revisions/{revision}/qaQuestions/{qa_question} */
  name: string;
  /** Required. The list of fields to be updated. All possible fields can be updated by passing `*`, or a subset of the following updateable fields can be provided: * `abbreviation` * `answer_choices` * `answer_instructions` * `order` * `question_body` * `tags` */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1QaQuestion;
}

export const PatchProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1QaQuestion).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/qaScorecards/{qaScorecardsId}/revisions/{revisionsId}/qaQuestions/{qaQuestionsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest>;

export type PatchProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse = GoogleCloudContactcenterinsightsV1QaQuestion;
export const PatchProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse = GoogleCloudContactcenterinsightsV1QaQuestion;

export type PatchProjectsLocationsQaScorecardsRevisionsQaQuestionsError = CommonErrors;

export const patchProjectsLocationsQaScorecardsRevisionsQaQuestions: API.OperationMethod<PatchProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest, PatchProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse, PatchProjectsLocationsQaScorecardsRevisionsQaQuestionsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest,
  output: PatchProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse,
  errors: [],
}));

/** Deletes a QaQuestion. */
export interface DeleteProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest {
  /** Required. The name of the QaQuestion to delete. */
  name: string;
}

export const DeleteProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/qaScorecards/{qaScorecardsId}/revisions/{revisionsId}/qaQuestions/{qaQuestionsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest>;

export type DeleteProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsQaScorecardsRevisionsQaQuestionsError = CommonErrors;

export const deleteProjectsLocationsQaScorecardsRevisionsQaQuestions: API.OperationMethod<DeleteProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest, DeleteProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse, DeleteProjectsLocationsQaScorecardsRevisionsQaQuestionsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest,
  output: DeleteProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse,
  errors: [],
}));

/** Lists QaQuestions. */
export interface ListProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest {
  /** Required. The parent resource of the questions. */
  parent: string;
  /** Optional. The maximum number of questions to return in the response. If the value is zero, the service will select a default size. A call might return fewer objects than requested. A non-empty `next_page_token` in the response indicates that more data is available. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListQaQuestionsResponse`. This value indicates that this is a continuation of a prior `ListQaQuestions` call and that the system should return the next page of data. */
  pageToken?: string;
}

export const ListProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/qaScorecards/{qaScorecardsId}/revisions/{revisionsId}/qaQuestions" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest>;

export type ListProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse = GoogleCloudContactcenterinsightsV1ListQaQuestionsResponse;
export const ListProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse = GoogleCloudContactcenterinsightsV1ListQaQuestionsResponse;

export type ListProjectsLocationsQaScorecardsRevisionsQaQuestionsError = CommonErrors;

export const listProjectsLocationsQaScorecardsRevisionsQaQuestions = API.makePaginated(() => ({
  input: ListProjectsLocationsQaScorecardsRevisionsQaQuestionsRequest,
  output: ListProjectsLocationsQaScorecardsRevisionsQaQuestionsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Create AuthorizedViewSet */
export interface CreateProjectsLocationsAuthorizedViewSetsRequest {
  /** Required. The parent resource of the AuthorizedViewSet. */
  parent: string;
  /** Optional. A unique ID for the new AuthorizedViewSet. This ID will become the final component of the AuthorizedViewSet's resource name. If no ID is specified, a server-generated ID will be used. This value should be 4-64 characters and must match the regular expression `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`. See https://google.aip.dev/122#resource-id-segments */
  authorizedViewSetId?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1AuthorizedViewSet;
}

export const CreateProjectsLocationsAuthorizedViewSetsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  authorizedViewSetId: Schema.optional(Schema.String).pipe(T.HttpQuery("authorizedViewSetId")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1AuthorizedViewSet).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsAuthorizedViewSetsRequest>;

export type CreateProjectsLocationsAuthorizedViewSetsResponse = GoogleCloudContactcenterinsightsV1AuthorizedViewSet;
export const CreateProjectsLocationsAuthorizedViewSetsResponse = GoogleCloudContactcenterinsightsV1AuthorizedViewSet;

export type CreateProjectsLocationsAuthorizedViewSetsError = CommonErrors;

export const createProjectsLocationsAuthorizedViewSets: API.OperationMethod<CreateProjectsLocationsAuthorizedViewSetsRequest, CreateProjectsLocationsAuthorizedViewSetsResponse, CreateProjectsLocationsAuthorizedViewSetsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsAuthorizedViewSetsRequest,
  output: CreateProjectsLocationsAuthorizedViewSetsResponse,
  errors: [],
}));

/** Get AuthorizedViewSet */
export interface GetProjectsLocationsAuthorizedViewSetsRequest {
  /** Required. The name of the AuthorizedViewSet to get. */
  name: string;
}

export const GetProjectsLocationsAuthorizedViewSetsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsAuthorizedViewSetsRequest>;

export type GetProjectsLocationsAuthorizedViewSetsResponse = GoogleCloudContactcenterinsightsV1AuthorizedViewSet;
export const GetProjectsLocationsAuthorizedViewSetsResponse = GoogleCloudContactcenterinsightsV1AuthorizedViewSet;

export type GetProjectsLocationsAuthorizedViewSetsError = CommonErrors;

export const getProjectsLocationsAuthorizedViewSets: API.OperationMethod<GetProjectsLocationsAuthorizedViewSetsRequest, GetProjectsLocationsAuthorizedViewSetsResponse, GetProjectsLocationsAuthorizedViewSetsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsAuthorizedViewSetsRequest,
  output: GetProjectsLocationsAuthorizedViewSetsResponse,
  errors: [],
}));

/** List AuthorizedViewSets */
export interface ListProjectsLocationsAuthorizedViewSetsRequest {
  /** Required. The parent resource of the AuthorizedViewSets. */
  parent: string;
  /** Optional. The maximum number of view sets to return in the response. If the value is zero, the service will select a default size. A call might return fewer objects than requested. A non-empty `next_page_token` in the response indicates that more data is available. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListAuthorizedViewSetsResponse`. This value indicates that this is a continuation of a prior `ListAuthorizedViewSets` call and that the system should return the next page of data. */
  pageToken?: string;
  /** Optional. The filter expression to filter authorized view sets listed in the response. */
  filter?: string;
  /** Optional. The order by expression to order authorized view sets listed in the response. */
  orderBy?: string;
}

export const ListProjectsLocationsAuthorizedViewSetsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsAuthorizedViewSetsRequest>;

export type ListProjectsLocationsAuthorizedViewSetsResponse = GoogleCloudContactcenterinsightsV1ListAuthorizedViewSetsResponse;
export const ListProjectsLocationsAuthorizedViewSetsResponse = GoogleCloudContactcenterinsightsV1ListAuthorizedViewSetsResponse;

export type ListProjectsLocationsAuthorizedViewSetsError = CommonErrors;

export const listProjectsLocationsAuthorizedViewSets = API.makePaginated(() => ({
  input: ListProjectsLocationsAuthorizedViewSetsRequest,
  output: ListProjectsLocationsAuthorizedViewSetsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Updates an AuthorizedViewSet. */
export interface PatchProjectsLocationsAuthorizedViewSetsRequest {
  /** Identifier. The resource name of the AuthorizedViewSet. Format: projects/{project}/locations/{location}/authorizedViewSets/{authorized_view_set} */
  name: string;
  /** Optional. The list of fields to be updated. All possible fields can be updated by passing `*`, or a subset of the following updateable fields can be provided: * `display_name` */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1AuthorizedViewSet;
}

export const PatchProjectsLocationsAuthorizedViewSetsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1AuthorizedViewSet).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsAuthorizedViewSetsRequest>;

export type PatchProjectsLocationsAuthorizedViewSetsResponse = GoogleCloudContactcenterinsightsV1AuthorizedViewSet;
export const PatchProjectsLocationsAuthorizedViewSetsResponse = GoogleCloudContactcenterinsightsV1AuthorizedViewSet;

export type PatchProjectsLocationsAuthorizedViewSetsError = CommonErrors;

export const patchProjectsLocationsAuthorizedViewSets: API.OperationMethod<PatchProjectsLocationsAuthorizedViewSetsRequest, PatchProjectsLocationsAuthorizedViewSetsResponse, PatchProjectsLocationsAuthorizedViewSetsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsAuthorizedViewSetsRequest,
  output: PatchProjectsLocationsAuthorizedViewSetsResponse,
  errors: [],
}));

/** Deletes an AuthorizedViewSet. */
export interface DeleteProjectsLocationsAuthorizedViewSetsRequest {
  /** Required. The name of the AuthorizedViewSet to delete. */
  name: string;
  /** Optional. If set to true, all of this AuthorizedViewSet's child resources will also be deleted. Otherwise, the request will only succeed if it has none. */
  force?: boolean;
}

export const DeleteProjectsLocationsAuthorizedViewSetsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  force: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("force")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsAuthorizedViewSetsRequest>;

export type DeleteProjectsLocationsAuthorizedViewSetsResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsAuthorizedViewSetsResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsAuthorizedViewSetsError = CommonErrors;

export const deleteProjectsLocationsAuthorizedViewSets: API.OperationMethod<DeleteProjectsLocationsAuthorizedViewSetsRequest, DeleteProjectsLocationsAuthorizedViewSetsResponse, DeleteProjectsLocationsAuthorizedViewSetsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsAuthorizedViewSetsRequest,
  output: DeleteProjectsLocationsAuthorizedViewSetsResponse,
  errors: [],
}));

/** Sets the access control policy on the specified resource. Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors. */
export interface SetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest {
  /** REQUIRED: The resource for which the policy is being specified. See [Resource names](https://cloud.google.com/apis/design/resource_names) for the appropriate value for this field. */
  resource: string;
  /** Request body */
  body?: GoogleIamV1SetIamPolicyRequest;
}

export const SetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest = Schema.Struct({
  resource: Schema.String.pipe(T.HttpPath("resource")),
  body: Schema.optional(GoogleIamV1SetIamPolicyRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}:setIamPolicy", hasBody: true }),
  svc,
) as unknown as Schema.Schema<SetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest>;

export type SetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleIamV1Policy;
export const SetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleIamV1Policy;

export type SetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsError = CommonErrors;

export const setIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViews: API.OperationMethod<SetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest, SetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse, SetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: SetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest,
  output: SetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse,
  errors: [],
}));

/** Gets the access control policy for a resource. Returns an empty policy if the resource exists and does not have a policy set. */
export interface GetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest {
  /** REQUIRED: The resource for which the policy is being requested. See [Resource names](https://cloud.google.com/apis/design/resource_names) for the appropriate value for this field. */
  resource: string;
  /** Optional. The maximum policy version that will be used to format the policy. Valid values are 0, 1, and 3. Requests specifying an invalid value will be rejected. Requests for policies with any conditional role bindings must specify version 3. Policies with no conditional role bindings may specify any valid value or leave the field unset. The policy in the response might use the policy version that you specified, or it might use a lower policy version. For example, if you specify version 3, but the policy has no conditional role bindings, the response uses version 1. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). */
  "options.requestedPolicyVersion"?: number;
}

export const GetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest = Schema.Struct({
  resource: Schema.String.pipe(T.HttpPath("resource")),
  "options.requestedPolicyVersion": Schema.optional(Schema.Number).pipe(T.HttpQuery("options.requestedPolicyVersion")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}:getIamPolicy" }),
  svc,
) as unknown as Schema.Schema<GetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest>;

export type GetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleIamV1Policy;
export const GetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleIamV1Policy;

export type GetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsError = CommonErrors;

export const getIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViews: API.OperationMethod<GetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest, GetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse, GetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest,
  output: GetIamPolicyProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse,
  errors: [],
}));

/** Returns permissions that a caller has on the specified resource. If the resource does not exist, this will return an empty set of permissions, not a `NOT_FOUND` error. Note: This operation is designed to be used for building permission-aware UIs and command-line tools, not for authorization checking. This operation may "fail open" without warning. */
export interface TestIamPermissionsProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest {
  /** REQUIRED: The resource for which the policy detail is being requested. See [Resource names](https://cloud.google.com/apis/design/resource_names) for the appropriate value for this field. */
  resource: string;
  /** Request body */
  body?: GoogleIamV1TestIamPermissionsRequest;
}

export const TestIamPermissionsProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest = Schema.Struct({
  resource: Schema.String.pipe(T.HttpPath("resource")),
  body: Schema.optional(GoogleIamV1TestIamPermissionsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}:testIamPermissions", hasBody: true }),
  svc,
) as unknown as Schema.Schema<TestIamPermissionsProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest>;

export type TestIamPermissionsProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleIamV1TestIamPermissionsResponse;
export const TestIamPermissionsProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleIamV1TestIamPermissionsResponse;

export type TestIamPermissionsProjectsLocationsAuthorizedViewSetsAuthorizedViewsError = CommonErrors;

export const testIamPermissionsProjectsLocationsAuthorizedViewSetsAuthorizedViews: API.OperationMethod<TestIamPermissionsProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest, TestIamPermissionsProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse, TestIamPermissionsProjectsLocationsAuthorizedViewSetsAuthorizedViewsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: TestIamPermissionsProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest,
  output: TestIamPermissionsProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse,
  errors: [],
}));

/** Query metrics. */
export interface QueryMetricsProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest {
  /** Required. The location of the data. "projects/{project}/locations/{location}" */
  location: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1QueryMetricsRequest;
}

export const QueryMetricsProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest = Schema.Struct({
  location: Schema.String.pipe(T.HttpPath("location")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1QueryMetricsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}:queryMetrics", hasBody: true }),
  svc,
) as unknown as Schema.Schema<QueryMetricsProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest>;

export type QueryMetricsProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleLongrunningOperation;
export const QueryMetricsProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleLongrunningOperation;

export type QueryMetricsProjectsLocationsAuthorizedViewSetsAuthorizedViewsError = CommonErrors;

export const queryMetricsProjectsLocationsAuthorizedViewSetsAuthorizedViews: API.OperationMethod<QueryMetricsProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest, QueryMetricsProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse, QueryMetricsProjectsLocationsAuthorizedViewSetsAuthorizedViewsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: QueryMetricsProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest,
  output: QueryMetricsProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse,
  errors: [],
}));

/** Natural language based Insights which powers the next generation of dashboards in Insights. Next generation of QueryMetrics. */
export interface GenerativeInsightsProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest {
  /** Required. The location of the data. "projects/{project}/locations/{location}" */
  location: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1GenerativeInsightsRequest;
}

export const GenerativeInsightsProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest = Schema.Struct({
  location: Schema.String.pipe(T.HttpPath("location")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1GenerativeInsightsRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}:generativeInsights", hasBody: true }),
  svc,
) as unknown as Schema.Schema<GenerativeInsightsProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest>;

export type GenerativeInsightsProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleLongrunningOperation;
export const GenerativeInsightsProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleLongrunningOperation;

export type GenerativeInsightsProjectsLocationsAuthorizedViewSetsAuthorizedViewsError = CommonErrors;

export const generativeInsightsProjectsLocationsAuthorizedViewSetsAuthorizedViews: API.OperationMethod<GenerativeInsightsProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest, GenerativeInsightsProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse, GenerativeInsightsProjectsLocationsAuthorizedViewSetsAuthorizedViewsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GenerativeInsightsProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest,
  output: GenerativeInsightsProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse,
  errors: [],
}));

/** Generates a summary of predefined performance metrics for a set of conversations. Conversations can be specified by specifying a time window and an agent id, for now. The summary includes a comparison of metrics computed for conversations in the previous time period, and also a comparison with peers in the same time period. */
export interface QueryPerformanceOverviewProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest {
  /** Required. The parent resource of the conversations to derive performance stats from. "projects/{project}/locations/{location}" */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewRequest;
}

export const QueryPerformanceOverviewProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1QueryPerformanceOverviewRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}:queryPerformanceOverview", hasBody: true }),
  svc,
) as unknown as Schema.Schema<QueryPerformanceOverviewProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest>;

export type QueryPerformanceOverviewProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleLongrunningOperation;
export const QueryPerformanceOverviewProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleLongrunningOperation;

export type QueryPerformanceOverviewProjectsLocationsAuthorizedViewSetsAuthorizedViewsError = CommonErrors;

export const queryPerformanceOverviewProjectsLocationsAuthorizedViewSetsAuthorizedViews: API.OperationMethod<QueryPerformanceOverviewProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest, QueryPerformanceOverviewProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse, QueryPerformanceOverviewProjectsLocationsAuthorizedViewSetsAuthorizedViewsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: QueryPerformanceOverviewProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest,
  output: QueryPerformanceOverviewProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse,
  errors: [],
}));

/** Create AuthorizedView */
export interface CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest {
  /** Required. The parent resource of the AuthorizedView. */
  parent: string;
  /** Optional. A unique ID for the new AuthorizedView. This ID will become the final component of the AuthorizedView's resource name. If no ID is specified, a server-generated ID will be used. This value should be 4-64 characters and must match the regular expression `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`. See https://google.aip.dev/122#resource-id-segments */
  authorizedViewId?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1AuthorizedView;
}

export const CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  authorizedViewId: Schema.optional(Schema.String).pipe(T.HttpQuery("authorizedViewId")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1AuthorizedView).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest>;

export type CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleCloudContactcenterinsightsV1AuthorizedView;
export const CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleCloudContactcenterinsightsV1AuthorizedView;

export type CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsError = CommonErrors;

export const createProjectsLocationsAuthorizedViewSetsAuthorizedViews: API.OperationMethod<CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest, CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse, CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest,
  output: CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse,
  errors: [],
}));

/** Get AuthorizedView */
export interface GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest {
  /** Required. The name of the AuthorizedView to get. */
  name: string;
}

export const GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest>;

export type GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleCloudContactcenterinsightsV1AuthorizedView;
export const GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleCloudContactcenterinsightsV1AuthorizedView;

export type GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsError = CommonErrors;

export const getProjectsLocationsAuthorizedViewSetsAuthorizedViews: API.OperationMethod<GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest, GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse, GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest,
  output: GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse,
  errors: [],
}));

/** List AuthorizedViewSets */
export interface ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest {
  /** Required. The parent resource of the AuthorizedViews. If the parent is set to `-`, all AuthorizedViews under the location will be returned. */
  parent: string;
  /** Optional. The maximum number of view to return in the response. If the value is zero, the service will select a default size. A call might return fewer objects than requested. A non-empty `next_page_token` in the response indicates that more data is available. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListAuthorizedViewsResponse`. This value indicates that this is a continuation of a prior `ListAuthorizedViews` call and that the system should return the next page of data. */
  pageToken?: string;
  /** Optional. The filter expression to filter authorized views listed in the response. */
  filter?: string;
  /** Optional. The order by expression to order authorized views listed in the response. */
  orderBy?: string;
}

export const ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest>;

export type ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleCloudContactcenterinsightsV1ListAuthorizedViewsResponse;
export const ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleCloudContactcenterinsightsV1ListAuthorizedViewsResponse;

export type ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsError = CommonErrors;

export const listProjectsLocationsAuthorizedViewSetsAuthorizedViews = API.makePaginated(() => ({
  input: ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest,
  output: ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** SearchAuthorizedViewSets */
export interface SearchProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest {
  /** Required. The parent resource of the AuthorizedViews. If the parent is set to `-`, all AuthorizedViews under the location will be returned. */
  parent: string;
  /** Optional. The maximum number of view to return in the response. If the value is zero, the service will select a default size. A call might return fewer objects than requested. A non-empty `next_page_token` in the response indicates that more data is available. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListAuthorizedViewsResponse`. This value indicates that this is a continuation of a prior `ListAuthorizedViews` call and that the system should return the next page of data. */
  pageToken?: string;
  /** Optional. The query expression to search authorized views. */
  query?: string;
  /** Optional. The order by expression to order authorized views listed in the response. */
  orderBy?: string;
}

export const SearchProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  query: Schema.optional(Schema.String).pipe(T.HttpQuery("query")),
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews:search" }),
  svc,
) as unknown as Schema.Schema<SearchProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest>;

export type SearchProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleCloudContactcenterinsightsV1SearchAuthorizedViewsResponse;
export const SearchProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleCloudContactcenterinsightsV1SearchAuthorizedViewsResponse;

export type SearchProjectsLocationsAuthorizedViewSetsAuthorizedViewsError = CommonErrors;

export const searchProjectsLocationsAuthorizedViewSetsAuthorizedViews = API.makePaginated(() => ({
  input: SearchProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest,
  output: SearchProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Updates an AuthorizedView. */
export interface PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest {
  /** Identifier. The resource name of the AuthorizedView. Format: projects/{project}/locations/{location}/authorizedViewSets/{authorized_view_set}/authorizedViews/{authorized_view} */
  name: string;
  /** Optional. The list of fields to be updated. All possible fields can be updated by passing `*`, or a subset of the following updateable fields can be provided: * `conversation_filter` * `display_name` */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1AuthorizedView;
}

export const PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1AuthorizedView).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest>;

export type PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleCloudContactcenterinsightsV1AuthorizedView;
export const PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleCloudContactcenterinsightsV1AuthorizedView;

export type PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsError = CommonErrors;

export const patchProjectsLocationsAuthorizedViewSetsAuthorizedViews: API.OperationMethod<PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest, PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse, PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest,
  output: PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse,
  errors: [],
}));

/** Deletes an AuthorizedView. */
export interface DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest {
  /** Required. The name of the AuthorizedView to delete. */
  name: string;
}

export const DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest>;

export type DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsError = CommonErrors;

export const deleteProjectsLocationsAuthorizedViewSetsAuthorizedViews: API.OperationMethod<DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest, DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse, DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsRequest,
  output: DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsResponse,
  errors: [],
}));

/** Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns `UNIMPLEMENTED`. */
export interface ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsRequest {
  /** The name of the operation's parent resource. */
  name: string;
  /** The standard list filter. */
  filter?: string;
  /** The standard list page size. */
  pageSize?: number;
  /** The standard list page token. */
  pageToken?: string;
  /** When set to `true`, operations that are reachable are returned as normal, and those that are unreachable are returned in the ListOperationsResponse.unreachable field. This can only be `true` when reading across collections. For example, when `parent` is set to `"projects/example/locations/-"`. This field is not supported by default and will result in an `UNIMPLEMENTED` error if set unless explicitly documented otherwise in service or product specific documentation. */
  returnPartialSuccess?: boolean;
}

export const ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  returnPartialSuccess: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("returnPartialSuccess")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/operations" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsRequest>;

export type ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsResponse = GoogleLongrunningListOperationsResponse;
export const ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsResponse = GoogleLongrunningListOperationsResponse;

export type ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsError = CommonErrors;

export const listProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperations = API.makePaginated(() => ({
  input: ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsRequest,
  output: ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Gets the latest state of a long-running operation. Clients can use this method to poll the operation result at intervals as recommended by the API service. */
export interface GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsRequest {
  /** The name of the operation resource. */
  name: string;
}

export const GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/operations/{operationsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsRequest>;

export type GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsResponse = GoogleLongrunningOperation;
export const GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsResponse = GoogleLongrunningOperation;

export type GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsError = CommonErrors;

export const getProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperations: API.OperationMethod<GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsRequest, GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsResponse, GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsRequest,
  output: GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsResponse,
  errors: [],
}));

/** Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of `1`, corresponding to `Code.CANCELLED`. */
export interface CancelProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsRequest {
  /** The name of the operation resource to be cancelled. */
  name: string;
}

export const CancelProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/operations/{operationsId}:cancel", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CancelProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsRequest>;

export type CancelProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsResponse = GoogleProtobufEmpty;
export const CancelProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsResponse = GoogleProtobufEmpty;

export type CancelProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsError = CommonErrors;

export const cancelProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperations: API.OperationMethod<CancelProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsRequest, CancelProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsResponse, CancelProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CancelProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsRequest,
  output: CancelProjectsLocationsAuthorizedViewSetsAuthorizedViewsOperationsResponse,
  errors: [],
}));

/** Gets a conversation. */
export interface GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest {
  /** Required. The name of the conversation to get. */
  name: string;
  /** The level of details of the conversation. Default is `FULL`. */
  view?: "CONVERSATION_VIEW_UNSPECIFIED" | "FULL" | "BASIC" | (string & {});
}

export const GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  view: Schema.optional(Schema.String).pipe(T.HttpQuery("view")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest>;

export type GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse = GoogleCloudContactcenterinsightsV1Conversation;
export const GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse = GoogleCloudContactcenterinsightsV1Conversation;

export type GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsError = CommonErrors;

export const getProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversations: API.OperationMethod<GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest, GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse, GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest,
  output: GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse,
  errors: [],
}));

/** Lists conversations. */
export interface ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest {
  /** Required. The parent resource of the conversation. */
  parent: string;
  /** The maximum number of conversations to return in the response. A valid page size ranges from 0 to 100,000 inclusive. If the page size is zero or unspecified, a default page size of 100 will be chosen. Note that a call might return fewer results than the requested page size. */
  pageSize?: number;
  /** The value returned by the last `ListConversationsResponse`. This value indicates that this is a continuation of a prior `ListConversations` call and that the system should return the next page of data. */
  pageToken?: string;
  /** A filter to reduce results to a specific subset. Useful for querying conversations with specific properties. */
  filter?: string;
  /** Optional. The attribute by which to order conversations in the response. If empty, conversations will be ordered by descending creation time. Supported values are one of the following: * create_time * customer_satisfaction_rating * duration * latest_analysis * start_time * turn_count The default sort order is ascending. To specify order, append `asc` or `desc` (`create_time desc`). For more details, see [Google AIPs Ordering](https://google.aip.dev/132#ordering). */
  orderBy?: string;
  /** The level of details of the conversation. Default is `BASIC`. */
  view?: "CONVERSATION_VIEW_UNSPECIFIED" | "FULL" | "BASIC" | (string & {});
}

export const ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy")),
  view: Schema.optional(Schema.String).pipe(T.HttpQuery("view")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest>;

export type ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse = GoogleCloudContactcenterinsightsV1ListConversationsResponse;
export const ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse = GoogleCloudContactcenterinsightsV1ListConversationsResponse;

export type ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsError = CommonErrors;

export const listProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversations = API.makePaginated(() => ({
  input: ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest,
  output: ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Gets the signed URI for the audio for the given conversation. */
export interface GenerateSignedAudioProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest {
  /** Required. The name of the conversation to sign. */
  name: string;
}

export const GenerateSignedAudioProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}:generateSignedAudio" }),
  svc,
) as unknown as Schema.Schema<GenerateSignedAudioProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest>;

export type GenerateSignedAudioProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse = GoogleCloudContactcenterinsightsV1GenerateConversationSignedAudioResponse;
export const GenerateSignedAudioProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse = GoogleCloudContactcenterinsightsV1GenerateConversationSignedAudioResponse;

export type GenerateSignedAudioProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsError = CommonErrors;

export const generateSignedAudioProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversations: API.OperationMethod<GenerateSignedAudioProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest, GenerateSignedAudioProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse, GenerateSignedAudioProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GenerateSignedAudioProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest,
  output: GenerateSignedAudioProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse,
  errors: [],
}));

/** Deletes a conversation. */
export interface DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest {
  /** Required. The name of the conversation to delete. */
  name: string;
  /** If set to true, all of this conversation's analyses will also be deleted. Otherwise, the request will only succeed if the conversation has no analyses. */
  force?: boolean;
}

export const DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  force: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("force")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest>;

export type DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsError = CommonErrors;

export const deleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversations: API.OperationMethod<DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest, DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse, DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest,
  output: DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse,
  errors: [],
}));

/** Gets conversation statistics. */
export interface CalculateStatsProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest {
  /** Required. The location of the conversations. */
  location: string;
  /** A filter to reduce results to a specific subset. This field is useful for getting statistics about conversations with specific properties. */
  filter?: string;
}

export const CalculateStatsProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest = Schema.Struct({
  location: Schema.String.pipe(T.HttpPath("location")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations:calculateStats" }),
  svc,
) as unknown as Schema.Schema<CalculateStatsProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest>;

export type CalculateStatsProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse = GoogleCloudContactcenterinsightsV1CalculateStatsResponse;
export const CalculateStatsProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse = GoogleCloudContactcenterinsightsV1CalculateStatsResponse;

export type CalculateStatsProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsError = CommonErrors;

export const calculateStatsProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversations: API.OperationMethod<CalculateStatsProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest, CalculateStatsProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse, CalculateStatsProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CalculateStatsProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsRequest,
  output: CalculateStatsProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsResponse,
  errors: [],
}));

/** Create feedback label. */
export interface CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest {
  /** Required. The parent resource of the feedback label. */
  parent: string;
  /** Optional. The ID of the feedback label to create. If one is not specified it will be generated by the server. */
  feedbackLabelId?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1FeedbackLabel;
}

export const CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  feedbackLabelId: Schema.optional(Schema.String).pipe(T.HttpQuery("feedbackLabelId")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1FeedbackLabel).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}/feedbackLabels", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest>;

export type CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1FeedbackLabel;
export const CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1FeedbackLabel;

export type CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsError = CommonErrors;

export const createProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabels: API.OperationMethod<CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest, CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse, CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest,
  output: CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse,
  errors: [],
}));

/** List feedback labels. */
export interface ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest {
  /** Required. The parent resource of the feedback labels. */
  parent: string;
  /** Optional. A filter to reduce results to a specific subset. Supports disjunctions (OR) and conjunctions (AND). Automatically sorts by conversation ID. To sort by all feedback labels in a project see ListAllFeedbackLabels. Supported fields: * `issue_model_id` * `qa_question_id` * `qa_scorecard_id` * `min_create_time` * `max_create_time` * `min_update_time` * `max_update_time` * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING */
  filter?: string;
  /** Optional. The maximum number of feedback labels to return in the response. A valid page size ranges from 0 to 100,000 inclusive. If the page size is zero or unspecified, a default page size of 100 will be chosen. Note that a call might return fewer results than the requested page size. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListFeedbackLabelsResponse`. This value indicates that this is a continuation of a prior `ListFeedbackLabels` call and that the system should return the next page of data. */
  pageToken?: string;
}

export const ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}/feedbackLabels" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest>;

export type ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1ListFeedbackLabelsResponse;
export const ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1ListFeedbackLabelsResponse;

export type ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsError = CommonErrors;

export const listProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabels = API.makePaginated(() => ({
  input: ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest,
  output: ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Get feedback label. */
export interface GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest {
  /** Required. The name of the feedback label to get. */
  name: string;
}

export const GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}/feedbackLabels/{feedbackLabelsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest>;

export type GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1FeedbackLabel;
export const GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1FeedbackLabel;

export type GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsError = CommonErrors;

export const getProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabels: API.OperationMethod<GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest, GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse, GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest,
  output: GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse,
  errors: [],
}));

/** Update feedback label. */
export interface PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest {
  /** Immutable. Resource name of the FeedbackLabel. Format: projects/{project}/locations/{location}/conversations/{conversation}/feedbackLabels/{feedback_label} */
  name: string;
  /** Required. The list of fields to be updated. */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1FeedbackLabel;
}

export const PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1FeedbackLabel).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}/feedbackLabels/{feedbackLabelsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest>;

export type PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1FeedbackLabel;
export const PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse = GoogleCloudContactcenterinsightsV1FeedbackLabel;

export type PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsError = CommonErrors;

export const patchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabels: API.OperationMethod<PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest, PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse, PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest,
  output: PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse,
  errors: [],
}));

/** Delete feedback label. */
export interface DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest {
  /** Required. The name of the feedback label to delete. */
  name: string;
}

export const DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}/feedbackLabels/{feedbackLabelsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest>;

export type DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsError = CommonErrors;

export const deleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabels: API.OperationMethod<DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest, DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse, DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsRequest,
  output: DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsFeedbackLabelsResponse,
  errors: [],
}));

/** Create Assessment. */
export interface CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest {
  /** Required. The parent resource of the assessment. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1Assessment;
}

export const CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1Assessment).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}/assessments", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest>;

export type CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;
export const CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;

export type CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsError = CommonErrors;

export const createProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessments: API.OperationMethod<CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest, CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse, CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest,
  output: CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse,
  errors: [],
}));

/** Get Assessment. */
export interface GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest {
  /** Required. The name of the assessment to get. */
  name: string;
}

export const GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}/assessments/{assessmentsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest>;

export type GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;
export const GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;

export type GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsError = CommonErrors;

export const getProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessments: API.OperationMethod<GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest, GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse, GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest,
  output: GetProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse,
  errors: [],
}));

/** List Assessments. */
export interface ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest {
  /** Required. The parent resource of the assessments. To list all assessments in a location, substitute the conversation ID with a '-' character. */
  parent: string;
  /** The maximum number of assessments to list. If zero, the service will select a default size. A call may return fewer objects than requested. A non-empty `next_page_token` in the response indicates that more data is available. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListAssessmentRulesResponse`; indicates that this is a continuation of a prior `ListAssessmentRules` call and the system should return the next page of data. */
  pageToken?: string;
  /** Optional. A filter to reduce results to a specific subset. Supported filters include: * `state` - The state of the assessment * `agent_info.agent_id` - The ID of the agent the assessment is for */
  filter?: string;
}

export const ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}/assessments" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest>;

export type ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1ListAssessmentsResponse;
export const ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1ListAssessmentsResponse;

export type ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsError = CommonErrors;

export const listProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessments = API.makePaginated(() => ({
  input: ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest,
  output: ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Delete an Assessment. */
export interface DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest {
  /** Required. The name of the assessment to delete. */
  name: string;
  /** Optional. If set to true, all of this assessment's notes will also be deleted. Otherwise, the request will only succeed if it has no notes. */
  force?: boolean;
}

export const DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  force: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("force")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}/assessments/{assessmentsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest>;

export type DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsError = CommonErrors;

export const deleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessments: API.OperationMethod<DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest, DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse, DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest,
  output: DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse,
  errors: [],
}));

/** Publish an Assessment. */
export interface PublishProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest {
  /** Required. The name of the assessment to publish. */
  name: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1PublishAssessmentRequest;
}

export const PublishProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1PublishAssessmentRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}/assessments/{assessmentsId}:publish", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PublishProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest>;

export type PublishProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;
export const PublishProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;

export type PublishProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsError = CommonErrors;

export const publishProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessments: API.OperationMethod<PublishProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest, PublishProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse, PublishProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PublishProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest,
  output: PublishProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse,
  errors: [],
}));

/** Appeal an Assessment. */
export interface AppealProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest {
  /** Required. The name of the assessment to appeal. */
  name: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1AppealAssessmentRequest;
}

export const AppealProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1AppealAssessmentRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}/assessments/{assessmentsId}:appeal", hasBody: true }),
  svc,
) as unknown as Schema.Schema<AppealProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest>;

export type AppealProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;
export const AppealProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;

export type AppealProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsError = CommonErrors;

export const appealProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessments: API.OperationMethod<AppealProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest, AppealProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse, AppealProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: AppealProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest,
  output: AppealProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse,
  errors: [],
}));

/** Finalize an Assessment. */
export interface FinalizeProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest {
  /** Required. The name of the assessment to finalize. */
  name: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1FinalizeAssessmentRequest;
}

export const FinalizeProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1FinalizeAssessmentRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}/assessments/{assessmentsId}:finalize", hasBody: true }),
  svc,
) as unknown as Schema.Schema<FinalizeProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest>;

export type FinalizeProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;
export const FinalizeProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse = GoogleCloudContactcenterinsightsV1Assessment;

export type FinalizeProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsError = CommonErrors;

export const finalizeProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessments: API.OperationMethod<FinalizeProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest, FinalizeProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse, FinalizeProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: FinalizeProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsRequest,
  output: FinalizeProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsResponse,
  errors: [],
}));

/** Create Note. */
export interface CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest {
  /** Required. The parent resource of the note. */
  parent: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1Note;
}

export const CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1Note).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}/assessments/{assessmentsId}/notes", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest>;

export type CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesResponse = GoogleCloudContactcenterinsightsV1Note;
export const CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesResponse = GoogleCloudContactcenterinsightsV1Note;

export type CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesError = CommonErrors;

export const createProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotes: API.OperationMethod<CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest, CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesResponse, CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest,
  output: CreateProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesResponse,
  errors: [],
}));

/** List Notes. */
export interface ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest {
  /** Required. The parent resource of the notes. */
  parent: string;
  /** Optional. The maximum number of notes to return in the response. If zero the service will select a default size. A call might return fewer objects than requested. A non-empty `next_page_token` in the response indicates that more data is available. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListNotesResponse`. This value indicates that this is a continuation of a prior `ListNotes` call and that the system should return the next page of data. */
  pageToken?: string;
}

export const ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}/assessments/{assessmentsId}/notes" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest>;

export type ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesResponse = GoogleCloudContactcenterinsightsV1ListNotesResponse;
export const ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesResponse = GoogleCloudContactcenterinsightsV1ListNotesResponse;

export type ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesError = CommonErrors;

export const listProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotes = API.makePaginated(() => ({
  input: ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest,
  output: ListProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Update Note. */
export interface PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest {
  /** Identifier. The resource name of the note. Format: projects/{project}/locations/{location}/conversations/{conversation}/assessments/{assessment}/notes/{note} */
  name: string;
  /** Optional. The list of fields to be updated. If the update_mask is empty, all updateable fields will be updated. Acceptable fields include: * `content` */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1Note;
}

export const PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1Note).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}/assessments/{assessmentsId}/notes/{notesId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest>;

export type PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesResponse = GoogleCloudContactcenterinsightsV1Note;
export const PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesResponse = GoogleCloudContactcenterinsightsV1Note;

export type PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesError = CommonErrors;

export const patchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotes: API.OperationMethod<PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest, PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesResponse, PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest,
  output: PatchProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesResponse,
  errors: [],
}));

/** Deletes a Note. */
export interface DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest {
  /** Required. The name of the note to delete. */
  name: string;
}

export const DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/authorizedViewSets/{authorizedViewSetsId}/authorizedViews/{authorizedViewsId}/conversations/{conversationsId}/assessments/{assessmentsId}/notes/{notesId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest>;

export type DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesError = CommonErrors;

export const deleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotes: API.OperationMethod<DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest, DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesResponse, DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesRequest,
  output: DeleteProjectsLocationsAuthorizedViewSetsAuthorizedViewsConversationsAssessmentsNotesResponse,
  errors: [],
}));

/** Creates a Dashboard. */
export interface CreateProjectsLocationsDashboardsRequest {
  /** Required. The parent resource of the dashboard. */
  parent: string;
  /** Optional. A unique ID for the new Dashboard. This ID will become the final component of the Dashboard's resource name. If no ID is specified, a server-generated ID will be used. This value should be 4-64 characters and must match the regular expression `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`. */
  dashboardId?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1Dashboard;
}

export const CreateProjectsLocationsDashboardsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  dashboardId: Schema.optional(Schema.String).pipe(T.HttpQuery("dashboardId")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1Dashboard).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/dashboards", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsDashboardsRequest>;

export type CreateProjectsLocationsDashboardsResponse = GoogleCloudContactcenterinsightsV1Dashboard;
export const CreateProjectsLocationsDashboardsResponse = GoogleCloudContactcenterinsightsV1Dashboard;

export type CreateProjectsLocationsDashboardsError = CommonErrors;

export const createProjectsLocationsDashboards: API.OperationMethod<CreateProjectsLocationsDashboardsRequest, CreateProjectsLocationsDashboardsResponse, CreateProjectsLocationsDashboardsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsDashboardsRequest,
  output: CreateProjectsLocationsDashboardsResponse,
  errors: [],
}));

/** Gets a Dashboard. */
export interface GetProjectsLocationsDashboardsRequest {
  /** Required. The name of the dashboard to get. */
  name: string;
}

export const GetProjectsLocationsDashboardsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/dashboards/{dashboardsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsDashboardsRequest>;

export type GetProjectsLocationsDashboardsResponse = GoogleCloudContactcenterinsightsV1Dashboard;
export const GetProjectsLocationsDashboardsResponse = GoogleCloudContactcenterinsightsV1Dashboard;

export type GetProjectsLocationsDashboardsError = CommonErrors;

export const getProjectsLocationsDashboards: API.OperationMethod<GetProjectsLocationsDashboardsRequest, GetProjectsLocationsDashboardsResponse, GetProjectsLocationsDashboardsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsDashboardsRequest,
  output: GetProjectsLocationsDashboardsResponse,
  errors: [],
}));

/** Lists Dashboards. */
export interface ListProjectsLocationsDashboardsRequest {
  /** Required. The parent resource of the dashboards. */
  parent: string;
  /** Optional. The maximum number of dashboards to return. The service may return fewer than this value. The default and maximum value is 100. */
  pageSize?: number;
  /** Optional. The value returned by the last `ListDashboardsResponse`. This value indicates that this is a continuation of a prior `ListDashboards` call and that the system should return the next page of data. */
  pageToken?: string;
  /** Optional. The filter expression to filter dashboards listed in the response. */
  filter?: string;
  /** Optional. The order by expression to order dashboards listed in the response. */
  orderBy?: string;
}

export const ListProjectsLocationsDashboardsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/dashboards" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsDashboardsRequest>;

export type ListProjectsLocationsDashboardsResponse = GoogleCloudContactcenterinsightsV1ListDashboardsResponse;
export const ListProjectsLocationsDashboardsResponse = GoogleCloudContactcenterinsightsV1ListDashboardsResponse;

export type ListProjectsLocationsDashboardsError = CommonErrors;

export const listProjectsLocationsDashboards = API.makePaginated(() => ({
  input: ListProjectsLocationsDashboardsRequest,
  output: ListProjectsLocationsDashboardsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Updates a Dashboard. */
export interface PatchProjectsLocationsDashboardsRequest {
  /** Identifier. Dashboard resource name. Format: projects/{project}/locations/{location}/dashboards/{dashboard} */
  name: string;
  /** Optional. List of fields to be updated. All possible fields can be updated by passing `*`, or a subset of the following updateable fields can be provided: * `display_name` * `root_container` * `description` */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1Dashboard;
}

export const PatchProjectsLocationsDashboardsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1Dashboard).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/dashboards/{dashboardsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsDashboardsRequest>;

export type PatchProjectsLocationsDashboardsResponse = GoogleCloudContactcenterinsightsV1Dashboard;
export const PatchProjectsLocationsDashboardsResponse = GoogleCloudContactcenterinsightsV1Dashboard;

export type PatchProjectsLocationsDashboardsError = CommonErrors;

export const patchProjectsLocationsDashboards: API.OperationMethod<PatchProjectsLocationsDashboardsRequest, PatchProjectsLocationsDashboardsResponse, PatchProjectsLocationsDashboardsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsDashboardsRequest,
  output: PatchProjectsLocationsDashboardsResponse,
  errors: [],
}));

/** Deletes a Dashboard. */
export interface DeleteProjectsLocationsDashboardsRequest {
  /** Required. The name of the dashboard to delete. */
  name: string;
}

export const DeleteProjectsLocationsDashboardsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/dashboards/{dashboardsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsDashboardsRequest>;

export type DeleteProjectsLocationsDashboardsResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsDashboardsResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsDashboardsError = CommonErrors;

export const deleteProjectsLocationsDashboards: API.OperationMethod<DeleteProjectsLocationsDashboardsRequest, DeleteProjectsLocationsDashboardsResponse, DeleteProjectsLocationsDashboardsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsDashboardsRequest,
  output: DeleteProjectsLocationsDashboardsResponse,
  errors: [],
}));

/** Creates a Chart. */
export interface CreateProjectsLocationsDashboardsChartsRequest {
  /** Required. The parent resource of the chart. */
  parent: string;
  /** Optional. A unique ID for the new Chart. This ID will become the final component of the Chart's resource name. If no ID is specified, a server-generated ID will be used. This value should be 4-64 characters and must match the regular expression `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`. */
  chartId?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1Chart;
}

export const CreateProjectsLocationsDashboardsChartsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  chartId: Schema.optional(Schema.String).pipe(T.HttpQuery("chartId")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1Chart).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1/projects/{projectsId}/locations/{locationsId}/dashboards/{dashboardsId}/charts", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsDashboardsChartsRequest>;

export type CreateProjectsLocationsDashboardsChartsResponse = GoogleCloudContactcenterinsightsV1Chart;
export const CreateProjectsLocationsDashboardsChartsResponse = GoogleCloudContactcenterinsightsV1Chart;

export type CreateProjectsLocationsDashboardsChartsError = CommonErrors;

export const createProjectsLocationsDashboardsCharts: API.OperationMethod<CreateProjectsLocationsDashboardsChartsRequest, CreateProjectsLocationsDashboardsChartsResponse, CreateProjectsLocationsDashboardsChartsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsDashboardsChartsRequest,
  output: CreateProjectsLocationsDashboardsChartsResponse,
  errors: [],
}));

/** Gets a Chart. */
export interface GetProjectsLocationsDashboardsChartsRequest {
  /** Required. The name of the chart to get. */
  name: string;
}

export const GetProjectsLocationsDashboardsChartsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/dashboards/{dashboardsId}/charts/{chartsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsDashboardsChartsRequest>;

export type GetProjectsLocationsDashboardsChartsResponse = GoogleCloudContactcenterinsightsV1Chart;
export const GetProjectsLocationsDashboardsChartsResponse = GoogleCloudContactcenterinsightsV1Chart;

export type GetProjectsLocationsDashboardsChartsError = CommonErrors;

export const getProjectsLocationsDashboardsCharts: API.OperationMethod<GetProjectsLocationsDashboardsChartsRequest, GetProjectsLocationsDashboardsChartsResponse, GetProjectsLocationsDashboardsChartsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsDashboardsChartsRequest,
  output: GetProjectsLocationsDashboardsChartsResponse,
  errors: [],
}));

/** Lists Charts. */
export interface ListProjectsLocationsDashboardsChartsRequest {
  /** Required. The parent resource of the charts. */
  parent: string;
}

export const ListProjectsLocationsDashboardsChartsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
}).pipe(
  T.Http({ method: "GET", path: "v1/projects/{projectsId}/locations/{locationsId}/dashboards/{dashboardsId}/charts" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsDashboardsChartsRequest>;

export type ListProjectsLocationsDashboardsChartsResponse = GoogleCloudContactcenterinsightsV1ListChartsResponse;
export const ListProjectsLocationsDashboardsChartsResponse = GoogleCloudContactcenterinsightsV1ListChartsResponse;

export type ListProjectsLocationsDashboardsChartsError = CommonErrors;

export const listProjectsLocationsDashboardsCharts: API.OperationMethod<ListProjectsLocationsDashboardsChartsRequest, ListProjectsLocationsDashboardsChartsResponse, ListProjectsLocationsDashboardsChartsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: ListProjectsLocationsDashboardsChartsRequest,
  output: ListProjectsLocationsDashboardsChartsResponse,
  errors: [],
}));

/** Updates a Chart. */
export interface PatchProjectsLocationsDashboardsChartsRequest {
  /** Identifier. Chart resource name. Format: projects/{project}/locations/{location}/dashboards/{dashboard}/charts/{chart} */
  name: string;
  /** Optional. List of fields to be updated. All possible fields can be updated by passing `*`, or a subset of the following updateable fields can be provided: * `display_name` */
  updateMask?: string;
  /** Request body */
  body?: GoogleCloudContactcenterinsightsV1Chart;
}

export const PatchProjectsLocationsDashboardsChartsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(GoogleCloudContactcenterinsightsV1Chart).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1/projects/{projectsId}/locations/{locationsId}/dashboards/{dashboardsId}/charts/{chartsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsDashboardsChartsRequest>;

export type PatchProjectsLocationsDashboardsChartsResponse = GoogleCloudContactcenterinsightsV1Chart;
export const PatchProjectsLocationsDashboardsChartsResponse = GoogleCloudContactcenterinsightsV1Chart;

export type PatchProjectsLocationsDashboardsChartsError = CommonErrors;

export const patchProjectsLocationsDashboardsCharts: API.OperationMethod<PatchProjectsLocationsDashboardsChartsRequest, PatchProjectsLocationsDashboardsChartsResponse, PatchProjectsLocationsDashboardsChartsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsDashboardsChartsRequest,
  output: PatchProjectsLocationsDashboardsChartsResponse,
  errors: [],
}));

/** Deletes a Chart. */
export interface DeleteProjectsLocationsDashboardsChartsRequest {
  /** Required. The name of the chart to delete. */
  name: string;
}

export const DeleteProjectsLocationsDashboardsChartsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1/projects/{projectsId}/locations/{locationsId}/dashboards/{dashboardsId}/charts/{chartsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsDashboardsChartsRequest>;

export type DeleteProjectsLocationsDashboardsChartsResponse = GoogleProtobufEmpty;
export const DeleteProjectsLocationsDashboardsChartsResponse = GoogleProtobufEmpty;

export type DeleteProjectsLocationsDashboardsChartsError = CommonErrors;

export const deleteProjectsLocationsDashboardsCharts: API.OperationMethod<DeleteProjectsLocationsDashboardsChartsRequest, DeleteProjectsLocationsDashboardsChartsResponse, DeleteProjectsLocationsDashboardsChartsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsDashboardsChartsRequest,
  output: DeleteProjectsLocationsDashboardsChartsResponse,
  errors: [],
}));

