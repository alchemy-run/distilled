// ==========================================================================
// AdSense Management API (adsense v2)
// DO NOT EDIT - Generated from GCP Discovery Document
// ==========================================================================

import * as Schema from "effect/Schema";
import * as API from "../client/api.ts";
import * as T from "../traits.ts";
import * as C from "../category.ts";
import type { GCPAuth } from "../auth.ts";
import type { CommonErrors } from "../errors.ts";
import type * as HttpClient from "effect/unstable/http/HttpClient";

// Service metadata
const svc = T.Service({
  name: "adsense",
  version: "v2",
  rootUrl: "https://adsense.googleapis.com/",
  servicePath: "",
});

// ==========================================================================
// Schemas
// ==========================================================================

export interface TimeZone {
  /** IANA Time Zone Database time zone. For example "America/New_York". */
  id?: string;
  /** Optional. IANA Time Zone Database version number. For example "2019a". */
  version?: string;
}

export const TimeZone: Schema.Schema<TimeZone> = Schema.suspend(() => Schema.Struct({
  id: Schema.optional(Schema.String),
  version: Schema.optional(Schema.String),
})).annotate({ identifier: "TimeZone" }) as any as Schema.Schema<TimeZone>;

export interface Account {
  /** Output only. Resource name of the account. Format: accounts/pub-[0-9]+ */
  name?: string;
  /** Output only. Display name of this account. */
  displayName?: string;
  /** Output only. Whether this account is premium. Premium accounts have access to additional spam-related metrics. */
  premium?: boolean;
  /** The account time zone, as used by reporting. For more information, see [changing the time zone of your reports](https://support.google.com/adsense/answer/9830725). */
  timeZone?: TimeZone;
  /** Output only. Creation time of the account. */
  createTime?: string;
  /** Output only. Outstanding tasks that need to be completed as part of the sign-up process for a new account. e.g. "billing-profile-creation", "phone-pin-verification". */
  pendingTasks?: Array<string>;
  /** Output only. State of the account. */
  state?: "STATE_UNSPECIFIED" | "READY" | "NEEDS_ATTENTION" | "CLOSED" | (string & {});
}

export const Account: Schema.Schema<Account> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  premium: Schema.optional(Schema.Boolean),
  timeZone: Schema.optional(TimeZone),
  createTime: Schema.optional(Schema.String),
  pendingTasks: Schema.optional(Schema.Array(Schema.String)),
  state: Schema.optional(Schema.String),
})).annotate({ identifier: "Account" }) as any as Schema.Schema<Account>;

export interface ListAccountsResponse {
  /** The accounts returned in this list response. */
  accounts?: Array<Account>;
  /** Continuation token used to page through accounts. To retrieve the next page of the results, set the next request's "page_token" value to this. */
  nextPageToken?: string;
}

export const ListAccountsResponse: Schema.Schema<ListAccountsResponse> = Schema.suspend(() => Schema.Struct({
  accounts: Schema.optional(Schema.Array(Account)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "ListAccountsResponse" }) as any as Schema.Schema<ListAccountsResponse>;

export interface ListChildAccountsResponse {
  /** The accounts returned in this list response. */
  accounts?: Array<Account>;
  /** Continuation token used to page through accounts. To retrieve the next page of the results, set the next request's "page_token" value to this. */
  nextPageToken?: string;
}

export const ListChildAccountsResponse: Schema.Schema<ListChildAccountsResponse> = Schema.suspend(() => Schema.Struct({
  accounts: Schema.optional(Schema.Array(Account)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "ListChildAccountsResponse" }) as any as Schema.Schema<ListChildAccountsResponse>;

export interface AdBlockingRecoveryTag {
  /** The ad blocking recovery tag. Note that the message generated by the tag can be blocked by an ad blocking extension. If this is not your desired outcome, then you'll need to use it in conjunction with the error protection code. */
  tag?: string;
  /** Error protection code that can be used in conjunction with the tag. It'll display a message to users if an [ad blocking extension blocks their access to your site](https://support.google.com/adsense/answer/11575480). */
  errorProtectionCode?: string;
}

export const AdBlockingRecoveryTag: Schema.Schema<AdBlockingRecoveryTag> = Schema.suspend(() => Schema.Struct({
  tag: Schema.optional(Schema.String),
  errorProtectionCode: Schema.optional(Schema.String),
})).annotate({ identifier: "AdBlockingRecoveryTag" }) as any as Schema.Schema<AdBlockingRecoveryTag>;

export interface AdClient {
  /** Output only. Resource name of the ad client. Format: accounts/{account}/adclients/{adclient} */
  name?: string;
  /** Output only. Unique ID of the ad client as used in the `AD_CLIENT_ID` reporting dimension. Present only if the ad client supports reporting. */
  reportingDimensionId?: string;
  /** Output only. Reporting product code of the ad client. For example, "AFC" for AdSense for Content. Corresponds to the `PRODUCT_CODE` dimension, and present only if the ad client supports reporting. */
  productCode?: string;
  /** Output only. State of the ad client. */
  state?: "STATE_UNSPECIFIED" | "READY" | "GETTING_READY" | "REQUIRES_REVIEW" | (string & {});
}

export const AdClient: Schema.Schema<AdClient> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  reportingDimensionId: Schema.optional(Schema.String),
  productCode: Schema.optional(Schema.String),
  state: Schema.optional(Schema.String),
})).annotate({ identifier: "AdClient" }) as any as Schema.Schema<AdClient>;

export interface ListAdClientsResponse {
  /** The ad clients returned in this list response. */
  adClients?: Array<AdClient>;
  /** Continuation token used to page through ad clients. To retrieve the next page of the results, set the next request's "page_token" value to this. */
  nextPageToken?: string;
}

export const ListAdClientsResponse: Schema.Schema<ListAdClientsResponse> = Schema.suspend(() => Schema.Struct({
  adClients: Schema.optional(Schema.Array(AdClient)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "ListAdClientsResponse" }) as any as Schema.Schema<ListAdClientsResponse>;

export interface AdClientAdCode {
  /** Output only. The AdSense code snippet to add to the head of an HTML page. */
  adCode?: string;
  /** Output only. The AdSense code snippet to add to the head of an AMP page. */
  ampHead?: string;
  /** Output only. The AdSense code snippet to add to the body of an AMP page. */
  ampBody?: string;
}

export const AdClientAdCode: Schema.Schema<AdClientAdCode> = Schema.suspend(() => Schema.Struct({
  adCode: Schema.optional(Schema.String),
  ampHead: Schema.optional(Schema.String),
  ampBody: Schema.optional(Schema.String),
})).annotate({ identifier: "AdClientAdCode" }) as any as Schema.Schema<AdClientAdCode>;

export interface ContentAdsSettings {
  /** Required. Size of the ad unit. e.g. "728x90", "1x3" (for responsive ad units). */
  size?: string;
  /** Required. Type of the ad unit. */
  type?: "TYPE_UNSPECIFIED" | "DISPLAY" | "FEED" | "ARTICLE" | "MATCHED_CONTENT" | "LINK" | (string & {});
}

export const ContentAdsSettings: Schema.Schema<ContentAdsSettings> = Schema.suspend(() => Schema.Struct({
  size: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
})).annotate({ identifier: "ContentAdsSettings" }) as any as Schema.Schema<ContentAdsSettings>;

export interface AdUnit {
  /** Output only. Resource name of the ad unit. Format: accounts/{account}/adclients/{adclient}/adunits/{adunit} */
  name?: string;
  /** Output only. Unique ID of the ad unit as used in the `AD_UNIT_ID` reporting dimension. */
  reportingDimensionId?: string;
  /** Required. Display name of the ad unit, as provided when the ad unit was created. */
  displayName?: string;
  /** Required. State of the ad unit. */
  state?: "STATE_UNSPECIFIED" | "ACTIVE" | "ARCHIVED" | (string & {});
  /** Required. Settings specific to content ads (AFC). */
  contentAdsSettings?: ContentAdsSettings;
}

export const AdUnit: Schema.Schema<AdUnit> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  reportingDimensionId: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  state: Schema.optional(Schema.String),
  contentAdsSettings: Schema.optional(ContentAdsSettings),
})).annotate({ identifier: "AdUnit" }) as any as Schema.Schema<AdUnit>;

export interface ListAdUnitsResponse {
  /** The ad units returned in the list response. */
  adUnits?: Array<AdUnit>;
  /** Continuation token used to page through ad units. To retrieve the next page of the results, set the next request's "page_token" value to this. */
  nextPageToken?: string;
}

export const ListAdUnitsResponse: Schema.Schema<ListAdUnitsResponse> = Schema.suspend(() => Schema.Struct({
  adUnits: Schema.optional(Schema.Array(AdUnit)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "ListAdUnitsResponse" }) as any as Schema.Schema<ListAdUnitsResponse>;

export interface AdUnitAdCode {
  /** Output only. The code snippet to add to the body of an HTML page. */
  adCode?: string;
}

export const AdUnitAdCode: Schema.Schema<AdUnitAdCode> = Schema.suspend(() => Schema.Struct({
  adCode: Schema.optional(Schema.String),
})).annotate({ identifier: "AdUnitAdCode" }) as any as Schema.Schema<AdUnitAdCode>;

export interface ListLinkedAdUnitsResponse {
  /** The ad units returned in the list response. */
  adUnits?: Array<AdUnit>;
  /** Continuation token used to page through ad units. To retrieve the next page of the results, set the next request's "page_token" value to this. */
  nextPageToken?: string;
}

export const ListLinkedAdUnitsResponse: Schema.Schema<ListLinkedAdUnitsResponse> = Schema.suspend(() => Schema.Struct({
  adUnits: Schema.optional(Schema.Array(AdUnit)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "ListLinkedAdUnitsResponse" }) as any as Schema.Schema<ListLinkedAdUnitsResponse>;

export interface Alert {
  /** Output only. Resource name of the alert. Format: accounts/{account}/alerts/{alert} */
  name?: string;
  /** Output only. Severity of this alert. */
  severity?: "SEVERITY_UNSPECIFIED" | "INFO" | "WARNING" | "SEVERE" | (string & {});
  /** Output only. The localized alert message. This may contain HTML markup, such as phrase elements or links. */
  message?: string;
  /** Output only. Type of alert. This identifies the broad type of this alert, and provides a stable machine-readable identifier that will not be translated. For example, "payment-hold". */
  type?: string;
}

export const Alert: Schema.Schema<Alert> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  severity: Schema.optional(Schema.String),
  message: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
})).annotate({ identifier: "Alert" }) as any as Schema.Schema<Alert>;

export interface ListAlertsResponse {
  /** The alerts returned in this list response. */
  alerts?: Array<Alert>;
}

export const ListAlertsResponse: Schema.Schema<ListAlertsResponse> = Schema.suspend(() => Schema.Struct({
  alerts: Schema.optional(Schema.Array(Alert)),
})).annotate({ identifier: "ListAlertsResponse" }) as any as Schema.Schema<ListAlertsResponse>;

export interface CustomChannel {
  /** Output only. Resource name of the custom channel. Format: accounts/{account}/adclients/{adclient}/customchannels/{customchannel} */
  name?: string;
  /** Output only. Unique ID of the custom channel as used in the `CUSTOM_CHANNEL_ID` reporting dimension. */
  reportingDimensionId?: string;
  /** Required. Display name of the custom channel. */
  displayName?: string;
  /** Whether the custom channel is active and collecting data. See https://support.google.com/adsense/answer/10077192. */
  active?: boolean;
}

export const CustomChannel: Schema.Schema<CustomChannel> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  reportingDimensionId: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  active: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "CustomChannel" }) as any as Schema.Schema<CustomChannel>;

export interface ListCustomChannelsResponse {
  /** The custom channels returned in this list response. */
  customChannels?: Array<CustomChannel>;
  /** Continuation token used to page through alerts. To retrieve the next page of the results, set the next request's "page_token" value to this. */
  nextPageToken?: string;
}

export const ListCustomChannelsResponse: Schema.Schema<ListCustomChannelsResponse> = Schema.suspend(() => Schema.Struct({
  customChannels: Schema.optional(Schema.Array(CustomChannel)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "ListCustomChannelsResponse" }) as any as Schema.Schema<ListCustomChannelsResponse>;

export interface ListLinkedCustomChannelsResponse {
  /** The custom channels returned in this list response. */
  customChannels?: Array<CustomChannel>;
  /** Continuation token used to page through alerts. To retrieve the next page of the results, set the next request's "page_token" value to this. */
  nextPageToken?: string;
}

export const ListLinkedCustomChannelsResponse: Schema.Schema<ListLinkedCustomChannelsResponse> = Schema.suspend(() => Schema.Struct({
  customChannels: Schema.optional(Schema.Array(CustomChannel)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "ListLinkedCustomChannelsResponse" }) as any as Schema.Schema<ListLinkedCustomChannelsResponse>;

export interface Empty {
}

export const Empty: Schema.Schema<Empty> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "Empty" }) as any as Schema.Schema<Empty>;

export interface Adsense_Date {
  /** Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year. */
  year?: number;
  /** Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day. */
  month?: number;
  /** Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant. */
  day?: number;
}

export const Adsense_Date: Schema.Schema<Adsense_Date> = Schema.suspend(() => Schema.Struct({
  year: Schema.optional(Schema.Number),
  month: Schema.optional(Schema.Number),
  day: Schema.optional(Schema.Number),
})).annotate({ identifier: "Adsense_Date" }) as any as Schema.Schema<Adsense_Date>;

export interface Payment {
  /** Output only. Resource name of the payment. Format: - accounts/{account}/payments/unpaid for unpaid (current) AdSense earnings. - accounts/{account}/payments/youtube-unpaid for unpaid (current) YouTube earnings. - accounts/{account}/payments/yyyy-MM-dd for paid AdSense earnings. - accounts/{account}/payments/youtube-yyyy-MM-dd for paid YouTube earnings. */
  name?: string;
  /** Output only. For paid earnings, the date that the payment was credited. For unpaid earnings, this field is empty. Payment dates are always returned in the billing timezone (America/Los_Angeles). */
  date?: Adsense_Date;
  /** Output only. The amount of unpaid or paid earnings, as a formatted string, including the currency. E.g. "¥1,235 JPY", "$1,234.57", "£87.65". */
  amount?: string;
}

export const Payment: Schema.Schema<Payment> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  date: Schema.optional(Adsense_Date),
  amount: Schema.optional(Schema.String),
})).annotate({ identifier: "Payment" }) as any as Schema.Schema<Payment>;

export interface ListPaymentsResponse {
  /** The payments returned in this list response. */
  payments?: Array<Payment>;
}

export const ListPaymentsResponse: Schema.Schema<ListPaymentsResponse> = Schema.suspend(() => Schema.Struct({
  payments: Schema.optional(Schema.Array(Payment)),
})).annotate({ identifier: "ListPaymentsResponse" }) as any as Schema.Schema<ListPaymentsResponse>;

export interface PolicyTopic {
  /** Required. The policy topic. For example, "sexual-content" or "ads-obscuring-content"." */
  topic?: string;
  /** Required. Deprecated. Always set to false. */
  mustFix?: boolean;
  /** Optional. The type of policy topic. For example, "POLICY" represents all the policy topics that are related to the Google Publisher Policy (GPP). See https://support.google.com/adsense/answer/15689616. */
  type?: "POLICY_TOPIC_TYPE_UNSPECIFIED" | "POLICY" | "ADVERTISER_PREFERENCE" | "REGULATORY" | (string & {});
}

export const PolicyTopic: Schema.Schema<PolicyTopic> = Schema.suspend(() => Schema.Struct({
  topic: Schema.optional(Schema.String),
  mustFix: Schema.optional(Schema.Boolean),
  type: Schema.optional(Schema.String),
})).annotate({ identifier: "PolicyTopic" }) as any as Schema.Schema<PolicyTopic>;

export interface PolicyIssue {
  /** Required. Resource name of the entity with policy issues. Format: accounts/{account}/policyIssues/{policy_issue} */
  name?: string;
  /** Required. Type of the entity indicating if the entity is a site, site-section, or page. */
  entityType?: "ENTITY_TYPE_UNSPECIFIED" | "SITE" | "SITE_SECTION" | "PAGE" | (string & {});
  /** Required. Hostname/domain of the entity (for example "foo.com" or "www.foo.com"). This _should_ be a bare domain/host name without any protocol. This will be present for all policy issues. */
  site?: string;
  /** Optional. Prefix of the site-section having policy issues (For example "foo.com/bar-section"). This will be present if the `entity_type` is `SITE_SECTION` and will be absent for other entity types. */
  siteSection?: string;
  /** Optional. URI of the page having policy violations (for example "foo.com/bar" or "www.foo.com/bar"). This will be present if the `entity_type` is `PAGE` and will be absent for other entity types. */
  uri?: string;
  /** Optional. List of ad clients associated with the policy issue (either as the primary ad client or an associated host/secondary ad client). In the latter case, this will be an ad client that is not owned by the current account. */
  adClients?: Array<string>;
  /** Required. Unordered list. The policy topics that this entity was found to violate over the past seven days. */
  policyTopics?: Array<PolicyTopic>;
  /** Required. Total number of ad requests affected by the policy violations over the past seven days. */
  adRequestCount?: string;
  /** Required. The most severe action taken on the entity over the past seven days. */
  action?: "ENFORCEMENT_ACTION_UNSPECIFIED" | "WARNED" | "AD_SERVING_RESTRICTED" | "AD_SERVING_DISABLED" | "AD_SERVED_WITH_CLICK_CONFIRMATION" | "AD_PERSONALIZATION_RESTRICTED" | (string & {});
  /** Required. The date (in the America/Los_Angeles timezone) when policy violations were first detected on the entity. */
  firstDetectedDate?: Adsense_Date;
  /** Required. The date (in the America/Los_Angeles timezone) when policy violations were last detected on the entity. */
  lastDetectedDate?: Adsense_Date;
  /** Optional. The date (in the America/Los_Angeles timezone) when the entity will have ad serving demand restricted or ad serving disabled. This is present only for issues with a `WARNED` enforcement action. See https://support.google.com/adsense/answer/11066888. */
  warningEscalationDate?: Adsense_Date;
}

export const PolicyIssue: Schema.Schema<PolicyIssue> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  entityType: Schema.optional(Schema.String),
  site: Schema.optional(Schema.String),
  siteSection: Schema.optional(Schema.String),
  uri: Schema.optional(Schema.String),
  adClients: Schema.optional(Schema.Array(Schema.String)),
  policyTopics: Schema.optional(Schema.Array(PolicyTopic)),
  adRequestCount: Schema.optional(Schema.String),
  action: Schema.optional(Schema.String),
  firstDetectedDate: Schema.optional(Adsense_Date),
  lastDetectedDate: Schema.optional(Adsense_Date),
  warningEscalationDate: Schema.optional(Adsense_Date),
})).annotate({ identifier: "PolicyIssue" }) as any as Schema.Schema<PolicyIssue>;

export interface ListPolicyIssuesResponse {
  /** The policy issues returned in the list response. */
  policyIssues?: Array<PolicyIssue>;
  /** Continuation token used to page through policy issues. To retrieve the next page of the results, set the next request's "page_token" value to this. */
  nextPageToken?: string;
}

export const ListPolicyIssuesResponse: Schema.Schema<ListPolicyIssuesResponse> = Schema.suspend(() => Schema.Struct({
  policyIssues: Schema.optional(Schema.Array(PolicyIssue)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "ListPolicyIssuesResponse" }) as any as Schema.Schema<ListPolicyIssuesResponse>;

export interface Header {
  /** Required. Name of the header. */
  name?: string;
  /** Required. Type of the header. */
  type?: "HEADER_TYPE_UNSPECIFIED" | "DIMENSION" | "METRIC_TALLY" | "METRIC_RATIO" | "METRIC_CURRENCY" | "METRIC_MILLISECONDS" | "METRIC_DECIMAL" | (string & {});
  /** The [ISO-4217 currency code](https://en.wikipedia.org/wiki/ISO_4217) of this column. Only present if the header type is METRIC_CURRENCY. */
  currencyCode?: string;
}

export const Header: Schema.Schema<Header> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  currencyCode: Schema.optional(Schema.String),
})).annotate({ identifier: "Header" }) as any as Schema.Schema<Header>;

export interface Cell {
  /** Value in the cell. The dimension cells contain strings, and the metric cells contain numbers. */
  value?: string;
}

export const Cell: Schema.Schema<Cell> = Schema.suspend(() => Schema.Struct({
  value: Schema.optional(Schema.String),
})).annotate({ identifier: "Cell" }) as any as Schema.Schema<Cell>;

export interface Row {
  /** Cells in the row. */
  cells?: Array<Cell>;
}

export const Row: Schema.Schema<Row> = Schema.suspend(() => Schema.Struct({
  cells: Schema.optional(Schema.Array(Cell)),
})).annotate({ identifier: "Row" }) as any as Schema.Schema<Row>;

export interface ReportResult {
  /** The total number of rows matched by the report request. */
  totalMatchedRows?: string;
  /** The header information; one for each dimension in the request, followed by one for each metric in the request. */
  headers?: Array<Header>;
  /** The output rows of the report. Each row is a list of cells; one for each dimension in the request, followed by one for each metric in the request. */
  rows?: Array<Row>;
  /** The totals of the report. This is the same length as any other row in the report; cells corresponding to dimension columns are empty. */
  totals?: Row;
  /** The averages of the report. This is the same length as any other row in the report; cells corresponding to dimension columns are empty. */
  averages?: Row;
  /** Any warnings associated with generation of the report. These warnings are always returned in English. */
  warnings?: Array<string>;
  /** Required. Start date of the range (inclusive). */
  startDate?: Adsense_Date;
  /** Required. End date of the range (inclusive). */
  endDate?: Adsense_Date;
}

export const ReportResult: Schema.Schema<ReportResult> = Schema.suspend(() => Schema.Struct({
  totalMatchedRows: Schema.optional(Schema.String),
  headers: Schema.optional(Schema.Array(Header)),
  rows: Schema.optional(Schema.Array(Row)),
  totals: Schema.optional(Row),
  averages: Schema.optional(Row),
  warnings: Schema.optional(Schema.Array(Schema.String)),
  startDate: Schema.optional(Adsense_Date),
  endDate: Schema.optional(Adsense_Date),
})).annotate({ identifier: "ReportResult" }) as any as Schema.Schema<ReportResult>;

export interface HttpBody {
  /** The HTTP Content-Type header value specifying the content type of the body. */
  contentType?: string;
  /** The HTTP request/response body as raw binary. */
  data?: string;
  /** Application specific response metadata. Must be set in the first response for streaming APIs. */
  extensions?: Array<Record<string, unknown>>;
}

export const HttpBody: Schema.Schema<HttpBody> = Schema.suspend(() => Schema.Struct({
  contentType: Schema.optional(Schema.String),
  data: Schema.optional(Schema.String),
  extensions: Schema.optional(Schema.Array(Schema.Record(Schema.String, Schema.Unknown))),
})).annotate({ identifier: "HttpBody" }) as any as Schema.Schema<HttpBody>;

export interface SavedReport {
  /** Output only. Resource name of the report. Format: accounts/{account}/reports/{report} */
  name?: string;
  /** Report title as specified by publisher. */
  title?: string;
}

export const SavedReport: Schema.Schema<SavedReport> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  title: Schema.optional(Schema.String),
})).annotate({ identifier: "SavedReport" }) as any as Schema.Schema<SavedReport>;

export interface ListSavedReportsResponse {
  /** The reports returned in this list response. */
  savedReports?: Array<SavedReport>;
  /** Continuation token used to page through reports. To retrieve the next page of the results, set the next request's "page_token" value to this. */
  nextPageToken?: string;
}

export const ListSavedReportsResponse: Schema.Schema<ListSavedReportsResponse> = Schema.suspend(() => Schema.Struct({
  savedReports: Schema.optional(Schema.Array(SavedReport)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "ListSavedReportsResponse" }) as any as Schema.Schema<ListSavedReportsResponse>;

export interface Site {
  /** Output only. Resource name of a site. Format: accounts/{account}/sites/{site} */
  name?: string;
  /** Output only. Unique ID of the site as used in the `OWNED_SITE_ID` reporting dimension. */
  reportingDimensionId?: string;
  /** Domain (or subdomain) of the site, e.g. "example.com" or "www.example.com". This is used in the `OWNED_SITE_DOMAIN_NAME` reporting dimension. */
  domain?: string;
  /** Output only. State of a site. */
  state?: "STATE_UNSPECIFIED" | "REQUIRES_REVIEW" | "GETTING_READY" | "READY" | "NEEDS_ATTENTION" | (string & {});
  /** Whether auto ads is turned on for the site. */
  autoAdsEnabled?: boolean;
}

export const Site: Schema.Schema<Site> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  reportingDimensionId: Schema.optional(Schema.String),
  domain: Schema.optional(Schema.String),
  state: Schema.optional(Schema.String),
  autoAdsEnabled: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "Site" }) as any as Schema.Schema<Site>;

export interface ListSitesResponse {
  /** The sites returned in this list response. */
  sites?: Array<Site>;
  /** Continuation token used to page through sites. To retrieve the next page of the results, set the next request's "page_token" value to this. */
  nextPageToken?: string;
}

export const ListSitesResponse: Schema.Schema<ListSitesResponse> = Schema.suspend(() => Schema.Struct({
  sites: Schema.optional(Schema.Array(Site)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "ListSitesResponse" }) as any as Schema.Schema<ListSitesResponse>;

export interface UrlChannel {
  /** Output only. Resource name of the URL channel. Format: accounts/{account}/adclients/{adclient}/urlchannels/{urlchannel} */
  name?: string;
  /** Output only. Unique ID of the custom channel as used in the `URL_CHANNEL_ID` reporting dimension. */
  reportingDimensionId?: string;
  /** URI pattern of the channel. Does not include "http://" or "https://". Example: www.example.com/home */
  uriPattern?: string;
}

export const UrlChannel: Schema.Schema<UrlChannel> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
  reportingDimensionId: Schema.optional(Schema.String),
  uriPattern: Schema.optional(Schema.String),
})).annotate({ identifier: "UrlChannel" }) as any as Schema.Schema<UrlChannel>;

export interface ListUrlChannelsResponse {
  /** The url channels returned in this list response. */
  urlChannels?: Array<UrlChannel>;
  /** Continuation token used to page through url channels. To retrieve the next page of the results, set the next request's "page_token" value to this. */
  nextPageToken?: string;
}

export const ListUrlChannelsResponse: Schema.Schema<ListUrlChannelsResponse> = Schema.suspend(() => Schema.Struct({
  urlChannels: Schema.optional(Schema.Array(UrlChannel)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "ListUrlChannelsResponse" }) as any as Schema.Schema<ListUrlChannelsResponse>;

// ==========================================================================
// Operations
// ==========================================================================

/** Gets information about the selected AdSense account. */
export interface GetAccountsRequest {
  /** Required. Account to get information about. Format: accounts/{account} */
  name: string;
}

export const GetAccountsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}" }),
  svc,
) as unknown as Schema.Schema<GetAccountsRequest>;

export type GetAccountsResponse = Account;
export const GetAccountsResponse = Account;

export type GetAccountsError = CommonErrors;

export const getAccounts: API.OperationMethod<GetAccountsRequest, GetAccountsResponse, GetAccountsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetAccountsRequest,
  output: GetAccountsResponse,
  errors: [],
}));

/** Lists all accounts available to this user. */
export interface ListAccountsRequest {
  /** The maximum number of accounts to include in the response, used for paging. If unspecified, at most 10000 accounts will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000. */
  pageSize?: number;
  /** A page token, received from a previous `ListAccounts` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListAccounts` must match the call that provided the page token. */
  pageToken?: string;
}

export const ListAccountsRequest = Schema.Struct({
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts" }),
  svc,
) as unknown as Schema.Schema<ListAccountsRequest>;

export type ListAccountsResponse_Op = ListAccountsResponse;
export const ListAccountsResponse_Op = ListAccountsResponse;

export type ListAccountsError = CommonErrors;

export const listAccounts = API.makePaginated(() => ({
  input: ListAccountsRequest,
  output: ListAccountsResponse_Op,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Lists all accounts directly managed by the given AdSense account. */
export interface ListChildAccountsAccountsRequest {
  /** Required. The parent account, which owns the child accounts. Format: accounts/{account} */
  parent: string;
  /** The maximum number of accounts to include in the response, used for paging. If unspecified, at most 10000 accounts will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000. */
  pageSize?: number;
  /** A page token, received from a previous `ListChildAccounts` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListChildAccounts` must match the call that provided the page token. */
  pageToken?: string;
}

export const ListChildAccountsAccountsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}:listChildAccounts" }),
  svc,
) as unknown as Schema.Schema<ListChildAccountsAccountsRequest>;

export type ListChildAccountsAccountsResponse = ListChildAccountsResponse;
export const ListChildAccountsAccountsResponse = ListChildAccountsResponse;

export type ListChildAccountsAccountsError = CommonErrors;

export const listChildAccountsAccounts = API.makePaginated(() => ({
  input: ListChildAccountsAccountsRequest,
  output: ListChildAccountsAccountsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Gets the ad blocking recovery tag of an account. */
export interface GetAdBlockingRecoveryTagAccountsRequest {
  /** Required. The name of the account to get the tag for. Format: accounts/{account} */
  name: string;
}

export const GetAdBlockingRecoveryTagAccountsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/adBlockingRecoveryTag" }),
  svc,
) as unknown as Schema.Schema<GetAdBlockingRecoveryTagAccountsRequest>;

export type GetAdBlockingRecoveryTagAccountsResponse = AdBlockingRecoveryTag;
export const GetAdBlockingRecoveryTagAccountsResponse = AdBlockingRecoveryTag;

export type GetAdBlockingRecoveryTagAccountsError = CommonErrors;

export const getAdBlockingRecoveryTagAccounts: API.OperationMethod<GetAdBlockingRecoveryTagAccountsRequest, GetAdBlockingRecoveryTagAccountsResponse, GetAdBlockingRecoveryTagAccountsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetAdBlockingRecoveryTagAccountsRequest,
  output: GetAdBlockingRecoveryTagAccountsResponse,
  errors: [],
}));

/** Lists all the ad clients available in an account. */
export interface ListAccountsAdclientsRequest {
  /** Required. The account which owns the collection of ad clients. Format: accounts/{account} */
  parent: string;
  /** The maximum number of ad clients to include in the response, used for paging. If unspecified, at most 10000 ad clients will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000. */
  pageSize?: number;
  /** A page token, received from a previous `ListAdClients` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListAdClients` must match the call that provided the page token. */
  pageToken?: string;
}

export const ListAccountsAdclientsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/adclients" }),
  svc,
) as unknown as Schema.Schema<ListAccountsAdclientsRequest>;

export type ListAccountsAdclientsResponse = ListAdClientsResponse;
export const ListAccountsAdclientsResponse = ListAdClientsResponse;

export type ListAccountsAdclientsError = CommonErrors;

export const listAccountsAdclients = API.makePaginated(() => ({
  input: ListAccountsAdclientsRequest,
  output: ListAccountsAdclientsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Gets the ad client from the given resource name. */
export interface GetAccountsAdclientsRequest {
  /** Required. The name of the ad client to retrieve. Format: accounts/{account}/adclients/{adclient} */
  name: string;
}

export const GetAccountsAdclientsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/adclients/{adclientsId}" }),
  svc,
) as unknown as Schema.Schema<GetAccountsAdclientsRequest>;

export type GetAccountsAdclientsResponse = AdClient;
export const GetAccountsAdclientsResponse = AdClient;

export type GetAccountsAdclientsError = CommonErrors;

export const getAccountsAdclients: API.OperationMethod<GetAccountsAdclientsRequest, GetAccountsAdclientsResponse, GetAccountsAdclientsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetAccountsAdclientsRequest,
  output: GetAccountsAdclientsResponse,
  errors: [],
}));

/** Gets the AdSense code for a given ad client. This returns what was previously known as the 'auto ad code'. This is only supported for ad clients with a product_code of AFC. For more information, see [About the AdSense code](https://support.google.com/adsense/answer/9274634). */
export interface GetAdcodeAccountsAdclientsRequest {
  /** Required. Name of the ad client for which to get the adcode. Format: accounts/{account}/adclients/{adclient} */
  name: string;
}

export const GetAdcodeAccountsAdclientsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/adclients/{adclientsId}/adcode" }),
  svc,
) as unknown as Schema.Schema<GetAdcodeAccountsAdclientsRequest>;

export type GetAdcodeAccountsAdclientsResponse = AdClientAdCode;
export const GetAdcodeAccountsAdclientsResponse = AdClientAdCode;

export type GetAdcodeAccountsAdclientsError = CommonErrors;

export const getAdcodeAccountsAdclients: API.OperationMethod<GetAdcodeAccountsAdclientsRequest, GetAdcodeAccountsAdclientsResponse, GetAdcodeAccountsAdclientsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetAdcodeAccountsAdclientsRequest,
  output: GetAdcodeAccountsAdclientsResponse,
  errors: [],
}));

/** Gets an ad unit from a specified account and ad client. */
export interface GetAccountsAdclientsAdunitsRequest {
  /** Required. AdUnit to get information about. Format: accounts/{account}/adclients/{adclient}/adunits/{adunit} */
  name: string;
}

export const GetAccountsAdclientsAdunitsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/adclients/{adclientsId}/adunits/{adunitsId}" }),
  svc,
) as unknown as Schema.Schema<GetAccountsAdclientsAdunitsRequest>;

export type GetAccountsAdclientsAdunitsResponse = AdUnit;
export const GetAccountsAdclientsAdunitsResponse = AdUnit;

export type GetAccountsAdclientsAdunitsError = CommonErrors;

export const getAccountsAdclientsAdunits: API.OperationMethod<GetAccountsAdclientsAdunitsRequest, GetAccountsAdclientsAdunitsResponse, GetAccountsAdclientsAdunitsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetAccountsAdclientsAdunitsRequest,
  output: GetAccountsAdclientsAdunitsResponse,
  errors: [],
}));

/** Lists all ad units under a specified account and ad client. */
export interface ListAccountsAdclientsAdunitsRequest {
  /** Required. The ad client which owns the collection of ad units. Format: accounts/{account}/adclients/{adclient} */
  parent: string;
  /** The maximum number of ad units to include in the response, used for paging. If unspecified, at most 10000 ad units will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000. */
  pageSize?: number;
  /** A page token, received from a previous `ListAdUnits` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListAdUnits` must match the call that provided the page token. */
  pageToken?: string;
}

export const ListAccountsAdclientsAdunitsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/adclients/{adclientsId}/adunits" }),
  svc,
) as unknown as Schema.Schema<ListAccountsAdclientsAdunitsRequest>;

export type ListAccountsAdclientsAdunitsResponse = ListAdUnitsResponse;
export const ListAccountsAdclientsAdunitsResponse = ListAdUnitsResponse;

export type ListAccountsAdclientsAdunitsError = CommonErrors;

export const listAccountsAdclientsAdunits = API.makePaginated(() => ({
  input: ListAccountsAdclientsAdunitsRequest,
  output: ListAccountsAdclientsAdunitsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Gets the ad unit code for a given ad unit. For more information, see [About the AdSense code](https://support.google.com/adsense/answer/9274634) and [Where to place the ad code in your HTML](https://support.google.com/adsense/answer/9190028). */
export interface GetAdcodeAccountsAdclientsAdunitsRequest {
  /** Required. Name of the adunit for which to get the adcode. Format: accounts/{account}/adclients/{adclient}/adunits/{adunit} */
  name: string;
}

export const GetAdcodeAccountsAdclientsAdunitsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/adclients/{adclientsId}/adunits/{adunitsId}/adcode" }),
  svc,
) as unknown as Schema.Schema<GetAdcodeAccountsAdclientsAdunitsRequest>;

export type GetAdcodeAccountsAdclientsAdunitsResponse = AdUnitAdCode;
export const GetAdcodeAccountsAdclientsAdunitsResponse = AdUnitAdCode;

export type GetAdcodeAccountsAdclientsAdunitsError = CommonErrors;

export const getAdcodeAccountsAdclientsAdunits: API.OperationMethod<GetAdcodeAccountsAdclientsAdunitsRequest, GetAdcodeAccountsAdclientsAdunitsResponse, GetAdcodeAccountsAdclientsAdunitsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetAdcodeAccountsAdclientsAdunitsRequest,
  output: GetAdcodeAccountsAdclientsAdunitsResponse,
  errors: [],
}));

/** Creates an ad unit. This method can be called only by a restricted set of projects, which are usually owned by [AdSense for Platforms](https://developers.google.com/adsense/platforms/) publishers. Contact your account manager if you need to use this method. Note that ad units can only be created for ad clients with an "AFC" product code. For more info see the [AdClient resource](/adsense/management/reference/rest/v2/accounts.adclients). For now, this method can only be used to create `DISPLAY` ad units. See: https://support.google.com/adsense/answer/9183566 */
export interface CreateAccountsAdclientsAdunitsRequest {
  /** Required. Ad client to create an ad unit under. Format: accounts/{account}/adclients/{adclient} */
  parent: string;
  /** Request body */
  body?: AdUnit;
}

export const CreateAccountsAdclientsAdunitsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(AdUnit).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v2/accounts/{accountsId}/adclients/{adclientsId}/adunits", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateAccountsAdclientsAdunitsRequest>;

export type CreateAccountsAdclientsAdunitsResponse = AdUnit;
export const CreateAccountsAdclientsAdunitsResponse = AdUnit;

export type CreateAccountsAdclientsAdunitsError = CommonErrors;

export const createAccountsAdclientsAdunits: API.OperationMethod<CreateAccountsAdclientsAdunitsRequest, CreateAccountsAdclientsAdunitsResponse, CreateAccountsAdclientsAdunitsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateAccountsAdclientsAdunitsRequest,
  output: CreateAccountsAdclientsAdunitsResponse,
  errors: [],
}));

/** Updates an ad unit. This method can be called only by a restricted set of projects, which are usually owned by [AdSense for Platforms](https://developers.google.com/adsense/platforms/) publishers. Contact your account manager if you need to use this method. For now, this method can only be used to update `DISPLAY` ad units. See: https://support.google.com/adsense/answer/9183566 */
export interface PatchAccountsAdclientsAdunitsRequest {
  /** Output only. Resource name of the ad unit. Format: accounts/{account}/adclients/{adclient}/adunits/{adunit} */
  name: string;
  /** The list of fields to update. If empty, a full update is performed. */
  updateMask?: string;
  /** Request body */
  body?: AdUnit;
}

export const PatchAccountsAdclientsAdunitsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(AdUnit).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v2/accounts/{accountsId}/adclients/{adclientsId}/adunits/{adunitsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchAccountsAdclientsAdunitsRequest>;

export type PatchAccountsAdclientsAdunitsResponse = AdUnit;
export const PatchAccountsAdclientsAdunitsResponse = AdUnit;

export type PatchAccountsAdclientsAdunitsError = CommonErrors;

export const patchAccountsAdclientsAdunits: API.OperationMethod<PatchAccountsAdclientsAdunitsRequest, PatchAccountsAdclientsAdunitsResponse, PatchAccountsAdclientsAdunitsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchAccountsAdclientsAdunitsRequest,
  output: PatchAccountsAdclientsAdunitsResponse,
  errors: [],
}));

/** Lists all the custom channels available for an ad unit. */
export interface ListLinkedCustomChannelsAccountsAdclientsAdunitsRequest {
  /** Required. The ad unit which owns the collection of custom channels. Format: accounts/{account}/adclients/{adclient}/adunits/{adunit} */
  parent: string;
  /** The maximum number of custom channels to include in the response, used for paging. If unspecified, at most 10000 custom channels will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000. */
  pageSize?: number;
  /** A page token, received from a previous `ListLinkedCustomChannels` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListLinkedCustomChannels` must match the call that provided the page token. */
  pageToken?: string;
}

export const ListLinkedCustomChannelsAccountsAdclientsAdunitsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/adclients/{adclientsId}/adunits/{adunitsId}:listLinkedCustomChannels" }),
  svc,
) as unknown as Schema.Schema<ListLinkedCustomChannelsAccountsAdclientsAdunitsRequest>;

export type ListLinkedCustomChannelsAccountsAdclientsAdunitsResponse = ListLinkedCustomChannelsResponse;
export const ListLinkedCustomChannelsAccountsAdclientsAdunitsResponse = ListLinkedCustomChannelsResponse;

export type ListLinkedCustomChannelsAccountsAdclientsAdunitsError = CommonErrors;

export const listLinkedCustomChannelsAccountsAdclientsAdunits = API.makePaginated(() => ({
  input: ListLinkedCustomChannelsAccountsAdclientsAdunitsRequest,
  output: ListLinkedCustomChannelsAccountsAdclientsAdunitsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Lists all the ad units available for a custom channel. */
export interface ListLinkedAdUnitsAccountsAdclientsCustomchannelsRequest {
  /** Required. The custom channel which owns the collection of ad units. Format: accounts/{account}/adclients/{adclient}/customchannels/{customchannel} */
  parent: string;
  /** The maximum number of ad units to include in the response, used for paging. If unspecified, at most 10000 ad units will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000. */
  pageSize?: number;
  /** A page token, received from a previous `ListLinkedAdUnits` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListLinkedAdUnits` must match the call that provided the page token. */
  pageToken?: string;
}

export const ListLinkedAdUnitsAccountsAdclientsCustomchannelsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/adclients/{adclientsId}/customchannels/{customchannelsId}:listLinkedAdUnits" }),
  svc,
) as unknown as Schema.Schema<ListLinkedAdUnitsAccountsAdclientsCustomchannelsRequest>;

export type ListLinkedAdUnitsAccountsAdclientsCustomchannelsResponse = ListLinkedAdUnitsResponse;
export const ListLinkedAdUnitsAccountsAdclientsCustomchannelsResponse = ListLinkedAdUnitsResponse;

export type ListLinkedAdUnitsAccountsAdclientsCustomchannelsError = CommonErrors;

export const listLinkedAdUnitsAccountsAdclientsCustomchannels = API.makePaginated(() => ({
  input: ListLinkedAdUnitsAccountsAdclientsCustomchannelsRequest,
  output: ListLinkedAdUnitsAccountsAdclientsCustomchannelsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Gets information about the selected custom channel. */
export interface GetAccountsAdclientsCustomchannelsRequest {
  /** Required. Name of the custom channel. Format: accounts/{account}/adclients/{adclient}/customchannels/{customchannel} */
  name: string;
}

export const GetAccountsAdclientsCustomchannelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/adclients/{adclientsId}/customchannels/{customchannelsId}" }),
  svc,
) as unknown as Schema.Schema<GetAccountsAdclientsCustomchannelsRequest>;

export type GetAccountsAdclientsCustomchannelsResponse = CustomChannel;
export const GetAccountsAdclientsCustomchannelsResponse = CustomChannel;

export type GetAccountsAdclientsCustomchannelsError = CommonErrors;

export const getAccountsAdclientsCustomchannels: API.OperationMethod<GetAccountsAdclientsCustomchannelsRequest, GetAccountsAdclientsCustomchannelsResponse, GetAccountsAdclientsCustomchannelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetAccountsAdclientsCustomchannelsRequest,
  output: GetAccountsAdclientsCustomchannelsResponse,
  errors: [],
}));

/** Lists all the custom channels available in an ad client. */
export interface ListAccountsAdclientsCustomchannelsRequest {
  /** Required. The ad client which owns the collection of custom channels. Format: accounts/{account}/adclients/{adclient} */
  parent: string;
  /** The maximum number of custom channels to include in the response, used for paging. If unspecified, at most 10000 custom channels will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000. */
  pageSize?: number;
  /** A page token, received from a previous `ListCustomChannels` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListCustomChannels` must match the call that provided the page token. */
  pageToken?: string;
}

export const ListAccountsAdclientsCustomchannelsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/adclients/{adclientsId}/customchannels" }),
  svc,
) as unknown as Schema.Schema<ListAccountsAdclientsCustomchannelsRequest>;

export type ListAccountsAdclientsCustomchannelsResponse = ListCustomChannelsResponse;
export const ListAccountsAdclientsCustomchannelsResponse = ListCustomChannelsResponse;

export type ListAccountsAdclientsCustomchannelsError = CommonErrors;

export const listAccountsAdclientsCustomchannels = API.makePaginated(() => ({
  input: ListAccountsAdclientsCustomchannelsRequest,
  output: ListAccountsAdclientsCustomchannelsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Creates a custom channel. This method can be called only by a restricted set of projects, which are usually owned by [AdSense for Platforms](https://developers.google.com/adsense/platforms/) publishers. Contact your account manager if you need to use this method. */
export interface CreateAccountsAdclientsCustomchannelsRequest {
  /** Required. The ad client to create a custom channel under. Format: accounts/{account}/adclients/{adclient} */
  parent: string;
  /** Request body */
  body?: CustomChannel;
}

export const CreateAccountsAdclientsCustomchannelsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(CustomChannel).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v2/accounts/{accountsId}/adclients/{adclientsId}/customchannels", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateAccountsAdclientsCustomchannelsRequest>;

export type CreateAccountsAdclientsCustomchannelsResponse = CustomChannel;
export const CreateAccountsAdclientsCustomchannelsResponse = CustomChannel;

export type CreateAccountsAdclientsCustomchannelsError = CommonErrors;

export const createAccountsAdclientsCustomchannels: API.OperationMethod<CreateAccountsAdclientsCustomchannelsRequest, CreateAccountsAdclientsCustomchannelsResponse, CreateAccountsAdclientsCustomchannelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateAccountsAdclientsCustomchannelsRequest,
  output: CreateAccountsAdclientsCustomchannelsResponse,
  errors: [],
}));

/** Updates a custom channel. This method can be called only by a restricted set of projects, which are usually owned by [AdSense for Platforms](https://developers.google.com/adsense/platforms/) publishers. Contact your account manager if you need to use this method. */
export interface PatchAccountsAdclientsCustomchannelsRequest {
  /** Output only. Resource name of the custom channel. Format: accounts/{account}/adclients/{adclient}/customchannels/{customchannel} */
  name: string;
  /** The list of fields to update. If empty, a full update is performed. */
  updateMask?: string;
  /** Request body */
  body?: CustomChannel;
}

export const PatchAccountsAdclientsCustomchannelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(CustomChannel).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v2/accounts/{accountsId}/adclients/{adclientsId}/customchannels/{customchannelsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchAccountsAdclientsCustomchannelsRequest>;

export type PatchAccountsAdclientsCustomchannelsResponse = CustomChannel;
export const PatchAccountsAdclientsCustomchannelsResponse = CustomChannel;

export type PatchAccountsAdclientsCustomchannelsError = CommonErrors;

export const patchAccountsAdclientsCustomchannels: API.OperationMethod<PatchAccountsAdclientsCustomchannelsRequest, PatchAccountsAdclientsCustomchannelsResponse, PatchAccountsAdclientsCustomchannelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchAccountsAdclientsCustomchannelsRequest,
  output: PatchAccountsAdclientsCustomchannelsResponse,
  errors: [],
}));

/** Deletes a custom channel. This method can be called only by a restricted set of projects, which are usually owned by [AdSense for Platforms](https://developers.google.com/adsense/platforms/) publishers. Contact your account manager if you need to use this method. */
export interface DeleteAccountsAdclientsCustomchannelsRequest {
  /** Required. Name of the custom channel to delete. Format: accounts/{account}/adclients/{adclient}/customchannels/{customchannel} */
  name: string;
}

export const DeleteAccountsAdclientsCustomchannelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v2/accounts/{accountsId}/adclients/{adclientsId}/customchannels/{customchannelsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteAccountsAdclientsCustomchannelsRequest>;

export type DeleteAccountsAdclientsCustomchannelsResponse = Empty;
export const DeleteAccountsAdclientsCustomchannelsResponse = Empty;

export type DeleteAccountsAdclientsCustomchannelsError = CommonErrors;

export const deleteAccountsAdclientsCustomchannels: API.OperationMethod<DeleteAccountsAdclientsCustomchannelsRequest, DeleteAccountsAdclientsCustomchannelsResponse, DeleteAccountsAdclientsCustomchannelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteAccountsAdclientsCustomchannelsRequest,
  output: DeleteAccountsAdclientsCustomchannelsResponse,
  errors: [],
}));

/** Gets information about the selected url channel. */
export interface GetAccountsAdclientsUrlchannelsRequest {
  /** Required. The name of the url channel to retrieve. Format: accounts/{account}/adclients/{adclient}/urlchannels/{urlchannel} */
  name: string;
}

export const GetAccountsAdclientsUrlchannelsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/adclients/{adclientsId}/urlchannels/{urlchannelsId}" }),
  svc,
) as unknown as Schema.Schema<GetAccountsAdclientsUrlchannelsRequest>;

export type GetAccountsAdclientsUrlchannelsResponse = UrlChannel;
export const GetAccountsAdclientsUrlchannelsResponse = UrlChannel;

export type GetAccountsAdclientsUrlchannelsError = CommonErrors;

export const getAccountsAdclientsUrlchannels: API.OperationMethod<GetAccountsAdclientsUrlchannelsRequest, GetAccountsAdclientsUrlchannelsResponse, GetAccountsAdclientsUrlchannelsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetAccountsAdclientsUrlchannelsRequest,
  output: GetAccountsAdclientsUrlchannelsResponse,
  errors: [],
}));

/** Lists active url channels. */
export interface ListAccountsAdclientsUrlchannelsRequest {
  /** Required. The ad client which owns the collection of url channels. Format: accounts/{account}/adclients/{adclient} */
  parent: string;
  /** The maximum number of url channels to include in the response, used for paging. If unspecified, at most 10000 url channels will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000. */
  pageSize?: number;
  /** A page token, received from a previous `ListUrlChannels` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListUrlChannels` must match the call that provided the page token. */
  pageToken?: string;
}

export const ListAccountsAdclientsUrlchannelsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/adclients/{adclientsId}/urlchannels" }),
  svc,
) as unknown as Schema.Schema<ListAccountsAdclientsUrlchannelsRequest>;

export type ListAccountsAdclientsUrlchannelsResponse = ListUrlChannelsResponse;
export const ListAccountsAdclientsUrlchannelsResponse = ListUrlChannelsResponse;

export type ListAccountsAdclientsUrlchannelsError = CommonErrors;

export const listAccountsAdclientsUrlchannels = API.makePaginated(() => ({
  input: ListAccountsAdclientsUrlchannelsRequest,
  output: ListAccountsAdclientsUrlchannelsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Lists all the alerts available in an account. */
export interface ListAccountsAlertsRequest {
  /** Required. The account which owns the collection of alerts. Format: accounts/{account} */
  parent: string;
  /** The language to use for translating alert messages. If unspecified, this defaults to the user's display language. If the given language is not supported, alerts will be returned in English. The language is specified as an [IETF BCP-47 language code](https://en.wikipedia.org/wiki/IETF_language_tag). */
  languageCode?: string;
}

export const ListAccountsAlertsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  languageCode: Schema.optional(Schema.String).pipe(T.HttpQuery("languageCode")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/alerts" }),
  svc,
) as unknown as Schema.Schema<ListAccountsAlertsRequest>;

export type ListAccountsAlertsResponse = ListAlertsResponse;
export const ListAccountsAlertsResponse = ListAlertsResponse;

export type ListAccountsAlertsError = CommonErrors;

export const listAccountsAlerts: API.OperationMethod<ListAccountsAlertsRequest, ListAccountsAlertsResponse, ListAccountsAlertsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: ListAccountsAlertsRequest,
  output: ListAccountsAlertsResponse,
  errors: [],
}));

/** Lists all the payments available for an account. */
export interface ListAccountsPaymentsRequest {
  /** Required. The account which owns the collection of payments. Format: accounts/{account} */
  parent: string;
}

export const ListAccountsPaymentsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/payments" }),
  svc,
) as unknown as Schema.Schema<ListAccountsPaymentsRequest>;

export type ListAccountsPaymentsResponse = ListPaymentsResponse;
export const ListAccountsPaymentsResponse = ListPaymentsResponse;

export type ListAccountsPaymentsError = CommonErrors;

export const listAccountsPayments: API.OperationMethod<ListAccountsPaymentsRequest, ListAccountsPaymentsResponse, ListAccountsPaymentsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: ListAccountsPaymentsRequest,
  output: ListAccountsPaymentsResponse,
  errors: [],
}));

/** Gets information about the selected policy issue. */
export interface GetAccountsPolicyIssuesRequest {
  /** Required. Name of the policy issue. Format: accounts/{account}/policyIssues/{policy_issue} */
  name: string;
}

export const GetAccountsPolicyIssuesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/policyIssues/{policyIssuesId}" }),
  svc,
) as unknown as Schema.Schema<GetAccountsPolicyIssuesRequest>;

export type GetAccountsPolicyIssuesResponse = PolicyIssue;
export const GetAccountsPolicyIssuesResponse = PolicyIssue;

export type GetAccountsPolicyIssuesError = CommonErrors;

export const getAccountsPolicyIssues: API.OperationMethod<GetAccountsPolicyIssuesRequest, GetAccountsPolicyIssuesResponse, GetAccountsPolicyIssuesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetAccountsPolicyIssuesRequest,
  output: GetAccountsPolicyIssuesResponse,
  errors: [],
}));

/** Lists all the policy issues where the specified account is involved, both directly and through any AFP child accounts. */
export interface ListAccountsPolicyIssuesRequest {
  /** Required. The account for which policy issues are being retrieved. Format: accounts/{account} */
  parent: string;
  /** The maximum number of policy issues to include in the response, used for paging. If unspecified, at most 10000 policy issues will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000. */
  pageSize?: number;
  /** A page token, received from a previous `ListPolicyIssues` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListPolicyIssues` must match the call that provided the page token. */
  pageToken?: string;
}

export const ListAccountsPolicyIssuesRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/policyIssues" }),
  svc,
) as unknown as Schema.Schema<ListAccountsPolicyIssuesRequest>;

export type ListAccountsPolicyIssuesResponse = ListPolicyIssuesResponse;
export const ListAccountsPolicyIssuesResponse = ListPolicyIssuesResponse;

export type ListAccountsPolicyIssuesError = CommonErrors;

export const listAccountsPolicyIssues = API.makePaginated(() => ({
  input: ListAccountsPolicyIssuesRequest,
  output: ListAccountsPolicyIssuesResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Gets the saved report from the given resource name. */
export interface GetSavedAccountsReportsRequest {
  /** Required. The name of the saved report to retrieve. Format: accounts/{account}/reports/{report} */
  name: string;
}

export const GetSavedAccountsReportsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/reports/{reportsId}/saved" }),
  svc,
) as unknown as Schema.Schema<GetSavedAccountsReportsRequest>;

export type GetSavedAccountsReportsResponse = SavedReport;
export const GetSavedAccountsReportsResponse = SavedReport;

export type GetSavedAccountsReportsError = CommonErrors;

export const getSavedAccountsReports: API.OperationMethod<GetSavedAccountsReportsRequest, GetSavedAccountsReportsResponse, GetSavedAccountsReportsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetSavedAccountsReportsRequest,
  output: GetSavedAccountsReportsResponse,
  errors: [],
}));

/** Generates an ad hoc report. */
export interface GenerateAccountsReportsRequest {
  /** Required. The account which owns the collection of reports. Format: accounts/{account} */
  account: string;
  /** Dimensions to base the report on. */
  dimensions?: "DIMENSION_UNSPECIFIED" | "DATE" | "WEEK" | "MONTH" | "ACCOUNT_NAME" | "AD_CLIENT_ID" | "HOSTED_AD_CLIENT_ID" | "PRODUCT_NAME" | "PRODUCT_CODE" | "AD_UNIT_NAME" | "AD_UNIT_ID" | "AD_UNIT_SIZE_NAME" | "AD_UNIT_SIZE_CODE" | "CUSTOM_CHANNEL_NAME" | "CUSTOM_CHANNEL_ID" | "HOSTED_CUSTOM_CHANNEL_ID" | "OWNED_SITE_DOMAIN_NAME" | "OWNED_SITE_ID" | "PAGE_URL" | "URL_CHANNEL_NAME" | "URL_CHANNEL_ID" | "BUYER_NETWORK_NAME" | "BUYER_NETWORK_ID" | "BID_TYPE_NAME" | "BID_TYPE_CODE" | "CREATIVE_SIZE_NAME" | "CREATIVE_SIZE_CODE" | "DOMAIN_NAME" | "DOMAIN_CODE" | "COUNTRY_NAME" | "COUNTRY_CODE" | "PLATFORM_TYPE_NAME" | "PLATFORM_TYPE_CODE" | "TARGETING_TYPE_NAME" | "TARGETING_TYPE_CODE" | "TRAFFIC_SOURCE_NAME" | "TRAFFIC_SOURCE_CODE" | "CONTENT_PLATFORM_NAME" | "CONTENT_PLATFORM_CODE" | "AD_PLACEMENT_NAME" | "AD_PLACEMENT_CODE" | "REQUESTED_AD_TYPE_NAME" | "REQUESTED_AD_TYPE_CODE" | "SERVED_AD_TYPE_NAME" | "SERVED_AD_TYPE_CODE" | "AD_FORMAT_NAME" | "AD_FORMAT_CODE" | "CUSTOM_SEARCH_STYLE_NAME" | "CUSTOM_SEARCH_STYLE_ID" | "DOMAIN_REGISTRANT" | "WEBSEARCH_QUERY_STRING" | "OS_TYPE_NAME" | "OS_TYPE_CODE" | "BROWSER_TYPE_NAME" | "BROWSER_TYPE_CODE" | "WEBVIEW_TYPE_NAME" | "WEBVIEW_TYPE_CODE" | (string & {})[];
  /** Required. Reporting metrics. */
  metrics?: "METRIC_UNSPECIFIED" | "PAGE_VIEWS" | "AD_REQUESTS" | "MATCHED_AD_REQUESTS" | "TOTAL_IMPRESSIONS" | "IMPRESSIONS" | "INDIVIDUAL_AD_IMPRESSIONS" | "CLICKS" | "PAGE_VIEWS_SPAM_RATIO" | "AD_REQUESTS_SPAM_RATIO" | "MATCHED_AD_REQUESTS_SPAM_RATIO" | "IMPRESSIONS_SPAM_RATIO" | "INDIVIDUAL_AD_IMPRESSIONS_SPAM_RATIO" | "CLICKS_SPAM_RATIO" | "AD_REQUESTS_COVERAGE" | "PAGE_VIEWS_CTR" | "AD_REQUESTS_CTR" | "MATCHED_AD_REQUESTS_CTR" | "IMPRESSIONS_CTR" | "INDIVIDUAL_AD_IMPRESSIONS_CTR" | "ACTIVE_VIEW_MEASURABILITY" | "ACTIVE_VIEW_VIEWABILITY" | "ACTIVE_VIEW_TIME" | "ESTIMATED_EARNINGS" | "PAGE_VIEWS_RPM" | "AD_REQUESTS_RPM" | "MATCHED_AD_REQUESTS_RPM" | "IMPRESSIONS_RPM" | "INDIVIDUAL_AD_IMPRESSIONS_RPM" | "COST_PER_CLICK" | "ADS_PER_IMPRESSION" | "TOTAL_EARNINGS" | "WEBSEARCH_RESULT_PAGES" | "FUNNEL_REQUESTS" | "FUNNEL_IMPRESSIONS" | "FUNNEL_CLICKS" | "FUNNEL_RPM" | (string & {})[];
  /** A list of [filters](/adsense/management/reporting/filtering) to apply to the report. All provided filters must match in order for the data to be included in the report. */
  filters?: string[];
  /** Date range of the report, if unset the range will be considered CUSTOM. */
  dateRange?: "REPORTING_DATE_RANGE_UNSPECIFIED" | "CUSTOM" | "TODAY" | "YESTERDAY" | "MONTH_TO_DATE" | "YEAR_TO_DATE" | "LAST_7_DAYS" | "LAST_30_DAYS" | (string & {});
  /** Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year. */
  "startDate.year"?: number;
  /** Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day. */
  "startDate.month"?: number;
  /** Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant. */
  "startDate.day"?: number;
  /** Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year. */
  "endDate.year"?: number;
  /** Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day. */
  "endDate.month"?: number;
  /** Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant. */
  "endDate.day"?: number;
  /** The name of a dimension or metric to sort the resulting report on, can be prefixed with "+" to sort ascending or "-" to sort descending. If no prefix is specified, the column is sorted ascending. */
  orderBy?: string[];
  /** The language to use for translating report output. If unspecified, this defaults to English ("en"). If the given language is not supported, report output will be returned in English. The language is specified as an [IETF BCP-47 language code](https://en.wikipedia.org/wiki/IETF_language_tag). */
  languageCode?: string;
  /** The [ISO-4217 currency code](https://en.wikipedia.org/wiki/ISO_4217) to use when reporting on monetary metrics. Defaults to the account's currency if not set. */
  currencyCode?: string;
  /** The maximum number of rows of report data to return. Reports producing more rows than the requested limit will be truncated. If unset, this defaults to 100,000 rows for `Reports.GenerateReport` and 1,000,000 rows for `Reports.GenerateCsvReport`, which are also the maximum values permitted here. Report truncation can be identified (for `Reports.GenerateReport` only) by comparing the number of rows returned to the value returned in `total_matched_rows`. */
  limit?: number;
  /** Timezone in which to generate the report. If unspecified, this defaults to the account timezone. For more information, see [changing the time zone of your reports](https://support.google.com/adsense/answer/9830725). */
  reportingTimeZone?: "REPORTING_TIME_ZONE_UNSPECIFIED" | "ACCOUNT_TIME_ZONE" | "GOOGLE_TIME_ZONE" | (string & {});
}

export const GenerateAccountsReportsRequest = Schema.Struct({
  account: Schema.String.pipe(T.HttpPath("account")),
  dimensions: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dimensions")),
  metrics: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("metrics")),
  filters: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("filters")),
  dateRange: Schema.optional(Schema.String).pipe(T.HttpQuery("dateRange")),
  "startDate.year": Schema.optional(Schema.Number).pipe(T.HttpQuery("startDate.year")),
  "startDate.month": Schema.optional(Schema.Number).pipe(T.HttpQuery("startDate.month")),
  "startDate.day": Schema.optional(Schema.Number).pipe(T.HttpQuery("startDate.day")),
  "endDate.year": Schema.optional(Schema.Number).pipe(T.HttpQuery("endDate.year")),
  "endDate.month": Schema.optional(Schema.Number).pipe(T.HttpQuery("endDate.month")),
  "endDate.day": Schema.optional(Schema.Number).pipe(T.HttpQuery("endDate.day")),
  orderBy: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("orderBy")),
  languageCode: Schema.optional(Schema.String).pipe(T.HttpQuery("languageCode")),
  currencyCode: Schema.optional(Schema.String).pipe(T.HttpQuery("currencyCode")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  reportingTimeZone: Schema.optional(Schema.String).pipe(T.HttpQuery("reportingTimeZone")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/reports:generate" }),
  svc,
) as unknown as Schema.Schema<GenerateAccountsReportsRequest>;

export type GenerateAccountsReportsResponse = ReportResult;
export const GenerateAccountsReportsResponse = ReportResult;

export type GenerateAccountsReportsError = CommonErrors;

export const generateAccountsReports: API.OperationMethod<GenerateAccountsReportsRequest, GenerateAccountsReportsResponse, GenerateAccountsReportsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GenerateAccountsReportsRequest,
  output: GenerateAccountsReportsResponse,
  errors: [],
}));

/** Generates a csv formatted ad hoc report. */
export interface GenerateCsvAccountsReportsRequest {
  /** Required. The account which owns the collection of reports. Format: accounts/{account} */
  account: string;
  /** Dimensions to base the report on. */
  dimensions?: "DIMENSION_UNSPECIFIED" | "DATE" | "WEEK" | "MONTH" | "ACCOUNT_NAME" | "AD_CLIENT_ID" | "HOSTED_AD_CLIENT_ID" | "PRODUCT_NAME" | "PRODUCT_CODE" | "AD_UNIT_NAME" | "AD_UNIT_ID" | "AD_UNIT_SIZE_NAME" | "AD_UNIT_SIZE_CODE" | "CUSTOM_CHANNEL_NAME" | "CUSTOM_CHANNEL_ID" | "HOSTED_CUSTOM_CHANNEL_ID" | "OWNED_SITE_DOMAIN_NAME" | "OWNED_SITE_ID" | "PAGE_URL" | "URL_CHANNEL_NAME" | "URL_CHANNEL_ID" | "BUYER_NETWORK_NAME" | "BUYER_NETWORK_ID" | "BID_TYPE_NAME" | "BID_TYPE_CODE" | "CREATIVE_SIZE_NAME" | "CREATIVE_SIZE_CODE" | "DOMAIN_NAME" | "DOMAIN_CODE" | "COUNTRY_NAME" | "COUNTRY_CODE" | "PLATFORM_TYPE_NAME" | "PLATFORM_TYPE_CODE" | "TARGETING_TYPE_NAME" | "TARGETING_TYPE_CODE" | "TRAFFIC_SOURCE_NAME" | "TRAFFIC_SOURCE_CODE" | "CONTENT_PLATFORM_NAME" | "CONTENT_PLATFORM_CODE" | "AD_PLACEMENT_NAME" | "AD_PLACEMENT_CODE" | "REQUESTED_AD_TYPE_NAME" | "REQUESTED_AD_TYPE_CODE" | "SERVED_AD_TYPE_NAME" | "SERVED_AD_TYPE_CODE" | "AD_FORMAT_NAME" | "AD_FORMAT_CODE" | "CUSTOM_SEARCH_STYLE_NAME" | "CUSTOM_SEARCH_STYLE_ID" | "DOMAIN_REGISTRANT" | "WEBSEARCH_QUERY_STRING" | "OS_TYPE_NAME" | "OS_TYPE_CODE" | "BROWSER_TYPE_NAME" | "BROWSER_TYPE_CODE" | "WEBVIEW_TYPE_NAME" | "WEBVIEW_TYPE_CODE" | (string & {})[];
  /** Required. Reporting metrics. */
  metrics?: "METRIC_UNSPECIFIED" | "PAGE_VIEWS" | "AD_REQUESTS" | "MATCHED_AD_REQUESTS" | "TOTAL_IMPRESSIONS" | "IMPRESSIONS" | "INDIVIDUAL_AD_IMPRESSIONS" | "CLICKS" | "PAGE_VIEWS_SPAM_RATIO" | "AD_REQUESTS_SPAM_RATIO" | "MATCHED_AD_REQUESTS_SPAM_RATIO" | "IMPRESSIONS_SPAM_RATIO" | "INDIVIDUAL_AD_IMPRESSIONS_SPAM_RATIO" | "CLICKS_SPAM_RATIO" | "AD_REQUESTS_COVERAGE" | "PAGE_VIEWS_CTR" | "AD_REQUESTS_CTR" | "MATCHED_AD_REQUESTS_CTR" | "IMPRESSIONS_CTR" | "INDIVIDUAL_AD_IMPRESSIONS_CTR" | "ACTIVE_VIEW_MEASURABILITY" | "ACTIVE_VIEW_VIEWABILITY" | "ACTIVE_VIEW_TIME" | "ESTIMATED_EARNINGS" | "PAGE_VIEWS_RPM" | "AD_REQUESTS_RPM" | "MATCHED_AD_REQUESTS_RPM" | "IMPRESSIONS_RPM" | "INDIVIDUAL_AD_IMPRESSIONS_RPM" | "COST_PER_CLICK" | "ADS_PER_IMPRESSION" | "TOTAL_EARNINGS" | "WEBSEARCH_RESULT_PAGES" | "FUNNEL_REQUESTS" | "FUNNEL_IMPRESSIONS" | "FUNNEL_CLICKS" | "FUNNEL_RPM" | (string & {})[];
  /** A list of [filters](/adsense/management/reporting/filtering) to apply to the report. All provided filters must match in order for the data to be included in the report. */
  filters?: string[];
  /** Date range of the report, if unset the range will be considered CUSTOM. */
  dateRange?: "REPORTING_DATE_RANGE_UNSPECIFIED" | "CUSTOM" | "TODAY" | "YESTERDAY" | "MONTH_TO_DATE" | "YEAR_TO_DATE" | "LAST_7_DAYS" | "LAST_30_DAYS" | (string & {});
  /** Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year. */
  "startDate.year"?: number;
  /** Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day. */
  "startDate.month"?: number;
  /** Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant. */
  "startDate.day"?: number;
  /** Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year. */
  "endDate.year"?: number;
  /** Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day. */
  "endDate.month"?: number;
  /** Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant. */
  "endDate.day"?: number;
  /** The name of a dimension or metric to sort the resulting report on, can be prefixed with "+" to sort ascending or "-" to sort descending. If no prefix is specified, the column is sorted ascending. */
  orderBy?: string[];
  /** The language to use for translating report output. If unspecified, this defaults to English ("en"). If the given language is not supported, report output will be returned in English. The language is specified as an [IETF BCP-47 language code](https://en.wikipedia.org/wiki/IETF_language_tag). */
  languageCode?: string;
  /** The [ISO-4217 currency code](https://en.wikipedia.org/wiki/ISO_4217) to use when reporting on monetary metrics. Defaults to the account's currency if not set. */
  currencyCode?: string;
  /** The maximum number of rows of report data to return. Reports producing more rows than the requested limit will be truncated. If unset, this defaults to 100,000 rows for `Reports.GenerateReport` and 1,000,000 rows for `Reports.GenerateCsvReport`, which are also the maximum values permitted here. Report truncation can be identified (for `Reports.GenerateReport` only) by comparing the number of rows returned to the value returned in `total_matched_rows`. */
  limit?: number;
  /** Timezone in which to generate the report. If unspecified, this defaults to the account timezone. For more information, see [changing the time zone of your reports](https://support.google.com/adsense/answer/9830725). */
  reportingTimeZone?: "REPORTING_TIME_ZONE_UNSPECIFIED" | "ACCOUNT_TIME_ZONE" | "GOOGLE_TIME_ZONE" | (string & {});
}

export const GenerateCsvAccountsReportsRequest = Schema.Struct({
  account: Schema.String.pipe(T.HttpPath("account")),
  dimensions: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("dimensions")),
  metrics: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("metrics")),
  filters: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("filters")),
  dateRange: Schema.optional(Schema.String).pipe(T.HttpQuery("dateRange")),
  "startDate.year": Schema.optional(Schema.Number).pipe(T.HttpQuery("startDate.year")),
  "startDate.month": Schema.optional(Schema.Number).pipe(T.HttpQuery("startDate.month")),
  "startDate.day": Schema.optional(Schema.Number).pipe(T.HttpQuery("startDate.day")),
  "endDate.year": Schema.optional(Schema.Number).pipe(T.HttpQuery("endDate.year")),
  "endDate.month": Schema.optional(Schema.Number).pipe(T.HttpQuery("endDate.month")),
  "endDate.day": Schema.optional(Schema.Number).pipe(T.HttpQuery("endDate.day")),
  orderBy: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("orderBy")),
  languageCode: Schema.optional(Schema.String).pipe(T.HttpQuery("languageCode")),
  currencyCode: Schema.optional(Schema.String).pipe(T.HttpQuery("currencyCode")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  reportingTimeZone: Schema.optional(Schema.String).pipe(T.HttpQuery("reportingTimeZone")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/reports:generateCsv" }),
  svc,
) as unknown as Schema.Schema<GenerateCsvAccountsReportsRequest>;

export type GenerateCsvAccountsReportsResponse = HttpBody;
export const GenerateCsvAccountsReportsResponse = HttpBody;

export type GenerateCsvAccountsReportsError = CommonErrors;

export const generateCsvAccountsReports: API.OperationMethod<GenerateCsvAccountsReportsRequest, GenerateCsvAccountsReportsResponse, GenerateCsvAccountsReportsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GenerateCsvAccountsReportsRequest,
  output: GenerateCsvAccountsReportsResponse,
  errors: [],
}));

/** Generates a saved report. */
export interface GenerateAccountsReportsSavedRequest {
  /** Required. Name of the saved report. Format: accounts/{account}/reports/{report} */
  name: string;
  /** Date range of the report, if unset the range will be considered CUSTOM. */
  dateRange?: "REPORTING_DATE_RANGE_UNSPECIFIED" | "CUSTOM" | "TODAY" | "YESTERDAY" | "MONTH_TO_DATE" | "YEAR_TO_DATE" | "LAST_7_DAYS" | "LAST_30_DAYS" | (string & {});
  /** Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year. */
  "startDate.year"?: number;
  /** Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day. */
  "startDate.month"?: number;
  /** Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant. */
  "startDate.day"?: number;
  /** Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year. */
  "endDate.year"?: number;
  /** Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day. */
  "endDate.month"?: number;
  /** Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant. */
  "endDate.day"?: number;
  /** The language to use for translating report output. If unspecified, this defaults to English ("en"). If the given language is not supported, report output will be returned in English. The language is specified as an [IETF BCP-47 language code](https://en.wikipedia.org/wiki/IETF_language_tag). */
  languageCode?: string;
  /** The [ISO-4217 currency code](https://en.wikipedia.org/wiki/ISO_4217) to use when reporting on monetary metrics. Defaults to the account's currency if not set. */
  currencyCode?: string;
  /** Timezone in which to generate the report. If unspecified, this defaults to the account timezone. For more information, see [changing the time zone of your reports](https://support.google.com/adsense/answer/9830725). */
  reportingTimeZone?: "REPORTING_TIME_ZONE_UNSPECIFIED" | "ACCOUNT_TIME_ZONE" | "GOOGLE_TIME_ZONE" | (string & {});
}

export const GenerateAccountsReportsSavedRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  dateRange: Schema.optional(Schema.String).pipe(T.HttpQuery("dateRange")),
  "startDate.year": Schema.optional(Schema.Number).pipe(T.HttpQuery("startDate.year")),
  "startDate.month": Schema.optional(Schema.Number).pipe(T.HttpQuery("startDate.month")),
  "startDate.day": Schema.optional(Schema.Number).pipe(T.HttpQuery("startDate.day")),
  "endDate.year": Schema.optional(Schema.Number).pipe(T.HttpQuery("endDate.year")),
  "endDate.month": Schema.optional(Schema.Number).pipe(T.HttpQuery("endDate.month")),
  "endDate.day": Schema.optional(Schema.Number).pipe(T.HttpQuery("endDate.day")),
  languageCode: Schema.optional(Schema.String).pipe(T.HttpQuery("languageCode")),
  currencyCode: Schema.optional(Schema.String).pipe(T.HttpQuery("currencyCode")),
  reportingTimeZone: Schema.optional(Schema.String).pipe(T.HttpQuery("reportingTimeZone")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/reports/{reportsId}/saved:generate" }),
  svc,
) as unknown as Schema.Schema<GenerateAccountsReportsSavedRequest>;

export type GenerateAccountsReportsSavedResponse = ReportResult;
export const GenerateAccountsReportsSavedResponse = ReportResult;

export type GenerateAccountsReportsSavedError = CommonErrors;

export const generateAccountsReportsSaved: API.OperationMethod<GenerateAccountsReportsSavedRequest, GenerateAccountsReportsSavedResponse, GenerateAccountsReportsSavedError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GenerateAccountsReportsSavedRequest,
  output: GenerateAccountsReportsSavedResponse,
  errors: [],
}));

/** Generates a csv formatted saved report. */
export interface GenerateCsvAccountsReportsSavedRequest {
  /** Required. Name of the saved report. Format: accounts/{account}/reports/{report} */
  name: string;
  /** Date range of the report, if unset the range will be considered CUSTOM. */
  dateRange?: "REPORTING_DATE_RANGE_UNSPECIFIED" | "CUSTOM" | "TODAY" | "YESTERDAY" | "MONTH_TO_DATE" | "YEAR_TO_DATE" | "LAST_7_DAYS" | "LAST_30_DAYS" | (string & {});
  /** Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year. */
  "startDate.year"?: number;
  /** Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day. */
  "startDate.month"?: number;
  /** Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant. */
  "startDate.day"?: number;
  /** Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year. */
  "endDate.year"?: number;
  /** Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day. */
  "endDate.month"?: number;
  /** Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant. */
  "endDate.day"?: number;
  /** The language to use for translating report output. If unspecified, this defaults to English ("en"). If the given language is not supported, report output will be returned in English. The language is specified as an [IETF BCP-47 language code](https://en.wikipedia.org/wiki/IETF_language_tag). */
  languageCode?: string;
  /** The [ISO-4217 currency code](https://en.wikipedia.org/wiki/ISO_4217) to use when reporting on monetary metrics. Defaults to the account's currency if not set. */
  currencyCode?: string;
  /** Timezone in which to generate the report. If unspecified, this defaults to the account timezone. For more information, see [changing the time zone of your reports](https://support.google.com/adsense/answer/9830725). */
  reportingTimeZone?: "REPORTING_TIME_ZONE_UNSPECIFIED" | "ACCOUNT_TIME_ZONE" | "GOOGLE_TIME_ZONE" | (string & {});
}

export const GenerateCsvAccountsReportsSavedRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  dateRange: Schema.optional(Schema.String).pipe(T.HttpQuery("dateRange")),
  "startDate.year": Schema.optional(Schema.Number).pipe(T.HttpQuery("startDate.year")),
  "startDate.month": Schema.optional(Schema.Number).pipe(T.HttpQuery("startDate.month")),
  "startDate.day": Schema.optional(Schema.Number).pipe(T.HttpQuery("startDate.day")),
  "endDate.year": Schema.optional(Schema.Number).pipe(T.HttpQuery("endDate.year")),
  "endDate.month": Schema.optional(Schema.Number).pipe(T.HttpQuery("endDate.month")),
  "endDate.day": Schema.optional(Schema.Number).pipe(T.HttpQuery("endDate.day")),
  languageCode: Schema.optional(Schema.String).pipe(T.HttpQuery("languageCode")),
  currencyCode: Schema.optional(Schema.String).pipe(T.HttpQuery("currencyCode")),
  reportingTimeZone: Schema.optional(Schema.String).pipe(T.HttpQuery("reportingTimeZone")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/reports/{reportsId}/saved:generateCsv" }),
  svc,
) as unknown as Schema.Schema<GenerateCsvAccountsReportsSavedRequest>;

export type GenerateCsvAccountsReportsSavedResponse = HttpBody;
export const GenerateCsvAccountsReportsSavedResponse = HttpBody;

export type GenerateCsvAccountsReportsSavedError = CommonErrors;

export const generateCsvAccountsReportsSaved: API.OperationMethod<GenerateCsvAccountsReportsSavedRequest, GenerateCsvAccountsReportsSavedResponse, GenerateCsvAccountsReportsSavedError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GenerateCsvAccountsReportsSavedRequest,
  output: GenerateCsvAccountsReportsSavedResponse,
  errors: [],
}));

/** Lists saved reports. */
export interface ListAccountsReportsSavedRequest {
  /** Required. The account which owns the collection of reports. Format: accounts/{account} */
  parent: string;
  /** The maximum number of reports to include in the response, used for paging. If unspecified, at most 10000 reports will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000. */
  pageSize?: number;
  /** A page token, received from a previous `ListSavedReports` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListSavedReports` must match the call that provided the page token. */
  pageToken?: string;
}

export const ListAccountsReportsSavedRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/reports/saved" }),
  svc,
) as unknown as Schema.Schema<ListAccountsReportsSavedRequest>;

export type ListAccountsReportsSavedResponse = ListSavedReportsResponse;
export const ListAccountsReportsSavedResponse = ListSavedReportsResponse;

export type ListAccountsReportsSavedError = CommonErrors;

export const listAccountsReportsSaved = API.makePaginated(() => ({
  input: ListAccountsReportsSavedRequest,
  output: ListAccountsReportsSavedResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Gets information about the selected site. */
export interface GetAccountsSitesRequest {
  /** Required. Name of the site. Format: accounts/{account}/sites/{site} */
  name: string;
}

export const GetAccountsSitesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/sites/{sitesId}" }),
  svc,
) as unknown as Schema.Schema<GetAccountsSitesRequest>;

export type GetAccountsSitesResponse = Site;
export const GetAccountsSitesResponse = Site;

export type GetAccountsSitesError = CommonErrors;

export const getAccountsSites: API.OperationMethod<GetAccountsSitesRequest, GetAccountsSitesResponse, GetAccountsSitesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetAccountsSitesRequest,
  output: GetAccountsSitesResponse,
  errors: [],
}));

/** Lists all the sites available in an account. */
export interface ListAccountsSitesRequest {
  /** Required. The account which owns the collection of sites. Format: accounts/{account} */
  parent: string;
  /** The maximum number of sites to include in the response, used for paging. If unspecified, at most 10000 sites will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000. */
  pageSize?: number;
  /** A page token, received from a previous `ListSites` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListSites` must match the call that provided the page token. */
  pageToken?: string;
}

export const ListAccountsSitesRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v2/accounts/{accountsId}/sites" }),
  svc,
) as unknown as Schema.Schema<ListAccountsSitesRequest>;

export type ListAccountsSitesResponse = ListSitesResponse;
export const ListAccountsSitesResponse = ListSitesResponse;

export type ListAccountsSitesError = CommonErrors;

export const listAccountsSites = API.makePaginated(() => ({
  input: ListAccountsSitesRequest,
  output: ListAccountsSitesResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

