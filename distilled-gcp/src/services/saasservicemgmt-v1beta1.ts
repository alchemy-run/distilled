// ==========================================================================
// SaaS Runtime API (saasservicemgmt v1beta1)
// DO NOT EDIT - Generated from GCP Discovery Document
// ==========================================================================

import * as Schema from "effect/Schema";
import * as API from "../client/api.ts";
import * as T from "../traits.ts";
import * as C from "../category.ts";
import type { GCPAuth } from "../auth.ts";
import type { CommonErrors } from "../errors.ts";
import type * as HttpClient from "effect/unstable/http/HttpClient";

// Service metadata
const svc = T.Service({
  name: "saasservicemgmt",
  version: "v1beta1",
  rootUrl: "https://saasservicemgmt.googleapis.com/",
  servicePath: "",
});

// ==========================================================================
// Schemas
// ==========================================================================

export interface Location {
  /** Optional. Name of location. */
  name?: string;
}

export const Location: Schema.Schema<Location> = Schema.suspend(() => Schema.Struct({
  name: Schema.optional(Schema.String),
})).annotate({ identifier: "Location" }) as any as Schema.Schema<Location>;

export interface Saas {
  /** Output only. The unique identifier of the resource. UID is unique in the time and space for this resource within the scope of the service. It is typically generated by the server on successful creation of a resource and must not be changed. UID is used to uniquely identify resources with resource name reuses. This should be a UUID4. */
  uid?: string;
  /** Identifier. The resource name (full URI of the resource) following the standard naming scheme: "projects/{project}/locations/{location}/saas/{saas}" */
  name?: string;
  /** Output only. The timestamp when the resource was last updated. Any change to the resource made by users must refresh this value. Changes to a resource made by the service should refresh this value. */
  updateTime?: string;
  /** Optional. The labels on the resource, which can be used for categorization. similar to Kubernetes resource labels. */
  labels?: Record<string, string>;
  /** Optional. Annotations is an unstructured key-value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/user-guide/annotations */
  annotations?: Record<string, string>;
  /** Output only. The timestamp when the resource was created. */
  createTime?: string;
  /** Optional. List of locations that the service is available in. Rollout refers to the list to generate a rollout plan. */
  locations?: Array<Location>;
  /** Output only. An opaque value that uniquely identifies a version or generation of a resource. It can be used to confirm that the client and server agree on the ordering of a resource being written. */
  etag?: string;
}

export const Saas: Schema.Schema<Saas> = Schema.suspend(() => Schema.Struct({
  uid: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  labels: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  annotations: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  createTime: Schema.optional(Schema.String),
  locations: Schema.optional(Schema.Array(Location)),
  etag: Schema.optional(Schema.String),
})).annotate({ identifier: "Saas" }) as any as Schema.Schema<Saas>;

export interface Blueprint {
  /** Output only. Type of the engine used to actuate the blueprint. e.g. terraform, helm etc. */
  engine?: string;
  /** Optional. Immutable. URI to a blueprint used by the Unit (required unless unitKind or release is set). */
  package?: string;
  /** Output only. Version metadata if present on the blueprint. */
  version?: string;
}

export const Blueprint: Schema.Schema<Blueprint> = Schema.suspend(() => Schema.Struct({
  engine: Schema.optional(Schema.String),
  package: Schema.optional(Schema.String),
  version: Schema.optional(Schema.String),
})).annotate({ identifier: "Blueprint" }) as any as Schema.Schema<Blueprint>;

export interface Dependency {
  /** Required. Immutable. The unit kind of the dependency. */
  unitKind?: string;
  /** Required. An alias for the dependency. Used for input variable mapping. */
  alias?: string;
}

export const Dependency: Schema.Schema<Dependency> = Schema.suspend(() => Schema.Struct({
  unitKind: Schema.optional(Schema.String),
  alias: Schema.optional(Schema.String),
})).annotate({ identifier: "Dependency" }) as any as Schema.Schema<Dependency>;

export interface UnitDependency {
  /** Output only. A reference to the Unit object. */
  unit?: string;
  /** Output only. Alias for the name of the dependency. */
  alias?: string;
}

export const UnitDependency: Schema.Schema<UnitDependency> = Schema.suspend(() => Schema.Struct({
  unit: Schema.optional(Schema.String),
  alias: Schema.optional(Schema.String),
})).annotate({ identifier: "UnitDependency" }) as any as Schema.Schema<UnitDependency>;

export interface UnitCondition {
  /** Required. Type of the condition. */
  type?: "TYPE_UNSPECIFIED" | "TYPE_READY" | "TYPE_UPDATING" | "TYPE_PROVISIONED" | "TYPE_OPERATION_ERROR" | (string & {});
  /** Required. Brief reason for the condition's last transition. */
  reason?: string;
  /** Required. Status of the condition. */
  status?: "STATUS_UNSPECIFIED" | "STATUS_UNKNOWN" | "STATUS_TRUE" | "STATUS_FALSE" | (string & {});
  /** Required. Last time the condition transited from one status to another. */
  lastTransitionTime?: string;
  /** Required. Human readable message indicating details about the last transition. */
  message?: string;
}

export const UnitCondition: Schema.Schema<UnitCondition> = Schema.suspend(() => Schema.Struct({
  type: Schema.optional(Schema.String),
  reason: Schema.optional(Schema.String),
  status: Schema.optional(Schema.String),
  lastTransitionTime: Schema.optional(Schema.String),
  message: Schema.optional(Schema.String),
})).annotate({ identifier: "UnitCondition" }) as any as Schema.Schema<UnitCondition>;

export interface UnitVariable {
  /** Optional. Immutable. Name of a supported variable type. Supported types are string, int, bool. */
  type?: "TYPE_UNSPECIFIED" | "STRING" | "INT" | "BOOL" | (string & {});
  /** Required. Immutable. Name of the variable from actuation configs. */
  variable?: string;
  /** Optional. String encoded value for the variable. */
  value?: string;
}

export const UnitVariable: Schema.Schema<UnitVariable> = Schema.suspend(() => Schema.Struct({
  type: Schema.optional(Schema.String),
  variable: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String),
})).annotate({ identifier: "UnitVariable" }) as any as Schema.Schema<UnitVariable>;

export interface MaintenanceSettings {
  /** Optional. If present, it fixes the release on the unit until the given time; i.e. changes to the release field will be rejected. Rollouts should and will also respect this by not requesting an upgrade in the first place. */
  pinnedUntilTime?: string;
}

export const MaintenanceSettings: Schema.Schema<MaintenanceSettings> = Schema.suspend(() => Schema.Struct({
  pinnedUntilTime: Schema.optional(Schema.String),
})).annotate({ identifier: "MaintenanceSettings" }) as any as Schema.Schema<MaintenanceSettings>;

export interface Unit {
  /** Optional. Output only. List of pending (wait to be executed) UnitOperations for this unit. */
  pendingOperations?: Array<string>;
  /** Optional. Output only. List of scheduled UnitOperations for this unit. */
  scheduledOperations?: Array<string>;
  /** Optional. Output only. Set of dependencies for this unit. Maximum 10. */
  dependencies?: Array<UnitDependency>;
  /** Output only. Indicates whether the resource location satisfies Zone Isolation constraints. This is false by default. */
  satisfiesPzi?: boolean;
  /** Optional. Output only. List of concurrent UnitOperations that are operating on this Unit. */
  ongoingOperations?: Array<string>;
  /** Optional. The labels on the resource, which can be used for categorization. similar to Kubernetes resource labels. */
  labels?: Record<string, string>;
  /** Optional. Output only. A set of conditions which indicate the various conditions this resource can have. */
  conditions?: Array<UnitCondition>;
  /** Optional. Output only. The current Release object for this Unit. */
  release?: string;
  /** Optional. Output only. If set, indicates the time when the system will start removing the unit. */
  systemCleanupAt?: string;
  /** Optional. Reference to the UnitKind this Unit belongs to. Immutable once set. */
  unitKind?: string;
  /** Optional. Output only. Set of key/value pairs corresponding to output variables from execution of actuation templates. The variables are declared in actuation configs (e.g in helm chart or terraform) and the values are fetched and returned by the actuation engine upon completion of execution. */
  outputVariables?: Array<UnitVariable>;
  /** Optional. Output only. Current lifecycle state of the resource (e.g. if it's being created or ready to use). */
  state?: "UNIT_STATE_UNSPECIFIED" | "UNIT_STATE_NOT_PROVISIONED" | "UNIT_STATE_PROVISIONING" | "UNIT_STATE_UPDATING" | "UNIT_STATE_DEPROVISIONING" | "UNIT_STATE_READY" | "UNIT_STATE_ERROR" | (string & {});
  /** Optional. Output only. Indicates the current input variables deployed by the unit */
  inputVariables?: Array<UnitVariable>;
  /** Optional. Reference to the Saas Tenant resource this unit belongs to. This for example informs the maintenance policies to use for scheduling future updates on a unit. (optional and immutable once created) */
  tenant?: string;
  /** Optional. Immutable. Indicates whether the Unit life cycle is controlled by the user or by the system. Immutable once created. */
  managementMode?: "MANAGEMENT_MODE_UNSPECIFIED" | "MANAGEMENT_MODE_USER" | "MANAGEMENT_MODE_SYSTEM" | (string & {});
  /** Output only. The timestamp when the resource was last updated. Any change to the resource made by users must refresh this value. Changes to a resource made by the service should refresh this value. */
  updateTime?: string;
  /** Output only. The unique identifier of the resource. UID is unique in the time and space for this resource within the scope of the service. It is typically generated by the server on successful creation of a resource and must not be changed. UID is used to uniquely identify resources with resource name reuses. This should be a UUID4. */
  uid?: string;
  /** Identifier. The resource name (full URI of the resource) following the standard naming scheme: "projects/{project}/locations/{location}/units/{unit}" */
  name?: string;
  /** Optional. Output only. Indicates the system managed state of the unit. */
  systemManagedState?: "SYSTEM_MANAGED_STATE_UNSPECIFIED" | "SYSTEM_MANAGED_STATE_ACTIVE" | "SYSTEM_MANAGED_STATE_INACTIVE" | "SYSTEM_MANAGED_STATE_DECOMMISSIONED" | (string & {});
  /** Optional. Captures requested directives for performing future maintenance on the unit. This includes a request for the unit to skip maintenance for a period of time and remain pinned to its current release as well as controls for postponing maintenance scheduled in future. */
  maintenance?: MaintenanceSettings;
  /** Optional. Output only. List of Units that depend on this unit. Unit can only be deprovisioned if this list is empty. Maximum 1000. */
  dependents?: Array<UnitDependency>;
  /** Output only. Indicates whether the resource location satisfies Zone Separation constraints. This is false by default. */
  satisfiesPzs?: boolean;
  /** Optional. Annotations is an unstructured key-value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/user-guide/annotations */
  annotations?: Record<string, string>;
  /** Output only. An opaque value that uniquely identifies a version or generation of a resource. It can be used to confirm that the client and server agree on the ordering of a resource being written. */
  etag?: string;
  /** Output only. The timestamp when the resource was created. */
  createTime?: string;
}

export const Unit: Schema.Schema<Unit> = Schema.suspend(() => Schema.Struct({
  pendingOperations: Schema.optional(Schema.Array(Schema.String)),
  scheduledOperations: Schema.optional(Schema.Array(Schema.String)),
  dependencies: Schema.optional(Schema.Array(UnitDependency)),
  satisfiesPzi: Schema.optional(Schema.Boolean),
  ongoingOperations: Schema.optional(Schema.Array(Schema.String)),
  labels: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  conditions: Schema.optional(Schema.Array(UnitCondition)),
  release: Schema.optional(Schema.String),
  systemCleanupAt: Schema.optional(Schema.String),
  unitKind: Schema.optional(Schema.String),
  outputVariables: Schema.optional(Schema.Array(UnitVariable)),
  state: Schema.optional(Schema.String),
  inputVariables: Schema.optional(Schema.Array(UnitVariable)),
  tenant: Schema.optional(Schema.String),
  managementMode: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  uid: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  systemManagedState: Schema.optional(Schema.String),
  maintenance: Schema.optional(MaintenanceSettings),
  dependents: Schema.optional(Schema.Array(UnitDependency)),
  satisfiesPzs: Schema.optional(Schema.Boolean),
  annotations: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  etag: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
})).annotate({ identifier: "Unit" }) as any as Schema.Schema<Unit>;

export interface Tenant {
  /** Optional. The labels on the resource, which can be used for categorization. similar to Kubernetes resource labels. */
  labels?: Record<string, string>;
  /** Output only. The unique identifier of the resource. UID is unique in the time and space for this resource within the scope of the service. It is typically generated by the server on successful creation of a resource and must not be changed. UID is used to uniquely identify resources with resource name reuses. This should be a UUID4. */
  uid?: string;
  /** Optional. Annotations is an unstructured key-value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/user-guide/annotations */
  annotations?: Record<string, string>;
  /** Required. Immutable. A reference to the Saas that defines the product (managed service) that the producer wants to manage with SaaS Runtime. Part of the SaaS Runtime common data model. */
  saas?: string;
  /** Output only. The timestamp when the resource was created. */
  createTime?: string;
  /** Optional. Immutable. A reference to the consumer resource this SaaS Tenant is representing. The relationship with a consumer resource can be used by SaaS Runtime for retrieving consumer-defined settings and policies such as maintenance policies (using Unified Maintenance Policy API). */
  consumerResource?: string;
  /** Identifier. The resource name (full URI of the resource) following the standard naming scheme: "projects/{project}/locations/{location}/tenants/{tenant}" */
  name?: string;
  /** Output only. An opaque value that uniquely identifies a version or generation of a resource. It can be used to confirm that the client and server agree on the ordering of a resource being written. */
  etag?: string;
  /** Output only. The timestamp when the resource was last updated. Any change to the resource made by users must refresh this value. Changes to a resource made by the service should refresh this value. */
  updateTime?: string;
}

export const Tenant: Schema.Schema<Tenant> = Schema.suspend(() => Schema.Struct({
  labels: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  uid: Schema.optional(Schema.String),
  annotations: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  saas: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  consumerResource: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  etag: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
})).annotate({ identifier: "Tenant" }) as any as Schema.Schema<Tenant>;

export interface ListTenantsResponse {
  /** If present, the next page token can be provided to a subsequent ListTenants call to list the next page. If empty, there are no more pages. */
  nextPageToken?: string;
  /** Locations that could not be reached. */
  unreachable?: Array<string>;
  /** The resulting tenants. */
  tenants?: Array<Tenant>;
}

export const ListTenantsResponse: Schema.Schema<ListTenantsResponse> = Schema.suspend(() => Schema.Struct({
  nextPageToken: Schema.optional(Schema.String),
  unreachable: Schema.optional(Schema.Array(Schema.String)),
  tenants: Schema.optional(Schema.Array(Tenant)),
})).annotate({ identifier: "ListTenantsResponse" }) as any as Schema.Schema<ListTenantsResponse>;

export interface Provision {
  /** Optional. Reference to the Release object to use for the Unit. (optional). */
  release?: string;
  /** Optional. Set of input variables. Maximum 100. (optional) */
  inputVariables?: Array<UnitVariable>;
}

export const Provision: Schema.Schema<Provision> = Schema.suspend(() => Schema.Struct({
  release: Schema.optional(Schema.String),
  inputVariables: Schema.optional(Schema.Array(UnitVariable)),
})).annotate({ identifier: "Provision" }) as any as Schema.Schema<Provision>;

export interface ErrorBudget {
  /** Optional. The maximum number of failed units allowed in a location without pausing the rollout. */
  allowedCount?: number;
  /** Optional. The maximum percentage of units allowed to fail (0, 100] within a location without pausing the rollout. */
  allowedPercentage?: number;
}

export const ErrorBudget: Schema.Schema<ErrorBudget> = Schema.suspend(() => Schema.Struct({
  allowedCount: Schema.optional(Schema.Number),
  allowedPercentage: Schema.optional(Schema.Number),
})).annotate({ identifier: "ErrorBudget" }) as any as Schema.Schema<ErrorBudget>;

export interface RolloutKind {
  /** Optional. The configuration for error budget. If the number of failed units exceeds max(allowed_count, allowed_ratio * total_units), the rollout will be paused. If not set, all units will be attempted to be updated regardless of the number of failures encountered. */
  errorBudget?: ErrorBudget;
  /** Optional. Value among strict (enforcing maintenance policy and only looking at Units with maintenance policy), ignore (ignoring maintenance policy) and skip (skipping Units with maintenance policy) */
  maintenancePolicyEnforcement?: "MAINTENANCE_POLICY_ENFORCEMENT_UNSPECIFIED" | "MAINTENANCE_POLICY_ENFORCEMENT_STRICT" | "MAINTENANCE_POLICY_ENFORCEMENT_IGNORED" | "MAINTENANCE_POLICY_ENFORCEMENT_SKIPPED" | (string & {});
  /** Identifier. The resource name (full URI of the resource) following the standard naming scheme: "projects/{project}/locations/{location}/rolloutKinds/{rollout_kind_id}" */
  name?: string;
  /** Required. Immutable. UnitKind that this rollout kind corresponds to. Rollouts stemming from this rollout kind will target the units of this unit kind. In other words, this defines the population of target units to be upgraded by rollouts. */
  unitKind?: string;
  /** Output only. The unique identifier of the resource. UID is unique in the time and space for this resource within the scope of the service. It is typically generated by the server on successful creation of a resource and must not be changed. UID is used to uniquely identify resources with resource name reuses. This should be a UUID4. */
  uid?: string;
  /** Output only. An opaque value that uniquely identifies a version or generation of a resource. It can be used to confirm that the client and server agree on the ordering of a resource being written. */
  etag?: string;
  /** Optional. CEL(https://github.com/google/cel-spec) formatted filter string against Unit. The filter will be applied to determine the eligible unit population. This filter can only reduce, but not expand the scope of the rollout. */
  unitFilter?: string;
  /** Output only. The timestamp when the resource was created. */
  createTime?: string;
  /** Optional. The strategy used for executing a Rollout. This is a required field. There are two supported values strategies which are used to control - "Google.Cloud.Simple.AllAtOnce" - "Google.Cloud.Simple.OneLocationAtATime" A rollout with one of these simple strategies will rollout across all locations defined in the associated UnitKind's Saas Locations. */
  rolloutOrchestrationStrategy?: string;
  /** Optional. The config for updating the unit kind. By default, the unit kind will be updated on the rollout start. */
  updateUnitKindStrategy?: "UPDATE_UNIT_KIND_STRATEGY_UNSPECIFIED" | "UPDATE_UNIT_KIND_STRATEGY_ON_START" | "UPDATE_UNIT_KIND_STRATEGY_NEVER" | (string & {});
  /** Optional. Annotations is an unstructured key-value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/user-guide/annotations */
  annotations?: Record<string, string>;
  /** Output only. The timestamp when the resource was last updated. Any change to the resource made by users must refresh this value. Changes to a resource made by the service should refresh this value. */
  updateTime?: string;
  /** Optional. The labels on the resource, which can be used for categorization. similar to Kubernetes resource labels. */
  labels?: Record<string, string>;
}

export const RolloutKind: Schema.Schema<RolloutKind> = Schema.suspend(() => Schema.Struct({
  errorBudget: Schema.optional(ErrorBudget),
  maintenancePolicyEnforcement: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  unitKind: Schema.optional(Schema.String),
  uid: Schema.optional(Schema.String),
  etag: Schema.optional(Schema.String),
  unitFilter: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  rolloutOrchestrationStrategy: Schema.optional(Schema.String),
  updateUnitKindStrategy: Schema.optional(Schema.String),
  annotations: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  updateTime: Schema.optional(Schema.String),
  labels: Schema.optional(Schema.Record(Schema.String, Schema.String)),
})).annotate({ identifier: "RolloutKind" }) as any as Schema.Schema<RolloutKind>;

export interface GoogleCloudLocationLocation {
  /** The canonical id for this location. For example: `"us-east1"`. */
  locationId?: string;
  /** The friendly name for this location, typically a nearby city name. For example, "Tokyo". */
  displayName?: string;
  /** Service-specific metadata. For example the available capacity at the given location. */
  metadata?: Record<string, unknown>;
  /** Resource name for the location, which may vary between implementations. For example: `"projects/example-project/locations/us-east1"` */
  name?: string;
  /** Cross-service attributes for the location. For example {"cloud.googleapis.com/region": "us-east1"} */
  labels?: Record<string, string>;
}

export const GoogleCloudLocationLocation: Schema.Schema<GoogleCloudLocationLocation> = Schema.suspend(() => Schema.Struct({
  locationId: Schema.optional(Schema.String),
  displayName: Schema.optional(Schema.String),
  metadata: Schema.optional(Schema.Record(Schema.String, Schema.Unknown)),
  name: Schema.optional(Schema.String),
  labels: Schema.optional(Schema.Record(Schema.String, Schema.String)),
})).annotate({ identifier: "GoogleCloudLocationLocation" }) as any as Schema.Schema<GoogleCloudLocationLocation>;

export interface RunRolloutActionParams {
  /** Required. If true, the rollout will retry failed operations when resumed. This is applicable only the current state of the Rollout is PAUSED and the requested action is RUN. */
  retryFailedOperations?: boolean;
}

export const RunRolloutActionParams: Schema.Schema<RunRolloutActionParams> = Schema.suspend(() => Schema.Struct({
  retryFailedOperations: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "RunRolloutActionParams" }) as any as Schema.Schema<RunRolloutActionParams>;

export interface RolloutControl {
  /** Required. Action to be performed on the Rollout. The default behavior is to run the rollout until it naturally reaches a terminal state. */
  action?: "ROLLOUT_ACTION_UNSPECIFIED" | "ROLLOUT_ACTION_RUN" | "ROLLOUT_ACTION_PAUSE" | "ROLLOUT_ACTION_CANCEL" | (string & {});
  /** Optional. Parameters for the RUN action. It is an error to specify this if the RolloutAction is not set to RUN. By default, the rollout will retry failed operations when resumed. */
  runParams?: RunRolloutActionParams;
}

export const RolloutControl: Schema.Schema<RolloutControl> = Schema.suspend(() => Schema.Struct({
  action: Schema.optional(Schema.String),
  runParams: Schema.optional(RunRolloutActionParams),
})).annotate({ identifier: "RolloutControl" }) as any as Schema.Schema<RolloutControl>;

export interface Aggregate {
  /** Required. Group by which to aggregate. */
  group?: string;
  /** Required. Number of records in the group. */
  count?: number;
}

export const Aggregate: Schema.Schema<Aggregate> = Schema.suspend(() => Schema.Struct({
  group: Schema.optional(Schema.String),
  count: Schema.optional(Schema.Number),
})).annotate({ identifier: "Aggregate" }) as any as Schema.Schema<Aggregate>;

export interface RolloutStats {
  /** Optional. Output only. Unordered list. A breakdown of the progress of operations triggered by the rollout. Provides a count of Operations by their state. This can be used to determine the number of units which have been updated, or are scheduled to be updated. There will be at most one entry per group. Possible values for operation groups are: - "SCHEDULED" - "PENDING" - "RUNNING" - "SUCCEEDED" - "FAILED" - "CANCELLED" */
  operationsByState?: Array<Aggregate>;
}

export const RolloutStats: Schema.Schema<RolloutStats> = Schema.suspend(() => Schema.Struct({
  operationsByState: Schema.optional(Schema.Array(Aggregate)),
})).annotate({ identifier: "RolloutStats" }) as any as Schema.Schema<RolloutStats>;

export interface Rollout {
  /** Optional. Output only. The root rollout that this rollout is stemming from. The resource name (full URI of the resource) following the standard naming scheme: "projects/{project}/locations/{location}/rollouts/{rollout_id}" */
  rootRollout?: string;
  /** Optional. Output only. The direct parent rollout that this rollout is stemming from. The resource name (full URI of the resource) following the standard naming scheme: "projects/{project}/locations/{location}/rollouts/{rollout_id}" */
  parentRollout?: string;
  /** Optional. Immutable. Name of the Release that gets rolled out to target Units. Required if no other type of release is specified. */
  release?: string;
  /** Optional. Requested change to the execution of this rollout. Default RolloutControl.action is ROLLOUT_ACTION_RUN meaning the rollout will be executed to completion while progressing through all natural Rollout States (such as RUNNING -> SUCCEEDED or RUNNING -> FAILED). Requests can only be made when the Rollout is in a non-terminal state. */
  control?: RolloutControl;
  /** Optional. Output only. The time when the rollout finished execution (regardless of success, failure, or cancellation). Will be empty if the rollout hasn't finished yet. Once set, the rollout is in terminal state and all the results are final. */
  endTime?: string;
  /** Identifier. The resource name (full URI of the resource) following the standard naming scheme: "projects/{project}/locations/{location}/rollout/{rollout_id}" */
  name?: string;
  /** Optional. Annotations is an unstructured key-value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/user-guide/annotations */
  annotations?: Record<string, string>;
  /** Optional. The labels on the resource, which can be used for categorization. similar to Kubernetes resource labels. */
  labels?: Record<string, string>;
  /** Optional. The strategy used for executing this Rollout. This strategy will override whatever strategy is specified in the RolloutKind. If not specified on creation, the strategy from RolloutKind will be used. There are two supported values strategies which are used to control - "Google.Cloud.Simple.AllAtOnce" - "Google.Cloud.Simple.OneLocationAtATime" A rollout with one of these simple strategies will rollout across all locations defined in the targeted UnitKind's Saas Locations. */
  rolloutOrchestrationStrategy?: string;
  /** Output only. The unique identifier of the resource. UID is unique in the time and space for this resource within the scope of the service. It is typically generated by the server on successful creation of a resource and must not be changed. UID is used to uniquely identify resources with resource name reuses. This should be a UUID4. */
  uid?: string;
  /** Optional. Output only. Details about the progress of the rollout. */
  stats?: RolloutStats;
  /** Optional. CEL(https://github.com/google/cel-spec) formatted filter string against Unit. The filter will be applied to determine the eligible unit population. This filter can only reduce, but not expand the scope of the rollout. If not provided, the unit_filter from the RolloutKind will be used. */
  unitFilter?: string;
  /** Optional. Output only. The time when the rollout transitioned into its current state. */
  stateTransitionTime?: string;
  /** Output only. An opaque value that uniquely identifies a version or generation of a resource. It can be used to confirm that the client and server agree on the ordering of a resource being written. */
  etag?: string;
  /** Output only. Human readable message indicating details about the last state transition. */
  stateMessage?: string;
  /** Output only. The timestamp when the resource was last updated. Any change to the resource made by users must refresh this value. Changes to a resource made by the service should refresh this value. */
  updateTime?: string;
  /** Output only. The timestamp when the resource was created. */
  createTime?: string;
  /** Output only. Current state of the rollout. */
  state?: "ROLLOUT_STATE_UNSPECIFIED" | "ROLLOUT_STATE_RUNNING" | "ROLLOUT_STATE_PAUSED" | "ROLLOUT_STATE_SUCCEEDED" | "ROLLOUT_STATE_FAILED" | "ROLLOUT_STATE_CANCELLED" | "ROLLOUT_STATE_WAITING" | "ROLLOUT_STATE_CANCELLING" | "ROLLOUT_STATE_RESUMING" | "ROLLOUT_STATE_PAUSING" | (string & {});
  /** Optional. Output only. The time when the rollout started executing. Will be empty if the rollout hasn't started yet. */
  startTime?: string;
  /** Optional. Output only. Output only snapshot of the effective unit filter at Rollout start time. Contains a CEL(https://github.com/google/cel-spec) expression consisting of a conjunction of Rollout.unit_filter and RolloutKind.unit_filter. This field captures the filter applied by the Rollout to determine the Unit population. If the associated RolloutKind's unit_filter is modified after the rollout is started, it will not be updated here. */
  effectiveUnitFilter?: string;
  /** Optional. Immutable. Name of the RolloutKind this rollout is stemming from and adhering to. */
  rolloutKind?: string;
  /** Output only. The timestamp when the resource was marked for deletion (deletion is an asynchronous operation). */
  deleteTime?: string;
}

export const Rollout: Schema.Schema<Rollout> = Schema.suspend(() => Schema.Struct({
  rootRollout: Schema.optional(Schema.String),
  parentRollout: Schema.optional(Schema.String),
  release: Schema.optional(Schema.String),
  control: Schema.optional(RolloutControl),
  endTime: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  annotations: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  labels: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  rolloutOrchestrationStrategy: Schema.optional(Schema.String),
  uid: Schema.optional(Schema.String),
  stats: Schema.optional(RolloutStats),
  unitFilter: Schema.optional(Schema.String),
  stateTransitionTime: Schema.optional(Schema.String),
  etag: Schema.optional(Schema.String),
  stateMessage: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  state: Schema.optional(Schema.String),
  startTime: Schema.optional(Schema.String),
  effectiveUnitFilter: Schema.optional(Schema.String),
  rolloutKind: Schema.optional(Schema.String),
  deleteTime: Schema.optional(Schema.String),
})).annotate({ identifier: "Rollout" }) as any as Schema.Schema<Rollout>;

export interface ListSaasResponse {
  /** If present, the next page token can be provided to a subsequent ListSaas call to list the next page. If empty, there are no more pages. */
  nextPageToken?: string;
  /** The resulting saas. */
  saas?: Array<Saas>;
  /** Locations that could not be reached. */
  unreachable?: Array<string>;
}

export const ListSaasResponse: Schema.Schema<ListSaasResponse> = Schema.suspend(() => Schema.Struct({
  nextPageToken: Schema.optional(Schema.String),
  saas: Schema.optional(Schema.Array(Saas)),
  unreachable: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "ListSaasResponse" }) as any as Schema.Schema<ListSaasResponse>;

export interface ListUnitsResponse {
  /** The resulting units. */
  units?: Array<Unit>;
  /** If present, the next page token can be provided to a subsequent ListUnits call to list the next page. If empty, there are no more pages. */
  nextPageToken?: string;
  /** Locations that could not be reached. */
  unreachable?: Array<string>;
}

export const ListUnitsResponse: Schema.Schema<ListUnitsResponse> = Schema.suspend(() => Schema.Struct({
  units: Schema.optional(Schema.Array(Unit)),
  nextPageToken: Schema.optional(Schema.String),
  unreachable: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "ListUnitsResponse" }) as any as Schema.Schema<ListUnitsResponse>;

export interface UnitOperationCondition {
  /** Required. Last time the condition transited from one status to another. */
  lastTransitionTime?: string;
  /** Required. Human readable message indicating details about the last transition. */
  message?: string;
  /** Required. Brief reason for the condition's last transition. */
  reason?: string;
  /** Required. Type of the condition. */
  type?: "TYPE_UNSPECIFIED" | "TYPE_SCHEDULED" | "TYPE_RUNNING" | "TYPE_SUCCEEDED" | "TYPE_CANCELLED" | "TYPE_APP_CREATED" | "TYPE_APP_COMPONENTS_REGISTERED" | (string & {});
  /** Required. Status of the condition. */
  status?: "STATUS_UNSPECIFIED" | "STATUS_UNKNOWN" | "STATUS_TRUE" | "STATUS_FALSE" | (string & {});
}

export const UnitOperationCondition: Schema.Schema<UnitOperationCondition> = Schema.suspend(() => Schema.Struct({
  lastTransitionTime: Schema.optional(Schema.String),
  message: Schema.optional(Schema.String),
  reason: Schema.optional(Schema.String),
  type: Schema.optional(Schema.String),
  status: Schema.optional(Schema.String),
})).annotate({ identifier: "UnitOperationCondition" }) as any as Schema.Schema<UnitOperationCondition>;

export interface FromMapping {
  /** Required. Alias of the dependency that the outputVariable will pass its value to */
  dependency?: string;
  /** Required. Name of the outputVariable on the dependency */
  outputVariable?: string;
}

export const FromMapping: Schema.Schema<FromMapping> = Schema.suspend(() => Schema.Struct({
  dependency: Schema.optional(Schema.String),
  outputVariable: Schema.optional(Schema.String),
})).annotate({ identifier: "FromMapping" }) as any as Schema.Schema<FromMapping>;

export interface ToMapping {
  /** Required. Name of the inputVariable on the dependency */
  inputVariable?: string;
  /** Optional. Tells SaaS Runtime if this mapping should be used during lookup or not */
  ignoreForLookup?: boolean;
  /** Required. Alias of the dependency that the inputVariable will pass its value to */
  dependency?: string;
}

export const ToMapping: Schema.Schema<ToMapping> = Schema.suspend(() => Schema.Struct({
  inputVariable: Schema.optional(Schema.String),
  ignoreForLookup: Schema.optional(Schema.Boolean),
  dependency: Schema.optional(Schema.String),
})).annotate({ identifier: "ToMapping" }) as any as Schema.Schema<ToMapping>;

export interface VariableMapping {
  /** Required. name of the variable */
  variable?: string;
  /** Optional. Output variables which will get their values from dependencies */
  from?: FromMapping;
  /** Optional. Input variables whose values will be passed on to dependencies. */
  to?: ToMapping;
}

export const VariableMapping: Schema.Schema<VariableMapping> = Schema.suspend(() => Schema.Struct({
  variable: Schema.optional(Schema.String),
  from: Schema.optional(FromMapping),
  to: Schema.optional(ToMapping),
})).annotate({ identifier: "VariableMapping" }) as any as Schema.Schema<VariableMapping>;

export interface UnitKind {
  /** Optional. Immutable. List of other unit kinds that this release will depend on. Dependencies will be automatically provisioned if not found. Maximum 10. */
  dependencies?: Array<Dependency>;
  /** Output only. An opaque value that uniquely identifies a version or generation of a resource. It can be used to confirm that the client and server agree on the ordering of a resource being written. */
  etag?: string;
  /** Optional. Annotations is an unstructured key-value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/user-guide/annotations */
  annotations?: Record<string, string>;
  /** Output only. The unique identifier of the resource. UID is unique in the time and space for this resource within the scope of the service. It is typically generated by the server on successful creation of a resource and must not be changed. UID is used to uniquely identify resources with resource name reuses. This should be a UUID4. */
  uid?: string;
  /** Optional. List of outputVariables for this unit kind will be passed to this unit's outputVariables. Maximum 100. */
  outputVariableMappings?: Array<VariableMapping>;
  /** Output only. The timestamp when the resource was created. */
  createTime?: string;
  /** Required. Immutable. A reference to the Saas that defines the product (managed service) that the producer wants to manage with SaaS Runtime. Part of the SaaS Runtime common data model. Immutable once set. */
  saas?: string;
  /** Output only. The timestamp when the resource was last updated. Any change to the resource made by users must refresh this value. Changes to a resource made by the service should refresh this value. */
  updateTime?: string;
  /** Optional. A reference to the Release object to use as default for creating new units of this UnitKind (optional). If not specified, a new unit must explicitly reference which release to use for its creation. */
  defaultRelease?: string;
  /** Optional. The labels on the resource, which can be used for categorization. similar to Kubernetes resource labels. */
  labels?: Record<string, string>;
  /** Identifier. The resource name (full URI of the resource) following the standard naming scheme: "projects/{project}/locations/{location}/unitKinds/{unitKind}" */
  name?: string;
  /** Optional. List of inputVariables for this release that will either be retrieved from a dependency’s outputVariables, or will be passed on to a dependency’s inputVariables. Maximum 100. */
  inputVariableMappings?: Array<VariableMapping>;
}

export const UnitKind: Schema.Schema<UnitKind> = Schema.suspend(() => Schema.Struct({
  dependencies: Schema.optional(Schema.Array(Dependency)),
  etag: Schema.optional(Schema.String),
  annotations: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  uid: Schema.optional(Schema.String),
  outputVariableMappings: Schema.optional(Schema.Array(VariableMapping)),
  createTime: Schema.optional(Schema.String),
  saas: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  defaultRelease: Schema.optional(Schema.String),
  labels: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  name: Schema.optional(Schema.String),
  inputVariableMappings: Schema.optional(Schema.Array(VariableMapping)),
})).annotate({ identifier: "UnitKind" }) as any as Schema.Schema<UnitKind>;

export interface ListUnitKindsResponse {
  /** The resulting unit kinds. */
  unitKinds?: Array<UnitKind>;
  /** If present, the next page token can be provided to a subsequent ListUnitKinds call to list the next page. If empty, there are no more pages. */
  nextPageToken?: string;
  /** Locations that could not be reached. */
  unreachable?: Array<string>;
}

export const ListUnitKindsResponse: Schema.Schema<ListUnitKindsResponse> = Schema.suspend(() => Schema.Struct({
  unitKinds: Schema.optional(Schema.Array(UnitKind)),
  nextPageToken: Schema.optional(Schema.String),
  unreachable: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "ListUnitKindsResponse" }) as any as Schema.Schema<ListUnitKindsResponse>;

export interface Deprovision {
}

export const Deprovision: Schema.Schema<Deprovision> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "Deprovision" }) as any as Schema.Schema<Deprovision>;

export interface Empty {
}

export const Empty: Schema.Schema<Empty> = Schema.suspend(() => Schema.Struct({
})).annotate({ identifier: "Empty" }) as any as Schema.Schema<Empty>;

export interface ListLocationsResponse {
  /** The standard List next-page token. */
  nextPageToken?: string;
  /** A list of locations that matches the specified filter in the request. */
  locations?: Array<GoogleCloudLocationLocation>;
}

export const ListLocationsResponse: Schema.Schema<ListLocationsResponse> = Schema.suspend(() => Schema.Struct({
  nextPageToken: Schema.optional(Schema.String),
  locations: Schema.optional(Schema.Array(GoogleCloudLocationLocation)),
})).annotate({ identifier: "ListLocationsResponse" }) as any as Schema.Schema<ListLocationsResponse>;

export interface Schedule {
  /** Optional. Start of operation. If not set, will be set to the start of the next window. (optional) */
  startTime?: string;
}

export const Schedule: Schema.Schema<Schedule> = Schema.suspend(() => Schema.Struct({
  startTime: Schema.optional(Schema.String),
})).annotate({ identifier: "Schedule" }) as any as Schema.Schema<Schedule>;

export interface Upgrade {
  /** Optional. Reference to the Release object to use for the Unit. (optional). */
  release?: string;
  /** Optional. Set of input variables. Maximum 100. (optional) */
  inputVariables?: Array<UnitVariable>;
}

export const Upgrade: Schema.Schema<Upgrade> = Schema.suspend(() => Schema.Struct({
  release: Schema.optional(Schema.String),
  inputVariables: Schema.optional(Schema.Array(UnitVariable)),
})).annotate({ identifier: "Upgrade" }) as any as Schema.Schema<Upgrade>;

export interface UnitOperation {
  /** Required. Immutable. The Unit a given UnitOperation will act upon. */
  unit?: string;
  /** Output only. The unique identifier of the resource. UID is unique in the time and space for this resource within the scope of the service. It is typically generated by the server on successful creation of a resource and must not be changed. UID is used to uniquely identify resources with resource name reuses. This should be a UUID4. */
  uid?: string;
  /** Output only. An opaque value that uniquely identifies a version or generation of a resource. It can be used to confirm that the client and server agree on the ordering of a resource being written. */
  etag?: string;
  /** Optional. Output only. UnitOperationErrorCategory describe the error category. */
  errorCategory?: "UNIT_OPERATION_ERROR_CATEGORY_UNSPECIFIED" | "NOT_APPLICABLE" | "FATAL" | "RETRIABLE" | "IGNORABLE" | "STANDARD" | (string & {});
  /** Optional. Specifies which rollout created this Unit Operation. This cannot be modified and is used for filtering purposes only. If a dependent unit and unit operation are created as part of another unit operation, they will use the same rolloutId. */
  rollout?: string;
  provision?: Provision;
  /** Optional. When true, attempt to cancel the operation. Cancellation may fail if the operation is already executing. (Optional) */
  cancel?: boolean;
  /** Optional. Reference to parent resource: UnitOperation. If an operation needs to create other operations as part of its workflow, each of the child operations should have this field set to the parent. This can be used for tracing. (Optional) */
  parentUnitOperation?: string;
  /** Output only. The timestamp when the resource was last updated. Any change to the resource made by users must refresh this value. Changes to a resource made by the service should refresh this value. */
  updateTime?: string;
  deprovision?: Deprovision;
  /** Output only. The timestamp when the resource was marked for deletion (deletion is an asynchronous operation). */
  deleteTime?: string;
  /** Optional. Output only. A set of conditions which indicate the various conditions this resource can have. */
  conditions?: Array<UnitOperationCondition>;
  /** Identifier. The resource name (full URI of the resource) following the standard naming scheme: "projects/{project}/locations/{location}/unitOperations/{unitOperation}" */
  name?: string;
  /** Output only. The timestamp when the resource was created. */
  createTime?: string;
  /** Optional. Annotations is an unstructured key-value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/user-guide/annotations */
  annotations?: Record<string, string>;
  /** Optional. The labels on the resource, which can be used for categorization. similar to Kubernetes resource labels. */
  labels?: Record<string, string>;
  /** Optional. Output only. UnitOperationState describes the current state of the unit operation. */
  state?: "UNIT_OPERATION_STATE_UNKNOWN" | "UNIT_OPERATION_STATE_PENDING" | "UNIT_OPERATION_STATE_SCHEDULED" | "UNIT_OPERATION_STATE_RUNNING" | "UNIT_OPERATION_STATE_SUCCEEDED" | "UNIT_OPERATION_STATE_FAILED" | "UNIT_OPERATION_STATE_CANCELLED" | (string & {});
  /** Optional. Output only. The engine state for on-going deployment engine operation(s). This field is opaque for external usage. */
  engineState?: string;
  /** Optional. When to schedule this operation. */
  schedule?: Schedule;
  upgrade?: Upgrade;
}

export const UnitOperation: Schema.Schema<UnitOperation> = Schema.suspend(() => Schema.Struct({
  unit: Schema.optional(Schema.String),
  uid: Schema.optional(Schema.String),
  etag: Schema.optional(Schema.String),
  errorCategory: Schema.optional(Schema.String),
  rollout: Schema.optional(Schema.String),
  provision: Schema.optional(Provision),
  cancel: Schema.optional(Schema.Boolean),
  parentUnitOperation: Schema.optional(Schema.String),
  updateTime: Schema.optional(Schema.String),
  deprovision: Schema.optional(Deprovision),
  deleteTime: Schema.optional(Schema.String),
  conditions: Schema.optional(Schema.Array(UnitOperationCondition)),
  name: Schema.optional(Schema.String),
  createTime: Schema.optional(Schema.String),
  annotations: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  labels: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  state: Schema.optional(Schema.String),
  engineState: Schema.optional(Schema.String),
  schedule: Schema.optional(Schedule),
  upgrade: Schema.optional(Upgrade),
})).annotate({ identifier: "UnitOperation" }) as any as Schema.Schema<UnitOperation>;

export interface ReleaseRequirements {
  /** Optional. A list of releases from which a unit can be upgraded to this one (optional). If left empty no constraints will be applied. When provided, unit upgrade requests to this release will check and enforce this constraint. */
  upgradeableFromReleases?: Array<string>;
}

export const ReleaseRequirements: Schema.Schema<ReleaseRequirements> = Schema.suspend(() => Schema.Struct({
  upgradeableFromReleases: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "ReleaseRequirements" }) as any as Schema.Schema<ReleaseRequirements>;

export interface ListRolloutsResponse {
  /** If present, the next page token can be provided to a subsequent ListRollouts call to list the next page. If empty, there are no more pages. */
  nextPageToken?: string;
  /** The resulting rollouts. */
  rollouts?: Array<Rollout>;
  /** Locations that could not be reached. */
  unreachable?: Array<string>;
}

export const ListRolloutsResponse: Schema.Schema<ListRolloutsResponse> = Schema.suspend(() => Schema.Struct({
  nextPageToken: Schema.optional(Schema.String),
  rollouts: Schema.optional(Schema.Array(Rollout)),
  unreachable: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "ListRolloutsResponse" }) as any as Schema.Schema<ListRolloutsResponse>;

export interface Release {
  /** Output only. The timestamp when the resource was created. */
  createTime?: string;
  /** Optional. Output only. List of output variables declared on the blueprint and can be present with their values on the unit status */
  outputVariables?: Array<UnitVariable>;
  /** Output only. An opaque value that uniquely identifies a version or generation of a resource. It can be used to confirm that the client and server agree on the ordering of a resource being written. */
  etag?: string;
  /** Optional. Set of requirements to be fulfilled on the Unit when using this Release. */
  releaseRequirements?: ReleaseRequirements;
  /** Optional. Mapping of input variables to default values. Maximum 100 */
  inputVariableDefaults?: Array<UnitVariable>;
  /** Output only. The timestamp when the resource was last updated. Any change to the resource made by users must refresh this value. Changes to a resource made by the service should refresh this value. */
  updateTime?: string;
  /** Optional. Blueprints are OCI Images that contain all of the artifacts needed to provision a unit. */
  blueprint?: Blueprint;
  /** Optional. Annotations is an unstructured key-value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/user-guide/annotations */
  annotations?: Record<string, string>;
  /** Output only. The unique identifier of the resource. UID is unique in the time and space for this resource within the scope of the service. It is typically generated by the server on successful creation of a resource and must not be changed. UID is used to uniquely identify resources with resource name reuses. This should be a UUID4. */
  uid?: string;
  /** Optional. Output only. List of input variables declared on the blueprint and can be present with their values on the unit spec */
  inputVariables?: Array<UnitVariable>;
  /** Identifier. The resource name (full URI of the resource) following the standard naming scheme: "projects/{project}/locations/{location}/releases/{release}" */
  name?: string;
  /** Required. Immutable. Reference to the UnitKind this Release corresponds to (required and immutable once created). */
  unitKind?: string;
  /** Optional. The labels on the resource, which can be used for categorization. similar to Kubernetes resource labels. */
  labels?: Record<string, string>;
}

export const Release: Schema.Schema<Release> = Schema.suspend(() => Schema.Struct({
  createTime: Schema.optional(Schema.String),
  outputVariables: Schema.optional(Schema.Array(UnitVariable)),
  etag: Schema.optional(Schema.String),
  releaseRequirements: Schema.optional(ReleaseRequirements),
  inputVariableDefaults: Schema.optional(Schema.Array(UnitVariable)),
  updateTime: Schema.optional(Schema.String),
  blueprint: Schema.optional(Blueprint),
  annotations: Schema.optional(Schema.Record(Schema.String, Schema.String)),
  uid: Schema.optional(Schema.String),
  inputVariables: Schema.optional(Schema.Array(UnitVariable)),
  name: Schema.optional(Schema.String),
  unitKind: Schema.optional(Schema.String),
  labels: Schema.optional(Schema.Record(Schema.String, Schema.String)),
})).annotate({ identifier: "Release" }) as any as Schema.Schema<Release>;

export interface ListReleasesResponse {
  /** The resulting releases. */
  releases?: Array<Release>;
  /** If present, the next page token can be provided to a subsequent ListReleases call to list the next page. If empty, there are no more pages. */
  nextPageToken?: string;
  /** Locations that could not be reached. */
  unreachable?: Array<string>;
}

export const ListReleasesResponse: Schema.Schema<ListReleasesResponse> = Schema.suspend(() => Schema.Struct({
  releases: Schema.optional(Schema.Array(Release)),
  nextPageToken: Schema.optional(Schema.String),
  unreachable: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "ListReleasesResponse" }) as any as Schema.Schema<ListReleasesResponse>;

export interface ListRolloutKindsResponse {
  /** Locations that could not be reached. */
  unreachable?: Array<string>;
  /** If present, the next page token can be provided to a subsequent ListRolloutKinds call to list the next page. If empty, there are no more pages. */
  nextPageToken?: string;
  /** The resulting rollout kinds. */
  rolloutKinds?: Array<RolloutKind>;
}

export const ListRolloutKindsResponse: Schema.Schema<ListRolloutKindsResponse> = Schema.suspend(() => Schema.Struct({
  unreachable: Schema.optional(Schema.Array(Schema.String)),
  nextPageToken: Schema.optional(Schema.String),
  rolloutKinds: Schema.optional(Schema.Array(RolloutKind)),
})).annotate({ identifier: "ListRolloutKindsResponse" }) as any as Schema.Schema<ListRolloutKindsResponse>;

export interface ListUnitOperationsResponse {
  /** Locations that could not be reached. */
  unreachable?: Array<string>;
  /** The resulting unit operations. */
  unitOperations?: Array<UnitOperation>;
  /** If present, the next page token can be provided to a subsequent ListUnitOperations call to list the next page. If empty, there are no more pages. */
  nextPageToken?: string;
}

export const ListUnitOperationsResponse: Schema.Schema<ListUnitOperationsResponse> = Schema.suspend(() => Schema.Struct({
  unreachable: Schema.optional(Schema.Array(Schema.String)),
  unitOperations: Schema.optional(Schema.Array(UnitOperation)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "ListUnitOperationsResponse" }) as any as Schema.Schema<ListUnitOperationsResponse>;

// ==========================================================================
// Operations
// ==========================================================================

/** Gets information about a location. */
export interface GetProjectsLocationsRequest {
  /** Resource name for the location. */
  name: string;
}

export const GetProjectsLocationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1beta1/projects/{projectsId}/locations/{locationsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsRequest>;

export type GetProjectsLocationsResponse = GoogleCloudLocationLocation;
export const GetProjectsLocationsResponse = GoogleCloudLocationLocation;

export type GetProjectsLocationsError = CommonErrors;

export const getProjectsLocations: API.OperationMethod<GetProjectsLocationsRequest, GetProjectsLocationsResponse, GetProjectsLocationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsRequest,
  output: GetProjectsLocationsResponse,
  errors: [],
}));

/** Lists information about the supported locations for this service. This method can be called in two ways: * **List all public locations:** Use the path `GET /v1/locations`. * **List project-visible locations:** Use the path `GET /v1/projects/{project_id}/locations`. This may include public locations as well as private or other locations specifically visible to the project. */
export interface ListProjectsLocationsRequest {
  /** Optional. Do not use this field. It is unsupported and is ignored unless explicitly documented otherwise. This is primarily for internal usage. */
  extraLocationTypes?: string[];
  /** A page token received from the `next_page_token` field in the response. Send that page token to receive the subsequent page. */
  pageToken?: string;
  /** The maximum number of results to return. If not set, the service selects a default. */
  pageSize?: number;
  /** The resource that owns the locations collection, if applicable. */
  name: string;
  /** A filter to narrow down results to a preferred subset. The filtering language accepts strings like `"displayName=tokyo"`, and is documented in more detail in [AIP-160](https://google.aip.dev/160). */
  filter?: string;
}

export const ListProjectsLocationsRequest = Schema.Struct({
  extraLocationTypes: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("extraLocationTypes")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  name: Schema.String.pipe(T.HttpPath("name")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
}).pipe(
  T.Http({ method: "GET", path: "v1beta1/projects/{projectsId}/locations" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsRequest>;

export type ListProjectsLocationsResponse = ListLocationsResponse;
export const ListProjectsLocationsResponse = ListLocationsResponse;

export type ListProjectsLocationsError = CommonErrors;

export const listProjectsLocations = API.makePaginated(() => ({
  input: ListProjectsLocationsRequest,
  output: ListProjectsLocationsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Delete a single unit operation. */
export interface DeleteProjectsLocationsUnitOperationsRequest {
  /** The etag known to the client for the expected state of the unit operation. This is used with state-changing methods to prevent accidental overwrites when multiple user agents might be acting in parallel on the same resource. An etag wildcard provide optimistic concurrency based on the expected existence of the unit operation. The Any wildcard (`*`) requires that the resource must already exists, and the Not Any wildcard (`!*`) requires that it must not. */
  etag?: string;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** Required. The resource name of the resource within a service. */
  name: string;
}

export const DeleteProjectsLocationsUnitOperationsRequest = Schema.Struct({
  etag: Schema.optional(Schema.String).pipe(T.HttpQuery("etag")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/unitOperations/{unitOperationsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsUnitOperationsRequest>;

export type DeleteProjectsLocationsUnitOperationsResponse = Empty;
export const DeleteProjectsLocationsUnitOperationsResponse = Empty;

export type DeleteProjectsLocationsUnitOperationsError = CommonErrors;

export const deleteProjectsLocationsUnitOperations: API.OperationMethod<DeleteProjectsLocationsUnitOperationsRequest, DeleteProjectsLocationsUnitOperationsResponse, DeleteProjectsLocationsUnitOperationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsUnitOperationsRequest,
  output: DeleteProjectsLocationsUnitOperationsResponse,
  errors: [],
}));

/** Update a single unit operation. */
export interface PatchProjectsLocationsUnitOperationsRequest {
  /** Identifier. The resource name (full URI of the resource) following the standard naming scheme: "projects/{project}/locations/{location}/unitOperations/{unitOperation}" */
  name: string;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** Field mask is used to specify the fields to be overwritten in the UnitOperation resource by the update. The fields specified in the update_mask are relative to the resource, not the full request. A field will be overwritten if it is in the mask. If the user does not provide a mask then all fields in the UnitOperation will be overwritten. */
  updateMask?: string;
  /** Request body */
  body?: UnitOperation;
}

export const PatchProjectsLocationsUnitOperationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(UnitOperation).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/unitOperations/{unitOperationsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsUnitOperationsRequest>;

export type PatchProjectsLocationsUnitOperationsResponse = UnitOperation;
export const PatchProjectsLocationsUnitOperationsResponse = UnitOperation;

export type PatchProjectsLocationsUnitOperationsError = CommonErrors;

export const patchProjectsLocationsUnitOperations: API.OperationMethod<PatchProjectsLocationsUnitOperationsRequest, PatchProjectsLocationsUnitOperationsResponse, PatchProjectsLocationsUnitOperationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsUnitOperationsRequest,
  output: PatchProjectsLocationsUnitOperationsResponse,
  errors: [],
}));

/** Retrieve a single unit operation. */
export interface GetProjectsLocationsUnitOperationsRequest {
  /** Required. The resource name of the resource within a service. */
  name: string;
}

export const GetProjectsLocationsUnitOperationsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/unitOperations/{unitOperationsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsUnitOperationsRequest>;

export type GetProjectsLocationsUnitOperationsResponse = UnitOperation;
export const GetProjectsLocationsUnitOperationsResponse = UnitOperation;

export type GetProjectsLocationsUnitOperationsError = CommonErrors;

export const getProjectsLocationsUnitOperations: API.OperationMethod<GetProjectsLocationsUnitOperationsRequest, GetProjectsLocationsUnitOperationsResponse, GetProjectsLocationsUnitOperationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsUnitOperationsRequest,
  output: GetProjectsLocationsUnitOperationsResponse,
  errors: [],
}));

/** Create a new unit operation. */
export interface CreateProjectsLocationsUnitOperationsRequest {
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** Required. The ID value for the new unit operation. */
  unitOperationId?: string;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** Required. The parent of the unit operation. */
  parent: string;
  /** Request body */
  body?: UnitOperation;
}

export const CreateProjectsLocationsUnitOperationsRequest = Schema.Struct({
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  unitOperationId: Schema.optional(Schema.String).pipe(T.HttpQuery("unitOperationId")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(UnitOperation).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/unitOperations", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsUnitOperationsRequest>;

export type CreateProjectsLocationsUnitOperationsResponse = UnitOperation;
export const CreateProjectsLocationsUnitOperationsResponse = UnitOperation;

export type CreateProjectsLocationsUnitOperationsError = CommonErrors;

export const createProjectsLocationsUnitOperations: API.OperationMethod<CreateProjectsLocationsUnitOperationsRequest, CreateProjectsLocationsUnitOperationsResponse, CreateProjectsLocationsUnitOperationsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsUnitOperationsRequest,
  output: CreateProjectsLocationsUnitOperationsResponse,
  errors: [],
}));

/** Retrieve a collection of unit operations. */
export interface ListProjectsLocationsUnitOperationsRequest {
  /** The page token: If the next_page_token from a previous response is provided, this request will send the subsequent page. */
  pageToken?: string;
  /** Filter the list as specified in https://google.aip.dev/160. */
  filter?: string;
  /** The maximum number of unit operations to send per page. */
  pageSize?: number;
  /** Order results as specified in https://google.aip.dev/132. */
  orderBy?: string;
  /** Required. The parent of the unit operation. */
  parent: string;
}

export const ListProjectsLocationsUnitOperationsRequest = Schema.Struct({
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy")),
  parent: Schema.String.pipe(T.HttpPath("parent")),
}).pipe(
  T.Http({ method: "GET", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/unitOperations" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsUnitOperationsRequest>;

export type ListProjectsLocationsUnitOperationsResponse = ListUnitOperationsResponse;
export const ListProjectsLocationsUnitOperationsResponse = ListUnitOperationsResponse;

export type ListProjectsLocationsUnitOperationsError = CommonErrors;

export const listProjectsLocationsUnitOperations = API.makePaginated(() => ({
  input: ListProjectsLocationsUnitOperationsRequest,
  output: ListProjectsLocationsUnitOperationsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Retrieve a single saas. */
export interface GetProjectsLocationsSaasRequest {
  /** Required. The resource name of the resource within a service. */
  name: string;
}

export const GetProjectsLocationsSaasRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/saas/{saasId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsSaasRequest>;

export type GetProjectsLocationsSaasResponse = Saas;
export const GetProjectsLocationsSaasResponse = Saas;

export type GetProjectsLocationsSaasError = CommonErrors;

export const getProjectsLocationsSaas: API.OperationMethod<GetProjectsLocationsSaasRequest, GetProjectsLocationsSaasResponse, GetProjectsLocationsSaasError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsSaasRequest,
  output: GetProjectsLocationsSaasResponse,
  errors: [],
}));

/** Create a new saas. */
export interface CreateProjectsLocationsSaasRequest {
  /** Required. The ID value for the new saas. */
  saasId?: string;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** Required. The parent of the saas. */
  parent: string;
  /** Request body */
  body?: Saas;
}

export const CreateProjectsLocationsSaasRequest = Schema.Struct({
  saasId: Schema.optional(Schema.String).pipe(T.HttpQuery("saasId")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(Saas).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/saas", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsSaasRequest>;

export type CreateProjectsLocationsSaasResponse = Saas;
export const CreateProjectsLocationsSaasResponse = Saas;

export type CreateProjectsLocationsSaasError = CommonErrors;

export const createProjectsLocationsSaas: API.OperationMethod<CreateProjectsLocationsSaasRequest, CreateProjectsLocationsSaasResponse, CreateProjectsLocationsSaasError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsSaasRequest,
  output: CreateProjectsLocationsSaasResponse,
  errors: [],
}));

/** Delete a single saas. */
export interface DeleteProjectsLocationsSaasRequest {
  /** Required. The resource name of the resource within a service. */
  name: string;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** The etag known to the client for the expected state of the saas. This is used with state-changing methods to prevent accidental overwrites when multiple user agents might be acting in parallel on the same resource. An etag wildcard provide optimistic concurrency based on the expected existence of the saas. The Any wildcard (`*`) requires that the resource must already exists, and the Not Any wildcard (`!*`) requires that it must not. */
  etag?: string;
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
}

export const DeleteProjectsLocationsSaasRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  etag: Schema.optional(Schema.String).pipe(T.HttpQuery("etag")),
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/saas/{saasId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsSaasRequest>;

export type DeleteProjectsLocationsSaasResponse = Empty;
export const DeleteProjectsLocationsSaasResponse = Empty;

export type DeleteProjectsLocationsSaasError = CommonErrors;

export const deleteProjectsLocationsSaas: API.OperationMethod<DeleteProjectsLocationsSaasRequest, DeleteProjectsLocationsSaasResponse, DeleteProjectsLocationsSaasError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsSaasRequest,
  output: DeleteProjectsLocationsSaasResponse,
  errors: [],
}));

/** Update a single saas. */
export interface PatchProjectsLocationsSaasRequest {
  /** Identifier. The resource name (full URI of the resource) following the standard naming scheme: "projects/{project}/locations/{location}/saas/{saas}" */
  name: string;
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** Field mask is used to specify the fields to be overwritten in the Saas resource by the update. The fields specified in the update_mask are relative to the resource, not the full request. A field will be overwritten if it is in the mask. If the user does not provide a mask then all fields in the Saas will be overwritten. */
  updateMask?: string;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** Request body */
  body?: Saas;
}

export const PatchProjectsLocationsSaasRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  body: Schema.optional(Saas).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/saas/{saasId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsSaasRequest>;

export type PatchProjectsLocationsSaasResponse = Saas;
export const PatchProjectsLocationsSaasResponse = Saas;

export type PatchProjectsLocationsSaasError = CommonErrors;

export const patchProjectsLocationsSaas: API.OperationMethod<PatchProjectsLocationsSaasRequest, PatchProjectsLocationsSaasResponse, PatchProjectsLocationsSaasError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsSaasRequest,
  output: PatchProjectsLocationsSaasResponse,
  errors: [],
}));

/** Retrieve a collection of saas. */
export interface ListProjectsLocationsSaasRequest {
  /** Filter the list as specified in https://google.aip.dev/160. */
  filter?: string;
  /** The page token: If the next_page_token from a previous response is provided, this request will send the subsequent page. */
  pageToken?: string;
  /** Order results as specified in https://google.aip.dev/132. */
  orderBy?: string;
  /** Required. The parent of the saas. */
  parent: string;
  /** The maximum number of saas to send per page. */
  pageSize?: number;
}

export const ListProjectsLocationsSaasRequest = Schema.Struct({
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy")),
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
}).pipe(
  T.Http({ method: "GET", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/saas" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsSaasRequest>;

export type ListProjectsLocationsSaasResponse = ListSaasResponse;
export const ListProjectsLocationsSaasResponse = ListSaasResponse;

export type ListProjectsLocationsSaasError = CommonErrors;

export const listProjectsLocationsSaas = API.makePaginated(() => ({
  input: ListProjectsLocationsSaasRequest,
  output: ListProjectsLocationsSaasResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Retrieve a collection of units. */
export interface ListProjectsLocationsUnitsRequest {
  /** The page token: If the next_page_token from a previous response is provided, this request will send the subsequent page. */
  pageToken?: string;
  /** Filter the list as specified in https://google.aip.dev/160. */
  filter?: string;
  /** Required. The parent of the unit. */
  parent: string;
  /** Order results as specified in https://google.aip.dev/132. */
  orderBy?: string;
  /** The maximum number of units to send per page. */
  pageSize?: number;
}

export const ListProjectsLocationsUnitsRequest = Schema.Struct({
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  parent: Schema.String.pipe(T.HttpPath("parent")),
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
}).pipe(
  T.Http({ method: "GET", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/units" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsUnitsRequest>;

export type ListProjectsLocationsUnitsResponse = ListUnitsResponse;
export const ListProjectsLocationsUnitsResponse = ListUnitsResponse;

export type ListProjectsLocationsUnitsError = CommonErrors;

export const listProjectsLocationsUnits = API.makePaginated(() => ({
  input: ListProjectsLocationsUnitsRequest,
  output: ListProjectsLocationsUnitsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Update a single unit. */
export interface PatchProjectsLocationsUnitsRequest {
  /** Field mask is used to specify the fields to be overwritten in the Unit resource by the update. The fields specified in the update_mask are relative to the resource, not the full request. A field will be overwritten if it is in the mask. If the user does not provide a mask then all fields in the Unit will be overwritten. */
  updateMask?: string;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** Identifier. The resource name (full URI of the resource) following the standard naming scheme: "projects/{project}/locations/{location}/units/{unit}" */
  name: string;
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** Request body */
  body?: Unit;
}

export const PatchProjectsLocationsUnitsRequest = Schema.Struct({
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  name: Schema.String.pipe(T.HttpPath("name")),
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  body: Schema.optional(Unit).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/units/{unitsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsUnitsRequest>;

export type PatchProjectsLocationsUnitsResponse = Unit;
export const PatchProjectsLocationsUnitsResponse = Unit;

export type PatchProjectsLocationsUnitsError = CommonErrors;

export const patchProjectsLocationsUnits: API.OperationMethod<PatchProjectsLocationsUnitsRequest, PatchProjectsLocationsUnitsResponse, PatchProjectsLocationsUnitsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsUnitsRequest,
  output: PatchProjectsLocationsUnitsResponse,
  errors: [],
}));

/** Retrieve a single unit. */
export interface GetProjectsLocationsUnitsRequest {
  /** Required. The resource name of the resource within a service. */
  name: string;
}

export const GetProjectsLocationsUnitsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/units/{unitsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsUnitsRequest>;

export type GetProjectsLocationsUnitsResponse = Unit;
export const GetProjectsLocationsUnitsResponse = Unit;

export type GetProjectsLocationsUnitsError = CommonErrors;

export const getProjectsLocationsUnits: API.OperationMethod<GetProjectsLocationsUnitsRequest, GetProjectsLocationsUnitsResponse, GetProjectsLocationsUnitsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsUnitsRequest,
  output: GetProjectsLocationsUnitsResponse,
  errors: [],
}));

/** Create a new unit. */
export interface CreateProjectsLocationsUnitsRequest {
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** Required. The ID value for the new unit. */
  unitId?: string;
  /** Required. The parent of the unit. */
  parent: string;
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** Request body */
  body?: Unit;
}

export const CreateProjectsLocationsUnitsRequest = Schema.Struct({
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  unitId: Schema.optional(Schema.String).pipe(T.HttpQuery("unitId")),
  parent: Schema.String.pipe(T.HttpPath("parent")),
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  body: Schema.optional(Unit).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/units", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsUnitsRequest>;

export type CreateProjectsLocationsUnitsResponse = Unit;
export const CreateProjectsLocationsUnitsResponse = Unit;

export type CreateProjectsLocationsUnitsError = CommonErrors;

export const createProjectsLocationsUnits: API.OperationMethod<CreateProjectsLocationsUnitsRequest, CreateProjectsLocationsUnitsResponse, CreateProjectsLocationsUnitsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsUnitsRequest,
  output: CreateProjectsLocationsUnitsResponse,
  errors: [],
}));

/** Delete a single unit. */
export interface DeleteProjectsLocationsUnitsRequest {
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** Required. The resource name of the resource within a service. */
  name: string;
  /** The etag known to the client for the expected state of the unit. This is used with state-changing methods to prevent accidental overwrites when multiple user agents might be acting in parallel on the same resource. An etag wildcard provide optimistic concurrency based on the expected existence of the unit. The Any wildcard (`*`) requires that the resource must already exists, and the Not Any wildcard (`!*`) requires that it must not. */
  etag?: string;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
}

export const DeleteProjectsLocationsUnitsRequest = Schema.Struct({
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  name: Schema.String.pipe(T.HttpPath("name")),
  etag: Schema.optional(Schema.String).pipe(T.HttpQuery("etag")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/units/{unitsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsUnitsRequest>;

export type DeleteProjectsLocationsUnitsResponse = Empty;
export const DeleteProjectsLocationsUnitsResponse = Empty;

export type DeleteProjectsLocationsUnitsError = CommonErrors;

export const deleteProjectsLocationsUnits: API.OperationMethod<DeleteProjectsLocationsUnitsRequest, DeleteProjectsLocationsUnitsResponse, DeleteProjectsLocationsUnitsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsUnitsRequest,
  output: DeleteProjectsLocationsUnitsResponse,
  errors: [],
}));

/** Delete a single rollout kind. */
export interface DeleteProjectsLocationsRolloutKindsRequest {
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** The etag known to the client for the expected state of the rollout kind. This is used with state-changing methods to prevent accidental overwrites when multiple user agents might be acting in parallel on the same resource. An etag wildcard provide optimistic concurrency based on the expected existence of the rollout kind. The Any wildcard (`*`) requires that the resource must already exists, and the Not Any wildcard (`!*`) requires that it must not. */
  etag?: string;
  /** Required. The resource name of the resource within a service. */
  name: string;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
}

export const DeleteProjectsLocationsRolloutKindsRequest = Schema.Struct({
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  etag: Schema.optional(Schema.String).pipe(T.HttpQuery("etag")),
  name: Schema.String.pipe(T.HttpPath("name")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/rolloutKinds/{rolloutKindsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsRolloutKindsRequest>;

export type DeleteProjectsLocationsRolloutKindsResponse = Empty;
export const DeleteProjectsLocationsRolloutKindsResponse = Empty;

export type DeleteProjectsLocationsRolloutKindsError = CommonErrors;

export const deleteProjectsLocationsRolloutKinds: API.OperationMethod<DeleteProjectsLocationsRolloutKindsRequest, DeleteProjectsLocationsRolloutKindsResponse, DeleteProjectsLocationsRolloutKindsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsRolloutKindsRequest,
  output: DeleteProjectsLocationsRolloutKindsResponse,
  errors: [],
}));

/** Retrieve a single rollout kind. */
export interface GetProjectsLocationsRolloutKindsRequest {
  /** Required. The resource name of the resource within a service. */
  name: string;
}

export const GetProjectsLocationsRolloutKindsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/rolloutKinds/{rolloutKindsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsRolloutKindsRequest>;

export type GetProjectsLocationsRolloutKindsResponse = RolloutKind;
export const GetProjectsLocationsRolloutKindsResponse = RolloutKind;

export type GetProjectsLocationsRolloutKindsError = CommonErrors;

export const getProjectsLocationsRolloutKinds: API.OperationMethod<GetProjectsLocationsRolloutKindsRequest, GetProjectsLocationsRolloutKindsResponse, GetProjectsLocationsRolloutKindsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsRolloutKindsRequest,
  output: GetProjectsLocationsRolloutKindsResponse,
  errors: [],
}));

/** Create a new rollout kind. */
export interface CreateProjectsLocationsRolloutKindsRequest {
  /** Required. The parent of the rollout kind. */
  parent: string;
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** Required. The ID value for the new rollout kind. */
  rolloutKindId?: string;
  /** Request body */
  body?: RolloutKind;
}

export const CreateProjectsLocationsRolloutKindsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  rolloutKindId: Schema.optional(Schema.String).pipe(T.HttpQuery("rolloutKindId")),
  body: Schema.optional(RolloutKind).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/rolloutKinds", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsRolloutKindsRequest>;

export type CreateProjectsLocationsRolloutKindsResponse = RolloutKind;
export const CreateProjectsLocationsRolloutKindsResponse = RolloutKind;

export type CreateProjectsLocationsRolloutKindsError = CommonErrors;

export const createProjectsLocationsRolloutKinds: API.OperationMethod<CreateProjectsLocationsRolloutKindsRequest, CreateProjectsLocationsRolloutKindsResponse, CreateProjectsLocationsRolloutKindsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsRolloutKindsRequest,
  output: CreateProjectsLocationsRolloutKindsResponse,
  errors: [],
}));

/** Retrieve a collection of rollout kinds. */
export interface ListProjectsLocationsRolloutKindsRequest {
  /** Order results as specified in https://google.aip.dev/132. */
  orderBy?: string;
  /** The maximum number of rollout kinds to send per page. */
  pageSize?: number;
  /** Required. The parent of the rollout kind. */
  parent: string;
  /** Filter the list as specified in https://google.aip.dev/160. */
  filter?: string;
  /** The page token: If the next_page_token from a previous response is provided, this request will send the subsequent page. */
  pageToken?: string;
}

export const ListProjectsLocationsRolloutKindsRequest = Schema.Struct({
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  parent: Schema.String.pipe(T.HttpPath("parent")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/rolloutKinds" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsRolloutKindsRequest>;

export type ListProjectsLocationsRolloutKindsResponse = ListRolloutKindsResponse;
export const ListProjectsLocationsRolloutKindsResponse = ListRolloutKindsResponse;

export type ListProjectsLocationsRolloutKindsError = CommonErrors;

export const listProjectsLocationsRolloutKinds = API.makePaginated(() => ({
  input: ListProjectsLocationsRolloutKindsRequest,
  output: ListProjectsLocationsRolloutKindsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Update a single rollout kind. */
export interface PatchProjectsLocationsRolloutKindsRequest {
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** Identifier. The resource name (full URI of the resource) following the standard naming scheme: "projects/{project}/locations/{location}/rolloutKinds/{rollout_kind_id}" */
  name: string;
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** Field mask is used to specify the fields to be overwritten in the RolloutKind resource by the update. The fields specified in the update_mask are relative to the resource, not the full request. A field will be overwritten if it is in the mask. If the user does not provide a mask then all fields in the RolloutKind will be overwritten. */
  updateMask?: string;
  /** Request body */
  body?: RolloutKind;
}

export const PatchProjectsLocationsRolloutKindsRequest = Schema.Struct({
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  name: Schema.String.pipe(T.HttpPath("name")),
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  body: Schema.optional(RolloutKind).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/rolloutKinds/{rolloutKindsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsRolloutKindsRequest>;

export type PatchProjectsLocationsRolloutKindsResponse = RolloutKind;
export const PatchProjectsLocationsRolloutKindsResponse = RolloutKind;

export type PatchProjectsLocationsRolloutKindsError = CommonErrors;

export const patchProjectsLocationsRolloutKinds: API.OperationMethod<PatchProjectsLocationsRolloutKindsRequest, PatchProjectsLocationsRolloutKindsResponse, PatchProjectsLocationsRolloutKindsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsRolloutKindsRequest,
  output: PatchProjectsLocationsRolloutKindsResponse,
  errors: [],
}));

/** Delete a single tenant. */
export interface DeleteProjectsLocationsTenantsRequest {
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** The etag known to the client for the expected state of the tenant. This is used with state-changing methods to prevent accidental overwrites when multiple user agents might be acting in parallel on the same resource. An etag wildcard provide optimistic concurrency based on the expected existence of the tenant. The Any wildcard (`*`) requires that the resource must already exists, and the Not Any wildcard (`!*`) requires that it must not. */
  etag?: string;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** Required. The resource name of the resource within a service. */
  name: string;
}

export const DeleteProjectsLocationsTenantsRequest = Schema.Struct({
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  etag: Schema.optional(Schema.String).pipe(T.HttpQuery("etag")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/tenants/{tenantsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsTenantsRequest>;

export type DeleteProjectsLocationsTenantsResponse = Empty;
export const DeleteProjectsLocationsTenantsResponse = Empty;

export type DeleteProjectsLocationsTenantsError = CommonErrors;

export const deleteProjectsLocationsTenants: API.OperationMethod<DeleteProjectsLocationsTenantsRequest, DeleteProjectsLocationsTenantsResponse, DeleteProjectsLocationsTenantsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsTenantsRequest,
  output: DeleteProjectsLocationsTenantsResponse,
  errors: [],
}));

/** Update a single tenant. */
export interface PatchProjectsLocationsTenantsRequest {
  /** Identifier. The resource name (full URI of the resource) following the standard naming scheme: "projects/{project}/locations/{location}/tenants/{tenant}" */
  name: string;
  /** Field mask is used to specify the fields to be overwritten in the Tenant resource by the update. The fields specified in the update_mask are relative to the resource, not the full request. A field will be overwritten if it is in the mask. If the user does not provide a mask then all fields in the Tenant will be overwritten. */
  updateMask?: string;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** Request body */
  body?: Tenant;
}

export const PatchProjectsLocationsTenantsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  body: Schema.optional(Tenant).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/tenants/{tenantsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsTenantsRequest>;

export type PatchProjectsLocationsTenantsResponse = Tenant;
export const PatchProjectsLocationsTenantsResponse = Tenant;

export type PatchProjectsLocationsTenantsError = CommonErrors;

export const patchProjectsLocationsTenants: API.OperationMethod<PatchProjectsLocationsTenantsRequest, PatchProjectsLocationsTenantsResponse, PatchProjectsLocationsTenantsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsTenantsRequest,
  output: PatchProjectsLocationsTenantsResponse,
  errors: [],
}));

/** Retrieve a single tenant. */
export interface GetProjectsLocationsTenantsRequest {
  /** Required. The resource name of the resource within a service. */
  name: string;
}

export const GetProjectsLocationsTenantsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/tenants/{tenantsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsTenantsRequest>;

export type GetProjectsLocationsTenantsResponse = Tenant;
export const GetProjectsLocationsTenantsResponse = Tenant;

export type GetProjectsLocationsTenantsError = CommonErrors;

export const getProjectsLocationsTenants: API.OperationMethod<GetProjectsLocationsTenantsRequest, GetProjectsLocationsTenantsResponse, GetProjectsLocationsTenantsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsTenantsRequest,
  output: GetProjectsLocationsTenantsResponse,
  errors: [],
}));

/** Create a new tenant. */
export interface CreateProjectsLocationsTenantsRequest {
  /** Required. The parent of the tenant. */
  parent: string;
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** Required. The ID value for the new tenant. */
  tenantId?: string;
  /** Request body */
  body?: Tenant;
}

export const CreateProjectsLocationsTenantsRequest = Schema.Struct({
  parent: Schema.String.pipe(T.HttpPath("parent")),
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  tenantId: Schema.optional(Schema.String).pipe(T.HttpQuery("tenantId")),
  body: Schema.optional(Tenant).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/tenants", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsTenantsRequest>;

export type CreateProjectsLocationsTenantsResponse = Tenant;
export const CreateProjectsLocationsTenantsResponse = Tenant;

export type CreateProjectsLocationsTenantsError = CommonErrors;

export const createProjectsLocationsTenants: API.OperationMethod<CreateProjectsLocationsTenantsRequest, CreateProjectsLocationsTenantsResponse, CreateProjectsLocationsTenantsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsTenantsRequest,
  output: CreateProjectsLocationsTenantsResponse,
  errors: [],
}));

/** Retrieve a collection of tenants. */
export interface ListProjectsLocationsTenantsRequest {
  /** Order results as specified in https://google.aip.dev/132. */
  orderBy?: string;
  /** Required. The parent of the tenant. */
  parent: string;
  /** The maximum number of tenants to send per page. */
  pageSize?: number;
  /** Filter the list as specified in https://google.aip.dev/160. */
  filter?: string;
  /** The page token: If the next_page_token from a previous response is provided, this request will send the subsequent page. */
  pageToken?: string;
}

export const ListProjectsLocationsTenantsRequest = Schema.Struct({
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy")),
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/tenants" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsTenantsRequest>;

export type ListProjectsLocationsTenantsResponse = ListTenantsResponse;
export const ListProjectsLocationsTenantsResponse = ListTenantsResponse;

export type ListProjectsLocationsTenantsError = CommonErrors;

export const listProjectsLocationsTenants = API.makePaginated(() => ({
  input: ListProjectsLocationsTenantsRequest,
  output: ListProjectsLocationsTenantsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Create a new unit kind. */
export interface CreateProjectsLocationsUnitKindsRequest {
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** Required. The parent of the unit kind. */
  parent: string;
  /** Required. The ID value for the new unit kind. */
  unitKindId?: string;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** Request body */
  body?: UnitKind;
}

export const CreateProjectsLocationsUnitKindsRequest = Schema.Struct({
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  parent: Schema.String.pipe(T.HttpPath("parent")),
  unitKindId: Schema.optional(Schema.String).pipe(T.HttpQuery("unitKindId")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  body: Schema.optional(UnitKind).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/unitKinds", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsUnitKindsRequest>;

export type CreateProjectsLocationsUnitKindsResponse = UnitKind;
export const CreateProjectsLocationsUnitKindsResponse = UnitKind;

export type CreateProjectsLocationsUnitKindsError = CommonErrors;

export const createProjectsLocationsUnitKinds: API.OperationMethod<CreateProjectsLocationsUnitKindsRequest, CreateProjectsLocationsUnitKindsResponse, CreateProjectsLocationsUnitKindsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsUnitKindsRequest,
  output: CreateProjectsLocationsUnitKindsResponse,
  errors: [],
}));

/** Retrieve a single unit kind. */
export interface GetProjectsLocationsUnitKindsRequest {
  /** Required. The resource name of the resource within a service. */
  name: string;
}

export const GetProjectsLocationsUnitKindsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/unitKinds/{unitKindsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsUnitKindsRequest>;

export type GetProjectsLocationsUnitKindsResponse = UnitKind;
export const GetProjectsLocationsUnitKindsResponse = UnitKind;

export type GetProjectsLocationsUnitKindsError = CommonErrors;

export const getProjectsLocationsUnitKinds: API.OperationMethod<GetProjectsLocationsUnitKindsRequest, GetProjectsLocationsUnitKindsResponse, GetProjectsLocationsUnitKindsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsUnitKindsRequest,
  output: GetProjectsLocationsUnitKindsResponse,
  errors: [],
}));

/** Delete a single unit kind. */
export interface DeleteProjectsLocationsUnitKindsRequest {
  /** The etag known to the client for the expected state of the unit kind. This is used with state-changing methods to prevent accidental overwrites when multiple user agents might be acting in parallel on the same resource. An etag wildcard provide optimistic concurrency based on the expected existence of the unit kind. The Any wildcard (`*`) requires that the resource must already exists, and the Not Any wildcard (`!*`) requires that it must not. */
  etag?: string;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** Required. The resource name of the resource within a service. */
  name: string;
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
}

export const DeleteProjectsLocationsUnitKindsRequest = Schema.Struct({
  etag: Schema.optional(Schema.String).pipe(T.HttpQuery("etag")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  name: Schema.String.pipe(T.HttpPath("name")),
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/unitKinds/{unitKindsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsUnitKindsRequest>;

export type DeleteProjectsLocationsUnitKindsResponse = Empty;
export const DeleteProjectsLocationsUnitKindsResponse = Empty;

export type DeleteProjectsLocationsUnitKindsError = CommonErrors;

export const deleteProjectsLocationsUnitKinds: API.OperationMethod<DeleteProjectsLocationsUnitKindsRequest, DeleteProjectsLocationsUnitKindsResponse, DeleteProjectsLocationsUnitKindsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsUnitKindsRequest,
  output: DeleteProjectsLocationsUnitKindsResponse,
  errors: [],
}));

/** Update a single unit kind. */
export interface PatchProjectsLocationsUnitKindsRequest {
  /** Field mask is used to specify the fields to be overwritten in the UnitKind resource by the update. The fields specified in the update_mask are relative to the resource, not the full request. A field will be overwritten if it is in the mask. If the user does not provide a mask then all fields in the UnitKind will be overwritten. */
  updateMask?: string;
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** Identifier. The resource name (full URI of the resource) following the standard naming scheme: "projects/{project}/locations/{location}/unitKinds/{unitKind}" */
  name: string;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** Request body */
  body?: UnitKind;
}

export const PatchProjectsLocationsUnitKindsRequest = Schema.Struct({
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  name: Schema.String.pipe(T.HttpPath("name")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  body: Schema.optional(UnitKind).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/unitKinds/{unitKindsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsUnitKindsRequest>;

export type PatchProjectsLocationsUnitKindsResponse = UnitKind;
export const PatchProjectsLocationsUnitKindsResponse = UnitKind;

export type PatchProjectsLocationsUnitKindsError = CommonErrors;

export const patchProjectsLocationsUnitKinds: API.OperationMethod<PatchProjectsLocationsUnitKindsRequest, PatchProjectsLocationsUnitKindsResponse, PatchProjectsLocationsUnitKindsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsUnitKindsRequest,
  output: PatchProjectsLocationsUnitKindsResponse,
  errors: [],
}));

/** Retrieve a collection of unit kinds. */
export interface ListProjectsLocationsUnitKindsRequest {
  /** Filter the list as specified in https://google.aip.dev/160. */
  filter?: string;
  /** The page token: If the next_page_token from a previous response is provided, this request will send the subsequent page. */
  pageToken?: string;
  /** Required. The parent of the unit kind. */
  parent: string;
  /** Order results as specified in https://google.aip.dev/132. */
  orderBy?: string;
  /** The maximum number of unit kinds to send per page. */
  pageSize?: number;
}

export const ListProjectsLocationsUnitKindsRequest = Schema.Struct({
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  parent: Schema.String.pipe(T.HttpPath("parent")),
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
}).pipe(
  T.Http({ method: "GET", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/unitKinds" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsUnitKindsRequest>;

export type ListProjectsLocationsUnitKindsResponse = ListUnitKindsResponse;
export const ListProjectsLocationsUnitKindsResponse = ListUnitKindsResponse;

export type ListProjectsLocationsUnitKindsError = CommonErrors;

export const listProjectsLocationsUnitKinds = API.makePaginated(() => ({
  input: ListProjectsLocationsUnitKindsRequest,
  output: ListProjectsLocationsUnitKindsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Retrieve a single rollout. */
export interface GetProjectsLocationsRolloutsRequest {
  /** Required. The resource name of the resource within a service. */
  name: string;
}

export const GetProjectsLocationsRolloutsRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/rollouts/{rolloutsId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsRolloutsRequest>;

export type GetProjectsLocationsRolloutsResponse = Rollout;
export const GetProjectsLocationsRolloutsResponse = Rollout;

export type GetProjectsLocationsRolloutsError = CommonErrors;

export const getProjectsLocationsRollouts: API.OperationMethod<GetProjectsLocationsRolloutsRequest, GetProjectsLocationsRolloutsResponse, GetProjectsLocationsRolloutsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsRolloutsRequest,
  output: GetProjectsLocationsRolloutsResponse,
  errors: [],
}));

/** Update a single rollout. */
export interface PatchProjectsLocationsRolloutsRequest {
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** Field mask is used to specify the fields to be overwritten in the Rollout resource by the update. The fields specified in the update_mask are relative to the resource, not the full request. A field will be overwritten if it is in the mask. If the user does not provide a mask then all fields in the Rollout will be overwritten. */
  updateMask?: string;
  /** Identifier. The resource name (full URI of the resource) following the standard naming scheme: "projects/{project}/locations/{location}/rollout/{rollout_id}" */
  name: string;
  /** Request body */
  body?: Rollout;
}

export const PatchProjectsLocationsRolloutsRequest = Schema.Struct({
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  name: Schema.String.pipe(T.HttpPath("name")),
  body: Schema.optional(Rollout).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/rollouts/{rolloutsId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsRolloutsRequest>;

export type PatchProjectsLocationsRolloutsResponse = Rollout;
export const PatchProjectsLocationsRolloutsResponse = Rollout;

export type PatchProjectsLocationsRolloutsError = CommonErrors;

export const patchProjectsLocationsRollouts: API.OperationMethod<PatchProjectsLocationsRolloutsRequest, PatchProjectsLocationsRolloutsResponse, PatchProjectsLocationsRolloutsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsRolloutsRequest,
  output: PatchProjectsLocationsRolloutsResponse,
  errors: [],
}));

/** Delete a single rollout. */
export interface DeleteProjectsLocationsRolloutsRequest {
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** Required. The resource name of the resource within a service. */
  name: string;
  /** The etag known to the client for the expected state of the rollout. This is used with state-changing methods to prevent accidental overwrites when multiple user agents might be acting in parallel on the same resource. An etag wildcard provide optimistic concurrency based on the expected existence of the rollout. The Any wildcard (`*`) requires that the resource must already exists, and the Not Any wildcard (`!*`) requires that it must not. */
  etag?: string;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
}

export const DeleteProjectsLocationsRolloutsRequest = Schema.Struct({
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  name: Schema.String.pipe(T.HttpPath("name")),
  etag: Schema.optional(Schema.String).pipe(T.HttpQuery("etag")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/rollouts/{rolloutsId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsRolloutsRequest>;

export type DeleteProjectsLocationsRolloutsResponse = Empty;
export const DeleteProjectsLocationsRolloutsResponse = Empty;

export type DeleteProjectsLocationsRolloutsError = CommonErrors;

export const deleteProjectsLocationsRollouts: API.OperationMethod<DeleteProjectsLocationsRolloutsRequest, DeleteProjectsLocationsRolloutsResponse, DeleteProjectsLocationsRolloutsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsRolloutsRequest,
  output: DeleteProjectsLocationsRolloutsResponse,
  errors: [],
}));

/** Retrieve a collection of rollouts. */
export interface ListProjectsLocationsRolloutsRequest {
  /** Filter the list as specified in https://google.aip.dev/160. */
  filter?: string;
  /** Order results as specified in https://google.aip.dev/132. */
  orderBy?: string;
  /** Required. The parent of the rollout. */
  parent: string;
  /** The maximum number of rollouts to send per page. */
  pageSize?: number;
  /** The page token: If the next_page_token from a previous response is provided, this request will send the subsequent page. */
  pageToken?: string;
}

export const ListProjectsLocationsRolloutsRequest = Schema.Struct({
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy")),
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
}).pipe(
  T.Http({ method: "GET", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/rollouts" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsRolloutsRequest>;

export type ListProjectsLocationsRolloutsResponse = ListRolloutsResponse;
export const ListProjectsLocationsRolloutsResponse = ListRolloutsResponse;

export type ListProjectsLocationsRolloutsError = CommonErrors;

export const listProjectsLocationsRollouts = API.makePaginated(() => ({
  input: ListProjectsLocationsRolloutsRequest,
  output: ListProjectsLocationsRolloutsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Create a new rollout. */
export interface CreateProjectsLocationsRolloutsRequest {
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** Required. The parent of the rollout. */
  parent: string;
  /** Required. The ID value for the new rollout. */
  rolloutId?: string;
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** Request body */
  body?: Rollout;
}

export const CreateProjectsLocationsRolloutsRequest = Schema.Struct({
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  parent: Schema.String.pipe(T.HttpPath("parent")),
  rolloutId: Schema.optional(Schema.String).pipe(T.HttpQuery("rolloutId")),
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  body: Schema.optional(Rollout).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/rollouts", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsRolloutsRequest>;

export type CreateProjectsLocationsRolloutsResponse = Rollout;
export const CreateProjectsLocationsRolloutsResponse = Rollout;

export type CreateProjectsLocationsRolloutsError = CommonErrors;

export const createProjectsLocationsRollouts: API.OperationMethod<CreateProjectsLocationsRolloutsRequest, CreateProjectsLocationsRolloutsResponse, CreateProjectsLocationsRolloutsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsRolloutsRequest,
  output: CreateProjectsLocationsRolloutsResponse,
  errors: [],
}));

/** Retrieve a single release. */
export interface GetProjectsLocationsReleasesRequest {
  /** Required. The resource name of the resource within a service. */
  name: string;
}

export const GetProjectsLocationsReleasesRequest = Schema.Struct({
  name: Schema.String.pipe(T.HttpPath("name")),
}).pipe(
  T.Http({ method: "GET", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/releases/{releasesId}" }),
  svc,
) as unknown as Schema.Schema<GetProjectsLocationsReleasesRequest>;

export type GetProjectsLocationsReleasesResponse = Release;
export const GetProjectsLocationsReleasesResponse = Release;

export type GetProjectsLocationsReleasesError = CommonErrors;

export const getProjectsLocationsReleases: API.OperationMethod<GetProjectsLocationsReleasesRequest, GetProjectsLocationsReleasesResponse, GetProjectsLocationsReleasesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetProjectsLocationsReleasesRequest,
  output: GetProjectsLocationsReleasesResponse,
  errors: [],
}));

/** Create a new release. */
export interface CreateProjectsLocationsReleasesRequest {
  /** Required. The ID value for the new release. */
  releaseId?: string;
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** Required. The parent of the release. */
  parent: string;
  /** Request body */
  body?: Release;
}

export const CreateProjectsLocationsReleasesRequest = Schema.Struct({
  releaseId: Schema.optional(Schema.String).pipe(T.HttpQuery("releaseId")),
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  parent: Schema.String.pipe(T.HttpPath("parent")),
  body: Schema.optional(Release).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/releases", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateProjectsLocationsReleasesRequest>;

export type CreateProjectsLocationsReleasesResponse = Release;
export const CreateProjectsLocationsReleasesResponse = Release;

export type CreateProjectsLocationsReleasesError = CommonErrors;

export const createProjectsLocationsReleases: API.OperationMethod<CreateProjectsLocationsReleasesRequest, CreateProjectsLocationsReleasesResponse, CreateProjectsLocationsReleasesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateProjectsLocationsReleasesRequest,
  output: CreateProjectsLocationsReleasesResponse,
  errors: [],
}));

/** Retrieve a collection of releases. */
export interface ListProjectsLocationsReleasesRequest {
  /** The maximum number of releases to send per page. */
  pageSize?: number;
  /** Required. The parent of the release. */
  parent: string;
  /** The page token: If the next_page_token from a previous response is provided, this request will send the subsequent page. */
  pageToken?: string;
  /** Filter the list as specified in https://google.aip.dev/160. */
  filter?: string;
  /** Order results as specified in https://google.aip.dev/132. */
  orderBy?: string;
}

export const ListProjectsLocationsReleasesRequest = Schema.Struct({
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  parent: Schema.String.pipe(T.HttpPath("parent")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  filter: Schema.optional(Schema.String).pipe(T.HttpQuery("filter")),
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy")),
}).pipe(
  T.Http({ method: "GET", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/releases" }),
  svc,
) as unknown as Schema.Schema<ListProjectsLocationsReleasesRequest>;

export type ListProjectsLocationsReleasesResponse = ListReleasesResponse;
export const ListProjectsLocationsReleasesResponse = ListReleasesResponse;

export type ListProjectsLocationsReleasesError = CommonErrors;

export const listProjectsLocationsReleases = API.makePaginated(() => ({
  input: ListProjectsLocationsReleasesRequest,
  output: ListProjectsLocationsReleasesResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Update a single release. */
export interface PatchProjectsLocationsReleasesRequest {
  /** Field mask is used to specify the fields to be overwritten in the Release resource by the update. The fields specified in the update_mask are relative to the resource, not the full request. A field will be overwritten if it is in the mask. If the user does not provide a mask then all fields in the Release will be overwritten. */
  updateMask?: string;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** Identifier. The resource name (full URI of the resource) following the standard naming scheme: "projects/{project}/locations/{location}/releases/{release}" */
  name: string;
  /** Request body */
  body?: Release;
}

export const PatchProjectsLocationsReleasesRequest = Schema.Struct({
  updateMask: Schema.optional(Schema.String).pipe(T.HttpQuery("updateMask")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  name: Schema.String.pipe(T.HttpPath("name")),
  body: Schema.optional(Release).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "PATCH", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/releases/{releasesId}", hasBody: true }),
  svc,
) as unknown as Schema.Schema<PatchProjectsLocationsReleasesRequest>;

export type PatchProjectsLocationsReleasesResponse = Release;
export const PatchProjectsLocationsReleasesResponse = Release;

export type PatchProjectsLocationsReleasesError = CommonErrors;

export const patchProjectsLocationsReleases: API.OperationMethod<PatchProjectsLocationsReleasesRequest, PatchProjectsLocationsReleasesResponse, PatchProjectsLocationsReleasesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: PatchProjectsLocationsReleasesRequest,
  output: PatchProjectsLocationsReleasesResponse,
  errors: [],
}));

/** Delete a single release. */
export interface DeleteProjectsLocationsReleasesRequest {
  /** If "validate_only" is set to true, the service will try to validate that this request would succeed, but will not actually make changes. */
  validateOnly?: boolean;
  /** An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000). */
  requestId?: string;
  /** Required. The resource name of the resource within a service. */
  name: string;
  /** The etag known to the client for the expected state of the release. This is used with state-changing methods to prevent accidental overwrites when multiple user agents might be acting in parallel on the same resource. An etag wildcard provide optimistic concurrency based on the expected existence of the release. The Any wildcard (`*`) requires that the resource must already exists, and the Not Any wildcard (`!*`) requires that it must not. */
  etag?: string;
}

export const DeleteProjectsLocationsReleasesRequest = Schema.Struct({
  validateOnly: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("validateOnly")),
  requestId: Schema.optional(Schema.String).pipe(T.HttpQuery("requestId")),
  name: Schema.String.pipe(T.HttpPath("name")),
  etag: Schema.optional(Schema.String).pipe(T.HttpQuery("etag")),
}).pipe(
  T.Http({ method: "DELETE", path: "v1beta1/projects/{projectsId}/locations/{locationsId}/releases/{releasesId}" }),
  svc,
) as unknown as Schema.Schema<DeleteProjectsLocationsReleasesRequest>;

export type DeleteProjectsLocationsReleasesResponse = Empty;
export const DeleteProjectsLocationsReleasesResponse = Empty;

export type DeleteProjectsLocationsReleasesError = CommonErrors;

export const deleteProjectsLocationsReleases: API.OperationMethod<DeleteProjectsLocationsReleasesRequest, DeleteProjectsLocationsReleasesResponse, DeleteProjectsLocationsReleasesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteProjectsLocationsReleasesRequest,
  output: DeleteProjectsLocationsReleasesResponse,
  errors: [],
}));

