// ==========================================================================
// DoubleClick Bid Manager API (doubleclickbidmanager v2)
// DO NOT EDIT - Generated from GCP Discovery Document
// ==========================================================================

import * as Schema from "effect/Schema";
import * as API from "../client/api.ts";
import * as T from "../traits.ts";
import * as C from "../category.ts";
import type { GCPAuth } from "../auth.ts";
import type { CommonErrors } from "../errors.ts";
import type * as HttpClient from "effect/unstable/http/HttpClient";

// Service metadata
const svc = T.Service({
  name: "doubleclickbidmanager",
  version: "v2",
  rootUrl: "https://doubleclickbidmanager.googleapis.com/",
  servicePath: "v2/",
});

// ==========================================================================
// Schemas
// ==========================================================================

export interface Doubleclickbidmanager_Date {
  /** Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year. */
  year?: number;
  /** Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day. */
  month?: number;
  /** Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant. */
  day?: number;
}

export const Doubleclickbidmanager_Date: Schema.Schema<Doubleclickbidmanager_Date> = Schema.suspend(() => Schema.Struct({
  year: Schema.optional(Schema.Number),
  month: Schema.optional(Schema.Number),
  day: Schema.optional(Schema.Number),
})).annotate({ identifier: "Doubleclickbidmanager_Date" }) as any as Schema.Schema<Doubleclickbidmanager_Date>;

export interface DataRange {
  /** The preset date range to be reported on. If `CUSTOM_DATES` is assigned to this field, fields custom_start_date and custom_end_date must be set to specify the custom date range. */
  range?: "RANGE_UNSPECIFIED" | "CUSTOM_DATES" | "CURRENT_DAY" | "PREVIOUS_DAY" | "WEEK_TO_DATE" | "MONTH_TO_DATE" | "QUARTER_TO_DATE" | "YEAR_TO_DATE" | "PREVIOUS_WEEK" | "PREVIOUS_MONTH" | "PREVIOUS_QUARTER" | "PREVIOUS_YEAR" | "LAST_7_DAYS" | "LAST_30_DAYS" | "LAST_90_DAYS" | "LAST_365_DAYS" | "ALL_TIME" | "LAST_14_DAYS" | "LAST_60_DAYS" | (string & {});
  /** If `CUSTOM_DATES` is assigned to range, this field specifies the starting date for the date range that is reported on. This field is required if using `CUSTOM_DATES` range and will be ignored otherwise. */
  customStartDate?: Doubleclickbidmanager_Date;
  /** If `CUSTOM_DATES` is assigned to range, this field specifies the end date for the date range that is reported on. This field is required if using `CUSTOM_DATES` range and will be ignored otherwise. */
  customEndDate?: Doubleclickbidmanager_Date;
}

export const DataRange: Schema.Schema<DataRange> = Schema.suspend(() => Schema.Struct({
  range: Schema.optional(Schema.String),
  customStartDate: Schema.optional(Doubleclickbidmanager_Date),
  customEndDate: Schema.optional(Doubleclickbidmanager_Date),
})).annotate({ identifier: "DataRange" }) as any as Schema.Schema<DataRange>;

export interface QueryMetadata {
  /** The display name of the query. This value will be used in the file name of reports generated by the query. */
  title?: string;
  /** The date range the report generated by the query will report on. This date range will be defined by the time zone as used by the advertiser. */
  dataRange?: DataRange;
  /** The format of the report generated by the query. */
  format?: "FORMAT_UNSPECIFIED" | "CSV" | "XLSX" | (string & {});
  /** Whether an email notification is sent to the query creator when a report generated by the query is ready. This value is `false` by default. */
  sendNotification?: boolean;
  /** List of additional email addresses with which to share the query. If send_notification is `true`, these email addresses will receive a notification when a report generated by the query is ready. If these email addresses are connected to Display & Video 360 users, the query will be available to them in the Display & Video 360 interface. */
  shareEmailAddress?: Array<string>;
}

export const QueryMetadata: Schema.Schema<QueryMetadata> = Schema.suspend(() => Schema.Struct({
  title: Schema.optional(Schema.String),
  dataRange: Schema.optional(DataRange),
  format: Schema.optional(Schema.String),
  sendNotification: Schema.optional(Schema.Boolean),
  shareEmailAddress: Schema.optional(Schema.Array(Schema.String)),
})).annotate({ identifier: "QueryMetadata" }) as any as Schema.Schema<QueryMetadata>;

export interface FilterPair {
  /** The type of value to filter by. Defined by a [Filter](/bid-manager/reference/rest/v2/filters-metrics#filters) value. */
  type?: string;
  /** The identifying value to filter by, such as a relevant resource ID. */
  value?: string;
}

export const FilterPair: Schema.Schema<FilterPair> = Schema.suspend(() => Schema.Struct({
  type: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String),
})).annotate({ identifier: "FilterPair" }) as any as Schema.Schema<FilterPair>;

export interface Options {
  /** Whether to include data for audience lists specifically targeted by filtered line items or insertion orders. Requires the use of `FILTER_INSERTION_ORDER` or `FILTER_LINE_ITEM` filters. */
  includeOnlyTargetedUserLists?: boolean;
}

export const Options: Schema.Schema<Options> = Schema.suspend(() => Schema.Struct({
  includeOnlyTargetedUserLists: Schema.optional(Schema.Boolean),
})).annotate({ identifier: "Options" }) as any as Schema.Schema<Options>;

export interface Parameters {
  /** The type of the report. The type of the report determines the dimesions, filters, and metrics that can be used. */
  type?: "REPORT_TYPE_UNSPECIFIED" | "STANDARD" | "INVENTORY_AVAILABILITY" | "AUDIENCE_COMPOSITION" | "FLOODLIGHT" | "YOUTUBE" | "GRP" | "YOUTUBE_PROGRAMMATIC_GUARANTEED" | "REACH" | "UNIQUE_REACH_AUDIENCE" | "FULL_PATH" | "PATH_ATTRIBUTION" | (string & {});
  /** Dimensions by which to segment and group the data. Defined by [Filter](/bid-manager/reference/rest/v2/filters-metrics#filters) values. */
  groupBys?: Array<string>;
  /** Filters to limit the scope of reported data. */
  filters?: Array<FilterPair>;
  /** Metrics to define the data populating the report. Defined by [Metric](/bid-manager/reference/rest/v2/filters-metrics#metrics) values. */
  metrics?: Array<string>;
  /** Additional report parameter options. */
  options?: Options;
}

export const Parameters: Schema.Schema<Parameters> = Schema.suspend(() => Schema.Struct({
  type: Schema.optional(Schema.String),
  groupBys: Schema.optional(Schema.Array(Schema.String)),
  filters: Schema.optional(Schema.Array(FilterPair)),
  metrics: Schema.optional(Schema.Array(Schema.String)),
  options: Schema.optional(Options),
})).annotate({ identifier: "Parameters" }) as any as Schema.Schema<Parameters>;

export interface QuerySchedule {
  /** The date on which to begin the scheduled runs. This field is required if frequency is not set to `ONE_TIME`. Otherwise, it will be ignored. */
  startDate?: Doubleclickbidmanager_Date;
  /** The date on which to end the scheduled runs. This field is required if frequency is not set to `ONE_TIME`. Otherwise, it will be ignored. */
  endDate?: Doubleclickbidmanager_Date;
  /** How frequently to run the query. If set to `ONE_TIME`, the query will only be run when queries.run is called. */
  frequency?: "FREQUENCY_UNSPECIFIED" | "ONE_TIME" | "DAILY" | "WEEKLY" | "SEMI_MONTHLY" | "MONTHLY" | "QUARTERLY" | "YEARLY" | (string & {});
  /** The canonical code for the timezone the query schedule is based on. Scheduled runs are usually conducted in the morning of a given day. Defaults to `America/New_York`. */
  nextRunTimezoneCode?: string;
}

export const QuerySchedule: Schema.Schema<QuerySchedule> = Schema.suspend(() => Schema.Struct({
  startDate: Schema.optional(Doubleclickbidmanager_Date),
  endDate: Schema.optional(Doubleclickbidmanager_Date),
  frequency: Schema.optional(Schema.String),
  nextRunTimezoneCode: Schema.optional(Schema.String),
})).annotate({ identifier: "QuerySchedule" }) as any as Schema.Schema<QuerySchedule>;

export interface Query {
  /** Output only. The unique ID of the query. */
  queryId?: string;
  /** The metadata of the query. */
  metadata?: QueryMetadata;
  /** The parameters of the report generated by the query. */
  params?: Parameters;
  /** When and how often the query is scheduled to run. If the frequency field is set to `ONE_TIME`, the query will only run when queries.run is called. */
  schedule?: QuerySchedule;
}

export const Query: Schema.Schema<Query> = Schema.suspend(() => Schema.Struct({
  queryId: Schema.optional(Schema.String),
  metadata: Schema.optional(QueryMetadata),
  params: Schema.optional(Parameters),
  schedule: Schema.optional(QuerySchedule),
})).annotate({ identifier: "Query" }) as any as Schema.Schema<Query>;

export interface ListQueriesResponse {
  /** The list of queries. This field will be absent if empty. */
  queries?: Array<Query>;
  /** A token to retrieve the next page of results. Pass this value in the page_token field in the subsequent call to `queries.list` method to retrieve the next page of results. */
  nextPageToken?: string;
}

export const ListQueriesResponse: Schema.Schema<ListQueriesResponse> = Schema.suspend(() => Schema.Struct({
  queries: Schema.optional(Schema.Array(Query)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "ListQueriesResponse" }) as any as Schema.Schema<ListQueriesResponse>;

export interface RunQueryRequest {
  /** The date range used by the query to generate the report. If unspecified, the query's original data_range is used. */
  dataRange?: DataRange;
}

export const RunQueryRequest: Schema.Schema<RunQueryRequest> = Schema.suspend(() => Schema.Struct({
  dataRange: Schema.optional(DataRange),
})).annotate({ identifier: "RunQueryRequest" }) as any as Schema.Schema<RunQueryRequest>;

export interface ReportKey {
  /** Output only. The unique ID of the query that generated the report. */
  queryId?: string;
  /** Output only. The unique ID of the report. */
  reportId?: string;
}

export const ReportKey: Schema.Schema<ReportKey> = Schema.suspend(() => Schema.Struct({
  queryId: Schema.optional(Schema.String),
  reportId: Schema.optional(Schema.String),
})).annotate({ identifier: "ReportKey" }) as any as Schema.Schema<ReportKey>;

export interface ReportStatus {
  /** Output only. The state of the report generation. */
  state?: "STATE_UNSPECIFIED" | "QUEUED" | "RUNNING" | "DONE" | "FAILED" | (string & {});
  /** Output only. The timestamp of when report generation finished successfully or in failure. This field will not be set unless state is `DONE` or `FAILED`. */
  finishTime?: string;
  /** The format of the generated report file. */
  format?: "FORMAT_UNSPECIFIED" | "CSV" | "XLSX" | (string & {});
}

export const ReportStatus: Schema.Schema<ReportStatus> = Schema.suspend(() => Schema.Struct({
  state: Schema.optional(Schema.String),
  finishTime: Schema.optional(Schema.String),
  format: Schema.optional(Schema.String),
})).annotate({ identifier: "ReportStatus" }) as any as Schema.Schema<ReportStatus>;

export interface ReportMetadata {
  /** The status of the report. */
  status?: ReportStatus;
  /** The start date of the report data date range. */
  reportDataStartDate?: Doubleclickbidmanager_Date;
  /** The end date of the report data date range. */
  reportDataEndDate?: Doubleclickbidmanager_Date;
  /** Output only. The location of the generated report file in Google Cloud Storage. This field will be absent if status.state is not `DONE`. */
  googleCloudStoragePath?: string;
}

export const ReportMetadata: Schema.Schema<ReportMetadata> = Schema.suspend(() => Schema.Struct({
  status: Schema.optional(ReportStatus),
  reportDataStartDate: Schema.optional(Doubleclickbidmanager_Date),
  reportDataEndDate: Schema.optional(Doubleclickbidmanager_Date),
  googleCloudStoragePath: Schema.optional(Schema.String),
})).annotate({ identifier: "ReportMetadata" }) as any as Schema.Schema<ReportMetadata>;

export interface Report {
  /** The key information identifying the report. */
  key?: ReportKey;
  /** The metadata of the report. */
  metadata?: ReportMetadata;
  /** The parameters of the report. */
  params?: Parameters;
}

export const Report: Schema.Schema<Report> = Schema.suspend(() => Schema.Struct({
  key: Schema.optional(ReportKey),
  metadata: Schema.optional(ReportMetadata),
  params: Schema.optional(Parameters),
})).annotate({ identifier: "Report" }) as any as Schema.Schema<Report>;

export interface ListReportsResponse {
  /** The list of reports. This field will be absent if empty. */
  reports?: Array<Report>;
  /** A token to retrieve the next page of results. Pass this value in the page_token field in the subsequent call to `queries.reports.list` method to retrieve the next page of results. */
  nextPageToken?: string;
}

export const ListReportsResponse: Schema.Schema<ListReportsResponse> = Schema.suspend(() => Schema.Struct({
  reports: Schema.optional(Schema.Array(Report)),
  nextPageToken: Schema.optional(Schema.String),
})).annotate({ identifier: "ListReportsResponse" }) as any as Schema.Schema<ListReportsResponse>;

// ==========================================================================
// Operations
// ==========================================================================

/** Creates a new query. */
export interface CreateQueriesRequest {
  /** Request body */
  body?: Query;
}

export const CreateQueriesRequest = Schema.Struct({
  body: Schema.optional(Query).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "queries", hasBody: true }),
  svc,
) as unknown as Schema.Schema<CreateQueriesRequest>;

export type CreateQueriesResponse = Query;
export const CreateQueriesResponse = Query;

export type CreateQueriesError = CommonErrors;

export const createQueries: API.OperationMethod<CreateQueriesRequest, CreateQueriesResponse, CreateQueriesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: CreateQueriesRequest,
  output: CreateQueriesResponse,
  errors: [],
}));

/** Deletes an existing query as well as its generated reports. */
export interface DeleteQueriesRequest {
  /** Required. The ID of the query to delete. */
  queryId: string;
}

export const DeleteQueriesRequest = Schema.Struct({
  queryId: Schema.String.pipe(T.HttpPath("queryId")),
}).pipe(
  T.Http({ method: "DELETE", path: "queries/{queryId}" }),
  svc,
) as unknown as Schema.Schema<DeleteQueriesRequest>;

export interface DeleteQueriesResponse {}
export const DeleteQueriesResponse: Schema.Schema<DeleteQueriesResponse> = Schema.Struct({}) as any as Schema.Schema<DeleteQueriesResponse>;

export type DeleteQueriesError = CommonErrors;

export const deleteQueries: API.OperationMethod<DeleteQueriesRequest, DeleteQueriesResponse, DeleteQueriesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: DeleteQueriesRequest,
  output: DeleteQueriesResponse,
  errors: [],
}));

/** Retrieves a query. */
export interface GetQueriesRequest {
  /** Required. The ID of the query to retrieve. */
  queryId: string;
}

export const GetQueriesRequest = Schema.Struct({
  queryId: Schema.String.pipe(T.HttpPath("queryId")),
}).pipe(
  T.Http({ method: "GET", path: "queries/{queryId}" }),
  svc,
) as unknown as Schema.Schema<GetQueriesRequest>;

export type GetQueriesResponse = Query;
export const GetQueriesResponse = Query;

export type GetQueriesError = CommonErrors;

export const getQueries: API.OperationMethod<GetQueriesRequest, GetQueriesResponse, GetQueriesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetQueriesRequest,
  output: GetQueriesResponse,
  errors: [],
}));

/** Lists queries created by the current user. */
export interface ListQueriesRequest {
  /** Maximum number of results per page. Must be between `1` and `100`. Defaults to `100` if unspecified. */
  pageSize?: number;
  /** A token identifying which page of results the server should return. Typically, this is the value of nextPageToken, returned from the previous call to the `queries.list` method. If unspecified, the first page of results is returned. */
  pageToken?: string;
  /** Field to sort the list by. Accepts the following values: * `queryId` (default) * `metadata.title` The default sorting order is ascending. To specify descending order for a field, add the suffix `desc` to the field name. For example, `queryId desc`. */
  orderBy?: string;
}

export const ListQueriesRequest = Schema.Struct({
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy")),
}).pipe(
  T.Http({ method: "GET", path: "queries" }),
  svc,
) as unknown as Schema.Schema<ListQueriesRequest>;

export type ListQueriesResponse_Op = ListQueriesResponse;
export const ListQueriesResponse_Op = ListQueriesResponse;

export type ListQueriesError = CommonErrors;

export const listQueries = API.makePaginated(() => ({
  input: ListQueriesRequest,
  output: ListQueriesResponse_Op,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Runs an existing query to generate a report. */
export interface RunQueriesRequest {
  /** Required. The ID of the query to run. */
  queryId: string;
  /** Whether the query should be run synchronously. When `true`, the request won't return until the resulting report has finished running. This parameter is `false` by default. Setting this parameter to `true` is **not recommended**. */
  synchronous?: boolean;
  /** Request body */
  body?: RunQueryRequest;
}

export const RunQueriesRequest = Schema.Struct({
  queryId: Schema.String.pipe(T.HttpPath("queryId")),
  synchronous: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("synchronous")),
  body: Schema.optional(RunQueryRequest).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "queries/{queryId}:run", hasBody: true }),
  svc,
) as unknown as Schema.Schema<RunQueriesRequest>;

export type RunQueriesResponse = Report;
export const RunQueriesResponse = Report;

export type RunQueriesError = CommonErrors;

export const runQueries: API.OperationMethod<RunQueriesRequest, RunQueriesResponse, RunQueriesError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: RunQueriesRequest,
  output: RunQueriesResponse,
  errors: [],
}));

/** Lists reports generated by the provided query. */
export interface ListQueriesReportsRequest {
  /** Required. The ID of the query that generated the reports. */
  queryId: string;
  /** Maximum number of results per page. Must be between `1` and `100`. Defaults to `100` if unspecified. */
  pageSize?: number;
  /** A token identifying which page of results the server should return. Typically, this is the value of nextPageToken returned from the previous call to the `queries.reports.list` method. If unspecified, the first page of results is returned. */
  pageToken?: string;
  /** Field to sort the list by. Accepts the following values: * `key.reportId` (default) The default sorting order is ascending. To specify descending order for a field, add the suffix `desc` to the field name. For example, `key.reportId desc`. */
  orderBy?: string;
}

export const ListQueriesReportsRequest = Schema.Struct({
  queryId: Schema.String.pipe(T.HttpPath("queryId")),
  pageSize: Schema.optional(Schema.Number).pipe(T.HttpQuery("pageSize")),
  pageToken: Schema.optional(Schema.String).pipe(T.HttpQuery("pageToken")),
  orderBy: Schema.optional(Schema.String).pipe(T.HttpQuery("orderBy")),
}).pipe(
  T.Http({ method: "GET", path: "queries/{queryId}/reports" }),
  svc,
) as unknown as Schema.Schema<ListQueriesReportsRequest>;

export type ListQueriesReportsResponse = ListReportsResponse;
export const ListQueriesReportsResponse = ListReportsResponse;

export type ListQueriesReportsError = CommonErrors;

export const listQueriesReports = API.makePaginated(() => ({
  input: ListQueriesReportsRequest,
  output: ListQueriesReportsResponse,
  errors: [],
  pagination: {
    inputToken: "pageToken",
    outputToken: "nextPageToken",
  },
}));

/** Retrieves a report. */
export interface GetQueriesReportsRequest {
  /** Required. The ID of the query that generated the report. */
  queryId: string;
  /** Required. The ID of the query to retrieve. */
  reportId: string;
}

export const GetQueriesReportsRequest = Schema.Struct({
  queryId: Schema.String.pipe(T.HttpPath("queryId")),
  reportId: Schema.String.pipe(T.HttpPath("reportId")),
}).pipe(
  T.Http({ method: "GET", path: "queries/{queryId}/reports/{reportId}" }),
  svc,
) as unknown as Schema.Schema<GetQueriesReportsRequest>;

export type GetQueriesReportsResponse = Report;
export const GetQueriesReportsResponse = Report;

export type GetQueriesReportsError = CommonErrors;

export const getQueriesReports: API.OperationMethod<GetQueriesReportsRequest, GetQueriesReportsResponse, GetQueriesReportsError, GCPAuth | HttpClient.HttpClient> = API.make(() => ({
  input: GetQueriesReportsRequest,
  output: GetQueriesReportsResponse,
  errors: [],
}));

