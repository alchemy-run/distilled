/**
 * Cloudflare ZERO-TRUST API
 *
 * Generated from Cloudflare TypeScript SDK.
 * DO NOT EDIT - regenerate with: bun scripts/generate-from-sdk.ts --service zero-trust
 */

import * as Effect from "effect/Effect";
import * as Schema from "effect/Schema";
import type * as HttpClient from "effect/unstable/http/HttpClient";
import * as API from "../client/api.ts";
import * as T from "../traits.ts";
import type { ApiToken } from "../auth.ts";
import {
  type CommonErrors,
  UnknownCloudflareError,
  CloudflareNetworkError,
  CloudflareHttpError,
} from "../errors.ts";

// =============================================================================
// AccessAiControlMcpPortal
// =============================================================================

export interface ListAccessAiControlMcpPortalsRequest {
  /** Path param: */
  accountId: string;
  /** Query param: Search by id, name, hostname */
  search?: string;
}

export const ListAccessAiControlMcpPortalsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/ai-controls/mcp/portals",
  }),
) as unknown as Schema.Schema<ListAccessAiControlMcpPortalsRequest>;

export type ListAccessAiControlMcpPortalsResponse = {
  id: string;
  hostname: string;
  name: string;
  createdAt?: string;
  createdBy?: string;
  description?: string;
  modifiedAt?: string;
  modifiedBy?: string;
}[];

export const ListAccessAiControlMcpPortalsResponse = Schema.Array(
  Schema.Struct({
    id: Schema.String,
    hostname: Schema.String,
    name: Schema.String,
    createdAt: Schema.optional(Schema.String),
    createdBy: Schema.optional(Schema.String),
    description: Schema.optional(Schema.String),
    modifiedAt: Schema.optional(Schema.String),
    modifiedBy: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      hostname: "hostname",
      name: "name",
      createdAt: "created_at",
      createdBy: "created_by",
      description: "description",
      modifiedAt: "modified_at",
      modifiedBy: "modified_by",
    }),
  ),
) as unknown as Schema.Schema<ListAccessAiControlMcpPortalsResponse>;

export type ListAccessAiControlMcpPortalsError = CommonErrors;

export const listAccessAiControlMcpPortals: API.OperationMethod<
  ListAccessAiControlMcpPortalsRequest,
  ListAccessAiControlMcpPortalsResponse,
  ListAccessAiControlMcpPortalsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessAiControlMcpPortalsRequest,
  output: ListAccessAiControlMcpPortalsResponse,
  errors: [],
}));

export interface CreateAccessAiControlMcpPortalRequest {
  /** Path param: */
  accountId: string;
  /** Body param: portal id */
  id: string;
  /** Body param: */
  hostname: string;
  /** Body param: */
  name: string;
  /** Body param: */
  description?: string;
  /** Body param: */
  servers?: {
    serverId: string;
    defaultDisabled?: boolean;
    onBehalf?: boolean;
    updatedPrompts?: {
      name: string;
      description?: string;
      enabled?: boolean;
    }[];
    updatedTools?: { name: string; description?: string; enabled?: boolean }[];
  }[];
}

export const CreateAccessAiControlMcpPortalRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.String,
  hostname: Schema.String,
  name: Schema.String,
  description: Schema.optional(Schema.String),
  servers: Schema.optional(
    Schema.Array(
      Schema.Struct({
        serverId: Schema.String,
        defaultDisabled: Schema.optional(Schema.Boolean),
        onBehalf: Schema.optional(Schema.Boolean),
        updatedPrompts: Schema.optional(
          Schema.Array(
            Schema.Struct({
              name: Schema.String,
              description: Schema.optional(Schema.String),
              enabled: Schema.optional(Schema.Boolean),
            }),
          ),
        ),
        updatedTools: Schema.optional(
          Schema.Array(
            Schema.Struct({
              name: Schema.String,
              description: Schema.optional(Schema.String),
              enabled: Schema.optional(Schema.Boolean),
            }),
          ),
        ),
      }).pipe(
        Schema.encodeKeys({
          serverId: "server_id",
          defaultDisabled: "default_disabled",
          onBehalf: "on_behalf",
          updatedPrompts: "updated_prompts",
          updatedTools: "updated_tools",
        }),
      ),
    ),
  ),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/access/ai-controls/mcp/portals",
  }),
) as unknown as Schema.Schema<CreateAccessAiControlMcpPortalRequest>;

export interface CreateAccessAiControlMcpPortalResponse {
  /** portal id */
  id: string;
  hostname: string;
  name: string;
  createdAt?: string;
  createdBy?: string;
  description?: string;
  modifiedAt?: string;
  modifiedBy?: string;
}

export const CreateAccessAiControlMcpPortalResponse = Schema.Struct({
  id: Schema.String,
  hostname: Schema.String,
  name: Schema.String,
  createdAt: Schema.optional(Schema.String),
  createdBy: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  modifiedAt: Schema.optional(Schema.String),
  modifiedBy: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    hostname: "hostname",
    name: "name",
    createdAt: "created_at",
    createdBy: "created_by",
    description: "description",
    modifiedAt: "modified_at",
    modifiedBy: "modified_by",
  }),
) as unknown as Schema.Schema<CreateAccessAiControlMcpPortalResponse>;

export type CreateAccessAiControlMcpPortalError = CommonErrors;

export const createAccessAiControlMcpPortal: API.OperationMethod<
  CreateAccessAiControlMcpPortalRequest,
  CreateAccessAiControlMcpPortalResponse,
  CreateAccessAiControlMcpPortalError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAccessAiControlMcpPortalRequest,
  output: CreateAccessAiControlMcpPortalResponse,
  errors: [],
}));

export interface UpdateAccessAiControlMcpPortalRequest {
  id: string;
  /** Path param: */
  accountId: string;
  /** Body param: */
  description?: string;
  /** Body param: */
  hostname?: string;
  /** Body param: */
  name?: string;
  /** Body param: */
  servers?: {
    serverId: string;
    defaultDisabled?: boolean;
    onBehalf?: boolean;
    updatedPrompts?: {
      name: string;
      description?: string;
      enabled?: boolean;
    }[];
    updatedTools?: { name: string; description?: string; enabled?: boolean }[];
  }[];
}

export const UpdateAccessAiControlMcpPortalRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  description: Schema.optional(Schema.String),
  hostname: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  servers: Schema.optional(
    Schema.Array(
      Schema.Struct({
        serverId: Schema.String,
        defaultDisabled: Schema.optional(Schema.Boolean),
        onBehalf: Schema.optional(Schema.Boolean),
        updatedPrompts: Schema.optional(
          Schema.Array(
            Schema.Struct({
              name: Schema.String,
              description: Schema.optional(Schema.String),
              enabled: Schema.optional(Schema.Boolean),
            }),
          ),
        ),
        updatedTools: Schema.optional(
          Schema.Array(
            Schema.Struct({
              name: Schema.String,
              description: Schema.optional(Schema.String),
              enabled: Schema.optional(Schema.Boolean),
            }),
          ),
        ),
      }).pipe(
        Schema.encodeKeys({
          serverId: "server_id",
          defaultDisabled: "default_disabled",
          onBehalf: "on_behalf",
          updatedPrompts: "updated_prompts",
          updatedTools: "updated_tools",
        }),
      ),
    ),
  ),
}).pipe(
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/access/ai-controls/mcp/portals/{id}",
  }),
) as unknown as Schema.Schema<UpdateAccessAiControlMcpPortalRequest>;

export interface UpdateAccessAiControlMcpPortalResponse {
  /** portal id */
  id: string;
  hostname: string;
  name: string;
  createdAt?: string;
  createdBy?: string;
  description?: string;
  modifiedAt?: string;
  modifiedBy?: string;
}

export const UpdateAccessAiControlMcpPortalResponse = Schema.Struct({
  id: Schema.String,
  hostname: Schema.String,
  name: Schema.String,
  createdAt: Schema.optional(Schema.String),
  createdBy: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  modifiedAt: Schema.optional(Schema.String),
  modifiedBy: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    hostname: "hostname",
    name: "name",
    createdAt: "created_at",
    createdBy: "created_by",
    description: "description",
    modifiedAt: "modified_at",
    modifiedBy: "modified_by",
  }),
) as unknown as Schema.Schema<UpdateAccessAiControlMcpPortalResponse>;

export type UpdateAccessAiControlMcpPortalError = CommonErrors;

export const updateAccessAiControlMcpPortal: API.OperationMethod<
  UpdateAccessAiControlMcpPortalRequest,
  UpdateAccessAiControlMcpPortalResponse,
  UpdateAccessAiControlMcpPortalError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAccessAiControlMcpPortalRequest,
  output: UpdateAccessAiControlMcpPortalResponse,
  errors: [],
}));

export interface DeleteAccessAiControlMcpPortalRequest {
  id: string;
  accountId: string;
}

export const DeleteAccessAiControlMcpPortalRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/access/ai-controls/mcp/portals/{id}",
  }),
) as unknown as Schema.Schema<DeleteAccessAiControlMcpPortalRequest>;

export interface DeleteAccessAiControlMcpPortalResponse {
  /** portal id */
  id: string;
  hostname: string;
  name: string;
  createdAt?: string;
  createdBy?: string;
  description?: string;
  modifiedAt?: string;
  modifiedBy?: string;
}

export const DeleteAccessAiControlMcpPortalResponse = Schema.Struct({
  id: Schema.String,
  hostname: Schema.String,
  name: Schema.String,
  createdAt: Schema.optional(Schema.String),
  createdBy: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  modifiedAt: Schema.optional(Schema.String),
  modifiedBy: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    hostname: "hostname",
    name: "name",
    createdAt: "created_at",
    createdBy: "created_by",
    description: "description",
    modifiedAt: "modified_at",
    modifiedBy: "modified_by",
  }),
) as unknown as Schema.Schema<DeleteAccessAiControlMcpPortalResponse>;

export type DeleteAccessAiControlMcpPortalError = CommonErrors;

export const deleteAccessAiControlMcpPortal: API.OperationMethod<
  DeleteAccessAiControlMcpPortalRequest,
  DeleteAccessAiControlMcpPortalResponse,
  DeleteAccessAiControlMcpPortalError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccessAiControlMcpPortalRequest,
  output: DeleteAccessAiControlMcpPortalResponse,
  errors: [],
}));

export interface ReadAccessAiControlMcpPortalRequest {
  id: string;
  accountId: string;
}

export const ReadAccessAiControlMcpPortalRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/ai-controls/mcp/portals/{id}",
  }),
) as unknown as Schema.Schema<ReadAccessAiControlMcpPortalRequest>;

export interface ReadAccessAiControlMcpPortalResponse {
  /** portal id */
  id: string;
  hostname: string;
  name: string;
  servers: {
    id: string;
    authType: "oauth" | "bearer" | "unauthenticated";
    hostname: string;
    name: string;
    prompts: Record<string, unknown>[];
    tools: Record<string, unknown>[];
    updatedPrompts: Record<string, unknown>[];
    updatedTools: Record<string, unknown>[];
    createdAt?: string;
    createdBy?: string;
    defaultDisabled?: boolean;
    description?: string | null;
    error?: string;
    lastSynced?: string;
    modifiedAt?: string;
    modifiedBy?: string;
    onBehalf?: boolean;
    status?: string;
  }[];
  createdAt?: string;
  createdBy?: string;
  description?: string;
  modifiedAt?: string;
  modifiedBy?: string;
}

export const ReadAccessAiControlMcpPortalResponse = Schema.Struct({
  id: Schema.String,
  hostname: Schema.String,
  name: Schema.String,
  servers: Schema.Array(
    Schema.Struct({
      id: Schema.String,
      authType: Schema.Literals(["oauth", "bearer", "unauthenticated"]),
      hostname: Schema.String,
      name: Schema.String,
      prompts: Schema.Array(Schema.Struct({})),
      tools: Schema.Array(Schema.Struct({})),
      updatedPrompts: Schema.Array(Schema.Struct({})),
      updatedTools: Schema.Array(Schema.Struct({})),
      createdAt: Schema.optional(Schema.String),
      createdBy: Schema.optional(Schema.String),
      defaultDisabled: Schema.optional(Schema.Boolean),
      description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      error: Schema.optional(Schema.String),
      lastSynced: Schema.optional(Schema.String),
      modifiedAt: Schema.optional(Schema.String),
      modifiedBy: Schema.optional(Schema.String),
      onBehalf: Schema.optional(Schema.Boolean),
      status: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        authType: "auth_type",
        hostname: "hostname",
        name: "name",
        prompts: "prompts",
        tools: "tools",
        updatedPrompts: "updated_prompts",
        updatedTools: "updated_tools",
        createdAt: "created_at",
        createdBy: "created_by",
        defaultDisabled: "default_disabled",
        description: "description",
        error: "error",
        lastSynced: "last_synced",
        modifiedAt: "modified_at",
        modifiedBy: "modified_by",
        onBehalf: "on_behalf",
        status: "status",
      }),
    ),
  ),
  createdAt: Schema.optional(Schema.String),
  createdBy: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  modifiedAt: Schema.optional(Schema.String),
  modifiedBy: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    hostname: "hostname",
    name: "name",
    servers: "servers",
    createdAt: "created_at",
    createdBy: "created_by",
    description: "description",
    modifiedAt: "modified_at",
    modifiedBy: "modified_by",
  }),
) as unknown as Schema.Schema<ReadAccessAiControlMcpPortalResponse>;

export type ReadAccessAiControlMcpPortalError = CommonErrors;

export const readAccessAiControlMcpPortal: API.OperationMethod<
  ReadAccessAiControlMcpPortalRequest,
  ReadAccessAiControlMcpPortalResponse,
  ReadAccessAiControlMcpPortalError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ReadAccessAiControlMcpPortalRequest,
  output: ReadAccessAiControlMcpPortalResponse,
  errors: [],
}));

// =============================================================================
// AccessAiControlMcpServer
// =============================================================================

export interface ListAccessAiControlMcpServersRequest {
  /** Path param: */
  accountId: string;
  /** Query param: Search by id, name */
  search?: string;
}

export const ListAccessAiControlMcpServersRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/ai-controls/mcp/servers",
  }),
) as unknown as Schema.Schema<ListAccessAiControlMcpServersRequest>;

export type ListAccessAiControlMcpServersResponse = {
  id: string;
  authType: "oauth" | "bearer" | "unauthenticated";
  hostname: string;
  name: string;
  prompts: Record<string, unknown>[];
  tools: Record<string, unknown>[];
  createdAt?: string;
  createdBy?: string;
  description?: string | null;
  error?: string;
  lastSynced?: string;
  modifiedAt?: string;
  modifiedBy?: string;
  status?: string;
}[];

export const ListAccessAiControlMcpServersResponse = Schema.Array(
  Schema.Struct({
    id: Schema.String,
    authType: Schema.Literals(["oauth", "bearer", "unauthenticated"]),
    hostname: Schema.String,
    name: Schema.String,
    prompts: Schema.Array(Schema.Struct({})),
    tools: Schema.Array(Schema.Struct({})),
    createdAt: Schema.optional(Schema.String),
    createdBy: Schema.optional(Schema.String),
    description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    error: Schema.optional(Schema.String),
    lastSynced: Schema.optional(Schema.String),
    modifiedAt: Schema.optional(Schema.String),
    modifiedBy: Schema.optional(Schema.String),
    status: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      authType: "auth_type",
      hostname: "hostname",
      name: "name",
      prompts: "prompts",
      tools: "tools",
      createdAt: "created_at",
      createdBy: "created_by",
      description: "description",
      error: "error",
      lastSynced: "last_synced",
      modifiedAt: "modified_at",
      modifiedBy: "modified_by",
      status: "status",
    }),
  ),
) as unknown as Schema.Schema<ListAccessAiControlMcpServersResponse>;

export type ListAccessAiControlMcpServersError = CommonErrors;

export const listAccessAiControlMcpServers: API.OperationMethod<
  ListAccessAiControlMcpServersRequest,
  ListAccessAiControlMcpServersResponse,
  ListAccessAiControlMcpServersError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessAiControlMcpServersRequest,
  output: ListAccessAiControlMcpServersResponse,
  errors: [],
}));

export interface CreateAccessAiControlMcpServerRequest {
  /** Path param: */
  accountId: string;
  /** Body param: server id */
  id: string;
  /** Body param: */
  authType: "oauth" | "bearer" | "unauthenticated";
  /** Body param: */
  hostname: string;
  /** Body param: */
  name: string;
  /** Body param: */
  authCredentials?: string;
  /** Body param: */
  description?: string | null;
}

export const CreateAccessAiControlMcpServerRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.String,
  authType: Schema.Literals(["oauth", "bearer", "unauthenticated"]),
  hostname: Schema.String,
  name: Schema.String,
  authCredentials: Schema.optional(Schema.String),
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    authType: "auth_type",
    hostname: "hostname",
    name: "name",
    authCredentials: "auth_credentials",
    description: "description",
  }),
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/access/ai-controls/mcp/servers",
  }),
) as unknown as Schema.Schema<CreateAccessAiControlMcpServerRequest>;

export interface CreateAccessAiControlMcpServerResponse {
  /** server id */
  id: string;
  authType: "oauth" | "bearer" | "unauthenticated";
  hostname: string;
  name: string;
  prompts: Record<string, unknown>[];
  tools: Record<string, unknown>[];
  createdAt?: string;
  createdBy?: string;
  description?: string | null;
  error?: string;
  lastSynced?: string;
  modifiedAt?: string;
  modifiedBy?: string;
  status?: string;
}

export const CreateAccessAiControlMcpServerResponse = Schema.Struct({
  id: Schema.String,
  authType: Schema.Literals(["oauth", "bearer", "unauthenticated"]),
  hostname: Schema.String,
  name: Schema.String,
  prompts: Schema.Array(Schema.Struct({})),
  tools: Schema.Array(Schema.Struct({})),
  createdAt: Schema.optional(Schema.String),
  createdBy: Schema.optional(Schema.String),
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  error: Schema.optional(Schema.String),
  lastSynced: Schema.optional(Schema.String),
  modifiedAt: Schema.optional(Schema.String),
  modifiedBy: Schema.optional(Schema.String),
  status: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    authType: "auth_type",
    hostname: "hostname",
    name: "name",
    prompts: "prompts",
    tools: "tools",
    createdAt: "created_at",
    createdBy: "created_by",
    description: "description",
    error: "error",
    lastSynced: "last_synced",
    modifiedAt: "modified_at",
    modifiedBy: "modified_by",
    status: "status",
  }),
) as unknown as Schema.Schema<CreateAccessAiControlMcpServerResponse>;

export type CreateAccessAiControlMcpServerError = CommonErrors;

export const createAccessAiControlMcpServer: API.OperationMethod<
  CreateAccessAiControlMcpServerRequest,
  CreateAccessAiControlMcpServerResponse,
  CreateAccessAiControlMcpServerError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAccessAiControlMcpServerRequest,
  output: CreateAccessAiControlMcpServerResponse,
  errors: [],
}));

export interface UpdateAccessAiControlMcpServerRequest {
  id: string;
  /** Path param: */
  accountId: string;
  /** Body param: */
  authCredentials?: string;
  /** Body param: */
  description?: string | null;
  /** Body param: */
  name?: string;
}

export const UpdateAccessAiControlMcpServerRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  authCredentials: Schema.optional(Schema.String),
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  name: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    authCredentials: "auth_credentials",
    description: "description",
    name: "name",
  }),
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/access/ai-controls/mcp/servers/{id}",
  }),
) as unknown as Schema.Schema<UpdateAccessAiControlMcpServerRequest>;

export interface UpdateAccessAiControlMcpServerResponse {
  /** server id */
  id: string;
  authType: "oauth" | "bearer" | "unauthenticated";
  hostname: string;
  name: string;
  prompts: Record<string, unknown>[];
  tools: Record<string, unknown>[];
  createdAt?: string;
  createdBy?: string;
  description?: string | null;
  error?: string;
  lastSynced?: string;
  modifiedAt?: string;
  modifiedBy?: string;
  status?: string;
}

export const UpdateAccessAiControlMcpServerResponse = Schema.Struct({
  id: Schema.String,
  authType: Schema.Literals(["oauth", "bearer", "unauthenticated"]),
  hostname: Schema.String,
  name: Schema.String,
  prompts: Schema.Array(Schema.Struct({})),
  tools: Schema.Array(Schema.Struct({})),
  createdAt: Schema.optional(Schema.String),
  createdBy: Schema.optional(Schema.String),
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  error: Schema.optional(Schema.String),
  lastSynced: Schema.optional(Schema.String),
  modifiedAt: Schema.optional(Schema.String),
  modifiedBy: Schema.optional(Schema.String),
  status: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    authType: "auth_type",
    hostname: "hostname",
    name: "name",
    prompts: "prompts",
    tools: "tools",
    createdAt: "created_at",
    createdBy: "created_by",
    description: "description",
    error: "error",
    lastSynced: "last_synced",
    modifiedAt: "modified_at",
    modifiedBy: "modified_by",
    status: "status",
  }),
) as unknown as Schema.Schema<UpdateAccessAiControlMcpServerResponse>;

export type UpdateAccessAiControlMcpServerError = CommonErrors;

export const updateAccessAiControlMcpServer: API.OperationMethod<
  UpdateAccessAiControlMcpServerRequest,
  UpdateAccessAiControlMcpServerResponse,
  UpdateAccessAiControlMcpServerError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAccessAiControlMcpServerRequest,
  output: UpdateAccessAiControlMcpServerResponse,
  errors: [],
}));

export interface DeleteAccessAiControlMcpServerRequest {
  id: string;
  accountId: string;
}

export const DeleteAccessAiControlMcpServerRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/access/ai-controls/mcp/servers/{id}",
  }),
) as unknown as Schema.Schema<DeleteAccessAiControlMcpServerRequest>;

export interface DeleteAccessAiControlMcpServerResponse {
  /** server id */
  id: string;
  authType: "oauth" | "bearer" | "unauthenticated";
  hostname: string;
  name: string;
  prompts: Record<string, unknown>[];
  tools: Record<string, unknown>[];
  createdAt?: string;
  createdBy?: string;
  description?: string | null;
  error?: string;
  lastSynced?: string;
  modifiedAt?: string;
  modifiedBy?: string;
  status?: string;
}

export const DeleteAccessAiControlMcpServerResponse = Schema.Struct({
  id: Schema.String,
  authType: Schema.Literals(["oauth", "bearer", "unauthenticated"]),
  hostname: Schema.String,
  name: Schema.String,
  prompts: Schema.Array(Schema.Struct({})),
  tools: Schema.Array(Schema.Struct({})),
  createdAt: Schema.optional(Schema.String),
  createdBy: Schema.optional(Schema.String),
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  error: Schema.optional(Schema.String),
  lastSynced: Schema.optional(Schema.String),
  modifiedAt: Schema.optional(Schema.String),
  modifiedBy: Schema.optional(Schema.String),
  status: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    authType: "auth_type",
    hostname: "hostname",
    name: "name",
    prompts: "prompts",
    tools: "tools",
    createdAt: "created_at",
    createdBy: "created_by",
    description: "description",
    error: "error",
    lastSynced: "last_synced",
    modifiedAt: "modified_at",
    modifiedBy: "modified_by",
    status: "status",
  }),
) as unknown as Schema.Schema<DeleteAccessAiControlMcpServerResponse>;

export type DeleteAccessAiControlMcpServerError = CommonErrors;

export const deleteAccessAiControlMcpServer: API.OperationMethod<
  DeleteAccessAiControlMcpServerRequest,
  DeleteAccessAiControlMcpServerResponse,
  DeleteAccessAiControlMcpServerError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccessAiControlMcpServerRequest,
  output: DeleteAccessAiControlMcpServerResponse,
  errors: [],
}));

export interface ReadAccessAiControlMcpServerRequest {
  id: string;
  accountId: string;
}

export const ReadAccessAiControlMcpServerRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/ai-controls/mcp/servers/{id}",
  }),
) as unknown as Schema.Schema<ReadAccessAiControlMcpServerRequest>;

export interface ReadAccessAiControlMcpServerResponse {
  /** server id */
  id: string;
  authType: "oauth" | "bearer" | "unauthenticated";
  hostname: string;
  name: string;
  prompts: Record<string, unknown>[];
  tools: Record<string, unknown>[];
  createdAt?: string;
  createdBy?: string;
  description?: string | null;
  error?: string;
  lastSynced?: string;
  modifiedAt?: string;
  modifiedBy?: string;
  status?: string;
}

export const ReadAccessAiControlMcpServerResponse = Schema.Struct({
  id: Schema.String,
  authType: Schema.Literals(["oauth", "bearer", "unauthenticated"]),
  hostname: Schema.String,
  name: Schema.String,
  prompts: Schema.Array(Schema.Struct({})),
  tools: Schema.Array(Schema.Struct({})),
  createdAt: Schema.optional(Schema.String),
  createdBy: Schema.optional(Schema.String),
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  error: Schema.optional(Schema.String),
  lastSynced: Schema.optional(Schema.String),
  modifiedAt: Schema.optional(Schema.String),
  modifiedBy: Schema.optional(Schema.String),
  status: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    authType: "auth_type",
    hostname: "hostname",
    name: "name",
    prompts: "prompts",
    tools: "tools",
    createdAt: "created_at",
    createdBy: "created_by",
    description: "description",
    error: "error",
    lastSynced: "last_synced",
    modifiedAt: "modified_at",
    modifiedBy: "modified_by",
    status: "status",
  }),
) as unknown as Schema.Schema<ReadAccessAiControlMcpServerResponse>;

export type ReadAccessAiControlMcpServerError = CommonErrors;

export const readAccessAiControlMcpServer: API.OperationMethod<
  ReadAccessAiControlMcpServerRequest,
  ReadAccessAiControlMcpServerResponse,
  ReadAccessAiControlMcpServerError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ReadAccessAiControlMcpServerRequest,
  output: ReadAccessAiControlMcpServerResponse,
  errors: [],
}));

export interface SyncAccessAiControlMcpServerRequest {
  id: string;
  accountId: string;
}

export const SyncAccessAiControlMcpServerRequest = Schema.Struct({
  id: Schema.String.pipe(T.HttpPath("id")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/access/ai-controls/mcp/servers/{id}/sync",
  }),
) as unknown as Schema.Schema<SyncAccessAiControlMcpServerRequest>;

export type SyncAccessAiControlMcpServerResponse = unknown;

export const SyncAccessAiControlMcpServerResponse =
  Schema.Unknown as unknown as Schema.Schema<SyncAccessAiControlMcpServerResponse>;

export type SyncAccessAiControlMcpServerError = CommonErrors;

export const syncAccessAiControlMcpServer: API.OperationMethod<
  SyncAccessAiControlMcpServerRequest,
  SyncAccessAiControlMcpServerResponse,
  SyncAccessAiControlMcpServerError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: SyncAccessAiControlMcpServerRequest,
  output: SyncAccessAiControlMcpServerResponse,
  errors: [],
}));

// =============================================================================
// AccessApplication
// =============================================================================

export interface GetAccessApplicationRequest {}

export const GetAccessApplicationRequest = Schema.Struct({}).pipe(
  T.Http({
    method: "GET",
    path: "/{accountOrZone}/{accountOrZoneId}/access/apps/{appId}",
  }),
) as unknown as Schema.Schema<GetAccessApplicationRequest>;

export type GetAccessApplicationResponse =
  | {
      domain: string;
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      allowAuthenticateViaWarp?: boolean;
      allowIframe?: boolean;
      allowedIdps?: string[];
      appLauncherVisible?: boolean;
      aud?: string;
      autoRedirectToIdentity?: boolean;
      corsHeaders?: unknown;
      customDenyMessage?: string;
      customDenyUrl?: string;
      customNonIdentityDenyUrl?: string;
      customPages?: string[];
      destinations?: (
        | { type?: "public"; uri?: string }
        | {
            cidr?: string;
            hostname?: string;
            l4Protocol?: "tcp" | "udp";
            portRange?: string;
            type?: "private";
            vnetId?: string;
          }
        | { mcpServerId?: string; type?: "via_mcp_server_portal" }
      )[];
      enableBindingCookie?: boolean;
      httpOnlyCookieAttribute?: boolean;
      logoUrl?: string;
      name?: string;
      optionsPreflightBypass?: boolean;
      pathCookieAttribute?: boolean;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      readServiceTokensFromHeader?: string;
      sameSiteCookieAttribute?: string;
      scimConfig?: {
        idpUid: string;
        remoteUri: string;
        authentication?:
          | unknown
          | {
              clientId: string;
              clientSecret: string;
              scheme: "access_service_token";
            }
          | (
              | unknown
              | {
                  clientId: string;
                  clientSecret: string;
                  scheme: "access_service_token";
                }
            )[];
        deactivateOnDelete?: boolean;
        enabled?: boolean;
        mappings?: unknown[];
      };
      selfHostedDomains?: string[];
      serviceAuth_401Redirect?: boolean;
      sessionDuration?: string;
      skipInterstitial?: boolean;
      tags?: string[];
    }
  | {
      id?: string;
      allowedIdps?: string[];
      appLauncherVisible?: boolean;
      aud?: string;
      autoRedirectToIdentity?: boolean;
      customPages?: string[];
      logoUrl?: string;
      name?: string;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      saasApp?: unknown;
      scimConfig?: {
        idpUid: string;
        remoteUri: string;
        authentication?:
          | unknown
          | {
              clientId: string;
              clientSecret: string;
              scheme: "access_service_token";
            }
          | (
              | unknown
              | {
                  clientId: string;
                  clientSecret: string;
                  scheme: "access_service_token";
                }
            )[];
        deactivateOnDelete?: boolean;
        enabled?: boolean;
        mappings?: unknown[];
      };
      tags?: string[];
      type?:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
    }
  | {
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      allowedIdps?: string[];
      appLauncherLogoUrl?: string;
      aud?: string;
      autoRedirectToIdentity?: boolean;
      bgColor?: string;
      customDenyUrl?: string;
      customNonIdentityDenyUrl?: string;
      customPages?: string[];
      domain?: string;
      footerLinks?: { name: string; url: string }[];
      headerBgColor?: string;
      landingPageDesign?: {
        buttonColor?: string;
        buttonTextColor?: string;
        imageUrl?: string;
        message?: string;
        title?: string;
      };
      name?: string;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      sessionDuration?: string;
      skipAppLauncherLoginPage?: boolean;
    }
  | {
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      allowedIdps?: string[];
      aud?: string;
      autoRedirectToIdentity?: boolean;
      customDenyUrl?: string;
      customNonIdentityDenyUrl?: string;
      customPages?: string[];
      domain?: string;
      name?: string;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      sessionDuration?: string;
    }
  | {
      id?: string;
      appLauncherVisible?: boolean;
      aud?: string;
      domain?: string;
      logoUrl?: string;
      name?: string;
      tags?: string[];
      type?:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
    }
  | {
      targetCriteria: {
        port: number;
        protocol: "SSH";
        targetAttributes: Record<string, unknown>;
      }[];
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      aud?: string;
      name?: string;
      policies?: {
        decision: "allow" | "bypass" | "deny" | "non_identity";
        include: unknown[];
        name: string;
        connectionRules?: {
          ssh?: { usernames: string[]; allowEmailAlias?: boolean };
        };
        exclude?: unknown[];
        require?: unknown[];
      }[];
    }
  | {
      domain: string;
      targetCriteria: {
        port: number;
        protocol: "RDP";
        targetAttributes: Record<string, unknown>;
      }[];
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      allowAuthenticateViaWarp?: boolean;
      allowIframe?: boolean;
      allowedIdps?: string[];
      appLauncherVisible?: boolean;
      aud?: string;
      autoRedirectToIdentity?: boolean;
      corsHeaders?: unknown;
      customDenyMessage?: string;
      customDenyUrl?: string;
      customNonIdentityDenyUrl?: string;
      customPages?: string[];
      destinations?: (
        | { type?: "public"; uri?: string }
        | {
            cidr?: string;
            hostname?: string;
            l4Protocol?: "tcp" | "udp";
            portRange?: string;
            type?: "private";
            vnetId?: string;
          }
        | { mcpServerId?: string; type?: "via_mcp_server_portal" }
      )[];
      enableBindingCookie?: boolean;
      httpOnlyCookieAttribute?: boolean;
      logoUrl?: string;
      name?: string;
      optionsPreflightBypass?: boolean;
      pathCookieAttribute?: boolean;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      readServiceTokensFromHeader?: string;
      sameSiteCookieAttribute?: string;
      scimConfig?: {
        idpUid: string;
        remoteUri: string;
        authentication?:
          | unknown
          | {
              clientId: string;
              clientSecret: string;
              scheme: "access_service_token";
            }
          | (
              | unknown
              | {
                  clientId: string;
                  clientSecret: string;
                  scheme: "access_service_token";
                }
            )[];
        deactivateOnDelete?: boolean;
        enabled?: boolean;
        mappings?: unknown[];
      };
      selfHostedDomains?: string[];
      serviceAuth_401Redirect?: boolean;
      sessionDuration?: string;
      skipInterstitial?: boolean;
      tags?: string[];
    };

export const GetAccessApplicationResponse = Schema.Union([
  Schema.Struct({
    domain: Schema.String,
    type: Schema.Literals([
      "self_hosted",
      "saas",
      "ssh",
      "vnc",
      "app_launcher",
      "warp",
      "biso",
      "bookmark",
      "dash_sso",
      "infrastructure",
      "rdp",
      "mcp",
      "mcp_portal",
      "proxy_endpoint",
    ]),
    id: Schema.optional(Schema.String),
    allowAuthenticateViaWarp: Schema.optional(Schema.Boolean),
    allowIframe: Schema.optional(Schema.Boolean),
    allowedIdps: Schema.optional(Schema.Array(Schema.String)),
    appLauncherVisible: Schema.optional(Schema.Boolean),
    aud: Schema.optional(Schema.String),
    autoRedirectToIdentity: Schema.optional(Schema.Boolean),
    corsHeaders: Schema.optional(Schema.Unknown),
    customDenyMessage: Schema.optional(Schema.String),
    customDenyUrl: Schema.optional(Schema.String),
    customNonIdentityDenyUrl: Schema.optional(Schema.String),
    customPages: Schema.optional(Schema.Array(Schema.String)),
    destinations: Schema.optional(
      Schema.Array(
        Schema.Union([
          Schema.Struct({
            type: Schema.optional(Schema.Literal("public")),
            uri: Schema.optional(Schema.String),
          }),
          Schema.Struct({
            cidr: Schema.optional(Schema.String),
            hostname: Schema.optional(Schema.String),
            l4Protocol: Schema.optional(Schema.Literals(["tcp", "udp"])),
            portRange: Schema.optional(Schema.String),
            type: Schema.optional(Schema.Literal("private")),
            vnetId: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              cidr: "cidr",
              hostname: "hostname",
              l4Protocol: "l4_protocol",
              portRange: "port_range",
              type: "type",
              vnetId: "vnet_id",
            }),
          ),
          Schema.Struct({
            mcpServerId: Schema.optional(Schema.String),
            type: Schema.optional(Schema.Literal("via_mcp_server_portal")),
          }).pipe(
            Schema.encodeKeys({ mcpServerId: "mcp_server_id", type: "type" }),
          ),
        ]),
      ),
    ),
    enableBindingCookie: Schema.optional(Schema.Boolean),
    httpOnlyCookieAttribute: Schema.optional(Schema.Boolean),
    logoUrl: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    optionsPreflightBypass: Schema.optional(Schema.Boolean),
    pathCookieAttribute: Schema.optional(Schema.Boolean),
    policies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
          approvalRequired: Schema.optional(Schema.Boolean),
          createdAt: Schema.optional(Schema.String),
          decision: Schema.optional(
            Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
          ),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          include: Schema.optional(Schema.Array(Schema.Unknown)),
          isolationRequired: Schema.optional(Schema.Boolean),
          name: Schema.optional(Schema.String),
          precedence: Schema.optional(Schema.Number),
          purposeJustificationPrompt: Schema.optional(Schema.String),
          purposeJustificationRequired: Schema.optional(Schema.Boolean),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
          sessionDuration: Schema.optional(Schema.String),
          updatedAt: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            approvalGroups: "approval_groups",
            approvalRequired: "approval_required",
            createdAt: "created_at",
            decision: "decision",
            exclude: "exclude",
            include: "include",
            isolationRequired: "isolation_required",
            name: "name",
            precedence: "precedence",
            purposeJustificationPrompt: "purpose_justification_prompt",
            purposeJustificationRequired: "purpose_justification_required",
            require: "require",
            sessionDuration: "session_duration",
            updatedAt: "updated_at",
          }),
        ),
      ),
    ),
    readServiceTokensFromHeader: Schema.optional(Schema.String),
    sameSiteCookieAttribute: Schema.optional(Schema.String),
    scimConfig: Schema.optional(
      Schema.Struct({
        idpUid: Schema.String,
        remoteUri: Schema.String,
        authentication: Schema.optional(
          Schema.Union([
            Schema.Unknown,
            Schema.Struct({
              clientId: Schema.String,
              clientSecret: Schema.String,
              scheme: Schema.Literal("access_service_token"),
            }).pipe(
              Schema.encodeKeys({
                clientId: "client_id",
                clientSecret: "client_secret",
                scheme: "scheme",
              }),
            ),
            Schema.Array(
              Schema.Union([
                Schema.Unknown,
                Schema.Struct({
                  clientId: Schema.String,
                  clientSecret: Schema.String,
                  scheme: Schema.Literal("access_service_token"),
                }).pipe(
                  Schema.encodeKeys({
                    clientId: "client_id",
                    clientSecret: "client_secret",
                    scheme: "scheme",
                  }),
                ),
              ]),
            ),
          ]),
        ),
        deactivateOnDelete: Schema.optional(Schema.Boolean),
        enabled: Schema.optional(Schema.Boolean),
        mappings: Schema.optional(Schema.Array(Schema.Unknown)),
      }).pipe(
        Schema.encodeKeys({
          idpUid: "idp_uid",
          remoteUri: "remote_uri",
          authentication: "authentication",
          deactivateOnDelete: "deactivate_on_delete",
          enabled: "enabled",
          mappings: "mappings",
        }),
      ),
    ),
    selfHostedDomains: Schema.optional(Schema.Array(Schema.String)),
    serviceAuth_401Redirect: Schema.optional(Schema.Boolean),
    sessionDuration: Schema.optional(Schema.String),
    skipInterstitial: Schema.optional(Schema.Boolean),
    tags: Schema.optional(Schema.Array(Schema.String)),
  }).pipe(
    Schema.encodeKeys({
      domain: "domain",
      type: "type",
      id: "id",
      allowAuthenticateViaWarp: "allow_authenticate_via_warp",
      allowIframe: "allow_iframe",
      allowedIdps: "allowed_idps",
      appLauncherVisible: "app_launcher_visible",
      aud: "aud",
      autoRedirectToIdentity: "auto_redirect_to_identity",
      corsHeaders: "cors_headers",
      customDenyMessage: "custom_deny_message",
      customDenyUrl: "custom_deny_url",
      customNonIdentityDenyUrl: "custom_non_identity_deny_url",
      customPages: "custom_pages",
      destinations: "destinations",
      enableBindingCookie: "enable_binding_cookie",
      httpOnlyCookieAttribute: "http_only_cookie_attribute",
      logoUrl: "logo_url",
      name: "name",
      optionsPreflightBypass: "options_preflight_bypass",
      pathCookieAttribute: "path_cookie_attribute",
      policies: "policies",
      readServiceTokensFromHeader: "read_service_tokens_from_header",
      sameSiteCookieAttribute: "same_site_cookie_attribute",
      scimConfig: "scim_config",
      selfHostedDomains: "self_hosted_domains",
      serviceAuth_401Redirect: "service_auth_401_redirect",
      sessionDuration: "session_duration",
      skipInterstitial: "skip_interstitial",
      tags: "tags",
    }),
  ),
  Schema.Struct({
    id: Schema.optional(Schema.String),
    allowedIdps: Schema.optional(Schema.Array(Schema.String)),
    appLauncherVisible: Schema.optional(Schema.Boolean),
    aud: Schema.optional(Schema.String),
    autoRedirectToIdentity: Schema.optional(Schema.Boolean),
    customPages: Schema.optional(Schema.Array(Schema.String)),
    logoUrl: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    policies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
          approvalRequired: Schema.optional(Schema.Boolean),
          createdAt: Schema.optional(Schema.String),
          decision: Schema.optional(
            Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
          ),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          include: Schema.optional(Schema.Array(Schema.Unknown)),
          isolationRequired: Schema.optional(Schema.Boolean),
          name: Schema.optional(Schema.String),
          precedence: Schema.optional(Schema.Number),
          purposeJustificationPrompt: Schema.optional(Schema.String),
          purposeJustificationRequired: Schema.optional(Schema.Boolean),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
          sessionDuration: Schema.optional(Schema.String),
          updatedAt: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            approvalGroups: "approval_groups",
            approvalRequired: "approval_required",
            createdAt: "created_at",
            decision: "decision",
            exclude: "exclude",
            include: "include",
            isolationRequired: "isolation_required",
            name: "name",
            precedence: "precedence",
            purposeJustificationPrompt: "purpose_justification_prompt",
            purposeJustificationRequired: "purpose_justification_required",
            require: "require",
            sessionDuration: "session_duration",
            updatedAt: "updated_at",
          }),
        ),
      ),
    ),
    saasApp: Schema.optional(Schema.Unknown),
    scimConfig: Schema.optional(
      Schema.Struct({
        idpUid: Schema.String,
        remoteUri: Schema.String,
        authentication: Schema.optional(
          Schema.Union([
            Schema.Unknown,
            Schema.Struct({
              clientId: Schema.String,
              clientSecret: Schema.String,
              scheme: Schema.Literal("access_service_token"),
            }).pipe(
              Schema.encodeKeys({
                clientId: "client_id",
                clientSecret: "client_secret",
                scheme: "scheme",
              }),
            ),
            Schema.Array(
              Schema.Union([
                Schema.Unknown,
                Schema.Struct({
                  clientId: Schema.String,
                  clientSecret: Schema.String,
                  scheme: Schema.Literal("access_service_token"),
                }).pipe(
                  Schema.encodeKeys({
                    clientId: "client_id",
                    clientSecret: "client_secret",
                    scheme: "scheme",
                  }),
                ),
              ]),
            ),
          ]),
        ),
        deactivateOnDelete: Schema.optional(Schema.Boolean),
        enabled: Schema.optional(Schema.Boolean),
        mappings: Schema.optional(Schema.Array(Schema.Unknown)),
      }).pipe(
        Schema.encodeKeys({
          idpUid: "idp_uid",
          remoteUri: "remote_uri",
          authentication: "authentication",
          deactivateOnDelete: "deactivate_on_delete",
          enabled: "enabled",
          mappings: "mappings",
        }),
      ),
    ),
    tags: Schema.optional(Schema.Array(Schema.String)),
    type: Schema.optional(
      Schema.Literals([
        "self_hosted",
        "saas",
        "ssh",
        "vnc",
        "app_launcher",
        "warp",
        "biso",
        "bookmark",
        "dash_sso",
        "infrastructure",
        "rdp",
        "mcp",
        "mcp_portal",
        "proxy_endpoint",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      allowedIdps: "allowed_idps",
      appLauncherVisible: "app_launcher_visible",
      aud: "aud",
      autoRedirectToIdentity: "auto_redirect_to_identity",
      customPages: "custom_pages",
      logoUrl: "logo_url",
      name: "name",
      policies: "policies",
      saasApp: "saas_app",
      scimConfig: "scim_config",
      tags: "tags",
      type: "type",
    }),
  ),
  Schema.Struct({
    type: Schema.Literals([
      "self_hosted",
      "saas",
      "ssh",
      "vnc",
      "app_launcher",
      "warp",
      "biso",
      "bookmark",
      "dash_sso",
      "infrastructure",
      "rdp",
      "mcp",
      "mcp_portal",
      "proxy_endpoint",
    ]),
    id: Schema.optional(Schema.String),
    allowedIdps: Schema.optional(Schema.Array(Schema.String)),
    appLauncherLogoUrl: Schema.optional(Schema.String),
    aud: Schema.optional(Schema.String),
    autoRedirectToIdentity: Schema.optional(Schema.Boolean),
    bgColor: Schema.optional(Schema.String),
    customDenyUrl: Schema.optional(Schema.String),
    customNonIdentityDenyUrl: Schema.optional(Schema.String),
    customPages: Schema.optional(Schema.Array(Schema.String)),
    domain: Schema.optional(Schema.String),
    footerLinks: Schema.optional(
      Schema.Array(
        Schema.Struct({
          name: Schema.String,
          url: Schema.String,
        }),
      ),
    ),
    headerBgColor: Schema.optional(Schema.String),
    landingPageDesign: Schema.optional(
      Schema.Struct({
        buttonColor: Schema.optional(Schema.String),
        buttonTextColor: Schema.optional(Schema.String),
        imageUrl: Schema.optional(Schema.String),
        message: Schema.optional(Schema.String),
        title: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          buttonColor: "button_color",
          buttonTextColor: "button_text_color",
          imageUrl: "image_url",
          message: "message",
          title: "title",
        }),
      ),
    ),
    name: Schema.optional(Schema.String),
    policies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
          approvalRequired: Schema.optional(Schema.Boolean),
          createdAt: Schema.optional(Schema.String),
          decision: Schema.optional(
            Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
          ),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          include: Schema.optional(Schema.Array(Schema.Unknown)),
          isolationRequired: Schema.optional(Schema.Boolean),
          name: Schema.optional(Schema.String),
          precedence: Schema.optional(Schema.Number),
          purposeJustificationPrompt: Schema.optional(Schema.String),
          purposeJustificationRequired: Schema.optional(Schema.Boolean),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
          sessionDuration: Schema.optional(Schema.String),
          updatedAt: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            approvalGroups: "approval_groups",
            approvalRequired: "approval_required",
            createdAt: "created_at",
            decision: "decision",
            exclude: "exclude",
            include: "include",
            isolationRequired: "isolation_required",
            name: "name",
            precedence: "precedence",
            purposeJustificationPrompt: "purpose_justification_prompt",
            purposeJustificationRequired: "purpose_justification_required",
            require: "require",
            sessionDuration: "session_duration",
            updatedAt: "updated_at",
          }),
        ),
      ),
    ),
    sessionDuration: Schema.optional(Schema.String),
    skipAppLauncherLoginPage: Schema.optional(Schema.Boolean),
  }).pipe(
    Schema.encodeKeys({
      type: "type",
      id: "id",
      allowedIdps: "allowed_idps",
      appLauncherLogoUrl: "app_launcher_logo_url",
      aud: "aud",
      autoRedirectToIdentity: "auto_redirect_to_identity",
      bgColor: "bg_color",
      customDenyUrl: "custom_deny_url",
      customNonIdentityDenyUrl: "custom_non_identity_deny_url",
      customPages: "custom_pages",
      domain: "domain",
      footerLinks: "footer_links",
      headerBgColor: "header_bg_color",
      landingPageDesign: "landing_page_design",
      name: "name",
      policies: "policies",
      sessionDuration: "session_duration",
      skipAppLauncherLoginPage: "skip_app_launcher_login_page",
    }),
  ),
  Schema.Struct({
    type: Schema.Literals([
      "self_hosted",
      "saas",
      "ssh",
      "vnc",
      "app_launcher",
      "warp",
      "biso",
      "bookmark",
      "dash_sso",
      "infrastructure",
      "rdp",
      "mcp",
      "mcp_portal",
      "proxy_endpoint",
    ]),
    id: Schema.optional(Schema.String),
    allowedIdps: Schema.optional(Schema.Array(Schema.String)),
    aud: Schema.optional(Schema.String),
    autoRedirectToIdentity: Schema.optional(Schema.Boolean),
    customDenyUrl: Schema.optional(Schema.String),
    customNonIdentityDenyUrl: Schema.optional(Schema.String),
    customPages: Schema.optional(Schema.Array(Schema.String)),
    domain: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    policies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
          approvalRequired: Schema.optional(Schema.Boolean),
          createdAt: Schema.optional(Schema.String),
          decision: Schema.optional(
            Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
          ),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          include: Schema.optional(Schema.Array(Schema.Unknown)),
          isolationRequired: Schema.optional(Schema.Boolean),
          name: Schema.optional(Schema.String),
          precedence: Schema.optional(Schema.Number),
          purposeJustificationPrompt: Schema.optional(Schema.String),
          purposeJustificationRequired: Schema.optional(Schema.Boolean),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
          sessionDuration: Schema.optional(Schema.String),
          updatedAt: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            approvalGroups: "approval_groups",
            approvalRequired: "approval_required",
            createdAt: "created_at",
            decision: "decision",
            exclude: "exclude",
            include: "include",
            isolationRequired: "isolation_required",
            name: "name",
            precedence: "precedence",
            purposeJustificationPrompt: "purpose_justification_prompt",
            purposeJustificationRequired: "purpose_justification_required",
            require: "require",
            sessionDuration: "session_duration",
            updatedAt: "updated_at",
          }),
        ),
      ),
    ),
    sessionDuration: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      type: "type",
      id: "id",
      allowedIdps: "allowed_idps",
      aud: "aud",
      autoRedirectToIdentity: "auto_redirect_to_identity",
      customDenyUrl: "custom_deny_url",
      customNonIdentityDenyUrl: "custom_non_identity_deny_url",
      customPages: "custom_pages",
      domain: "domain",
      name: "name",
      policies: "policies",
      sessionDuration: "session_duration",
    }),
  ),
  Schema.Struct({
    id: Schema.optional(Schema.String),
    appLauncherVisible: Schema.optional(Schema.Boolean),
    aud: Schema.optional(Schema.String),
    domain: Schema.optional(Schema.String),
    logoUrl: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    tags: Schema.optional(Schema.Array(Schema.String)),
    type: Schema.optional(
      Schema.Literals([
        "self_hosted",
        "saas",
        "ssh",
        "vnc",
        "app_launcher",
        "warp",
        "biso",
        "bookmark",
        "dash_sso",
        "infrastructure",
        "rdp",
        "mcp",
        "mcp_portal",
        "proxy_endpoint",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      appLauncherVisible: "app_launcher_visible",
      aud: "aud",
      domain: "domain",
      logoUrl: "logo_url",
      name: "name",
      tags: "tags",
      type: "type",
    }),
  ),
  Schema.Struct({
    targetCriteria: Schema.Array(
      Schema.Struct({
        port: Schema.Number,
        protocol: Schema.Literal("SSH"),
        targetAttributes: Schema.Struct({}),
      }).pipe(
        Schema.encodeKeys({
          port: "port",
          protocol: "protocol",
          targetAttributes: "target_attributes",
        }),
      ),
    ),
    type: Schema.Literals([
      "self_hosted",
      "saas",
      "ssh",
      "vnc",
      "app_launcher",
      "warp",
      "biso",
      "bookmark",
      "dash_sso",
      "infrastructure",
      "rdp",
      "mcp",
      "mcp_portal",
      "proxy_endpoint",
    ]),
    id: Schema.optional(Schema.String),
    aud: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    policies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          decision: Schema.Literals([
            "allow",
            "bypass",
            "deny",
            "non_identity",
          ]),
          include: Schema.Array(Schema.Unknown),
          name: Schema.String,
          connectionRules: Schema.optional(
            Schema.Struct({
              ssh: Schema.optional(
                Schema.Struct({
                  usernames: Schema.Array(Schema.String),
                  allowEmailAlias: Schema.optional(Schema.Boolean),
                }).pipe(
                  Schema.encodeKeys({
                    usernames: "usernames",
                    allowEmailAlias: "allow_email_alias",
                  }),
                ),
              ),
            }),
          ),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
        }).pipe(
          Schema.encodeKeys({
            decision: "decision",
            include: "include",
            name: "name",
            connectionRules: "connection_rules",
            exclude: "exclude",
            require: "require",
          }),
        ),
      ),
    ),
  }).pipe(
    Schema.encodeKeys({
      targetCriteria: "target_criteria",
      type: "type",
      id: "id",
      aud: "aud",
      name: "name",
      policies: "policies",
    }),
  ),
  Schema.Struct({
    domain: Schema.String,
    targetCriteria: Schema.Array(
      Schema.Struct({
        port: Schema.Number,
        protocol: Schema.Literal("RDP"),
        targetAttributes: Schema.Struct({}),
      }).pipe(
        Schema.encodeKeys({
          port: "port",
          protocol: "protocol",
          targetAttributes: "target_attributes",
        }),
      ),
    ),
    type: Schema.Literals([
      "self_hosted",
      "saas",
      "ssh",
      "vnc",
      "app_launcher",
      "warp",
      "biso",
      "bookmark",
      "dash_sso",
      "infrastructure",
      "rdp",
      "mcp",
      "mcp_portal",
      "proxy_endpoint",
    ]),
    id: Schema.optional(Schema.String),
    allowAuthenticateViaWarp: Schema.optional(Schema.Boolean),
    allowIframe: Schema.optional(Schema.Boolean),
    allowedIdps: Schema.optional(Schema.Array(Schema.String)),
    appLauncherVisible: Schema.optional(Schema.Boolean),
    aud: Schema.optional(Schema.String),
    autoRedirectToIdentity: Schema.optional(Schema.Boolean),
    corsHeaders: Schema.optional(Schema.Unknown),
    customDenyMessage: Schema.optional(Schema.String),
    customDenyUrl: Schema.optional(Schema.String),
    customNonIdentityDenyUrl: Schema.optional(Schema.String),
    customPages: Schema.optional(Schema.Array(Schema.String)),
    destinations: Schema.optional(
      Schema.Array(
        Schema.Union([
          Schema.Struct({
            type: Schema.optional(Schema.Literal("public")),
            uri: Schema.optional(Schema.String),
          }),
          Schema.Struct({
            cidr: Schema.optional(Schema.String),
            hostname: Schema.optional(Schema.String),
            l4Protocol: Schema.optional(Schema.Literals(["tcp", "udp"])),
            portRange: Schema.optional(Schema.String),
            type: Schema.optional(Schema.Literal("private")),
            vnetId: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              cidr: "cidr",
              hostname: "hostname",
              l4Protocol: "l4_protocol",
              portRange: "port_range",
              type: "type",
              vnetId: "vnet_id",
            }),
          ),
          Schema.Struct({
            mcpServerId: Schema.optional(Schema.String),
            type: Schema.optional(Schema.Literal("via_mcp_server_portal")),
          }).pipe(
            Schema.encodeKeys({ mcpServerId: "mcp_server_id", type: "type" }),
          ),
        ]),
      ),
    ),
    enableBindingCookie: Schema.optional(Schema.Boolean),
    httpOnlyCookieAttribute: Schema.optional(Schema.Boolean),
    logoUrl: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    optionsPreflightBypass: Schema.optional(Schema.Boolean),
    pathCookieAttribute: Schema.optional(Schema.Boolean),
    policies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
          approvalRequired: Schema.optional(Schema.Boolean),
          createdAt: Schema.optional(Schema.String),
          decision: Schema.optional(
            Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
          ),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          include: Schema.optional(Schema.Array(Schema.Unknown)),
          isolationRequired: Schema.optional(Schema.Boolean),
          name: Schema.optional(Schema.String),
          precedence: Schema.optional(Schema.Number),
          purposeJustificationPrompt: Schema.optional(Schema.String),
          purposeJustificationRequired: Schema.optional(Schema.Boolean),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
          sessionDuration: Schema.optional(Schema.String),
          updatedAt: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            approvalGroups: "approval_groups",
            approvalRequired: "approval_required",
            createdAt: "created_at",
            decision: "decision",
            exclude: "exclude",
            include: "include",
            isolationRequired: "isolation_required",
            name: "name",
            precedence: "precedence",
            purposeJustificationPrompt: "purpose_justification_prompt",
            purposeJustificationRequired: "purpose_justification_required",
            require: "require",
            sessionDuration: "session_duration",
            updatedAt: "updated_at",
          }),
        ),
      ),
    ),
    readServiceTokensFromHeader: Schema.optional(Schema.String),
    sameSiteCookieAttribute: Schema.optional(Schema.String),
    scimConfig: Schema.optional(
      Schema.Struct({
        idpUid: Schema.String,
        remoteUri: Schema.String,
        authentication: Schema.optional(
          Schema.Union([
            Schema.Unknown,
            Schema.Struct({
              clientId: Schema.String,
              clientSecret: Schema.String,
              scheme: Schema.Literal("access_service_token"),
            }).pipe(
              Schema.encodeKeys({
                clientId: "client_id",
                clientSecret: "client_secret",
                scheme: "scheme",
              }),
            ),
            Schema.Array(
              Schema.Union([
                Schema.Unknown,
                Schema.Struct({
                  clientId: Schema.String,
                  clientSecret: Schema.String,
                  scheme: Schema.Literal("access_service_token"),
                }).pipe(
                  Schema.encodeKeys({
                    clientId: "client_id",
                    clientSecret: "client_secret",
                    scheme: "scheme",
                  }),
                ),
              ]),
            ),
          ]),
        ),
        deactivateOnDelete: Schema.optional(Schema.Boolean),
        enabled: Schema.optional(Schema.Boolean),
        mappings: Schema.optional(Schema.Array(Schema.Unknown)),
      }).pipe(
        Schema.encodeKeys({
          idpUid: "idp_uid",
          remoteUri: "remote_uri",
          authentication: "authentication",
          deactivateOnDelete: "deactivate_on_delete",
          enabled: "enabled",
          mappings: "mappings",
        }),
      ),
    ),
    selfHostedDomains: Schema.optional(Schema.Array(Schema.String)),
    serviceAuth_401Redirect: Schema.optional(Schema.Boolean),
    sessionDuration: Schema.optional(Schema.String),
    skipInterstitial: Schema.optional(Schema.Boolean),
    tags: Schema.optional(Schema.Array(Schema.String)),
  }).pipe(
    Schema.encodeKeys({
      domain: "domain",
      targetCriteria: "target_criteria",
      type: "type",
      id: "id",
      allowAuthenticateViaWarp: "allow_authenticate_via_warp",
      allowIframe: "allow_iframe",
      allowedIdps: "allowed_idps",
      appLauncherVisible: "app_launcher_visible",
      aud: "aud",
      autoRedirectToIdentity: "auto_redirect_to_identity",
      corsHeaders: "cors_headers",
      customDenyMessage: "custom_deny_message",
      customDenyUrl: "custom_deny_url",
      customNonIdentityDenyUrl: "custom_non_identity_deny_url",
      customPages: "custom_pages",
      destinations: "destinations",
      enableBindingCookie: "enable_binding_cookie",
      httpOnlyCookieAttribute: "http_only_cookie_attribute",
      logoUrl: "logo_url",
      name: "name",
      optionsPreflightBypass: "options_preflight_bypass",
      pathCookieAttribute: "path_cookie_attribute",
      policies: "policies",
      readServiceTokensFromHeader: "read_service_tokens_from_header",
      sameSiteCookieAttribute: "same_site_cookie_attribute",
      scimConfig: "scim_config",
      selfHostedDomains: "self_hosted_domains",
      serviceAuth_401Redirect: "service_auth_401_redirect",
      sessionDuration: "session_duration",
      skipInterstitial: "skip_interstitial",
      tags: "tags",
    }),
  ),
]) as unknown as Schema.Schema<GetAccessApplicationResponse>;

export type GetAccessApplicationError = CommonErrors;

export const getAccessApplication: API.OperationMethod<
  GetAccessApplicationRequest,
  GetAccessApplicationResponse,
  GetAccessApplicationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccessApplicationRequest,
  output: GetAccessApplicationResponse,
  errors: [],
}));

export interface ListAccessApplicationsRequest {}

export const ListAccessApplicationsRequest = Schema.Struct({}).pipe(
  T.Http({
    method: "GET",
    path: "/{accountOrZone}/{accountOrZoneId}/access/apps",
  }),
) as unknown as Schema.Schema<ListAccessApplicationsRequest>;

export type ListAccessApplicationsResponse = (
  | {
      domain: string;
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      allowAuthenticateViaWarp?: boolean;
      allowIframe?: boolean;
      allowedIdps?: string[];
      appLauncherVisible?: boolean;
      aud?: string;
      autoRedirectToIdentity?: boolean;
      corsHeaders?: unknown;
      customDenyMessage?: string;
      customDenyUrl?: string;
      customNonIdentityDenyUrl?: string;
      customPages?: string[];
      destinations?: (
        | { type?: "public"; uri?: string }
        | {
            cidr?: string;
            hostname?: string;
            l4Protocol?: "tcp" | "udp";
            portRange?: string;
            type?: "private";
            vnetId?: string;
          }
        | { mcpServerId?: string; type?: "via_mcp_server_portal" }
      )[];
      enableBindingCookie?: boolean;
      httpOnlyCookieAttribute?: boolean;
      logoUrl?: string;
      name?: string;
      optionsPreflightBypass?: boolean;
      pathCookieAttribute?: boolean;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      readServiceTokensFromHeader?: string;
      sameSiteCookieAttribute?: string;
      scimConfig?: {
        idpUid: string;
        remoteUri: string;
        authentication?:
          | unknown
          | {
              clientId: string;
              clientSecret: string;
              scheme: "access_service_token";
            }
          | (
              | unknown
              | {
                  clientId: string;
                  clientSecret: string;
                  scheme: "access_service_token";
                }
            )[];
        deactivateOnDelete?: boolean;
        enabled?: boolean;
        mappings?: unknown[];
      };
      selfHostedDomains?: string[];
      serviceAuth_401Redirect?: boolean;
      sessionDuration?: string;
      skipInterstitial?: boolean;
      tags?: string[];
    }
  | {
      id?: string;
      allowedIdps?: string[];
      appLauncherVisible?: boolean;
      aud?: string;
      autoRedirectToIdentity?: boolean;
      customPages?: string[];
      logoUrl?: string;
      name?: string;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      saasApp?: unknown;
      scimConfig?: {
        idpUid: string;
        remoteUri: string;
        authentication?:
          | unknown
          | {
              clientId: string;
              clientSecret: string;
              scheme: "access_service_token";
            }
          | (
              | unknown
              | {
                  clientId: string;
                  clientSecret: string;
                  scheme: "access_service_token";
                }
            )[];
        deactivateOnDelete?: boolean;
        enabled?: boolean;
        mappings?: unknown[];
      };
      tags?: string[];
      type?:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
    }
  | {
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      allowedIdps?: string[];
      appLauncherLogoUrl?: string;
      aud?: string;
      autoRedirectToIdentity?: boolean;
      bgColor?: string;
      customDenyUrl?: string;
      customNonIdentityDenyUrl?: string;
      customPages?: string[];
      domain?: string;
      footerLinks?: { name: string; url: string }[];
      headerBgColor?: string;
      landingPageDesign?: {
        buttonColor?: string;
        buttonTextColor?: string;
        imageUrl?: string;
        message?: string;
        title?: string;
      };
      name?: string;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      sessionDuration?: string;
      skipAppLauncherLoginPage?: boolean;
    }
  | {
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      allowedIdps?: string[];
      aud?: string;
      autoRedirectToIdentity?: boolean;
      customDenyUrl?: string;
      customNonIdentityDenyUrl?: string;
      customPages?: string[];
      domain?: string;
      name?: string;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      sessionDuration?: string;
    }
  | {
      id?: string;
      appLauncherVisible?: boolean;
      aud?: string;
      domain?: string;
      logoUrl?: string;
      name?: string;
      tags?: string[];
      type?:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
    }
  | {
      targetCriteria: {
        port: number;
        protocol: "SSH";
        targetAttributes: Record<string, unknown>;
      }[];
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      aud?: string;
      name?: string;
      policies?: {
        decision: "allow" | "bypass" | "deny" | "non_identity";
        include: unknown[];
        name: string;
        connectionRules?: {
          ssh?: { usernames: string[]; allowEmailAlias?: boolean };
        };
        exclude?: unknown[];
        require?: unknown[];
      }[];
    }
  | {
      domain: string;
      targetCriteria: {
        port: number;
        protocol: "RDP";
        targetAttributes: Record<string, unknown>;
      }[];
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      allowAuthenticateViaWarp?: boolean;
      allowIframe?: boolean;
      allowedIdps?: string[];
      appLauncherVisible?: boolean;
      aud?: string;
      autoRedirectToIdentity?: boolean;
      corsHeaders?: unknown;
      customDenyMessage?: string;
      customDenyUrl?: string;
      customNonIdentityDenyUrl?: string;
      customPages?: string[];
      destinations?: (
        | { type?: "public"; uri?: string }
        | {
            cidr?: string;
            hostname?: string;
            l4Protocol?: "tcp" | "udp";
            portRange?: string;
            type?: "private";
            vnetId?: string;
          }
        | { mcpServerId?: string; type?: "via_mcp_server_portal" }
      )[];
      enableBindingCookie?: boolean;
      httpOnlyCookieAttribute?: boolean;
      logoUrl?: string;
      name?: string;
      optionsPreflightBypass?: boolean;
      pathCookieAttribute?: boolean;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      readServiceTokensFromHeader?: string;
      sameSiteCookieAttribute?: string;
      scimConfig?: {
        idpUid: string;
        remoteUri: string;
        authentication?:
          | unknown
          | {
              clientId: string;
              clientSecret: string;
              scheme: "access_service_token";
            }
          | (
              | unknown
              | {
                  clientId: string;
                  clientSecret: string;
                  scheme: "access_service_token";
                }
            )[];
        deactivateOnDelete?: boolean;
        enabled?: boolean;
        mappings?: unknown[];
      };
      selfHostedDomains?: string[];
      serviceAuth_401Redirect?: boolean;
      sessionDuration?: string;
      skipInterstitial?: boolean;
      tags?: string[];
    }
)[];

export const ListAccessApplicationsResponse = Schema.Array(
  Schema.Union([
    Schema.Struct({
      domain: Schema.String,
      type: Schema.Literals([
        "self_hosted",
        "saas",
        "ssh",
        "vnc",
        "app_launcher",
        "warp",
        "biso",
        "bookmark",
        "dash_sso",
        "infrastructure",
        "rdp",
        "mcp",
        "mcp_portal",
        "proxy_endpoint",
      ]),
      id: Schema.optional(Schema.String),
      allowAuthenticateViaWarp: Schema.optional(Schema.Boolean),
      allowIframe: Schema.optional(Schema.Boolean),
      allowedIdps: Schema.optional(Schema.Array(Schema.String)),
      appLauncherVisible: Schema.optional(Schema.Boolean),
      aud: Schema.optional(Schema.String),
      autoRedirectToIdentity: Schema.optional(Schema.Boolean),
      corsHeaders: Schema.optional(Schema.Unknown),
      customDenyMessage: Schema.optional(Schema.String),
      customDenyUrl: Schema.optional(Schema.String),
      customNonIdentityDenyUrl: Schema.optional(Schema.String),
      customPages: Schema.optional(Schema.Array(Schema.String)),
      destinations: Schema.optional(
        Schema.Array(
          Schema.Union([
            Schema.Struct({
              type: Schema.optional(Schema.Literal("public")),
              uri: Schema.optional(Schema.String),
            }),
            Schema.Struct({
              cidr: Schema.optional(Schema.String),
              hostname: Schema.optional(Schema.String),
              l4Protocol: Schema.optional(Schema.Literals(["tcp", "udp"])),
              portRange: Schema.optional(Schema.String),
              type: Schema.optional(Schema.Literal("private")),
              vnetId: Schema.optional(Schema.String),
            }).pipe(
              Schema.encodeKeys({
                cidr: "cidr",
                hostname: "hostname",
                l4Protocol: "l4_protocol",
                portRange: "port_range",
                type: "type",
                vnetId: "vnet_id",
              }),
            ),
            Schema.Struct({
              mcpServerId: Schema.optional(Schema.String),
              type: Schema.optional(Schema.Literal("via_mcp_server_portal")),
            }).pipe(
              Schema.encodeKeys({ mcpServerId: "mcp_server_id", type: "type" }),
            ),
          ]),
        ),
      ),
      enableBindingCookie: Schema.optional(Schema.Boolean),
      httpOnlyCookieAttribute: Schema.optional(Schema.Boolean),
      logoUrl: Schema.optional(Schema.String),
      name: Schema.optional(Schema.String),
      optionsPreflightBypass: Schema.optional(Schema.Boolean),
      pathCookieAttribute: Schema.optional(Schema.Boolean),
      policies: Schema.optional(
        Schema.Array(
          Schema.Struct({
            id: Schema.optional(Schema.String),
            approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
            approvalRequired: Schema.optional(Schema.Boolean),
            createdAt: Schema.optional(Schema.String),
            decision: Schema.optional(
              Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
            ),
            exclude: Schema.optional(Schema.Array(Schema.Unknown)),
            include: Schema.optional(Schema.Array(Schema.Unknown)),
            isolationRequired: Schema.optional(Schema.Boolean),
            name: Schema.optional(Schema.String),
            precedence: Schema.optional(Schema.Number),
            purposeJustificationPrompt: Schema.optional(Schema.String),
            purposeJustificationRequired: Schema.optional(Schema.Boolean),
            require: Schema.optional(Schema.Array(Schema.Unknown)),
            sessionDuration: Schema.optional(Schema.String),
            updatedAt: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              approvalGroups: "approval_groups",
              approvalRequired: "approval_required",
              createdAt: "created_at",
              decision: "decision",
              exclude: "exclude",
              include: "include",
              isolationRequired: "isolation_required",
              name: "name",
              precedence: "precedence",
              purposeJustificationPrompt: "purpose_justification_prompt",
              purposeJustificationRequired: "purpose_justification_required",
              require: "require",
              sessionDuration: "session_duration",
              updatedAt: "updated_at",
            }),
          ),
        ),
      ),
      readServiceTokensFromHeader: Schema.optional(Schema.String),
      sameSiteCookieAttribute: Schema.optional(Schema.String),
      scimConfig: Schema.optional(
        Schema.Struct({
          idpUid: Schema.String,
          remoteUri: Schema.String,
          authentication: Schema.optional(
            Schema.Union([
              Schema.Unknown,
              Schema.Struct({
                clientId: Schema.String,
                clientSecret: Schema.String,
                scheme: Schema.Literal("access_service_token"),
              }).pipe(
                Schema.encodeKeys({
                  clientId: "client_id",
                  clientSecret: "client_secret",
                  scheme: "scheme",
                }),
              ),
              Schema.Array(
                Schema.Union([
                  Schema.Unknown,
                  Schema.Struct({
                    clientId: Schema.String,
                    clientSecret: Schema.String,
                    scheme: Schema.Literal("access_service_token"),
                  }).pipe(
                    Schema.encodeKeys({
                      clientId: "client_id",
                      clientSecret: "client_secret",
                      scheme: "scheme",
                    }),
                  ),
                ]),
              ),
            ]),
          ),
          deactivateOnDelete: Schema.optional(Schema.Boolean),
          enabled: Schema.optional(Schema.Boolean),
          mappings: Schema.optional(Schema.Array(Schema.Unknown)),
        }).pipe(
          Schema.encodeKeys({
            idpUid: "idp_uid",
            remoteUri: "remote_uri",
            authentication: "authentication",
            deactivateOnDelete: "deactivate_on_delete",
            enabled: "enabled",
            mappings: "mappings",
          }),
        ),
      ),
      selfHostedDomains: Schema.optional(Schema.Array(Schema.String)),
      serviceAuth_401Redirect: Schema.optional(Schema.Boolean),
      sessionDuration: Schema.optional(Schema.String),
      skipInterstitial: Schema.optional(Schema.Boolean),
      tags: Schema.optional(Schema.Array(Schema.String)),
    }).pipe(
      Schema.encodeKeys({
        domain: "domain",
        type: "type",
        id: "id",
        allowAuthenticateViaWarp: "allow_authenticate_via_warp",
        allowIframe: "allow_iframe",
        allowedIdps: "allowed_idps",
        appLauncherVisible: "app_launcher_visible",
        aud: "aud",
        autoRedirectToIdentity: "auto_redirect_to_identity",
        corsHeaders: "cors_headers",
        customDenyMessage: "custom_deny_message",
        customDenyUrl: "custom_deny_url",
        customNonIdentityDenyUrl: "custom_non_identity_deny_url",
        customPages: "custom_pages",
        destinations: "destinations",
        enableBindingCookie: "enable_binding_cookie",
        httpOnlyCookieAttribute: "http_only_cookie_attribute",
        logoUrl: "logo_url",
        name: "name",
        optionsPreflightBypass: "options_preflight_bypass",
        pathCookieAttribute: "path_cookie_attribute",
        policies: "policies",
        readServiceTokensFromHeader: "read_service_tokens_from_header",
        sameSiteCookieAttribute: "same_site_cookie_attribute",
        scimConfig: "scim_config",
        selfHostedDomains: "self_hosted_domains",
        serviceAuth_401Redirect: "service_auth_401_redirect",
        sessionDuration: "session_duration",
        skipInterstitial: "skip_interstitial",
        tags: "tags",
      }),
    ),
    Schema.Struct({
      id: Schema.optional(Schema.String),
      allowedIdps: Schema.optional(Schema.Array(Schema.String)),
      appLauncherVisible: Schema.optional(Schema.Boolean),
      aud: Schema.optional(Schema.String),
      autoRedirectToIdentity: Schema.optional(Schema.Boolean),
      customPages: Schema.optional(Schema.Array(Schema.String)),
      logoUrl: Schema.optional(Schema.String),
      name: Schema.optional(Schema.String),
      policies: Schema.optional(
        Schema.Array(
          Schema.Struct({
            id: Schema.optional(Schema.String),
            approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
            approvalRequired: Schema.optional(Schema.Boolean),
            createdAt: Schema.optional(Schema.String),
            decision: Schema.optional(
              Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
            ),
            exclude: Schema.optional(Schema.Array(Schema.Unknown)),
            include: Schema.optional(Schema.Array(Schema.Unknown)),
            isolationRequired: Schema.optional(Schema.Boolean),
            name: Schema.optional(Schema.String),
            precedence: Schema.optional(Schema.Number),
            purposeJustificationPrompt: Schema.optional(Schema.String),
            purposeJustificationRequired: Schema.optional(Schema.Boolean),
            require: Schema.optional(Schema.Array(Schema.Unknown)),
            sessionDuration: Schema.optional(Schema.String),
            updatedAt: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              approvalGroups: "approval_groups",
              approvalRequired: "approval_required",
              createdAt: "created_at",
              decision: "decision",
              exclude: "exclude",
              include: "include",
              isolationRequired: "isolation_required",
              name: "name",
              precedence: "precedence",
              purposeJustificationPrompt: "purpose_justification_prompt",
              purposeJustificationRequired: "purpose_justification_required",
              require: "require",
              sessionDuration: "session_duration",
              updatedAt: "updated_at",
            }),
          ),
        ),
      ),
      saasApp: Schema.optional(Schema.Unknown),
      scimConfig: Schema.optional(
        Schema.Struct({
          idpUid: Schema.String,
          remoteUri: Schema.String,
          authentication: Schema.optional(
            Schema.Union([
              Schema.Unknown,
              Schema.Struct({
                clientId: Schema.String,
                clientSecret: Schema.String,
                scheme: Schema.Literal("access_service_token"),
              }).pipe(
                Schema.encodeKeys({
                  clientId: "client_id",
                  clientSecret: "client_secret",
                  scheme: "scheme",
                }),
              ),
              Schema.Array(
                Schema.Union([
                  Schema.Unknown,
                  Schema.Struct({
                    clientId: Schema.String,
                    clientSecret: Schema.String,
                    scheme: Schema.Literal("access_service_token"),
                  }).pipe(
                    Schema.encodeKeys({
                      clientId: "client_id",
                      clientSecret: "client_secret",
                      scheme: "scheme",
                    }),
                  ),
                ]),
              ),
            ]),
          ),
          deactivateOnDelete: Schema.optional(Schema.Boolean),
          enabled: Schema.optional(Schema.Boolean),
          mappings: Schema.optional(Schema.Array(Schema.Unknown)),
        }).pipe(
          Schema.encodeKeys({
            idpUid: "idp_uid",
            remoteUri: "remote_uri",
            authentication: "authentication",
            deactivateOnDelete: "deactivate_on_delete",
            enabled: "enabled",
            mappings: "mappings",
          }),
        ),
      ),
      tags: Schema.optional(Schema.Array(Schema.String)),
      type: Schema.optional(
        Schema.Literals([
          "self_hosted",
          "saas",
          "ssh",
          "vnc",
          "app_launcher",
          "warp",
          "biso",
          "bookmark",
          "dash_sso",
          "infrastructure",
          "rdp",
          "mcp",
          "mcp_portal",
          "proxy_endpoint",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        allowedIdps: "allowed_idps",
        appLauncherVisible: "app_launcher_visible",
        aud: "aud",
        autoRedirectToIdentity: "auto_redirect_to_identity",
        customPages: "custom_pages",
        logoUrl: "logo_url",
        name: "name",
        policies: "policies",
        saasApp: "saas_app",
        scimConfig: "scim_config",
        tags: "tags",
        type: "type",
      }),
    ),
    Schema.Struct({
      type: Schema.Literals([
        "self_hosted",
        "saas",
        "ssh",
        "vnc",
        "app_launcher",
        "warp",
        "biso",
        "bookmark",
        "dash_sso",
        "infrastructure",
        "rdp",
        "mcp",
        "mcp_portal",
        "proxy_endpoint",
      ]),
      id: Schema.optional(Schema.String),
      allowedIdps: Schema.optional(Schema.Array(Schema.String)),
      appLauncherLogoUrl: Schema.optional(Schema.String),
      aud: Schema.optional(Schema.String),
      autoRedirectToIdentity: Schema.optional(Schema.Boolean),
      bgColor: Schema.optional(Schema.String),
      customDenyUrl: Schema.optional(Schema.String),
      customNonIdentityDenyUrl: Schema.optional(Schema.String),
      customPages: Schema.optional(Schema.Array(Schema.String)),
      domain: Schema.optional(Schema.String),
      footerLinks: Schema.optional(
        Schema.Array(
          Schema.Struct({
            name: Schema.String,
            url: Schema.String,
          }),
        ),
      ),
      headerBgColor: Schema.optional(Schema.String),
      landingPageDesign: Schema.optional(
        Schema.Struct({
          buttonColor: Schema.optional(Schema.String),
          buttonTextColor: Schema.optional(Schema.String),
          imageUrl: Schema.optional(Schema.String),
          message: Schema.optional(Schema.String),
          title: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            buttonColor: "button_color",
            buttonTextColor: "button_text_color",
            imageUrl: "image_url",
            message: "message",
            title: "title",
          }),
        ),
      ),
      name: Schema.optional(Schema.String),
      policies: Schema.optional(
        Schema.Array(
          Schema.Struct({
            id: Schema.optional(Schema.String),
            approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
            approvalRequired: Schema.optional(Schema.Boolean),
            createdAt: Schema.optional(Schema.String),
            decision: Schema.optional(
              Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
            ),
            exclude: Schema.optional(Schema.Array(Schema.Unknown)),
            include: Schema.optional(Schema.Array(Schema.Unknown)),
            isolationRequired: Schema.optional(Schema.Boolean),
            name: Schema.optional(Schema.String),
            precedence: Schema.optional(Schema.Number),
            purposeJustificationPrompt: Schema.optional(Schema.String),
            purposeJustificationRequired: Schema.optional(Schema.Boolean),
            require: Schema.optional(Schema.Array(Schema.Unknown)),
            sessionDuration: Schema.optional(Schema.String),
            updatedAt: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              approvalGroups: "approval_groups",
              approvalRequired: "approval_required",
              createdAt: "created_at",
              decision: "decision",
              exclude: "exclude",
              include: "include",
              isolationRequired: "isolation_required",
              name: "name",
              precedence: "precedence",
              purposeJustificationPrompt: "purpose_justification_prompt",
              purposeJustificationRequired: "purpose_justification_required",
              require: "require",
              sessionDuration: "session_duration",
              updatedAt: "updated_at",
            }),
          ),
        ),
      ),
      sessionDuration: Schema.optional(Schema.String),
      skipAppLauncherLoginPage: Schema.optional(Schema.Boolean),
    }).pipe(
      Schema.encodeKeys({
        type: "type",
        id: "id",
        allowedIdps: "allowed_idps",
        appLauncherLogoUrl: "app_launcher_logo_url",
        aud: "aud",
        autoRedirectToIdentity: "auto_redirect_to_identity",
        bgColor: "bg_color",
        customDenyUrl: "custom_deny_url",
        customNonIdentityDenyUrl: "custom_non_identity_deny_url",
        customPages: "custom_pages",
        domain: "domain",
        footerLinks: "footer_links",
        headerBgColor: "header_bg_color",
        landingPageDesign: "landing_page_design",
        name: "name",
        policies: "policies",
        sessionDuration: "session_duration",
        skipAppLauncherLoginPage: "skip_app_launcher_login_page",
      }),
    ),
    Schema.Struct({
      type: Schema.Literals([
        "self_hosted",
        "saas",
        "ssh",
        "vnc",
        "app_launcher",
        "warp",
        "biso",
        "bookmark",
        "dash_sso",
        "infrastructure",
        "rdp",
        "mcp",
        "mcp_portal",
        "proxy_endpoint",
      ]),
      id: Schema.optional(Schema.String),
      allowedIdps: Schema.optional(Schema.Array(Schema.String)),
      aud: Schema.optional(Schema.String),
      autoRedirectToIdentity: Schema.optional(Schema.Boolean),
      customDenyUrl: Schema.optional(Schema.String),
      customNonIdentityDenyUrl: Schema.optional(Schema.String),
      customPages: Schema.optional(Schema.Array(Schema.String)),
      domain: Schema.optional(Schema.String),
      name: Schema.optional(Schema.String),
      policies: Schema.optional(
        Schema.Array(
          Schema.Struct({
            id: Schema.optional(Schema.String),
            approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
            approvalRequired: Schema.optional(Schema.Boolean),
            createdAt: Schema.optional(Schema.String),
            decision: Schema.optional(
              Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
            ),
            exclude: Schema.optional(Schema.Array(Schema.Unknown)),
            include: Schema.optional(Schema.Array(Schema.Unknown)),
            isolationRequired: Schema.optional(Schema.Boolean),
            name: Schema.optional(Schema.String),
            precedence: Schema.optional(Schema.Number),
            purposeJustificationPrompt: Schema.optional(Schema.String),
            purposeJustificationRequired: Schema.optional(Schema.Boolean),
            require: Schema.optional(Schema.Array(Schema.Unknown)),
            sessionDuration: Schema.optional(Schema.String),
            updatedAt: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              approvalGroups: "approval_groups",
              approvalRequired: "approval_required",
              createdAt: "created_at",
              decision: "decision",
              exclude: "exclude",
              include: "include",
              isolationRequired: "isolation_required",
              name: "name",
              precedence: "precedence",
              purposeJustificationPrompt: "purpose_justification_prompt",
              purposeJustificationRequired: "purpose_justification_required",
              require: "require",
              sessionDuration: "session_duration",
              updatedAt: "updated_at",
            }),
          ),
        ),
      ),
      sessionDuration: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        type: "type",
        id: "id",
        allowedIdps: "allowed_idps",
        aud: "aud",
        autoRedirectToIdentity: "auto_redirect_to_identity",
        customDenyUrl: "custom_deny_url",
        customNonIdentityDenyUrl: "custom_non_identity_deny_url",
        customPages: "custom_pages",
        domain: "domain",
        name: "name",
        policies: "policies",
        sessionDuration: "session_duration",
      }),
    ),
    Schema.Struct({
      id: Schema.optional(Schema.String),
      appLauncherVisible: Schema.optional(Schema.Boolean),
      aud: Schema.optional(Schema.String),
      domain: Schema.optional(Schema.String),
      logoUrl: Schema.optional(Schema.String),
      name: Schema.optional(Schema.String),
      tags: Schema.optional(Schema.Array(Schema.String)),
      type: Schema.optional(
        Schema.Literals([
          "self_hosted",
          "saas",
          "ssh",
          "vnc",
          "app_launcher",
          "warp",
          "biso",
          "bookmark",
          "dash_sso",
          "infrastructure",
          "rdp",
          "mcp",
          "mcp_portal",
          "proxy_endpoint",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        appLauncherVisible: "app_launcher_visible",
        aud: "aud",
        domain: "domain",
        logoUrl: "logo_url",
        name: "name",
        tags: "tags",
        type: "type",
      }),
    ),
    Schema.Struct({
      targetCriteria: Schema.Array(
        Schema.Struct({
          port: Schema.Number,
          protocol: Schema.Literal("SSH"),
          targetAttributes: Schema.Struct({}),
        }).pipe(
          Schema.encodeKeys({
            port: "port",
            protocol: "protocol",
            targetAttributes: "target_attributes",
          }),
        ),
      ),
      type: Schema.Literals([
        "self_hosted",
        "saas",
        "ssh",
        "vnc",
        "app_launcher",
        "warp",
        "biso",
        "bookmark",
        "dash_sso",
        "infrastructure",
        "rdp",
        "mcp",
        "mcp_portal",
        "proxy_endpoint",
      ]),
      id: Schema.optional(Schema.String),
      aud: Schema.optional(Schema.String),
      name: Schema.optional(Schema.String),
      policies: Schema.optional(
        Schema.Array(
          Schema.Struct({
            decision: Schema.Literals([
              "allow",
              "bypass",
              "deny",
              "non_identity",
            ]),
            include: Schema.Array(Schema.Unknown),
            name: Schema.String,
            connectionRules: Schema.optional(
              Schema.Struct({
                ssh: Schema.optional(
                  Schema.Struct({
                    usernames: Schema.Array(Schema.String),
                    allowEmailAlias: Schema.optional(Schema.Boolean),
                  }).pipe(
                    Schema.encodeKeys({
                      usernames: "usernames",
                      allowEmailAlias: "allow_email_alias",
                    }),
                  ),
                ),
              }),
            ),
            exclude: Schema.optional(Schema.Array(Schema.Unknown)),
            require: Schema.optional(Schema.Array(Schema.Unknown)),
          }).pipe(
            Schema.encodeKeys({
              decision: "decision",
              include: "include",
              name: "name",
              connectionRules: "connection_rules",
              exclude: "exclude",
              require: "require",
            }),
          ),
        ),
      ),
    }).pipe(
      Schema.encodeKeys({
        targetCriteria: "target_criteria",
        type: "type",
        id: "id",
        aud: "aud",
        name: "name",
        policies: "policies",
      }),
    ),
    Schema.Struct({
      domain: Schema.String,
      targetCriteria: Schema.Array(
        Schema.Struct({
          port: Schema.Number,
          protocol: Schema.Literal("RDP"),
          targetAttributes: Schema.Struct({}),
        }).pipe(
          Schema.encodeKeys({
            port: "port",
            protocol: "protocol",
            targetAttributes: "target_attributes",
          }),
        ),
      ),
      type: Schema.Literals([
        "self_hosted",
        "saas",
        "ssh",
        "vnc",
        "app_launcher",
        "warp",
        "biso",
        "bookmark",
        "dash_sso",
        "infrastructure",
        "rdp",
        "mcp",
        "mcp_portal",
        "proxy_endpoint",
      ]),
      id: Schema.optional(Schema.String),
      allowAuthenticateViaWarp: Schema.optional(Schema.Boolean),
      allowIframe: Schema.optional(Schema.Boolean),
      allowedIdps: Schema.optional(Schema.Array(Schema.String)),
      appLauncherVisible: Schema.optional(Schema.Boolean),
      aud: Schema.optional(Schema.String),
      autoRedirectToIdentity: Schema.optional(Schema.Boolean),
      corsHeaders: Schema.optional(Schema.Unknown),
      customDenyMessage: Schema.optional(Schema.String),
      customDenyUrl: Schema.optional(Schema.String),
      customNonIdentityDenyUrl: Schema.optional(Schema.String),
      customPages: Schema.optional(Schema.Array(Schema.String)),
      destinations: Schema.optional(
        Schema.Array(
          Schema.Union([
            Schema.Struct({
              type: Schema.optional(Schema.Literal("public")),
              uri: Schema.optional(Schema.String),
            }),
            Schema.Struct({
              cidr: Schema.optional(Schema.String),
              hostname: Schema.optional(Schema.String),
              l4Protocol: Schema.optional(Schema.Literals(["tcp", "udp"])),
              portRange: Schema.optional(Schema.String),
              type: Schema.optional(Schema.Literal("private")),
              vnetId: Schema.optional(Schema.String),
            }).pipe(
              Schema.encodeKeys({
                cidr: "cidr",
                hostname: "hostname",
                l4Protocol: "l4_protocol",
                portRange: "port_range",
                type: "type",
                vnetId: "vnet_id",
              }),
            ),
            Schema.Struct({
              mcpServerId: Schema.optional(Schema.String),
              type: Schema.optional(Schema.Literal("via_mcp_server_portal")),
            }).pipe(
              Schema.encodeKeys({ mcpServerId: "mcp_server_id", type: "type" }),
            ),
          ]),
        ),
      ),
      enableBindingCookie: Schema.optional(Schema.Boolean),
      httpOnlyCookieAttribute: Schema.optional(Schema.Boolean),
      logoUrl: Schema.optional(Schema.String),
      name: Schema.optional(Schema.String),
      optionsPreflightBypass: Schema.optional(Schema.Boolean),
      pathCookieAttribute: Schema.optional(Schema.Boolean),
      policies: Schema.optional(
        Schema.Array(
          Schema.Struct({
            id: Schema.optional(Schema.String),
            approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
            approvalRequired: Schema.optional(Schema.Boolean),
            createdAt: Schema.optional(Schema.String),
            decision: Schema.optional(
              Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
            ),
            exclude: Schema.optional(Schema.Array(Schema.Unknown)),
            include: Schema.optional(Schema.Array(Schema.Unknown)),
            isolationRequired: Schema.optional(Schema.Boolean),
            name: Schema.optional(Schema.String),
            precedence: Schema.optional(Schema.Number),
            purposeJustificationPrompt: Schema.optional(Schema.String),
            purposeJustificationRequired: Schema.optional(Schema.Boolean),
            require: Schema.optional(Schema.Array(Schema.Unknown)),
            sessionDuration: Schema.optional(Schema.String),
            updatedAt: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              approvalGroups: "approval_groups",
              approvalRequired: "approval_required",
              createdAt: "created_at",
              decision: "decision",
              exclude: "exclude",
              include: "include",
              isolationRequired: "isolation_required",
              name: "name",
              precedence: "precedence",
              purposeJustificationPrompt: "purpose_justification_prompt",
              purposeJustificationRequired: "purpose_justification_required",
              require: "require",
              sessionDuration: "session_duration",
              updatedAt: "updated_at",
            }),
          ),
        ),
      ),
      readServiceTokensFromHeader: Schema.optional(Schema.String),
      sameSiteCookieAttribute: Schema.optional(Schema.String),
      scimConfig: Schema.optional(
        Schema.Struct({
          idpUid: Schema.String,
          remoteUri: Schema.String,
          authentication: Schema.optional(
            Schema.Union([
              Schema.Unknown,
              Schema.Struct({
                clientId: Schema.String,
                clientSecret: Schema.String,
                scheme: Schema.Literal("access_service_token"),
              }).pipe(
                Schema.encodeKeys({
                  clientId: "client_id",
                  clientSecret: "client_secret",
                  scheme: "scheme",
                }),
              ),
              Schema.Array(
                Schema.Union([
                  Schema.Unknown,
                  Schema.Struct({
                    clientId: Schema.String,
                    clientSecret: Schema.String,
                    scheme: Schema.Literal("access_service_token"),
                  }).pipe(
                    Schema.encodeKeys({
                      clientId: "client_id",
                      clientSecret: "client_secret",
                      scheme: "scheme",
                    }),
                  ),
                ]),
              ),
            ]),
          ),
          deactivateOnDelete: Schema.optional(Schema.Boolean),
          enabled: Schema.optional(Schema.Boolean),
          mappings: Schema.optional(Schema.Array(Schema.Unknown)),
        }).pipe(
          Schema.encodeKeys({
            idpUid: "idp_uid",
            remoteUri: "remote_uri",
            authentication: "authentication",
            deactivateOnDelete: "deactivate_on_delete",
            enabled: "enabled",
            mappings: "mappings",
          }),
        ),
      ),
      selfHostedDomains: Schema.optional(Schema.Array(Schema.String)),
      serviceAuth_401Redirect: Schema.optional(Schema.Boolean),
      sessionDuration: Schema.optional(Schema.String),
      skipInterstitial: Schema.optional(Schema.Boolean),
      tags: Schema.optional(Schema.Array(Schema.String)),
    }).pipe(
      Schema.encodeKeys({
        domain: "domain",
        targetCriteria: "target_criteria",
        type: "type",
        id: "id",
        allowAuthenticateViaWarp: "allow_authenticate_via_warp",
        allowIframe: "allow_iframe",
        allowedIdps: "allowed_idps",
        appLauncherVisible: "app_launcher_visible",
        aud: "aud",
        autoRedirectToIdentity: "auto_redirect_to_identity",
        corsHeaders: "cors_headers",
        customDenyMessage: "custom_deny_message",
        customDenyUrl: "custom_deny_url",
        customNonIdentityDenyUrl: "custom_non_identity_deny_url",
        customPages: "custom_pages",
        destinations: "destinations",
        enableBindingCookie: "enable_binding_cookie",
        httpOnlyCookieAttribute: "http_only_cookie_attribute",
        logoUrl: "logo_url",
        name: "name",
        optionsPreflightBypass: "options_preflight_bypass",
        pathCookieAttribute: "path_cookie_attribute",
        policies: "policies",
        readServiceTokensFromHeader: "read_service_tokens_from_header",
        sameSiteCookieAttribute: "same_site_cookie_attribute",
        scimConfig: "scim_config",
        selfHostedDomains: "self_hosted_domains",
        serviceAuth_401Redirect: "service_auth_401_redirect",
        sessionDuration: "session_duration",
        skipInterstitial: "skip_interstitial",
        tags: "tags",
      }),
    ),
  ]),
) as unknown as Schema.Schema<ListAccessApplicationsResponse>;

export type ListAccessApplicationsError = CommonErrors;

export const listAccessApplications: API.OperationMethod<
  ListAccessApplicationsRequest,
  ListAccessApplicationsResponse,
  ListAccessApplicationsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessApplicationsRequest,
  output: ListAccessApplicationsResponse,
  errors: [],
}));

export interface CreateAccessApplicationRequest {
  /** Path param: The Account ID to use for this endpoint. Mutually exclusive with the Zone ID. */
  accountId?: string;
  /** Path param: The Zone ID to use for this endpoint. Mutually exclusive with the Account ID. */
  zoneId?: string;
  /** Body param: The primary hostname and path secured by Access. This domain will be displayed if the app is visible in the App Launcher. */
  domain: string;
  /** Body param: The application type. */
  type:
    | "self_hosted"
    | "saas"
    | "ssh"
    | "vnc"
    | "app_launcher"
    | "warp"
    | "biso"
    | "bookmark"
    | "dash_sso"
    | "infrastructure"
    | "rdp"
    | "mcp"
    | "mcp_portal"
    | "proxy_endpoint";
  /** Body param: When set to true, users can authenticate to this application using their WARP session. When set to false this application will always require direct IdP authentication. This setting always */
  allowAuthenticateViaWarp?: boolean;
  /** Body param: Enables loading application content in an iFrame. */
  allowIframe?: boolean;
  /** Body param: The identity providers your users can select when connecting to this application. Defaults to all IdPs configured in your account. */
  allowedIdps?: string[];
  /** Body param: Displays the application in the App Launcher. */
  appLauncherVisible?: boolean;
  /** Body param: When set to `true`, users skip the identity provider selection step during login. You must specify only one identity provider in allowed_idps. */
  autoRedirectToIdentity?: boolean;
  /** Body param: */
  corsHeaders?: {
    allowAllHeaders?: boolean;
    allowAllMethods?: boolean;
    allowAllOrigins?: boolean;
    allowCredentials?: boolean;
    allowedHeaders?: string[];
    allowedMethods?: (
      | "GET"
      | "POST"
      | "HEAD"
      | "PUT"
      | "DELETE"
      | "CONNECT"
      | "OPTIONS"
      | "TRACE"
      | "PATCH"
    )[];
    allowedOrigins?: string[];
    maxAge?: number;
  };
  /** Body param: The custom error message shown to a user when they are denied access to the application. */
  customDenyMessage?: string;
  /** Body param: The custom URL a user is redirected to when they are denied access to the application when failing identity-based rules. */
  customDenyUrl?: string;
  /** Body param: The custom URL a user is redirected to when they are denied access to the application when failing non-identity rules. */
  customNonIdentityDenyUrl?: string;
  /** Body param: The custom pages that will be displayed when applicable for this application */
  customPages?: string[];
  /** Body param: List of destinations secured by Access. This supersedes `self_hosted_domains` to allow for more flexibility in defining different types of domains. If `destinations` are provided, then `se */
  destinations?: (
    | { type?: "public"; uri?: string }
    | {
        cidr?: string;
        hostname?: string;
        l4Protocol?: "tcp" | "udp";
        portRange?: string;
        type?: "private";
        vnetId?: string;
      }
    | { mcpServerId?: string; type?: "via_mcp_server_portal" }
  )[];
  /** Body param: Enables the binding cookie, which increases security against compromised authorization tokens and CSRF attacks. */
  enableBindingCookie?: boolean;
  /** Body param: Enables the HttpOnly cookie attribute, which increases security against XSS attacks. */
  httpOnlyCookieAttribute?: boolean;
  /** Body param: The image URL for the logo shown in the App Launcher dashboard. */
  logoUrl?: string;
  /** Body param: The name of the application. */
  name?: string;
  /** Body param: Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if cors_headers is set. */
  optionsPreflightBypass?: boolean;
  /** Body param: Enables cookie paths to scope an application's JWT to the application path. If disabled, the JWT will scope to the hostname by default */
  pathCookieAttribute?: boolean;
  /** Body param: The policies that Access applies to the application, in ascending order of precedence. Items can reference existing policies or create new policies exclusive to the application. */
  policies?: (
    | { id?: string; precedence?: number }
    | string
    | {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        isolationRequired?: boolean;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        sessionDuration?: string;
      }
  )[];
  /** Body param: Allows matching Access Service Tokens passed HTTP in a single header with this name. This works as an alternative to the (CF-Access-Client-Id, CF-Access-Client-Secret) pair of headers. The */
  readServiceTokensFromHeader?: string;
  /** Body param: Sets the SameSite cookie setting, which provides increased security against CSRF attacks. */
  sameSiteCookieAttribute?: string;
  /** Body param: Configuration for provisioning to this application via SCIM. This is currently in closed beta. */
  scimConfig?: {
    idpUid: string;
    remoteUri: string;
    authentication?:
      | unknown
      | {
          clientId: string;
          clientSecret: string;
          scheme: "access_service_token";
        }
      | (
          | unknown
          | {
              clientId: string;
              clientSecret: string;
              scheme: "access_service_token";
            }
        )[];
    deactivateOnDelete?: boolean;
    enabled?: boolean;
    mappings?: unknown[];
  };
  /** @deprecated Body param: List of public domains that Access will secure. This field is deprecated in favor of `destinations` and will be supported until   November 21, 2025.  If `destinations` are prov */
  selfHostedDomains?: string[];
  /** Body param: Returns a 401 status code when the request is blocked by a Service Auth policy. */
  serviceAuth_401Redirect?: boolean;
  /** Body param: The amount of time that tokens issued for this application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. Note: unsupported for */
  sessionDuration?: string;
  /** Body param: Enables automatic authentication through cloudflared. */
  skipInterstitial?: boolean;
  /** Body param: The tags you want assigned to an application. Tags are used to filter applications in the App Launcher dashboard. */
  tags?: string[];
}

export const CreateAccessApplicationRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  domain: Schema.String,
  type: Schema.Literals([
    "self_hosted",
    "saas",
    "ssh",
    "vnc",
    "app_launcher",
    "warp",
    "biso",
    "bookmark",
    "dash_sso",
    "infrastructure",
    "rdp",
    "mcp",
    "mcp_portal",
    "proxy_endpoint",
  ]),
  allowAuthenticateViaWarp: Schema.optional(Schema.Boolean),
  allowIframe: Schema.optional(Schema.Boolean),
  allowedIdps: Schema.optional(Schema.Array(Schema.String)),
  appLauncherVisible: Schema.optional(Schema.Boolean),
  autoRedirectToIdentity: Schema.optional(Schema.Boolean),
  corsHeaders: Schema.optional(
    Schema.Struct({
      allowAllHeaders: Schema.optional(Schema.Boolean),
      allowAllMethods: Schema.optional(Schema.Boolean),
      allowAllOrigins: Schema.optional(Schema.Boolean),
      allowCredentials: Schema.optional(Schema.Boolean),
      allowedHeaders: Schema.optional(Schema.Array(Schema.String)),
      allowedMethods: Schema.optional(
        Schema.Array(
          Schema.Literals([
            "GET",
            "POST",
            "HEAD",
            "PUT",
            "DELETE",
            "CONNECT",
            "OPTIONS",
            "TRACE",
            "PATCH",
          ]),
        ),
      ),
      allowedOrigins: Schema.optional(Schema.Array(Schema.String)),
      maxAge: Schema.optional(Schema.Number),
    }).pipe(
      Schema.encodeKeys({
        allowAllHeaders: "allow_all_headers",
        allowAllMethods: "allow_all_methods",
        allowAllOrigins: "allow_all_origins",
        allowCredentials: "allow_credentials",
        allowedHeaders: "allowed_headers",
        allowedMethods: "allowed_methods",
        allowedOrigins: "allowed_origins",
        maxAge: "max_age",
      }),
    ),
  ),
  customDenyMessage: Schema.optional(Schema.String),
  customDenyUrl: Schema.optional(Schema.String),
  customNonIdentityDenyUrl: Schema.optional(Schema.String),
  customPages: Schema.optional(Schema.Array(Schema.String)),
  destinations: Schema.optional(
    Schema.Array(
      Schema.Union([
        Schema.Struct({
          type: Schema.optional(Schema.Literal("public")),
          uri: Schema.optional(Schema.String),
        }),
        Schema.Struct({
          cidr: Schema.optional(Schema.String),
          hostname: Schema.optional(Schema.String),
          l4Protocol: Schema.optional(Schema.Literals(["tcp", "udp"])),
          portRange: Schema.optional(Schema.String),
          type: Schema.optional(Schema.Literal("private")),
          vnetId: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            cidr: "cidr",
            hostname: "hostname",
            l4Protocol: "l4_protocol",
            portRange: "port_range",
            type: "type",
            vnetId: "vnet_id",
          }),
        ),
        Schema.Struct({
          mcpServerId: Schema.optional(Schema.String),
          type: Schema.optional(Schema.Literal("via_mcp_server_portal")),
        }).pipe(
          Schema.encodeKeys({ mcpServerId: "mcp_server_id", type: "type" }),
        ),
      ]),
    ),
  ),
  enableBindingCookie: Schema.optional(Schema.Boolean),
  httpOnlyCookieAttribute: Schema.optional(Schema.Boolean),
  logoUrl: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  optionsPreflightBypass: Schema.optional(Schema.Boolean),
  pathCookieAttribute: Schema.optional(Schema.Boolean),
  policies: Schema.optional(
    Schema.Array(
      Schema.Union([
        Schema.Struct({
          id: Schema.optional(Schema.String),
          precedence: Schema.optional(Schema.Number),
        }),
        Schema.String,
        Schema.Struct({
          id: Schema.optional(Schema.String),
          approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
          approvalRequired: Schema.optional(Schema.Boolean),
          isolationRequired: Schema.optional(Schema.Boolean),
          precedence: Schema.optional(Schema.Number),
          purposeJustificationPrompt: Schema.optional(Schema.String),
          purposeJustificationRequired: Schema.optional(Schema.Boolean),
          sessionDuration: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            approvalGroups: "approval_groups",
            approvalRequired: "approval_required",
            isolationRequired: "isolation_required",
            precedence: "precedence",
            purposeJustificationPrompt: "purpose_justification_prompt",
            purposeJustificationRequired: "purpose_justification_required",
            sessionDuration: "session_duration",
          }),
        ),
      ]),
    ),
  ),
  readServiceTokensFromHeader: Schema.optional(Schema.String),
  sameSiteCookieAttribute: Schema.optional(Schema.String),
  scimConfig: Schema.optional(
    Schema.Struct({
      idpUid: Schema.String,
      remoteUri: Schema.String,
      authentication: Schema.optional(
        Schema.Union([
          Schema.Unknown,
          Schema.Struct({
            clientId: Schema.String,
            clientSecret: Schema.String,
            scheme: Schema.Literal("access_service_token"),
          }).pipe(
            Schema.encodeKeys({
              clientId: "client_id",
              clientSecret: "client_secret",
              scheme: "scheme",
            }),
          ),
          Schema.Array(
            Schema.Union([
              Schema.Unknown,
              Schema.Struct({
                clientId: Schema.String,
                clientSecret: Schema.String,
                scheme: Schema.Literal("access_service_token"),
              }).pipe(
                Schema.encodeKeys({
                  clientId: "client_id",
                  clientSecret: "client_secret",
                  scheme: "scheme",
                }),
              ),
            ]),
          ),
        ]),
      ),
      deactivateOnDelete: Schema.optional(Schema.Boolean),
      enabled: Schema.optional(Schema.Boolean),
      mappings: Schema.optional(Schema.Array(Schema.Unknown)),
    }).pipe(
      Schema.encodeKeys({
        idpUid: "idp_uid",
        remoteUri: "remote_uri",
        authentication: "authentication",
        deactivateOnDelete: "deactivate_on_delete",
        enabled: "enabled",
        mappings: "mappings",
      }),
    ),
  ),
  selfHostedDomains: Schema.optional(Schema.Array(Schema.String)),
  serviceAuth_401Redirect: Schema.optional(Schema.Boolean),
  sessionDuration: Schema.optional(Schema.String),
  skipInterstitial: Schema.optional(Schema.Boolean),
  tags: Schema.optional(Schema.Array(Schema.String)),
}).pipe(
  Schema.encodeKeys({
    domain: "domain",
    type: "type",
    allowAuthenticateViaWarp: "allow_authenticate_via_warp",
    allowIframe: "allow_iframe",
    allowedIdps: "allowed_idps",
    appLauncherVisible: "app_launcher_visible",
    autoRedirectToIdentity: "auto_redirect_to_identity",
    corsHeaders: "cors_headers",
    customDenyMessage: "custom_deny_message",
    customDenyUrl: "custom_deny_url",
    customNonIdentityDenyUrl: "custom_non_identity_deny_url",
    customPages: "custom_pages",
    destinations: "destinations",
    enableBindingCookie: "enable_binding_cookie",
    httpOnlyCookieAttribute: "http_only_cookie_attribute",
    logoUrl: "logo_url",
    name: "name",
    optionsPreflightBypass: "options_preflight_bypass",
    pathCookieAttribute: "path_cookie_attribute",
    policies: "policies",
    readServiceTokensFromHeader: "read_service_tokens_from_header",
    sameSiteCookieAttribute: "same_site_cookie_attribute",
    scimConfig: "scim_config",
    selfHostedDomains: "self_hosted_domains",
    serviceAuth_401Redirect: "service_auth_401_redirect",
    sessionDuration: "session_duration",
    skipInterstitial: "skip_interstitial",
    tags: "tags",
  }),
  T.Http({
    method: "POST",
    path: "/{accountOrZone}/{accountOrZoneId}/access/apps",
  }),
) as unknown as Schema.Schema<CreateAccessApplicationRequest>;

export type CreateAccessApplicationResponse =
  | {
      domain: string;
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      allowAuthenticateViaWarp?: boolean;
      allowIframe?: boolean;
      allowedIdps?: string[];
      appLauncherVisible?: boolean;
      aud?: string;
      autoRedirectToIdentity?: boolean;
      corsHeaders?: unknown;
      customDenyMessage?: string;
      customDenyUrl?: string;
      customNonIdentityDenyUrl?: string;
      customPages?: string[];
      destinations?: (
        | { type?: "public"; uri?: string }
        | {
            cidr?: string;
            hostname?: string;
            l4Protocol?: "tcp" | "udp";
            portRange?: string;
            type?: "private";
            vnetId?: string;
          }
        | { mcpServerId?: string; type?: "via_mcp_server_portal" }
      )[];
      enableBindingCookie?: boolean;
      httpOnlyCookieAttribute?: boolean;
      logoUrl?: string;
      name?: string;
      optionsPreflightBypass?: boolean;
      pathCookieAttribute?: boolean;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      readServiceTokensFromHeader?: string;
      sameSiteCookieAttribute?: string;
      scimConfig?: {
        idpUid: string;
        remoteUri: string;
        authentication?:
          | unknown
          | {
              clientId: string;
              clientSecret: string;
              scheme: "access_service_token";
            }
          | (
              | unknown
              | {
                  clientId: string;
                  clientSecret: string;
                  scheme: "access_service_token";
                }
            )[];
        deactivateOnDelete?: boolean;
        enabled?: boolean;
        mappings?: unknown[];
      };
      selfHostedDomains?: string[];
      serviceAuth_401Redirect?: boolean;
      sessionDuration?: string;
      skipInterstitial?: boolean;
      tags?: string[];
    }
  | {
      id?: string;
      allowedIdps?: string[];
      appLauncherVisible?: boolean;
      aud?: string;
      autoRedirectToIdentity?: boolean;
      customPages?: string[];
      logoUrl?: string;
      name?: string;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      saasApp?: unknown;
      scimConfig?: {
        idpUid: string;
        remoteUri: string;
        authentication?:
          | unknown
          | {
              clientId: string;
              clientSecret: string;
              scheme: "access_service_token";
            }
          | (
              | unknown
              | {
                  clientId: string;
                  clientSecret: string;
                  scheme: "access_service_token";
                }
            )[];
        deactivateOnDelete?: boolean;
        enabled?: boolean;
        mappings?: unknown[];
      };
      tags?: string[];
      type?:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
    }
  | {
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      allowedIdps?: string[];
      appLauncherLogoUrl?: string;
      aud?: string;
      autoRedirectToIdentity?: boolean;
      bgColor?: string;
      customDenyUrl?: string;
      customNonIdentityDenyUrl?: string;
      customPages?: string[];
      domain?: string;
      footerLinks?: { name: string; url: string }[];
      headerBgColor?: string;
      landingPageDesign?: {
        buttonColor?: string;
        buttonTextColor?: string;
        imageUrl?: string;
        message?: string;
        title?: string;
      };
      name?: string;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      sessionDuration?: string;
      skipAppLauncherLoginPage?: boolean;
    }
  | {
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      allowedIdps?: string[];
      aud?: string;
      autoRedirectToIdentity?: boolean;
      customDenyUrl?: string;
      customNonIdentityDenyUrl?: string;
      customPages?: string[];
      domain?: string;
      name?: string;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      sessionDuration?: string;
    }
  | {
      id?: string;
      appLauncherVisible?: boolean;
      aud?: string;
      domain?: string;
      logoUrl?: string;
      name?: string;
      tags?: string[];
      type?:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
    }
  | {
      targetCriteria: {
        port: number;
        protocol: "SSH";
        targetAttributes: Record<string, unknown>;
      }[];
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      aud?: string;
      name?: string;
      policies?: {
        decision: "allow" | "bypass" | "deny" | "non_identity";
        include: unknown[];
        name: string;
        connectionRules?: {
          ssh?: { usernames: string[]; allowEmailAlias?: boolean };
        };
        exclude?: unknown[];
        require?: unknown[];
      }[];
    }
  | {
      domain: string;
      targetCriteria: {
        port: number;
        protocol: "RDP";
        targetAttributes: Record<string, unknown>;
      }[];
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      allowAuthenticateViaWarp?: boolean;
      allowIframe?: boolean;
      allowedIdps?: string[];
      appLauncherVisible?: boolean;
      aud?: string;
      autoRedirectToIdentity?: boolean;
      corsHeaders?: unknown;
      customDenyMessage?: string;
      customDenyUrl?: string;
      customNonIdentityDenyUrl?: string;
      customPages?: string[];
      destinations?: (
        | { type?: "public"; uri?: string }
        | {
            cidr?: string;
            hostname?: string;
            l4Protocol?: "tcp" | "udp";
            portRange?: string;
            type?: "private";
            vnetId?: string;
          }
        | { mcpServerId?: string; type?: "via_mcp_server_portal" }
      )[];
      enableBindingCookie?: boolean;
      httpOnlyCookieAttribute?: boolean;
      logoUrl?: string;
      name?: string;
      optionsPreflightBypass?: boolean;
      pathCookieAttribute?: boolean;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      readServiceTokensFromHeader?: string;
      sameSiteCookieAttribute?: string;
      scimConfig?: {
        idpUid: string;
        remoteUri: string;
        authentication?:
          | unknown
          | {
              clientId: string;
              clientSecret: string;
              scheme: "access_service_token";
            }
          | (
              | unknown
              | {
                  clientId: string;
                  clientSecret: string;
                  scheme: "access_service_token";
                }
            )[];
        deactivateOnDelete?: boolean;
        enabled?: boolean;
        mappings?: unknown[];
      };
      selfHostedDomains?: string[];
      serviceAuth_401Redirect?: boolean;
      sessionDuration?: string;
      skipInterstitial?: boolean;
      tags?: string[];
    };

export const CreateAccessApplicationResponse = Schema.Union([
  Schema.Struct({
    domain: Schema.String,
    type: Schema.Literals([
      "self_hosted",
      "saas",
      "ssh",
      "vnc",
      "app_launcher",
      "warp",
      "biso",
      "bookmark",
      "dash_sso",
      "infrastructure",
      "rdp",
      "mcp",
      "mcp_portal",
      "proxy_endpoint",
    ]),
    id: Schema.optional(Schema.String),
    allowAuthenticateViaWarp: Schema.optional(Schema.Boolean),
    allowIframe: Schema.optional(Schema.Boolean),
    allowedIdps: Schema.optional(Schema.Array(Schema.String)),
    appLauncherVisible: Schema.optional(Schema.Boolean),
    aud: Schema.optional(Schema.String),
    autoRedirectToIdentity: Schema.optional(Schema.Boolean),
    corsHeaders: Schema.optional(Schema.Unknown),
    customDenyMessage: Schema.optional(Schema.String),
    customDenyUrl: Schema.optional(Schema.String),
    customNonIdentityDenyUrl: Schema.optional(Schema.String),
    customPages: Schema.optional(Schema.Array(Schema.String)),
    destinations: Schema.optional(
      Schema.Array(
        Schema.Union([
          Schema.Struct({
            type: Schema.optional(Schema.Literal("public")),
            uri: Schema.optional(Schema.String),
          }),
          Schema.Struct({
            cidr: Schema.optional(Schema.String),
            hostname: Schema.optional(Schema.String),
            l4Protocol: Schema.optional(Schema.Literals(["tcp", "udp"])),
            portRange: Schema.optional(Schema.String),
            type: Schema.optional(Schema.Literal("private")),
            vnetId: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              cidr: "cidr",
              hostname: "hostname",
              l4Protocol: "l4_protocol",
              portRange: "port_range",
              type: "type",
              vnetId: "vnet_id",
            }),
          ),
          Schema.Struct({
            mcpServerId: Schema.optional(Schema.String),
            type: Schema.optional(Schema.Literal("via_mcp_server_portal")),
          }).pipe(
            Schema.encodeKeys({ mcpServerId: "mcp_server_id", type: "type" }),
          ),
        ]),
      ),
    ),
    enableBindingCookie: Schema.optional(Schema.Boolean),
    httpOnlyCookieAttribute: Schema.optional(Schema.Boolean),
    logoUrl: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    optionsPreflightBypass: Schema.optional(Schema.Boolean),
    pathCookieAttribute: Schema.optional(Schema.Boolean),
    policies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
          approvalRequired: Schema.optional(Schema.Boolean),
          createdAt: Schema.optional(Schema.String),
          decision: Schema.optional(
            Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
          ),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          include: Schema.optional(Schema.Array(Schema.Unknown)),
          isolationRequired: Schema.optional(Schema.Boolean),
          name: Schema.optional(Schema.String),
          precedence: Schema.optional(Schema.Number),
          purposeJustificationPrompt: Schema.optional(Schema.String),
          purposeJustificationRequired: Schema.optional(Schema.Boolean),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
          sessionDuration: Schema.optional(Schema.String),
          updatedAt: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            approvalGroups: "approval_groups",
            approvalRequired: "approval_required",
            createdAt: "created_at",
            decision: "decision",
            exclude: "exclude",
            include: "include",
            isolationRequired: "isolation_required",
            name: "name",
            precedence: "precedence",
            purposeJustificationPrompt: "purpose_justification_prompt",
            purposeJustificationRequired: "purpose_justification_required",
            require: "require",
            sessionDuration: "session_duration",
            updatedAt: "updated_at",
          }),
        ),
      ),
    ),
    readServiceTokensFromHeader: Schema.optional(Schema.String),
    sameSiteCookieAttribute: Schema.optional(Schema.String),
    scimConfig: Schema.optional(
      Schema.Struct({
        idpUid: Schema.String,
        remoteUri: Schema.String,
        authentication: Schema.optional(
          Schema.Union([
            Schema.Unknown,
            Schema.Struct({
              clientId: Schema.String,
              clientSecret: Schema.String,
              scheme: Schema.Literal("access_service_token"),
            }).pipe(
              Schema.encodeKeys({
                clientId: "client_id",
                clientSecret: "client_secret",
                scheme: "scheme",
              }),
            ),
            Schema.Array(
              Schema.Union([
                Schema.Unknown,
                Schema.Struct({
                  clientId: Schema.String,
                  clientSecret: Schema.String,
                  scheme: Schema.Literal("access_service_token"),
                }).pipe(
                  Schema.encodeKeys({
                    clientId: "client_id",
                    clientSecret: "client_secret",
                    scheme: "scheme",
                  }),
                ),
              ]),
            ),
          ]),
        ),
        deactivateOnDelete: Schema.optional(Schema.Boolean),
        enabled: Schema.optional(Schema.Boolean),
        mappings: Schema.optional(Schema.Array(Schema.Unknown)),
      }).pipe(
        Schema.encodeKeys({
          idpUid: "idp_uid",
          remoteUri: "remote_uri",
          authentication: "authentication",
          deactivateOnDelete: "deactivate_on_delete",
          enabled: "enabled",
          mappings: "mappings",
        }),
      ),
    ),
    selfHostedDomains: Schema.optional(Schema.Array(Schema.String)),
    serviceAuth_401Redirect: Schema.optional(Schema.Boolean),
    sessionDuration: Schema.optional(Schema.String),
    skipInterstitial: Schema.optional(Schema.Boolean),
    tags: Schema.optional(Schema.Array(Schema.String)),
  }).pipe(
    Schema.encodeKeys({
      domain: "domain",
      type: "type",
      id: "id",
      allowAuthenticateViaWarp: "allow_authenticate_via_warp",
      allowIframe: "allow_iframe",
      allowedIdps: "allowed_idps",
      appLauncherVisible: "app_launcher_visible",
      aud: "aud",
      autoRedirectToIdentity: "auto_redirect_to_identity",
      corsHeaders: "cors_headers",
      customDenyMessage: "custom_deny_message",
      customDenyUrl: "custom_deny_url",
      customNonIdentityDenyUrl: "custom_non_identity_deny_url",
      customPages: "custom_pages",
      destinations: "destinations",
      enableBindingCookie: "enable_binding_cookie",
      httpOnlyCookieAttribute: "http_only_cookie_attribute",
      logoUrl: "logo_url",
      name: "name",
      optionsPreflightBypass: "options_preflight_bypass",
      pathCookieAttribute: "path_cookie_attribute",
      policies: "policies",
      readServiceTokensFromHeader: "read_service_tokens_from_header",
      sameSiteCookieAttribute: "same_site_cookie_attribute",
      scimConfig: "scim_config",
      selfHostedDomains: "self_hosted_domains",
      serviceAuth_401Redirect: "service_auth_401_redirect",
      sessionDuration: "session_duration",
      skipInterstitial: "skip_interstitial",
      tags: "tags",
    }),
  ),
  Schema.Struct({
    id: Schema.optional(Schema.String),
    allowedIdps: Schema.optional(Schema.Array(Schema.String)),
    appLauncherVisible: Schema.optional(Schema.Boolean),
    aud: Schema.optional(Schema.String),
    autoRedirectToIdentity: Schema.optional(Schema.Boolean),
    customPages: Schema.optional(Schema.Array(Schema.String)),
    logoUrl: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    policies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
          approvalRequired: Schema.optional(Schema.Boolean),
          createdAt: Schema.optional(Schema.String),
          decision: Schema.optional(
            Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
          ),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          include: Schema.optional(Schema.Array(Schema.Unknown)),
          isolationRequired: Schema.optional(Schema.Boolean),
          name: Schema.optional(Schema.String),
          precedence: Schema.optional(Schema.Number),
          purposeJustificationPrompt: Schema.optional(Schema.String),
          purposeJustificationRequired: Schema.optional(Schema.Boolean),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
          sessionDuration: Schema.optional(Schema.String),
          updatedAt: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            approvalGroups: "approval_groups",
            approvalRequired: "approval_required",
            createdAt: "created_at",
            decision: "decision",
            exclude: "exclude",
            include: "include",
            isolationRequired: "isolation_required",
            name: "name",
            precedence: "precedence",
            purposeJustificationPrompt: "purpose_justification_prompt",
            purposeJustificationRequired: "purpose_justification_required",
            require: "require",
            sessionDuration: "session_duration",
            updatedAt: "updated_at",
          }),
        ),
      ),
    ),
    saasApp: Schema.optional(Schema.Unknown),
    scimConfig: Schema.optional(
      Schema.Struct({
        idpUid: Schema.String,
        remoteUri: Schema.String,
        authentication: Schema.optional(
          Schema.Union([
            Schema.Unknown,
            Schema.Struct({
              clientId: Schema.String,
              clientSecret: Schema.String,
              scheme: Schema.Literal("access_service_token"),
            }).pipe(
              Schema.encodeKeys({
                clientId: "client_id",
                clientSecret: "client_secret",
                scheme: "scheme",
              }),
            ),
            Schema.Array(
              Schema.Union([
                Schema.Unknown,
                Schema.Struct({
                  clientId: Schema.String,
                  clientSecret: Schema.String,
                  scheme: Schema.Literal("access_service_token"),
                }).pipe(
                  Schema.encodeKeys({
                    clientId: "client_id",
                    clientSecret: "client_secret",
                    scheme: "scheme",
                  }),
                ),
              ]),
            ),
          ]),
        ),
        deactivateOnDelete: Schema.optional(Schema.Boolean),
        enabled: Schema.optional(Schema.Boolean),
        mappings: Schema.optional(Schema.Array(Schema.Unknown)),
      }).pipe(
        Schema.encodeKeys({
          idpUid: "idp_uid",
          remoteUri: "remote_uri",
          authentication: "authentication",
          deactivateOnDelete: "deactivate_on_delete",
          enabled: "enabled",
          mappings: "mappings",
        }),
      ),
    ),
    tags: Schema.optional(Schema.Array(Schema.String)),
    type: Schema.optional(
      Schema.Literals([
        "self_hosted",
        "saas",
        "ssh",
        "vnc",
        "app_launcher",
        "warp",
        "biso",
        "bookmark",
        "dash_sso",
        "infrastructure",
        "rdp",
        "mcp",
        "mcp_portal",
        "proxy_endpoint",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      allowedIdps: "allowed_idps",
      appLauncherVisible: "app_launcher_visible",
      aud: "aud",
      autoRedirectToIdentity: "auto_redirect_to_identity",
      customPages: "custom_pages",
      logoUrl: "logo_url",
      name: "name",
      policies: "policies",
      saasApp: "saas_app",
      scimConfig: "scim_config",
      tags: "tags",
      type: "type",
    }),
  ),
  Schema.Struct({
    type: Schema.Literals([
      "self_hosted",
      "saas",
      "ssh",
      "vnc",
      "app_launcher",
      "warp",
      "biso",
      "bookmark",
      "dash_sso",
      "infrastructure",
      "rdp",
      "mcp",
      "mcp_portal",
      "proxy_endpoint",
    ]),
    id: Schema.optional(Schema.String),
    allowedIdps: Schema.optional(Schema.Array(Schema.String)),
    appLauncherLogoUrl: Schema.optional(Schema.String),
    aud: Schema.optional(Schema.String),
    autoRedirectToIdentity: Schema.optional(Schema.Boolean),
    bgColor: Schema.optional(Schema.String),
    customDenyUrl: Schema.optional(Schema.String),
    customNonIdentityDenyUrl: Schema.optional(Schema.String),
    customPages: Schema.optional(Schema.Array(Schema.String)),
    domain: Schema.optional(Schema.String),
    footerLinks: Schema.optional(
      Schema.Array(
        Schema.Struct({
          name: Schema.String,
          url: Schema.String,
        }),
      ),
    ),
    headerBgColor: Schema.optional(Schema.String),
    landingPageDesign: Schema.optional(
      Schema.Struct({
        buttonColor: Schema.optional(Schema.String),
        buttonTextColor: Schema.optional(Schema.String),
        imageUrl: Schema.optional(Schema.String),
        message: Schema.optional(Schema.String),
        title: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          buttonColor: "button_color",
          buttonTextColor: "button_text_color",
          imageUrl: "image_url",
          message: "message",
          title: "title",
        }),
      ),
    ),
    name: Schema.optional(Schema.String),
    policies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
          approvalRequired: Schema.optional(Schema.Boolean),
          createdAt: Schema.optional(Schema.String),
          decision: Schema.optional(
            Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
          ),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          include: Schema.optional(Schema.Array(Schema.Unknown)),
          isolationRequired: Schema.optional(Schema.Boolean),
          name: Schema.optional(Schema.String),
          precedence: Schema.optional(Schema.Number),
          purposeJustificationPrompt: Schema.optional(Schema.String),
          purposeJustificationRequired: Schema.optional(Schema.Boolean),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
          sessionDuration: Schema.optional(Schema.String),
          updatedAt: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            approvalGroups: "approval_groups",
            approvalRequired: "approval_required",
            createdAt: "created_at",
            decision: "decision",
            exclude: "exclude",
            include: "include",
            isolationRequired: "isolation_required",
            name: "name",
            precedence: "precedence",
            purposeJustificationPrompt: "purpose_justification_prompt",
            purposeJustificationRequired: "purpose_justification_required",
            require: "require",
            sessionDuration: "session_duration",
            updatedAt: "updated_at",
          }),
        ),
      ),
    ),
    sessionDuration: Schema.optional(Schema.String),
    skipAppLauncherLoginPage: Schema.optional(Schema.Boolean),
  }).pipe(
    Schema.encodeKeys({
      type: "type",
      id: "id",
      allowedIdps: "allowed_idps",
      appLauncherLogoUrl: "app_launcher_logo_url",
      aud: "aud",
      autoRedirectToIdentity: "auto_redirect_to_identity",
      bgColor: "bg_color",
      customDenyUrl: "custom_deny_url",
      customNonIdentityDenyUrl: "custom_non_identity_deny_url",
      customPages: "custom_pages",
      domain: "domain",
      footerLinks: "footer_links",
      headerBgColor: "header_bg_color",
      landingPageDesign: "landing_page_design",
      name: "name",
      policies: "policies",
      sessionDuration: "session_duration",
      skipAppLauncherLoginPage: "skip_app_launcher_login_page",
    }),
  ),
  Schema.Struct({
    type: Schema.Literals([
      "self_hosted",
      "saas",
      "ssh",
      "vnc",
      "app_launcher",
      "warp",
      "biso",
      "bookmark",
      "dash_sso",
      "infrastructure",
      "rdp",
      "mcp",
      "mcp_portal",
      "proxy_endpoint",
    ]),
    id: Schema.optional(Schema.String),
    allowedIdps: Schema.optional(Schema.Array(Schema.String)),
    aud: Schema.optional(Schema.String),
    autoRedirectToIdentity: Schema.optional(Schema.Boolean),
    customDenyUrl: Schema.optional(Schema.String),
    customNonIdentityDenyUrl: Schema.optional(Schema.String),
    customPages: Schema.optional(Schema.Array(Schema.String)),
    domain: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    policies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
          approvalRequired: Schema.optional(Schema.Boolean),
          createdAt: Schema.optional(Schema.String),
          decision: Schema.optional(
            Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
          ),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          include: Schema.optional(Schema.Array(Schema.Unknown)),
          isolationRequired: Schema.optional(Schema.Boolean),
          name: Schema.optional(Schema.String),
          precedence: Schema.optional(Schema.Number),
          purposeJustificationPrompt: Schema.optional(Schema.String),
          purposeJustificationRequired: Schema.optional(Schema.Boolean),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
          sessionDuration: Schema.optional(Schema.String),
          updatedAt: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            approvalGroups: "approval_groups",
            approvalRequired: "approval_required",
            createdAt: "created_at",
            decision: "decision",
            exclude: "exclude",
            include: "include",
            isolationRequired: "isolation_required",
            name: "name",
            precedence: "precedence",
            purposeJustificationPrompt: "purpose_justification_prompt",
            purposeJustificationRequired: "purpose_justification_required",
            require: "require",
            sessionDuration: "session_duration",
            updatedAt: "updated_at",
          }),
        ),
      ),
    ),
    sessionDuration: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      type: "type",
      id: "id",
      allowedIdps: "allowed_idps",
      aud: "aud",
      autoRedirectToIdentity: "auto_redirect_to_identity",
      customDenyUrl: "custom_deny_url",
      customNonIdentityDenyUrl: "custom_non_identity_deny_url",
      customPages: "custom_pages",
      domain: "domain",
      name: "name",
      policies: "policies",
      sessionDuration: "session_duration",
    }),
  ),
  Schema.Struct({
    id: Schema.optional(Schema.String),
    appLauncherVisible: Schema.optional(Schema.Boolean),
    aud: Schema.optional(Schema.String),
    domain: Schema.optional(Schema.String),
    logoUrl: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    tags: Schema.optional(Schema.Array(Schema.String)),
    type: Schema.optional(
      Schema.Literals([
        "self_hosted",
        "saas",
        "ssh",
        "vnc",
        "app_launcher",
        "warp",
        "biso",
        "bookmark",
        "dash_sso",
        "infrastructure",
        "rdp",
        "mcp",
        "mcp_portal",
        "proxy_endpoint",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      appLauncherVisible: "app_launcher_visible",
      aud: "aud",
      domain: "domain",
      logoUrl: "logo_url",
      name: "name",
      tags: "tags",
      type: "type",
    }),
  ),
  Schema.Struct({
    targetCriteria: Schema.Array(
      Schema.Struct({
        port: Schema.Number,
        protocol: Schema.Literal("SSH"),
        targetAttributes: Schema.Struct({}),
      }).pipe(
        Schema.encodeKeys({
          port: "port",
          protocol: "protocol",
          targetAttributes: "target_attributes",
        }),
      ),
    ),
    type: Schema.Literals([
      "self_hosted",
      "saas",
      "ssh",
      "vnc",
      "app_launcher",
      "warp",
      "biso",
      "bookmark",
      "dash_sso",
      "infrastructure",
      "rdp",
      "mcp",
      "mcp_portal",
      "proxy_endpoint",
    ]),
    id: Schema.optional(Schema.String),
    aud: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    policies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          decision: Schema.Literals([
            "allow",
            "bypass",
            "deny",
            "non_identity",
          ]),
          include: Schema.Array(Schema.Unknown),
          name: Schema.String,
          connectionRules: Schema.optional(
            Schema.Struct({
              ssh: Schema.optional(
                Schema.Struct({
                  usernames: Schema.Array(Schema.String),
                  allowEmailAlias: Schema.optional(Schema.Boolean),
                }).pipe(
                  Schema.encodeKeys({
                    usernames: "usernames",
                    allowEmailAlias: "allow_email_alias",
                  }),
                ),
              ),
            }),
          ),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
        }).pipe(
          Schema.encodeKeys({
            decision: "decision",
            include: "include",
            name: "name",
            connectionRules: "connection_rules",
            exclude: "exclude",
            require: "require",
          }),
        ),
      ),
    ),
  }).pipe(
    Schema.encodeKeys({
      targetCriteria: "target_criteria",
      type: "type",
      id: "id",
      aud: "aud",
      name: "name",
      policies: "policies",
    }),
  ),
  Schema.Struct({
    domain: Schema.String,
    targetCriteria: Schema.Array(
      Schema.Struct({
        port: Schema.Number,
        protocol: Schema.Literal("RDP"),
        targetAttributes: Schema.Struct({}),
      }).pipe(
        Schema.encodeKeys({
          port: "port",
          protocol: "protocol",
          targetAttributes: "target_attributes",
        }),
      ),
    ),
    type: Schema.Literals([
      "self_hosted",
      "saas",
      "ssh",
      "vnc",
      "app_launcher",
      "warp",
      "biso",
      "bookmark",
      "dash_sso",
      "infrastructure",
      "rdp",
      "mcp",
      "mcp_portal",
      "proxy_endpoint",
    ]),
    id: Schema.optional(Schema.String),
    allowAuthenticateViaWarp: Schema.optional(Schema.Boolean),
    allowIframe: Schema.optional(Schema.Boolean),
    allowedIdps: Schema.optional(Schema.Array(Schema.String)),
    appLauncherVisible: Schema.optional(Schema.Boolean),
    aud: Schema.optional(Schema.String),
    autoRedirectToIdentity: Schema.optional(Schema.Boolean),
    corsHeaders: Schema.optional(Schema.Unknown),
    customDenyMessage: Schema.optional(Schema.String),
    customDenyUrl: Schema.optional(Schema.String),
    customNonIdentityDenyUrl: Schema.optional(Schema.String),
    customPages: Schema.optional(Schema.Array(Schema.String)),
    destinations: Schema.optional(
      Schema.Array(
        Schema.Union([
          Schema.Struct({
            type: Schema.optional(Schema.Literal("public")),
            uri: Schema.optional(Schema.String),
          }),
          Schema.Struct({
            cidr: Schema.optional(Schema.String),
            hostname: Schema.optional(Schema.String),
            l4Protocol: Schema.optional(Schema.Literals(["tcp", "udp"])),
            portRange: Schema.optional(Schema.String),
            type: Schema.optional(Schema.Literal("private")),
            vnetId: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              cidr: "cidr",
              hostname: "hostname",
              l4Protocol: "l4_protocol",
              portRange: "port_range",
              type: "type",
              vnetId: "vnet_id",
            }),
          ),
          Schema.Struct({
            mcpServerId: Schema.optional(Schema.String),
            type: Schema.optional(Schema.Literal("via_mcp_server_portal")),
          }).pipe(
            Schema.encodeKeys({ mcpServerId: "mcp_server_id", type: "type" }),
          ),
        ]),
      ),
    ),
    enableBindingCookie: Schema.optional(Schema.Boolean),
    httpOnlyCookieAttribute: Schema.optional(Schema.Boolean),
    logoUrl: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    optionsPreflightBypass: Schema.optional(Schema.Boolean),
    pathCookieAttribute: Schema.optional(Schema.Boolean),
    policies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
          approvalRequired: Schema.optional(Schema.Boolean),
          createdAt: Schema.optional(Schema.String),
          decision: Schema.optional(
            Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
          ),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          include: Schema.optional(Schema.Array(Schema.Unknown)),
          isolationRequired: Schema.optional(Schema.Boolean),
          name: Schema.optional(Schema.String),
          precedence: Schema.optional(Schema.Number),
          purposeJustificationPrompt: Schema.optional(Schema.String),
          purposeJustificationRequired: Schema.optional(Schema.Boolean),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
          sessionDuration: Schema.optional(Schema.String),
          updatedAt: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            approvalGroups: "approval_groups",
            approvalRequired: "approval_required",
            createdAt: "created_at",
            decision: "decision",
            exclude: "exclude",
            include: "include",
            isolationRequired: "isolation_required",
            name: "name",
            precedence: "precedence",
            purposeJustificationPrompt: "purpose_justification_prompt",
            purposeJustificationRequired: "purpose_justification_required",
            require: "require",
            sessionDuration: "session_duration",
            updatedAt: "updated_at",
          }),
        ),
      ),
    ),
    readServiceTokensFromHeader: Schema.optional(Schema.String),
    sameSiteCookieAttribute: Schema.optional(Schema.String),
    scimConfig: Schema.optional(
      Schema.Struct({
        idpUid: Schema.String,
        remoteUri: Schema.String,
        authentication: Schema.optional(
          Schema.Union([
            Schema.Unknown,
            Schema.Struct({
              clientId: Schema.String,
              clientSecret: Schema.String,
              scheme: Schema.Literal("access_service_token"),
            }).pipe(
              Schema.encodeKeys({
                clientId: "client_id",
                clientSecret: "client_secret",
                scheme: "scheme",
              }),
            ),
            Schema.Array(
              Schema.Union([
                Schema.Unknown,
                Schema.Struct({
                  clientId: Schema.String,
                  clientSecret: Schema.String,
                  scheme: Schema.Literal("access_service_token"),
                }).pipe(
                  Schema.encodeKeys({
                    clientId: "client_id",
                    clientSecret: "client_secret",
                    scheme: "scheme",
                  }),
                ),
              ]),
            ),
          ]),
        ),
        deactivateOnDelete: Schema.optional(Schema.Boolean),
        enabled: Schema.optional(Schema.Boolean),
        mappings: Schema.optional(Schema.Array(Schema.Unknown)),
      }).pipe(
        Schema.encodeKeys({
          idpUid: "idp_uid",
          remoteUri: "remote_uri",
          authentication: "authentication",
          deactivateOnDelete: "deactivate_on_delete",
          enabled: "enabled",
          mappings: "mappings",
        }),
      ),
    ),
    selfHostedDomains: Schema.optional(Schema.Array(Schema.String)),
    serviceAuth_401Redirect: Schema.optional(Schema.Boolean),
    sessionDuration: Schema.optional(Schema.String),
    skipInterstitial: Schema.optional(Schema.Boolean),
    tags: Schema.optional(Schema.Array(Schema.String)),
  }).pipe(
    Schema.encodeKeys({
      domain: "domain",
      targetCriteria: "target_criteria",
      type: "type",
      id: "id",
      allowAuthenticateViaWarp: "allow_authenticate_via_warp",
      allowIframe: "allow_iframe",
      allowedIdps: "allowed_idps",
      appLauncherVisible: "app_launcher_visible",
      aud: "aud",
      autoRedirectToIdentity: "auto_redirect_to_identity",
      corsHeaders: "cors_headers",
      customDenyMessage: "custom_deny_message",
      customDenyUrl: "custom_deny_url",
      customNonIdentityDenyUrl: "custom_non_identity_deny_url",
      customPages: "custom_pages",
      destinations: "destinations",
      enableBindingCookie: "enable_binding_cookie",
      httpOnlyCookieAttribute: "http_only_cookie_attribute",
      logoUrl: "logo_url",
      name: "name",
      optionsPreflightBypass: "options_preflight_bypass",
      pathCookieAttribute: "path_cookie_attribute",
      policies: "policies",
      readServiceTokensFromHeader: "read_service_tokens_from_header",
      sameSiteCookieAttribute: "same_site_cookie_attribute",
      scimConfig: "scim_config",
      selfHostedDomains: "self_hosted_domains",
      serviceAuth_401Redirect: "service_auth_401_redirect",
      sessionDuration: "session_duration",
      skipInterstitial: "skip_interstitial",
      tags: "tags",
    }),
  ),
]) as unknown as Schema.Schema<CreateAccessApplicationResponse>;

export type CreateAccessApplicationError = CommonErrors;

export const createAccessApplication: API.OperationMethod<
  CreateAccessApplicationRequest,
  CreateAccessApplicationResponse,
  CreateAccessApplicationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAccessApplicationRequest,
  output: CreateAccessApplicationResponse,
  errors: [],
}));

export interface UpdateAccessApplicationRequest {
  /** Path param: The Account ID to use for this endpoint. Mutually exclusive with the Zone ID. */
  accountId?: string;
  /** Path param: The Zone ID to use for this endpoint. Mutually exclusive with the Account ID. */
  zoneId?: string;
  /** Body param: The primary hostname and path secured by Access. This domain will be displayed if the app is visible in the App Launcher. */
  domain: string;
  /** Body param: The application type. */
  type:
    | "self_hosted"
    | "saas"
    | "ssh"
    | "vnc"
    | "app_launcher"
    | "warp"
    | "biso"
    | "bookmark"
    | "dash_sso"
    | "infrastructure"
    | "rdp"
    | "mcp"
    | "mcp_portal"
    | "proxy_endpoint";
  /** Body param: When set to true, users can authenticate to this application using their WARP session. When set to false this application will always require direct IdP authentication. This setting always */
  allowAuthenticateViaWarp?: boolean;
  /** Body param: Enables loading application content in an iFrame. */
  allowIframe?: boolean;
  /** Body param: The identity providers your users can select when connecting to this application. Defaults to all IdPs configured in your account. */
  allowedIdps?: string[];
  /** Body param: Displays the application in the App Launcher. */
  appLauncherVisible?: boolean;
  /** Body param: When set to `true`, users skip the identity provider selection step during login. You must specify only one identity provider in allowed_idps. */
  autoRedirectToIdentity?: boolean;
  /** Body param: */
  corsHeaders?: {
    allowAllHeaders?: boolean;
    allowAllMethods?: boolean;
    allowAllOrigins?: boolean;
    allowCredentials?: boolean;
    allowedHeaders?: string[];
    allowedMethods?: (
      | "GET"
      | "POST"
      | "HEAD"
      | "PUT"
      | "DELETE"
      | "CONNECT"
      | "OPTIONS"
      | "TRACE"
      | "PATCH"
    )[];
    allowedOrigins?: string[];
    maxAge?: number;
  };
  /** Body param: The custom error message shown to a user when they are denied access to the application. */
  customDenyMessage?: string;
  /** Body param: The custom URL a user is redirected to when they are denied access to the application when failing identity-based rules. */
  customDenyUrl?: string;
  /** Body param: The custom URL a user is redirected to when they are denied access to the application when failing non-identity rules. */
  customNonIdentityDenyUrl?: string;
  /** Body param: The custom pages that will be displayed when applicable for this application */
  customPages?: string[];
  /** Body param: List of destinations secured by Access. This supersedes `self_hosted_domains` to allow for more flexibility in defining different types of domains. If `destinations` are provided, then `se */
  destinations?: (
    | { type?: "public"; uri?: string }
    | {
        cidr?: string;
        hostname?: string;
        l4Protocol?: "tcp" | "udp";
        portRange?: string;
        type?: "private";
        vnetId?: string;
      }
    | { mcpServerId?: string; type?: "via_mcp_server_portal" }
  )[];
  /** Body param: Enables the binding cookie, which increases security against compromised authorization tokens and CSRF attacks. */
  enableBindingCookie?: boolean;
  /** Body param: Enables the HttpOnly cookie attribute, which increases security against XSS attacks. */
  httpOnlyCookieAttribute?: boolean;
  /** Body param: The image URL for the logo shown in the App Launcher dashboard. */
  logoUrl?: string;
  /** Body param: The name of the application. */
  name?: string;
  /** Body param: Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if cors_headers is set. */
  optionsPreflightBypass?: boolean;
  /** Body param: Enables cookie paths to scope an application's JWT to the application path. If disabled, the JWT will scope to the hostname by default */
  pathCookieAttribute?: boolean;
  /** Body param: The policies that Access applies to the application, in ascending order of precedence. Items can reference existing policies or create new policies exclusive to the application. */
  policies?: (
    | { id?: string; precedence?: number }
    | string
    | {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        isolationRequired?: boolean;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        sessionDuration?: string;
      }
  )[];
  /** Body param: Allows matching Access Service Tokens passed HTTP in a single header with this name. This works as an alternative to the (CF-Access-Client-Id, CF-Access-Client-Secret) pair of headers. The */
  readServiceTokensFromHeader?: string;
  /** Body param: Sets the SameSite cookie setting, which provides increased security against CSRF attacks. */
  sameSiteCookieAttribute?: string;
  /** Body param: Configuration for provisioning to this application via SCIM. This is currently in closed beta. */
  scimConfig?: {
    idpUid: string;
    remoteUri: string;
    authentication?:
      | unknown
      | {
          clientId: string;
          clientSecret: string;
          scheme: "access_service_token";
        }
      | (
          | unknown
          | {
              clientId: string;
              clientSecret: string;
              scheme: "access_service_token";
            }
        )[];
    deactivateOnDelete?: boolean;
    enabled?: boolean;
    mappings?: unknown[];
  };
  /** @deprecated Body param: List of public domains that Access will secure. This field is deprecated in favor of `destinations` and will be supported until   November 21, 2025.  If `destinations` are prov */
  selfHostedDomains?: string[];
  /** Body param: Returns a 401 status code when the request is blocked by a Service Auth policy. */
  serviceAuth_401Redirect?: boolean;
  /** Body param: The amount of time that tokens issued for this application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. Note: unsupported for */
  sessionDuration?: string;
  /** Body param: Enables automatic authentication through cloudflared. */
  skipInterstitial?: boolean;
  /** Body param: The tags you want assigned to an application. Tags are used to filter applications in the App Launcher dashboard. */
  tags?: string[];
}

export const UpdateAccessApplicationRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  domain: Schema.String,
  type: Schema.Literals([
    "self_hosted",
    "saas",
    "ssh",
    "vnc",
    "app_launcher",
    "warp",
    "biso",
    "bookmark",
    "dash_sso",
    "infrastructure",
    "rdp",
    "mcp",
    "mcp_portal",
    "proxy_endpoint",
  ]),
  allowAuthenticateViaWarp: Schema.optional(Schema.Boolean),
  allowIframe: Schema.optional(Schema.Boolean),
  allowedIdps: Schema.optional(Schema.Array(Schema.String)),
  appLauncherVisible: Schema.optional(Schema.Boolean),
  autoRedirectToIdentity: Schema.optional(Schema.Boolean),
  corsHeaders: Schema.optional(
    Schema.Struct({
      allowAllHeaders: Schema.optional(Schema.Boolean),
      allowAllMethods: Schema.optional(Schema.Boolean),
      allowAllOrigins: Schema.optional(Schema.Boolean),
      allowCredentials: Schema.optional(Schema.Boolean),
      allowedHeaders: Schema.optional(Schema.Array(Schema.String)),
      allowedMethods: Schema.optional(
        Schema.Array(
          Schema.Literals([
            "GET",
            "POST",
            "HEAD",
            "PUT",
            "DELETE",
            "CONNECT",
            "OPTIONS",
            "TRACE",
            "PATCH",
          ]),
        ),
      ),
      allowedOrigins: Schema.optional(Schema.Array(Schema.String)),
      maxAge: Schema.optional(Schema.Number),
    }).pipe(
      Schema.encodeKeys({
        allowAllHeaders: "allow_all_headers",
        allowAllMethods: "allow_all_methods",
        allowAllOrigins: "allow_all_origins",
        allowCredentials: "allow_credentials",
        allowedHeaders: "allowed_headers",
        allowedMethods: "allowed_methods",
        allowedOrigins: "allowed_origins",
        maxAge: "max_age",
      }),
    ),
  ),
  customDenyMessage: Schema.optional(Schema.String),
  customDenyUrl: Schema.optional(Schema.String),
  customNonIdentityDenyUrl: Schema.optional(Schema.String),
  customPages: Schema.optional(Schema.Array(Schema.String)),
  destinations: Schema.optional(
    Schema.Array(
      Schema.Union([
        Schema.Struct({
          type: Schema.optional(Schema.Literal("public")),
          uri: Schema.optional(Schema.String),
        }),
        Schema.Struct({
          cidr: Schema.optional(Schema.String),
          hostname: Schema.optional(Schema.String),
          l4Protocol: Schema.optional(Schema.Literals(["tcp", "udp"])),
          portRange: Schema.optional(Schema.String),
          type: Schema.optional(Schema.Literal("private")),
          vnetId: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            cidr: "cidr",
            hostname: "hostname",
            l4Protocol: "l4_protocol",
            portRange: "port_range",
            type: "type",
            vnetId: "vnet_id",
          }),
        ),
        Schema.Struct({
          mcpServerId: Schema.optional(Schema.String),
          type: Schema.optional(Schema.Literal("via_mcp_server_portal")),
        }).pipe(
          Schema.encodeKeys({ mcpServerId: "mcp_server_id", type: "type" }),
        ),
      ]),
    ),
  ),
  enableBindingCookie: Schema.optional(Schema.Boolean),
  httpOnlyCookieAttribute: Schema.optional(Schema.Boolean),
  logoUrl: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  optionsPreflightBypass: Schema.optional(Schema.Boolean),
  pathCookieAttribute: Schema.optional(Schema.Boolean),
  policies: Schema.optional(
    Schema.Array(
      Schema.Union([
        Schema.Struct({
          id: Schema.optional(Schema.String),
          precedence: Schema.optional(Schema.Number),
        }),
        Schema.String,
        Schema.Struct({
          id: Schema.optional(Schema.String),
          approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
          approvalRequired: Schema.optional(Schema.Boolean),
          isolationRequired: Schema.optional(Schema.Boolean),
          precedence: Schema.optional(Schema.Number),
          purposeJustificationPrompt: Schema.optional(Schema.String),
          purposeJustificationRequired: Schema.optional(Schema.Boolean),
          sessionDuration: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            approvalGroups: "approval_groups",
            approvalRequired: "approval_required",
            isolationRequired: "isolation_required",
            precedence: "precedence",
            purposeJustificationPrompt: "purpose_justification_prompt",
            purposeJustificationRequired: "purpose_justification_required",
            sessionDuration: "session_duration",
          }),
        ),
      ]),
    ),
  ),
  readServiceTokensFromHeader: Schema.optional(Schema.String),
  sameSiteCookieAttribute: Schema.optional(Schema.String),
  scimConfig: Schema.optional(
    Schema.Struct({
      idpUid: Schema.String,
      remoteUri: Schema.String,
      authentication: Schema.optional(
        Schema.Union([
          Schema.Unknown,
          Schema.Struct({
            clientId: Schema.String,
            clientSecret: Schema.String,
            scheme: Schema.Literal("access_service_token"),
          }).pipe(
            Schema.encodeKeys({
              clientId: "client_id",
              clientSecret: "client_secret",
              scheme: "scheme",
            }),
          ),
          Schema.Array(
            Schema.Union([
              Schema.Unknown,
              Schema.Struct({
                clientId: Schema.String,
                clientSecret: Schema.String,
                scheme: Schema.Literal("access_service_token"),
              }).pipe(
                Schema.encodeKeys({
                  clientId: "client_id",
                  clientSecret: "client_secret",
                  scheme: "scheme",
                }),
              ),
            ]),
          ),
        ]),
      ),
      deactivateOnDelete: Schema.optional(Schema.Boolean),
      enabled: Schema.optional(Schema.Boolean),
      mappings: Schema.optional(Schema.Array(Schema.Unknown)),
    }).pipe(
      Schema.encodeKeys({
        idpUid: "idp_uid",
        remoteUri: "remote_uri",
        authentication: "authentication",
        deactivateOnDelete: "deactivate_on_delete",
        enabled: "enabled",
        mappings: "mappings",
      }),
    ),
  ),
  selfHostedDomains: Schema.optional(Schema.Array(Schema.String)),
  serviceAuth_401Redirect: Schema.optional(Schema.Boolean),
  sessionDuration: Schema.optional(Schema.String),
  skipInterstitial: Schema.optional(Schema.Boolean),
  tags: Schema.optional(Schema.Array(Schema.String)),
}).pipe(
  Schema.encodeKeys({
    domain: "domain",
    type: "type",
    allowAuthenticateViaWarp: "allow_authenticate_via_warp",
    allowIframe: "allow_iframe",
    allowedIdps: "allowed_idps",
    appLauncherVisible: "app_launcher_visible",
    autoRedirectToIdentity: "auto_redirect_to_identity",
    corsHeaders: "cors_headers",
    customDenyMessage: "custom_deny_message",
    customDenyUrl: "custom_deny_url",
    customNonIdentityDenyUrl: "custom_non_identity_deny_url",
    customPages: "custom_pages",
    destinations: "destinations",
    enableBindingCookie: "enable_binding_cookie",
    httpOnlyCookieAttribute: "http_only_cookie_attribute",
    logoUrl: "logo_url",
    name: "name",
    optionsPreflightBypass: "options_preflight_bypass",
    pathCookieAttribute: "path_cookie_attribute",
    policies: "policies",
    readServiceTokensFromHeader: "read_service_tokens_from_header",
    sameSiteCookieAttribute: "same_site_cookie_attribute",
    scimConfig: "scim_config",
    selfHostedDomains: "self_hosted_domains",
    serviceAuth_401Redirect: "service_auth_401_redirect",
    sessionDuration: "session_duration",
    skipInterstitial: "skip_interstitial",
    tags: "tags",
  }),
  T.Http({
    method: "PUT",
    path: "/{accountOrZone}/{accountOrZoneId}/access/apps/{appId}",
  }),
) as unknown as Schema.Schema<UpdateAccessApplicationRequest>;

export type UpdateAccessApplicationResponse =
  | {
      domain: string;
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      allowAuthenticateViaWarp?: boolean;
      allowIframe?: boolean;
      allowedIdps?: string[];
      appLauncherVisible?: boolean;
      aud?: string;
      autoRedirectToIdentity?: boolean;
      corsHeaders?: unknown;
      customDenyMessage?: string;
      customDenyUrl?: string;
      customNonIdentityDenyUrl?: string;
      customPages?: string[];
      destinations?: (
        | { type?: "public"; uri?: string }
        | {
            cidr?: string;
            hostname?: string;
            l4Protocol?: "tcp" | "udp";
            portRange?: string;
            type?: "private";
            vnetId?: string;
          }
        | { mcpServerId?: string; type?: "via_mcp_server_portal" }
      )[];
      enableBindingCookie?: boolean;
      httpOnlyCookieAttribute?: boolean;
      logoUrl?: string;
      name?: string;
      optionsPreflightBypass?: boolean;
      pathCookieAttribute?: boolean;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      readServiceTokensFromHeader?: string;
      sameSiteCookieAttribute?: string;
      scimConfig?: {
        idpUid: string;
        remoteUri: string;
        authentication?:
          | unknown
          | {
              clientId: string;
              clientSecret: string;
              scheme: "access_service_token";
            }
          | (
              | unknown
              | {
                  clientId: string;
                  clientSecret: string;
                  scheme: "access_service_token";
                }
            )[];
        deactivateOnDelete?: boolean;
        enabled?: boolean;
        mappings?: unknown[];
      };
      selfHostedDomains?: string[];
      serviceAuth_401Redirect?: boolean;
      sessionDuration?: string;
      skipInterstitial?: boolean;
      tags?: string[];
    }
  | {
      id?: string;
      allowedIdps?: string[];
      appLauncherVisible?: boolean;
      aud?: string;
      autoRedirectToIdentity?: boolean;
      customPages?: string[];
      logoUrl?: string;
      name?: string;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      saasApp?: unknown;
      scimConfig?: {
        idpUid: string;
        remoteUri: string;
        authentication?:
          | unknown
          | {
              clientId: string;
              clientSecret: string;
              scheme: "access_service_token";
            }
          | (
              | unknown
              | {
                  clientId: string;
                  clientSecret: string;
                  scheme: "access_service_token";
                }
            )[];
        deactivateOnDelete?: boolean;
        enabled?: boolean;
        mappings?: unknown[];
      };
      tags?: string[];
      type?:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
    }
  | {
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      allowedIdps?: string[];
      appLauncherLogoUrl?: string;
      aud?: string;
      autoRedirectToIdentity?: boolean;
      bgColor?: string;
      customDenyUrl?: string;
      customNonIdentityDenyUrl?: string;
      customPages?: string[];
      domain?: string;
      footerLinks?: { name: string; url: string }[];
      headerBgColor?: string;
      landingPageDesign?: {
        buttonColor?: string;
        buttonTextColor?: string;
        imageUrl?: string;
        message?: string;
        title?: string;
      };
      name?: string;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      sessionDuration?: string;
      skipAppLauncherLoginPage?: boolean;
    }
  | {
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      allowedIdps?: string[];
      aud?: string;
      autoRedirectToIdentity?: boolean;
      customDenyUrl?: string;
      customNonIdentityDenyUrl?: string;
      customPages?: string[];
      domain?: string;
      name?: string;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      sessionDuration?: string;
    }
  | {
      id?: string;
      appLauncherVisible?: boolean;
      aud?: string;
      domain?: string;
      logoUrl?: string;
      name?: string;
      tags?: string[];
      type?:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
    }
  | {
      targetCriteria: {
        port: number;
        protocol: "SSH";
        targetAttributes: Record<string, unknown>;
      }[];
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      aud?: string;
      name?: string;
      policies?: {
        decision: "allow" | "bypass" | "deny" | "non_identity";
        include: unknown[];
        name: string;
        connectionRules?: {
          ssh?: { usernames: string[]; allowEmailAlias?: boolean };
        };
        exclude?: unknown[];
        require?: unknown[];
      }[];
    }
  | {
      domain: string;
      targetCriteria: {
        port: number;
        protocol: "RDP";
        targetAttributes: Record<string, unknown>;
      }[];
      type:
        | "self_hosted"
        | "saas"
        | "ssh"
        | "vnc"
        | "app_launcher"
        | "warp"
        | "biso"
        | "bookmark"
        | "dash_sso"
        | "infrastructure"
        | "rdp"
        | "mcp"
        | "mcp_portal"
        | "proxy_endpoint";
      id?: string;
      allowAuthenticateViaWarp?: boolean;
      allowIframe?: boolean;
      allowedIdps?: string[];
      appLauncherVisible?: boolean;
      aud?: string;
      autoRedirectToIdentity?: boolean;
      corsHeaders?: unknown;
      customDenyMessage?: string;
      customDenyUrl?: string;
      customNonIdentityDenyUrl?: string;
      customPages?: string[];
      destinations?: (
        | { type?: "public"; uri?: string }
        | {
            cidr?: string;
            hostname?: string;
            l4Protocol?: "tcp" | "udp";
            portRange?: string;
            type?: "private";
            vnetId?: string;
          }
        | { mcpServerId?: string; type?: "via_mcp_server_portal" }
      )[];
      enableBindingCookie?: boolean;
      httpOnlyCookieAttribute?: boolean;
      logoUrl?: string;
      name?: string;
      optionsPreflightBypass?: boolean;
      pathCookieAttribute?: boolean;
      policies?: {
        id?: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        createdAt?: string;
        decision?: "allow" | "bypass" | "deny" | "non_identity";
        exclude?: unknown[];
        include?: unknown[];
        isolationRequired?: boolean;
        name?: string;
        precedence?: number;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
        updatedAt?: string;
      }[];
      readServiceTokensFromHeader?: string;
      sameSiteCookieAttribute?: string;
      scimConfig?: {
        idpUid: string;
        remoteUri: string;
        authentication?:
          | unknown
          | {
              clientId: string;
              clientSecret: string;
              scheme: "access_service_token";
            }
          | (
              | unknown
              | {
                  clientId: string;
                  clientSecret: string;
                  scheme: "access_service_token";
                }
            )[];
        deactivateOnDelete?: boolean;
        enabled?: boolean;
        mappings?: unknown[];
      };
      selfHostedDomains?: string[];
      serviceAuth_401Redirect?: boolean;
      sessionDuration?: string;
      skipInterstitial?: boolean;
      tags?: string[];
    };

export const UpdateAccessApplicationResponse = Schema.Union([
  Schema.Struct({
    domain: Schema.String,
    type: Schema.Literals([
      "self_hosted",
      "saas",
      "ssh",
      "vnc",
      "app_launcher",
      "warp",
      "biso",
      "bookmark",
      "dash_sso",
      "infrastructure",
      "rdp",
      "mcp",
      "mcp_portal",
      "proxy_endpoint",
    ]),
    id: Schema.optional(Schema.String),
    allowAuthenticateViaWarp: Schema.optional(Schema.Boolean),
    allowIframe: Schema.optional(Schema.Boolean),
    allowedIdps: Schema.optional(Schema.Array(Schema.String)),
    appLauncherVisible: Schema.optional(Schema.Boolean),
    aud: Schema.optional(Schema.String),
    autoRedirectToIdentity: Schema.optional(Schema.Boolean),
    corsHeaders: Schema.optional(Schema.Unknown),
    customDenyMessage: Schema.optional(Schema.String),
    customDenyUrl: Schema.optional(Schema.String),
    customNonIdentityDenyUrl: Schema.optional(Schema.String),
    customPages: Schema.optional(Schema.Array(Schema.String)),
    destinations: Schema.optional(
      Schema.Array(
        Schema.Union([
          Schema.Struct({
            type: Schema.optional(Schema.Literal("public")),
            uri: Schema.optional(Schema.String),
          }),
          Schema.Struct({
            cidr: Schema.optional(Schema.String),
            hostname: Schema.optional(Schema.String),
            l4Protocol: Schema.optional(Schema.Literals(["tcp", "udp"])),
            portRange: Schema.optional(Schema.String),
            type: Schema.optional(Schema.Literal("private")),
            vnetId: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              cidr: "cidr",
              hostname: "hostname",
              l4Protocol: "l4_protocol",
              portRange: "port_range",
              type: "type",
              vnetId: "vnet_id",
            }),
          ),
          Schema.Struct({
            mcpServerId: Schema.optional(Schema.String),
            type: Schema.optional(Schema.Literal("via_mcp_server_portal")),
          }).pipe(
            Schema.encodeKeys({ mcpServerId: "mcp_server_id", type: "type" }),
          ),
        ]),
      ),
    ),
    enableBindingCookie: Schema.optional(Schema.Boolean),
    httpOnlyCookieAttribute: Schema.optional(Schema.Boolean),
    logoUrl: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    optionsPreflightBypass: Schema.optional(Schema.Boolean),
    pathCookieAttribute: Schema.optional(Schema.Boolean),
    policies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
          approvalRequired: Schema.optional(Schema.Boolean),
          createdAt: Schema.optional(Schema.String),
          decision: Schema.optional(
            Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
          ),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          include: Schema.optional(Schema.Array(Schema.Unknown)),
          isolationRequired: Schema.optional(Schema.Boolean),
          name: Schema.optional(Schema.String),
          precedence: Schema.optional(Schema.Number),
          purposeJustificationPrompt: Schema.optional(Schema.String),
          purposeJustificationRequired: Schema.optional(Schema.Boolean),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
          sessionDuration: Schema.optional(Schema.String),
          updatedAt: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            approvalGroups: "approval_groups",
            approvalRequired: "approval_required",
            createdAt: "created_at",
            decision: "decision",
            exclude: "exclude",
            include: "include",
            isolationRequired: "isolation_required",
            name: "name",
            precedence: "precedence",
            purposeJustificationPrompt: "purpose_justification_prompt",
            purposeJustificationRequired: "purpose_justification_required",
            require: "require",
            sessionDuration: "session_duration",
            updatedAt: "updated_at",
          }),
        ),
      ),
    ),
    readServiceTokensFromHeader: Schema.optional(Schema.String),
    sameSiteCookieAttribute: Schema.optional(Schema.String),
    scimConfig: Schema.optional(
      Schema.Struct({
        idpUid: Schema.String,
        remoteUri: Schema.String,
        authentication: Schema.optional(
          Schema.Union([
            Schema.Unknown,
            Schema.Struct({
              clientId: Schema.String,
              clientSecret: Schema.String,
              scheme: Schema.Literal("access_service_token"),
            }).pipe(
              Schema.encodeKeys({
                clientId: "client_id",
                clientSecret: "client_secret",
                scheme: "scheme",
              }),
            ),
            Schema.Array(
              Schema.Union([
                Schema.Unknown,
                Schema.Struct({
                  clientId: Schema.String,
                  clientSecret: Schema.String,
                  scheme: Schema.Literal("access_service_token"),
                }).pipe(
                  Schema.encodeKeys({
                    clientId: "client_id",
                    clientSecret: "client_secret",
                    scheme: "scheme",
                  }),
                ),
              ]),
            ),
          ]),
        ),
        deactivateOnDelete: Schema.optional(Schema.Boolean),
        enabled: Schema.optional(Schema.Boolean),
        mappings: Schema.optional(Schema.Array(Schema.Unknown)),
      }).pipe(
        Schema.encodeKeys({
          idpUid: "idp_uid",
          remoteUri: "remote_uri",
          authentication: "authentication",
          deactivateOnDelete: "deactivate_on_delete",
          enabled: "enabled",
          mappings: "mappings",
        }),
      ),
    ),
    selfHostedDomains: Schema.optional(Schema.Array(Schema.String)),
    serviceAuth_401Redirect: Schema.optional(Schema.Boolean),
    sessionDuration: Schema.optional(Schema.String),
    skipInterstitial: Schema.optional(Schema.Boolean),
    tags: Schema.optional(Schema.Array(Schema.String)),
  }).pipe(
    Schema.encodeKeys({
      domain: "domain",
      type: "type",
      id: "id",
      allowAuthenticateViaWarp: "allow_authenticate_via_warp",
      allowIframe: "allow_iframe",
      allowedIdps: "allowed_idps",
      appLauncherVisible: "app_launcher_visible",
      aud: "aud",
      autoRedirectToIdentity: "auto_redirect_to_identity",
      corsHeaders: "cors_headers",
      customDenyMessage: "custom_deny_message",
      customDenyUrl: "custom_deny_url",
      customNonIdentityDenyUrl: "custom_non_identity_deny_url",
      customPages: "custom_pages",
      destinations: "destinations",
      enableBindingCookie: "enable_binding_cookie",
      httpOnlyCookieAttribute: "http_only_cookie_attribute",
      logoUrl: "logo_url",
      name: "name",
      optionsPreflightBypass: "options_preflight_bypass",
      pathCookieAttribute: "path_cookie_attribute",
      policies: "policies",
      readServiceTokensFromHeader: "read_service_tokens_from_header",
      sameSiteCookieAttribute: "same_site_cookie_attribute",
      scimConfig: "scim_config",
      selfHostedDomains: "self_hosted_domains",
      serviceAuth_401Redirect: "service_auth_401_redirect",
      sessionDuration: "session_duration",
      skipInterstitial: "skip_interstitial",
      tags: "tags",
    }),
  ),
  Schema.Struct({
    id: Schema.optional(Schema.String),
    allowedIdps: Schema.optional(Schema.Array(Schema.String)),
    appLauncherVisible: Schema.optional(Schema.Boolean),
    aud: Schema.optional(Schema.String),
    autoRedirectToIdentity: Schema.optional(Schema.Boolean),
    customPages: Schema.optional(Schema.Array(Schema.String)),
    logoUrl: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    policies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
          approvalRequired: Schema.optional(Schema.Boolean),
          createdAt: Schema.optional(Schema.String),
          decision: Schema.optional(
            Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
          ),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          include: Schema.optional(Schema.Array(Schema.Unknown)),
          isolationRequired: Schema.optional(Schema.Boolean),
          name: Schema.optional(Schema.String),
          precedence: Schema.optional(Schema.Number),
          purposeJustificationPrompt: Schema.optional(Schema.String),
          purposeJustificationRequired: Schema.optional(Schema.Boolean),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
          sessionDuration: Schema.optional(Schema.String),
          updatedAt: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            approvalGroups: "approval_groups",
            approvalRequired: "approval_required",
            createdAt: "created_at",
            decision: "decision",
            exclude: "exclude",
            include: "include",
            isolationRequired: "isolation_required",
            name: "name",
            precedence: "precedence",
            purposeJustificationPrompt: "purpose_justification_prompt",
            purposeJustificationRequired: "purpose_justification_required",
            require: "require",
            sessionDuration: "session_duration",
            updatedAt: "updated_at",
          }),
        ),
      ),
    ),
    saasApp: Schema.optional(Schema.Unknown),
    scimConfig: Schema.optional(
      Schema.Struct({
        idpUid: Schema.String,
        remoteUri: Schema.String,
        authentication: Schema.optional(
          Schema.Union([
            Schema.Unknown,
            Schema.Struct({
              clientId: Schema.String,
              clientSecret: Schema.String,
              scheme: Schema.Literal("access_service_token"),
            }).pipe(
              Schema.encodeKeys({
                clientId: "client_id",
                clientSecret: "client_secret",
                scheme: "scheme",
              }),
            ),
            Schema.Array(
              Schema.Union([
                Schema.Unknown,
                Schema.Struct({
                  clientId: Schema.String,
                  clientSecret: Schema.String,
                  scheme: Schema.Literal("access_service_token"),
                }).pipe(
                  Schema.encodeKeys({
                    clientId: "client_id",
                    clientSecret: "client_secret",
                    scheme: "scheme",
                  }),
                ),
              ]),
            ),
          ]),
        ),
        deactivateOnDelete: Schema.optional(Schema.Boolean),
        enabled: Schema.optional(Schema.Boolean),
        mappings: Schema.optional(Schema.Array(Schema.Unknown)),
      }).pipe(
        Schema.encodeKeys({
          idpUid: "idp_uid",
          remoteUri: "remote_uri",
          authentication: "authentication",
          deactivateOnDelete: "deactivate_on_delete",
          enabled: "enabled",
          mappings: "mappings",
        }),
      ),
    ),
    tags: Schema.optional(Schema.Array(Schema.String)),
    type: Schema.optional(
      Schema.Literals([
        "self_hosted",
        "saas",
        "ssh",
        "vnc",
        "app_launcher",
        "warp",
        "biso",
        "bookmark",
        "dash_sso",
        "infrastructure",
        "rdp",
        "mcp",
        "mcp_portal",
        "proxy_endpoint",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      allowedIdps: "allowed_idps",
      appLauncherVisible: "app_launcher_visible",
      aud: "aud",
      autoRedirectToIdentity: "auto_redirect_to_identity",
      customPages: "custom_pages",
      logoUrl: "logo_url",
      name: "name",
      policies: "policies",
      saasApp: "saas_app",
      scimConfig: "scim_config",
      tags: "tags",
      type: "type",
    }),
  ),
  Schema.Struct({
    type: Schema.Literals([
      "self_hosted",
      "saas",
      "ssh",
      "vnc",
      "app_launcher",
      "warp",
      "biso",
      "bookmark",
      "dash_sso",
      "infrastructure",
      "rdp",
      "mcp",
      "mcp_portal",
      "proxy_endpoint",
    ]),
    id: Schema.optional(Schema.String),
    allowedIdps: Schema.optional(Schema.Array(Schema.String)),
    appLauncherLogoUrl: Schema.optional(Schema.String),
    aud: Schema.optional(Schema.String),
    autoRedirectToIdentity: Schema.optional(Schema.Boolean),
    bgColor: Schema.optional(Schema.String),
    customDenyUrl: Schema.optional(Schema.String),
    customNonIdentityDenyUrl: Schema.optional(Schema.String),
    customPages: Schema.optional(Schema.Array(Schema.String)),
    domain: Schema.optional(Schema.String),
    footerLinks: Schema.optional(
      Schema.Array(
        Schema.Struct({
          name: Schema.String,
          url: Schema.String,
        }),
      ),
    ),
    headerBgColor: Schema.optional(Schema.String),
    landingPageDesign: Schema.optional(
      Schema.Struct({
        buttonColor: Schema.optional(Schema.String),
        buttonTextColor: Schema.optional(Schema.String),
        imageUrl: Schema.optional(Schema.String),
        message: Schema.optional(Schema.String),
        title: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          buttonColor: "button_color",
          buttonTextColor: "button_text_color",
          imageUrl: "image_url",
          message: "message",
          title: "title",
        }),
      ),
    ),
    name: Schema.optional(Schema.String),
    policies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
          approvalRequired: Schema.optional(Schema.Boolean),
          createdAt: Schema.optional(Schema.String),
          decision: Schema.optional(
            Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
          ),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          include: Schema.optional(Schema.Array(Schema.Unknown)),
          isolationRequired: Schema.optional(Schema.Boolean),
          name: Schema.optional(Schema.String),
          precedence: Schema.optional(Schema.Number),
          purposeJustificationPrompt: Schema.optional(Schema.String),
          purposeJustificationRequired: Schema.optional(Schema.Boolean),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
          sessionDuration: Schema.optional(Schema.String),
          updatedAt: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            approvalGroups: "approval_groups",
            approvalRequired: "approval_required",
            createdAt: "created_at",
            decision: "decision",
            exclude: "exclude",
            include: "include",
            isolationRequired: "isolation_required",
            name: "name",
            precedence: "precedence",
            purposeJustificationPrompt: "purpose_justification_prompt",
            purposeJustificationRequired: "purpose_justification_required",
            require: "require",
            sessionDuration: "session_duration",
            updatedAt: "updated_at",
          }),
        ),
      ),
    ),
    sessionDuration: Schema.optional(Schema.String),
    skipAppLauncherLoginPage: Schema.optional(Schema.Boolean),
  }).pipe(
    Schema.encodeKeys({
      type: "type",
      id: "id",
      allowedIdps: "allowed_idps",
      appLauncherLogoUrl: "app_launcher_logo_url",
      aud: "aud",
      autoRedirectToIdentity: "auto_redirect_to_identity",
      bgColor: "bg_color",
      customDenyUrl: "custom_deny_url",
      customNonIdentityDenyUrl: "custom_non_identity_deny_url",
      customPages: "custom_pages",
      domain: "domain",
      footerLinks: "footer_links",
      headerBgColor: "header_bg_color",
      landingPageDesign: "landing_page_design",
      name: "name",
      policies: "policies",
      sessionDuration: "session_duration",
      skipAppLauncherLoginPage: "skip_app_launcher_login_page",
    }),
  ),
  Schema.Struct({
    type: Schema.Literals([
      "self_hosted",
      "saas",
      "ssh",
      "vnc",
      "app_launcher",
      "warp",
      "biso",
      "bookmark",
      "dash_sso",
      "infrastructure",
      "rdp",
      "mcp",
      "mcp_portal",
      "proxy_endpoint",
    ]),
    id: Schema.optional(Schema.String),
    allowedIdps: Schema.optional(Schema.Array(Schema.String)),
    aud: Schema.optional(Schema.String),
    autoRedirectToIdentity: Schema.optional(Schema.Boolean),
    customDenyUrl: Schema.optional(Schema.String),
    customNonIdentityDenyUrl: Schema.optional(Schema.String),
    customPages: Schema.optional(Schema.Array(Schema.String)),
    domain: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    policies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
          approvalRequired: Schema.optional(Schema.Boolean),
          createdAt: Schema.optional(Schema.String),
          decision: Schema.optional(
            Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
          ),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          include: Schema.optional(Schema.Array(Schema.Unknown)),
          isolationRequired: Schema.optional(Schema.Boolean),
          name: Schema.optional(Schema.String),
          precedence: Schema.optional(Schema.Number),
          purposeJustificationPrompt: Schema.optional(Schema.String),
          purposeJustificationRequired: Schema.optional(Schema.Boolean),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
          sessionDuration: Schema.optional(Schema.String),
          updatedAt: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            approvalGroups: "approval_groups",
            approvalRequired: "approval_required",
            createdAt: "created_at",
            decision: "decision",
            exclude: "exclude",
            include: "include",
            isolationRequired: "isolation_required",
            name: "name",
            precedence: "precedence",
            purposeJustificationPrompt: "purpose_justification_prompt",
            purposeJustificationRequired: "purpose_justification_required",
            require: "require",
            sessionDuration: "session_duration",
            updatedAt: "updated_at",
          }),
        ),
      ),
    ),
    sessionDuration: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      type: "type",
      id: "id",
      allowedIdps: "allowed_idps",
      aud: "aud",
      autoRedirectToIdentity: "auto_redirect_to_identity",
      customDenyUrl: "custom_deny_url",
      customNonIdentityDenyUrl: "custom_non_identity_deny_url",
      customPages: "custom_pages",
      domain: "domain",
      name: "name",
      policies: "policies",
      sessionDuration: "session_duration",
    }),
  ),
  Schema.Struct({
    id: Schema.optional(Schema.String),
    appLauncherVisible: Schema.optional(Schema.Boolean),
    aud: Schema.optional(Schema.String),
    domain: Schema.optional(Schema.String),
    logoUrl: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    tags: Schema.optional(Schema.Array(Schema.String)),
    type: Schema.optional(
      Schema.Literals([
        "self_hosted",
        "saas",
        "ssh",
        "vnc",
        "app_launcher",
        "warp",
        "biso",
        "bookmark",
        "dash_sso",
        "infrastructure",
        "rdp",
        "mcp",
        "mcp_portal",
        "proxy_endpoint",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      appLauncherVisible: "app_launcher_visible",
      aud: "aud",
      domain: "domain",
      logoUrl: "logo_url",
      name: "name",
      tags: "tags",
      type: "type",
    }),
  ),
  Schema.Struct({
    targetCriteria: Schema.Array(
      Schema.Struct({
        port: Schema.Number,
        protocol: Schema.Literal("SSH"),
        targetAttributes: Schema.Struct({}),
      }).pipe(
        Schema.encodeKeys({
          port: "port",
          protocol: "protocol",
          targetAttributes: "target_attributes",
        }),
      ),
    ),
    type: Schema.Literals([
      "self_hosted",
      "saas",
      "ssh",
      "vnc",
      "app_launcher",
      "warp",
      "biso",
      "bookmark",
      "dash_sso",
      "infrastructure",
      "rdp",
      "mcp",
      "mcp_portal",
      "proxy_endpoint",
    ]),
    id: Schema.optional(Schema.String),
    aud: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    policies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          decision: Schema.Literals([
            "allow",
            "bypass",
            "deny",
            "non_identity",
          ]),
          include: Schema.Array(Schema.Unknown),
          name: Schema.String,
          connectionRules: Schema.optional(
            Schema.Struct({
              ssh: Schema.optional(
                Schema.Struct({
                  usernames: Schema.Array(Schema.String),
                  allowEmailAlias: Schema.optional(Schema.Boolean),
                }).pipe(
                  Schema.encodeKeys({
                    usernames: "usernames",
                    allowEmailAlias: "allow_email_alias",
                  }),
                ),
              ),
            }),
          ),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
        }).pipe(
          Schema.encodeKeys({
            decision: "decision",
            include: "include",
            name: "name",
            connectionRules: "connection_rules",
            exclude: "exclude",
            require: "require",
          }),
        ),
      ),
    ),
  }).pipe(
    Schema.encodeKeys({
      targetCriteria: "target_criteria",
      type: "type",
      id: "id",
      aud: "aud",
      name: "name",
      policies: "policies",
    }),
  ),
  Schema.Struct({
    domain: Schema.String,
    targetCriteria: Schema.Array(
      Schema.Struct({
        port: Schema.Number,
        protocol: Schema.Literal("RDP"),
        targetAttributes: Schema.Struct({}),
      }).pipe(
        Schema.encodeKeys({
          port: "port",
          protocol: "protocol",
          targetAttributes: "target_attributes",
        }),
      ),
    ),
    type: Schema.Literals([
      "self_hosted",
      "saas",
      "ssh",
      "vnc",
      "app_launcher",
      "warp",
      "biso",
      "bookmark",
      "dash_sso",
      "infrastructure",
      "rdp",
      "mcp",
      "mcp_portal",
      "proxy_endpoint",
    ]),
    id: Schema.optional(Schema.String),
    allowAuthenticateViaWarp: Schema.optional(Schema.Boolean),
    allowIframe: Schema.optional(Schema.Boolean),
    allowedIdps: Schema.optional(Schema.Array(Schema.String)),
    appLauncherVisible: Schema.optional(Schema.Boolean),
    aud: Schema.optional(Schema.String),
    autoRedirectToIdentity: Schema.optional(Schema.Boolean),
    corsHeaders: Schema.optional(Schema.Unknown),
    customDenyMessage: Schema.optional(Schema.String),
    customDenyUrl: Schema.optional(Schema.String),
    customNonIdentityDenyUrl: Schema.optional(Schema.String),
    customPages: Schema.optional(Schema.Array(Schema.String)),
    destinations: Schema.optional(
      Schema.Array(
        Schema.Union([
          Schema.Struct({
            type: Schema.optional(Schema.Literal("public")),
            uri: Schema.optional(Schema.String),
          }),
          Schema.Struct({
            cidr: Schema.optional(Schema.String),
            hostname: Schema.optional(Schema.String),
            l4Protocol: Schema.optional(Schema.Literals(["tcp", "udp"])),
            portRange: Schema.optional(Schema.String),
            type: Schema.optional(Schema.Literal("private")),
            vnetId: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              cidr: "cidr",
              hostname: "hostname",
              l4Protocol: "l4_protocol",
              portRange: "port_range",
              type: "type",
              vnetId: "vnet_id",
            }),
          ),
          Schema.Struct({
            mcpServerId: Schema.optional(Schema.String),
            type: Schema.optional(Schema.Literal("via_mcp_server_portal")),
          }).pipe(
            Schema.encodeKeys({ mcpServerId: "mcp_server_id", type: "type" }),
          ),
        ]),
      ),
    ),
    enableBindingCookie: Schema.optional(Schema.Boolean),
    httpOnlyCookieAttribute: Schema.optional(Schema.Boolean),
    logoUrl: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    optionsPreflightBypass: Schema.optional(Schema.Boolean),
    pathCookieAttribute: Schema.optional(Schema.Boolean),
    policies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
          approvalRequired: Schema.optional(Schema.Boolean),
          createdAt: Schema.optional(Schema.String),
          decision: Schema.optional(
            Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
          ),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          include: Schema.optional(Schema.Array(Schema.Unknown)),
          isolationRequired: Schema.optional(Schema.Boolean),
          name: Schema.optional(Schema.String),
          precedence: Schema.optional(Schema.Number),
          purposeJustificationPrompt: Schema.optional(Schema.String),
          purposeJustificationRequired: Schema.optional(Schema.Boolean),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
          sessionDuration: Schema.optional(Schema.String),
          updatedAt: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            approvalGroups: "approval_groups",
            approvalRequired: "approval_required",
            createdAt: "created_at",
            decision: "decision",
            exclude: "exclude",
            include: "include",
            isolationRequired: "isolation_required",
            name: "name",
            precedence: "precedence",
            purposeJustificationPrompt: "purpose_justification_prompt",
            purposeJustificationRequired: "purpose_justification_required",
            require: "require",
            sessionDuration: "session_duration",
            updatedAt: "updated_at",
          }),
        ),
      ),
    ),
    readServiceTokensFromHeader: Schema.optional(Schema.String),
    sameSiteCookieAttribute: Schema.optional(Schema.String),
    scimConfig: Schema.optional(
      Schema.Struct({
        idpUid: Schema.String,
        remoteUri: Schema.String,
        authentication: Schema.optional(
          Schema.Union([
            Schema.Unknown,
            Schema.Struct({
              clientId: Schema.String,
              clientSecret: Schema.String,
              scheme: Schema.Literal("access_service_token"),
            }).pipe(
              Schema.encodeKeys({
                clientId: "client_id",
                clientSecret: "client_secret",
                scheme: "scheme",
              }),
            ),
            Schema.Array(
              Schema.Union([
                Schema.Unknown,
                Schema.Struct({
                  clientId: Schema.String,
                  clientSecret: Schema.String,
                  scheme: Schema.Literal("access_service_token"),
                }).pipe(
                  Schema.encodeKeys({
                    clientId: "client_id",
                    clientSecret: "client_secret",
                    scheme: "scheme",
                  }),
                ),
              ]),
            ),
          ]),
        ),
        deactivateOnDelete: Schema.optional(Schema.Boolean),
        enabled: Schema.optional(Schema.Boolean),
        mappings: Schema.optional(Schema.Array(Schema.Unknown)),
      }).pipe(
        Schema.encodeKeys({
          idpUid: "idp_uid",
          remoteUri: "remote_uri",
          authentication: "authentication",
          deactivateOnDelete: "deactivate_on_delete",
          enabled: "enabled",
          mappings: "mappings",
        }),
      ),
    ),
    selfHostedDomains: Schema.optional(Schema.Array(Schema.String)),
    serviceAuth_401Redirect: Schema.optional(Schema.Boolean),
    sessionDuration: Schema.optional(Schema.String),
    skipInterstitial: Schema.optional(Schema.Boolean),
    tags: Schema.optional(Schema.Array(Schema.String)),
  }).pipe(
    Schema.encodeKeys({
      domain: "domain",
      targetCriteria: "target_criteria",
      type: "type",
      id: "id",
      allowAuthenticateViaWarp: "allow_authenticate_via_warp",
      allowIframe: "allow_iframe",
      allowedIdps: "allowed_idps",
      appLauncherVisible: "app_launcher_visible",
      aud: "aud",
      autoRedirectToIdentity: "auto_redirect_to_identity",
      corsHeaders: "cors_headers",
      customDenyMessage: "custom_deny_message",
      customDenyUrl: "custom_deny_url",
      customNonIdentityDenyUrl: "custom_non_identity_deny_url",
      customPages: "custom_pages",
      destinations: "destinations",
      enableBindingCookie: "enable_binding_cookie",
      httpOnlyCookieAttribute: "http_only_cookie_attribute",
      logoUrl: "logo_url",
      name: "name",
      optionsPreflightBypass: "options_preflight_bypass",
      pathCookieAttribute: "path_cookie_attribute",
      policies: "policies",
      readServiceTokensFromHeader: "read_service_tokens_from_header",
      sameSiteCookieAttribute: "same_site_cookie_attribute",
      scimConfig: "scim_config",
      selfHostedDomains: "self_hosted_domains",
      serviceAuth_401Redirect: "service_auth_401_redirect",
      sessionDuration: "session_duration",
      skipInterstitial: "skip_interstitial",
      tags: "tags",
    }),
  ),
]) as unknown as Schema.Schema<UpdateAccessApplicationResponse>;

export type UpdateAccessApplicationError = CommonErrors;

export const updateAccessApplication: API.OperationMethod<
  UpdateAccessApplicationRequest,
  UpdateAccessApplicationResponse,
  UpdateAccessApplicationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAccessApplicationRequest,
  output: UpdateAccessApplicationResponse,
  errors: [],
}));

export interface DeleteAccessApplicationRequest {}

export const DeleteAccessApplicationRequest = Schema.Struct({}).pipe(
  T.Http({
    method: "DELETE",
    path: "/{accountOrZone}/{accountOrZoneId}/access/apps/{appId}",
  }),
) as unknown as Schema.Schema<DeleteAccessApplicationRequest>;

export interface DeleteAccessApplicationResponse {
  /** UUID. */
  id?: string;
}

export const DeleteAccessApplicationResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
}) as unknown as Schema.Schema<DeleteAccessApplicationResponse>;

export type DeleteAccessApplicationError = CommonErrors;

export const deleteAccessApplication: API.OperationMethod<
  DeleteAccessApplicationRequest,
  DeleteAccessApplicationResponse,
  DeleteAccessApplicationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccessApplicationRequest,
  output: DeleteAccessApplicationResponse,
  errors: [],
}));

// =============================================================================
// AccessApplicationCa
// =============================================================================

export interface GetAccessApplicationCaRequest {
  appId: string;
}

export const GetAccessApplicationCaRequest = Schema.Struct({
  appId: Schema.String.pipe(T.HttpPath("appId")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/{accountOrZone}/{accountOrZoneId}/access/apps/{appId}/ca",
  }),
) as unknown as Schema.Schema<GetAccessApplicationCaRequest>;

export interface GetAccessApplicationCaResponse {
  /** The ID of the CA. */
  id?: string;
  /** The Application Audience (AUD) tag. Identifies the application associated with the CA. */
  aud?: string;
  /** The public key to add to your SSH server configuration. */
  publicKey?: string;
}

export const GetAccessApplicationCaResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  aud: Schema.optional(Schema.String),
  publicKey: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({ id: "id", aud: "aud", publicKey: "public_key" }),
) as unknown as Schema.Schema<GetAccessApplicationCaResponse>;

export type GetAccessApplicationCaError = CommonErrors;

export const getAccessApplicationCa: API.OperationMethod<
  GetAccessApplicationCaRequest,
  GetAccessApplicationCaResponse,
  GetAccessApplicationCaError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccessApplicationCaRequest,
  output: GetAccessApplicationCaResponse,
  errors: [],
}));

export interface ListAccessApplicationCasRequest {}

export const ListAccessApplicationCasRequest = Schema.Struct({}).pipe(
  T.Http({
    method: "GET",
    path: "/{accountOrZone}/{accountOrZoneId}/access/apps/ca",
  }),
) as unknown as Schema.Schema<ListAccessApplicationCasRequest>;

export type ListAccessApplicationCasResponse = {
  id?: string;
  aud?: string;
  publicKey?: string;
}[];

export const ListAccessApplicationCasResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    aud: Schema.optional(Schema.String),
    publicKey: Schema.optional(Schema.String),
  }).pipe(Schema.encodeKeys({ id: "id", aud: "aud", publicKey: "public_key" })),
) as unknown as Schema.Schema<ListAccessApplicationCasResponse>;

export type ListAccessApplicationCasError = CommonErrors;

export const listAccessApplicationCas: API.OperationMethod<
  ListAccessApplicationCasRequest,
  ListAccessApplicationCasResponse,
  ListAccessApplicationCasError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessApplicationCasRequest,
  output: ListAccessApplicationCasResponse,
  errors: [],
}));

export interface CreateAccessApplicationCaRequest {
  appId: string;
}

export const CreateAccessApplicationCaRequest = Schema.Struct({
  appId: Schema.String.pipe(T.HttpPath("appId")),
}).pipe(
  T.Http({
    method: "POST",
    path: "/{accountOrZone}/{accountOrZoneId}/access/apps/{appId}/ca",
  }),
) as unknown as Schema.Schema<CreateAccessApplicationCaRequest>;

export interface CreateAccessApplicationCaResponse {
  /** The ID of the CA. */
  id?: string;
  /** The Application Audience (AUD) tag. Identifies the application associated with the CA. */
  aud?: string;
  /** The public key to add to your SSH server configuration. */
  publicKey?: string;
}

export const CreateAccessApplicationCaResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  aud: Schema.optional(Schema.String),
  publicKey: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({ id: "id", aud: "aud", publicKey: "public_key" }),
) as unknown as Schema.Schema<CreateAccessApplicationCaResponse>;

export type CreateAccessApplicationCaError = CommonErrors;

export const createAccessApplicationCa: API.OperationMethod<
  CreateAccessApplicationCaRequest,
  CreateAccessApplicationCaResponse,
  CreateAccessApplicationCaError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAccessApplicationCaRequest,
  output: CreateAccessApplicationCaResponse,
  errors: [],
}));

export interface DeleteAccessApplicationCaRequest {
  appId: string;
}

export const DeleteAccessApplicationCaRequest = Schema.Struct({
  appId: Schema.String.pipe(T.HttpPath("appId")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/{accountOrZone}/{accountOrZoneId}/access/apps/{appId}/ca",
  }),
) as unknown as Schema.Schema<DeleteAccessApplicationCaRequest>;

export interface DeleteAccessApplicationCaResponse {
  /** The ID of the CA. */
  id?: string;
}

export const DeleteAccessApplicationCaResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
}) as unknown as Schema.Schema<DeleteAccessApplicationCaResponse>;

export type DeleteAccessApplicationCaError = CommonErrors;

export const deleteAccessApplicationCa: API.OperationMethod<
  DeleteAccessApplicationCaRequest,
  DeleteAccessApplicationCaResponse,
  DeleteAccessApplicationCaError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccessApplicationCaRequest,
  output: DeleteAccessApplicationCaResponse,
  errors: [],
}));

// =============================================================================
// AccessApplicationPolicy
// =============================================================================

export interface GetAccessApplicationPolicyRequest {
  appId: string;
  policyId: string;
}

export const GetAccessApplicationPolicyRequest = Schema.Struct({
  appId: Schema.String.pipe(T.HttpPath("appId")),
  policyId: Schema.String.pipe(T.HttpPath("policyId")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/{accountOrZone}/{accountOrZoneId}/access/apps/{appId}/policies/{policyId}",
  }),
) as unknown as Schema.Schema<GetAccessApplicationPolicyRequest>;

export interface GetAccessApplicationPolicyResponse {
  /** The UUID of the policy */
  id?: string;
  /** Administrators who can approve a temporary authentication request. */
  approvalGroups?: unknown[];
  /** Requires the user to request access from an administrator at the start of each session. */
  approvalRequired?: boolean;
  createdAt?: string;
  /** The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action. */
  decision?: "allow" | "bypass" | "deny" | "non_identity";
  /** Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules. */
  exclude?: (
    | { group: { id: string } }
    | { anyValidServiceToken: unknown }
    | { authContext: { id: string; acId: string; identityProviderId: string } }
    | { authMethod: { authMethod: string } }
    | { azureAD: { id: string; identityProviderId: string } }
    | { certificate: unknown }
    | { commonName: { commonName: string } }
    | { geo: { countryCode: string } }
    | { devicePosture: { integrationUid: string } }
    | { emailDomain: { domain: string } }
    | { emailList: { id: string } }
    | { email: { email: string } }
    | { everyone: unknown }
    | { externalEvaluation: { evaluateUrl: string; keysUrl: string } }
    | {
        githubOrganization: {
          identityProviderId: string;
          name: string;
          team?: string;
        };
      }
    | { gsuite: { email: string; identityProviderId: string } }
    | { loginMethod: { id: string } }
    | { ipList: { id: string } }
    | { ip: { ip: string } }
    | { okta: { identityProviderId: string; name: string } }
    | {
        saml: {
          attributeName: string;
          attributeValue: string;
          identityProviderId: string;
        };
      }
    | {
        oidc: {
          claimName: string;
          claimValue: string;
          identityProviderId: string;
        };
      }
    | { serviceToken: { tokenId: string } }
    | { linkedAppToken: { appUid: string } }
  )[];
  /** Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules. */
  include?: (
    | { group: { id: string } }
    | { anyValidServiceToken: unknown }
    | { authContext: { id: string; acId: string; identityProviderId: string } }
    | { authMethod: { authMethod: string } }
    | { azureAD: { id: string; identityProviderId: string } }
    | { certificate: unknown }
    | { commonName: { commonName: string } }
    | { geo: { countryCode: string } }
    | { devicePosture: { integrationUid: string } }
    | { emailDomain: { domain: string } }
    | { emailList: { id: string } }
    | { email: { email: string } }
    | { everyone: unknown }
    | { externalEvaluation: { evaluateUrl: string; keysUrl: string } }
    | {
        githubOrganization: {
          identityProviderId: string;
          name: string;
          team?: string;
        };
      }
    | { gsuite: { email: string; identityProviderId: string } }
    | { loginMethod: { id: string } }
    | { ipList: { id: string } }
    | { ip: { ip: string } }
    | { okta: { identityProviderId: string; name: string } }
    | {
        saml: {
          attributeName: string;
          attributeValue: string;
          identityProviderId: string;
        };
      }
    | {
        oidc: {
          claimName: string;
          claimValue: string;
          identityProviderId: string;
        };
      }
    | { serviceToken: { tokenId: string } }
    | { linkedAppToken: { appUid: string } }
  )[];
  /** Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature. */
  isolationRequired?: boolean;
  /** The name of the Access policy. */
  name?: string;
  /** The order of execution for this policy. Must be unique for each policy within an app. */
  precedence?: number;
  /** A custom message that will appear on the purpose justification screen. */
  purposeJustificationPrompt?: string;
  /** Require users to enter a justification when they log in to the application. */
  purposeJustificationRequired?: boolean;
  /** Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules. */
  require?: (
    | { group: { id: string } }
    | { anyValidServiceToken: unknown }
    | { authContext: { id: string; acId: string; identityProviderId: string } }
    | { authMethod: { authMethod: string } }
    | { azureAD: { id: string; identityProviderId: string } }
    | { certificate: unknown }
    | { commonName: { commonName: string } }
    | { geo: { countryCode: string } }
    | { devicePosture: { integrationUid: string } }
    | { emailDomain: { domain: string } }
    | { emailList: { id: string } }
    | { email: { email: string } }
    | { everyone: unknown }
    | { externalEvaluation: { evaluateUrl: string; keysUrl: string } }
    | {
        githubOrganization: {
          identityProviderId: string;
          name: string;
          team?: string;
        };
      }
    | { gsuite: { email: string; identityProviderId: string } }
    | { loginMethod: { id: string } }
    | { ipList: { id: string } }
    | { ip: { ip: string } }
    | { okta: { identityProviderId: string; name: string } }
    | {
        saml: {
          attributeName: string;
          attributeValue: string;
          identityProviderId: string;
        };
      }
    | {
        oidc: {
          claimName: string;
          claimValue: string;
          identityProviderId: string;
        };
      }
    | { serviceToken: { tokenId: string } }
    | { linkedAppToken: { appUid: string } }
  )[];
  /** The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. */
  sessionDuration?: string;
  updatedAt?: string;
}

export const GetAccessApplicationPolicyResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
  approvalRequired: Schema.optional(Schema.Boolean),
  createdAt: Schema.optional(Schema.String),
  decision: Schema.optional(
    Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
  ),
  exclude: Schema.optional(
    Schema.Array(
      Schema.Union([
        Schema.Struct({
          group: Schema.Struct({
            id: Schema.String,
          }),
        }),
        Schema.Struct({
          anyValidServiceToken: Schema.Unknown,
        }).pipe(
          Schema.encodeKeys({
            anyValidServiceToken: "any_valid_service_token",
          }),
        ),
        Schema.Struct({
          authContext: Schema.Struct({
            id: Schema.String,
            acId: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              acId: "ac_id",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }).pipe(Schema.encodeKeys({ authContext: "auth_context" })),
        Schema.Struct({
          authMethod: Schema.Struct({
            authMethod: Schema.String,
          }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
        }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
        Schema.Struct({
          azureAD: Schema.Struct({
            id: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          certificate: Schema.Unknown,
        }),
        Schema.Struct({
          commonName: Schema.Struct({
            commonName: Schema.String,
          }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
        }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
        Schema.Struct({
          geo: Schema.Struct({
            countryCode: Schema.String,
          }).pipe(Schema.encodeKeys({ countryCode: "country_code" })),
        }),
        Schema.Struct({
          devicePosture: Schema.Struct({
            integrationUid: Schema.String,
          }).pipe(Schema.encodeKeys({ integrationUid: "integration_uid" })),
        }).pipe(Schema.encodeKeys({ devicePosture: "device_posture" })),
        Schema.Struct({
          emailDomain: Schema.Struct({
            domain: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ emailDomain: "email_domain" })),
        Schema.Struct({
          emailList: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ emailList: "email_list" })),
        Schema.Struct({
          email: Schema.Struct({
            email: Schema.String,
          }),
        }),
        Schema.Struct({
          everyone: Schema.Unknown,
        }),
        Schema.Struct({
          externalEvaluation: Schema.Struct({
            evaluateUrl: Schema.String,
            keysUrl: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              evaluateUrl: "evaluate_url",
              keysUrl: "keys_url",
            }),
          ),
        }).pipe(
          Schema.encodeKeys({ externalEvaluation: "external_evaluation" }),
        ),
        Schema.Struct({
          githubOrganization: Schema.Struct({
            identityProviderId: Schema.String,
            name: Schema.String,
            team: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              identityProviderId: "identity_provider_id",
              name: "name",
              team: "team",
            }),
          ),
        }).pipe(
          Schema.encodeKeys({ githubOrganization: "'github-organization'" }),
        ),
        Schema.Struct({
          gsuite: Schema.Struct({
            email: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              email: "email",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          loginMethod: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ loginMethod: "login_method" })),
        Schema.Struct({
          ipList: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ ipList: "ip_list" })),
        Schema.Struct({
          ip: Schema.Struct({
            ip: Schema.String,
          }),
        }),
        Schema.Struct({
          okta: Schema.Struct({
            identityProviderId: Schema.String,
            name: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              identityProviderId: "identity_provider_id",
              name: "name",
            }),
          ),
        }),
        Schema.Struct({
          saml: Schema.Struct({
            attributeName: Schema.String,
            attributeValue: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              attributeName: "attribute_name",
              attributeValue: "attribute_value",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          oidc: Schema.Struct({
            claimName: Schema.String,
            claimValue: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              claimName: "claim_name",
              claimValue: "claim_value",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          serviceToken: Schema.Struct({
            tokenId: Schema.String,
          }).pipe(Schema.encodeKeys({ tokenId: "token_id" })),
        }).pipe(Schema.encodeKeys({ serviceToken: "service_token" })),
        Schema.Struct({
          linkedAppToken: Schema.Struct({
            appUid: Schema.String,
          }).pipe(Schema.encodeKeys({ appUid: "app_uid" })),
        }).pipe(Schema.encodeKeys({ linkedAppToken: "linked_app_token" })),
      ]),
    ),
  ),
  include: Schema.optional(
    Schema.Array(
      Schema.Union([
        Schema.Struct({
          group: Schema.Struct({
            id: Schema.String,
          }),
        }),
        Schema.Struct({
          anyValidServiceToken: Schema.Unknown,
        }).pipe(
          Schema.encodeKeys({
            anyValidServiceToken: "any_valid_service_token",
          }),
        ),
        Schema.Struct({
          authContext: Schema.Struct({
            id: Schema.String,
            acId: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              acId: "ac_id",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }).pipe(Schema.encodeKeys({ authContext: "auth_context" })),
        Schema.Struct({
          authMethod: Schema.Struct({
            authMethod: Schema.String,
          }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
        }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
        Schema.Struct({
          azureAD: Schema.Struct({
            id: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          certificate: Schema.Unknown,
        }),
        Schema.Struct({
          commonName: Schema.Struct({
            commonName: Schema.String,
          }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
        }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
        Schema.Struct({
          geo: Schema.Struct({
            countryCode: Schema.String,
          }).pipe(Schema.encodeKeys({ countryCode: "country_code" })),
        }),
        Schema.Struct({
          devicePosture: Schema.Struct({
            integrationUid: Schema.String,
          }).pipe(Schema.encodeKeys({ integrationUid: "integration_uid" })),
        }).pipe(Schema.encodeKeys({ devicePosture: "device_posture" })),
        Schema.Struct({
          emailDomain: Schema.Struct({
            domain: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ emailDomain: "email_domain" })),
        Schema.Struct({
          emailList: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ emailList: "email_list" })),
        Schema.Struct({
          email: Schema.Struct({
            email: Schema.String,
          }),
        }),
        Schema.Struct({
          everyone: Schema.Unknown,
        }),
        Schema.Struct({
          externalEvaluation: Schema.Struct({
            evaluateUrl: Schema.String,
            keysUrl: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              evaluateUrl: "evaluate_url",
              keysUrl: "keys_url",
            }),
          ),
        }).pipe(
          Schema.encodeKeys({ externalEvaluation: "external_evaluation" }),
        ),
        Schema.Struct({
          githubOrganization: Schema.Struct({
            identityProviderId: Schema.String,
            name: Schema.String,
            team: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              identityProviderId: "identity_provider_id",
              name: "name",
              team: "team",
            }),
          ),
        }).pipe(
          Schema.encodeKeys({ githubOrganization: "'github-organization'" }),
        ),
        Schema.Struct({
          gsuite: Schema.Struct({
            email: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              email: "email",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          loginMethod: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ loginMethod: "login_method" })),
        Schema.Struct({
          ipList: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ ipList: "ip_list" })),
        Schema.Struct({
          ip: Schema.Struct({
            ip: Schema.String,
          }),
        }),
        Schema.Struct({
          okta: Schema.Struct({
            identityProviderId: Schema.String,
            name: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              identityProviderId: "identity_provider_id",
              name: "name",
            }),
          ),
        }),
        Schema.Struct({
          saml: Schema.Struct({
            attributeName: Schema.String,
            attributeValue: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              attributeName: "attribute_name",
              attributeValue: "attribute_value",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          oidc: Schema.Struct({
            claimName: Schema.String,
            claimValue: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              claimName: "claim_name",
              claimValue: "claim_value",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          serviceToken: Schema.Struct({
            tokenId: Schema.String,
          }).pipe(Schema.encodeKeys({ tokenId: "token_id" })),
        }).pipe(Schema.encodeKeys({ serviceToken: "service_token" })),
        Schema.Struct({
          linkedAppToken: Schema.Struct({
            appUid: Schema.String,
          }).pipe(Schema.encodeKeys({ appUid: "app_uid" })),
        }).pipe(Schema.encodeKeys({ linkedAppToken: "linked_app_token" })),
      ]),
    ),
  ),
  isolationRequired: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
  precedence: Schema.optional(Schema.Number),
  purposeJustificationPrompt: Schema.optional(Schema.String),
  purposeJustificationRequired: Schema.optional(Schema.Boolean),
  require: Schema.optional(
    Schema.Array(
      Schema.Union([
        Schema.Struct({
          group: Schema.Struct({
            id: Schema.String,
          }),
        }),
        Schema.Struct({
          anyValidServiceToken: Schema.Unknown,
        }).pipe(
          Schema.encodeKeys({
            anyValidServiceToken: "any_valid_service_token",
          }),
        ),
        Schema.Struct({
          authContext: Schema.Struct({
            id: Schema.String,
            acId: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              acId: "ac_id",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }).pipe(Schema.encodeKeys({ authContext: "auth_context" })),
        Schema.Struct({
          authMethod: Schema.Struct({
            authMethod: Schema.String,
          }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
        }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
        Schema.Struct({
          azureAD: Schema.Struct({
            id: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          certificate: Schema.Unknown,
        }),
        Schema.Struct({
          commonName: Schema.Struct({
            commonName: Schema.String,
          }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
        }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
        Schema.Struct({
          geo: Schema.Struct({
            countryCode: Schema.String,
          }).pipe(Schema.encodeKeys({ countryCode: "country_code" })),
        }),
        Schema.Struct({
          devicePosture: Schema.Struct({
            integrationUid: Schema.String,
          }).pipe(Schema.encodeKeys({ integrationUid: "integration_uid" })),
        }).pipe(Schema.encodeKeys({ devicePosture: "device_posture" })),
        Schema.Struct({
          emailDomain: Schema.Struct({
            domain: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ emailDomain: "email_domain" })),
        Schema.Struct({
          emailList: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ emailList: "email_list" })),
        Schema.Struct({
          email: Schema.Struct({
            email: Schema.String,
          }),
        }),
        Schema.Struct({
          everyone: Schema.Unknown,
        }),
        Schema.Struct({
          externalEvaluation: Schema.Struct({
            evaluateUrl: Schema.String,
            keysUrl: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              evaluateUrl: "evaluate_url",
              keysUrl: "keys_url",
            }),
          ),
        }).pipe(
          Schema.encodeKeys({ externalEvaluation: "external_evaluation" }),
        ),
        Schema.Struct({
          githubOrganization: Schema.Struct({
            identityProviderId: Schema.String,
            name: Schema.String,
            team: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              identityProviderId: "identity_provider_id",
              name: "name",
              team: "team",
            }),
          ),
        }).pipe(
          Schema.encodeKeys({ githubOrganization: "'github-organization'" }),
        ),
        Schema.Struct({
          gsuite: Schema.Struct({
            email: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              email: "email",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          loginMethod: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ loginMethod: "login_method" })),
        Schema.Struct({
          ipList: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ ipList: "ip_list" })),
        Schema.Struct({
          ip: Schema.Struct({
            ip: Schema.String,
          }),
        }),
        Schema.Struct({
          okta: Schema.Struct({
            identityProviderId: Schema.String,
            name: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              identityProviderId: "identity_provider_id",
              name: "name",
            }),
          ),
        }),
        Schema.Struct({
          saml: Schema.Struct({
            attributeName: Schema.String,
            attributeValue: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              attributeName: "attribute_name",
              attributeValue: "attribute_value",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          oidc: Schema.Struct({
            claimName: Schema.String,
            claimValue: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              claimName: "claim_name",
              claimValue: "claim_value",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          serviceToken: Schema.Struct({
            tokenId: Schema.String,
          }).pipe(Schema.encodeKeys({ tokenId: "token_id" })),
        }).pipe(Schema.encodeKeys({ serviceToken: "service_token" })),
        Schema.Struct({
          linkedAppToken: Schema.Struct({
            appUid: Schema.String,
          }).pipe(Schema.encodeKeys({ appUid: "app_uid" })),
        }).pipe(Schema.encodeKeys({ linkedAppToken: "linked_app_token" })),
      ]),
    ),
  ),
  sessionDuration: Schema.optional(Schema.String),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    approvalGroups: "approval_groups",
    approvalRequired: "approval_required",
    createdAt: "created_at",
    decision: "decision",
    exclude: "exclude",
    include: "include",
    isolationRequired: "isolation_required",
    name: "name",
    precedence: "precedence",
    purposeJustificationPrompt: "purpose_justification_prompt",
    purposeJustificationRequired: "purpose_justification_required",
    require: "require",
    sessionDuration: "session_duration",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<GetAccessApplicationPolicyResponse>;

export type GetAccessApplicationPolicyError = CommonErrors;

export const getAccessApplicationPolicy: API.OperationMethod<
  GetAccessApplicationPolicyRequest,
  GetAccessApplicationPolicyResponse,
  GetAccessApplicationPolicyError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccessApplicationPolicyRequest,
  output: GetAccessApplicationPolicyResponse,
  errors: [],
}));

export interface ListAccessApplicationPoliciesRequest {
  appId: string;
}

export const ListAccessApplicationPoliciesRequest = Schema.Struct({
  appId: Schema.String.pipe(T.HttpPath("appId")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/{accountOrZone}/{accountOrZoneId}/access/apps/{appId}/policies",
  }),
) as unknown as Schema.Schema<ListAccessApplicationPoliciesRequest>;

export type ListAccessApplicationPoliciesResponse = {
  id?: string;
  approvalGroups?: unknown[];
  approvalRequired?: boolean;
  createdAt?: string;
  decision?: "allow" | "bypass" | "deny" | "non_identity";
  exclude?: (
    | { group: { id: string } }
    | { anyValidServiceToken: unknown }
    | { authContext: { id: string; acId: string; identityProviderId: string } }
    | { authMethod: { authMethod: string } }
    | { azureAD: { id: string; identityProviderId: string } }
    | { certificate: unknown }
    | { commonName: { commonName: string } }
    | { geo: { countryCode: string } }
    | { devicePosture: { integrationUid: string } }
    | { emailDomain: { domain: string } }
    | { emailList: { id: string } }
    | { email: { email: string } }
    | { everyone: unknown }
    | { externalEvaluation: { evaluateUrl: string; keysUrl: string } }
    | {
        githubOrganization: {
          identityProviderId: string;
          name: string;
          team?: string;
        };
      }
    | { gsuite: { email: string; identityProviderId: string } }
    | { loginMethod: { id: string } }
    | { ipList: { id: string } }
    | { ip: { ip: string } }
    | { okta: { identityProviderId: string; name: string } }
    | {
        saml: {
          attributeName: string;
          attributeValue: string;
          identityProviderId: string;
        };
      }
    | {
        oidc: {
          claimName: string;
          claimValue: string;
          identityProviderId: string;
        };
      }
    | { serviceToken: { tokenId: string } }
    | { linkedAppToken: { appUid: string } }
  )[];
  include?: (
    | { group: { id: string } }
    | { anyValidServiceToken: unknown }
    | { authContext: { id: string; acId: string; identityProviderId: string } }
    | { authMethod: { authMethod: string } }
    | { azureAD: { id: string; identityProviderId: string } }
    | { certificate: unknown }
    | { commonName: { commonName: string } }
    | { geo: { countryCode: string } }
    | { devicePosture: { integrationUid: string } }
    | { emailDomain: { domain: string } }
    | { emailList: { id: string } }
    | { email: { email: string } }
    | { everyone: unknown }
    | { externalEvaluation: { evaluateUrl: string; keysUrl: string } }
    | {
        githubOrganization: {
          identityProviderId: string;
          name: string;
          team?: string;
        };
      }
    | { gsuite: { email: string; identityProviderId: string } }
    | { loginMethod: { id: string } }
    | { ipList: { id: string } }
    | { ip: { ip: string } }
    | { okta: { identityProviderId: string; name: string } }
    | {
        saml: {
          attributeName: string;
          attributeValue: string;
          identityProviderId: string;
        };
      }
    | {
        oidc: {
          claimName: string;
          claimValue: string;
          identityProviderId: string;
        };
      }
    | { serviceToken: { tokenId: string } }
    | { linkedAppToken: { appUid: string } }
  )[];
  isolationRequired?: boolean;
  name?: string;
  precedence?: number;
  purposeJustificationPrompt?: string;
  purposeJustificationRequired?: boolean;
  require?: (
    | { group: { id: string } }
    | { anyValidServiceToken: unknown }
    | { authContext: { id: string; acId: string; identityProviderId: string } }
    | { authMethod: { authMethod: string } }
    | { azureAD: { id: string; identityProviderId: string } }
    | { certificate: unknown }
    | { commonName: { commonName: string } }
    | { geo: { countryCode: string } }
    | { devicePosture: { integrationUid: string } }
    | { emailDomain: { domain: string } }
    | { emailList: { id: string } }
    | { email: { email: string } }
    | { everyone: unknown }
    | { externalEvaluation: { evaluateUrl: string; keysUrl: string } }
    | {
        githubOrganization: {
          identityProviderId: string;
          name: string;
          team?: string;
        };
      }
    | { gsuite: { email: string; identityProviderId: string } }
    | { loginMethod: { id: string } }
    | { ipList: { id: string } }
    | { ip: { ip: string } }
    | { okta: { identityProviderId: string; name: string } }
    | {
        saml: {
          attributeName: string;
          attributeValue: string;
          identityProviderId: string;
        };
      }
    | {
        oidc: {
          claimName: string;
          claimValue: string;
          identityProviderId: string;
        };
      }
    | { serviceToken: { tokenId: string } }
    | { linkedAppToken: { appUid: string } }
  )[];
  sessionDuration?: string;
  updatedAt?: string;
}[];

export const ListAccessApplicationPoliciesResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
    approvalRequired: Schema.optional(Schema.Boolean),
    createdAt: Schema.optional(Schema.String),
    decision: Schema.optional(
      Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
    ),
    exclude: Schema.optional(
      Schema.Array(
        Schema.Union([
          Schema.Struct({
            group: Schema.Struct({
              id: Schema.String,
            }),
          }),
          Schema.Struct({
            anyValidServiceToken: Schema.Unknown,
          }).pipe(
            Schema.encodeKeys({
              anyValidServiceToken: "any_valid_service_token",
            }),
          ),
          Schema.Struct({
            authContext: Schema.Struct({
              id: Schema.String,
              acId: Schema.String,
              identityProviderId: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                id: "id",
                acId: "ac_id",
                identityProviderId: "identity_provider_id",
              }),
            ),
          }).pipe(Schema.encodeKeys({ authContext: "auth_context" })),
          Schema.Struct({
            authMethod: Schema.Struct({
              authMethod: Schema.String,
            }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
          }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
          Schema.Struct({
            azureAD: Schema.Struct({
              id: Schema.String,
              identityProviderId: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                id: "id",
                identityProviderId: "identity_provider_id",
              }),
            ),
          }),
          Schema.Struct({
            certificate: Schema.Unknown,
          }),
          Schema.Struct({
            commonName: Schema.Struct({
              commonName: Schema.String,
            }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
          }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
          Schema.Struct({
            geo: Schema.Struct({
              countryCode: Schema.String,
            }).pipe(Schema.encodeKeys({ countryCode: "country_code" })),
          }),
          Schema.Struct({
            devicePosture: Schema.Struct({
              integrationUid: Schema.String,
            }).pipe(Schema.encodeKeys({ integrationUid: "integration_uid" })),
          }).pipe(Schema.encodeKeys({ devicePosture: "device_posture" })),
          Schema.Struct({
            emailDomain: Schema.Struct({
              domain: Schema.String,
            }),
          }).pipe(Schema.encodeKeys({ emailDomain: "email_domain" })),
          Schema.Struct({
            emailList: Schema.Struct({
              id: Schema.String,
            }),
          }).pipe(Schema.encodeKeys({ emailList: "email_list" })),
          Schema.Struct({
            email: Schema.Struct({
              email: Schema.String,
            }),
          }),
          Schema.Struct({
            everyone: Schema.Unknown,
          }),
          Schema.Struct({
            externalEvaluation: Schema.Struct({
              evaluateUrl: Schema.String,
              keysUrl: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                evaluateUrl: "evaluate_url",
                keysUrl: "keys_url",
              }),
            ),
          }).pipe(
            Schema.encodeKeys({ externalEvaluation: "external_evaluation" }),
          ),
          Schema.Struct({
            githubOrganization: Schema.Struct({
              identityProviderId: Schema.String,
              name: Schema.String,
              team: Schema.optional(Schema.String),
            }).pipe(
              Schema.encodeKeys({
                identityProviderId: "identity_provider_id",
                name: "name",
                team: "team",
              }),
            ),
          }).pipe(
            Schema.encodeKeys({ githubOrganization: "'github-organization'" }),
          ),
          Schema.Struct({
            gsuite: Schema.Struct({
              email: Schema.String,
              identityProviderId: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                email: "email",
                identityProviderId: "identity_provider_id",
              }),
            ),
          }),
          Schema.Struct({
            loginMethod: Schema.Struct({
              id: Schema.String,
            }),
          }).pipe(Schema.encodeKeys({ loginMethod: "login_method" })),
          Schema.Struct({
            ipList: Schema.Struct({
              id: Schema.String,
            }),
          }).pipe(Schema.encodeKeys({ ipList: "ip_list" })),
          Schema.Struct({
            ip: Schema.Struct({
              ip: Schema.String,
            }),
          }),
          Schema.Struct({
            okta: Schema.Struct({
              identityProviderId: Schema.String,
              name: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                identityProviderId: "identity_provider_id",
                name: "name",
              }),
            ),
          }),
          Schema.Struct({
            saml: Schema.Struct({
              attributeName: Schema.String,
              attributeValue: Schema.String,
              identityProviderId: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                attributeName: "attribute_name",
                attributeValue: "attribute_value",
                identityProviderId: "identity_provider_id",
              }),
            ),
          }),
          Schema.Struct({
            oidc: Schema.Struct({
              claimName: Schema.String,
              claimValue: Schema.String,
              identityProviderId: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                claimName: "claim_name",
                claimValue: "claim_value",
                identityProviderId: "identity_provider_id",
              }),
            ),
          }),
          Schema.Struct({
            serviceToken: Schema.Struct({
              tokenId: Schema.String,
            }).pipe(Schema.encodeKeys({ tokenId: "token_id" })),
          }).pipe(Schema.encodeKeys({ serviceToken: "service_token" })),
          Schema.Struct({
            linkedAppToken: Schema.Struct({
              appUid: Schema.String,
            }).pipe(Schema.encodeKeys({ appUid: "app_uid" })),
          }).pipe(Schema.encodeKeys({ linkedAppToken: "linked_app_token" })),
        ]),
      ),
    ),
    include: Schema.optional(
      Schema.Array(
        Schema.Union([
          Schema.Struct({
            group: Schema.Struct({
              id: Schema.String,
            }),
          }),
          Schema.Struct({
            anyValidServiceToken: Schema.Unknown,
          }).pipe(
            Schema.encodeKeys({
              anyValidServiceToken: "any_valid_service_token",
            }),
          ),
          Schema.Struct({
            authContext: Schema.Struct({
              id: Schema.String,
              acId: Schema.String,
              identityProviderId: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                id: "id",
                acId: "ac_id",
                identityProviderId: "identity_provider_id",
              }),
            ),
          }).pipe(Schema.encodeKeys({ authContext: "auth_context" })),
          Schema.Struct({
            authMethod: Schema.Struct({
              authMethod: Schema.String,
            }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
          }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
          Schema.Struct({
            azureAD: Schema.Struct({
              id: Schema.String,
              identityProviderId: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                id: "id",
                identityProviderId: "identity_provider_id",
              }),
            ),
          }),
          Schema.Struct({
            certificate: Schema.Unknown,
          }),
          Schema.Struct({
            commonName: Schema.Struct({
              commonName: Schema.String,
            }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
          }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
          Schema.Struct({
            geo: Schema.Struct({
              countryCode: Schema.String,
            }).pipe(Schema.encodeKeys({ countryCode: "country_code" })),
          }),
          Schema.Struct({
            devicePosture: Schema.Struct({
              integrationUid: Schema.String,
            }).pipe(Schema.encodeKeys({ integrationUid: "integration_uid" })),
          }).pipe(Schema.encodeKeys({ devicePosture: "device_posture" })),
          Schema.Struct({
            emailDomain: Schema.Struct({
              domain: Schema.String,
            }),
          }).pipe(Schema.encodeKeys({ emailDomain: "email_domain" })),
          Schema.Struct({
            emailList: Schema.Struct({
              id: Schema.String,
            }),
          }).pipe(Schema.encodeKeys({ emailList: "email_list" })),
          Schema.Struct({
            email: Schema.Struct({
              email: Schema.String,
            }),
          }),
          Schema.Struct({
            everyone: Schema.Unknown,
          }),
          Schema.Struct({
            externalEvaluation: Schema.Struct({
              evaluateUrl: Schema.String,
              keysUrl: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                evaluateUrl: "evaluate_url",
                keysUrl: "keys_url",
              }),
            ),
          }).pipe(
            Schema.encodeKeys({ externalEvaluation: "external_evaluation" }),
          ),
          Schema.Struct({
            githubOrganization: Schema.Struct({
              identityProviderId: Schema.String,
              name: Schema.String,
              team: Schema.optional(Schema.String),
            }).pipe(
              Schema.encodeKeys({
                identityProviderId: "identity_provider_id",
                name: "name",
                team: "team",
              }),
            ),
          }).pipe(
            Schema.encodeKeys({ githubOrganization: "'github-organization'" }),
          ),
          Schema.Struct({
            gsuite: Schema.Struct({
              email: Schema.String,
              identityProviderId: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                email: "email",
                identityProviderId: "identity_provider_id",
              }),
            ),
          }),
          Schema.Struct({
            loginMethod: Schema.Struct({
              id: Schema.String,
            }),
          }).pipe(Schema.encodeKeys({ loginMethod: "login_method" })),
          Schema.Struct({
            ipList: Schema.Struct({
              id: Schema.String,
            }),
          }).pipe(Schema.encodeKeys({ ipList: "ip_list" })),
          Schema.Struct({
            ip: Schema.Struct({
              ip: Schema.String,
            }),
          }),
          Schema.Struct({
            okta: Schema.Struct({
              identityProviderId: Schema.String,
              name: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                identityProviderId: "identity_provider_id",
                name: "name",
              }),
            ),
          }),
          Schema.Struct({
            saml: Schema.Struct({
              attributeName: Schema.String,
              attributeValue: Schema.String,
              identityProviderId: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                attributeName: "attribute_name",
                attributeValue: "attribute_value",
                identityProviderId: "identity_provider_id",
              }),
            ),
          }),
          Schema.Struct({
            oidc: Schema.Struct({
              claimName: Schema.String,
              claimValue: Schema.String,
              identityProviderId: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                claimName: "claim_name",
                claimValue: "claim_value",
                identityProviderId: "identity_provider_id",
              }),
            ),
          }),
          Schema.Struct({
            serviceToken: Schema.Struct({
              tokenId: Schema.String,
            }).pipe(Schema.encodeKeys({ tokenId: "token_id" })),
          }).pipe(Schema.encodeKeys({ serviceToken: "service_token" })),
          Schema.Struct({
            linkedAppToken: Schema.Struct({
              appUid: Schema.String,
            }).pipe(Schema.encodeKeys({ appUid: "app_uid" })),
          }).pipe(Schema.encodeKeys({ linkedAppToken: "linked_app_token" })),
        ]),
      ),
    ),
    isolationRequired: Schema.optional(Schema.Boolean),
    name: Schema.optional(Schema.String),
    precedence: Schema.optional(Schema.Number),
    purposeJustificationPrompt: Schema.optional(Schema.String),
    purposeJustificationRequired: Schema.optional(Schema.Boolean),
    require: Schema.optional(
      Schema.Array(
        Schema.Union([
          Schema.Struct({
            group: Schema.Struct({
              id: Schema.String,
            }),
          }),
          Schema.Struct({
            anyValidServiceToken: Schema.Unknown,
          }).pipe(
            Schema.encodeKeys({
              anyValidServiceToken: "any_valid_service_token",
            }),
          ),
          Schema.Struct({
            authContext: Schema.Struct({
              id: Schema.String,
              acId: Schema.String,
              identityProviderId: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                id: "id",
                acId: "ac_id",
                identityProviderId: "identity_provider_id",
              }),
            ),
          }).pipe(Schema.encodeKeys({ authContext: "auth_context" })),
          Schema.Struct({
            authMethod: Schema.Struct({
              authMethod: Schema.String,
            }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
          }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
          Schema.Struct({
            azureAD: Schema.Struct({
              id: Schema.String,
              identityProviderId: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                id: "id",
                identityProviderId: "identity_provider_id",
              }),
            ),
          }),
          Schema.Struct({
            certificate: Schema.Unknown,
          }),
          Schema.Struct({
            commonName: Schema.Struct({
              commonName: Schema.String,
            }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
          }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
          Schema.Struct({
            geo: Schema.Struct({
              countryCode: Schema.String,
            }).pipe(Schema.encodeKeys({ countryCode: "country_code" })),
          }),
          Schema.Struct({
            devicePosture: Schema.Struct({
              integrationUid: Schema.String,
            }).pipe(Schema.encodeKeys({ integrationUid: "integration_uid" })),
          }).pipe(Schema.encodeKeys({ devicePosture: "device_posture" })),
          Schema.Struct({
            emailDomain: Schema.Struct({
              domain: Schema.String,
            }),
          }).pipe(Schema.encodeKeys({ emailDomain: "email_domain" })),
          Schema.Struct({
            emailList: Schema.Struct({
              id: Schema.String,
            }),
          }).pipe(Schema.encodeKeys({ emailList: "email_list" })),
          Schema.Struct({
            email: Schema.Struct({
              email: Schema.String,
            }),
          }),
          Schema.Struct({
            everyone: Schema.Unknown,
          }),
          Schema.Struct({
            externalEvaluation: Schema.Struct({
              evaluateUrl: Schema.String,
              keysUrl: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                evaluateUrl: "evaluate_url",
                keysUrl: "keys_url",
              }),
            ),
          }).pipe(
            Schema.encodeKeys({ externalEvaluation: "external_evaluation" }),
          ),
          Schema.Struct({
            githubOrganization: Schema.Struct({
              identityProviderId: Schema.String,
              name: Schema.String,
              team: Schema.optional(Schema.String),
            }).pipe(
              Schema.encodeKeys({
                identityProviderId: "identity_provider_id",
                name: "name",
                team: "team",
              }),
            ),
          }).pipe(
            Schema.encodeKeys({ githubOrganization: "'github-organization'" }),
          ),
          Schema.Struct({
            gsuite: Schema.Struct({
              email: Schema.String,
              identityProviderId: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                email: "email",
                identityProviderId: "identity_provider_id",
              }),
            ),
          }),
          Schema.Struct({
            loginMethod: Schema.Struct({
              id: Schema.String,
            }),
          }).pipe(Schema.encodeKeys({ loginMethod: "login_method" })),
          Schema.Struct({
            ipList: Schema.Struct({
              id: Schema.String,
            }),
          }).pipe(Schema.encodeKeys({ ipList: "ip_list" })),
          Schema.Struct({
            ip: Schema.Struct({
              ip: Schema.String,
            }),
          }),
          Schema.Struct({
            okta: Schema.Struct({
              identityProviderId: Schema.String,
              name: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                identityProviderId: "identity_provider_id",
                name: "name",
              }),
            ),
          }),
          Schema.Struct({
            saml: Schema.Struct({
              attributeName: Schema.String,
              attributeValue: Schema.String,
              identityProviderId: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                attributeName: "attribute_name",
                attributeValue: "attribute_value",
                identityProviderId: "identity_provider_id",
              }),
            ),
          }),
          Schema.Struct({
            oidc: Schema.Struct({
              claimName: Schema.String,
              claimValue: Schema.String,
              identityProviderId: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                claimName: "claim_name",
                claimValue: "claim_value",
                identityProviderId: "identity_provider_id",
              }),
            ),
          }),
          Schema.Struct({
            serviceToken: Schema.Struct({
              tokenId: Schema.String,
            }).pipe(Schema.encodeKeys({ tokenId: "token_id" })),
          }).pipe(Schema.encodeKeys({ serviceToken: "service_token" })),
          Schema.Struct({
            linkedAppToken: Schema.Struct({
              appUid: Schema.String,
            }).pipe(Schema.encodeKeys({ appUid: "app_uid" })),
          }).pipe(Schema.encodeKeys({ linkedAppToken: "linked_app_token" })),
        ]),
      ),
    ),
    sessionDuration: Schema.optional(Schema.String),
    updatedAt: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      approvalGroups: "approval_groups",
      approvalRequired: "approval_required",
      createdAt: "created_at",
      decision: "decision",
      exclude: "exclude",
      include: "include",
      isolationRequired: "isolation_required",
      name: "name",
      precedence: "precedence",
      purposeJustificationPrompt: "purpose_justification_prompt",
      purposeJustificationRequired: "purpose_justification_required",
      require: "require",
      sessionDuration: "session_duration",
      updatedAt: "updated_at",
    }),
  ),
) as unknown as Schema.Schema<ListAccessApplicationPoliciesResponse>;

export type ListAccessApplicationPoliciesError = CommonErrors;

export const listAccessApplicationPolicies: API.OperationMethod<
  ListAccessApplicationPoliciesRequest,
  ListAccessApplicationPoliciesResponse,
  ListAccessApplicationPoliciesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessApplicationPoliciesRequest,
  output: ListAccessApplicationPoliciesResponse,
  errors: [],
}));

export interface CreateAccessApplicationPolicyRequest {
  appId: string;
  /** Path param: The Account ID to use for this endpoint. Mutually exclusive with the Zone ID. */
  accountId?: string;
  /** Path param: The Zone ID to use for this endpoint. Mutually exclusive with the Account ID. */
  zoneId?: string;
  /** Body param: Administrators who can approve a temporary authentication request. */
  approvalGroups?: unknown[];
  /** Body param: Requires the user to request access from an administrator at the start of each session. */
  approvalRequired?: boolean;
  /** Body param: Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature. */
  isolationRequired?: boolean;
  /** Body param: The order of execution for this policy. Must be unique for each policy within an app. */
  precedence?: number;
  /** Body param: A custom message that will appear on the purpose justification screen. */
  purposeJustificationPrompt?: string;
  /** Body param: Require users to enter a justification when they log in to the application. */
  purposeJustificationRequired?: boolean;
  /** Body param: The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. */
  sessionDuration?: string;
}

export const CreateAccessApplicationPolicyRequest = Schema.Struct({
  appId: Schema.String.pipe(T.HttpPath("appId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
  approvalRequired: Schema.optional(Schema.Boolean),
  isolationRequired: Schema.optional(Schema.Boolean),
  precedence: Schema.optional(Schema.Number),
  purposeJustificationPrompt: Schema.optional(Schema.String),
  purposeJustificationRequired: Schema.optional(Schema.Boolean),
  sessionDuration: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    approvalGroups: "approval_groups",
    approvalRequired: "approval_required",
    isolationRequired: "isolation_required",
    precedence: "precedence",
    purposeJustificationPrompt: "purpose_justification_prompt",
    purposeJustificationRequired: "purpose_justification_required",
    sessionDuration: "session_duration",
  }),
  T.Http({
    method: "POST",
    path: "/{accountOrZone}/{accountOrZoneId}/access/apps/{appId}/policies",
  }),
) as unknown as Schema.Schema<CreateAccessApplicationPolicyRequest>;

export interface CreateAccessApplicationPolicyResponse {
  /** The UUID of the policy */
  id?: string;
  /** Administrators who can approve a temporary authentication request. */
  approvalGroups?: unknown[];
  /** Requires the user to request access from an administrator at the start of each session. */
  approvalRequired?: boolean;
  createdAt?: string;
  /** The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action. */
  decision?: "allow" | "bypass" | "deny" | "non_identity";
  /** Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules. */
  exclude?: (
    | { group: { id: string } }
    | { anyValidServiceToken: unknown }
    | { authContext: { id: string; acId: string; identityProviderId: string } }
    | { authMethod: { authMethod: string } }
    | { azureAD: { id: string; identityProviderId: string } }
    | { certificate: unknown }
    | { commonName: { commonName: string } }
    | { geo: { countryCode: string } }
    | { devicePosture: { integrationUid: string } }
    | { emailDomain: { domain: string } }
    | { emailList: { id: string } }
    | { email: { email: string } }
    | { everyone: unknown }
    | { externalEvaluation: { evaluateUrl: string; keysUrl: string } }
    | {
        githubOrganization: {
          identityProviderId: string;
          name: string;
          team?: string;
        };
      }
    | { gsuite: { email: string; identityProviderId: string } }
    | { loginMethod: { id: string } }
    | { ipList: { id: string } }
    | { ip: { ip: string } }
    | { okta: { identityProviderId: string; name: string } }
    | {
        saml: {
          attributeName: string;
          attributeValue: string;
          identityProviderId: string;
        };
      }
    | {
        oidc: {
          claimName: string;
          claimValue: string;
          identityProviderId: string;
        };
      }
    | { serviceToken: { tokenId: string } }
    | { linkedAppToken: { appUid: string } }
  )[];
  /** Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules. */
  include?: (
    | { group: { id: string } }
    | { anyValidServiceToken: unknown }
    | { authContext: { id: string; acId: string; identityProviderId: string } }
    | { authMethod: { authMethod: string } }
    | { azureAD: { id: string; identityProviderId: string } }
    | { certificate: unknown }
    | { commonName: { commonName: string } }
    | { geo: { countryCode: string } }
    | { devicePosture: { integrationUid: string } }
    | { emailDomain: { domain: string } }
    | { emailList: { id: string } }
    | { email: { email: string } }
    | { everyone: unknown }
    | { externalEvaluation: { evaluateUrl: string; keysUrl: string } }
    | {
        githubOrganization: {
          identityProviderId: string;
          name: string;
          team?: string;
        };
      }
    | { gsuite: { email: string; identityProviderId: string } }
    | { loginMethod: { id: string } }
    | { ipList: { id: string } }
    | { ip: { ip: string } }
    | { okta: { identityProviderId: string; name: string } }
    | {
        saml: {
          attributeName: string;
          attributeValue: string;
          identityProviderId: string;
        };
      }
    | {
        oidc: {
          claimName: string;
          claimValue: string;
          identityProviderId: string;
        };
      }
    | { serviceToken: { tokenId: string } }
    | { linkedAppToken: { appUid: string } }
  )[];
  /** Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature. */
  isolationRequired?: boolean;
  /** The name of the Access policy. */
  name?: string;
  /** The order of execution for this policy. Must be unique for each policy within an app. */
  precedence?: number;
  /** A custom message that will appear on the purpose justification screen. */
  purposeJustificationPrompt?: string;
  /** Require users to enter a justification when they log in to the application. */
  purposeJustificationRequired?: boolean;
  /** Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules. */
  require?: (
    | { group: { id: string } }
    | { anyValidServiceToken: unknown }
    | { authContext: { id: string; acId: string; identityProviderId: string } }
    | { authMethod: { authMethod: string } }
    | { azureAD: { id: string; identityProviderId: string } }
    | { certificate: unknown }
    | { commonName: { commonName: string } }
    | { geo: { countryCode: string } }
    | { devicePosture: { integrationUid: string } }
    | { emailDomain: { domain: string } }
    | { emailList: { id: string } }
    | { email: { email: string } }
    | { everyone: unknown }
    | { externalEvaluation: { evaluateUrl: string; keysUrl: string } }
    | {
        githubOrganization: {
          identityProviderId: string;
          name: string;
          team?: string;
        };
      }
    | { gsuite: { email: string; identityProviderId: string } }
    | { loginMethod: { id: string } }
    | { ipList: { id: string } }
    | { ip: { ip: string } }
    | { okta: { identityProviderId: string; name: string } }
    | {
        saml: {
          attributeName: string;
          attributeValue: string;
          identityProviderId: string;
        };
      }
    | {
        oidc: {
          claimName: string;
          claimValue: string;
          identityProviderId: string;
        };
      }
    | { serviceToken: { tokenId: string } }
    | { linkedAppToken: { appUid: string } }
  )[];
  /** The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. */
  sessionDuration?: string;
  updatedAt?: string;
}

export const CreateAccessApplicationPolicyResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
  approvalRequired: Schema.optional(Schema.Boolean),
  createdAt: Schema.optional(Schema.String),
  decision: Schema.optional(
    Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
  ),
  exclude: Schema.optional(
    Schema.Array(
      Schema.Union([
        Schema.Struct({
          group: Schema.Struct({
            id: Schema.String,
          }),
        }),
        Schema.Struct({
          anyValidServiceToken: Schema.Unknown,
        }).pipe(
          Schema.encodeKeys({
            anyValidServiceToken: "any_valid_service_token",
          }),
        ),
        Schema.Struct({
          authContext: Schema.Struct({
            id: Schema.String,
            acId: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              acId: "ac_id",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }).pipe(Schema.encodeKeys({ authContext: "auth_context" })),
        Schema.Struct({
          authMethod: Schema.Struct({
            authMethod: Schema.String,
          }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
        }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
        Schema.Struct({
          azureAD: Schema.Struct({
            id: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          certificate: Schema.Unknown,
        }),
        Schema.Struct({
          commonName: Schema.Struct({
            commonName: Schema.String,
          }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
        }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
        Schema.Struct({
          geo: Schema.Struct({
            countryCode: Schema.String,
          }).pipe(Schema.encodeKeys({ countryCode: "country_code" })),
        }),
        Schema.Struct({
          devicePosture: Schema.Struct({
            integrationUid: Schema.String,
          }).pipe(Schema.encodeKeys({ integrationUid: "integration_uid" })),
        }).pipe(Schema.encodeKeys({ devicePosture: "device_posture" })),
        Schema.Struct({
          emailDomain: Schema.Struct({
            domain: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ emailDomain: "email_domain" })),
        Schema.Struct({
          emailList: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ emailList: "email_list" })),
        Schema.Struct({
          email: Schema.Struct({
            email: Schema.String,
          }),
        }),
        Schema.Struct({
          everyone: Schema.Unknown,
        }),
        Schema.Struct({
          externalEvaluation: Schema.Struct({
            evaluateUrl: Schema.String,
            keysUrl: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              evaluateUrl: "evaluate_url",
              keysUrl: "keys_url",
            }),
          ),
        }).pipe(
          Schema.encodeKeys({ externalEvaluation: "external_evaluation" }),
        ),
        Schema.Struct({
          githubOrganization: Schema.Struct({
            identityProviderId: Schema.String,
            name: Schema.String,
            team: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              identityProviderId: "identity_provider_id",
              name: "name",
              team: "team",
            }),
          ),
        }).pipe(
          Schema.encodeKeys({ githubOrganization: "'github-organization'" }),
        ),
        Schema.Struct({
          gsuite: Schema.Struct({
            email: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              email: "email",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          loginMethod: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ loginMethod: "login_method" })),
        Schema.Struct({
          ipList: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ ipList: "ip_list" })),
        Schema.Struct({
          ip: Schema.Struct({
            ip: Schema.String,
          }),
        }),
        Schema.Struct({
          okta: Schema.Struct({
            identityProviderId: Schema.String,
            name: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              identityProviderId: "identity_provider_id",
              name: "name",
            }),
          ),
        }),
        Schema.Struct({
          saml: Schema.Struct({
            attributeName: Schema.String,
            attributeValue: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              attributeName: "attribute_name",
              attributeValue: "attribute_value",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          oidc: Schema.Struct({
            claimName: Schema.String,
            claimValue: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              claimName: "claim_name",
              claimValue: "claim_value",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          serviceToken: Schema.Struct({
            tokenId: Schema.String,
          }).pipe(Schema.encodeKeys({ tokenId: "token_id" })),
        }).pipe(Schema.encodeKeys({ serviceToken: "service_token" })),
        Schema.Struct({
          linkedAppToken: Schema.Struct({
            appUid: Schema.String,
          }).pipe(Schema.encodeKeys({ appUid: "app_uid" })),
        }).pipe(Schema.encodeKeys({ linkedAppToken: "linked_app_token" })),
      ]),
    ),
  ),
  include: Schema.optional(
    Schema.Array(
      Schema.Union([
        Schema.Struct({
          group: Schema.Struct({
            id: Schema.String,
          }),
        }),
        Schema.Struct({
          anyValidServiceToken: Schema.Unknown,
        }).pipe(
          Schema.encodeKeys({
            anyValidServiceToken: "any_valid_service_token",
          }),
        ),
        Schema.Struct({
          authContext: Schema.Struct({
            id: Schema.String,
            acId: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              acId: "ac_id",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }).pipe(Schema.encodeKeys({ authContext: "auth_context" })),
        Schema.Struct({
          authMethod: Schema.Struct({
            authMethod: Schema.String,
          }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
        }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
        Schema.Struct({
          azureAD: Schema.Struct({
            id: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          certificate: Schema.Unknown,
        }),
        Schema.Struct({
          commonName: Schema.Struct({
            commonName: Schema.String,
          }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
        }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
        Schema.Struct({
          geo: Schema.Struct({
            countryCode: Schema.String,
          }).pipe(Schema.encodeKeys({ countryCode: "country_code" })),
        }),
        Schema.Struct({
          devicePosture: Schema.Struct({
            integrationUid: Schema.String,
          }).pipe(Schema.encodeKeys({ integrationUid: "integration_uid" })),
        }).pipe(Schema.encodeKeys({ devicePosture: "device_posture" })),
        Schema.Struct({
          emailDomain: Schema.Struct({
            domain: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ emailDomain: "email_domain" })),
        Schema.Struct({
          emailList: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ emailList: "email_list" })),
        Schema.Struct({
          email: Schema.Struct({
            email: Schema.String,
          }),
        }),
        Schema.Struct({
          everyone: Schema.Unknown,
        }),
        Schema.Struct({
          externalEvaluation: Schema.Struct({
            evaluateUrl: Schema.String,
            keysUrl: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              evaluateUrl: "evaluate_url",
              keysUrl: "keys_url",
            }),
          ),
        }).pipe(
          Schema.encodeKeys({ externalEvaluation: "external_evaluation" }),
        ),
        Schema.Struct({
          githubOrganization: Schema.Struct({
            identityProviderId: Schema.String,
            name: Schema.String,
            team: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              identityProviderId: "identity_provider_id",
              name: "name",
              team: "team",
            }),
          ),
        }).pipe(
          Schema.encodeKeys({ githubOrganization: "'github-organization'" }),
        ),
        Schema.Struct({
          gsuite: Schema.Struct({
            email: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              email: "email",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          loginMethod: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ loginMethod: "login_method" })),
        Schema.Struct({
          ipList: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ ipList: "ip_list" })),
        Schema.Struct({
          ip: Schema.Struct({
            ip: Schema.String,
          }),
        }),
        Schema.Struct({
          okta: Schema.Struct({
            identityProviderId: Schema.String,
            name: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              identityProviderId: "identity_provider_id",
              name: "name",
            }),
          ),
        }),
        Schema.Struct({
          saml: Schema.Struct({
            attributeName: Schema.String,
            attributeValue: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              attributeName: "attribute_name",
              attributeValue: "attribute_value",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          oidc: Schema.Struct({
            claimName: Schema.String,
            claimValue: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              claimName: "claim_name",
              claimValue: "claim_value",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          serviceToken: Schema.Struct({
            tokenId: Schema.String,
          }).pipe(Schema.encodeKeys({ tokenId: "token_id" })),
        }).pipe(Schema.encodeKeys({ serviceToken: "service_token" })),
        Schema.Struct({
          linkedAppToken: Schema.Struct({
            appUid: Schema.String,
          }).pipe(Schema.encodeKeys({ appUid: "app_uid" })),
        }).pipe(Schema.encodeKeys({ linkedAppToken: "linked_app_token" })),
      ]),
    ),
  ),
  isolationRequired: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
  precedence: Schema.optional(Schema.Number),
  purposeJustificationPrompt: Schema.optional(Schema.String),
  purposeJustificationRequired: Schema.optional(Schema.Boolean),
  require: Schema.optional(
    Schema.Array(
      Schema.Union([
        Schema.Struct({
          group: Schema.Struct({
            id: Schema.String,
          }),
        }),
        Schema.Struct({
          anyValidServiceToken: Schema.Unknown,
        }).pipe(
          Schema.encodeKeys({
            anyValidServiceToken: "any_valid_service_token",
          }),
        ),
        Schema.Struct({
          authContext: Schema.Struct({
            id: Schema.String,
            acId: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              acId: "ac_id",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }).pipe(Schema.encodeKeys({ authContext: "auth_context" })),
        Schema.Struct({
          authMethod: Schema.Struct({
            authMethod: Schema.String,
          }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
        }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
        Schema.Struct({
          azureAD: Schema.Struct({
            id: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          certificate: Schema.Unknown,
        }),
        Schema.Struct({
          commonName: Schema.Struct({
            commonName: Schema.String,
          }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
        }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
        Schema.Struct({
          geo: Schema.Struct({
            countryCode: Schema.String,
          }).pipe(Schema.encodeKeys({ countryCode: "country_code" })),
        }),
        Schema.Struct({
          devicePosture: Schema.Struct({
            integrationUid: Schema.String,
          }).pipe(Schema.encodeKeys({ integrationUid: "integration_uid" })),
        }).pipe(Schema.encodeKeys({ devicePosture: "device_posture" })),
        Schema.Struct({
          emailDomain: Schema.Struct({
            domain: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ emailDomain: "email_domain" })),
        Schema.Struct({
          emailList: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ emailList: "email_list" })),
        Schema.Struct({
          email: Schema.Struct({
            email: Schema.String,
          }),
        }),
        Schema.Struct({
          everyone: Schema.Unknown,
        }),
        Schema.Struct({
          externalEvaluation: Schema.Struct({
            evaluateUrl: Schema.String,
            keysUrl: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              evaluateUrl: "evaluate_url",
              keysUrl: "keys_url",
            }),
          ),
        }).pipe(
          Schema.encodeKeys({ externalEvaluation: "external_evaluation" }),
        ),
        Schema.Struct({
          githubOrganization: Schema.Struct({
            identityProviderId: Schema.String,
            name: Schema.String,
            team: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              identityProviderId: "identity_provider_id",
              name: "name",
              team: "team",
            }),
          ),
        }).pipe(
          Schema.encodeKeys({ githubOrganization: "'github-organization'" }),
        ),
        Schema.Struct({
          gsuite: Schema.Struct({
            email: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              email: "email",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          loginMethod: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ loginMethod: "login_method" })),
        Schema.Struct({
          ipList: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ ipList: "ip_list" })),
        Schema.Struct({
          ip: Schema.Struct({
            ip: Schema.String,
          }),
        }),
        Schema.Struct({
          okta: Schema.Struct({
            identityProviderId: Schema.String,
            name: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              identityProviderId: "identity_provider_id",
              name: "name",
            }),
          ),
        }),
        Schema.Struct({
          saml: Schema.Struct({
            attributeName: Schema.String,
            attributeValue: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              attributeName: "attribute_name",
              attributeValue: "attribute_value",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          oidc: Schema.Struct({
            claimName: Schema.String,
            claimValue: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              claimName: "claim_name",
              claimValue: "claim_value",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          serviceToken: Schema.Struct({
            tokenId: Schema.String,
          }).pipe(Schema.encodeKeys({ tokenId: "token_id" })),
        }).pipe(Schema.encodeKeys({ serviceToken: "service_token" })),
        Schema.Struct({
          linkedAppToken: Schema.Struct({
            appUid: Schema.String,
          }).pipe(Schema.encodeKeys({ appUid: "app_uid" })),
        }).pipe(Schema.encodeKeys({ linkedAppToken: "linked_app_token" })),
      ]),
    ),
  ),
  sessionDuration: Schema.optional(Schema.String),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    approvalGroups: "approval_groups",
    approvalRequired: "approval_required",
    createdAt: "created_at",
    decision: "decision",
    exclude: "exclude",
    include: "include",
    isolationRequired: "isolation_required",
    name: "name",
    precedence: "precedence",
    purposeJustificationPrompt: "purpose_justification_prompt",
    purposeJustificationRequired: "purpose_justification_required",
    require: "require",
    sessionDuration: "session_duration",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<CreateAccessApplicationPolicyResponse>;

export type CreateAccessApplicationPolicyError = CommonErrors;

export const createAccessApplicationPolicy: API.OperationMethod<
  CreateAccessApplicationPolicyRequest,
  CreateAccessApplicationPolicyResponse,
  CreateAccessApplicationPolicyError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAccessApplicationPolicyRequest,
  output: CreateAccessApplicationPolicyResponse,
  errors: [],
}));

export interface UpdateAccessApplicationPolicyRequest {
  appId: string;
  policyId: string;
  /** Path param: The Account ID to use for this endpoint. Mutually exclusive with the Zone ID. */
  accountId?: string;
  /** Path param: The Zone ID to use for this endpoint. Mutually exclusive with the Account ID. */
  zoneId?: string;
  /** Body param: Administrators who can approve a temporary authentication request. */
  approvalGroups?: unknown[];
  /** Body param: Requires the user to request access from an administrator at the start of each session. */
  approvalRequired?: boolean;
  /** Body param: Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature. */
  isolationRequired?: boolean;
  /** Body param: The order of execution for this policy. Must be unique for each policy within an app. */
  precedence?: number;
  /** Body param: A custom message that will appear on the purpose justification screen. */
  purposeJustificationPrompt?: string;
  /** Body param: Require users to enter a justification when they log in to the application. */
  purposeJustificationRequired?: boolean;
  /** Body param: The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. */
  sessionDuration?: string;
}

export const UpdateAccessApplicationPolicyRequest = Schema.Struct({
  appId: Schema.String.pipe(T.HttpPath("appId")),
  policyId: Schema.String.pipe(T.HttpPath("policyId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
  approvalRequired: Schema.optional(Schema.Boolean),
  isolationRequired: Schema.optional(Schema.Boolean),
  precedence: Schema.optional(Schema.Number),
  purposeJustificationPrompt: Schema.optional(Schema.String),
  purposeJustificationRequired: Schema.optional(Schema.Boolean),
  sessionDuration: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    approvalGroups: "approval_groups",
    approvalRequired: "approval_required",
    isolationRequired: "isolation_required",
    precedence: "precedence",
    purposeJustificationPrompt: "purpose_justification_prompt",
    purposeJustificationRequired: "purpose_justification_required",
    sessionDuration: "session_duration",
  }),
  T.Http({
    method: "PUT",
    path: "/{accountOrZone}/{accountOrZoneId}/access/apps/{appId}/policies/{policyId}",
  }),
) as unknown as Schema.Schema<UpdateAccessApplicationPolicyRequest>;

export interface UpdateAccessApplicationPolicyResponse {
  /** The UUID of the policy */
  id?: string;
  /** Administrators who can approve a temporary authentication request. */
  approvalGroups?: unknown[];
  /** Requires the user to request access from an administrator at the start of each session. */
  approvalRequired?: boolean;
  createdAt?: string;
  /** The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action. */
  decision?: "allow" | "bypass" | "deny" | "non_identity";
  /** Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules. */
  exclude?: (
    | { group: { id: string } }
    | { anyValidServiceToken: unknown }
    | { authContext: { id: string; acId: string; identityProviderId: string } }
    | { authMethod: { authMethod: string } }
    | { azureAD: { id: string; identityProviderId: string } }
    | { certificate: unknown }
    | { commonName: { commonName: string } }
    | { geo: { countryCode: string } }
    | { devicePosture: { integrationUid: string } }
    | { emailDomain: { domain: string } }
    | { emailList: { id: string } }
    | { email: { email: string } }
    | { everyone: unknown }
    | { externalEvaluation: { evaluateUrl: string; keysUrl: string } }
    | {
        githubOrganization: {
          identityProviderId: string;
          name: string;
          team?: string;
        };
      }
    | { gsuite: { email: string; identityProviderId: string } }
    | { loginMethod: { id: string } }
    | { ipList: { id: string } }
    | { ip: { ip: string } }
    | { okta: { identityProviderId: string; name: string } }
    | {
        saml: {
          attributeName: string;
          attributeValue: string;
          identityProviderId: string;
        };
      }
    | {
        oidc: {
          claimName: string;
          claimValue: string;
          identityProviderId: string;
        };
      }
    | { serviceToken: { tokenId: string } }
    | { linkedAppToken: { appUid: string } }
  )[];
  /** Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules. */
  include?: (
    | { group: { id: string } }
    | { anyValidServiceToken: unknown }
    | { authContext: { id: string; acId: string; identityProviderId: string } }
    | { authMethod: { authMethod: string } }
    | { azureAD: { id: string; identityProviderId: string } }
    | { certificate: unknown }
    | { commonName: { commonName: string } }
    | { geo: { countryCode: string } }
    | { devicePosture: { integrationUid: string } }
    | { emailDomain: { domain: string } }
    | { emailList: { id: string } }
    | { email: { email: string } }
    | { everyone: unknown }
    | { externalEvaluation: { evaluateUrl: string; keysUrl: string } }
    | {
        githubOrganization: {
          identityProviderId: string;
          name: string;
          team?: string;
        };
      }
    | { gsuite: { email: string; identityProviderId: string } }
    | { loginMethod: { id: string } }
    | { ipList: { id: string } }
    | { ip: { ip: string } }
    | { okta: { identityProviderId: string; name: string } }
    | {
        saml: {
          attributeName: string;
          attributeValue: string;
          identityProviderId: string;
        };
      }
    | {
        oidc: {
          claimName: string;
          claimValue: string;
          identityProviderId: string;
        };
      }
    | { serviceToken: { tokenId: string } }
    | { linkedAppToken: { appUid: string } }
  )[];
  /** Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature. */
  isolationRequired?: boolean;
  /** The name of the Access policy. */
  name?: string;
  /** The order of execution for this policy. Must be unique for each policy within an app. */
  precedence?: number;
  /** A custom message that will appear on the purpose justification screen. */
  purposeJustificationPrompt?: string;
  /** Require users to enter a justification when they log in to the application. */
  purposeJustificationRequired?: boolean;
  /** Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules. */
  require?: (
    | { group: { id: string } }
    | { anyValidServiceToken: unknown }
    | { authContext: { id: string; acId: string; identityProviderId: string } }
    | { authMethod: { authMethod: string } }
    | { azureAD: { id: string; identityProviderId: string } }
    | { certificate: unknown }
    | { commonName: { commonName: string } }
    | { geo: { countryCode: string } }
    | { devicePosture: { integrationUid: string } }
    | { emailDomain: { domain: string } }
    | { emailList: { id: string } }
    | { email: { email: string } }
    | { everyone: unknown }
    | { externalEvaluation: { evaluateUrl: string; keysUrl: string } }
    | {
        githubOrganization: {
          identityProviderId: string;
          name: string;
          team?: string;
        };
      }
    | { gsuite: { email: string; identityProviderId: string } }
    | { loginMethod: { id: string } }
    | { ipList: { id: string } }
    | { ip: { ip: string } }
    | { okta: { identityProviderId: string; name: string } }
    | {
        saml: {
          attributeName: string;
          attributeValue: string;
          identityProviderId: string;
        };
      }
    | {
        oidc: {
          claimName: string;
          claimValue: string;
          identityProviderId: string;
        };
      }
    | { serviceToken: { tokenId: string } }
    | { linkedAppToken: { appUid: string } }
  )[];
  /** The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. */
  sessionDuration?: string;
  updatedAt?: string;
}

export const UpdateAccessApplicationPolicyResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
  approvalRequired: Schema.optional(Schema.Boolean),
  createdAt: Schema.optional(Schema.String),
  decision: Schema.optional(
    Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
  ),
  exclude: Schema.optional(
    Schema.Array(
      Schema.Union([
        Schema.Struct({
          group: Schema.Struct({
            id: Schema.String,
          }),
        }),
        Schema.Struct({
          anyValidServiceToken: Schema.Unknown,
        }).pipe(
          Schema.encodeKeys({
            anyValidServiceToken: "any_valid_service_token",
          }),
        ),
        Schema.Struct({
          authContext: Schema.Struct({
            id: Schema.String,
            acId: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              acId: "ac_id",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }).pipe(Schema.encodeKeys({ authContext: "auth_context" })),
        Schema.Struct({
          authMethod: Schema.Struct({
            authMethod: Schema.String,
          }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
        }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
        Schema.Struct({
          azureAD: Schema.Struct({
            id: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          certificate: Schema.Unknown,
        }),
        Schema.Struct({
          commonName: Schema.Struct({
            commonName: Schema.String,
          }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
        }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
        Schema.Struct({
          geo: Schema.Struct({
            countryCode: Schema.String,
          }).pipe(Schema.encodeKeys({ countryCode: "country_code" })),
        }),
        Schema.Struct({
          devicePosture: Schema.Struct({
            integrationUid: Schema.String,
          }).pipe(Schema.encodeKeys({ integrationUid: "integration_uid" })),
        }).pipe(Schema.encodeKeys({ devicePosture: "device_posture" })),
        Schema.Struct({
          emailDomain: Schema.Struct({
            domain: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ emailDomain: "email_domain" })),
        Schema.Struct({
          emailList: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ emailList: "email_list" })),
        Schema.Struct({
          email: Schema.Struct({
            email: Schema.String,
          }),
        }),
        Schema.Struct({
          everyone: Schema.Unknown,
        }),
        Schema.Struct({
          externalEvaluation: Schema.Struct({
            evaluateUrl: Schema.String,
            keysUrl: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              evaluateUrl: "evaluate_url",
              keysUrl: "keys_url",
            }),
          ),
        }).pipe(
          Schema.encodeKeys({ externalEvaluation: "external_evaluation" }),
        ),
        Schema.Struct({
          githubOrganization: Schema.Struct({
            identityProviderId: Schema.String,
            name: Schema.String,
            team: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              identityProviderId: "identity_provider_id",
              name: "name",
              team: "team",
            }),
          ),
        }).pipe(
          Schema.encodeKeys({ githubOrganization: "'github-organization'" }),
        ),
        Schema.Struct({
          gsuite: Schema.Struct({
            email: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              email: "email",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          loginMethod: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ loginMethod: "login_method" })),
        Schema.Struct({
          ipList: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ ipList: "ip_list" })),
        Schema.Struct({
          ip: Schema.Struct({
            ip: Schema.String,
          }),
        }),
        Schema.Struct({
          okta: Schema.Struct({
            identityProviderId: Schema.String,
            name: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              identityProviderId: "identity_provider_id",
              name: "name",
            }),
          ),
        }),
        Schema.Struct({
          saml: Schema.Struct({
            attributeName: Schema.String,
            attributeValue: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              attributeName: "attribute_name",
              attributeValue: "attribute_value",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          oidc: Schema.Struct({
            claimName: Schema.String,
            claimValue: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              claimName: "claim_name",
              claimValue: "claim_value",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          serviceToken: Schema.Struct({
            tokenId: Schema.String,
          }).pipe(Schema.encodeKeys({ tokenId: "token_id" })),
        }).pipe(Schema.encodeKeys({ serviceToken: "service_token" })),
        Schema.Struct({
          linkedAppToken: Schema.Struct({
            appUid: Schema.String,
          }).pipe(Schema.encodeKeys({ appUid: "app_uid" })),
        }).pipe(Schema.encodeKeys({ linkedAppToken: "linked_app_token" })),
      ]),
    ),
  ),
  include: Schema.optional(
    Schema.Array(
      Schema.Union([
        Schema.Struct({
          group: Schema.Struct({
            id: Schema.String,
          }),
        }),
        Schema.Struct({
          anyValidServiceToken: Schema.Unknown,
        }).pipe(
          Schema.encodeKeys({
            anyValidServiceToken: "any_valid_service_token",
          }),
        ),
        Schema.Struct({
          authContext: Schema.Struct({
            id: Schema.String,
            acId: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              acId: "ac_id",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }).pipe(Schema.encodeKeys({ authContext: "auth_context" })),
        Schema.Struct({
          authMethod: Schema.Struct({
            authMethod: Schema.String,
          }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
        }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
        Schema.Struct({
          azureAD: Schema.Struct({
            id: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          certificate: Schema.Unknown,
        }),
        Schema.Struct({
          commonName: Schema.Struct({
            commonName: Schema.String,
          }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
        }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
        Schema.Struct({
          geo: Schema.Struct({
            countryCode: Schema.String,
          }).pipe(Schema.encodeKeys({ countryCode: "country_code" })),
        }),
        Schema.Struct({
          devicePosture: Schema.Struct({
            integrationUid: Schema.String,
          }).pipe(Schema.encodeKeys({ integrationUid: "integration_uid" })),
        }).pipe(Schema.encodeKeys({ devicePosture: "device_posture" })),
        Schema.Struct({
          emailDomain: Schema.Struct({
            domain: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ emailDomain: "email_domain" })),
        Schema.Struct({
          emailList: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ emailList: "email_list" })),
        Schema.Struct({
          email: Schema.Struct({
            email: Schema.String,
          }),
        }),
        Schema.Struct({
          everyone: Schema.Unknown,
        }),
        Schema.Struct({
          externalEvaluation: Schema.Struct({
            evaluateUrl: Schema.String,
            keysUrl: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              evaluateUrl: "evaluate_url",
              keysUrl: "keys_url",
            }),
          ),
        }).pipe(
          Schema.encodeKeys({ externalEvaluation: "external_evaluation" }),
        ),
        Schema.Struct({
          githubOrganization: Schema.Struct({
            identityProviderId: Schema.String,
            name: Schema.String,
            team: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              identityProviderId: "identity_provider_id",
              name: "name",
              team: "team",
            }),
          ),
        }).pipe(
          Schema.encodeKeys({ githubOrganization: "'github-organization'" }),
        ),
        Schema.Struct({
          gsuite: Schema.Struct({
            email: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              email: "email",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          loginMethod: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ loginMethod: "login_method" })),
        Schema.Struct({
          ipList: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ ipList: "ip_list" })),
        Schema.Struct({
          ip: Schema.Struct({
            ip: Schema.String,
          }),
        }),
        Schema.Struct({
          okta: Schema.Struct({
            identityProviderId: Schema.String,
            name: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              identityProviderId: "identity_provider_id",
              name: "name",
            }),
          ),
        }),
        Schema.Struct({
          saml: Schema.Struct({
            attributeName: Schema.String,
            attributeValue: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              attributeName: "attribute_name",
              attributeValue: "attribute_value",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          oidc: Schema.Struct({
            claimName: Schema.String,
            claimValue: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              claimName: "claim_name",
              claimValue: "claim_value",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          serviceToken: Schema.Struct({
            tokenId: Schema.String,
          }).pipe(Schema.encodeKeys({ tokenId: "token_id" })),
        }).pipe(Schema.encodeKeys({ serviceToken: "service_token" })),
        Schema.Struct({
          linkedAppToken: Schema.Struct({
            appUid: Schema.String,
          }).pipe(Schema.encodeKeys({ appUid: "app_uid" })),
        }).pipe(Schema.encodeKeys({ linkedAppToken: "linked_app_token" })),
      ]),
    ),
  ),
  isolationRequired: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
  precedence: Schema.optional(Schema.Number),
  purposeJustificationPrompt: Schema.optional(Schema.String),
  purposeJustificationRequired: Schema.optional(Schema.Boolean),
  require: Schema.optional(
    Schema.Array(
      Schema.Union([
        Schema.Struct({
          group: Schema.Struct({
            id: Schema.String,
          }),
        }),
        Schema.Struct({
          anyValidServiceToken: Schema.Unknown,
        }).pipe(
          Schema.encodeKeys({
            anyValidServiceToken: "any_valid_service_token",
          }),
        ),
        Schema.Struct({
          authContext: Schema.Struct({
            id: Schema.String,
            acId: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              acId: "ac_id",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }).pipe(Schema.encodeKeys({ authContext: "auth_context" })),
        Schema.Struct({
          authMethod: Schema.Struct({
            authMethod: Schema.String,
          }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
        }).pipe(Schema.encodeKeys({ authMethod: "auth_method" })),
        Schema.Struct({
          azureAD: Schema.Struct({
            id: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          certificate: Schema.Unknown,
        }),
        Schema.Struct({
          commonName: Schema.Struct({
            commonName: Schema.String,
          }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
        }).pipe(Schema.encodeKeys({ commonName: "common_name" })),
        Schema.Struct({
          geo: Schema.Struct({
            countryCode: Schema.String,
          }).pipe(Schema.encodeKeys({ countryCode: "country_code" })),
        }),
        Schema.Struct({
          devicePosture: Schema.Struct({
            integrationUid: Schema.String,
          }).pipe(Schema.encodeKeys({ integrationUid: "integration_uid" })),
        }).pipe(Schema.encodeKeys({ devicePosture: "device_posture" })),
        Schema.Struct({
          emailDomain: Schema.Struct({
            domain: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ emailDomain: "email_domain" })),
        Schema.Struct({
          emailList: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ emailList: "email_list" })),
        Schema.Struct({
          email: Schema.Struct({
            email: Schema.String,
          }),
        }),
        Schema.Struct({
          everyone: Schema.Unknown,
        }),
        Schema.Struct({
          externalEvaluation: Schema.Struct({
            evaluateUrl: Schema.String,
            keysUrl: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              evaluateUrl: "evaluate_url",
              keysUrl: "keys_url",
            }),
          ),
        }).pipe(
          Schema.encodeKeys({ externalEvaluation: "external_evaluation" }),
        ),
        Schema.Struct({
          githubOrganization: Schema.Struct({
            identityProviderId: Schema.String,
            name: Schema.String,
            team: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              identityProviderId: "identity_provider_id",
              name: "name",
              team: "team",
            }),
          ),
        }).pipe(
          Schema.encodeKeys({ githubOrganization: "'github-organization'" }),
        ),
        Schema.Struct({
          gsuite: Schema.Struct({
            email: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              email: "email",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          loginMethod: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ loginMethod: "login_method" })),
        Schema.Struct({
          ipList: Schema.Struct({
            id: Schema.String,
          }),
        }).pipe(Schema.encodeKeys({ ipList: "ip_list" })),
        Schema.Struct({
          ip: Schema.Struct({
            ip: Schema.String,
          }),
        }),
        Schema.Struct({
          okta: Schema.Struct({
            identityProviderId: Schema.String,
            name: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              identityProviderId: "identity_provider_id",
              name: "name",
            }),
          ),
        }),
        Schema.Struct({
          saml: Schema.Struct({
            attributeName: Schema.String,
            attributeValue: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              attributeName: "attribute_name",
              attributeValue: "attribute_value",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          oidc: Schema.Struct({
            claimName: Schema.String,
            claimValue: Schema.String,
            identityProviderId: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              claimName: "claim_name",
              claimValue: "claim_value",
              identityProviderId: "identity_provider_id",
            }),
          ),
        }),
        Schema.Struct({
          serviceToken: Schema.Struct({
            tokenId: Schema.String,
          }).pipe(Schema.encodeKeys({ tokenId: "token_id" })),
        }).pipe(Schema.encodeKeys({ serviceToken: "service_token" })),
        Schema.Struct({
          linkedAppToken: Schema.Struct({
            appUid: Schema.String,
          }).pipe(Schema.encodeKeys({ appUid: "app_uid" })),
        }).pipe(Schema.encodeKeys({ linkedAppToken: "linked_app_token" })),
      ]),
    ),
  ),
  sessionDuration: Schema.optional(Schema.String),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    approvalGroups: "approval_groups",
    approvalRequired: "approval_required",
    createdAt: "created_at",
    decision: "decision",
    exclude: "exclude",
    include: "include",
    isolationRequired: "isolation_required",
    name: "name",
    precedence: "precedence",
    purposeJustificationPrompt: "purpose_justification_prompt",
    purposeJustificationRequired: "purpose_justification_required",
    require: "require",
    sessionDuration: "session_duration",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<UpdateAccessApplicationPolicyResponse>;

export type UpdateAccessApplicationPolicyError = CommonErrors;

export const updateAccessApplicationPolicy: API.OperationMethod<
  UpdateAccessApplicationPolicyRequest,
  UpdateAccessApplicationPolicyResponse,
  UpdateAccessApplicationPolicyError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAccessApplicationPolicyRequest,
  output: UpdateAccessApplicationPolicyResponse,
  errors: [],
}));

export interface DeleteAccessApplicationPolicyRequest {
  appId: string;
  policyId: string;
}

export const DeleteAccessApplicationPolicyRequest = Schema.Struct({
  appId: Schema.String.pipe(T.HttpPath("appId")),
  policyId: Schema.String.pipe(T.HttpPath("policyId")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/{accountOrZone}/{accountOrZoneId}/access/apps/{appId}/policies/{policyId}",
  }),
) as unknown as Schema.Schema<DeleteAccessApplicationPolicyRequest>;

export interface DeleteAccessApplicationPolicyResponse {
  /** UUID. */
  id?: string;
}

export const DeleteAccessApplicationPolicyResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
}) as unknown as Schema.Schema<DeleteAccessApplicationPolicyResponse>;

export type DeleteAccessApplicationPolicyError = CommonErrors;

export const deleteAccessApplicationPolicy: API.OperationMethod<
  DeleteAccessApplicationPolicyRequest,
  DeleteAccessApplicationPolicyResponse,
  DeleteAccessApplicationPolicyError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccessApplicationPolicyRequest,
  output: DeleteAccessApplicationPolicyResponse,
  errors: [],
}));

// =============================================================================
// AccessApplicationPolicyTest
// =============================================================================

export interface GetAccessApplicationPolicyTestRequest {
  policyTestId: string;
  /** Identifier. */
  accountId: string;
}

export const GetAccessApplicationPolicyTestRequest = Schema.Struct({
  policyTestId: Schema.String.pipe(T.HttpPath("policyTestId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/policy-tests/{policyTestId}",
  }),
) as unknown as Schema.Schema<GetAccessApplicationPolicyTestRequest>;

export interface GetAccessApplicationPolicyTestResponse {
  /** The UUID of the policy test. */
  id?: string;
  /** The percentage of (processed) users approved based on policy evaluation results. */
  percentApproved?: number;
  /** The percentage of (processed) users blocked based on policy evaluation results. */
  percentBlocked?: number;
  /** The percentage of (processed) users errored based on policy evaluation results. */
  percentErrored?: number;
  /** The percentage of users processed so far (of the entire user base). */
  percentUsersProcessed?: number;
  /** The status of the policy test. */
  status?: "blocked" | "processing" | "exceeded time" | "complete";
  /** The total number of users in the user base. */
  totalUsers?: number;
  /** The number of (processed) users approved based on policy evaluation results. */
  usersApproved?: number;
  /** The number of (processed) users blocked based on policy evaluation results. */
  usersBlocked?: number;
  /** The number of (processed) users errored based on policy evaluation results. */
  usersErrored?: number;
}

export const GetAccessApplicationPolicyTestResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  percentApproved: Schema.optional(Schema.Number),
  percentBlocked: Schema.optional(Schema.Number),
  percentErrored: Schema.optional(Schema.Number),
  percentUsersProcessed: Schema.optional(Schema.Number),
  status: Schema.optional(
    Schema.Literals(["blocked", "processing", "exceeded time", "complete"]),
  ),
  totalUsers: Schema.optional(Schema.Number),
  usersApproved: Schema.optional(Schema.Number),
  usersBlocked: Schema.optional(Schema.Number),
  usersErrored: Schema.optional(Schema.Number),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    percentApproved: "percent_approved",
    percentBlocked: "percent_blocked",
    percentErrored: "percent_errored",
    percentUsersProcessed: "percent_users_processed",
    status: "status",
    totalUsers: "total_users",
    usersApproved: "users_approved",
    usersBlocked: "users_blocked",
    usersErrored: "users_errored",
  }),
) as unknown as Schema.Schema<GetAccessApplicationPolicyTestResponse>;

export type GetAccessApplicationPolicyTestError = CommonErrors;

export const getAccessApplicationPolicyTest: API.OperationMethod<
  GetAccessApplicationPolicyTestRequest,
  GetAccessApplicationPolicyTestResponse,
  GetAccessApplicationPolicyTestError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccessApplicationPolicyTestRequest,
  output: GetAccessApplicationPolicyTestResponse,
  errors: [],
}));

export interface CreateAccessApplicationPolicyTestRequest {
  /** Path param: Identifier. */
  accountId: string;
  /** Body param: */
  policies?: (
    | {
        decision: "allow" | "bypass" | "deny" | "non_identity";
        include: unknown[];
        name: string;
        approvalGroups?: unknown[];
        approvalRequired?: boolean;
        exclude?: unknown[];
        isolationRequired?: boolean;
        purposeJustificationPrompt?: string;
        purposeJustificationRequired?: boolean;
        require?: unknown[];
        sessionDuration?: string;
      }
    | string
  )[];
}

export const CreateAccessApplicationPolicyTestRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  policies: Schema.optional(
    Schema.Array(
      Schema.Union([
        Schema.Struct({
          decision: Schema.Literals([
            "allow",
            "bypass",
            "deny",
            "non_identity",
          ]),
          include: Schema.Array(Schema.Unknown),
          name: Schema.String,
          approvalGroups: Schema.optional(Schema.Array(Schema.Unknown)),
          approvalRequired: Schema.optional(Schema.Boolean),
          exclude: Schema.optional(Schema.Array(Schema.Unknown)),
          isolationRequired: Schema.optional(Schema.Boolean),
          purposeJustificationPrompt: Schema.optional(Schema.String),
          purposeJustificationRequired: Schema.optional(Schema.Boolean),
          require: Schema.optional(Schema.Array(Schema.Unknown)),
          sessionDuration: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            decision: "decision",
            include: "include",
            name: "name",
            approvalGroups: "approval_groups",
            approvalRequired: "approval_required",
            exclude: "exclude",
            isolationRequired: "isolation_required",
            purposeJustificationPrompt: "purpose_justification_prompt",
            purposeJustificationRequired: "purpose_justification_required",
            require: "require",
            sessionDuration: "session_duration",
          }),
        ),
        Schema.String,
      ]),
    ),
  ),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/access/policy-tests",
  }),
) as unknown as Schema.Schema<CreateAccessApplicationPolicyTestRequest>;

export interface CreateAccessApplicationPolicyTestResponse {
  /** The UUID of the policy test. */
  id?: string;
  /** The status of the policy test request. */
  status?: "success";
}

export const CreateAccessApplicationPolicyTestResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  status: Schema.optional(Schema.Literal("success")),
}) as unknown as Schema.Schema<CreateAccessApplicationPolicyTestResponse>;

export type CreateAccessApplicationPolicyTestError = CommonErrors;

export const createAccessApplicationPolicyTest: API.OperationMethod<
  CreateAccessApplicationPolicyTestRequest,
  CreateAccessApplicationPolicyTestResponse,
  CreateAccessApplicationPolicyTestError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAccessApplicationPolicyTestRequest,
  output: CreateAccessApplicationPolicyTestResponse,
  errors: [],
}));

// =============================================================================
// AccessApplicationPolicyTestUser
// =============================================================================

export interface ListAccessApplicationPolicyTestUsersRequest {
  policyTestId: string;
  /** Path param: Identifier. */
  accountId: string;
  /** Query param: Filter users by their policy evaluation status. */
  status?: "success" | "fail" | "error";
}

export const ListAccessApplicationPolicyTestUsersRequest = Schema.Struct({
  policyTestId: Schema.String.pipe(T.HttpPath("policyTestId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  status: Schema.optional(Schema.Literals(["success", "fail", "error"])).pipe(
    T.HttpQuery("status"),
  ),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/policy-tests/{policyTestId}/users",
  }),
) as unknown as Schema.Schema<ListAccessApplicationPolicyTestUsersRequest>;

export type ListAccessApplicationPolicyTestUsersResponse = {
  id?: string;
  email?: string;
  name?: string;
  status?: "approved" | "blocked" | "error";
}[];

export const ListAccessApplicationPolicyTestUsersResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    email: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    status: Schema.optional(Schema.Literals(["approved", "blocked", "error"])),
  }),
) as unknown as Schema.Schema<ListAccessApplicationPolicyTestUsersResponse>;

export type ListAccessApplicationPolicyTestUsersError = CommonErrors;

export const listAccessApplicationPolicyTestUsers: API.OperationMethod<
  ListAccessApplicationPolicyTestUsersRequest,
  ListAccessApplicationPolicyTestUsersResponse,
  ListAccessApplicationPolicyTestUsersError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessApplicationPolicyTestUsersRequest,
  output: ListAccessApplicationPolicyTestUsersResponse,
  errors: [],
}));

// =============================================================================
// AccessApplicationSetting
// =============================================================================

export interface PutAccessApplicationSettingRequest {
  /** Path param: The Account ID to use for this endpoint. Mutually exclusive with the Zone ID. */
  accountId?: string;
  /** Path param: The Zone ID to use for this endpoint. Mutually exclusive with the Account ID. */
  zoneId?: string;
  /** Body param: Enables loading application content in an iFrame. */
  allowIframe?: boolean;
  /** Body param: Enables automatic authentication through cloudflared. */
  skipInterstitial?: boolean;
}

export const PutAccessApplicationSettingRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  allowIframe: Schema.optional(Schema.Boolean),
  skipInterstitial: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    allowIframe: "allow_iframe",
    skipInterstitial: "skip_interstitial",
  }),
  T.Http({
    method: "PUT",
    path: "/{accountOrZone}/{accountOrZoneId}/access/apps/{appId}/settings",
  }),
) as unknown as Schema.Schema<PutAccessApplicationSettingRequest>;

export interface PutAccessApplicationSettingResponse {
  /** Enables loading application content in an iFrame. */
  allowIframe?: boolean;
  /** Enables automatic authentication through cloudflared. */
  skipInterstitial?: boolean;
}

export const PutAccessApplicationSettingResponse = Schema.Struct({
  allowIframe: Schema.optional(Schema.Boolean),
  skipInterstitial: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    allowIframe: "allow_iframe",
    skipInterstitial: "skip_interstitial",
  }),
) as unknown as Schema.Schema<PutAccessApplicationSettingResponse>;

export type PutAccessApplicationSettingError = CommonErrors;

export const putAccessApplicationSetting: API.OperationMethod<
  PutAccessApplicationSettingRequest,
  PutAccessApplicationSettingResponse,
  PutAccessApplicationSettingError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutAccessApplicationSettingRequest,
  output: PutAccessApplicationSettingResponse,
  errors: [],
}));

export interface PatchAccessApplicationSettingRequest {
  /** Path param: The Account ID to use for this endpoint. Mutually exclusive with the Zone ID. */
  accountId?: string;
  /** Path param: The Zone ID to use for this endpoint. Mutually exclusive with the Account ID. */
  zoneId?: string;
  /** Body param: Enables loading application content in an iFrame. */
  allowIframe?: boolean;
  /** Body param: Enables automatic authentication through cloudflared. */
  skipInterstitial?: boolean;
}

export const PatchAccessApplicationSettingRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  allowIframe: Schema.optional(Schema.Boolean),
  skipInterstitial: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    allowIframe: "allow_iframe",
    skipInterstitial: "skip_interstitial",
  }),
  T.Http({
    method: "PATCH",
    path: "/{accountOrZone}/{accountOrZoneId}/access/apps/{appId}/settings",
  }),
) as unknown as Schema.Schema<PatchAccessApplicationSettingRequest>;

export interface PatchAccessApplicationSettingResponse {
  /** Enables loading application content in an iFrame. */
  allowIframe?: boolean;
  /** Enables automatic authentication through cloudflared. */
  skipInterstitial?: boolean;
}

export const PatchAccessApplicationSettingResponse = Schema.Struct({
  allowIframe: Schema.optional(Schema.Boolean),
  skipInterstitial: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    allowIframe: "allow_iframe",
    skipInterstitial: "skip_interstitial",
  }),
) as unknown as Schema.Schema<PatchAccessApplicationSettingResponse>;

export type PatchAccessApplicationSettingError = CommonErrors;

export const patchAccessApplicationSetting: API.OperationMethod<
  PatchAccessApplicationSettingRequest,
  PatchAccessApplicationSettingResponse,
  PatchAccessApplicationSettingError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchAccessApplicationSettingRequest,
  output: PatchAccessApplicationSettingResponse,
  errors: [],
}));

// =============================================================================
// AccessApplicationUserPolicyCheck
// =============================================================================

export interface ListAccessApplicationUserPolicyChecksRequest {}

export const ListAccessApplicationUserPolicyChecksRequest = Schema.Struct(
  {},
).pipe(
  T.Http({
    method: "GET",
    path: "/{accountOrZone}/{accountOrZoneId}/access/apps/{appId}/user_policy_checks",
  }),
) as unknown as Schema.Schema<ListAccessApplicationUserPolicyChecksRequest>;

export interface ListAccessApplicationUserPolicyChecksResponse {
  appState?: {
    appUid?: string;
    aud?: string;
    hostname?: string;
    name?: string;
    policies?: unknown[];
    status?: string;
  };
  userIdentity?: {
    id?: string;
    accountId?: string;
    deviceSessions?: unknown;
    email?: string;
    geo?: unknown;
    iat?: number;
    isGateway?: boolean;
    isWarp?: boolean;
    name?: string;
    userUuid?: string;
    version?: number;
  };
}

export const ListAccessApplicationUserPolicyChecksResponse = Schema.Struct({
  appState: Schema.optional(
    Schema.Struct({
      appUid: Schema.optional(Schema.String),
      aud: Schema.optional(Schema.String),
      hostname: Schema.optional(Schema.String),
      name: Schema.optional(Schema.String),
      policies: Schema.optional(Schema.Array(Schema.Unknown)),
      status: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        appUid: "app_uid",
        aud: "aud",
        hostname: "hostname",
        name: "name",
        policies: "policies",
        status: "status",
      }),
    ),
  ),
  userIdentity: Schema.optional(
    Schema.Struct({
      id: Schema.optional(Schema.String),
      accountId: Schema.optional(Schema.String),
      deviceSessions: Schema.optional(Schema.Unknown),
      email: Schema.optional(Schema.String),
      geo: Schema.optional(Schema.Unknown),
      iat: Schema.optional(Schema.Number),
      isGateway: Schema.optional(Schema.Boolean),
      isWarp: Schema.optional(Schema.Boolean),
      name: Schema.optional(Schema.String),
      userUuid: Schema.optional(Schema.String),
      version: Schema.optional(Schema.Number),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        accountId: "account_id",
        deviceSessions: "device_sessions",
        email: "email",
        geo: "geo",
        iat: "iat",
        isGateway: "is_gateway",
        isWarp: "is_warp",
        name: "name",
        userUuid: "user_uuid",
        version: "version",
      }),
    ),
  ),
}).pipe(
  Schema.encodeKeys({ appState: "app_state", userIdentity: "user_identity" }),
) as unknown as Schema.Schema<ListAccessApplicationUserPolicyChecksResponse>;

export type ListAccessApplicationUserPolicyChecksError = CommonErrors;

export const listAccessApplicationUserPolicyChecks: API.OperationMethod<
  ListAccessApplicationUserPolicyChecksRequest,
  ListAccessApplicationUserPolicyChecksResponse,
  ListAccessApplicationUserPolicyChecksError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessApplicationUserPolicyChecksRequest,
  output: ListAccessApplicationUserPolicyChecksResponse,
  errors: [],
}));

// =============================================================================
// AccessBookmark
// =============================================================================

export interface GetAccessBookmarkRequest {
  bookmarkId: string;
  accountId: string;
}

export const GetAccessBookmarkRequest = Schema.Struct({
  bookmarkId: Schema.String.pipe(T.HttpPath("bookmarkId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/bookmarks/{bookmarkId}",
  }),
) as unknown as Schema.Schema<GetAccessBookmarkRequest>;

export interface GetAccessBookmarkResponse {
  /** The unique identifier for the Bookmark application. */
  id?: string;
  /** Displays the application in the App Launcher. */
  appLauncherVisible?: boolean;
  /** The domain of the Bookmark application. */
  domain?: string;
  /** The image URL for the logo shown in the App Launcher dashboard. */
  logoUrl?: string;
  /** The name of the Bookmark application. */
  name?: string;
}

export const GetAccessBookmarkResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  appLauncherVisible: Schema.optional(Schema.Boolean),
  domain: Schema.optional(Schema.String),
  logoUrl: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    appLauncherVisible: "app_launcher_visible",
    domain: "domain",
    logoUrl: "logo_url",
    name: "name",
  }),
) as unknown as Schema.Schema<GetAccessBookmarkResponse>;

export type GetAccessBookmarkError = CommonErrors;

export const getAccessBookmark: API.OperationMethod<
  GetAccessBookmarkRequest,
  GetAccessBookmarkResponse,
  GetAccessBookmarkError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccessBookmarkRequest,
  output: GetAccessBookmarkResponse,
  errors: [],
}));

export interface ListAccessBookmarksRequest {
  accountId: string;
}

export const ListAccessBookmarksRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/access/bookmarks" }),
) as unknown as Schema.Schema<ListAccessBookmarksRequest>;

export type ListAccessBookmarksResponse = {
  id?: string;
  appLauncherVisible?: boolean;
  domain?: string;
  logoUrl?: string;
  name?: string;
}[];

export const ListAccessBookmarksResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    appLauncherVisible: Schema.optional(Schema.Boolean),
    domain: Schema.optional(Schema.String),
    logoUrl: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      appLauncherVisible: "app_launcher_visible",
      domain: "domain",
      logoUrl: "logo_url",
      name: "name",
    }),
  ),
) as unknown as Schema.Schema<ListAccessBookmarksResponse>;

export type ListAccessBookmarksError = CommonErrors;

export const listAccessBookmarks: API.OperationMethod<
  ListAccessBookmarksRequest,
  ListAccessBookmarksResponse,
  ListAccessBookmarksError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessBookmarksRequest,
  output: ListAccessBookmarksResponse,
  errors: [],
}));

export interface CreateAccessBookmarkRequest {
  bookmarkId: string;
  /** Path param: */
  accountId: string;
  /** Body param: */
  body: unknown;
}

export const CreateAccessBookmarkRequest = Schema.Struct({
  bookmarkId: Schema.String.pipe(T.HttpPath("bookmarkId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody()),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/access/bookmarks/{bookmarkId}",
  }),
) as unknown as Schema.Schema<CreateAccessBookmarkRequest>;

export interface CreateAccessBookmarkResponse {
  /** The unique identifier for the Bookmark application. */
  id?: string;
  /** Displays the application in the App Launcher. */
  appLauncherVisible?: boolean;
  /** The domain of the Bookmark application. */
  domain?: string;
  /** The image URL for the logo shown in the App Launcher dashboard. */
  logoUrl?: string;
  /** The name of the Bookmark application. */
  name?: string;
}

export const CreateAccessBookmarkResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  appLauncherVisible: Schema.optional(Schema.Boolean),
  domain: Schema.optional(Schema.String),
  logoUrl: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    appLauncherVisible: "app_launcher_visible",
    domain: "domain",
    logoUrl: "logo_url",
    name: "name",
  }),
) as unknown as Schema.Schema<CreateAccessBookmarkResponse>;

export type CreateAccessBookmarkError = CommonErrors;

export const createAccessBookmark: API.OperationMethod<
  CreateAccessBookmarkRequest,
  CreateAccessBookmarkResponse,
  CreateAccessBookmarkError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAccessBookmarkRequest,
  output: CreateAccessBookmarkResponse,
  errors: [],
}));

export interface UpdateAccessBookmarkRequest {
  bookmarkId: string;
  /** Path param: */
  accountId: string;
  /** Body param: */
  body: unknown;
}

export const UpdateAccessBookmarkRequest = Schema.Struct({
  bookmarkId: Schema.String.pipe(T.HttpPath("bookmarkId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody()),
}).pipe(
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/access/bookmarks/{bookmarkId}",
  }),
) as unknown as Schema.Schema<UpdateAccessBookmarkRequest>;

export interface UpdateAccessBookmarkResponse {
  /** The unique identifier for the Bookmark application. */
  id?: string;
  /** Displays the application in the App Launcher. */
  appLauncherVisible?: boolean;
  /** The domain of the Bookmark application. */
  domain?: string;
  /** The image URL for the logo shown in the App Launcher dashboard. */
  logoUrl?: string;
  /** The name of the Bookmark application. */
  name?: string;
}

export const UpdateAccessBookmarkResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  appLauncherVisible: Schema.optional(Schema.Boolean),
  domain: Schema.optional(Schema.String),
  logoUrl: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    appLauncherVisible: "app_launcher_visible",
    domain: "domain",
    logoUrl: "logo_url",
    name: "name",
  }),
) as unknown as Schema.Schema<UpdateAccessBookmarkResponse>;

export type UpdateAccessBookmarkError = CommonErrors;

export const updateAccessBookmark: API.OperationMethod<
  UpdateAccessBookmarkRequest,
  UpdateAccessBookmarkResponse,
  UpdateAccessBookmarkError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAccessBookmarkRequest,
  output: UpdateAccessBookmarkResponse,
  errors: [],
}));

export interface DeleteAccessBookmarkRequest {
  bookmarkId: string;
  accountId: string;
}

export const DeleteAccessBookmarkRequest = Schema.Struct({
  bookmarkId: Schema.String.pipe(T.HttpPath("bookmarkId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/access/bookmarks/{bookmarkId}",
  }),
) as unknown as Schema.Schema<DeleteAccessBookmarkRequest>;

export interface DeleteAccessBookmarkResponse {
  /** UUID. */
  id?: string;
}

export const DeleteAccessBookmarkResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
}) as unknown as Schema.Schema<DeleteAccessBookmarkResponse>;

export type DeleteAccessBookmarkError = CommonErrors;

export const deleteAccessBookmark: API.OperationMethod<
  DeleteAccessBookmarkRequest,
  DeleteAccessBookmarkResponse,
  DeleteAccessBookmarkError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccessBookmarkRequest,
  output: DeleteAccessBookmarkResponse,
  errors: [],
}));

// =============================================================================
// AccessCertificate
// =============================================================================

export interface GetAccessCertificateRequest {
  certificateId: string;
}

export const GetAccessCertificateRequest = Schema.Struct({
  certificateId: Schema.String.pipe(T.HttpPath("certificateId")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/{accountOrZone}/{accountOrZoneId}/access/certificates/{certificateId}",
  }),
) as unknown as Schema.Schema<GetAccessCertificateRequest>;

export interface GetAccessCertificateResponse {
  /** The ID of the application that will use this certificate. */
  id?: string;
  /** The hostnames of the applications that will use this certificate. */
  associatedHostnames?: string[];
  expiresOn?: string;
  /** The MD5 fingerprint of the certificate. */
  fingerprint?: string;
  /** The name of the certificate. */
  name?: string;
}

export const GetAccessCertificateResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  associatedHostnames: Schema.optional(Schema.Array(Schema.String)),
  expiresOn: Schema.optional(Schema.String),
  fingerprint: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    associatedHostnames: "associated_hostnames",
    expiresOn: "expires_on",
    fingerprint: "fingerprint",
    name: "name",
  }),
) as unknown as Schema.Schema<GetAccessCertificateResponse>;

export type GetAccessCertificateError = CommonErrors;

export const getAccessCertificate: API.OperationMethod<
  GetAccessCertificateRequest,
  GetAccessCertificateResponse,
  GetAccessCertificateError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccessCertificateRequest,
  output: GetAccessCertificateResponse,
  errors: [],
}));

export interface ListAccessCertificatesRequest {}

export const ListAccessCertificatesRequest = Schema.Struct({}).pipe(
  T.Http({
    method: "GET",
    path: "/{accountOrZone}/{accountOrZoneId}/access/certificates",
  }),
) as unknown as Schema.Schema<ListAccessCertificatesRequest>;

export type ListAccessCertificatesResponse = {
  id?: string;
  associatedHostnames?: string[];
  expiresOn?: string;
  fingerprint?: string;
  name?: string;
}[];

export const ListAccessCertificatesResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    associatedHostnames: Schema.optional(Schema.Array(Schema.String)),
    expiresOn: Schema.optional(Schema.String),
    fingerprint: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      associatedHostnames: "associated_hostnames",
      expiresOn: "expires_on",
      fingerprint: "fingerprint",
      name: "name",
    }),
  ),
) as unknown as Schema.Schema<ListAccessCertificatesResponse>;

export type ListAccessCertificatesError = CommonErrors;

export const listAccessCertificates: API.OperationMethod<
  ListAccessCertificatesRequest,
  ListAccessCertificatesResponse,
  ListAccessCertificatesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessCertificatesRequest,
  output: ListAccessCertificatesResponse,
  errors: [],
}));

export interface CreateAccessCertificateRequest {
  /** Path param: The Account ID to use for this endpoint. Mutually exclusive with the Zone ID. */
  accountId?: string;
  /** Path param: The Zone ID to use for this endpoint. Mutually exclusive with the Account ID. */
  zoneId?: string;
  /** Body param: The certificate content. */
  certificate: string;
  /** Body param: The name of the certificate. */
  name: string;
  /** Body param: The hostnames of the applications that will use this certificate. */
  associatedHostnames?: string[];
}

export const CreateAccessCertificateRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  certificate: Schema.String,
  name: Schema.String,
  associatedHostnames: Schema.optional(Schema.Array(Schema.String)),
}).pipe(
  Schema.encodeKeys({
    certificate: "certificate",
    name: "name",
    associatedHostnames: "associated_hostnames",
  }),
  T.Http({
    method: "POST",
    path: "/{accountOrZone}/{accountOrZoneId}/access/certificates",
  }),
) as unknown as Schema.Schema<CreateAccessCertificateRequest>;

export interface CreateAccessCertificateResponse {
  /** The ID of the application that will use this certificate. */
  id?: string;
  /** The hostnames of the applications that will use this certificate. */
  associatedHostnames?: string[];
  expiresOn?: string;
  /** The MD5 fingerprint of the certificate. */
  fingerprint?: string;
  /** The name of the certificate. */
  name?: string;
}

export const CreateAccessCertificateResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  associatedHostnames: Schema.optional(Schema.Array(Schema.String)),
  expiresOn: Schema.optional(Schema.String),
  fingerprint: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    associatedHostnames: "associated_hostnames",
    expiresOn: "expires_on",
    fingerprint: "fingerprint",
    name: "name",
  }),
) as unknown as Schema.Schema<CreateAccessCertificateResponse>;

export type CreateAccessCertificateError = CommonErrors;

export const createAccessCertificate: API.OperationMethod<
  CreateAccessCertificateRequest,
  CreateAccessCertificateResponse,
  CreateAccessCertificateError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAccessCertificateRequest,
  output: CreateAccessCertificateResponse,
  errors: [],
}));

export interface UpdateAccessCertificateRequest {
  certificateId: string;
  /** Path param: The Account ID to use for this endpoint. Mutually exclusive with the Zone ID. */
  accountId?: string;
  /** Path param: The Zone ID to use for this endpoint. Mutually exclusive with the Account ID. */
  zoneId?: string;
  /** Body param: The hostnames of the applications that will use this certificate. */
  associatedHostnames: string[];
  /** Body param: The name of the certificate. */
  name?: string;
}

export const UpdateAccessCertificateRequest = Schema.Struct({
  certificateId: Schema.String.pipe(T.HttpPath("certificateId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  associatedHostnames: Schema.Array(Schema.String),
  name: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    associatedHostnames: "associated_hostnames",
    name: "name",
  }),
  T.Http({
    method: "PUT",
    path: "/{accountOrZone}/{accountOrZoneId}/access/certificates/{certificateId}",
  }),
) as unknown as Schema.Schema<UpdateAccessCertificateRequest>;

export interface UpdateAccessCertificateResponse {
  /** The ID of the application that will use this certificate. */
  id?: string;
  /** The hostnames of the applications that will use this certificate. */
  associatedHostnames?: string[];
  expiresOn?: string;
  /** The MD5 fingerprint of the certificate. */
  fingerprint?: string;
  /** The name of the certificate. */
  name?: string;
}

export const UpdateAccessCertificateResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  associatedHostnames: Schema.optional(Schema.Array(Schema.String)),
  expiresOn: Schema.optional(Schema.String),
  fingerprint: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    associatedHostnames: "associated_hostnames",
    expiresOn: "expires_on",
    fingerprint: "fingerprint",
    name: "name",
  }),
) as unknown as Schema.Schema<UpdateAccessCertificateResponse>;

export type UpdateAccessCertificateError = CommonErrors;

export const updateAccessCertificate: API.OperationMethod<
  UpdateAccessCertificateRequest,
  UpdateAccessCertificateResponse,
  UpdateAccessCertificateError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAccessCertificateRequest,
  output: UpdateAccessCertificateResponse,
  errors: [],
}));

export interface DeleteAccessCertificateRequest {
  certificateId: string;
}

export const DeleteAccessCertificateRequest = Schema.Struct({
  certificateId: Schema.String.pipe(T.HttpPath("certificateId")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/{accountOrZone}/{accountOrZoneId}/access/certificates/{certificateId}",
  }),
) as unknown as Schema.Schema<DeleteAccessCertificateRequest>;

export interface DeleteAccessCertificateResponse {
  /** UUID. */
  id?: string;
}

export const DeleteAccessCertificateResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
}) as unknown as Schema.Schema<DeleteAccessCertificateResponse>;

export type DeleteAccessCertificateError = CommonErrors;

export const deleteAccessCertificate: API.OperationMethod<
  DeleteAccessCertificateRequest,
  DeleteAccessCertificateResponse,
  DeleteAccessCertificateError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccessCertificateRequest,
  output: DeleteAccessCertificateResponse,
  errors: [],
}));

// =============================================================================
// AccessCertificateSetting
// =============================================================================

export interface GetAccessCertificateSettingRequest {}

export const GetAccessCertificateSettingRequest = Schema.Struct({}).pipe(
  T.Http({
    method: "GET",
    path: "/{accountOrZone}/{accountOrZoneId}/access/certificates/settings",
  }),
) as unknown as Schema.Schema<GetAccessCertificateSettingRequest>;

export type GetAccessCertificateSettingResponse = {
  chinaNetwork: boolean;
  clientCertificateForwarding: boolean;
  hostname: string;
}[];

export const GetAccessCertificateSettingResponse = Schema.Array(
  Schema.Struct({
    chinaNetwork: Schema.Boolean,
    clientCertificateForwarding: Schema.Boolean,
    hostname: Schema.String,
  }).pipe(
    Schema.encodeKeys({
      chinaNetwork: "china_network",
      clientCertificateForwarding: "client_certificate_forwarding",
      hostname: "hostname",
    }),
  ),
) as unknown as Schema.Schema<GetAccessCertificateSettingResponse>;

export type GetAccessCertificateSettingError = CommonErrors;

export const getAccessCertificateSetting: API.OperationMethod<
  GetAccessCertificateSettingRequest,
  GetAccessCertificateSettingResponse,
  GetAccessCertificateSettingError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccessCertificateSettingRequest,
  output: GetAccessCertificateSettingResponse,
  errors: [],
}));

export interface UpdateAccessCertificateSettingRequest {
  /** Path param: The Account ID to use for this endpoint. Mutually exclusive with the Zone ID. */
  accountId?: string;
  /** Path param: The Zone ID to use for this endpoint. Mutually exclusive with the Account ID. */
  zoneId?: string;
  /** Body param: */
  settings: {
    chinaNetwork: boolean;
    clientCertificateForwarding: boolean;
    hostname: string;
  }[];
}

export const UpdateAccessCertificateSettingRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  settings: Schema.Array(
    Schema.Struct({
      chinaNetwork: Schema.Boolean,
      clientCertificateForwarding: Schema.Boolean,
      hostname: Schema.String,
    }).pipe(
      Schema.encodeKeys({
        chinaNetwork: "china_network",
        clientCertificateForwarding: "client_certificate_forwarding",
        hostname: "hostname",
      }),
    ),
  ),
}).pipe(
  T.Http({
    method: "GET",
    path: "/{accountOrZone}/{accountOrZoneId}/access/certificates/settings",
  }),
) as unknown as Schema.Schema<UpdateAccessCertificateSettingRequest>;

export type UpdateAccessCertificateSettingResponse = {
  chinaNetwork: boolean;
  clientCertificateForwarding: boolean;
  hostname: string;
}[];

export const UpdateAccessCertificateSettingResponse = Schema.Array(
  Schema.Struct({
    chinaNetwork: Schema.Boolean,
    clientCertificateForwarding: Schema.Boolean,
    hostname: Schema.String,
  }).pipe(
    Schema.encodeKeys({
      chinaNetwork: "china_network",
      clientCertificateForwarding: "client_certificate_forwarding",
      hostname: "hostname",
    }),
  ),
) as unknown as Schema.Schema<UpdateAccessCertificateSettingResponse>;

export type UpdateAccessCertificateSettingError = CommonErrors;

export const updateAccessCertificateSetting: API.OperationMethod<
  UpdateAccessCertificateSettingRequest,
  UpdateAccessCertificateSettingResponse,
  UpdateAccessCertificateSettingError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAccessCertificateSettingRequest,
  output: UpdateAccessCertificateSettingResponse,
  errors: [],
}));

// =============================================================================
// AccessCustomPage
// =============================================================================

export interface GetAccessCustomPageRequest {
  customPageId: string;
  /** Identifier. */
  accountId: string;
}

export const GetAccessCustomPageRequest = Schema.Struct({
  customPageId: Schema.String.pipe(T.HttpPath("customPageId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/custom_pages/{customPageId}",
  }),
) as unknown as Schema.Schema<GetAccessCustomPageRequest>;

export interface GetAccessCustomPageResponse {
  /** Custom page HTML. */
  customHtml: string;
  /** Custom page name. */
  name: string;
  /** Custom page type. */
  type: "identity_denied" | "forbidden";
  /** UUID. */
  uid?: string;
}

export const GetAccessCustomPageResponse = Schema.Struct({
  customHtml: Schema.String,
  name: Schema.String,
  type: Schema.Literals(["identity_denied", "forbidden"]),
  uid: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    customHtml: "custom_html",
    name: "name",
    type: "type",
    uid: "uid",
  }),
) as unknown as Schema.Schema<GetAccessCustomPageResponse>;

export type GetAccessCustomPageError = CommonErrors;

export const getAccessCustomPage: API.OperationMethod<
  GetAccessCustomPageRequest,
  GetAccessCustomPageResponse,
  GetAccessCustomPageError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccessCustomPageRequest,
  output: GetAccessCustomPageResponse,
  errors: [],
}));

export interface ListAccessCustomPagesRequest {
  /** Path param: Identifier. */
  accountId: string;
}

export const ListAccessCustomPagesRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/access/custom_pages" }),
) as unknown as Schema.Schema<ListAccessCustomPagesRequest>;

export type ListAccessCustomPagesResponse = {
  name: string;
  type: "identity_denied" | "forbidden";
  uid?: string;
}[];

export const ListAccessCustomPagesResponse = Schema.Array(
  Schema.Struct({
    name: Schema.String,
    type: Schema.Literals(["identity_denied", "forbidden"]),
    uid: Schema.optional(Schema.String),
  }),
) as unknown as Schema.Schema<ListAccessCustomPagesResponse>;

export type ListAccessCustomPagesError = CommonErrors;

export const listAccessCustomPages: API.OperationMethod<
  ListAccessCustomPagesRequest,
  ListAccessCustomPagesResponse,
  ListAccessCustomPagesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessCustomPagesRequest,
  output: ListAccessCustomPagesResponse,
  errors: [],
}));

export interface CreateAccessCustomPageRequest {
  /** Path param: Identifier. */
  accountId: string;
  /** Body param: Custom page HTML. */
  customHtml: string;
  /** Body param: Custom page name. */
  name: string;
  /** Body param: Custom page type. */
  type: "identity_denied" | "forbidden";
}

export const CreateAccessCustomPageRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  customHtml: Schema.String,
  name: Schema.String,
  type: Schema.Literals(["identity_denied", "forbidden"]),
}).pipe(
  Schema.encodeKeys({ customHtml: "custom_html", name: "name", type: "type" }),
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/access/custom_pages",
  }),
) as unknown as Schema.Schema<CreateAccessCustomPageRequest>;

export interface CreateAccessCustomPageResponse {
  /** Custom page name. */
  name: string;
  /** Custom page type. */
  type: "identity_denied" | "forbidden";
  /** UUID. */
  uid?: string;
}

export const CreateAccessCustomPageResponse = Schema.Struct({
  name: Schema.String,
  type: Schema.Literals(["identity_denied", "forbidden"]),
  uid: Schema.optional(Schema.String),
}) as unknown as Schema.Schema<CreateAccessCustomPageResponse>;

export type CreateAccessCustomPageError = CommonErrors;

export const createAccessCustomPage: API.OperationMethod<
  CreateAccessCustomPageRequest,
  CreateAccessCustomPageResponse,
  CreateAccessCustomPageError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAccessCustomPageRequest,
  output: CreateAccessCustomPageResponse,
  errors: [],
}));

export interface UpdateAccessCustomPageRequest {
  customPageId: string;
  /** Path param: Identifier. */
  accountId: string;
  /** Body param: Custom page HTML. */
  customHtml: string;
  /** Body param: Custom page name. */
  name: string;
  /** Body param: Custom page type. */
  type: "identity_denied" | "forbidden";
}

export const UpdateAccessCustomPageRequest = Schema.Struct({
  customPageId: Schema.String.pipe(T.HttpPath("customPageId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  customHtml: Schema.String,
  name: Schema.String,
  type: Schema.Literals(["identity_denied", "forbidden"]),
}).pipe(
  Schema.encodeKeys({ customHtml: "custom_html", name: "name", type: "type" }),
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/access/custom_pages/{customPageId}",
  }),
) as unknown as Schema.Schema<UpdateAccessCustomPageRequest>;

export interface UpdateAccessCustomPageResponse {
  /** Custom page name. */
  name: string;
  /** Custom page type. */
  type: "identity_denied" | "forbidden";
  /** UUID. */
  uid?: string;
}

export const UpdateAccessCustomPageResponse = Schema.Struct({
  name: Schema.String,
  type: Schema.Literals(["identity_denied", "forbidden"]),
  uid: Schema.optional(Schema.String),
}) as unknown as Schema.Schema<UpdateAccessCustomPageResponse>;

export type UpdateAccessCustomPageError = CommonErrors;

export const updateAccessCustomPage: API.OperationMethod<
  UpdateAccessCustomPageRequest,
  UpdateAccessCustomPageResponse,
  UpdateAccessCustomPageError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAccessCustomPageRequest,
  output: UpdateAccessCustomPageResponse,
  errors: [],
}));

export interface DeleteAccessCustomPageRequest {
  customPageId: string;
  /** Identifier. */
  accountId: string;
}

export const DeleteAccessCustomPageRequest = Schema.Struct({
  customPageId: Schema.String.pipe(T.HttpPath("customPageId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/access/custom_pages/{customPageId}",
  }),
) as unknown as Schema.Schema<DeleteAccessCustomPageRequest>;

export interface DeleteAccessCustomPageResponse {
  /** UUID. */
  id?: string;
}

export const DeleteAccessCustomPageResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
}) as unknown as Schema.Schema<DeleteAccessCustomPageResponse>;

export type DeleteAccessCustomPageError = CommonErrors;

export const deleteAccessCustomPage: API.OperationMethod<
  DeleteAccessCustomPageRequest,
  DeleteAccessCustomPageResponse,
  DeleteAccessCustomPageError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccessCustomPageRequest,
  output: DeleteAccessCustomPageResponse,
  errors: [],
}));

// =============================================================================
// AccessGatewayCa
// =============================================================================

export interface ListAccessGatewayCasRequest {
  /** Identifier. */
  accountId: string;
}

export const ListAccessGatewayCasRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/access/gateway_ca" }),
) as unknown as Schema.Schema<ListAccessGatewayCasRequest>;

export type ListAccessGatewayCasResponse = {
  id?: string;
  publicKey?: string;
}[];

export const ListAccessGatewayCasResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    publicKey: Schema.optional(Schema.String),
  }).pipe(Schema.encodeKeys({ id: "id", publicKey: "public_key" })),
) as unknown as Schema.Schema<ListAccessGatewayCasResponse>;

export type ListAccessGatewayCasError = CommonErrors;

export const listAccessGatewayCas: API.OperationMethod<
  ListAccessGatewayCasRequest,
  ListAccessGatewayCasResponse,
  ListAccessGatewayCasError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessGatewayCasRequest,
  output: ListAccessGatewayCasResponse,
  errors: [],
}));

export interface CreateAccessGatewayCaRequest {
  /** Identifier. */
  accountId: string;
}

export const CreateAccessGatewayCaRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/access/gateway_ca" }),
) as unknown as Schema.Schema<CreateAccessGatewayCaRequest>;

export interface CreateAccessGatewayCaResponse {
  /** The key ID of this certificate. */
  id?: string;
  /** The public key of this certificate. */
  publicKey?: string;
}

export const CreateAccessGatewayCaResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  publicKey: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({ id: "id", publicKey: "public_key" }),
) as unknown as Schema.Schema<CreateAccessGatewayCaResponse>;

export type CreateAccessGatewayCaError = CommonErrors;

export const createAccessGatewayCa: API.OperationMethod<
  CreateAccessGatewayCaRequest,
  CreateAccessGatewayCaResponse,
  CreateAccessGatewayCaError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAccessGatewayCaRequest,
  output: CreateAccessGatewayCaResponse,
  errors: [],
}));

export interface DeleteAccessGatewayCaRequest {
  certificateId: string;
  /** Identifier. */
  accountId: string;
}

export const DeleteAccessGatewayCaRequest = Schema.Struct({
  certificateId: Schema.String.pipe(T.HttpPath("certificateId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/access/gateway_ca/{certificateId}",
  }),
) as unknown as Schema.Schema<DeleteAccessGatewayCaRequest>;

export interface DeleteAccessGatewayCaResponse {
  /** UUID. */
  id?: string;
}

export const DeleteAccessGatewayCaResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
}) as unknown as Schema.Schema<DeleteAccessGatewayCaResponse>;

export type DeleteAccessGatewayCaError = CommonErrors;

export const deleteAccessGatewayCa: API.OperationMethod<
  DeleteAccessGatewayCaRequest,
  DeleteAccessGatewayCaResponse,
  DeleteAccessGatewayCaError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccessGatewayCaRequest,
  output: DeleteAccessGatewayCaResponse,
  errors: [],
}));

// =============================================================================
// AccessGroup
// =============================================================================

export interface GetAccessGroupRequest {
  groupId: string;
}

export const GetAccessGroupRequest = Schema.Struct({
  groupId: Schema.String.pipe(T.HttpPath("groupId")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/{accountOrZone}/{accountOrZoneId}/access/groups/{groupId}",
  }),
) as unknown as Schema.Schema<GetAccessGroupRequest>;

export interface GetAccessGroupResponse {
  /** UUID. */
  id?: string;
  /** Rules evaluated with a NOT logical operator. To match a policy, a user cannot meet any of the Exclude rules. */
  exclude?: unknown[];
  /** Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules. */
  include?: unknown[];
  /** Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules. */
  isDefault?: unknown[];
  /** The name of the Access group. */
  name?: string;
  /** Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules. */
  require?: unknown[];
}

export const GetAccessGroupResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  exclude: Schema.optional(Schema.Array(Schema.Unknown)),
  include: Schema.optional(Schema.Array(Schema.Unknown)),
  isDefault: Schema.optional(Schema.Array(Schema.Unknown)),
  name: Schema.optional(Schema.String),
  require: Schema.optional(Schema.Array(Schema.Unknown)),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    exclude: "exclude",
    include: "include",
    isDefault: "is_default",
    name: "name",
    require: "require",
  }),
) as unknown as Schema.Schema<GetAccessGroupResponse>;

export type GetAccessGroupError = CommonErrors;

export const getAccessGroup: API.OperationMethod<
  GetAccessGroupRequest,
  GetAccessGroupResponse,
  GetAccessGroupError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccessGroupRequest,
  output: GetAccessGroupResponse,
  errors: [],
}));

export interface ListAccessGroupsRequest {}

export const ListAccessGroupsRequest = Schema.Struct({}).pipe(
  T.Http({
    method: "GET",
    path: "/{accountOrZone}/{accountOrZoneId}/access/groups",
  }),
) as unknown as Schema.Schema<ListAccessGroupsRequest>;

export type ListAccessGroupsResponse = {
  id?: string;
  exclude?: unknown[];
  include?: unknown[];
  isDefault?: unknown[];
  name?: string;
  require?: unknown[];
}[];

export const ListAccessGroupsResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    exclude: Schema.optional(Schema.Array(Schema.Unknown)),
    include: Schema.optional(Schema.Array(Schema.Unknown)),
    isDefault: Schema.optional(Schema.Array(Schema.Unknown)),
    name: Schema.optional(Schema.String),
    require: Schema.optional(Schema.Array(Schema.Unknown)),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      exclude: "exclude",
      include: "include",
      isDefault: "is_default",
      name: "name",
      require: "require",
    }),
  ),
) as unknown as Schema.Schema<ListAccessGroupsResponse>;

export type ListAccessGroupsError = CommonErrors;

export const listAccessGroups: API.OperationMethod<
  ListAccessGroupsRequest,
  ListAccessGroupsResponse,
  ListAccessGroupsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessGroupsRequest,
  output: ListAccessGroupsResponse,
  errors: [],
}));

export interface CreateAccessGroupRequest {
  /** Path param: The Account ID to use for this endpoint. Mutually exclusive with the Zone ID. */
  accountId?: string;
  /** Path param: The Zone ID to use for this endpoint. Mutually exclusive with the Account ID. */
  zoneId?: string;
  /** Body param: Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules. */
  include: unknown[];
  /** Body param: The name of the Access group. */
  name: string;
  /** Body param: Rules evaluated with a NOT logical operator. To match a policy, a user cannot meet any of the Exclude rules. */
  exclude?: unknown[];
  /** Body param: Whether this is the default group */
  isDefault?: boolean;
  /** Body param: Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules. */
  require?: unknown[];
}

export const CreateAccessGroupRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  include: Schema.Array(Schema.Unknown),
  name: Schema.String,
  exclude: Schema.optional(Schema.Array(Schema.Unknown)),
  isDefault: Schema.optional(Schema.Boolean),
  require: Schema.optional(Schema.Array(Schema.Unknown)),
}).pipe(
  Schema.encodeKeys({
    include: "include",
    name: "name",
    exclude: "exclude",
    isDefault: "is_default",
    require: "require",
  }),
  T.Http({
    method: "POST",
    path: "/{accountOrZone}/{accountOrZoneId}/access/groups",
  }),
) as unknown as Schema.Schema<CreateAccessGroupRequest>;

export interface CreateAccessGroupResponse {
  /** UUID. */
  id?: string;
  /** Rules evaluated with a NOT logical operator. To match a policy, a user cannot meet any of the Exclude rules. */
  exclude?: unknown[];
  /** Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules. */
  include?: unknown[];
  /** Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules. */
  isDefault?: unknown[];
  /** The name of the Access group. */
  name?: string;
  /** Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules. */
  require?: unknown[];
}

export const CreateAccessGroupResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  exclude: Schema.optional(Schema.Array(Schema.Unknown)),
  include: Schema.optional(Schema.Array(Schema.Unknown)),
  isDefault: Schema.optional(Schema.Array(Schema.Unknown)),
  name: Schema.optional(Schema.String),
  require: Schema.optional(Schema.Array(Schema.Unknown)),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    exclude: "exclude",
    include: "include",
    isDefault: "is_default",
    name: "name",
    require: "require",
  }),
) as unknown as Schema.Schema<CreateAccessGroupResponse>;

export type CreateAccessGroupError = CommonErrors;

export const createAccessGroup: API.OperationMethod<
  CreateAccessGroupRequest,
  CreateAccessGroupResponse,
  CreateAccessGroupError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAccessGroupRequest,
  output: CreateAccessGroupResponse,
  errors: [],
}));

export interface UpdateAccessGroupRequest {
  groupId: string;
  /** Path param: The Account ID to use for this endpoint. Mutually exclusive with the Zone ID. */
  accountId?: string;
  /** Path param: The Zone ID to use for this endpoint. Mutually exclusive with the Account ID. */
  zoneId?: string;
  /** Body param: Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules. */
  include: unknown[];
  /** Body param: The name of the Access group. */
  name: string;
  /** Body param: Rules evaluated with a NOT logical operator. To match a policy, a user cannot meet any of the Exclude rules. */
  exclude?: unknown[];
  /** Body param: Whether this is the default group */
  isDefault?: boolean;
  /** Body param: Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules. */
  require?: unknown[];
}

export const UpdateAccessGroupRequest = Schema.Struct({
  groupId: Schema.String.pipe(T.HttpPath("groupId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  include: Schema.Array(Schema.Unknown),
  name: Schema.String,
  exclude: Schema.optional(Schema.Array(Schema.Unknown)),
  isDefault: Schema.optional(Schema.Boolean),
  require: Schema.optional(Schema.Array(Schema.Unknown)),
}).pipe(
  Schema.encodeKeys({
    include: "include",
    name: "name",
    exclude: "exclude",
    isDefault: "is_default",
    require: "require",
  }),
  T.Http({
    method: "PUT",
    path: "/{accountOrZone}/{accountOrZoneId}/access/groups/{groupId}",
  }),
) as unknown as Schema.Schema<UpdateAccessGroupRequest>;

export interface UpdateAccessGroupResponse {
  /** UUID. */
  id?: string;
  /** Rules evaluated with a NOT logical operator. To match a policy, a user cannot meet any of the Exclude rules. */
  exclude?: unknown[];
  /** Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules. */
  include?: unknown[];
  /** Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules. */
  isDefault?: unknown[];
  /** The name of the Access group. */
  name?: string;
  /** Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules. */
  require?: unknown[];
}

export const UpdateAccessGroupResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  exclude: Schema.optional(Schema.Array(Schema.Unknown)),
  include: Schema.optional(Schema.Array(Schema.Unknown)),
  isDefault: Schema.optional(Schema.Array(Schema.Unknown)),
  name: Schema.optional(Schema.String),
  require: Schema.optional(Schema.Array(Schema.Unknown)),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    exclude: "exclude",
    include: "include",
    isDefault: "is_default",
    name: "name",
    require: "require",
  }),
) as unknown as Schema.Schema<UpdateAccessGroupResponse>;

export type UpdateAccessGroupError = CommonErrors;

export const updateAccessGroup: API.OperationMethod<
  UpdateAccessGroupRequest,
  UpdateAccessGroupResponse,
  UpdateAccessGroupError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAccessGroupRequest,
  output: UpdateAccessGroupResponse,
  errors: [],
}));

export interface DeleteAccessGroupRequest {
  groupId: string;
}

export const DeleteAccessGroupRequest = Schema.Struct({
  groupId: Schema.String.pipe(T.HttpPath("groupId")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/{accountOrZone}/{accountOrZoneId}/access/groups/{groupId}",
  }),
) as unknown as Schema.Schema<DeleteAccessGroupRequest>;

export interface DeleteAccessGroupResponse {
  /** UUID. */
  id?: string;
}

export const DeleteAccessGroupResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
}) as unknown as Schema.Schema<DeleteAccessGroupResponse>;

export type DeleteAccessGroupError = CommonErrors;

export const deleteAccessGroup: API.OperationMethod<
  DeleteAccessGroupRequest,
  DeleteAccessGroupResponse,
  DeleteAccessGroupError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccessGroupRequest,
  output: DeleteAccessGroupResponse,
  errors: [],
}));

// =============================================================================
// AccessInfrastructureTarget
// =============================================================================

export interface GetAccessInfrastructureTargetRequest {
  targetId: string;
  /** Account identifier */
  accountId: string;
}

export const GetAccessInfrastructureTargetRequest = Schema.Struct({
  targetId: Schema.String.pipe(T.HttpPath("targetId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/infrastructure/targets/{targetId}",
  }),
) as unknown as Schema.Schema<GetAccessInfrastructureTargetRequest>;

export interface GetAccessInfrastructureTargetResponse {
  /** Target identifier */
  id: string;
  /** Date and time at which the target was created */
  createdAt: string;
  /** A non-unique field that refers to a target */
  hostname: string;
  /** The IPv4/IPv6 address that identifies where to reach a target */
  ip: {
    ipv4?: { ipAddr?: string; virtualNetworkId?: string };
    ipv6?: { ipAddr?: string; virtualNetworkId?: string };
  };
  /** Date and time at which the target was modified */
  modifiedAt: string;
}

export const GetAccessInfrastructureTargetResponse = Schema.Struct({
  id: Schema.String,
  createdAt: Schema.String,
  hostname: Schema.String,
  ip: Schema.Struct({
    ipv4: Schema.optional(
      Schema.Struct({
        ipAddr: Schema.optional(Schema.String),
        virtualNetworkId: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          ipAddr: "ip_addr",
          virtualNetworkId: "virtual_network_id",
        }),
      ),
    ),
    ipv6: Schema.optional(
      Schema.Struct({
        ipAddr: Schema.optional(Schema.String),
        virtualNetworkId: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          ipAddr: "ip_addr",
          virtualNetworkId: "virtual_network_id",
        }),
      ),
    ),
  }),
  modifiedAt: Schema.String,
}).pipe(
  Schema.encodeKeys({
    id: "id",
    createdAt: "created_at",
    hostname: "hostname",
    ip: "ip",
    modifiedAt: "modified_at",
  }),
) as unknown as Schema.Schema<GetAccessInfrastructureTargetResponse>;

export type GetAccessInfrastructureTargetError = CommonErrors;

export const getAccessInfrastructureTarget: API.OperationMethod<
  GetAccessInfrastructureTargetRequest,
  GetAccessInfrastructureTargetResponse,
  GetAccessInfrastructureTargetError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccessInfrastructureTargetRequest,
  output: GetAccessInfrastructureTargetResponse,
  errors: [],
}));

export interface ListAccessInfrastructureTargetsRequest {
  /** Path param: Account identifier */
  accountId: string;
  /** Query param: Date and time at which the target was created after (inclusive) */
  createdAfter?: string | null;
  /** Query param: Date and time at which the target was created before (inclusive) */
  createdBefore?: string | null;
  /** Query param: The sorting direction. */
  direction?: "asc" | "desc";
  /** Query param: Hostname of a target */
  hostname?: string | null;
  /** Query param: Partial match to the hostname of a target */
  hostnameContains?: string | null;
  /** Query param: Filters for targets whose IP addresses look like the specified string. Supports ` ` as a wildcard character */
  ipLike?: string | null;
  /** Query param: IPv4 address of the target */
  ipV4?: string | null;
  /** Query param: IPv6 address of the target */
  ipV6?: string | null;
  /** Query param: Filters for targets that have any of the following IP addresses. Specify `ips` multiple times in query parameter to build list of candidates. */
  ips?: string[];
  /** Query param: Defines an IPv4 filter range's ending value (inclusive). Requires `ipv4_start` to be specified as well. */
  ipv4End?: string | null;
  /** Query param: Defines an IPv4 filter range's starting value (inclusive). Requires `ipv4_end` to be specified as well. */
  ipv4Start?: string | null;
  /** Query param: Defines an IPv6 filter range's ending value (inclusive). Requires `ipv6_start` to be specified as well. */
  ipv6End?: string | null;
  /** Query param: Defines an IPv6 filter range's starting value (inclusive). Requires `ipv6_end` to be specified as well. */
  ipv6Start?: string | null;
  /** Query param: Date and time at which the target was modified after (inclusive) */
  modifiedAfter?: string | null;
  /** Query param: Date and time at which the target was modified before (inclusive) */
  modifiedBefore?: string | null;
  /** Query param: The field to sort by. */
  order?: "hostname" | "created_at";
  /** Query param: Filters for targets that have any of the following UUIDs. Specify `target_ids` multiple times in query parameter to build list of candidates. */
  targetIds?: string[];
  /** Query param: Private virtual network identifier of the target */
  virtualNetworkId?: string | null;
}

export const ListAccessInfrastructureTargetsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  createdAfter: Schema.optional(
    Schema.Union([Schema.String, Schema.Null]),
  ).pipe(T.HttpQuery("created_after")),
  createdBefore: Schema.optional(
    Schema.Union([Schema.String, Schema.Null]),
  ).pipe(T.HttpQuery("created_before")),
  direction: Schema.optional(Schema.Literals(["asc", "desc"])).pipe(
    T.HttpQuery("direction"),
  ),
  hostname: Schema.optional(Schema.Union([Schema.String, Schema.Null])).pipe(
    T.HttpQuery("hostname"),
  ),
  hostnameContains: Schema.optional(
    Schema.Union([Schema.String, Schema.Null]),
  ).pipe(T.HttpQuery("hostname_contains")),
  ipLike: Schema.optional(Schema.Union([Schema.String, Schema.Null])).pipe(
    T.HttpQuery("ip_like"),
  ),
  ipV4: Schema.optional(Schema.Union([Schema.String, Schema.Null])).pipe(
    T.HttpQuery("ip_v4"),
  ),
  ipV6: Schema.optional(Schema.Union([Schema.String, Schema.Null])).pipe(
    T.HttpQuery("ip_v6"),
  ),
  ips: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("ips")),
  ipv4End: Schema.optional(Schema.Union([Schema.String, Schema.Null])).pipe(
    T.HttpQuery("ipv4_end"),
  ),
  ipv4Start: Schema.optional(Schema.Union([Schema.String, Schema.Null])).pipe(
    T.HttpQuery("ipv4_start"),
  ),
  ipv6End: Schema.optional(Schema.Union([Schema.String, Schema.Null])).pipe(
    T.HttpQuery("ipv6_end"),
  ),
  ipv6Start: Schema.optional(Schema.Union([Schema.String, Schema.Null])).pipe(
    T.HttpQuery("ipv6_start"),
  ),
  modifiedAfter: Schema.optional(
    Schema.Union([Schema.String, Schema.Null]),
  ).pipe(T.HttpQuery("modified_after")),
  modifiedBefore: Schema.optional(
    Schema.Union([Schema.String, Schema.Null]),
  ).pipe(T.HttpQuery("modified_before")),
  order: Schema.optional(Schema.Literals(["hostname", "created_at"])).pipe(
    T.HttpQuery("order"),
  ),
  targetIds: Schema.optional(Schema.Array(Schema.String)).pipe(
    T.HttpQuery("target_ids"),
  ),
  virtualNetworkId: Schema.optional(
    Schema.Union([Schema.String, Schema.Null]),
  ).pipe(T.HttpQuery("virtual_network_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/infrastructure/targets",
  }),
) as unknown as Schema.Schema<ListAccessInfrastructureTargetsRequest>;

export type ListAccessInfrastructureTargetsResponse = {
  id: string;
  createdAt: string;
  hostname: string;
  ip: {
    ipv4?: { ipAddr?: string; virtualNetworkId?: string };
    ipv6?: { ipAddr?: string; virtualNetworkId?: string };
  };
  modifiedAt: string;
}[];

export const ListAccessInfrastructureTargetsResponse = Schema.Array(
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    hostname: Schema.String,
    ip: Schema.Struct({
      ipv4: Schema.optional(
        Schema.Struct({
          ipAddr: Schema.optional(Schema.String),
          virtualNetworkId: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            ipAddr: "ip_addr",
            virtualNetworkId: "virtual_network_id",
          }),
        ),
      ),
      ipv6: Schema.optional(
        Schema.Struct({
          ipAddr: Schema.optional(Schema.String),
          virtualNetworkId: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            ipAddr: "ip_addr",
            virtualNetworkId: "virtual_network_id",
          }),
        ),
      ),
    }),
    modifiedAt: Schema.String,
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      hostname: "hostname",
      ip: "ip",
      modifiedAt: "modified_at",
    }),
  ),
) as unknown as Schema.Schema<ListAccessInfrastructureTargetsResponse>;

export type ListAccessInfrastructureTargetsError = CommonErrors;

export const listAccessInfrastructureTargets: API.OperationMethod<
  ListAccessInfrastructureTargetsRequest,
  ListAccessInfrastructureTargetsResponse,
  ListAccessInfrastructureTargetsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessInfrastructureTargetsRequest,
  output: ListAccessInfrastructureTargetsResponse,
  errors: [],
}));

export interface CreateAccessInfrastructureTargetRequest {
  /** Path param: Account identifier */
  accountId: string;
  /** Body param: A non-unique field that refers to a target. Case insensitive, maximum length of 255 characters, supports the use of special characters dash and period, does not support spaces, and must st */
  hostname: string;
  /** Body param: The IPv4/IPv6 address that identifies where to reach a target */
  ip: {
    ipv4?: { ipAddr?: string; virtualNetworkId?: string };
    ipv6?: { ipAddr?: string; virtualNetworkId?: string };
  };
}

export const CreateAccessInfrastructureTargetRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  hostname: Schema.String,
  ip: Schema.Struct({
    ipv4: Schema.optional(
      Schema.Struct({
        ipAddr: Schema.optional(Schema.String),
        virtualNetworkId: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          ipAddr: "ip_addr",
          virtualNetworkId: "virtual_network_id",
        }),
      ),
    ),
    ipv6: Schema.optional(
      Schema.Struct({
        ipAddr: Schema.optional(Schema.String),
        virtualNetworkId: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          ipAddr: "ip_addr",
          virtualNetworkId: "virtual_network_id",
        }),
      ),
    ),
  }),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/infrastructure/targets",
  }),
) as unknown as Schema.Schema<CreateAccessInfrastructureTargetRequest>;

export interface CreateAccessInfrastructureTargetResponse {
  /** Target identifier */
  id: string;
  /** Date and time at which the target was created */
  createdAt: string;
  /** A non-unique field that refers to a target */
  hostname: string;
  /** The IPv4/IPv6 address that identifies where to reach a target */
  ip: {
    ipv4?: { ipAddr?: string; virtualNetworkId?: string };
    ipv6?: { ipAddr?: string; virtualNetworkId?: string };
  };
  /** Date and time at which the target was modified */
  modifiedAt: string;
}

export const CreateAccessInfrastructureTargetResponse = Schema.Struct({
  id: Schema.String,
  createdAt: Schema.String,
  hostname: Schema.String,
  ip: Schema.Struct({
    ipv4: Schema.optional(
      Schema.Struct({
        ipAddr: Schema.optional(Schema.String),
        virtualNetworkId: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          ipAddr: "ip_addr",
          virtualNetworkId: "virtual_network_id",
        }),
      ),
    ),
    ipv6: Schema.optional(
      Schema.Struct({
        ipAddr: Schema.optional(Schema.String),
        virtualNetworkId: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          ipAddr: "ip_addr",
          virtualNetworkId: "virtual_network_id",
        }),
      ),
    ),
  }),
  modifiedAt: Schema.String,
}).pipe(
  Schema.encodeKeys({
    id: "id",
    createdAt: "created_at",
    hostname: "hostname",
    ip: "ip",
    modifiedAt: "modified_at",
  }),
) as unknown as Schema.Schema<CreateAccessInfrastructureTargetResponse>;

export type CreateAccessInfrastructureTargetError = CommonErrors;

export const createAccessInfrastructureTarget: API.OperationMethod<
  CreateAccessInfrastructureTargetRequest,
  CreateAccessInfrastructureTargetResponse,
  CreateAccessInfrastructureTargetError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAccessInfrastructureTargetRequest,
  output: CreateAccessInfrastructureTargetResponse,
  errors: [],
}));

export interface UpdateAccessInfrastructureTargetRequest {
  targetId: string;
  /** Path param: Account identifier */
  accountId: string;
  /** Body param: A non-unique field that refers to a target. Case insensitive, maximum length of 255 characters, supports the use of special characters dash and period, does not support spaces, and must st */
  hostname: string;
  /** Body param: The IPv4/IPv6 address that identifies where to reach a target */
  ip: {
    ipv4?: { ipAddr?: string; virtualNetworkId?: string };
    ipv6?: { ipAddr?: string; virtualNetworkId?: string };
  };
}

export const UpdateAccessInfrastructureTargetRequest = Schema.Struct({
  targetId: Schema.String.pipe(T.HttpPath("targetId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  hostname: Schema.String,
  ip: Schema.Struct({
    ipv4: Schema.optional(
      Schema.Struct({
        ipAddr: Schema.optional(Schema.String),
        virtualNetworkId: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          ipAddr: "ip_addr",
          virtualNetworkId: "virtual_network_id",
        }),
      ),
    ),
    ipv6: Schema.optional(
      Schema.Struct({
        ipAddr: Schema.optional(Schema.String),
        virtualNetworkId: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          ipAddr: "ip_addr",
          virtualNetworkId: "virtual_network_id",
        }),
      ),
    ),
  }),
}).pipe(
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/infrastructure/targets/{targetId}",
  }),
) as unknown as Schema.Schema<UpdateAccessInfrastructureTargetRequest>;

export interface UpdateAccessInfrastructureTargetResponse {
  /** Target identifier */
  id: string;
  /** Date and time at which the target was created */
  createdAt: string;
  /** A non-unique field that refers to a target */
  hostname: string;
  /** The IPv4/IPv6 address that identifies where to reach a target */
  ip: {
    ipv4?: { ipAddr?: string; virtualNetworkId?: string };
    ipv6?: { ipAddr?: string; virtualNetworkId?: string };
  };
  /** Date and time at which the target was modified */
  modifiedAt: string;
}

export const UpdateAccessInfrastructureTargetResponse = Schema.Struct({
  id: Schema.String,
  createdAt: Schema.String,
  hostname: Schema.String,
  ip: Schema.Struct({
    ipv4: Schema.optional(
      Schema.Struct({
        ipAddr: Schema.optional(Schema.String),
        virtualNetworkId: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          ipAddr: "ip_addr",
          virtualNetworkId: "virtual_network_id",
        }),
      ),
    ),
    ipv6: Schema.optional(
      Schema.Struct({
        ipAddr: Schema.optional(Schema.String),
        virtualNetworkId: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          ipAddr: "ip_addr",
          virtualNetworkId: "virtual_network_id",
        }),
      ),
    ),
  }),
  modifiedAt: Schema.String,
}).pipe(
  Schema.encodeKeys({
    id: "id",
    createdAt: "created_at",
    hostname: "hostname",
    ip: "ip",
    modifiedAt: "modified_at",
  }),
) as unknown as Schema.Schema<UpdateAccessInfrastructureTargetResponse>;

export type UpdateAccessInfrastructureTargetError = CommonErrors;

export const updateAccessInfrastructureTarget: API.OperationMethod<
  UpdateAccessInfrastructureTargetRequest,
  UpdateAccessInfrastructureTargetResponse,
  UpdateAccessInfrastructureTargetError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAccessInfrastructureTargetRequest,
  output: UpdateAccessInfrastructureTargetResponse,
  errors: [],
}));

export interface DeleteAccessInfrastructureTargetRequest {
  targetId: string;
  /** Account identifier */
  accountId: string;
}

export const DeleteAccessInfrastructureTargetRequest = Schema.Struct({
  targetId: Schema.String.pipe(T.HttpPath("targetId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/infrastructure/targets/{targetId}",
  }),
) as unknown as Schema.Schema<DeleteAccessInfrastructureTargetRequest>;

export type DeleteAccessInfrastructureTargetResponse = unknown;

export const DeleteAccessInfrastructureTargetResponse =
  Schema.Unknown as unknown as Schema.Schema<DeleteAccessInfrastructureTargetResponse>;

export type DeleteAccessInfrastructureTargetError = CommonErrors;

export const deleteAccessInfrastructureTarget: API.OperationMethod<
  DeleteAccessInfrastructureTargetRequest,
  DeleteAccessInfrastructureTargetResponse,
  DeleteAccessInfrastructureTargetError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccessInfrastructureTargetRequest,
  output: DeleteAccessInfrastructureTargetResponse,
  errors: [],
}));

export interface BulkUpdateAccessInfrastructureTargetsRequest {
  /** Path param: Account identifier */
  accountId: string;
  /** Body param: */
  body: {
    hostname: string;
    ip: {
      ipv4?: { ipAddr?: string; virtualNetworkId?: string };
      ipv6?: { ipAddr?: string; virtualNetworkId?: string };
    };
  }[];
}

export const BulkUpdateAccessInfrastructureTargetsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(
    Schema.Struct({
      hostname: Schema.String,
      ip: Schema.Struct({
        ipv4: Schema.optional(
          Schema.Struct({
            ipAddr: Schema.optional(Schema.String),
            virtualNetworkId: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              ipAddr: "ip_addr",
              virtualNetworkId: "virtual_network_id",
            }),
          ),
        ),
        ipv6: Schema.optional(
          Schema.Struct({
            ipAddr: Schema.optional(Schema.String),
            virtualNetworkId: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              ipAddr: "ip_addr",
              virtualNetworkId: "virtual_network_id",
            }),
          ),
        ),
      }),
    }),
  ).pipe(T.HttpBody()),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/infrastructure/targets/batch",
  }),
) as unknown as Schema.Schema<BulkUpdateAccessInfrastructureTargetsRequest>;

export type BulkUpdateAccessInfrastructureTargetsResponse = {
  id: string;
  createdAt: string;
  hostname: string;
  ip: {
    ipv4?: { ipAddr?: string; virtualNetworkId?: string };
    ipv6?: { ipAddr?: string; virtualNetworkId?: string };
  };
  modifiedAt: string;
}[];

export const BulkUpdateAccessInfrastructureTargetsResponse = Schema.Array(
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    hostname: Schema.String,
    ip: Schema.Struct({
      ipv4: Schema.optional(
        Schema.Struct({
          ipAddr: Schema.optional(Schema.String),
          virtualNetworkId: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            ipAddr: "ip_addr",
            virtualNetworkId: "virtual_network_id",
          }),
        ),
      ),
      ipv6: Schema.optional(
        Schema.Struct({
          ipAddr: Schema.optional(Schema.String),
          virtualNetworkId: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            ipAddr: "ip_addr",
            virtualNetworkId: "virtual_network_id",
          }),
        ),
      ),
    }),
    modifiedAt: Schema.String,
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      hostname: "hostname",
      ip: "ip",
      modifiedAt: "modified_at",
    }),
  ),
) as unknown as Schema.Schema<BulkUpdateAccessInfrastructureTargetsResponse>;

export type BulkUpdateAccessInfrastructureTargetsError = CommonErrors;

export const bulkUpdateAccessInfrastructureTargets: API.OperationMethod<
  BulkUpdateAccessInfrastructureTargetsRequest,
  BulkUpdateAccessInfrastructureTargetsResponse,
  BulkUpdateAccessInfrastructureTargetsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: BulkUpdateAccessInfrastructureTargetsRequest,
  output: BulkUpdateAccessInfrastructureTargetsResponse,
  errors: [],
}));

export interface BulkDeleteAccessInfrastructureTargetsRequest {
  /** Account identifier */
  accountId: string;
}

export const BulkDeleteAccessInfrastructureTargetsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/infrastructure/targets/batch",
  }),
) as unknown as Schema.Schema<BulkDeleteAccessInfrastructureTargetsRequest>;

export type BulkDeleteAccessInfrastructureTargetsResponse = unknown;

export const BulkDeleteAccessInfrastructureTargetsResponse =
  Schema.Unknown as unknown as Schema.Schema<BulkDeleteAccessInfrastructureTargetsResponse>;

export type BulkDeleteAccessInfrastructureTargetsError = CommonErrors;

export const bulkDeleteAccessInfrastructureTargets: API.OperationMethod<
  BulkDeleteAccessInfrastructureTargetsRequest,
  BulkDeleteAccessInfrastructureTargetsResponse,
  BulkDeleteAccessInfrastructureTargetsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: BulkDeleteAccessInfrastructureTargetsRequest,
  output: BulkDeleteAccessInfrastructureTargetsResponse,
  errors: [],
}));

// =============================================================================
// AccessKey
// =============================================================================

export interface GetAccessKeyRequest {
  /** Identifier. */
  accountId: string;
}

export const GetAccessKeyRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/access/keys" }),
) as unknown as Schema.Schema<GetAccessKeyRequest>;

export interface GetAccessKeyResponse {
  /** The number of days until the next key rotation. */
  daysUntilNextRotation?: number;
  /** The number of days between key rotations. */
  keyRotationIntervalDays?: number;
  /** The timestamp of the previous key rotation. */
  lastKeyRotationAt?: string;
}

export const GetAccessKeyResponse = Schema.Struct({
  daysUntilNextRotation: Schema.optional(Schema.Number),
  keyRotationIntervalDays: Schema.optional(Schema.Number),
  lastKeyRotationAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    daysUntilNextRotation: "days_until_next_rotation",
    keyRotationIntervalDays: "key_rotation_interval_days",
    lastKeyRotationAt: "last_key_rotation_at",
  }),
) as unknown as Schema.Schema<GetAccessKeyResponse>;

export type GetAccessKeyError = CommonErrors;

export const getAccessKey: API.OperationMethod<
  GetAccessKeyRequest,
  GetAccessKeyResponse,
  GetAccessKeyError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccessKeyRequest,
  output: GetAccessKeyResponse,
  errors: [],
}));

export interface PutAccessKeyRequest {
  /** Path param: Identifier. */
  accountId: string;
  /** Body param: The number of days between key rotations. */
  keyRotationIntervalDays: number;
}

export const PutAccessKeyRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  keyRotationIntervalDays: Schema.Number,
}).pipe(
  Schema.encodeKeys({ keyRotationIntervalDays: "key_rotation_interval_days" }),
  T.Http({ method: "PUT", path: "/accounts/{account_id}/access/keys" }),
) as unknown as Schema.Schema<PutAccessKeyRequest>;

export interface PutAccessKeyResponse {
  /** The number of days until the next key rotation. */
  daysUntilNextRotation?: number;
  /** The number of days between key rotations. */
  keyRotationIntervalDays?: number;
  /** The timestamp of the previous key rotation. */
  lastKeyRotationAt?: string;
}

export const PutAccessKeyResponse = Schema.Struct({
  daysUntilNextRotation: Schema.optional(Schema.Number),
  keyRotationIntervalDays: Schema.optional(Schema.Number),
  lastKeyRotationAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    daysUntilNextRotation: "days_until_next_rotation",
    keyRotationIntervalDays: "key_rotation_interval_days",
    lastKeyRotationAt: "last_key_rotation_at",
  }),
) as unknown as Schema.Schema<PutAccessKeyResponse>;

export type PutAccessKeyError = CommonErrors;

export const putAccessKey: API.OperationMethod<
  PutAccessKeyRequest,
  PutAccessKeyResponse,
  PutAccessKeyError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutAccessKeyRequest,
  output: PutAccessKeyResponse,
  errors: [],
}));

export interface RotateAccessKeyRequest {
  /** Identifier. */
  accountId: string;
}

export const RotateAccessKeyRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/access/keys/rotate" }),
) as unknown as Schema.Schema<RotateAccessKeyRequest>;

export interface RotateAccessKeyResponse {
  /** The number of days until the next key rotation. */
  daysUntilNextRotation?: number;
  /** The number of days between key rotations. */
  keyRotationIntervalDays?: number;
  /** The timestamp of the previous key rotation. */
  lastKeyRotationAt?: string;
}

export const RotateAccessKeyResponse = Schema.Struct({
  daysUntilNextRotation: Schema.optional(Schema.Number),
  keyRotationIntervalDays: Schema.optional(Schema.Number),
  lastKeyRotationAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    daysUntilNextRotation: "days_until_next_rotation",
    keyRotationIntervalDays: "key_rotation_interval_days",
    lastKeyRotationAt: "last_key_rotation_at",
  }),
) as unknown as Schema.Schema<RotateAccessKeyResponse>;

export type RotateAccessKeyError = CommonErrors;

export const rotateAccessKey: API.OperationMethod<
  RotateAccessKeyRequest,
  RotateAccessKeyResponse,
  RotateAccessKeyError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: RotateAccessKeyRequest,
  output: RotateAccessKeyResponse,
  errors: [],
}));

// =============================================================================
// AccessLogAccessRequest
// =============================================================================

export interface ListAccessLogAccessRequestsRequest {
  /** Path param: Identifier. */
  accountId: string;
  /** Query param: The chronological sorting order for the logs. */
  direction?: "desc" | "asc";
  /** Query param: Filter by user email. Defaults to substring matching. To force exact matching, set `email_exact=true`. Example (default): `email=@example.com` returns all events with that domain. Example */
  email?: string;
  /** Query param: When true, `email` is matched exactly instead of substring matching. */
  emailExact?: boolean;
  /** Query param: The maximum number of log entries to retrieve. */
  limit?: number;
  /** Query param: Page number of results. */
  page?: number;
  /** Query param: Number of results per page. */
  perPage?: number;
  /** Query param: The earliest event timestamp to query. */
  since?: string;
  /** Query param: The latest event timestamp to query. */
  until?: string;
  /** Query param: Filter by user UUID. */
  userId?: string;
}

export const ListAccessLogAccessRequestsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  direction: Schema.optional(Schema.Literals(["desc", "asc"])).pipe(
    T.HttpQuery("direction"),
  ),
  email: Schema.optional(Schema.String).pipe(T.HttpQuery("email")),
  emailExact: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("email_exact")),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  page: Schema.optional(Schema.Number).pipe(T.HttpQuery("page")),
  perPage: Schema.optional(Schema.Number).pipe(T.HttpQuery("per_page")),
  since: Schema.optional(Schema.String).pipe(T.HttpQuery("since")),
  until: Schema.optional(Schema.String).pipe(T.HttpQuery("until")),
  userId: Schema.optional(Schema.String).pipe(T.HttpQuery("user_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/logs/access_requests",
  }),
) as unknown as Schema.Schema<ListAccessLogAccessRequestsRequest>;

export type ListAccessLogAccessRequestsResponse = unknown[];

export const ListAccessLogAccessRequestsResponse = Schema.Array(
  Schema.Unknown,
) as unknown as Schema.Schema<ListAccessLogAccessRequestsResponse>;

export type ListAccessLogAccessRequestsError = CommonErrors;

export const listAccessLogAccessRequests: API.OperationMethod<
  ListAccessLogAccessRequestsRequest,
  ListAccessLogAccessRequestsResponse,
  ListAccessLogAccessRequestsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessLogAccessRequestsRequest,
  output: ListAccessLogAccessRequestsResponse,
  errors: [],
}));

// =============================================================================
// AccessLogScimUpdate
// =============================================================================

export interface ListAccessLogScimUpdatesRequest {
  /** Path param: Identifier. */
  accountId: string;
  /** Query param: The unique Id of the IdP that has SCIM enabled. */
  idpId: string[];
  /** Query param: The unique Cloudflare-generated Id of the SCIM resource. */
  cfResourceId?: string;
  /** Query param: The chronological order used to sort the logs. */
  direction?: "desc" | "asc";
  /** Query param: The IdP-generated Id of the SCIM resource. */
  idpResourceId?: string;
  /** Query param: The maximum number of update logs to retrieve. */
  limit?: number;
  /** Query param: The request method of the SCIM request. */
  requestMethod?: ("DELETE" | "PATCH" | "POST" | "PUT")[];
  /** Query param: The display name of the SCIM Group resource. */
  resourceGroupName?: string;
  /** Query param: The resource type of the SCIM request. */
  resourceType?: ("USER" | "GROUP")[];
  /** Query param: The email address of the SCIM User resource. */
  resourceUserEmail?: string;
  /** Query param: the timestamp of the earliest update log. */
  since?: string;
  /** Query param: The status of the SCIM request. */
  status?: ("FAILURE" | "SUCCESS")[];
  /** Query param: the timestamp of the most-recent update log. */
  until?: string;
}

export const ListAccessLogScimUpdatesRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  idpId: Schema.Array(Schema.String).pipe(T.HttpQuery("idp_id")),
  cfResourceId: Schema.optional(Schema.String).pipe(
    T.HttpQuery("cf_resource_id"),
  ),
  direction: Schema.optional(Schema.Literals(["desc", "asc"])).pipe(
    T.HttpQuery("direction"),
  ),
  idpResourceId: Schema.optional(Schema.String).pipe(
    T.HttpQuery("idp_resource_id"),
  ),
  limit: Schema.optional(Schema.Number).pipe(T.HttpQuery("limit")),
  requestMethod: Schema.optional(
    Schema.Array(Schema.Literals(["DELETE", "PATCH", "POST", "PUT"])),
  ).pipe(T.HttpQuery("request_method")),
  resourceGroupName: Schema.optional(Schema.String).pipe(
    T.HttpQuery("resource_group_name"),
  ),
  resourceType: Schema.optional(
    Schema.Array(Schema.Literals(["USER", "GROUP"])),
  ).pipe(T.HttpQuery("resource_type")),
  resourceUserEmail: Schema.optional(Schema.String).pipe(
    T.HttpQuery("resource_user_email"),
  ),
  since: Schema.optional(Schema.String).pipe(T.HttpQuery("since")),
  status: Schema.optional(
    Schema.Array(Schema.Literals(["FAILURE", "SUCCESS"])),
  ).pipe(T.HttpQuery("status")),
  until: Schema.optional(Schema.String).pipe(T.HttpQuery("until")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/logs/scim/updates",
  }),
) as unknown as Schema.Schema<ListAccessLogScimUpdatesRequest>;

export type ListAccessLogScimUpdatesResponse = {
  cfResourceId?: string;
  errorDescription?: string;
  idpId?: string;
  idpResourceId?: string;
  loggedAt?: string;
  requestBody?: string;
  requestMethod?: string;
  resourceGroupName?: string;
  resourceType?: string;
  resourceUserEmail?: string;
  status?: string;
}[];

export const ListAccessLogScimUpdatesResponse = Schema.Array(
  Schema.Struct({
    cfResourceId: Schema.optional(Schema.String),
    errorDescription: Schema.optional(Schema.String),
    idpId: Schema.optional(Schema.String),
    idpResourceId: Schema.optional(Schema.String),
    loggedAt: Schema.optional(Schema.String),
    requestBody: Schema.optional(Schema.String),
    requestMethod: Schema.optional(Schema.String),
    resourceGroupName: Schema.optional(Schema.String),
    resourceType: Schema.optional(Schema.String),
    resourceUserEmail: Schema.optional(Schema.String),
    status: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      cfResourceId: "cf_resource_id",
      errorDescription: "error_description",
      idpId: "idp_id",
      idpResourceId: "idp_resource_id",
      loggedAt: "logged_at",
      requestBody: "request_body",
      requestMethod: "request_method",
      resourceGroupName: "resource_group_name",
      resourceType: "resource_type",
      resourceUserEmail: "resource_user_email",
      status: "status",
    }),
  ),
) as unknown as Schema.Schema<ListAccessLogScimUpdatesResponse>;

export type ListAccessLogScimUpdatesError = CommonErrors;

export const listAccessLogScimUpdates: API.OperationMethod<
  ListAccessLogScimUpdatesRequest,
  ListAccessLogScimUpdatesResponse,
  ListAccessLogScimUpdatesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessLogScimUpdatesRequest,
  output: ListAccessLogScimUpdatesResponse,
  errors: [],
}));

// =============================================================================
// AccessPolicy
// =============================================================================

export interface GetAccessPolicyRequest {
  policyId: string;
  /** Identifier. */
  accountId: string;
}

export const GetAccessPolicyRequest = Schema.Struct({
  policyId: Schema.String.pipe(T.HttpPath("policyId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/policies/{policyId}",
  }),
) as unknown as Schema.Schema<GetAccessPolicyRequest>;

export interface GetAccessPolicyResponse {
  /** The UUID of the policy */
  id?: string;
  /** Number of access applications currently using this policy. */
  appCount?: number;
  /** Administrators who can approve a temporary authentication request. */
  approvalGroups?: {
    approvalsNeeded: number;
    emailAddresses?: unknown[];
    emailListUuid?: string;
  }[];
  /** Requires the user to request access from an administrator at the start of each session. */
  approvalRequired?: boolean;
  createdAt?: string;
  /** The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action. */
  decision?: "allow" | "bypass" | "deny" | "non_identity";
  /** Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules. */
  exclude?: unknown[];
  /** Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules. */
  include?: unknown[];
  /** Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature. */
  isolationRequired?: boolean;
  /** The name of the Access policy. */
  name?: string;
  /** A custom message that will appear on the purpose justification screen. */
  purposeJustificationPrompt?: string;
  /** Require users to enter a justification when they log in to the application. */
  purposeJustificationRequired?: boolean;
  /** Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules. */
  require?: unknown[];
  reusable?: true;
  /** The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. */
  sessionDuration?: string;
  updatedAt?: string;
}

export const GetAccessPolicyResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  appCount: Schema.optional(Schema.Number),
  approvalGroups: Schema.optional(
    Schema.Array(
      Schema.Struct({
        approvalsNeeded: Schema.Number,
        emailAddresses: Schema.optional(Schema.Array(Schema.Unknown)),
        emailListUuid: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          approvalsNeeded: "approvals_needed",
          emailAddresses: "email_addresses",
          emailListUuid: "email_list_uuid",
        }),
      ),
    ),
  ),
  approvalRequired: Schema.optional(Schema.Boolean),
  createdAt: Schema.optional(Schema.String),
  decision: Schema.optional(
    Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
  ),
  exclude: Schema.optional(Schema.Array(Schema.Unknown)),
  include: Schema.optional(Schema.Array(Schema.Unknown)),
  isolationRequired: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
  purposeJustificationPrompt: Schema.optional(Schema.String),
  purposeJustificationRequired: Schema.optional(Schema.Boolean),
  require: Schema.optional(Schema.Array(Schema.Unknown)),
  reusable: Schema.optional(Schema.Literal(true)),
  sessionDuration: Schema.optional(Schema.String),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    appCount: "app_count",
    approvalGroups: "approval_groups",
    approvalRequired: "approval_required",
    createdAt: "created_at",
    decision: "decision",
    exclude: "exclude",
    include: "include",
    isolationRequired: "isolation_required",
    name: "name",
    purposeJustificationPrompt: "purpose_justification_prompt",
    purposeJustificationRequired: "purpose_justification_required",
    require: "require",
    reusable: "reusable",
    sessionDuration: "session_duration",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<GetAccessPolicyResponse>;

export type GetAccessPolicyError = CommonErrors;

export const getAccessPolicy: API.OperationMethod<
  GetAccessPolicyRequest,
  GetAccessPolicyResponse,
  GetAccessPolicyError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccessPolicyRequest,
  output: GetAccessPolicyResponse,
  errors: [],
}));

export interface ListAccessPoliciesRequest {
  /** Path param: Identifier. */
  accountId: string;
}

export const ListAccessPoliciesRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/access/policies" }),
) as unknown as Schema.Schema<ListAccessPoliciesRequest>;

export type ListAccessPoliciesResponse = {
  id?: string;
  appCount?: number;
  approvalGroups?: {
    approvalsNeeded: number;
    emailAddresses?: unknown[];
    emailListUuid?: string;
  }[];
  approvalRequired?: boolean;
  createdAt?: string;
  decision?: "allow" | "bypass" | "deny" | "non_identity";
  exclude?: unknown[];
  include?: unknown[];
  isolationRequired?: boolean;
  name?: string;
  purposeJustificationPrompt?: string;
  purposeJustificationRequired?: boolean;
  require?: unknown[];
  reusable?: true;
  sessionDuration?: string;
  updatedAt?: string;
}[];

export const ListAccessPoliciesResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    appCount: Schema.optional(Schema.Number),
    approvalGroups: Schema.optional(
      Schema.Array(
        Schema.Struct({
          approvalsNeeded: Schema.Number,
          emailAddresses: Schema.optional(Schema.Array(Schema.Unknown)),
          emailListUuid: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            approvalsNeeded: "approvals_needed",
            emailAddresses: "email_addresses",
            emailListUuid: "email_list_uuid",
          }),
        ),
      ),
    ),
    approvalRequired: Schema.optional(Schema.Boolean),
    createdAt: Schema.optional(Schema.String),
    decision: Schema.optional(
      Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
    ),
    exclude: Schema.optional(Schema.Array(Schema.Unknown)),
    include: Schema.optional(Schema.Array(Schema.Unknown)),
    isolationRequired: Schema.optional(Schema.Boolean),
    name: Schema.optional(Schema.String),
    purposeJustificationPrompt: Schema.optional(Schema.String),
    purposeJustificationRequired: Schema.optional(Schema.Boolean),
    require: Schema.optional(Schema.Array(Schema.Unknown)),
    reusable: Schema.optional(Schema.Literal(true)),
    sessionDuration: Schema.optional(Schema.String),
    updatedAt: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      appCount: "app_count",
      approvalGroups: "approval_groups",
      approvalRequired: "approval_required",
      createdAt: "created_at",
      decision: "decision",
      exclude: "exclude",
      include: "include",
      isolationRequired: "isolation_required",
      name: "name",
      purposeJustificationPrompt: "purpose_justification_prompt",
      purposeJustificationRequired: "purpose_justification_required",
      require: "require",
      reusable: "reusable",
      sessionDuration: "session_duration",
      updatedAt: "updated_at",
    }),
  ),
) as unknown as Schema.Schema<ListAccessPoliciesResponse>;

export type ListAccessPoliciesError = CommonErrors;

export const listAccessPolicies: API.OperationMethod<
  ListAccessPoliciesRequest,
  ListAccessPoliciesResponse,
  ListAccessPoliciesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessPoliciesRequest,
  output: ListAccessPoliciesResponse,
  errors: [],
}));

export interface CreateAccessPolicyRequest {
  /** Path param: Identifier. */
  accountId: string;
  /** Body param: The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action. */
  decision: "allow" | "bypass" | "deny" | "non_identity";
  /** Body param: Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules. */
  include: unknown[];
  /** Body param: The name of the Access policy. */
  name: string;
  /** Body param: Administrators who can approve a temporary authentication request. */
  approvalGroups?: {
    approvalsNeeded: number;
    emailAddresses?: string[];
    emailListUuid?: string;
  }[];
  /** Body param: Requires the user to request access from an administrator at the start of each session. */
  approvalRequired?: boolean;
  /** Body param: Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules. */
  exclude?: unknown[];
  /** Body param: Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature. */
  isolationRequired?: boolean;
  /** Body param: A custom message that will appear on the purpose justification screen. */
  purposeJustificationPrompt?: string;
  /** Body param: Require users to enter a justification when they log in to the application. */
  purposeJustificationRequired?: boolean;
  /** Body param: Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules. */
  require?: unknown[];
  /** Body param: The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. */
  sessionDuration?: string;
}

export const CreateAccessPolicyRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  decision: Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
  include: Schema.Array(Schema.Unknown),
  name: Schema.String,
  approvalGroups: Schema.optional(
    Schema.Array(
      Schema.Struct({
        approvalsNeeded: Schema.Number,
        emailAddresses: Schema.optional(Schema.Array(Schema.String)),
        emailListUuid: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          approvalsNeeded: "approvals_needed",
          emailAddresses: "email_addresses",
          emailListUuid: "email_list_uuid",
        }),
      ),
    ),
  ),
  approvalRequired: Schema.optional(Schema.Boolean),
  exclude: Schema.optional(Schema.Array(Schema.Unknown)),
  isolationRequired: Schema.optional(Schema.Boolean),
  purposeJustificationPrompt: Schema.optional(Schema.String),
  purposeJustificationRequired: Schema.optional(Schema.Boolean),
  require: Schema.optional(Schema.Array(Schema.Unknown)),
  sessionDuration: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    decision: "decision",
    include: "include",
    name: "name",
    approvalGroups: "approval_groups",
    approvalRequired: "approval_required",
    exclude: "exclude",
    isolationRequired: "isolation_required",
    purposeJustificationPrompt: "purpose_justification_prompt",
    purposeJustificationRequired: "purpose_justification_required",
    require: "require",
    sessionDuration: "session_duration",
  }),
  T.Http({ method: "POST", path: "/accounts/{account_id}/access/policies" }),
) as unknown as Schema.Schema<CreateAccessPolicyRequest>;

export interface CreateAccessPolicyResponse {
  /** The UUID of the policy */
  id?: string;
  /** Number of access applications currently using this policy. */
  appCount?: number;
  /** Administrators who can approve a temporary authentication request. */
  approvalGroups?: {
    approvalsNeeded: number;
    emailAddresses?: unknown[];
    emailListUuid?: string;
  }[];
  /** Requires the user to request access from an administrator at the start of each session. */
  approvalRequired?: boolean;
  createdAt?: string;
  /** The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action. */
  decision?: "allow" | "bypass" | "deny" | "non_identity";
  /** Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules. */
  exclude?: unknown[];
  /** Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules. */
  include?: unknown[];
  /** Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature. */
  isolationRequired?: boolean;
  /** The name of the Access policy. */
  name?: string;
  /** A custom message that will appear on the purpose justification screen. */
  purposeJustificationPrompt?: string;
  /** Require users to enter a justification when they log in to the application. */
  purposeJustificationRequired?: boolean;
  /** Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules. */
  require?: unknown[];
  reusable?: true;
  /** The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. */
  sessionDuration?: string;
  updatedAt?: string;
}

export const CreateAccessPolicyResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  appCount: Schema.optional(Schema.Number),
  approvalGroups: Schema.optional(
    Schema.Array(
      Schema.Struct({
        approvalsNeeded: Schema.Number,
        emailAddresses: Schema.optional(Schema.Array(Schema.Unknown)),
        emailListUuid: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          approvalsNeeded: "approvals_needed",
          emailAddresses: "email_addresses",
          emailListUuid: "email_list_uuid",
        }),
      ),
    ),
  ),
  approvalRequired: Schema.optional(Schema.Boolean),
  createdAt: Schema.optional(Schema.String),
  decision: Schema.optional(
    Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
  ),
  exclude: Schema.optional(Schema.Array(Schema.Unknown)),
  include: Schema.optional(Schema.Array(Schema.Unknown)),
  isolationRequired: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
  purposeJustificationPrompt: Schema.optional(Schema.String),
  purposeJustificationRequired: Schema.optional(Schema.Boolean),
  require: Schema.optional(Schema.Array(Schema.Unknown)),
  reusable: Schema.optional(Schema.Literal(true)),
  sessionDuration: Schema.optional(Schema.String),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    appCount: "app_count",
    approvalGroups: "approval_groups",
    approvalRequired: "approval_required",
    createdAt: "created_at",
    decision: "decision",
    exclude: "exclude",
    include: "include",
    isolationRequired: "isolation_required",
    name: "name",
    purposeJustificationPrompt: "purpose_justification_prompt",
    purposeJustificationRequired: "purpose_justification_required",
    require: "require",
    reusable: "reusable",
    sessionDuration: "session_duration",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<CreateAccessPolicyResponse>;

export type CreateAccessPolicyError = CommonErrors;

export const createAccessPolicy: API.OperationMethod<
  CreateAccessPolicyRequest,
  CreateAccessPolicyResponse,
  CreateAccessPolicyError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAccessPolicyRequest,
  output: CreateAccessPolicyResponse,
  errors: [],
}));

export interface UpdateAccessPolicyRequest {
  policyId: string;
  /** Path param: Identifier. */
  accountId: string;
  /** Body param: The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action. */
  decision: "allow" | "bypass" | "deny" | "non_identity";
  /** Body param: Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules. */
  include: unknown[];
  /** Body param: The name of the Access policy. */
  name: string;
  /** Body param: Administrators who can approve a temporary authentication request. */
  approvalGroups?: {
    approvalsNeeded: number;
    emailAddresses?: string[];
    emailListUuid?: string;
  }[];
  /** Body param: Requires the user to request access from an administrator at the start of each session. */
  approvalRequired?: boolean;
  /** Body param: Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules. */
  exclude?: unknown[];
  /** Body param: Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature. */
  isolationRequired?: boolean;
  /** Body param: A custom message that will appear on the purpose justification screen. */
  purposeJustificationPrompt?: string;
  /** Body param: Require users to enter a justification when they log in to the application. */
  purposeJustificationRequired?: boolean;
  /** Body param: Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules. */
  require?: unknown[];
  /** Body param: The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. */
  sessionDuration?: string;
}

export const UpdateAccessPolicyRequest = Schema.Struct({
  policyId: Schema.String.pipe(T.HttpPath("policyId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  decision: Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
  include: Schema.Array(Schema.Unknown),
  name: Schema.String,
  approvalGroups: Schema.optional(
    Schema.Array(
      Schema.Struct({
        approvalsNeeded: Schema.Number,
        emailAddresses: Schema.optional(Schema.Array(Schema.String)),
        emailListUuid: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          approvalsNeeded: "approvals_needed",
          emailAddresses: "email_addresses",
          emailListUuid: "email_list_uuid",
        }),
      ),
    ),
  ),
  approvalRequired: Schema.optional(Schema.Boolean),
  exclude: Schema.optional(Schema.Array(Schema.Unknown)),
  isolationRequired: Schema.optional(Schema.Boolean),
  purposeJustificationPrompt: Schema.optional(Schema.String),
  purposeJustificationRequired: Schema.optional(Schema.Boolean),
  require: Schema.optional(Schema.Array(Schema.Unknown)),
  sessionDuration: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    decision: "decision",
    include: "include",
    name: "name",
    approvalGroups: "approval_groups",
    approvalRequired: "approval_required",
    exclude: "exclude",
    isolationRequired: "isolation_required",
    purposeJustificationPrompt: "purpose_justification_prompt",
    purposeJustificationRequired: "purpose_justification_required",
    require: "require",
    sessionDuration: "session_duration",
  }),
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/access/policies/{policyId}",
  }),
) as unknown as Schema.Schema<UpdateAccessPolicyRequest>;

export interface UpdateAccessPolicyResponse {
  /** The UUID of the policy */
  id?: string;
  /** Number of access applications currently using this policy. */
  appCount?: number;
  /** Administrators who can approve a temporary authentication request. */
  approvalGroups?: {
    approvalsNeeded: number;
    emailAddresses?: unknown[];
    emailListUuid?: string;
  }[];
  /** Requires the user to request access from an administrator at the start of each session. */
  approvalRequired?: boolean;
  createdAt?: string;
  /** The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action. */
  decision?: "allow" | "bypass" | "deny" | "non_identity";
  /** Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules. */
  exclude?: unknown[];
  /** Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules. */
  include?: unknown[];
  /** Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature. */
  isolationRequired?: boolean;
  /** The name of the Access policy. */
  name?: string;
  /** A custom message that will appear on the purpose justification screen. */
  purposeJustificationPrompt?: string;
  /** Require users to enter a justification when they log in to the application. */
  purposeJustificationRequired?: boolean;
  /** Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules. */
  require?: unknown[];
  reusable?: true;
  /** The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. */
  sessionDuration?: string;
  updatedAt?: string;
}

export const UpdateAccessPolicyResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  appCount: Schema.optional(Schema.Number),
  approvalGroups: Schema.optional(
    Schema.Array(
      Schema.Struct({
        approvalsNeeded: Schema.Number,
        emailAddresses: Schema.optional(Schema.Array(Schema.Unknown)),
        emailListUuid: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          approvalsNeeded: "approvals_needed",
          emailAddresses: "email_addresses",
          emailListUuid: "email_list_uuid",
        }),
      ),
    ),
  ),
  approvalRequired: Schema.optional(Schema.Boolean),
  createdAt: Schema.optional(Schema.String),
  decision: Schema.optional(
    Schema.Literals(["allow", "bypass", "deny", "non_identity"]),
  ),
  exclude: Schema.optional(Schema.Array(Schema.Unknown)),
  include: Schema.optional(Schema.Array(Schema.Unknown)),
  isolationRequired: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
  purposeJustificationPrompt: Schema.optional(Schema.String),
  purposeJustificationRequired: Schema.optional(Schema.Boolean),
  require: Schema.optional(Schema.Array(Schema.Unknown)),
  reusable: Schema.optional(Schema.Literal(true)),
  sessionDuration: Schema.optional(Schema.String),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    appCount: "app_count",
    approvalGroups: "approval_groups",
    approvalRequired: "approval_required",
    createdAt: "created_at",
    decision: "decision",
    exclude: "exclude",
    include: "include",
    isolationRequired: "isolation_required",
    name: "name",
    purposeJustificationPrompt: "purpose_justification_prompt",
    purposeJustificationRequired: "purpose_justification_required",
    require: "require",
    reusable: "reusable",
    sessionDuration: "session_duration",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<UpdateAccessPolicyResponse>;

export type UpdateAccessPolicyError = CommonErrors;

export const updateAccessPolicy: API.OperationMethod<
  UpdateAccessPolicyRequest,
  UpdateAccessPolicyResponse,
  UpdateAccessPolicyError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAccessPolicyRequest,
  output: UpdateAccessPolicyResponse,
  errors: [],
}));

export interface DeleteAccessPolicyRequest {
  policyId: string;
  /** Identifier. */
  accountId: string;
}

export const DeleteAccessPolicyRequest = Schema.Struct({
  policyId: Schema.String.pipe(T.HttpPath("policyId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/access/policies/{policyId}",
  }),
) as unknown as Schema.Schema<DeleteAccessPolicyRequest>;

export interface DeleteAccessPolicyResponse {
  /** The UUID of the policy */
  id?: string;
}

export const DeleteAccessPolicyResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
}) as unknown as Schema.Schema<DeleteAccessPolicyResponse>;

export type DeleteAccessPolicyError = CommonErrors;

export const deleteAccessPolicy: API.OperationMethod<
  DeleteAccessPolicyRequest,
  DeleteAccessPolicyResponse,
  DeleteAccessPolicyError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccessPolicyRequest,
  output: DeleteAccessPolicyResponse,
  errors: [],
}));

// =============================================================================
// AccessServiceToken
// =============================================================================

export interface GetAccessServiceTokenRequest {
  serviceTokenId: string;
}

export const GetAccessServiceTokenRequest = Schema.Struct({
  serviceTokenId: Schema.String.pipe(T.HttpPath("serviceTokenId")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/{accountOrZone}/{accountOrZoneId}/access/service_tokens/{serviceTokenId}",
  }),
) as unknown as Schema.Schema<GetAccessServiceTokenRequest>;

export interface GetAccessServiceTokenResponse {
  /** The ID of the service token. */
  id?: string;
  /** The Client ID for the service token. Access will check for this value in the `CF-Access-Client-ID` request header. */
  clientId?: string;
  /** The duration for how long the service token will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. The default is 1 year in hours (8760h). */
  duration?: string;
  expiresAt?: string;
  /** The name of the service token. */
  name?: string;
}

export const GetAccessServiceTokenResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  clientId: Schema.optional(Schema.String),
  duration: Schema.optional(Schema.String),
  expiresAt: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    clientId: "client_id",
    duration: "duration",
    expiresAt: "expires_at",
    name: "name",
  }),
) as unknown as Schema.Schema<GetAccessServiceTokenResponse>;

export type GetAccessServiceTokenError = CommonErrors;

export const getAccessServiceToken: API.OperationMethod<
  GetAccessServiceTokenRequest,
  GetAccessServiceTokenResponse,
  GetAccessServiceTokenError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccessServiceTokenRequest,
  output: GetAccessServiceTokenResponse,
  errors: [],
}));

export interface ListAccessServiceTokensRequest {}

export const ListAccessServiceTokensRequest = Schema.Struct({}).pipe(
  T.Http({
    method: "GET",
    path: "/{accountOrZone}/{accountOrZoneId}/access/service_tokens",
  }),
) as unknown as Schema.Schema<ListAccessServiceTokensRequest>;

export type ListAccessServiceTokensResponse = {
  id?: string;
  clientId?: string;
  duration?: string;
  expiresAt?: string;
  name?: string;
}[];

export const ListAccessServiceTokensResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    clientId: Schema.optional(Schema.String),
    duration: Schema.optional(Schema.String),
    expiresAt: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      clientId: "client_id",
      duration: "duration",
      expiresAt: "expires_at",
      name: "name",
    }),
  ),
) as unknown as Schema.Schema<ListAccessServiceTokensResponse>;

export type ListAccessServiceTokensError = CommonErrors;

export const listAccessServiceTokens: API.OperationMethod<
  ListAccessServiceTokensRequest,
  ListAccessServiceTokensResponse,
  ListAccessServiceTokensError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessServiceTokensRequest,
  output: ListAccessServiceTokensResponse,
  errors: [],
}));

export interface CreateAccessServiceTokenRequest {
  /** Path param: The Account ID to use for this endpoint. Mutually exclusive with the Zone ID. */
  accountId?: string;
  /** Path param: The Zone ID to use for this endpoint. Mutually exclusive with the Account ID. */
  zoneId?: string;
  /** Body param: The name of the service token. */
  name: string;
  /** Body param: A version number identifying the current `client_secret` associated with the service token. Incrementing it triggers a rotation; the previous secret will still be accepted until the time i */
  clientSecretVersion?: number;
  /** Body param: The duration for how long the service token will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. The default is 1 year in hours (8760 */
  duration?: string;
  /** Body param: The expiration of the previous `client_secret`. This can be modified at any point after a rotation. For example, you may extend it further into the future if you need more time to update s */
  previousClientSecretExpiresAt?: string;
}

export const CreateAccessServiceTokenRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  name: Schema.String,
  clientSecretVersion: Schema.optional(Schema.Number),
  duration: Schema.optional(Schema.String),
  previousClientSecretExpiresAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    name: "name",
    clientSecretVersion: "client_secret_version",
    duration: "duration",
    previousClientSecretExpiresAt: "previous_client_secret_expires_at",
  }),
  T.Http({
    method: "POST",
    path: "/{accountOrZone}/{accountOrZoneId}/access/service_tokens",
  }),
) as unknown as Schema.Schema<CreateAccessServiceTokenRequest>;

export interface CreateAccessServiceTokenResponse {
  /** The ID of the service token. */
  id?: string;
  /** The Client ID for the service token. Access will check for this value in the `CF-Access-Client-ID` request header. */
  clientId?: string;
  /** The Client Secret for the service token. Access will check for this value in the `CF-Access-Client-Secret` request header. */
  clientSecret?: string;
  /** The duration for how long the service token will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. The default is 1 year in hours (8760h). */
  duration?: string;
  /** The name of the service token. */
  name?: string;
}

export const CreateAccessServiceTokenResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  clientId: Schema.optional(Schema.String),
  clientSecret: Schema.optional(Schema.String),
  duration: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    clientId: "client_id",
    clientSecret: "client_secret",
    duration: "duration",
    name: "name",
  }),
) as unknown as Schema.Schema<CreateAccessServiceTokenResponse>;

export type CreateAccessServiceTokenError = CommonErrors;

export const createAccessServiceToken: API.OperationMethod<
  CreateAccessServiceTokenRequest,
  CreateAccessServiceTokenResponse,
  CreateAccessServiceTokenError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAccessServiceTokenRequest,
  output: CreateAccessServiceTokenResponse,
  errors: [],
}));

export interface UpdateAccessServiceTokenRequest {
  serviceTokenId: string;
  /** Path param: The Account ID to use for this endpoint. Mutually exclusive with the Zone ID. */
  accountId?: string;
  /** Path param: The Zone ID to use for this endpoint. Mutually exclusive with the Account ID. */
  zoneId?: string;
  /** Body param: A version number identifying the current `client_secret` associated with the service token. Incrementing it triggers a rotation; the previous secret will still be accepted until the time i */
  clientSecretVersion?: number;
  /** Body param: The duration for how long the service token will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. The default is 1 year in hours (8760 */
  duration?: string;
  /** Body param: The name of the service token. */
  name?: string;
  /** Body param: The expiration of the previous `client_secret`. This can be modified at any point after a rotation. For example, you may extend it further into the future if you need more time to update s */
  previousClientSecretExpiresAt?: string;
}

export const UpdateAccessServiceTokenRequest = Schema.Struct({
  serviceTokenId: Schema.String.pipe(T.HttpPath("serviceTokenId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  clientSecretVersion: Schema.optional(Schema.Number),
  duration: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  previousClientSecretExpiresAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    clientSecretVersion: "client_secret_version",
    duration: "duration",
    name: "name",
    previousClientSecretExpiresAt: "previous_client_secret_expires_at",
  }),
  T.Http({
    method: "PUT",
    path: "/{accountOrZone}/{accountOrZoneId}/access/service_tokens/{serviceTokenId}",
  }),
) as unknown as Schema.Schema<UpdateAccessServiceTokenRequest>;

export interface UpdateAccessServiceTokenResponse {
  /** The ID of the service token. */
  id?: string;
  /** The Client ID for the service token. Access will check for this value in the `CF-Access-Client-ID` request header. */
  clientId?: string;
  /** The duration for how long the service token will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. The default is 1 year in hours (8760h). */
  duration?: string;
  expiresAt?: string;
  /** The name of the service token. */
  name?: string;
}

export const UpdateAccessServiceTokenResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  clientId: Schema.optional(Schema.String),
  duration: Schema.optional(Schema.String),
  expiresAt: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    clientId: "client_id",
    duration: "duration",
    expiresAt: "expires_at",
    name: "name",
  }),
) as unknown as Schema.Schema<UpdateAccessServiceTokenResponse>;

export type UpdateAccessServiceTokenError = CommonErrors;

export const updateAccessServiceToken: API.OperationMethod<
  UpdateAccessServiceTokenRequest,
  UpdateAccessServiceTokenResponse,
  UpdateAccessServiceTokenError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAccessServiceTokenRequest,
  output: UpdateAccessServiceTokenResponse,
  errors: [],
}));

export interface DeleteAccessServiceTokenRequest {
  serviceTokenId: string;
}

export const DeleteAccessServiceTokenRequest = Schema.Struct({
  serviceTokenId: Schema.String.pipe(T.HttpPath("serviceTokenId")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/{accountOrZone}/{accountOrZoneId}/access/service_tokens/{serviceTokenId}",
  }),
) as unknown as Schema.Schema<DeleteAccessServiceTokenRequest>;

export interface DeleteAccessServiceTokenResponse {
  /** The ID of the service token. */
  id?: string;
  /** The Client ID for the service token. Access will check for this value in the `CF-Access-Client-ID` request header. */
  clientId?: string;
  /** The duration for how long the service token will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. The default is 1 year in hours (8760h). */
  duration?: string;
  expiresAt?: string;
  /** The name of the service token. */
  name?: string;
}

export const DeleteAccessServiceTokenResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  clientId: Schema.optional(Schema.String),
  duration: Schema.optional(Schema.String),
  expiresAt: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    clientId: "client_id",
    duration: "duration",
    expiresAt: "expires_at",
    name: "name",
  }),
) as unknown as Schema.Schema<DeleteAccessServiceTokenResponse>;

export type DeleteAccessServiceTokenError = CommonErrors;

export const deleteAccessServiceToken: API.OperationMethod<
  DeleteAccessServiceTokenRequest,
  DeleteAccessServiceTokenResponse,
  DeleteAccessServiceTokenError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccessServiceTokenRequest,
  output: DeleteAccessServiceTokenResponse,
  errors: [],
}));

export interface RefreshAccessServiceTokenRequest {
  serviceTokenId: string;
  /** Identifier. */
  accountId: string;
}

export const RefreshAccessServiceTokenRequest = Schema.Struct({
  serviceTokenId: Schema.String.pipe(T.HttpPath("serviceTokenId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/access/service_tokens/{serviceTokenId}/refresh",
  }),
) as unknown as Schema.Schema<RefreshAccessServiceTokenRequest>;

export interface RefreshAccessServiceTokenResponse {
  /** The ID of the service token. */
  id?: string;
  /** The Client ID for the service token. Access will check for this value in the `CF-Access-Client-ID` request header. */
  clientId?: string;
  /** The duration for how long the service token will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. The default is 1 year in hours (8760h). */
  duration?: string;
  expiresAt?: string;
  /** The name of the service token. */
  name?: string;
}

export const RefreshAccessServiceTokenResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  clientId: Schema.optional(Schema.String),
  duration: Schema.optional(Schema.String),
  expiresAt: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    clientId: "client_id",
    duration: "duration",
    expiresAt: "expires_at",
    name: "name",
  }),
) as unknown as Schema.Schema<RefreshAccessServiceTokenResponse>;

export type RefreshAccessServiceTokenError = CommonErrors;

export const refreshAccessServiceToken: API.OperationMethod<
  RefreshAccessServiceTokenRequest,
  RefreshAccessServiceTokenResponse,
  RefreshAccessServiceTokenError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: RefreshAccessServiceTokenRequest,
  output: RefreshAccessServiceTokenResponse,
  errors: [],
}));

export interface RotateAccessServiceTokenRequest {
  serviceTokenId: string;
  /** Path param: Identifier. */
  accountId: string;
  /** Body param: The expiration of the previous `client_secret`. If not provided, it defaults to the current timestamp in order to immediately expire the previous secret. */
  previousClientSecretExpiresAt?: string;
}

export const RotateAccessServiceTokenRequest = Schema.Struct({
  serviceTokenId: Schema.String.pipe(T.HttpPath("serviceTokenId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  previousClientSecretExpiresAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    previousClientSecretExpiresAt: "previous_client_secret_expires_at",
  }),
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/access/service_tokens/{serviceTokenId}/rotate",
  }),
) as unknown as Schema.Schema<RotateAccessServiceTokenRequest>;

export interface RotateAccessServiceTokenResponse {
  /** The ID of the service token. */
  id?: string;
  /** The Client ID for the service token. Access will check for this value in the `CF-Access-Client-ID` request header. */
  clientId?: string;
  /** The Client Secret for the service token. Access will check for this value in the `CF-Access-Client-Secret` request header. */
  clientSecret?: string;
  /** The duration for how long the service token will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. The default is 1 year in hours (8760h). */
  duration?: string;
  /** The name of the service token. */
  name?: string;
}

export const RotateAccessServiceTokenResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  clientId: Schema.optional(Schema.String),
  clientSecret: Schema.optional(Schema.String),
  duration: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    clientId: "client_id",
    clientSecret: "client_secret",
    duration: "duration",
    name: "name",
  }),
) as unknown as Schema.Schema<RotateAccessServiceTokenResponse>;

export type RotateAccessServiceTokenError = CommonErrors;

export const rotateAccessServiceToken: API.OperationMethod<
  RotateAccessServiceTokenRequest,
  RotateAccessServiceTokenResponse,
  RotateAccessServiceTokenError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: RotateAccessServiceTokenRequest,
  output: RotateAccessServiceTokenResponse,
  errors: [],
}));

// =============================================================================
// AccessTag
// =============================================================================

export interface GetAccessTagRequest {
  tagName: string;
  /** Identifier. */
  accountId: string;
}

export const GetAccessTagRequest = Schema.Struct({
  tagName: Schema.String.pipe(T.HttpPath("tagName")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/tags/{tagName}",
  }),
) as unknown as Schema.Schema<GetAccessTagRequest>;

export interface GetAccessTagResponse {
  /** The name of the tag */
  name: string;
}

export const GetAccessTagResponse = Schema.Struct({
  name: Schema.String,
}) as unknown as Schema.Schema<GetAccessTagResponse>;

export type GetAccessTagError = CommonErrors;

export const getAccessTag: API.OperationMethod<
  GetAccessTagRequest,
  GetAccessTagResponse,
  GetAccessTagError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccessTagRequest,
  output: GetAccessTagResponse,
  errors: [],
}));

export interface ListAccessTagsRequest {
  /** Path param: Identifier. */
  accountId: string;
}

export const ListAccessTagsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/access/tags" }),
) as unknown as Schema.Schema<ListAccessTagsRequest>;

export type ListAccessTagsResponse = { name: string }[];

export const ListAccessTagsResponse = Schema.Array(
  Schema.Struct({
    name: Schema.String,
  }),
) as unknown as Schema.Schema<ListAccessTagsResponse>;

export type ListAccessTagsError = CommonErrors;

export const listAccessTags: API.OperationMethod<
  ListAccessTagsRequest,
  ListAccessTagsResponse,
  ListAccessTagsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessTagsRequest,
  output: ListAccessTagsResponse,
  errors: [],
}));

export interface CreateAccessTagRequest {
  /** Path param: Identifier. */
  accountId: string;
  /** Body param: The name of the tag */
  name?: string;
}

export const CreateAccessTagRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.optional(Schema.String),
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/access/tags" }),
) as unknown as Schema.Schema<CreateAccessTagRequest>;

export interface CreateAccessTagResponse {
  /** The name of the tag */
  name: string;
}

export const CreateAccessTagResponse = Schema.Struct({
  name: Schema.String,
}) as unknown as Schema.Schema<CreateAccessTagResponse>;

export type CreateAccessTagError = CommonErrors;

export const createAccessTag: API.OperationMethod<
  CreateAccessTagRequest,
  CreateAccessTagResponse,
  CreateAccessTagError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateAccessTagRequest,
  output: CreateAccessTagResponse,
  errors: [],
}));

export interface UpdateAccessTagRequest {
  tagName: string;
  /** Path param: Identifier. */
  accountId: string;
  /** Body param: The name of the tag */
  name: string;
}

export const UpdateAccessTagRequest = Schema.Struct({
  tagName: Schema.String.pipe(T.HttpPath("tagName")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.String,
}).pipe(
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/access/tags/{tagName}",
  }),
) as unknown as Schema.Schema<UpdateAccessTagRequest>;

export interface UpdateAccessTagResponse {
  /** The name of the tag */
  name: string;
}

export const UpdateAccessTagResponse = Schema.Struct({
  name: Schema.String,
}) as unknown as Schema.Schema<UpdateAccessTagResponse>;

export type UpdateAccessTagError = CommonErrors;

export const updateAccessTag: API.OperationMethod<
  UpdateAccessTagRequest,
  UpdateAccessTagResponse,
  UpdateAccessTagError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateAccessTagRequest,
  output: UpdateAccessTagResponse,
  errors: [],
}));

export interface DeleteAccessTagRequest {
  tagName: string;
  /** Identifier. */
  accountId: string;
}

export const DeleteAccessTagRequest = Schema.Struct({
  tagName: Schema.String.pipe(T.HttpPath("tagName")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/access/tags/{tagName}",
  }),
) as unknown as Schema.Schema<DeleteAccessTagRequest>;

export interface DeleteAccessTagResponse {
  /** The name of the tag */
  name?: string;
}

export const DeleteAccessTagResponse = Schema.Struct({
  name: Schema.optional(Schema.String),
}) as unknown as Schema.Schema<DeleteAccessTagResponse>;

export type DeleteAccessTagError = CommonErrors;

export const deleteAccessTag: API.OperationMethod<
  DeleteAccessTagRequest,
  DeleteAccessTagResponse,
  DeleteAccessTagError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteAccessTagRequest,
  output: DeleteAccessTagResponse,
  errors: [],
}));

// =============================================================================
// AccessUser
// =============================================================================

export interface ListAccessUsersRequest {
  /** Path param: Identifier. */
  accountId: string;
  /** Query param: The email of the user. */
  email?: string;
  /** Query param: The name of the user. */
  name?: string;
  /** Query param: Search for users by other listed query parameters. */
  search?: string;
}

export const ListAccessUsersRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  email: Schema.optional(Schema.String).pipe(T.HttpQuery("email")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/access/users" }),
) as unknown as Schema.Schema<ListAccessUsersRequest>;

export type ListAccessUsersResponse = {
  id?: string;
  accessSeat?: boolean;
  activeDeviceCount?: number;
  createdAt?: string;
  email?: string;
  gatewaySeat?: boolean;
  lastSuccessfulLogin?: string;
  name?: string;
  seatUid?: string;
  uid?: string;
  updatedAt?: string;
}[];

export const ListAccessUsersResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    accessSeat: Schema.optional(Schema.Boolean),
    activeDeviceCount: Schema.optional(Schema.Number),
    createdAt: Schema.optional(Schema.String),
    email: Schema.optional(Schema.String),
    gatewaySeat: Schema.optional(Schema.Boolean),
    lastSuccessfulLogin: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    seatUid: Schema.optional(Schema.String),
    uid: Schema.optional(Schema.String),
    updatedAt: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      accessSeat: "access_seat",
      activeDeviceCount: "active_device_count",
      createdAt: "created_at",
      email: "email",
      gatewaySeat: "gateway_seat",
      lastSuccessfulLogin: "last_successful_login",
      name: "name",
      seatUid: "seat_uid",
      uid: "uid",
      updatedAt: "updated_at",
    }),
  ),
) as unknown as Schema.Schema<ListAccessUsersResponse>;

export type ListAccessUsersError = CommonErrors;

export const listAccessUsers: API.OperationMethod<
  ListAccessUsersRequest,
  ListAccessUsersResponse,
  ListAccessUsersError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessUsersRequest,
  output: ListAccessUsersResponse,
  errors: [],
}));

// =============================================================================
// AccessUserActiveSession
// =============================================================================

export interface GetAccessUserActiveSessionRequest {
  userId: string;
  nonce: string;
  /** Identifier. */
  accountId: string;
}

export const GetAccessUserActiveSessionRequest = Schema.Struct({
  userId: Schema.String.pipe(T.HttpPath("userId")),
  nonce: Schema.String.pipe(T.HttpPath("nonce")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/users/{userId}/active_sessions/{nonce}",
  }),
) as unknown as Schema.Schema<GetAccessUserActiveSessionRequest>;

export interface GetAccessUserActiveSessionResponse {
  accountId?: string;
  authStatus?: string;
  commonName?: string;
  deviceId?: string;
  deviceSessions?: Record<string, unknown>;
  devicePosture?: Record<string, unknown>;
  email?: string;
  geo?: unknown;
  iat?: number;
  idp?: { id?: string; type?: string };
  ip?: string;
  isGateway?: boolean;
  isWarp?: boolean;
  isActive?: boolean;
  mtlsAuth?: {
    authStatus?: string;
    certIssuerDn?: string;
    certIssuerSki?: string;
    certPresented?: boolean;
    certSerial?: string;
  };
  serviceTokenId?: string;
  serviceTokenStatus?: boolean;
  userUuid?: string;
  version?: number;
}

export const GetAccessUserActiveSessionResponse = Schema.Struct({
  accountId: Schema.optional(Schema.String),
  authStatus: Schema.optional(Schema.String),
  commonName: Schema.optional(Schema.String),
  deviceId: Schema.optional(Schema.String),
  deviceSessions: Schema.optional(Schema.Struct({})),
  devicePosture: Schema.optional(Schema.Struct({})),
  email: Schema.optional(Schema.String),
  geo: Schema.optional(Schema.Unknown),
  iat: Schema.optional(Schema.Number),
  idp: Schema.optional(
    Schema.Struct({
      id: Schema.optional(Schema.String),
      type: Schema.optional(Schema.String),
    }),
  ),
  ip: Schema.optional(Schema.String),
  isGateway: Schema.optional(Schema.Boolean),
  isWarp: Schema.optional(Schema.Boolean),
  isActive: Schema.optional(Schema.Boolean),
  mtlsAuth: Schema.optional(
    Schema.Struct({
      authStatus: Schema.optional(Schema.String),
      certIssuerDn: Schema.optional(Schema.String),
      certIssuerSki: Schema.optional(Schema.String),
      certPresented: Schema.optional(Schema.Boolean),
      certSerial: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        authStatus: "auth_status",
        certIssuerDn: "cert_issuer_dn",
        certIssuerSki: "cert_issuer_ski",
        certPresented: "cert_presented",
        certSerial: "cert_serial",
      }),
    ),
  ),
  serviceTokenId: Schema.optional(Schema.String),
  serviceTokenStatus: Schema.optional(Schema.Boolean),
  userUuid: Schema.optional(Schema.String),
  version: Schema.optional(Schema.Number),
}).pipe(
  Schema.encodeKeys({
    accountId: "account_id",
    authStatus: "auth_status",
    commonName: "common_name",
    deviceId: "device_id",
    deviceSessions: "device_sessions",
    devicePosture: "devicePosture",
    email: "email",
    geo: "geo",
    iat: "iat",
    idp: "idp",
    ip: "ip",
    isGateway: "is_gateway",
    isWarp: "is_warp",
    isActive: "isActive",
    mtlsAuth: "mtls_auth",
    serviceTokenId: "service_token_id",
    serviceTokenStatus: "service_token_status",
    userUuid: "user_uuid",
    version: "version",
  }),
) as unknown as Schema.Schema<GetAccessUserActiveSessionResponse>;

export type GetAccessUserActiveSessionError = CommonErrors;

export const getAccessUserActiveSession: API.OperationMethod<
  GetAccessUserActiveSessionRequest,
  GetAccessUserActiveSessionResponse,
  GetAccessUserActiveSessionError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccessUserActiveSessionRequest,
  output: GetAccessUserActiveSessionResponse,
  errors: [],
}));

export interface ListAccessUserActiveSessionsRequest {
  userId: string;
  /** Identifier. */
  accountId: string;
}

export const ListAccessUserActiveSessionsRequest = Schema.Struct({
  userId: Schema.String.pipe(T.HttpPath("userId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/users/{userId}/active_sessions",
  }),
) as unknown as Schema.Schema<ListAccessUserActiveSessionsRequest>;

export type ListAccessUserActiveSessionsResponse = {
  expiration?: number;
  metadata?: {
    apps?: Record<string, unknown>;
    expires?: number;
    iat?: number;
    nonce?: string;
    ttl?: number;
  };
  name?: string;
}[];

export const ListAccessUserActiveSessionsResponse = Schema.Array(
  Schema.Struct({
    expiration: Schema.optional(Schema.Number),
    metadata: Schema.optional(
      Schema.Struct({
        apps: Schema.optional(Schema.Struct({})),
        expires: Schema.optional(Schema.Number),
        iat: Schema.optional(Schema.Number),
        nonce: Schema.optional(Schema.String),
        ttl: Schema.optional(Schema.Number),
      }),
    ),
    name: Schema.optional(Schema.String),
  }),
) as unknown as Schema.Schema<ListAccessUserActiveSessionsResponse>;

export type ListAccessUserActiveSessionsError = CommonErrors;

export const listAccessUserActiveSessions: API.OperationMethod<
  ListAccessUserActiveSessionsRequest,
  ListAccessUserActiveSessionsResponse,
  ListAccessUserActiveSessionsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessUserActiveSessionsRequest,
  output: ListAccessUserActiveSessionsResponse,
  errors: [],
}));

// =============================================================================
// AccessUserFailedLogin
// =============================================================================

export interface ListAccessUserFailedLoginsRequest {
  userId: string;
  /** Identifier. */
  accountId: string;
}

export const ListAccessUserFailedLoginsRequest = Schema.Struct({
  userId: Schema.String.pipe(T.HttpPath("userId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/users/{userId}/failed_logins",
  }),
) as unknown as Schema.Schema<ListAccessUserFailedLoginsRequest>;

export type ListAccessUserFailedLoginsResponse = {
  expiration?: number;
  metadata?: unknown;
}[];

export const ListAccessUserFailedLoginsResponse = Schema.Array(
  Schema.Struct({
    expiration: Schema.optional(Schema.Number),
    metadata: Schema.optional(Schema.Unknown),
  }),
) as unknown as Schema.Schema<ListAccessUserFailedLoginsResponse>;

export type ListAccessUserFailedLoginsError = CommonErrors;

export const listAccessUserFailedLogins: API.OperationMethod<
  ListAccessUserFailedLoginsRequest,
  ListAccessUserFailedLoginsResponse,
  ListAccessUserFailedLoginsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListAccessUserFailedLoginsRequest,
  output: ListAccessUserFailedLoginsResponse,
  errors: [],
}));

// =============================================================================
// AccessUserLastSeenIdentity
// =============================================================================

export interface GetAccessUserLastSeenIdentityRequest {
  userId: string;
  /** Identifier. */
  accountId: string;
}

export const GetAccessUserLastSeenIdentityRequest = Schema.Struct({
  userId: Schema.String.pipe(T.HttpPath("userId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/users/{userId}/last_seen_identity",
  }),
) as unknown as Schema.Schema<GetAccessUserLastSeenIdentityRequest>;

export interface GetAccessUserLastSeenIdentityResponse {
  accountId?: string;
  authStatus?: string;
  commonName?: string;
  deviceId?: string;
  deviceSessions?: Record<string, unknown>;
  devicePosture?: Record<string, unknown>;
  email?: string;
  geo?: unknown;
  iat?: number;
  idp?: { id?: string; type?: string };
  ip?: string;
  isGateway?: boolean;
  isWarp?: boolean;
  mtlsAuth?: {
    authStatus?: string;
    certIssuerDn?: string;
    certIssuerSki?: string;
    certPresented?: boolean;
    certSerial?: string;
  };
  serviceTokenId?: string;
  serviceTokenStatus?: boolean;
  userUuid?: string;
  version?: number;
}

export const GetAccessUserLastSeenIdentityResponse = Schema.Struct({
  accountId: Schema.optional(Schema.String),
  authStatus: Schema.optional(Schema.String),
  commonName: Schema.optional(Schema.String),
  deviceId: Schema.optional(Schema.String),
  deviceSessions: Schema.optional(Schema.Struct({})),
  devicePosture: Schema.optional(Schema.Struct({})),
  email: Schema.optional(Schema.String),
  geo: Schema.optional(Schema.Unknown),
  iat: Schema.optional(Schema.Number),
  idp: Schema.optional(
    Schema.Struct({
      id: Schema.optional(Schema.String),
      type: Schema.optional(Schema.String),
    }),
  ),
  ip: Schema.optional(Schema.String),
  isGateway: Schema.optional(Schema.Boolean),
  isWarp: Schema.optional(Schema.Boolean),
  mtlsAuth: Schema.optional(
    Schema.Struct({
      authStatus: Schema.optional(Schema.String),
      certIssuerDn: Schema.optional(Schema.String),
      certIssuerSki: Schema.optional(Schema.String),
      certPresented: Schema.optional(Schema.Boolean),
      certSerial: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        authStatus: "auth_status",
        certIssuerDn: "cert_issuer_dn",
        certIssuerSki: "cert_issuer_ski",
        certPresented: "cert_presented",
        certSerial: "cert_serial",
      }),
    ),
  ),
  serviceTokenId: Schema.optional(Schema.String),
  serviceTokenStatus: Schema.optional(Schema.Boolean),
  userUuid: Schema.optional(Schema.String),
  version: Schema.optional(Schema.Number),
}).pipe(
  Schema.encodeKeys({
    accountId: "account_id",
    authStatus: "auth_status",
    commonName: "common_name",
    deviceId: "device_id",
    deviceSessions: "device_sessions",
    devicePosture: "devicePosture",
    email: "email",
    geo: "geo",
    iat: "iat",
    idp: "idp",
    ip: "ip",
    isGateway: "is_gateway",
    isWarp: "is_warp",
    mtlsAuth: "mtls_auth",
    serviceTokenId: "service_token_id",
    serviceTokenStatus: "service_token_status",
    userUuid: "user_uuid",
    version: "version",
  }),
) as unknown as Schema.Schema<GetAccessUserLastSeenIdentityResponse>;

export type GetAccessUserLastSeenIdentityError = CommonErrors;

export const getAccessUserLastSeenIdentity: API.OperationMethod<
  GetAccessUserLastSeenIdentityRequest,
  GetAccessUserLastSeenIdentityResponse,
  GetAccessUserLastSeenIdentityError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetAccessUserLastSeenIdentityRequest,
  output: GetAccessUserLastSeenIdentityResponse,
  errors: [],
}));

// =============================================================================
// ConnectivitySetting
// =============================================================================

export interface GetConnectivitySettingRequest {
  /** Cloudflare account ID */
  accountId: string;
}

export const GetConnectivitySettingRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/zerotrust/connectivity_settings",
  }),
) as unknown as Schema.Schema<GetConnectivitySettingRequest>;

export interface GetConnectivitySettingResponse {
  /** A flag to enable the ICMP proxy for the account network. */
  icmpProxyEnabled?: boolean;
  /** A flag to enable WARP to WARP traffic. */
  offrampWarpEnabled?: boolean;
}

export const GetConnectivitySettingResponse = Schema.Struct({
  icmpProxyEnabled: Schema.optional(Schema.Boolean),
  offrampWarpEnabled: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    icmpProxyEnabled: "icmp_proxy_enabled",
    offrampWarpEnabled: "offramp_warp_enabled",
  }),
) as unknown as Schema.Schema<GetConnectivitySettingResponse>;

export type GetConnectivitySettingError = CommonErrors;

export const getConnectivitySetting: API.OperationMethod<
  GetConnectivitySettingRequest,
  GetConnectivitySettingResponse,
  GetConnectivitySettingError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetConnectivitySettingRequest,
  output: GetConnectivitySettingResponse,
  errors: [],
}));

export interface PatchConnectivitySettingRequest {
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Body param: A flag to enable the ICMP proxy for the account network. */
  icmpProxyEnabled?: boolean;
  /** Body param: A flag to enable WARP to WARP traffic. */
  offrampWarpEnabled?: boolean;
}

export const PatchConnectivitySettingRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  icmpProxyEnabled: Schema.optional(Schema.Boolean),
  offrampWarpEnabled: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    icmpProxyEnabled: "icmp_proxy_enabled",
    offrampWarpEnabled: "offramp_warp_enabled",
  }),
  T.Http({
    method: "PATCH",
    path: "/accounts/{account_id}/zerotrust/connectivity_settings",
  }),
) as unknown as Schema.Schema<PatchConnectivitySettingRequest>;

export interface PatchConnectivitySettingResponse {
  /** A flag to enable the ICMP proxy for the account network. */
  icmpProxyEnabled?: boolean;
  /** A flag to enable WARP to WARP traffic. */
  offrampWarpEnabled?: boolean;
}

export const PatchConnectivitySettingResponse = Schema.Struct({
  icmpProxyEnabled: Schema.optional(Schema.Boolean),
  offrampWarpEnabled: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    icmpProxyEnabled: "icmp_proxy_enabled",
    offrampWarpEnabled: "offramp_warp_enabled",
  }),
) as unknown as Schema.Schema<PatchConnectivitySettingResponse>;

export type PatchConnectivitySettingError = CommonErrors;

export const patchConnectivitySetting: API.OperationMethod<
  PatchConnectivitySettingRequest,
  PatchConnectivitySettingResponse,
  PatchConnectivitySettingError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchConnectivitySettingRequest,
  output: PatchConnectivitySettingResponse,
  errors: [],
}));

// =============================================================================
// Device
// =============================================================================

export interface GetDeviceRequest {
  deviceId: string;
  accountId: string;
}

export const GetDeviceRequest = Schema.Struct({
  deviceId: Schema.String.pipe(T.HttpPath("deviceId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/{deviceId}" }),
) as unknown as Schema.Schema<GetDeviceRequest>;

export interface GetDeviceResponse {
  /** Registration ID. Equal to Device ID except for accounts which enabled [multi-user mode](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/warp/deployment/mdm-deployment/wind */
  id?: string;
  account?: { id?: string; accountType?: string; name?: string };
  /** When the device was created. */
  created?: string;
  /** True if the device was deleted. */
  deleted?: boolean;
  deviceType?: string;
  /** @deprecated */
  gatewayDeviceId?: string;
  /** IPv4 or IPv6 address. */
  ip?: string;
  /** The device's public key. */
  key?: string;
  /** Type of the key. */
  keyType?: string;
  /** When the device last connected to Cloudflare services. */
  lastSeen?: string;
  /** The device mac address. */
  macAddress?: string;
  /** The device model name. */
  model?: string;
  /** The device name. */
  name?: string;
  /** The operating system version. */
  osVersion?: string;
  /** The device serial number. */
  serialNumber?: string;
  /** Type of the tunnel connection used. */
  tunnelType?: string;
  /** When the device was updated. */
  updated?: string;
  user?: { id?: string; email?: string; name?: string };
  /** The WARP client version. */
  version?: string;
}

export const GetDeviceResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  account: Schema.optional(
    Schema.Struct({
      id: Schema.optional(Schema.String),
      accountType: Schema.optional(Schema.String),
      name: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        accountType: "account_type",
        name: "name",
      }),
    ),
  ),
  created: Schema.optional(Schema.String),
  deleted: Schema.optional(Schema.Boolean),
  deviceType: Schema.optional(Schema.String),
  gatewayDeviceId: Schema.optional(Schema.String),
  ip: Schema.optional(Schema.String),
  key: Schema.optional(Schema.String),
  keyType: Schema.optional(Schema.String),
  lastSeen: Schema.optional(Schema.String),
  macAddress: Schema.optional(Schema.String),
  model: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  osVersion: Schema.optional(Schema.String),
  serialNumber: Schema.optional(Schema.String),
  tunnelType: Schema.optional(Schema.String),
  updated: Schema.optional(Schema.String),
  user: Schema.optional(
    Schema.Struct({
      id: Schema.optional(Schema.String),
      email: Schema.optional(Schema.String),
      name: Schema.optional(Schema.String),
    }),
  ),
  version: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    account: "account",
    created: "created",
    deleted: "deleted",
    deviceType: "device_type",
    gatewayDeviceId: "gateway_device_id",
    ip: "ip",
    key: "key",
    keyType: "key_type",
    lastSeen: "last_seen",
    macAddress: "mac_address",
    model: "model",
    name: "name",
    osVersion: "os_version",
    serialNumber: "serial_number",
    tunnelType: "tunnel_type",
    updated: "updated",
    user: "user",
    version: "version",
  }),
) as unknown as Schema.Schema<GetDeviceResponse>;

export type GetDeviceError = CommonErrors;

export const getDevice: API.OperationMethod<
  GetDeviceRequest,
  GetDeviceResponse,
  GetDeviceError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDeviceRequest,
  output: GetDeviceResponse,
  errors: [],
}));

export interface ListDevicesRequest {
  accountId: string;
}

export const ListDevicesRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices" }),
) as unknown as Schema.Schema<ListDevicesRequest>;

export type ListDevicesResponse = {
  id?: string;
  created?: string;
  deleted?: boolean;
  deviceType?: "windows" | "mac" | "linux" | "android" | "ios" | "chromeos";
  ip?: string;
  key?: string;
  lastSeen?: string;
  macAddress?: string;
  manufacturer?: string;
  model?: string;
  name?: string;
  osDistroName?: string;
  osDistroRevision?: string;
  osVersion?: string;
  osVersionExtra?: string;
  revokedAt?: string;
  serialNumber?: string;
  updated?: string;
  user?: { id?: string; email?: string; name?: string };
  version?: string;
}[];

export const ListDevicesResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    created: Schema.optional(Schema.String),
    deleted: Schema.optional(Schema.Boolean),
    deviceType: Schema.optional(
      Schema.Literals([
        "windows",
        "mac",
        "linux",
        "android",
        "ios",
        "chromeos",
      ]),
    ),
    ip: Schema.optional(Schema.String),
    key: Schema.optional(Schema.String),
    lastSeen: Schema.optional(Schema.String),
    macAddress: Schema.optional(Schema.String),
    manufacturer: Schema.optional(Schema.String),
    model: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    osDistroName: Schema.optional(Schema.String),
    osDistroRevision: Schema.optional(Schema.String),
    osVersion: Schema.optional(Schema.String),
    osVersionExtra: Schema.optional(Schema.String),
    revokedAt: Schema.optional(Schema.String),
    serialNumber: Schema.optional(Schema.String),
    updated: Schema.optional(Schema.String),
    user: Schema.optional(
      Schema.Struct({
        id: Schema.optional(Schema.String),
        email: Schema.optional(Schema.String),
        name: Schema.optional(Schema.String),
      }),
    ),
    version: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      created: "created",
      deleted: "deleted",
      deviceType: "device_type",
      ip: "ip",
      key: "key",
      lastSeen: "last_seen",
      macAddress: "mac_address",
      manufacturer: "manufacturer",
      model: "model",
      name: "name",
      osDistroName: "os_distro_name",
      osDistroRevision: "os_distro_revision",
      osVersion: "os_version",
      osVersionExtra: "os_version_extra",
      revokedAt: "revoked_at",
      serialNumber: "serial_number",
      updated: "updated",
      user: "user",
      version: "version",
    }),
  ),
) as unknown as Schema.Schema<ListDevicesResponse>;

export type ListDevicesError = CommonErrors;

export const listDevices: API.OperationMethod<
  ListDevicesRequest,
  ListDevicesResponse,
  ListDevicesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDevicesRequest,
  output: ListDevicesResponse,
  errors: [],
}));

// =============================================================================
// DeviceDevices_
// =============================================================================

export interface GetDeviceDevices_Request {
  deviceId: string;
  /** Path param: */
  accountId: string;
  /** Query param: Comma-separated list of additional information that should be included in the device response. Supported values are: "last_seen_registration.policy". */
  include?: string;
}

export const GetDeviceDevices_Request = Schema.Struct({
  deviceId: Schema.String.pipe(T.HttpPath("deviceId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  include: Schema.optional(Schema.String).pipe(T.HttpQuery("include")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/physical-devices/{deviceId}",
  }),
) as unknown as Schema.Schema<GetDeviceDevices_Request>;

export interface GetDeviceDevices_Response {
  /** The unique ID of the device. */
  id: string;
  /** The number of active registrations for the device. Active registrations are those which haven't been revoked or deleted. */
  activeRegistrations: number;
  /** The RFC3339 timestamp when the device was created. */
  createdAt: string;
  /** The RFC3339 timestamp when the device was last seen. */
  lastSeenAt: string | null;
  /** The name of the device. */
  name: string;
  /** The RFC3339 timestamp when the device was last updated. */
  updatedAt: string;
  /** Version of the WARP client. */
  clientVersion?: string | null;
  /** The RFC3339 timestamp when the device was deleted. */
  deletedAt?: string | null;
  /** The device operating system. */
  deviceType?: string | null;
  /** A string that uniquely identifies the hardware or virtual machine (VM). */
  hardwareId?: string | null;
  /** The last seen registration for the device. */
  lastSeenRegistration?: {
    policy?: {
      id: string;
      default: boolean;
      deleted: boolean;
      name: string;
      updatedAt: string;
    } | null;
  } | null;
  /** The last user to use the WARP device. */
  lastSeenUser?: { id?: string; email?: string; name?: string } | null;
  /** The device MAC address. */
  macAddress?: string | null;
  /** The device manufacturer. */
  manufacturer?: string | null;
  /** The model name of the device. */
  model?: string | null;
  /** The device operating system version number. */
  osVersion?: string | null;
  /** Additional operating system version details. For Windows, the UBR (Update Build Revision). For Mac or iOS, the Product Version Extra. For Linux, the distribution name and version. */
  osVersionExtra?: string | null;
  /** @deprecated  Deprecated  : IP information is provided by DEX - see https://developers.cloudflare.com/api/resources/zero_trust/subresources/dex/subresources/fleet_status/subresources/devices/methods/li */
  publicIp?: string | null;
  /** The device serial number. */
  serialNumber?: string | null;
}

export const GetDeviceDevices_Response = Schema.Struct({
  id: Schema.String,
  activeRegistrations: Schema.Number,
  createdAt: Schema.String,
  lastSeenAt: Schema.Union([Schema.String, Schema.Null]),
  name: Schema.String,
  updatedAt: Schema.String,
  clientVersion: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  deletedAt: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  deviceType: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  hardwareId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  lastSeenRegistration: Schema.optional(
    Schema.Union([
      Schema.Struct({
        policy: Schema.optional(
          Schema.Union([
            Schema.Struct({
              id: Schema.String,
              default: Schema.Boolean,
              deleted: Schema.Boolean,
              name: Schema.String,
              updatedAt: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                id: "id",
                default: "default",
                deleted: "deleted",
                name: "name",
                updatedAt: "updated_at",
              }),
            ),
            Schema.Null,
          ]),
        ),
      }),
      Schema.Null,
    ]),
  ),
  lastSeenUser: Schema.optional(
    Schema.Union([
      Schema.Struct({
        id: Schema.optional(Schema.String),
        email: Schema.optional(Schema.String),
        name: Schema.optional(Schema.String),
      }),
      Schema.Null,
    ]),
  ),
  macAddress: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  manufacturer: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  model: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  osVersion: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  osVersionExtra: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  publicIp: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  serialNumber: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    activeRegistrations: "active_registrations",
    createdAt: "created_at",
    lastSeenAt: "last_seen_at",
    name: "name",
    updatedAt: "updated_at",
    clientVersion: "client_version",
    deletedAt: "deleted_at",
    deviceType: "device_type",
    hardwareId: "hardware_id",
    lastSeenRegistration: "last_seen_registration",
    lastSeenUser: "last_seen_user",
    macAddress: "mac_address",
    manufacturer: "manufacturer",
    model: "model",
    osVersion: "os_version",
    osVersionExtra: "os_version_extra",
    publicIp: "public_ip",
    serialNumber: "serial_number",
  }),
) as unknown as Schema.Schema<GetDeviceDevices_Response>;

export type GetDeviceDevices_Error = CommonErrors;

export const getDeviceDevices_: API.OperationMethod<
  GetDeviceDevices_Request,
  GetDeviceDevices_Response,
  GetDeviceDevices_Error,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDeviceDevices_Request,
  output: GetDeviceDevices_Response,
  errors: [],
}));

export interface DeleteDeviceDevices_Request {
  deviceId: string;
  accountId: string;
}

export const DeleteDeviceDevices_Request = Schema.Struct({
  deviceId: Schema.String.pipe(T.HttpPath("deviceId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/devices/physical-devices/{deviceId}",
  }),
) as unknown as Schema.Schema<DeleteDeviceDevices_Request>;

export type DeleteDeviceDevices_Response = unknown;

export const DeleteDeviceDevices_Response =
  Schema.Unknown as unknown as Schema.Schema<DeleteDeviceDevices_Response>;

export type DeleteDeviceDevices_Error = CommonErrors;

export const deleteDeviceDevices_: API.OperationMethod<
  DeleteDeviceDevices_Request,
  DeleteDeviceDevices_Response,
  DeleteDeviceDevices_Error,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDeviceDevices_Request,
  output: DeleteDeviceDevices_Response,
  errors: [],
}));

export interface RevokeDeviceDevices_Request {
  deviceId: string;
  accountId: string;
}

export const RevokeDeviceDevices_Request = Schema.Struct({
  deviceId: Schema.String.pipe(T.HttpPath("deviceId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/devices/physical-devices/{deviceId}/revoke",
  }),
) as unknown as Schema.Schema<RevokeDeviceDevices_Request>;

export type RevokeDeviceDevices_Response = unknown;

export const RevokeDeviceDevices_Response =
  Schema.Unknown as unknown as Schema.Schema<RevokeDeviceDevices_Response>;

export type RevokeDeviceDevices_Error = CommonErrors;

export const revokeDeviceDevices_: API.OperationMethod<
  RevokeDeviceDevices_Request,
  RevokeDeviceDevices_Response,
  RevokeDeviceDevices_Error,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: RevokeDeviceDevices_Request,
  output: RevokeDeviceDevices_Response,
  errors: [],
}));

// =============================================================================
// DeviceDevicesS
// =============================================================================

export interface ListDeviceDevicesSRequest {
  /** Path param: */
  accountId: string;
  /** Query param: Filter by a one or more device IDs. */
  id?: string[];
  /** Query param: Include or exclude devices with active registrations. The default is "only" - return only devices with active registrations. */
  activeRegistrations?: "include" | "only" | "exclude";
  /** Query param: Comma-separated list of additional information that should be included in the device response. Supported values are: "last_seen_registration.policy". */
  include?: string;
  /** Query param: */
  lastSeenUser?: { email?: string };
  /** Query param: Search by device details. */
  search?: string;
  /** Query param: Filter by the last_seen timestamp - returns only devices last seen after this timestamp. */
  seenAfter?: string;
  /** Query param: Filter by the last_seen timestamp - returns only devices last seen before this timestamp. */
  seenBefore?: string;
  /** Query param: The device field to order results by. */
  sortBy?:
    | "name"
    | "id"
    | "client_version"
    | "last_seen_user.email"
    | "last_seen_at"
    | "active_registrations"
    | "created_at";
  /** Query param: Sort direction. */
  sortOrder?: "asc" | "desc";
}

export const ListDeviceDevicesSRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("id")),
  activeRegistrations: Schema.optional(
    Schema.Literals(["include", "only", "exclude"]),
  ).pipe(T.HttpQuery("active_registrations")),
  include: Schema.optional(Schema.String).pipe(T.HttpQuery("include")),
  lastSeenUser: Schema.optional(
    Schema.Struct({
      email: Schema.optional(Schema.String),
    }),
  ).pipe(T.HttpQuery("last_seen_user")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
  seenAfter: Schema.optional(Schema.String).pipe(T.HttpQuery("seen_after")),
  seenBefore: Schema.optional(Schema.String).pipe(T.HttpQuery("seen_before")),
  sortBy: Schema.optional(
    Schema.Literals([
      "name",
      "id",
      "client_version",
      "last_seen_user.email",
      "last_seen_at",
      "active_registrations",
      "created_at",
    ]),
  ).pipe(T.HttpQuery("sort_by")),
  sortOrder: Schema.optional(Schema.Literals(["asc", "desc"])).pipe(
    T.HttpQuery("sort_order"),
  ),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/physical-devices",
  }),
) as unknown as Schema.Schema<ListDeviceDevicesSRequest>;

export type ListDeviceDevicesSResponse = {
  id: string;
  activeRegistrations: number;
  createdAt: string;
  lastSeenAt: string | null;
  name: string;
  updatedAt: string;
  clientVersion?: string | null;
  deletedAt?: string | null;
  deviceType?: string | null;
  hardwareId?: string | null;
  lastSeenRegistration?: {
    policy?: {
      id: string;
      default: boolean;
      deleted: boolean;
      name: string;
      updatedAt: string;
    } | null;
  } | null;
  lastSeenUser?: { id?: string; email?: string; name?: string } | null;
  macAddress?: string | null;
  manufacturer?: string | null;
  model?: string | null;
  osVersion?: string | null;
  osVersionExtra?: string | null;
  publicIp?: string | null;
  serialNumber?: string | null;
}[];

export const ListDeviceDevicesSResponse = Schema.Array(
  Schema.Struct({
    id: Schema.String,
    activeRegistrations: Schema.Number,
    createdAt: Schema.String,
    lastSeenAt: Schema.Union([Schema.String, Schema.Null]),
    name: Schema.String,
    updatedAt: Schema.String,
    clientVersion: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    deletedAt: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    deviceType: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    hardwareId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    lastSeenRegistration: Schema.optional(
      Schema.Union([
        Schema.Struct({
          policy: Schema.optional(
            Schema.Union([
              Schema.Struct({
                id: Schema.String,
                default: Schema.Boolean,
                deleted: Schema.Boolean,
                name: Schema.String,
                updatedAt: Schema.String,
              }).pipe(
                Schema.encodeKeys({
                  id: "id",
                  default: "default",
                  deleted: "deleted",
                  name: "name",
                  updatedAt: "updated_at",
                }),
              ),
              Schema.Null,
            ]),
          ),
        }),
        Schema.Null,
      ]),
    ),
    lastSeenUser: Schema.optional(
      Schema.Union([
        Schema.Struct({
          id: Schema.optional(Schema.String),
          email: Schema.optional(Schema.String),
          name: Schema.optional(Schema.String),
        }),
        Schema.Null,
      ]),
    ),
    macAddress: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    manufacturer: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    model: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    osVersion: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    osVersionExtra: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    publicIp: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    serialNumber: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      activeRegistrations: "active_registrations",
      createdAt: "created_at",
      lastSeenAt: "last_seen_at",
      name: "name",
      updatedAt: "updated_at",
      clientVersion: "client_version",
      deletedAt: "deleted_at",
      deviceType: "device_type",
      hardwareId: "hardware_id",
      lastSeenRegistration: "last_seen_registration",
      lastSeenUser: "last_seen_user",
      macAddress: "mac_address",
      manufacturer: "manufacturer",
      model: "model",
      osVersion: "os_version",
      osVersionExtra: "os_version_extra",
      publicIp: "public_ip",
      serialNumber: "serial_number",
    }),
  ),
) as unknown as Schema.Schema<ListDeviceDevicesSResponse>;

export type ListDeviceDevicesSError = CommonErrors;

export const listDeviceDevicesS: API.OperationMethod<
  ListDeviceDevicesSRequest,
  ListDeviceDevicesSResponse,
  ListDeviceDevicesSError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDeviceDevicesSRequest,
  output: ListDeviceDevicesSResponse,
  errors: [],
}));

// =============================================================================
// DeviceDexTest
// =============================================================================

export interface GetDeviceDexTestRequest {
  dexTestId: string;
  accountId: string;
}

export const GetDeviceDexTestRequest = Schema.Struct({
  dexTestId: Schema.String.pipe(T.HttpPath("dexTestId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dex/devices/dex_tests/{dexTestId}",
  }),
) as unknown as Schema.Schema<GetDeviceDexTestRequest>;

export interface GetDeviceDexTestResponse {
  /** The configuration object which contains the details for the WARP client to conduct the test. */
  data: { host?: string; kind?: string; method?: string };
  /** Determines whether or not the test is active. */
  enabled: boolean;
  /** How often the test will run. */
  interval: string;
  /** The name of the DEX test. Must be unique. */
  name: string;
  /** Additional details about the test. */
  description?: string;
  /** DEX rules targeted by this test */
  targetPolicies?: { id?: string; default?: boolean; name?: string }[];
  targeted?: boolean;
  /** The unique identifier for the test. */
  testId?: string;
}

export const GetDeviceDexTestResponse = Schema.Struct({
  data: Schema.Struct({
    host: Schema.optional(Schema.String),
    kind: Schema.optional(Schema.String),
    method: Schema.optional(Schema.String),
  }),
  enabled: Schema.Boolean,
  interval: Schema.String,
  name: Schema.String,
  description: Schema.optional(Schema.String),
  targetPolicies: Schema.optional(
    Schema.Array(
      Schema.Struct({
        id: Schema.optional(Schema.String),
        default: Schema.optional(Schema.Boolean),
        name: Schema.optional(Schema.String),
      }),
    ),
  ),
  targeted: Schema.optional(Schema.Boolean),
  testId: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    data: "data",
    enabled: "enabled",
    interval: "interval",
    name: "name",
    description: "description",
    targetPolicies: "target_policies",
    targeted: "targeted",
    testId: "test_id",
  }),
) as unknown as Schema.Schema<GetDeviceDexTestResponse>;

export type GetDeviceDexTestError = CommonErrors;

export const getDeviceDexTest: API.OperationMethod<
  GetDeviceDexTestRequest,
  GetDeviceDexTestResponse,
  GetDeviceDexTestError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDeviceDexTestRequest,
  output: GetDeviceDexTestResponse,
  errors: [],
}));

export interface ListDeviceDexTestsRequest {
  accountId: string;
}

export const ListDeviceDexTestsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dex/devices/dex_tests",
  }),
) as unknown as Schema.Schema<ListDeviceDexTestsRequest>;

export type ListDeviceDexTestsResponse = {
  data: { host?: string; kind?: string; method?: string };
  enabled: boolean;
  interval: string;
  name: string;
  description?: string;
  targetPolicies?: { id?: string; default?: boolean; name?: string }[];
  targeted?: boolean;
  testId?: string;
}[];

export const ListDeviceDexTestsResponse = Schema.Array(
  Schema.Struct({
    data: Schema.Struct({
      host: Schema.optional(Schema.String),
      kind: Schema.optional(Schema.String),
      method: Schema.optional(Schema.String),
    }),
    enabled: Schema.Boolean,
    interval: Schema.String,
    name: Schema.String,
    description: Schema.optional(Schema.String),
    targetPolicies: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          default: Schema.optional(Schema.Boolean),
          name: Schema.optional(Schema.String),
        }),
      ),
    ),
    targeted: Schema.optional(Schema.Boolean),
    testId: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      data: "data",
      enabled: "enabled",
      interval: "interval",
      name: "name",
      description: "description",
      targetPolicies: "target_policies",
      targeted: "targeted",
      testId: "test_id",
    }),
  ),
) as unknown as Schema.Schema<ListDeviceDexTestsResponse>;

export type ListDeviceDexTestsError = CommonErrors;

export const listDeviceDexTests: API.OperationMethod<
  ListDeviceDexTestsRequest,
  ListDeviceDexTestsResponse,
  ListDeviceDexTestsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDeviceDexTestsRequest,
  output: ListDeviceDexTestsResponse,
  errors: [],
}));

export interface CreateDeviceDexTestRequest {
  /** Path param: */
  accountId: string;
  /** Body param: The configuration object which contains the details for the WARP client to conduct the test. */
  data: { host?: string; kind?: string; method?: string };
  /** Body param: Determines whether or not the test is active. */
  enabled: boolean;
  /** Body param: How often the test will run. */
  interval: string;
  /** Body param: The name of the DEX test. Must be unique. */
  name: string;
  /** Body param: Additional details about the test. */
  description?: string;
  /** Body param: DEX rules targeted by this test */
  targetPolicies?: { id?: string; default?: boolean; name?: string }[];
  /** Body param: */
  targeted?: boolean;
}

export const CreateDeviceDexTestRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  data: Schema.Struct({
    host: Schema.optional(Schema.String),
    kind: Schema.optional(Schema.String),
    method: Schema.optional(Schema.String),
  }),
  enabled: Schema.Boolean,
  interval: Schema.String,
  name: Schema.String,
  description: Schema.optional(Schema.String),
  targetPolicies: Schema.optional(
    Schema.Array(
      Schema.Struct({
        id: Schema.optional(Schema.String),
        default: Schema.optional(Schema.Boolean),
        name: Schema.optional(Schema.String),
      }),
    ),
  ),
  targeted: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    data: "data",
    enabled: "enabled",
    interval: "interval",
    name: "name",
    description: "description",
    targetPolicies: "target_policies",
    targeted: "targeted",
  }),
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/dex/devices/dex_tests",
  }),
) as unknown as Schema.Schema<CreateDeviceDexTestRequest>;

export interface CreateDeviceDexTestResponse {
  /** The configuration object which contains the details for the WARP client to conduct the test. */
  data: { host?: string; kind?: string; method?: string };
  /** Determines whether or not the test is active. */
  enabled: boolean;
  /** How often the test will run. */
  interval: string;
  /** The name of the DEX test. Must be unique. */
  name: string;
  /** Additional details about the test. */
  description?: string;
  /** DEX rules targeted by this test */
  targetPolicies?: { id?: string; default?: boolean; name?: string }[];
  targeted?: boolean;
  /** The unique identifier for the test. */
  testId?: string;
}

export const CreateDeviceDexTestResponse = Schema.Struct({
  data: Schema.Struct({
    host: Schema.optional(Schema.String),
    kind: Schema.optional(Schema.String),
    method: Schema.optional(Schema.String),
  }),
  enabled: Schema.Boolean,
  interval: Schema.String,
  name: Schema.String,
  description: Schema.optional(Schema.String),
  targetPolicies: Schema.optional(
    Schema.Array(
      Schema.Struct({
        id: Schema.optional(Schema.String),
        default: Schema.optional(Schema.Boolean),
        name: Schema.optional(Schema.String),
      }),
    ),
  ),
  targeted: Schema.optional(Schema.Boolean),
  testId: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    data: "data",
    enabled: "enabled",
    interval: "interval",
    name: "name",
    description: "description",
    targetPolicies: "target_policies",
    targeted: "targeted",
    testId: "test_id",
  }),
) as unknown as Schema.Schema<CreateDeviceDexTestResponse>;

export type CreateDeviceDexTestError = CommonErrors;

export const createDeviceDexTest: API.OperationMethod<
  CreateDeviceDexTestRequest,
  CreateDeviceDexTestResponse,
  CreateDeviceDexTestError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDeviceDexTestRequest,
  output: CreateDeviceDexTestResponse,
  errors: [],
}));

export interface UpdateDeviceDexTestRequest {
  dexTestId: string;
  /** Path param: */
  accountId: string;
  /** Body param: The configuration object which contains the details for the WARP client to conduct the test. */
  data: { host?: string; kind?: string; method?: string };
  /** Body param: Determines whether or not the test is active. */
  enabled: boolean;
  /** Body param: How often the test will run. */
  interval: string;
  /** Body param: The name of the DEX test. Must be unique. */
  name: string;
  /** Body param: Additional details about the test. */
  description?: string;
  /** Body param: DEX rules targeted by this test */
  targetPolicies?: { id?: string; default?: boolean; name?: string }[];
  /** Body param: */
  targeted?: boolean;
}

export const UpdateDeviceDexTestRequest = Schema.Struct({
  dexTestId: Schema.String.pipe(T.HttpPath("dexTestId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  data: Schema.Struct({
    host: Schema.optional(Schema.String),
    kind: Schema.optional(Schema.String),
    method: Schema.optional(Schema.String),
  }),
  enabled: Schema.Boolean,
  interval: Schema.String,
  name: Schema.String,
  description: Schema.optional(Schema.String),
  targetPolicies: Schema.optional(
    Schema.Array(
      Schema.Struct({
        id: Schema.optional(Schema.String),
        default: Schema.optional(Schema.Boolean),
        name: Schema.optional(Schema.String),
      }),
    ),
  ),
  targeted: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    data: "data",
    enabled: "enabled",
    interval: "interval",
    name: "name",
    description: "description",
    targetPolicies: "target_policies",
    targeted: "targeted",
  }),
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/dex/devices/dex_tests/{dexTestId}",
  }),
) as unknown as Schema.Schema<UpdateDeviceDexTestRequest>;

export interface UpdateDeviceDexTestResponse {
  /** The configuration object which contains the details for the WARP client to conduct the test. */
  data: { host?: string; kind?: string; method?: string };
  /** Determines whether or not the test is active. */
  enabled: boolean;
  /** How often the test will run. */
  interval: string;
  /** The name of the DEX test. Must be unique. */
  name: string;
  /** Additional details about the test. */
  description?: string;
  /** DEX rules targeted by this test */
  targetPolicies?: { id?: string; default?: boolean; name?: string }[];
  targeted?: boolean;
  /** The unique identifier for the test. */
  testId?: string;
}

export const UpdateDeviceDexTestResponse = Schema.Struct({
  data: Schema.Struct({
    host: Schema.optional(Schema.String),
    kind: Schema.optional(Schema.String),
    method: Schema.optional(Schema.String),
  }),
  enabled: Schema.Boolean,
  interval: Schema.String,
  name: Schema.String,
  description: Schema.optional(Schema.String),
  targetPolicies: Schema.optional(
    Schema.Array(
      Schema.Struct({
        id: Schema.optional(Schema.String),
        default: Schema.optional(Schema.Boolean),
        name: Schema.optional(Schema.String),
      }),
    ),
  ),
  targeted: Schema.optional(Schema.Boolean),
  testId: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    data: "data",
    enabled: "enabled",
    interval: "interval",
    name: "name",
    description: "description",
    targetPolicies: "target_policies",
    targeted: "targeted",
    testId: "test_id",
  }),
) as unknown as Schema.Schema<UpdateDeviceDexTestResponse>;

export type UpdateDeviceDexTestError = CommonErrors;

export const updateDeviceDexTest: API.OperationMethod<
  UpdateDeviceDexTestRequest,
  UpdateDeviceDexTestResponse,
  UpdateDeviceDexTestError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDeviceDexTestRequest,
  output: UpdateDeviceDexTestResponse,
  errors: [],
}));

export interface DeleteDeviceDexTestRequest {
  dexTestId: string;
  accountId: string;
}

export const DeleteDeviceDexTestRequest = Schema.Struct({
  dexTestId: Schema.String.pipe(T.HttpPath("dexTestId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/dex/devices/dex_tests/{dexTestId}",
  }),
) as unknown as Schema.Schema<DeleteDeviceDexTestRequest>;

export interface DeleteDeviceDexTestResponse {
  dexTests?: {
    data: { host?: string; kind?: string; method?: string };
    enabled: boolean;
    interval: string;
    name: string;
    description?: string;
    targetPolicies?: { id?: string; default?: boolean; name?: string }[];
    targeted?: boolean;
    testId?: string;
  }[];
}

export const DeleteDeviceDexTestResponse = Schema.Struct({
  dexTests: Schema.optional(
    Schema.Array(
      Schema.Struct({
        data: Schema.Struct({
          host: Schema.optional(Schema.String),
          kind: Schema.optional(Schema.String),
          method: Schema.optional(Schema.String),
        }),
        enabled: Schema.Boolean,
        interval: Schema.String,
        name: Schema.String,
        description: Schema.optional(Schema.String),
        targetPolicies: Schema.optional(
          Schema.Array(
            Schema.Struct({
              id: Schema.optional(Schema.String),
              default: Schema.optional(Schema.Boolean),
              name: Schema.optional(Schema.String),
            }),
          ),
        ),
        targeted: Schema.optional(Schema.Boolean),
        testId: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          data: "data",
          enabled: "enabled",
          interval: "interval",
          name: "name",
          description: "description",
          targetPolicies: "target_policies",
          targeted: "targeted",
          testId: "test_id",
        }),
      ),
    ),
  ),
}).pipe(
  Schema.encodeKeys({ dexTests: "dex_tests" }),
) as unknown as Schema.Schema<DeleteDeviceDexTestResponse>;

export type DeleteDeviceDexTestError = CommonErrors;

export const deleteDeviceDexTest: API.OperationMethod<
  DeleteDeviceDexTestRequest,
  DeleteDeviceDexTestResponse,
  DeleteDeviceDexTestError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDeviceDexTestRequest,
  output: DeleteDeviceDexTestResponse,
  errors: [],
}));

// =============================================================================
// DeviceFleetStatus
// =============================================================================

export interface GetDeviceFleetStatusRequest {
  deviceId: string;
  /** Path param: Unique identifier for account */
  accountId: string;
  /** Query param: Number of minutes before current time */
  sinceMinutes: number;
  /** Query param: List of data centers to filter results */
  colo?: string;
  /** Query param: Number of minutes before current time */
  timeNow?: string;
}

export const GetDeviceFleetStatusRequest = Schema.Struct({
  deviceId: Schema.String.pipe(T.HttpPath("deviceId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  sinceMinutes: Schema.Number.pipe(T.HttpQuery("since_minutes")),
  colo: Schema.optional(Schema.String).pipe(T.HttpQuery("colo")),
  timeNow: Schema.optional(Schema.String).pipe(T.HttpQuery("time_now")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dex/devices/{deviceId}/fleet-status/live",
  }),
) as unknown as Schema.Schema<GetDeviceFleetStatusRequest>;

export interface GetDeviceFleetStatusResponse {
  /** Cloudflare colo */
  colo: string;
  /** Device identifier (UUID v4) */
  deviceId: string;
  /** The mode under which the WARP client is run */
  mode: string;
  /** Operating system */
  platform: string;
  /** Network status */
  status: string;
  /** Timestamp in ISO format */
  timestamp: string;
  /** WARP client version */
  version: string;
  alwaysOn?: boolean | null;
  batteryCharging?: boolean | null;
  batteryCycles?: number | null;
  batteryPct?: number | null;
  connectionType?: string | null;
  cpuPct?: number | null;
  cpuPctByApp?: { cpuPct?: number; name?: string }[][] | null;
  deviceIpv4?: {
    address?: string | null;
    asn?: number | null;
    aso?: string | null;
    location?: {
      city?: string | null;
      countryIso?: string | null;
      stateIso?: string | null;
      zip?: string | null;
    };
    netmask?: string | null;
    version?: string | null;
  };
  deviceIpv6?: {
    address?: string | null;
    asn?: number | null;
    aso?: string | null;
    location?: {
      city?: string | null;
      countryIso?: string | null;
      stateIso?: string | null;
      zip?: string | null;
    };
    netmask?: string | null;
    version?: string | null;
  };
  /** Device identifier (human readable) */
  deviceName?: string;
  diskReadBps?: number | null;
  diskUsagePct?: number | null;
  diskWriteBps?: number | null;
  dohSubdomain?: string | null;
  estimatedLossPct?: number | null;
  firewallEnabled?: boolean | null;
  gatewayIpv4?: {
    address?: string | null;
    asn?: number | null;
    aso?: string | null;
    location?: {
      city?: string | null;
      countryIso?: string | null;
      stateIso?: string | null;
      zip?: string | null;
    };
    netmask?: string | null;
    version?: string | null;
  };
  gatewayIpv6?: {
    address?: string | null;
    asn?: number | null;
    aso?: string | null;
    location?: {
      city?: string | null;
      countryIso?: string | null;
      stateIso?: string | null;
      zip?: string | null;
    };
    netmask?: string | null;
    version?: string | null;
  };
  handshakeLatencyMs?: number | null;
  ispIpv4?: {
    address?: string | null;
    asn?: number | null;
    aso?: string | null;
    location?: {
      city?: string | null;
      countryIso?: string | null;
      stateIso?: string | null;
      zip?: string | null;
    };
    netmask?: string | null;
    version?: string | null;
  };
  ispIpv6?: {
    address?: string | null;
    asn?: number | null;
    aso?: string | null;
    location?: {
      city?: string | null;
      countryIso?: string | null;
      stateIso?: string | null;
      zip?: string | null;
    };
    netmask?: string | null;
    version?: string | null;
  };
  metal?: string | null;
  networkRcvdBps?: number | null;
  networkSentBps?: number | null;
  networkSsid?: string | null;
  /** User contact email address */
  personEmail?: string;
  ramAvailableKb?: number | null;
  ramUsedPct?: number | null;
  ramUsedPctByApp?: { name?: string; ramUsedPct?: number }[][] | null;
  switchLocked?: boolean | null;
  wifiStrengthDbm?: number | null;
}

export const GetDeviceFleetStatusResponse = Schema.Struct({
  colo: Schema.String,
  deviceId: Schema.String,
  mode: Schema.String,
  platform: Schema.String,
  status: Schema.String,
  timestamp: Schema.String,
  version: Schema.String,
  alwaysOn: Schema.optional(Schema.Union([Schema.Boolean, Schema.Null])),
  batteryCharging: Schema.optional(Schema.Union([Schema.Boolean, Schema.Null])),
  batteryCycles: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
  batteryPct: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
  connectionType: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  cpuPct: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
  cpuPctByApp: Schema.optional(
    Schema.Union([
      Schema.Array(
        Schema.Array(
          Schema.Struct({
            cpuPct: Schema.optional(Schema.Number),
            name: Schema.optional(Schema.String),
          }).pipe(Schema.encodeKeys({ cpuPct: "cpu_pct", name: "name" })),
        ),
      ),
      Schema.Null,
    ]),
  ),
  deviceIpv4: Schema.optional(
    Schema.Struct({
      address: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      asn: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
      aso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      location: Schema.optional(
        Schema.Struct({
          city: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          countryIso: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
          stateIso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          zip: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        }).pipe(
          Schema.encodeKeys({
            city: "city",
            countryIso: "country_iso",
            stateIso: "state_iso",
            zip: "zip",
          }),
        ),
      ),
      netmask: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      version: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    }),
  ),
  deviceIpv6: Schema.optional(
    Schema.Struct({
      address: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      asn: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
      aso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      location: Schema.optional(
        Schema.Struct({
          city: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          countryIso: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
          stateIso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          zip: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        }).pipe(
          Schema.encodeKeys({
            city: "city",
            countryIso: "country_iso",
            stateIso: "state_iso",
            zip: "zip",
          }),
        ),
      ),
      netmask: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      version: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    }),
  ),
  deviceName: Schema.optional(Schema.String),
  diskReadBps: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
  diskUsagePct: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
  diskWriteBps: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
  dohSubdomain: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  estimatedLossPct: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
  firewallEnabled: Schema.optional(Schema.Union([Schema.Boolean, Schema.Null])),
  gatewayIpv4: Schema.optional(
    Schema.Struct({
      address: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      asn: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
      aso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      location: Schema.optional(
        Schema.Struct({
          city: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          countryIso: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
          stateIso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          zip: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        }).pipe(
          Schema.encodeKeys({
            city: "city",
            countryIso: "country_iso",
            stateIso: "state_iso",
            zip: "zip",
          }),
        ),
      ),
      netmask: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      version: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    }),
  ),
  gatewayIpv6: Schema.optional(
    Schema.Struct({
      address: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      asn: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
      aso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      location: Schema.optional(
        Schema.Struct({
          city: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          countryIso: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
          stateIso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          zip: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        }).pipe(
          Schema.encodeKeys({
            city: "city",
            countryIso: "country_iso",
            stateIso: "state_iso",
            zip: "zip",
          }),
        ),
      ),
      netmask: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      version: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    }),
  ),
  handshakeLatencyMs: Schema.optional(
    Schema.Union([Schema.Number, Schema.Null]),
  ),
  ispIpv4: Schema.optional(
    Schema.Struct({
      address: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      asn: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
      aso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      location: Schema.optional(
        Schema.Struct({
          city: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          countryIso: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
          stateIso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          zip: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        }).pipe(
          Schema.encodeKeys({
            city: "city",
            countryIso: "country_iso",
            stateIso: "state_iso",
            zip: "zip",
          }),
        ),
      ),
      netmask: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      version: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    }),
  ),
  ispIpv6: Schema.optional(
    Schema.Struct({
      address: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      asn: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
      aso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      location: Schema.optional(
        Schema.Struct({
          city: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          countryIso: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
          stateIso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          zip: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        }).pipe(
          Schema.encodeKeys({
            city: "city",
            countryIso: "country_iso",
            stateIso: "state_iso",
            zip: "zip",
          }),
        ),
      ),
      netmask: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      version: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    }),
  ),
  metal: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  networkRcvdBps: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
  networkSentBps: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
  networkSsid: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  personEmail: Schema.optional(Schema.String),
  ramAvailableKb: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
  ramUsedPct: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
  ramUsedPctByApp: Schema.optional(
    Schema.Union([
      Schema.Array(
        Schema.Array(
          Schema.Struct({
            name: Schema.optional(Schema.String),
            ramUsedPct: Schema.optional(Schema.Number),
          }).pipe(
            Schema.encodeKeys({ name: "name", ramUsedPct: "ram_used_pct" }),
          ),
        ),
      ),
      Schema.Null,
    ]),
  ),
  switchLocked: Schema.optional(Schema.Union([Schema.Boolean, Schema.Null])),
  wifiStrengthDbm: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
}) as unknown as Schema.Schema<GetDeviceFleetStatusResponse>;

export type GetDeviceFleetStatusError = CommonErrors;

export const getDeviceFleetStatus: API.OperationMethod<
  GetDeviceFleetStatusRequest,
  GetDeviceFleetStatusResponse,
  GetDeviceFleetStatusError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDeviceFleetStatusRequest,
  output: GetDeviceFleetStatusResponse,
  errors: [],
}));

// =============================================================================
// DeviceNetwork
// =============================================================================

export interface GetDeviceNetworkRequest {
  networkId: string;
  accountId: string;
}

export const GetDeviceNetworkRequest = Schema.Struct({
  networkId: Schema.String.pipe(T.HttpPath("networkId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/networks/{networkId}",
  }),
) as unknown as Schema.Schema<GetDeviceNetworkRequest>;

export interface GetDeviceNetworkResponse {
  /** The configuration object containing information for the WARP client to detect the managed network. */
  config?: { tlsSockaddr: string; sha256?: string };
  /** The name of the device managed network. This name must be unique. */
  name?: string;
  /** API UUID. */
  networkId?: string;
  /** The type of device managed network. */
  type?: "tls";
}

export const GetDeviceNetworkResponse = Schema.Struct({
  config: Schema.optional(
    Schema.Struct({
      tlsSockaddr: Schema.String,
      sha256: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({ tlsSockaddr: "tls_sockaddr", sha256: "sha256" }),
    ),
  ),
  name: Schema.optional(Schema.String),
  networkId: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("tls")),
}).pipe(
  Schema.encodeKeys({
    config: "config",
    name: "name",
    networkId: "network_id",
    type: "type",
  }),
) as unknown as Schema.Schema<GetDeviceNetworkResponse>;

export type GetDeviceNetworkError = CommonErrors;

export const getDeviceNetwork: API.OperationMethod<
  GetDeviceNetworkRequest,
  GetDeviceNetworkResponse,
  GetDeviceNetworkError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDeviceNetworkRequest,
  output: GetDeviceNetworkResponse,
  errors: [],
}));

export interface ListDeviceNetworksRequest {
  accountId: string;
}

export const ListDeviceNetworksRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/networks" }),
) as unknown as Schema.Schema<ListDeviceNetworksRequest>;

export type ListDeviceNetworksResponse = {
  config?: { tlsSockaddr: string; sha256?: string };
  name?: string;
  networkId?: string;
  type?: "tls";
}[];

export const ListDeviceNetworksResponse = Schema.Array(
  Schema.Struct({
    config: Schema.optional(
      Schema.Struct({
        tlsSockaddr: Schema.String,
        sha256: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({ tlsSockaddr: "tls_sockaddr", sha256: "sha256" }),
      ),
    ),
    name: Schema.optional(Schema.String),
    networkId: Schema.optional(Schema.String),
    type: Schema.optional(Schema.Literal("tls")),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      networkId: "network_id",
      type: "type",
    }),
  ),
) as unknown as Schema.Schema<ListDeviceNetworksResponse>;

export type ListDeviceNetworksError = CommonErrors;

export const listDeviceNetworks: API.OperationMethod<
  ListDeviceNetworksRequest,
  ListDeviceNetworksResponse,
  ListDeviceNetworksError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDeviceNetworksRequest,
  output: ListDeviceNetworksResponse,
  errors: [],
}));

export interface CreateDeviceNetworkRequest {
  /** Path param: */
  accountId: string;
  /** Body param: The configuration object containing information for the WARP client to detect the managed network. */
  config: { tlsSockaddr: string; sha256?: string };
  /** Body param: The name of the device managed network. This name must be unique. */
  name: string;
  /** Body param: The type of device managed network. */
  type: "tls";
}

export const CreateDeviceNetworkRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  config: Schema.Struct({
    tlsSockaddr: Schema.String,
    sha256: Schema.optional(Schema.String),
  }).pipe(Schema.encodeKeys({ tlsSockaddr: "tls_sockaddr", sha256: "sha256" })),
  name: Schema.String,
  type: Schema.Literal("tls"),
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/devices/networks" }),
) as unknown as Schema.Schema<CreateDeviceNetworkRequest>;

export interface CreateDeviceNetworkResponse {
  /** The configuration object containing information for the WARP client to detect the managed network. */
  config?: { tlsSockaddr: string; sha256?: string };
  /** The name of the device managed network. This name must be unique. */
  name?: string;
  /** API UUID. */
  networkId?: string;
  /** The type of device managed network. */
  type?: "tls";
}

export const CreateDeviceNetworkResponse = Schema.Struct({
  config: Schema.optional(
    Schema.Struct({
      tlsSockaddr: Schema.String,
      sha256: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({ tlsSockaddr: "tls_sockaddr", sha256: "sha256" }),
    ),
  ),
  name: Schema.optional(Schema.String),
  networkId: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("tls")),
}).pipe(
  Schema.encodeKeys({
    config: "config",
    name: "name",
    networkId: "network_id",
    type: "type",
  }),
) as unknown as Schema.Schema<CreateDeviceNetworkResponse>;

export type CreateDeviceNetworkError = CommonErrors;

export const createDeviceNetwork: API.OperationMethod<
  CreateDeviceNetworkRequest,
  CreateDeviceNetworkResponse,
  CreateDeviceNetworkError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDeviceNetworkRequest,
  output: CreateDeviceNetworkResponse,
  errors: [],
}));

export interface UpdateDeviceNetworkRequest {
  networkId: string;
  /** Path param: */
  accountId: string;
  /** Body param: The configuration object containing information for the WARP client to detect the managed network. */
  config?: { tlsSockaddr: string; sha256?: string };
  /** Body param: The name of the device managed network. This name must be unique. */
  name?: string;
  /** Body param: The type of device managed network. */
  type?: "tls";
}

export const UpdateDeviceNetworkRequest = Schema.Struct({
  networkId: Schema.String.pipe(T.HttpPath("networkId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  config: Schema.optional(
    Schema.Struct({
      tlsSockaddr: Schema.String,
      sha256: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({ tlsSockaddr: "tls_sockaddr", sha256: "sha256" }),
    ),
  ),
  name: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("tls")),
}).pipe(
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/devices/networks/{networkId}",
  }),
) as unknown as Schema.Schema<UpdateDeviceNetworkRequest>;

export interface UpdateDeviceNetworkResponse {
  /** The configuration object containing information for the WARP client to detect the managed network. */
  config?: { tlsSockaddr: string; sha256?: string };
  /** The name of the device managed network. This name must be unique. */
  name?: string;
  /** API UUID. */
  networkId?: string;
  /** The type of device managed network. */
  type?: "tls";
}

export const UpdateDeviceNetworkResponse = Schema.Struct({
  config: Schema.optional(
    Schema.Struct({
      tlsSockaddr: Schema.String,
      sha256: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({ tlsSockaddr: "tls_sockaddr", sha256: "sha256" }),
    ),
  ),
  name: Schema.optional(Schema.String),
  networkId: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literal("tls")),
}).pipe(
  Schema.encodeKeys({
    config: "config",
    name: "name",
    networkId: "network_id",
    type: "type",
  }),
) as unknown as Schema.Schema<UpdateDeviceNetworkResponse>;

export type UpdateDeviceNetworkError = CommonErrors;

export const updateDeviceNetwork: API.OperationMethod<
  UpdateDeviceNetworkRequest,
  UpdateDeviceNetworkResponse,
  UpdateDeviceNetworkError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDeviceNetworkRequest,
  output: UpdateDeviceNetworkResponse,
  errors: [],
}));

export interface DeleteDeviceNetworkRequest {
  networkId: string;
  accountId: string;
}

export const DeleteDeviceNetworkRequest = Schema.Struct({
  networkId: Schema.String.pipe(T.HttpPath("networkId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/networks/{networkId}",
  }),
) as unknown as Schema.Schema<DeleteDeviceNetworkRequest>;

export type DeleteDeviceNetworkResponse = {
  config?: { tlsSockaddr: string; sha256?: string };
  name?: string;
  networkId?: string;
  type?: "tls";
}[];

export const DeleteDeviceNetworkResponse = Schema.Array(
  Schema.Struct({
    config: Schema.optional(
      Schema.Struct({
        tlsSockaddr: Schema.String,
        sha256: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({ tlsSockaddr: "tls_sockaddr", sha256: "sha256" }),
      ),
    ),
    name: Schema.optional(Schema.String),
    networkId: Schema.optional(Schema.String),
    type: Schema.optional(Schema.Literal("tls")),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      networkId: "network_id",
      type: "type",
    }),
  ),
) as unknown as Schema.Schema<DeleteDeviceNetworkResponse>;

export type DeleteDeviceNetworkError = CommonErrors;

export const deleteDeviceNetwork: API.OperationMethod<
  DeleteDeviceNetworkRequest,
  DeleteDeviceNetworkResponse,
  DeleteDeviceNetworkError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDeviceNetworkRequest,
  output: DeleteDeviceNetworkResponse,
  errors: [],
}));

// =============================================================================
// DeviceOverrideCode
// =============================================================================

export interface GetDeviceOverrideCodeRequest {
  registrationId: string;
  accountId: string;
}

export const GetDeviceOverrideCodeRequest = Schema.Struct({
  registrationId: Schema.String.pipe(T.HttpPath("registrationId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/registrations/{registrationId}/override_codes",
  }),
) as unknown as Schema.Schema<GetDeviceOverrideCodeRequest>;

export interface GetDeviceOverrideCodeResponse {
  disableForTime?: Record<string, unknown>;
}

export const GetDeviceOverrideCodeResponse = Schema.Struct({
  disableForTime: Schema.optional(Schema.Struct({})),
}).pipe(
  Schema.encodeKeys({ disableForTime: "disable_for_time" }),
) as unknown as Schema.Schema<GetDeviceOverrideCodeResponse>;

export type GetDeviceOverrideCodeError = CommonErrors;

export const getDeviceOverrideCode: API.OperationMethod<
  GetDeviceOverrideCodeRequest,
  GetDeviceOverrideCodeResponse,
  GetDeviceOverrideCodeError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDeviceOverrideCodeRequest,
  output: GetDeviceOverrideCodeResponse,
  errors: [],
}));

export interface ListDeviceOverrideCodesRequest {
  deviceId: string;
  accountId: string;
}

export const ListDeviceOverrideCodesRequest = Schema.Struct({
  deviceId: Schema.String.pipe(T.HttpPath("deviceId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/{deviceId}/override_codes",
  }),
) as unknown as Schema.Schema<ListDeviceOverrideCodesRequest>;

export type ListDeviceOverrideCodesResponse = unknown[];

export const ListDeviceOverrideCodesResponse = Schema.Array(
  Schema.Unknown,
) as unknown as Schema.Schema<ListDeviceOverrideCodesResponse>;

export type ListDeviceOverrideCodesError = CommonErrors;

export const listDeviceOverrideCodes: API.OperationMethod<
  ListDeviceOverrideCodesRequest,
  ListDeviceOverrideCodesResponse,
  ListDeviceOverrideCodesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDeviceOverrideCodesRequest,
  output: ListDeviceOverrideCodesResponse,
  errors: [],
}));

// =============================================================================
// DevicePolicyCustom
// =============================================================================

export interface GetDevicePolicyCustomRequest {
  policyId: string;
  accountId: string;
}

export const GetDevicePolicyCustomRequest = Schema.Struct({
  policyId: Schema.String.pipe(T.HttpPath("policyId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/policy/{policyId}",
  }),
) as unknown as Schema.Schema<GetDevicePolicyCustomRequest>;

export type GetDevicePolicyCustomResponse = unknown;

export const GetDevicePolicyCustomResponse =
  Schema.Unknown as unknown as Schema.Schema<GetDevicePolicyCustomResponse>;

export type GetDevicePolicyCustomError = CommonErrors;

export const getDevicePolicyCustom: API.OperationMethod<
  GetDevicePolicyCustomRequest,
  GetDevicePolicyCustomResponse,
  GetDevicePolicyCustomError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDevicePolicyCustomRequest,
  output: GetDevicePolicyCustomResponse,
  errors: [],
}));

export interface ListDevicePolicyCustomsRequest {
  accountId: string;
}

export const ListDevicePolicyCustomsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/policies" }),
) as unknown as Schema.Schema<ListDevicePolicyCustomsRequest>;

export type ListDevicePolicyCustomsResponse = unknown;

export const ListDevicePolicyCustomsResponse =
  Schema.Unknown as unknown as Schema.Schema<ListDevicePolicyCustomsResponse>;

export type ListDevicePolicyCustomsError = CommonErrors;

export const listDevicePolicyCustoms: API.OperationMethod<
  ListDevicePolicyCustomsRequest,
  ListDevicePolicyCustomsResponse,
  ListDevicePolicyCustomsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDevicePolicyCustomsRequest,
  output: ListDevicePolicyCustomsResponse,
  errors: [],
}));

export interface CreateDevicePolicyCustomRequest {
  /** Path param: */
  accountId: string;
  /** Body param: The wirefilter expression to match devices. Available values: "identity.email", "identity.groups.id", "identity.groups.name", "identity.groups.email", "identity.service_token_uuid", "ident */
  match: string;
  /** Body param: The name of the device settings profile. */
  name: string;
  /** Body param: The precedence of the policy. Lower values indicate higher precedence. Policies will be evaluated in ascending order of this field. */
  precedence: number;
  /** Body param: Whether to allow the user to switch WARP between modes. */
  allowModeSwitch?: boolean;
  /** Body param: Whether to receive update notifications when a new version of the client is available. */
  allowUpdates?: boolean;
  /** Body param: Whether to allow devices to leave the organization. */
  allowedToLeave?: boolean;
  /** Body param: The amount of time in seconds to reconnect after having been disabled. */
  autoConnect?: number;
  /** Body param: Turn on the captive portal after the specified amount of time. */
  captivePortal?: number;
  /** Body param: A description of the policy. */
  description?: string;
  /** Body param: If the `dns_server` field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers unless this policy option is set to `true`. */
  disableAutoFallback?: boolean;
  /** Body param: Whether the policy will be applied to matching devices. */
  enabled?: boolean;
  /** Body param: List of routes excluded in the WARP client's tunnel. Both 'exclude' and 'include' cannot be set in the same request. */
  exclude?: unknown[];
  /** Body param: Whether to add Microsoft IPs to Split Tunnel exclusions. */
  excludeOfficeIps?: boolean;
  /** Body param: List of routes included in the WARP client's tunnel. Both 'exclude' and 'include' cannot be set in the same request. */
  include?: unknown[];
  /** Body param: The amount of time in minutes a user is allowed access to their LAN. A value of 0 will allow LAN access until the next WARP reconnection, such as a reboot or a laptop waking from sleep. No */
  lanAllowMinutes?: number;
  /** Body param: The size of the subnet for the local access network. Note that this field is omitted from the response if null or unset. */
  lanAllowSubnetSize?: number;
  /** Body param: Determines if the operating system will register WARP's local interface IP with your on-premises DNS server. */
  registerInterfaceIpWithDns?: boolean;
  /** Body param: Determines whether the WARP client indicates to SCCM that it is inside a VPN boundary. (Windows only). */
  sccmVpnBoundarySupport?: boolean;
  /** Body param: */
  serviceModeV2?: { mode?: string; port?: number };
  /** Body param: The URL to launch when the Send Feedback button is clicked. */
  supportUrl?: string;
  /** Body param: Whether to allow the user to turn off the WARP switch and disconnect the client. */
  switchLocked?: boolean;
  /** Body param: Determines which tunnel protocol to use. */
  tunnelProtocol?: string;
}

export const CreateDevicePolicyCustomRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  match: Schema.String,
  name: Schema.String,
  precedence: Schema.Number,
  allowModeSwitch: Schema.optional(Schema.Boolean),
  allowUpdates: Schema.optional(Schema.Boolean),
  allowedToLeave: Schema.optional(Schema.Boolean),
  autoConnect: Schema.optional(Schema.Number),
  captivePortal: Schema.optional(Schema.Number),
  description: Schema.optional(Schema.String),
  disableAutoFallback: Schema.optional(Schema.Boolean),
  enabled: Schema.optional(Schema.Boolean),
  exclude: Schema.optional(Schema.Array(Schema.Unknown)),
  excludeOfficeIps: Schema.optional(Schema.Boolean),
  include: Schema.optional(Schema.Array(Schema.Unknown)),
  lanAllowMinutes: Schema.optional(Schema.Number),
  lanAllowSubnetSize: Schema.optional(Schema.Number),
  registerInterfaceIpWithDns: Schema.optional(Schema.Boolean),
  sccmVpnBoundarySupport: Schema.optional(Schema.Boolean),
  serviceModeV2: Schema.optional(
    Schema.Struct({
      mode: Schema.optional(Schema.String),
      port: Schema.optional(Schema.Number),
    }),
  ),
  supportUrl: Schema.optional(Schema.String),
  switchLocked: Schema.optional(Schema.Boolean),
  tunnelProtocol: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    match: "match",
    name: "name",
    precedence: "precedence",
    allowModeSwitch: "allow_mode_switch",
    allowUpdates: "allow_updates",
    allowedToLeave: "allowed_to_leave",
    autoConnect: "auto_connect",
    captivePortal: "captive_portal",
    description: "description",
    disableAutoFallback: "disable_auto_fallback",
    enabled: "enabled",
    exclude: "exclude",
    excludeOfficeIps: "exclude_office_ips",
    include: "include",
    lanAllowMinutes: "lan_allow_minutes",
    lanAllowSubnetSize: "lan_allow_subnet_size",
    registerInterfaceIpWithDns: "register_interface_ip_with_dns",
    sccmVpnBoundarySupport: "sccm_vpn_boundary_support",
    serviceModeV2: "service_mode_v2",
    supportUrl: "support_url",
    switchLocked: "switch_locked",
    tunnelProtocol: "tunnel_protocol",
  }),
  T.Http({ method: "POST", path: "/accounts/{account_id}/devices/policy" }),
) as unknown as Schema.Schema<CreateDevicePolicyCustomRequest>;

export type CreateDevicePolicyCustomResponse = unknown;

export const CreateDevicePolicyCustomResponse =
  Schema.Unknown as unknown as Schema.Schema<CreateDevicePolicyCustomResponse>;

export type CreateDevicePolicyCustomError = CommonErrors;

export const createDevicePolicyCustom: API.OperationMethod<
  CreateDevicePolicyCustomRequest,
  CreateDevicePolicyCustomResponse,
  CreateDevicePolicyCustomError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDevicePolicyCustomRequest,
  output: CreateDevicePolicyCustomResponse,
  errors: [],
}));

export interface PatchDevicePolicyCustomRequest {
  policyId: string;
  /** Path param: */
  accountId: string;
  /** Body param: Whether to allow the user to switch WARP between modes. */
  allowModeSwitch?: boolean;
  /** Body param: Whether to receive update notifications when a new version of the client is available. */
  allowUpdates?: boolean;
  /** Body param: Whether to allow devices to leave the organization. */
  allowedToLeave?: boolean;
  /** Body param: The amount of time in seconds to reconnect after having been disabled. */
  autoConnect?: number;
  /** Body param: Turn on the captive portal after the specified amount of time. */
  captivePortal?: number;
  /** Body param: A description of the policy. */
  description?: string;
  /** Body param: If the `dns_server` field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers unless this policy option is set to `true`. */
  disableAutoFallback?: boolean;
  /** Body param: Whether the policy will be applied to matching devices. */
  enabled?: boolean;
  /** Body param: List of routes excluded in the WARP client's tunnel. Both 'exclude' and 'include' cannot be set in the same request. */
  exclude?: unknown[];
  /** Body param: Whether to add Microsoft IPs to Split Tunnel exclusions. */
  excludeOfficeIps?: boolean;
  /** Body param: List of routes included in the WARP client's tunnel. Both 'exclude' and 'include' cannot be set in the same request. */
  include?: unknown[];
  /** Body param: The amount of time in minutes a user is allowed access to their LAN. A value of 0 will allow LAN access until the next WARP reconnection, such as a reboot or a laptop waking from sleep. No */
  lanAllowMinutes?: number;
  /** Body param: The size of the subnet for the local access network. Note that this field is omitted from the response if null or unset. */
  lanAllowSubnetSize?: number;
  /** Body param: The wirefilter expression to match devices. Available values: "identity.email", "identity.groups.id", "identity.groups.name", "identity.groups.email", "identity.service_token_uuid", "ident */
  match?: string;
  /** Body param: The name of the device settings profile. */
  name?: string;
  /** Body param: The precedence of the policy. Lower values indicate higher precedence. Policies will be evaluated in ascending order of this field. */
  precedence?: number;
  /** Body param: Determines if the operating system will register WARP's local interface IP with your on-premises DNS server. */
  registerInterfaceIpWithDns?: boolean;
  /** Body param: Determines whether the WARP client indicates to SCCM that it is inside a VPN boundary. (Windows only). */
  sccmVpnBoundarySupport?: boolean;
  /** Body param: */
  serviceModeV2?: { mode?: string; port?: number };
  /** Body param: The URL to launch when the Send Feedback button is clicked. */
  supportUrl?: string;
  /** Body param: Whether to allow the user to turn off the WARP switch and disconnect the client. */
  switchLocked?: boolean;
  /** Body param: Determines which tunnel protocol to use. */
  tunnelProtocol?: string;
}

export const PatchDevicePolicyCustomRequest = Schema.Struct({
  policyId: Schema.String.pipe(T.HttpPath("policyId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  allowModeSwitch: Schema.optional(Schema.Boolean),
  allowUpdates: Schema.optional(Schema.Boolean),
  allowedToLeave: Schema.optional(Schema.Boolean),
  autoConnect: Schema.optional(Schema.Number),
  captivePortal: Schema.optional(Schema.Number),
  description: Schema.optional(Schema.String),
  disableAutoFallback: Schema.optional(Schema.Boolean),
  enabled: Schema.optional(Schema.Boolean),
  exclude: Schema.optional(Schema.Array(Schema.Unknown)),
  excludeOfficeIps: Schema.optional(Schema.Boolean),
  include: Schema.optional(Schema.Array(Schema.Unknown)),
  lanAllowMinutes: Schema.optional(Schema.Number),
  lanAllowSubnetSize: Schema.optional(Schema.Number),
  match: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  precedence: Schema.optional(Schema.Number),
  registerInterfaceIpWithDns: Schema.optional(Schema.Boolean),
  sccmVpnBoundarySupport: Schema.optional(Schema.Boolean),
  serviceModeV2: Schema.optional(
    Schema.Struct({
      mode: Schema.optional(Schema.String),
      port: Schema.optional(Schema.Number),
    }),
  ),
  supportUrl: Schema.optional(Schema.String),
  switchLocked: Schema.optional(Schema.Boolean),
  tunnelProtocol: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    allowModeSwitch: "allow_mode_switch",
    allowUpdates: "allow_updates",
    allowedToLeave: "allowed_to_leave",
    autoConnect: "auto_connect",
    captivePortal: "captive_portal",
    description: "description",
    disableAutoFallback: "disable_auto_fallback",
    enabled: "enabled",
    exclude: "exclude",
    excludeOfficeIps: "exclude_office_ips",
    include: "include",
    lanAllowMinutes: "lan_allow_minutes",
    lanAllowSubnetSize: "lan_allow_subnet_size",
    match: "match",
    name: "name",
    precedence: "precedence",
    registerInterfaceIpWithDns: "register_interface_ip_with_dns",
    sccmVpnBoundarySupport: "sccm_vpn_boundary_support",
    serviceModeV2: "service_mode_v2",
    supportUrl: "support_url",
    switchLocked: "switch_locked",
    tunnelProtocol: "tunnel_protocol",
  }),
  T.Http({
    method: "PATCH",
    path: "/accounts/{account_id}/devices/policy/{policyId}",
  }),
) as unknown as Schema.Schema<PatchDevicePolicyCustomRequest>;

export type PatchDevicePolicyCustomResponse = unknown;

export const PatchDevicePolicyCustomResponse =
  Schema.Unknown as unknown as Schema.Schema<PatchDevicePolicyCustomResponse>;

export type PatchDevicePolicyCustomError = CommonErrors;

export const patchDevicePolicyCustom: API.OperationMethod<
  PatchDevicePolicyCustomRequest,
  PatchDevicePolicyCustomResponse,
  PatchDevicePolicyCustomError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchDevicePolicyCustomRequest,
  output: PatchDevicePolicyCustomResponse,
  errors: [],
}));

export interface DeleteDevicePolicyCustomRequest {
  policyId: string;
  accountId: string;
}

export const DeleteDevicePolicyCustomRequest = Schema.Struct({
  policyId: Schema.String.pipe(T.HttpPath("policyId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/policy/{policyId}",
  }),
) as unknown as Schema.Schema<DeleteDevicePolicyCustomRequest>;

export type DeleteDevicePolicyCustomResponse = unknown;

export const DeleteDevicePolicyCustomResponse =
  Schema.Unknown as unknown as Schema.Schema<DeleteDevicePolicyCustomResponse>;

export type DeleteDevicePolicyCustomError = CommonErrors;

export const deleteDevicePolicyCustom: API.OperationMethod<
  DeleteDevicePolicyCustomRequest,
  DeleteDevicePolicyCustomResponse,
  DeleteDevicePolicyCustomError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDevicePolicyCustomRequest,
  output: DeleteDevicePolicyCustomResponse,
  errors: [],
}));

// =============================================================================
// DevicePolicyCustomExclude
// =============================================================================

export interface GetDevicePolicyCustomExcludeRequest {
  policyId: string;
  accountId: string;
}

export const GetDevicePolicyCustomExcludeRequest = Schema.Struct({
  policyId: Schema.String.pipe(T.HttpPath("policyId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/policy/{policyId}/exclude",
  }),
) as unknown as Schema.Schema<GetDevicePolicyCustomExcludeRequest>;

export type GetDevicePolicyCustomExcludeResponse = unknown;

export const GetDevicePolicyCustomExcludeResponse =
  Schema.Unknown as unknown as Schema.Schema<GetDevicePolicyCustomExcludeResponse>;

export type GetDevicePolicyCustomExcludeError = CommonErrors;

export const getDevicePolicyCustomExclude: API.OperationMethod<
  GetDevicePolicyCustomExcludeRequest,
  GetDevicePolicyCustomExcludeResponse,
  GetDevicePolicyCustomExcludeError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDevicePolicyCustomExcludeRequest,
  output: GetDevicePolicyCustomExcludeResponse,
  errors: [],
}));

export interface UpdateDevicePolicyCustomExcludeRequest {
  policyId: string;
  /** Path param: */
  accountId: string;
  /** Body param: */
  body: unknown[];
}

export const UpdateDevicePolicyCustomExcludeRequest = Schema.Struct({
  policyId: Schema.String.pipe(T.HttpPath("policyId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Unknown).pipe(T.HttpBody()),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/policy/{policyId}/exclude",
  }),
) as unknown as Schema.Schema<UpdateDevicePolicyCustomExcludeRequest>;

export type UpdateDevicePolicyCustomExcludeResponse = unknown;

export const UpdateDevicePolicyCustomExcludeResponse =
  Schema.Unknown as unknown as Schema.Schema<UpdateDevicePolicyCustomExcludeResponse>;

export type UpdateDevicePolicyCustomExcludeError = CommonErrors;

export const updateDevicePolicyCustomExclude: API.OperationMethod<
  UpdateDevicePolicyCustomExcludeRequest,
  UpdateDevicePolicyCustomExcludeResponse,
  UpdateDevicePolicyCustomExcludeError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDevicePolicyCustomExcludeRequest,
  output: UpdateDevicePolicyCustomExcludeResponse,
  errors: [],
}));

// =============================================================================
// DevicePolicyCustomFallbackDomain
// =============================================================================

export interface GetDevicePolicyCustomFallbackDomainRequest {
  policyId: string;
  accountId: string;
}

export const GetDevicePolicyCustomFallbackDomainRequest = Schema.Struct({
  policyId: Schema.String.pipe(T.HttpPath("policyId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/policy/{policyId}/fallback_domains",
  }),
) as unknown as Schema.Schema<GetDevicePolicyCustomFallbackDomainRequest>;

export type GetDevicePolicyCustomFallbackDomainResponse = unknown;

export const GetDevicePolicyCustomFallbackDomainResponse =
  Schema.Unknown as unknown as Schema.Schema<GetDevicePolicyCustomFallbackDomainResponse>;

export type GetDevicePolicyCustomFallbackDomainError = CommonErrors;

export const getDevicePolicyCustomFallbackDomain: API.OperationMethod<
  GetDevicePolicyCustomFallbackDomainRequest,
  GetDevicePolicyCustomFallbackDomainResponse,
  GetDevicePolicyCustomFallbackDomainError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDevicePolicyCustomFallbackDomainRequest,
  output: GetDevicePolicyCustomFallbackDomainResponse,
  errors: [],
}));

export interface UpdateDevicePolicyCustomFallbackDomainRequest {
  policyId: string;
  /** Path param: */
  accountId: string;
  /** Body param: */
  domains: unknown[];
}

export const UpdateDevicePolicyCustomFallbackDomainRequest = Schema.Struct({
  policyId: Schema.String.pipe(T.HttpPath("policyId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  domains: Schema.Array(Schema.Unknown),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/policy/{policyId}/fallback_domains",
  }),
) as unknown as Schema.Schema<UpdateDevicePolicyCustomFallbackDomainRequest>;

export type UpdateDevicePolicyCustomFallbackDomainResponse = unknown;

export const UpdateDevicePolicyCustomFallbackDomainResponse =
  Schema.Unknown as unknown as Schema.Schema<UpdateDevicePolicyCustomFallbackDomainResponse>;

export type UpdateDevicePolicyCustomFallbackDomainError = CommonErrors;

export const updateDevicePolicyCustomFallbackDomain: API.OperationMethod<
  UpdateDevicePolicyCustomFallbackDomainRequest,
  UpdateDevicePolicyCustomFallbackDomainResponse,
  UpdateDevicePolicyCustomFallbackDomainError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDevicePolicyCustomFallbackDomainRequest,
  output: UpdateDevicePolicyCustomFallbackDomainResponse,
  errors: [],
}));

// =============================================================================
// DevicePolicyCustomInclude
// =============================================================================

export interface GetDevicePolicyCustomIncludeRequest {
  policyId: string;
  accountId: string;
}

export const GetDevicePolicyCustomIncludeRequest = Schema.Struct({
  policyId: Schema.String.pipe(T.HttpPath("policyId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/policy/{policyId}/include",
  }),
) as unknown as Schema.Schema<GetDevicePolicyCustomIncludeRequest>;

export type GetDevicePolicyCustomIncludeResponse = unknown;

export const GetDevicePolicyCustomIncludeResponse =
  Schema.Unknown as unknown as Schema.Schema<GetDevicePolicyCustomIncludeResponse>;

export type GetDevicePolicyCustomIncludeError = CommonErrors;

export const getDevicePolicyCustomInclude: API.OperationMethod<
  GetDevicePolicyCustomIncludeRequest,
  GetDevicePolicyCustomIncludeResponse,
  GetDevicePolicyCustomIncludeError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDevicePolicyCustomIncludeRequest,
  output: GetDevicePolicyCustomIncludeResponse,
  errors: [],
}));

export interface UpdateDevicePolicyCustomIncludeRequest {
  policyId: string;
  /** Path param: */
  accountId: string;
  /** Body param: */
  body: unknown[];
}

export const UpdateDevicePolicyCustomIncludeRequest = Schema.Struct({
  policyId: Schema.String.pipe(T.HttpPath("policyId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Unknown).pipe(T.HttpBody()),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/policy/{policyId}/include",
  }),
) as unknown as Schema.Schema<UpdateDevicePolicyCustomIncludeRequest>;

export type UpdateDevicePolicyCustomIncludeResponse = unknown;

export const UpdateDevicePolicyCustomIncludeResponse =
  Schema.Unknown as unknown as Schema.Schema<UpdateDevicePolicyCustomIncludeResponse>;

export type UpdateDevicePolicyCustomIncludeError = CommonErrors;

export const updateDevicePolicyCustomInclude: API.OperationMethod<
  UpdateDevicePolicyCustomIncludeRequest,
  UpdateDevicePolicyCustomIncludeResponse,
  UpdateDevicePolicyCustomIncludeError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDevicePolicyCustomIncludeRequest,
  output: UpdateDevicePolicyCustomIncludeResponse,
  errors: [],
}));

// =============================================================================
// DevicePolicyDefault
// =============================================================================

export interface GetDevicePolicyDefaultRequest {
  accountId: string;
}

export const GetDevicePolicyDefaultRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/policy" }),
) as unknown as Schema.Schema<GetDevicePolicyDefaultRequest>;

export interface GetDevicePolicyDefaultResponse {
  /** Whether to allow the user to switch WARP between modes. */
  allowModeSwitch?: boolean;
  /** Whether to receive update notifications when a new version of the client is available. */
  allowUpdates?: boolean;
  /** Whether to allow devices to leave the organization. */
  allowedToLeave?: boolean;
  /** The amount of time in seconds to reconnect after having been disabled. */
  autoConnect?: number;
  /** Turn on the captive portal after the specified amount of time. */
  captivePortal?: number;
  /** Whether the policy will be applied to matching devices. */
  default?: boolean;
  /** If the `dns_server` field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers unless this policy option is set to `true`. */
  disableAutoFallback?: boolean;
  /** Whether the policy will be applied to matching devices. */
  enabled?: boolean;
  /** List of routes excluded in the WARP client's tunnel. */
  exclude?: unknown[];
  /** Whether to add Microsoft IPs to Split Tunnel exclusions. */
  excludeOfficeIps?: boolean;
  fallbackDomains?: unknown[];
  gatewayUniqueId?: string;
  /** List of routes included in the WARP client's tunnel. */
  include?: unknown[];
  /** Determines if the operating system will register WARP's local interface IP with your on-premises DNS server. */
  registerInterfaceIpWithDns?: boolean;
  /** Determines whether the WARP client indicates to SCCM that it is inside a VPN boundary. (Windows only). */
  sccmVpnBoundarySupport?: boolean;
  serviceModeV2?: { mode?: string; port?: number };
  /** The URL to launch when the Send Feedback button is clicked. */
  supportUrl?: string;
  /** Whether to allow the user to turn off the WARP switch and disconnect the client. */
  switchLocked?: boolean;
  /** Determines which tunnel protocol to use. */
  tunnelProtocol?: string;
}

export const GetDevicePolicyDefaultResponse = Schema.Struct({
  allowModeSwitch: Schema.optional(Schema.Boolean),
  allowUpdates: Schema.optional(Schema.Boolean),
  allowedToLeave: Schema.optional(Schema.Boolean),
  autoConnect: Schema.optional(Schema.Number),
  captivePortal: Schema.optional(Schema.Number),
  default: Schema.optional(Schema.Boolean),
  disableAutoFallback: Schema.optional(Schema.Boolean),
  enabled: Schema.optional(Schema.Boolean),
  exclude: Schema.optional(Schema.Array(Schema.Unknown)),
  excludeOfficeIps: Schema.optional(Schema.Boolean),
  fallbackDomains: Schema.optional(Schema.Array(Schema.Unknown)),
  gatewayUniqueId: Schema.optional(Schema.String),
  include: Schema.optional(Schema.Array(Schema.Unknown)),
  registerInterfaceIpWithDns: Schema.optional(Schema.Boolean),
  sccmVpnBoundarySupport: Schema.optional(Schema.Boolean),
  serviceModeV2: Schema.optional(
    Schema.Struct({
      mode: Schema.optional(Schema.String),
      port: Schema.optional(Schema.Number),
    }),
  ),
  supportUrl: Schema.optional(Schema.String),
  switchLocked: Schema.optional(Schema.Boolean),
  tunnelProtocol: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    allowModeSwitch: "allow_mode_switch",
    allowUpdates: "allow_updates",
    allowedToLeave: "allowed_to_leave",
    autoConnect: "auto_connect",
    captivePortal: "captive_portal",
    default: "default",
    disableAutoFallback: "disable_auto_fallback",
    enabled: "enabled",
    exclude: "exclude",
    excludeOfficeIps: "exclude_office_ips",
    fallbackDomains: "fallback_domains",
    gatewayUniqueId: "gateway_unique_id",
    include: "include",
    registerInterfaceIpWithDns: "register_interface_ip_with_dns",
    sccmVpnBoundarySupport: "sccm_vpn_boundary_support",
    serviceModeV2: "service_mode_v2",
    supportUrl: "support_url",
    switchLocked: "switch_locked",
    tunnelProtocol: "tunnel_protocol",
  }),
) as unknown as Schema.Schema<GetDevicePolicyDefaultResponse>;

export type GetDevicePolicyDefaultError = CommonErrors;

export const getDevicePolicyDefault: API.OperationMethod<
  GetDevicePolicyDefaultRequest,
  GetDevicePolicyDefaultResponse,
  GetDevicePolicyDefaultError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDevicePolicyDefaultRequest,
  output: GetDevicePolicyDefaultResponse,
  errors: [],
}));

export interface PatchDevicePolicyDefaultRequest {
  /** Path param: */
  accountId: string;
  /** Body param: Whether to allow the user to switch WARP between modes. */
  allowModeSwitch?: boolean;
  /** Body param: Whether to receive update notifications when a new version of the client is available. */
  allowUpdates?: boolean;
  /** Body param: Whether to allow devices to leave the organization. */
  allowedToLeave?: boolean;
  /** Body param: The amount of time in seconds to reconnect after having been disabled. */
  autoConnect?: number;
  /** Body param: Turn on the captive portal after the specified amount of time. */
  captivePortal?: number;
  /** Body param: If the `dns_server` field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers unless this policy option is set to `true`. */
  disableAutoFallback?: boolean;
  /** Body param: List of routes excluded in the WARP client's tunnel. Both 'exclude' and 'include' cannot be set in the same request. */
  exclude?: unknown[];
  /** Body param: Whether to add Microsoft IPs to Split Tunnel exclusions. */
  excludeOfficeIps?: boolean;
  /** Body param: List of routes included in the WARP client's tunnel. Both 'exclude' and 'include' cannot be set in the same request. */
  include?: unknown[];
  /** Body param: The amount of time in minutes a user is allowed access to their LAN. A value of 0 will allow LAN access until the next WARP reconnection, such as a reboot or a laptop waking from sleep. No */
  lanAllowMinutes?: number;
  /** Body param: The size of the subnet for the local access network. Note that this field is omitted from the response if null or unset. */
  lanAllowSubnetSize?: number;
  /** Body param: Determines if the operating system will register WARP's local interface IP with your on-premises DNS server. */
  registerInterfaceIpWithDns?: boolean;
  /** Body param: Determines whether the WARP client indicates to SCCM that it is inside a VPN boundary. (Windows only). */
  sccmVpnBoundarySupport?: boolean;
  /** Body param: */
  serviceModeV2?: { mode?: string; port?: number };
  /** Body param: The URL to launch when the Send Feedback button is clicked. */
  supportUrl?: string;
  /** Body param: Whether to allow the user to turn off the WARP switch and disconnect the client. */
  switchLocked?: boolean;
  /** Body param: Determines which tunnel protocol to use. */
  tunnelProtocol?: string;
}

export const PatchDevicePolicyDefaultRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  allowModeSwitch: Schema.optional(Schema.Boolean),
  allowUpdates: Schema.optional(Schema.Boolean),
  allowedToLeave: Schema.optional(Schema.Boolean),
  autoConnect: Schema.optional(Schema.Number),
  captivePortal: Schema.optional(Schema.Number),
  disableAutoFallback: Schema.optional(Schema.Boolean),
  exclude: Schema.optional(Schema.Array(Schema.Unknown)),
  excludeOfficeIps: Schema.optional(Schema.Boolean),
  include: Schema.optional(Schema.Array(Schema.Unknown)),
  lanAllowMinutes: Schema.optional(Schema.Number),
  lanAllowSubnetSize: Schema.optional(Schema.Number),
  registerInterfaceIpWithDns: Schema.optional(Schema.Boolean),
  sccmVpnBoundarySupport: Schema.optional(Schema.Boolean),
  serviceModeV2: Schema.optional(
    Schema.Struct({
      mode: Schema.optional(Schema.String),
      port: Schema.optional(Schema.Number),
    }),
  ),
  supportUrl: Schema.optional(Schema.String),
  switchLocked: Schema.optional(Schema.Boolean),
  tunnelProtocol: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    allowModeSwitch: "allow_mode_switch",
    allowUpdates: "allow_updates",
    allowedToLeave: "allowed_to_leave",
    autoConnect: "auto_connect",
    captivePortal: "captive_portal",
    disableAutoFallback: "disable_auto_fallback",
    exclude: "exclude",
    excludeOfficeIps: "exclude_office_ips",
    include: "include",
    lanAllowMinutes: "lan_allow_minutes",
    lanAllowSubnetSize: "lan_allow_subnet_size",
    registerInterfaceIpWithDns: "register_interface_ip_with_dns",
    sccmVpnBoundarySupport: "sccm_vpn_boundary_support",
    serviceModeV2: "service_mode_v2",
    supportUrl: "support_url",
    switchLocked: "switch_locked",
    tunnelProtocol: "tunnel_protocol",
  }),
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/devices/policy" }),
) as unknown as Schema.Schema<PatchDevicePolicyDefaultRequest>;

export interface PatchDevicePolicyDefaultResponse {
  /** Whether to allow the user to switch WARP between modes. */
  allowModeSwitch?: boolean;
  /** Whether to receive update notifications when a new version of the client is available. */
  allowUpdates?: boolean;
  /** Whether to allow devices to leave the organization. */
  allowedToLeave?: boolean;
  /** The amount of time in seconds to reconnect after having been disabled. */
  autoConnect?: number;
  /** Turn on the captive portal after the specified amount of time. */
  captivePortal?: number;
  /** Whether the policy will be applied to matching devices. */
  default?: boolean;
  /** If the `dns_server` field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers unless this policy option is set to `true`. */
  disableAutoFallback?: boolean;
  /** Whether the policy will be applied to matching devices. */
  enabled?: boolean;
  /** List of routes excluded in the WARP client's tunnel. */
  exclude?: unknown[];
  /** Whether to add Microsoft IPs to Split Tunnel exclusions. */
  excludeOfficeIps?: boolean;
  fallbackDomains?: unknown[];
  gatewayUniqueId?: string;
  /** List of routes included in the WARP client's tunnel. */
  include?: unknown[];
  /** Determines if the operating system will register WARP's local interface IP with your on-premises DNS server. */
  registerInterfaceIpWithDns?: boolean;
  /** Determines whether the WARP client indicates to SCCM that it is inside a VPN boundary. (Windows only). */
  sccmVpnBoundarySupport?: boolean;
  serviceModeV2?: { mode?: string; port?: number };
  /** The URL to launch when the Send Feedback button is clicked. */
  supportUrl?: string;
  /** Whether to allow the user to turn off the WARP switch and disconnect the client. */
  switchLocked?: boolean;
  /** Determines which tunnel protocol to use. */
  tunnelProtocol?: string;
}

export const PatchDevicePolicyDefaultResponse = Schema.Struct({
  allowModeSwitch: Schema.optional(Schema.Boolean),
  allowUpdates: Schema.optional(Schema.Boolean),
  allowedToLeave: Schema.optional(Schema.Boolean),
  autoConnect: Schema.optional(Schema.Number),
  captivePortal: Schema.optional(Schema.Number),
  default: Schema.optional(Schema.Boolean),
  disableAutoFallback: Schema.optional(Schema.Boolean),
  enabled: Schema.optional(Schema.Boolean),
  exclude: Schema.optional(Schema.Array(Schema.Unknown)),
  excludeOfficeIps: Schema.optional(Schema.Boolean),
  fallbackDomains: Schema.optional(Schema.Array(Schema.Unknown)),
  gatewayUniqueId: Schema.optional(Schema.String),
  include: Schema.optional(Schema.Array(Schema.Unknown)),
  registerInterfaceIpWithDns: Schema.optional(Schema.Boolean),
  sccmVpnBoundarySupport: Schema.optional(Schema.Boolean),
  serviceModeV2: Schema.optional(
    Schema.Struct({
      mode: Schema.optional(Schema.String),
      port: Schema.optional(Schema.Number),
    }),
  ),
  supportUrl: Schema.optional(Schema.String),
  switchLocked: Schema.optional(Schema.Boolean),
  tunnelProtocol: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    allowModeSwitch: "allow_mode_switch",
    allowUpdates: "allow_updates",
    allowedToLeave: "allowed_to_leave",
    autoConnect: "auto_connect",
    captivePortal: "captive_portal",
    default: "default",
    disableAutoFallback: "disable_auto_fallback",
    enabled: "enabled",
    exclude: "exclude",
    excludeOfficeIps: "exclude_office_ips",
    fallbackDomains: "fallback_domains",
    gatewayUniqueId: "gateway_unique_id",
    include: "include",
    registerInterfaceIpWithDns: "register_interface_ip_with_dns",
    sccmVpnBoundarySupport: "sccm_vpn_boundary_support",
    serviceModeV2: "service_mode_v2",
    supportUrl: "support_url",
    switchLocked: "switch_locked",
    tunnelProtocol: "tunnel_protocol",
  }),
) as unknown as Schema.Schema<PatchDevicePolicyDefaultResponse>;

export type PatchDevicePolicyDefaultError = CommonErrors;

export const patchDevicePolicyDefault: API.OperationMethod<
  PatchDevicePolicyDefaultRequest,
  PatchDevicePolicyDefaultResponse,
  PatchDevicePolicyDefaultError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchDevicePolicyDefaultRequest,
  output: PatchDevicePolicyDefaultResponse,
  errors: [],
}));

// =============================================================================
// DevicePolicyDefaultCertificate
// =============================================================================

export interface GetDevicePolicyDefaultCertificateRequest {
  zoneId: string;
}

export const GetDevicePolicyDefaultCertificateRequest = Schema.Struct({
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/zones/{zone_id}/devices/policy/certificates",
  }),
) as unknown as Schema.Schema<GetDevicePolicyDefaultCertificateRequest>;

export type GetDevicePolicyDefaultCertificateResponse = unknown;

export const GetDevicePolicyDefaultCertificateResponse =
  Schema.Unknown as unknown as Schema.Schema<GetDevicePolicyDefaultCertificateResponse>;

export type GetDevicePolicyDefaultCertificateError = CommonErrors;

export const getDevicePolicyDefaultCertificate: API.OperationMethod<
  GetDevicePolicyDefaultCertificateRequest,
  GetDevicePolicyDefaultCertificateResponse,
  GetDevicePolicyDefaultCertificateError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDevicePolicyDefaultCertificateRequest,
  output: GetDevicePolicyDefaultCertificateResponse,
  errors: [],
}));

export interface PatchDevicePolicyDefaultCertificateRequest {
  /** Path param: */
  zoneId: string;
  /** Body param: The current status of the device policy certificate provisioning feature for WARP clients. */
  enabled: boolean;
}

export const PatchDevicePolicyDefaultCertificateRequest = Schema.Struct({
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  enabled: Schema.Boolean,
}).pipe(
  T.Http({
    method: "PATCH",
    path: "/zones/{zone_id}/devices/policy/certificates",
  }),
) as unknown as Schema.Schema<PatchDevicePolicyDefaultCertificateRequest>;

export type PatchDevicePolicyDefaultCertificateResponse = unknown;

export const PatchDevicePolicyDefaultCertificateResponse =
  Schema.Unknown as unknown as Schema.Schema<PatchDevicePolicyDefaultCertificateResponse>;

export type PatchDevicePolicyDefaultCertificateError = CommonErrors;

export const patchDevicePolicyDefaultCertificate: API.OperationMethod<
  PatchDevicePolicyDefaultCertificateRequest,
  PatchDevicePolicyDefaultCertificateResponse,
  PatchDevicePolicyDefaultCertificateError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchDevicePolicyDefaultCertificateRequest,
  output: PatchDevicePolicyDefaultCertificateResponse,
  errors: [],
}));

// =============================================================================
// DevicePolicyDefaultExclude
// =============================================================================

export interface GetDevicePolicyDefaultExcludeRequest {
  accountId: string;
}

export const GetDevicePolicyDefaultExcludeRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/policy/exclude",
  }),
) as unknown as Schema.Schema<GetDevicePolicyDefaultExcludeRequest>;

export type GetDevicePolicyDefaultExcludeResponse = unknown;

export const GetDevicePolicyDefaultExcludeResponse =
  Schema.Unknown as unknown as Schema.Schema<GetDevicePolicyDefaultExcludeResponse>;

export type GetDevicePolicyDefaultExcludeError = CommonErrors;

export const getDevicePolicyDefaultExclude: API.OperationMethod<
  GetDevicePolicyDefaultExcludeRequest,
  GetDevicePolicyDefaultExcludeResponse,
  GetDevicePolicyDefaultExcludeError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDevicePolicyDefaultExcludeRequest,
  output: GetDevicePolicyDefaultExcludeResponse,
  errors: [],
}));

export interface UpdateDevicePolicyDefaultExcludeRequest {
  /** Path param: */
  accountId: string;
  /** Body param: */
  body: unknown[];
}

export const UpdateDevicePolicyDefaultExcludeRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Unknown).pipe(T.HttpBody()),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/policy/exclude",
  }),
) as unknown as Schema.Schema<UpdateDevicePolicyDefaultExcludeRequest>;

export type UpdateDevicePolicyDefaultExcludeResponse = unknown;

export const UpdateDevicePolicyDefaultExcludeResponse =
  Schema.Unknown as unknown as Schema.Schema<UpdateDevicePolicyDefaultExcludeResponse>;

export type UpdateDevicePolicyDefaultExcludeError = CommonErrors;

export const updateDevicePolicyDefaultExclude: API.OperationMethod<
  UpdateDevicePolicyDefaultExcludeRequest,
  UpdateDevicePolicyDefaultExcludeResponse,
  UpdateDevicePolicyDefaultExcludeError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDevicePolicyDefaultExcludeRequest,
  output: UpdateDevicePolicyDefaultExcludeResponse,
  errors: [],
}));

// =============================================================================
// DevicePolicyDefaultFallbackDomain
// =============================================================================

export interface GetDevicePolicyDefaultFallbackDomainRequest {
  accountId: string;
}

export const GetDevicePolicyDefaultFallbackDomainRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/policy/fallback_domains",
  }),
) as unknown as Schema.Schema<GetDevicePolicyDefaultFallbackDomainRequest>;

export type GetDevicePolicyDefaultFallbackDomainResponse = unknown;

export const GetDevicePolicyDefaultFallbackDomainResponse =
  Schema.Unknown as unknown as Schema.Schema<GetDevicePolicyDefaultFallbackDomainResponse>;

export type GetDevicePolicyDefaultFallbackDomainError = CommonErrors;

export const getDevicePolicyDefaultFallbackDomain: API.OperationMethod<
  GetDevicePolicyDefaultFallbackDomainRequest,
  GetDevicePolicyDefaultFallbackDomainResponse,
  GetDevicePolicyDefaultFallbackDomainError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDevicePolicyDefaultFallbackDomainRequest,
  output: GetDevicePolicyDefaultFallbackDomainResponse,
  errors: [],
}));

export interface UpdateDevicePolicyDefaultFallbackDomainRequest {
  /** Path param: */
  accountId: string;
  /** Body param: */
  domains: unknown[];
}

export const UpdateDevicePolicyDefaultFallbackDomainRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  domains: Schema.Array(Schema.Unknown),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/policy/fallback_domains",
  }),
) as unknown as Schema.Schema<UpdateDevicePolicyDefaultFallbackDomainRequest>;

export type UpdateDevicePolicyDefaultFallbackDomainResponse = unknown;

export const UpdateDevicePolicyDefaultFallbackDomainResponse =
  Schema.Unknown as unknown as Schema.Schema<UpdateDevicePolicyDefaultFallbackDomainResponse>;

export type UpdateDevicePolicyDefaultFallbackDomainError = CommonErrors;

export const updateDevicePolicyDefaultFallbackDomain: API.OperationMethod<
  UpdateDevicePolicyDefaultFallbackDomainRequest,
  UpdateDevicePolicyDefaultFallbackDomainResponse,
  UpdateDevicePolicyDefaultFallbackDomainError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDevicePolicyDefaultFallbackDomainRequest,
  output: UpdateDevicePolicyDefaultFallbackDomainResponse,
  errors: [],
}));

// =============================================================================
// DevicePolicyDefaultInclude
// =============================================================================

export interface GetDevicePolicyDefaultIncludeRequest {
  accountId: string;
}

export const GetDevicePolicyDefaultIncludeRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/policy/include",
  }),
) as unknown as Schema.Schema<GetDevicePolicyDefaultIncludeRequest>;

export type GetDevicePolicyDefaultIncludeResponse = unknown;

export const GetDevicePolicyDefaultIncludeResponse =
  Schema.Unknown as unknown as Schema.Schema<GetDevicePolicyDefaultIncludeResponse>;

export type GetDevicePolicyDefaultIncludeError = CommonErrors;

export const getDevicePolicyDefaultInclude: API.OperationMethod<
  GetDevicePolicyDefaultIncludeRequest,
  GetDevicePolicyDefaultIncludeResponse,
  GetDevicePolicyDefaultIncludeError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDevicePolicyDefaultIncludeRequest,
  output: GetDevicePolicyDefaultIncludeResponse,
  errors: [],
}));

export interface UpdateDevicePolicyDefaultIncludeRequest {
  /** Path param: */
  accountId: string;
  /** Body param: */
  body: unknown[];
}

export const UpdateDevicePolicyDefaultIncludeRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.Unknown).pipe(T.HttpBody()),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/policy/include",
  }),
) as unknown as Schema.Schema<UpdateDevicePolicyDefaultIncludeRequest>;

export type UpdateDevicePolicyDefaultIncludeResponse = unknown;

export const UpdateDevicePolicyDefaultIncludeResponse =
  Schema.Unknown as unknown as Schema.Schema<UpdateDevicePolicyDefaultIncludeResponse>;

export type UpdateDevicePolicyDefaultIncludeError = CommonErrors;

export const updateDevicePolicyDefaultInclude: API.OperationMethod<
  UpdateDevicePolicyDefaultIncludeRequest,
  UpdateDevicePolicyDefaultIncludeResponse,
  UpdateDevicePolicyDefaultIncludeError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDevicePolicyDefaultIncludeRequest,
  output: UpdateDevicePolicyDefaultIncludeResponse,
  errors: [],
}));

// =============================================================================
// DevicePosture
// =============================================================================

export interface GetDevicePostureRequest {
  ruleId: string;
  accountId: string;
}

export const GetDevicePostureRequest = Schema.Struct({
  ruleId: Schema.String.pipe(T.HttpPath("ruleId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/posture/{ruleId}",
  }),
) as unknown as Schema.Schema<GetDevicePostureRequest>;

export interface GetDevicePostureResponse {
  /** API UUID. */
  id?: string;
  /** The description of the device posture rule. */
  description?: string;
  /** Sets the expiration time for a posture check result. If empty, the result remains valid until it is overwritten by new data from the WARP client. */
  expiration?: string;
  /** The value to be checked against. */
  input?:
    | {
        operatingSystem: "windows" | "linux" | "mac";
        path: string;
        exists?: boolean;
        sha256?: string;
        thumbprint?: string;
      }
    | { id: string; operatingSystem: "android" | "ios" | "chromeos" }
    | { operatingSystem: "windows"; domain?: string }
    | {
        operatingSystem: "windows";
        operator: "<" | "<=" | ">" | ">=" | "==";
        version: string;
        osDistroName?: string;
        osDistroRevision?: string;
        osVersionExtra?: string;
      }
    | { enabled: boolean; operatingSystem: "windows" | "mac" }
    | {
        operatingSystem: "windows" | "linux" | "mac";
        path: string;
        sha256?: string;
        thumbprint?: string;
      }
    | { id: string }
    | { checkDisks?: string[]; requireAll?: boolean }
    | { certificateId: string; cn: string }
    | {
        certificateId: string;
        checkPrivateKey: boolean;
        operatingSystem: "windows" | "linux" | "mac";
        cn?: string;
        extendedKeyUsage?: ("clientAuth" | "emailProtection")[];
        locations?: { paths?: string[]; trustStores?: ("system" | "user")[] };
        subjectAlternativeNames?: string[];
      }
    | { updateWindowDays?: number }
    | {
        complianceStatus: "compliant" | "noncompliant" | "unknown";
        connectionId: string;
      }
    | {
        connectionId: string;
        lastSeen?: string;
        operator?: "<" | "<=" | ">" | ">=" | "==";
        os?: string;
        overall?: string;
        sensorConfig?: string;
        state?: "online" | "offline" | "unknown";
        version?: string;
        versionOperator?: "<" | "<=" | ">" | ">=" | "==";
      }
    | {
        complianceStatus:
          | "compliant"
          | "noncompliant"
          | "unknown"
          | "notapplicable"
          | "ingraceperiod"
          | "error";
        connectionId: string;
      }
    | {
        connectionId: string;
        countOperator: "<" | "<=" | ">" | ">=" | "==";
        issueCount: string;
      }
    | {
        connectionId: string;
        eidLastSeen?: string;
        operator?: "<" | "<=" | ">" | ">=" | "==";
        riskLevel?: "low" | "medium" | "high" | "critical";
        scoreOperator?: "<" | "<=" | ">" | ">=" | "==";
        totalScore?: number;
      }
    | {
        connectionId: string;
        activeThreats?: number;
        infected?: boolean;
        isActive?: boolean;
        networkStatus?:
          | "connected"
          | "disconnected"
          | "disconnecting"
          | "connecting";
        operationalState?:
          | "na"
          | "partially_disabled"
          | "auto_fully_disabled"
          | "fully_disabled"
          | "auto_partially_disabled"
          | "disabled_error"
          | "db_corruption";
        operator?: "<" | "<=" | ">" | ">=" | "==";
      }
    | {
        connectionId: string;
        operator: "<" | "<=" | ">" | ">=" | "==";
        score: number;
      };
  /** The conditions that the client must match to run the rule. */
  match?: {
    platform?: "windows" | "mac" | "linux" | "android" | "ios" | "chromeos";
  }[];
  /** The name of the device posture rule. */
  name?: string;
  /** Polling frequency for the WARP client posture check. Default: `5m` (poll every five minutes). Minimum: `1m`. */
  schedule?: string;
  /** The type of device posture rule. */
  type?:
    | "file"
    | "application"
    | "tanium"
    | "gateway"
    | "warp"
    | "disk_encryption"
    | "serial_number"
    | "sentinelone"
    | "carbonblack"
    | "firewall"
    | "os_version"
    | "domain_joined"
    | "client_certificate"
    | "client_certificate_v2"
    | "antivirus"
    | "unique_client_id"
    | "kolide"
    | "tanium_s2s"
    | "crowdstrike_s2s"
    | "intune"
    | "workspace_one"
    | "sentinelone_s2s"
    | "custom_s2s";
}

export const GetDevicePostureResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  expiration: Schema.optional(Schema.String),
  input: Schema.optional(
    Schema.Union([
      Schema.Struct({
        operatingSystem: Schema.Literals(["windows", "linux", "mac"]),
        path: Schema.String,
        exists: Schema.optional(Schema.Boolean),
        sha256: Schema.optional(Schema.String),
        thumbprint: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          path: "path",
          exists: "exists",
          sha256: "sha256",
          thumbprint: "thumbprint",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
        operatingSystem: Schema.Literals(["android", "ios", "chromeos"]),
      }).pipe(
        Schema.encodeKeys({ id: "id", operatingSystem: "operating_system" }),
      ),
      Schema.Struct({
        operatingSystem: Schema.Literal("windows"),
        domain: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          domain: "domain",
        }),
      ),
      Schema.Struct({
        operatingSystem: Schema.Literal("windows"),
        operator: Schema.Literals(["<", "<=", ">", ">=", "=="]),
        version: Schema.String,
        osDistroName: Schema.optional(Schema.String),
        osDistroRevision: Schema.optional(Schema.String),
        osVersionExtra: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          operator: "operator",
          version: "version",
          osDistroName: "os_distro_name",
          osDistroRevision: "os_distro_revision",
          osVersionExtra: "os_version_extra",
        }),
      ),
      Schema.Struct({
        enabled: Schema.Boolean,
        operatingSystem: Schema.Literals(["windows", "mac"]),
      }).pipe(
        Schema.encodeKeys({
          enabled: "enabled",
          operatingSystem: "operating_system",
        }),
      ),
      Schema.Struct({
        operatingSystem: Schema.Literals(["windows", "linux", "mac"]),
        path: Schema.String,
        sha256: Schema.optional(Schema.String),
        thumbprint: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          path: "path",
          sha256: "sha256",
          thumbprint: "thumbprint",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
      }),
      Schema.Struct({
        checkDisks: Schema.optional(Schema.Array(Schema.String)),
        requireAll: Schema.optional(Schema.Boolean),
      }),
      Schema.Struct({
        certificateId: Schema.String,
        cn: Schema.String,
      }).pipe(Schema.encodeKeys({ certificateId: "certificate_id", cn: "cn" })),
      Schema.Struct({
        certificateId: Schema.String,
        checkPrivateKey: Schema.Boolean,
        operatingSystem: Schema.Literals(["windows", "linux", "mac"]),
        cn: Schema.optional(Schema.String),
        extendedKeyUsage: Schema.optional(
          Schema.Array(Schema.Literals(["clientAuth", "emailProtection"])),
        ),
        locations: Schema.optional(
          Schema.Struct({
            paths: Schema.optional(Schema.Array(Schema.String)),
            trustStores: Schema.optional(
              Schema.Array(Schema.Literals(["system", "user"])),
            ),
          }).pipe(
            Schema.encodeKeys({ paths: "paths", trustStores: "trust_stores" }),
          ),
        ),
        subjectAlternativeNames: Schema.optional(Schema.Array(Schema.String)),
      }).pipe(
        Schema.encodeKeys({
          certificateId: "certificate_id",
          checkPrivateKey: "check_private_key",
          operatingSystem: "operating_system",
          cn: "cn",
          extendedKeyUsage: "extended_key_usage",
          locations: "locations",
          subjectAlternativeNames: "subject_alternative_names",
        }),
      ),
      Schema.Struct({
        updateWindowDays: Schema.optional(Schema.Number),
      }).pipe(Schema.encodeKeys({ updateWindowDays: "update_window_days" })),
      Schema.Struct({
        complianceStatus: Schema.Literals([
          "compliant",
          "noncompliant",
          "unknown",
        ]),
        connectionId: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          complianceStatus: "compliance_status",
          connectionId: "connection_id",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        lastSeen: Schema.optional(Schema.String),
        operator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
        os: Schema.optional(Schema.String),
        overall: Schema.optional(Schema.String),
        sensorConfig: Schema.optional(Schema.String),
        state: Schema.optional(
          Schema.Literals(["online", "offline", "unknown"]),
        ),
        version: Schema.optional(Schema.String),
        versionOperator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          lastSeen: "last_seen",
          operator: "operator",
          os: "os",
          overall: "overall",
          sensorConfig: "sensor_config",
          state: "state",
          version: "version",
          versionOperator: "versionOperator",
        }),
      ),
      Schema.Struct({
        complianceStatus: Schema.Literals([
          "compliant",
          "noncompliant",
          "unknown",
          "notapplicable",
          "ingraceperiod",
          "error",
        ]),
        connectionId: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          complianceStatus: "compliance_status",
          connectionId: "connection_id",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        countOperator: Schema.Literals(["<", "<=", ">", ">=", "=="]),
        issueCount: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          countOperator: "countOperator",
          issueCount: "issue_count",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        eidLastSeen: Schema.optional(Schema.String),
        operator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
        riskLevel: Schema.optional(
          Schema.Literals(["low", "medium", "high", "critical"]),
        ),
        scoreOperator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
        totalScore: Schema.optional(Schema.Number),
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          eidLastSeen: "eid_last_seen",
          operator: "operator",
          riskLevel: "risk_level",
          scoreOperator: "scoreOperator",
          totalScore: "total_score",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        activeThreats: Schema.optional(Schema.Number),
        infected: Schema.optional(Schema.Boolean),
        isActive: Schema.optional(Schema.Boolean),
        networkStatus: Schema.optional(
          Schema.Literals([
            "connected",
            "disconnected",
            "disconnecting",
            "connecting",
          ]),
        ),
        operationalState: Schema.optional(
          Schema.Literals([
            "na",
            "partially_disabled",
            "auto_fully_disabled",
            "fully_disabled",
            "auto_partially_disabled",
            "disabled_error",
            "db_corruption",
          ]),
        ),
        operator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          activeThreats: "active_threats",
          infected: "infected",
          isActive: "is_active",
          networkStatus: "network_status",
          operationalState: "operational_state",
          operator: "operator",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        operator: Schema.Literals(["<", "<=", ">", ">=", "=="]),
        score: Schema.Number,
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          operator: "operator",
          score: "score",
        }),
      ),
    ]),
  ),
  match: Schema.optional(
    Schema.Array(
      Schema.Struct({
        platform: Schema.optional(
          Schema.Literals([
            "windows",
            "mac",
            "linux",
            "android",
            "ios",
            "chromeos",
          ]),
        ),
      }),
    ),
  ),
  name: Schema.optional(Schema.String),
  schedule: Schema.optional(Schema.String),
  type: Schema.optional(
    Schema.Literals([
      "file",
      "application",
      "tanium",
      "gateway",
      "warp",
      "disk_encryption",
      "serial_number",
      "sentinelone",
      "carbonblack",
      "firewall",
      "os_version",
      "domain_joined",
      "client_certificate",
      "client_certificate_v2",
      "antivirus",
      "unique_client_id",
      "kolide",
      "tanium_s2s",
      "crowdstrike_s2s",
      "intune",
      "workspace_one",
      "sentinelone_s2s",
      "custom_s2s",
    ]),
  ),
}) as unknown as Schema.Schema<GetDevicePostureResponse>;

export type GetDevicePostureError = CommonErrors;

export const getDevicePosture: API.OperationMethod<
  GetDevicePostureRequest,
  GetDevicePostureResponse,
  GetDevicePostureError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDevicePostureRequest,
  output: GetDevicePostureResponse,
  errors: [],
}));

export interface ListDevicePosturesRequest {
  accountId: string;
}

export const ListDevicePosturesRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/posture" }),
) as unknown as Schema.Schema<ListDevicePosturesRequest>;

export type ListDevicePosturesResponse = {
  id?: string;
  description?: string;
  expiration?: string;
  input?:
    | {
        operatingSystem: "windows" | "linux" | "mac";
        path: string;
        exists?: boolean;
        sha256?: string;
        thumbprint?: string;
      }
    | { id: string; operatingSystem: "android" | "ios" | "chromeos" }
    | { operatingSystem: "windows"; domain?: string }
    | {
        operatingSystem: "windows";
        operator: "<" | "<=" | ">" | ">=" | "==";
        version: string;
        osDistroName?: string;
        osDistroRevision?: string;
        osVersionExtra?: string;
      }
    | { enabled: boolean; operatingSystem: "windows" | "mac" }
    | {
        operatingSystem: "windows" | "linux" | "mac";
        path: string;
        sha256?: string;
        thumbprint?: string;
      }
    | { id: string }
    | { checkDisks?: string[]; requireAll?: boolean }
    | { certificateId: string; cn: string }
    | {
        certificateId: string;
        checkPrivateKey: boolean;
        operatingSystem: "windows" | "linux" | "mac";
        cn?: string;
        extendedKeyUsage?: ("clientAuth" | "emailProtection")[];
        locations?: { paths?: string[]; trustStores?: ("system" | "user")[] };
        subjectAlternativeNames?: string[];
      }
    | { updateWindowDays?: number }
    | {
        complianceStatus: "compliant" | "noncompliant" | "unknown";
        connectionId: string;
      }
    | {
        connectionId: string;
        lastSeen?: string;
        operator?: "<" | "<=" | ">" | ">=" | "==";
        os?: string;
        overall?: string;
        sensorConfig?: string;
        state?: "online" | "offline" | "unknown";
        version?: string;
        versionOperator?: "<" | "<=" | ">" | ">=" | "==";
      }
    | {
        complianceStatus:
          | "compliant"
          | "noncompliant"
          | "unknown"
          | "notapplicable"
          | "ingraceperiod"
          | "error";
        connectionId: string;
      }
    | {
        connectionId: string;
        countOperator: "<" | "<=" | ">" | ">=" | "==";
        issueCount: string;
      }
    | {
        connectionId: string;
        eidLastSeen?: string;
        operator?: "<" | "<=" | ">" | ">=" | "==";
        riskLevel?: "low" | "medium" | "high" | "critical";
        scoreOperator?: "<" | "<=" | ">" | ">=" | "==";
        totalScore?: number;
      }
    | {
        connectionId: string;
        activeThreats?: number;
        infected?: boolean;
        isActive?: boolean;
        networkStatus?:
          | "connected"
          | "disconnected"
          | "disconnecting"
          | "connecting";
        operationalState?:
          | "na"
          | "partially_disabled"
          | "auto_fully_disabled"
          | "fully_disabled"
          | "auto_partially_disabled"
          | "disabled_error"
          | "db_corruption";
        operator?: "<" | "<=" | ">" | ">=" | "==";
      }
    | {
        connectionId: string;
        operator: "<" | "<=" | ">" | ">=" | "==";
        score: number;
      };
  match?: {
    platform?: "windows" | "mac" | "linux" | "android" | "ios" | "chromeos";
  }[];
  name?: string;
  schedule?: string;
  type?:
    | "file"
    | "application"
    | "tanium"
    | "gateway"
    | "warp"
    | "disk_encryption"
    | "serial_number"
    | "sentinelone"
    | "carbonblack"
    | "firewall"
    | "os_version"
    | "domain_joined"
    | "client_certificate"
    | "client_certificate_v2"
    | "antivirus"
    | "unique_client_id"
    | "kolide"
    | "tanium_s2s"
    | "crowdstrike_s2s"
    | "intune"
    | "workspace_one"
    | "sentinelone_s2s"
    | "custom_s2s";
}[];

export const ListDevicePosturesResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    description: Schema.optional(Schema.String),
    expiration: Schema.optional(Schema.String),
    input: Schema.optional(
      Schema.Union([
        Schema.Struct({
          operatingSystem: Schema.Literals(["windows", "linux", "mac"]),
          path: Schema.String,
          exists: Schema.optional(Schema.Boolean),
          sha256: Schema.optional(Schema.String),
          thumbprint: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            operatingSystem: "operating_system",
            path: "path",
            exists: "exists",
            sha256: "sha256",
            thumbprint: "thumbprint",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          operatingSystem: Schema.Literals(["android", "ios", "chromeos"]),
        }).pipe(
          Schema.encodeKeys({ id: "id", operatingSystem: "operating_system" }),
        ),
        Schema.Struct({
          operatingSystem: Schema.Literal("windows"),
          domain: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            operatingSystem: "operating_system",
            domain: "domain",
          }),
        ),
        Schema.Struct({
          operatingSystem: Schema.Literal("windows"),
          operator: Schema.Literals(["<", "<=", ">", ">=", "=="]),
          version: Schema.String,
          osDistroName: Schema.optional(Schema.String),
          osDistroRevision: Schema.optional(Schema.String),
          osVersionExtra: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            operatingSystem: "operating_system",
            operator: "operator",
            version: "version",
            osDistroName: "os_distro_name",
            osDistroRevision: "os_distro_revision",
            osVersionExtra: "os_version_extra",
          }),
        ),
        Schema.Struct({
          enabled: Schema.Boolean,
          operatingSystem: Schema.Literals(["windows", "mac"]),
        }).pipe(
          Schema.encodeKeys({
            enabled: "enabled",
            operatingSystem: "operating_system",
          }),
        ),
        Schema.Struct({
          operatingSystem: Schema.Literals(["windows", "linux", "mac"]),
          path: Schema.String,
          sha256: Schema.optional(Schema.String),
          thumbprint: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            operatingSystem: "operating_system",
            path: "path",
            sha256: "sha256",
            thumbprint: "thumbprint",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
        }),
        Schema.Struct({
          checkDisks: Schema.optional(Schema.Array(Schema.String)),
          requireAll: Schema.optional(Schema.Boolean),
        }),
        Schema.Struct({
          certificateId: Schema.String,
          cn: Schema.String,
        }).pipe(
          Schema.encodeKeys({ certificateId: "certificate_id", cn: "cn" }),
        ),
        Schema.Struct({
          certificateId: Schema.String,
          checkPrivateKey: Schema.Boolean,
          operatingSystem: Schema.Literals(["windows", "linux", "mac"]),
          cn: Schema.optional(Schema.String),
          extendedKeyUsage: Schema.optional(
            Schema.Array(Schema.Literals(["clientAuth", "emailProtection"])),
          ),
          locations: Schema.optional(
            Schema.Struct({
              paths: Schema.optional(Schema.Array(Schema.String)),
              trustStores: Schema.optional(
                Schema.Array(Schema.Literals(["system", "user"])),
              ),
            }).pipe(
              Schema.encodeKeys({
                paths: "paths",
                trustStores: "trust_stores",
              }),
            ),
          ),
          subjectAlternativeNames: Schema.optional(Schema.Array(Schema.String)),
        }).pipe(
          Schema.encodeKeys({
            certificateId: "certificate_id",
            checkPrivateKey: "check_private_key",
            operatingSystem: "operating_system",
            cn: "cn",
            extendedKeyUsage: "extended_key_usage",
            locations: "locations",
            subjectAlternativeNames: "subject_alternative_names",
          }),
        ),
        Schema.Struct({
          updateWindowDays: Schema.optional(Schema.Number),
        }).pipe(Schema.encodeKeys({ updateWindowDays: "update_window_days" })),
        Schema.Struct({
          complianceStatus: Schema.Literals([
            "compliant",
            "noncompliant",
            "unknown",
          ]),
          connectionId: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            complianceStatus: "compliance_status",
            connectionId: "connection_id",
          }),
        ),
        Schema.Struct({
          connectionId: Schema.String,
          lastSeen: Schema.optional(Schema.String),
          operator: Schema.optional(
            Schema.Literals(["<", "<=", ">", ">=", "=="]),
          ),
          os: Schema.optional(Schema.String),
          overall: Schema.optional(Schema.String),
          sensorConfig: Schema.optional(Schema.String),
          state: Schema.optional(
            Schema.Literals(["online", "offline", "unknown"]),
          ),
          version: Schema.optional(Schema.String),
          versionOperator: Schema.optional(
            Schema.Literals(["<", "<=", ">", ">=", "=="]),
          ),
        }).pipe(
          Schema.encodeKeys({
            connectionId: "connection_id",
            lastSeen: "last_seen",
            operator: "operator",
            os: "os",
            overall: "overall",
            sensorConfig: "sensor_config",
            state: "state",
            version: "version",
            versionOperator: "versionOperator",
          }),
        ),
        Schema.Struct({
          complianceStatus: Schema.Literals([
            "compliant",
            "noncompliant",
            "unknown",
            "notapplicable",
            "ingraceperiod",
            "error",
          ]),
          connectionId: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            complianceStatus: "compliance_status",
            connectionId: "connection_id",
          }),
        ),
        Schema.Struct({
          connectionId: Schema.String,
          countOperator: Schema.Literals(["<", "<=", ">", ">=", "=="]),
          issueCount: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            connectionId: "connection_id",
            countOperator: "countOperator",
            issueCount: "issue_count",
          }),
        ),
        Schema.Struct({
          connectionId: Schema.String,
          eidLastSeen: Schema.optional(Schema.String),
          operator: Schema.optional(
            Schema.Literals(["<", "<=", ">", ">=", "=="]),
          ),
          riskLevel: Schema.optional(
            Schema.Literals(["low", "medium", "high", "critical"]),
          ),
          scoreOperator: Schema.optional(
            Schema.Literals(["<", "<=", ">", ">=", "=="]),
          ),
          totalScore: Schema.optional(Schema.Number),
        }).pipe(
          Schema.encodeKeys({
            connectionId: "connection_id",
            eidLastSeen: "eid_last_seen",
            operator: "operator",
            riskLevel: "risk_level",
            scoreOperator: "scoreOperator",
            totalScore: "total_score",
          }),
        ),
        Schema.Struct({
          connectionId: Schema.String,
          activeThreats: Schema.optional(Schema.Number),
          infected: Schema.optional(Schema.Boolean),
          isActive: Schema.optional(Schema.Boolean),
          networkStatus: Schema.optional(
            Schema.Literals([
              "connected",
              "disconnected",
              "disconnecting",
              "connecting",
            ]),
          ),
          operationalState: Schema.optional(
            Schema.Literals([
              "na",
              "partially_disabled",
              "auto_fully_disabled",
              "fully_disabled",
              "auto_partially_disabled",
              "disabled_error",
              "db_corruption",
            ]),
          ),
          operator: Schema.optional(
            Schema.Literals(["<", "<=", ">", ">=", "=="]),
          ),
        }).pipe(
          Schema.encodeKeys({
            connectionId: "connection_id",
            activeThreats: "active_threats",
            infected: "infected",
            isActive: "is_active",
            networkStatus: "network_status",
            operationalState: "operational_state",
            operator: "operator",
          }),
        ),
        Schema.Struct({
          connectionId: Schema.String,
          operator: Schema.Literals(["<", "<=", ">", ">=", "=="]),
          score: Schema.Number,
        }).pipe(
          Schema.encodeKeys({
            connectionId: "connection_id",
            operator: "operator",
            score: "score",
          }),
        ),
      ]),
    ),
    match: Schema.optional(
      Schema.Array(
        Schema.Struct({
          platform: Schema.optional(
            Schema.Literals([
              "windows",
              "mac",
              "linux",
              "android",
              "ios",
              "chromeos",
            ]),
          ),
        }),
      ),
    ),
    name: Schema.optional(Schema.String),
    schedule: Schema.optional(Schema.String),
    type: Schema.optional(
      Schema.Literals([
        "file",
        "application",
        "tanium",
        "gateway",
        "warp",
        "disk_encryption",
        "serial_number",
        "sentinelone",
        "carbonblack",
        "firewall",
        "os_version",
        "domain_joined",
        "client_certificate",
        "client_certificate_v2",
        "antivirus",
        "unique_client_id",
        "kolide",
        "tanium_s2s",
        "crowdstrike_s2s",
        "intune",
        "workspace_one",
        "sentinelone_s2s",
        "custom_s2s",
      ]),
    ),
  }),
) as unknown as Schema.Schema<ListDevicePosturesResponse>;

export type ListDevicePosturesError = CommonErrors;

export const listDevicePostures: API.OperationMethod<
  ListDevicePosturesRequest,
  ListDevicePosturesResponse,
  ListDevicePosturesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDevicePosturesRequest,
  output: ListDevicePosturesResponse,
  errors: [],
}));

export interface CreateDevicePostureRequest {
  /** Path param: */
  accountId: string;
  /** Body param: The name of the device posture rule. */
  name: string;
  /** Body param: The type of device posture rule. */
  type:
    | "file"
    | "application"
    | "tanium"
    | "gateway"
    | "warp"
    | "disk_encryption"
    | "serial_number"
    | "sentinelone"
    | "carbonblack"
    | "firewall"
    | "os_version"
    | "domain_joined"
    | "client_certificate"
    | "client_certificate_v2"
    | "antivirus"
    | "unique_client_id"
    | "kolide"
    | "tanium_s2s"
    | "crowdstrike_s2s"
    | "intune"
    | "workspace_one"
    | "sentinelone_s2s"
    | "custom_s2s";
  /** Body param: The description of the device posture rule. */
  description?: string;
  /** Body param: Sets the expiration time for a posture check result. If empty, the result remains valid until it is overwritten by new data from the WARP client. */
  expiration?: string;
  /** Body param: The value to be checked against. */
  input?:
    | {
        operatingSystem: "windows" | "linux" | "mac";
        path: string;
        exists?: boolean;
        sha256?: string;
        thumbprint?: string;
      }
    | { id: string; operatingSystem: "android" | "ios" | "chromeos" }
    | { operatingSystem: "windows"; domain?: string }
    | {
        operatingSystem: "windows";
        operator: "<" | "<=" | ">" | ">=" | "==";
        version: string;
        osDistroName?: string;
        osDistroRevision?: string;
        osVersionExtra?: string;
      }
    | { enabled: boolean; operatingSystem: "windows" | "mac" }
    | {
        operatingSystem: "windows" | "linux" | "mac";
        path: string;
        sha256?: string;
        thumbprint?: string;
      }
    | { id: string }
    | { checkDisks?: string[]; requireAll?: boolean }
    | { certificateId: string; cn: string }
    | {
        certificateId: string;
        checkPrivateKey: boolean;
        operatingSystem: "windows" | "linux" | "mac";
        cn?: string;
        extendedKeyUsage?: ("clientAuth" | "emailProtection")[];
        locations?: { paths?: string[]; trustStores?: ("system" | "user")[] };
        subjectAlternativeNames?: string[];
      }
    | { updateWindowDays?: number }
    | {
        complianceStatus: "compliant" | "noncompliant" | "unknown";
        connectionId: string;
      }
    | {
        connectionId: string;
        lastSeen?: string;
        operator?: "<" | "<=" | ">" | ">=" | "==";
        os?: string;
        overall?: string;
        sensorConfig?: string;
        state?: "online" | "offline" | "unknown";
        version?: string;
        versionOperator?: "<" | "<=" | ">" | ">=" | "==";
      }
    | {
        complianceStatus:
          | "compliant"
          | "noncompliant"
          | "unknown"
          | "notapplicable"
          | "ingraceperiod"
          | "error";
        connectionId: string;
      }
    | {
        connectionId: string;
        countOperator: "<" | "<=" | ">" | ">=" | "==";
        issueCount: string;
      }
    | {
        connectionId: string;
        eidLastSeen?: string;
        operator?: "<" | "<=" | ">" | ">=" | "==";
        riskLevel?: "low" | "medium" | "high" | "critical";
        scoreOperator?: "<" | "<=" | ">" | ">=" | "==";
        totalScore?: number;
      }
    | {
        connectionId: string;
        activeThreats?: number;
        infected?: boolean;
        isActive?: boolean;
        networkStatus?:
          | "connected"
          | "disconnected"
          | "disconnecting"
          | "connecting";
        operationalState?:
          | "na"
          | "partially_disabled"
          | "auto_fully_disabled"
          | "fully_disabled"
          | "auto_partially_disabled"
          | "disabled_error"
          | "db_corruption";
        operator?: "<" | "<=" | ">" | ">=" | "==";
      }
    | {
        connectionId: string;
        operator: "<" | "<=" | ">" | ">=" | "==";
        score: number;
      };
  /** Body param: The conditions that the client must match to run the rule. */
  match?: {
    platform?: "windows" | "mac" | "linux" | "android" | "ios" | "chromeos";
  }[];
  /** Body param: Polling frequency for the WARP client posture check. Default: `5m` (poll every five minutes). Minimum: `1m`. */
  schedule?: string;
}

export const CreateDevicePostureRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.String,
  type: Schema.Literals([
    "file",
    "application",
    "tanium",
    "gateway",
    "warp",
    "disk_encryption",
    "serial_number",
    "sentinelone",
    "carbonblack",
    "firewall",
    "os_version",
    "domain_joined",
    "client_certificate",
    "client_certificate_v2",
    "antivirus",
    "unique_client_id",
    "kolide",
    "tanium_s2s",
    "crowdstrike_s2s",
    "intune",
    "workspace_one",
    "sentinelone_s2s",
    "custom_s2s",
  ]),
  description: Schema.optional(Schema.String),
  expiration: Schema.optional(Schema.String),
  input: Schema.optional(
    Schema.Union([
      Schema.Struct({
        operatingSystem: Schema.Literals(["windows", "linux", "mac"]),
        path: Schema.String,
        exists: Schema.optional(Schema.Boolean),
        sha256: Schema.optional(Schema.String),
        thumbprint: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          path: "path",
          exists: "exists",
          sha256: "sha256",
          thumbprint: "thumbprint",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
        operatingSystem: Schema.Literals(["android", "ios", "chromeos"]),
      }).pipe(
        Schema.encodeKeys({ id: "id", operatingSystem: "operating_system" }),
      ),
      Schema.Struct({
        operatingSystem: Schema.Literal("windows"),
        domain: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          domain: "domain",
        }),
      ),
      Schema.Struct({
        operatingSystem: Schema.Literal("windows"),
        operator: Schema.Literals(["<", "<=", ">", ">=", "=="]),
        version: Schema.String,
        osDistroName: Schema.optional(Schema.String),
        osDistroRevision: Schema.optional(Schema.String),
        osVersionExtra: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          operator: "operator",
          version: "version",
          osDistroName: "os_distro_name",
          osDistroRevision: "os_distro_revision",
          osVersionExtra: "os_version_extra",
        }),
      ),
      Schema.Struct({
        enabled: Schema.Boolean,
        operatingSystem: Schema.Literals(["windows", "mac"]),
      }).pipe(
        Schema.encodeKeys({
          enabled: "enabled",
          operatingSystem: "operating_system",
        }),
      ),
      Schema.Struct({
        operatingSystem: Schema.Literals(["windows", "linux", "mac"]),
        path: Schema.String,
        sha256: Schema.optional(Schema.String),
        thumbprint: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          path: "path",
          sha256: "sha256",
          thumbprint: "thumbprint",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
      }),
      Schema.Struct({
        checkDisks: Schema.optional(Schema.Array(Schema.String)),
        requireAll: Schema.optional(Schema.Boolean),
      }),
      Schema.Struct({
        certificateId: Schema.String,
        cn: Schema.String,
      }).pipe(Schema.encodeKeys({ certificateId: "certificate_id", cn: "cn" })),
      Schema.Struct({
        certificateId: Schema.String,
        checkPrivateKey: Schema.Boolean,
        operatingSystem: Schema.Literals(["windows", "linux", "mac"]),
        cn: Schema.optional(Schema.String),
        extendedKeyUsage: Schema.optional(
          Schema.Array(Schema.Literals(["clientAuth", "emailProtection"])),
        ),
        locations: Schema.optional(
          Schema.Struct({
            paths: Schema.optional(Schema.Array(Schema.String)),
            trustStores: Schema.optional(
              Schema.Array(Schema.Literals(["system", "user"])),
            ),
          }).pipe(
            Schema.encodeKeys({ paths: "paths", trustStores: "trust_stores" }),
          ),
        ),
        subjectAlternativeNames: Schema.optional(Schema.Array(Schema.String)),
      }).pipe(
        Schema.encodeKeys({
          certificateId: "certificate_id",
          checkPrivateKey: "check_private_key",
          operatingSystem: "operating_system",
          cn: "cn",
          extendedKeyUsage: "extended_key_usage",
          locations: "locations",
          subjectAlternativeNames: "subject_alternative_names",
        }),
      ),
      Schema.Struct({
        updateWindowDays: Schema.optional(Schema.Number),
      }).pipe(Schema.encodeKeys({ updateWindowDays: "update_window_days" })),
      Schema.Struct({
        complianceStatus: Schema.Literals([
          "compliant",
          "noncompliant",
          "unknown",
        ]),
        connectionId: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          complianceStatus: "compliance_status",
          connectionId: "connection_id",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        lastSeen: Schema.optional(Schema.String),
        operator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
        os: Schema.optional(Schema.String),
        overall: Schema.optional(Schema.String),
        sensorConfig: Schema.optional(Schema.String),
        state: Schema.optional(
          Schema.Literals(["online", "offline", "unknown"]),
        ),
        version: Schema.optional(Schema.String),
        versionOperator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          lastSeen: "last_seen",
          operator: "operator",
          os: "os",
          overall: "overall",
          sensorConfig: "sensor_config",
          state: "state",
          version: "version",
          versionOperator: "versionOperator",
        }),
      ),
      Schema.Struct({
        complianceStatus: Schema.Literals([
          "compliant",
          "noncompliant",
          "unknown",
          "notapplicable",
          "ingraceperiod",
          "error",
        ]),
        connectionId: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          complianceStatus: "compliance_status",
          connectionId: "connection_id",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        countOperator: Schema.Literals(["<", "<=", ">", ">=", "=="]),
        issueCount: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          countOperator: "countOperator",
          issueCount: "issue_count",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        eidLastSeen: Schema.optional(Schema.String),
        operator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
        riskLevel: Schema.optional(
          Schema.Literals(["low", "medium", "high", "critical"]),
        ),
        scoreOperator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
        totalScore: Schema.optional(Schema.Number),
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          eidLastSeen: "eid_last_seen",
          operator: "operator",
          riskLevel: "risk_level",
          scoreOperator: "scoreOperator",
          totalScore: "total_score",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        activeThreats: Schema.optional(Schema.Number),
        infected: Schema.optional(Schema.Boolean),
        isActive: Schema.optional(Schema.Boolean),
        networkStatus: Schema.optional(
          Schema.Literals([
            "connected",
            "disconnected",
            "disconnecting",
            "connecting",
          ]),
        ),
        operationalState: Schema.optional(
          Schema.Literals([
            "na",
            "partially_disabled",
            "auto_fully_disabled",
            "fully_disabled",
            "auto_partially_disabled",
            "disabled_error",
            "db_corruption",
          ]),
        ),
        operator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          activeThreats: "active_threats",
          infected: "infected",
          isActive: "is_active",
          networkStatus: "network_status",
          operationalState: "operational_state",
          operator: "operator",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        operator: Schema.Literals(["<", "<=", ">", ">=", "=="]),
        score: Schema.Number,
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          operator: "operator",
          score: "score",
        }),
      ),
    ]),
  ),
  match: Schema.optional(
    Schema.Array(
      Schema.Struct({
        platform: Schema.optional(
          Schema.Literals([
            "windows",
            "mac",
            "linux",
            "android",
            "ios",
            "chromeos",
          ]),
        ),
      }),
    ),
  ),
  schedule: Schema.optional(Schema.String),
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/devices/posture" }),
) as unknown as Schema.Schema<CreateDevicePostureRequest>;

export interface CreateDevicePostureResponse {
  /** API UUID. */
  id?: string;
  /** The description of the device posture rule. */
  description?: string;
  /** Sets the expiration time for a posture check result. If empty, the result remains valid until it is overwritten by new data from the WARP client. */
  expiration?: string;
  /** The value to be checked against. */
  input?:
    | {
        operatingSystem: "windows" | "linux" | "mac";
        path: string;
        exists?: boolean;
        sha256?: string;
        thumbprint?: string;
      }
    | { id: string; operatingSystem: "android" | "ios" | "chromeos" }
    | { operatingSystem: "windows"; domain?: string }
    | {
        operatingSystem: "windows";
        operator: "<" | "<=" | ">" | ">=" | "==";
        version: string;
        osDistroName?: string;
        osDistroRevision?: string;
        osVersionExtra?: string;
      }
    | { enabled: boolean; operatingSystem: "windows" | "mac" }
    | {
        operatingSystem: "windows" | "linux" | "mac";
        path: string;
        sha256?: string;
        thumbprint?: string;
      }
    | { id: string }
    | { checkDisks?: string[]; requireAll?: boolean }
    | { certificateId: string; cn: string }
    | {
        certificateId: string;
        checkPrivateKey: boolean;
        operatingSystem: "windows" | "linux" | "mac";
        cn?: string;
        extendedKeyUsage?: ("clientAuth" | "emailProtection")[];
        locations?: { paths?: string[]; trustStores?: ("system" | "user")[] };
        subjectAlternativeNames?: string[];
      }
    | { updateWindowDays?: number }
    | {
        complianceStatus: "compliant" | "noncompliant" | "unknown";
        connectionId: string;
      }
    | {
        connectionId: string;
        lastSeen?: string;
        operator?: "<" | "<=" | ">" | ">=" | "==";
        os?: string;
        overall?: string;
        sensorConfig?: string;
        state?: "online" | "offline" | "unknown";
        version?: string;
        versionOperator?: "<" | "<=" | ">" | ">=" | "==";
      }
    | {
        complianceStatus:
          | "compliant"
          | "noncompliant"
          | "unknown"
          | "notapplicable"
          | "ingraceperiod"
          | "error";
        connectionId: string;
      }
    | {
        connectionId: string;
        countOperator: "<" | "<=" | ">" | ">=" | "==";
        issueCount: string;
      }
    | {
        connectionId: string;
        eidLastSeen?: string;
        operator?: "<" | "<=" | ">" | ">=" | "==";
        riskLevel?: "low" | "medium" | "high" | "critical";
        scoreOperator?: "<" | "<=" | ">" | ">=" | "==";
        totalScore?: number;
      }
    | {
        connectionId: string;
        activeThreats?: number;
        infected?: boolean;
        isActive?: boolean;
        networkStatus?:
          | "connected"
          | "disconnected"
          | "disconnecting"
          | "connecting";
        operationalState?:
          | "na"
          | "partially_disabled"
          | "auto_fully_disabled"
          | "fully_disabled"
          | "auto_partially_disabled"
          | "disabled_error"
          | "db_corruption";
        operator?: "<" | "<=" | ">" | ">=" | "==";
      }
    | {
        connectionId: string;
        operator: "<" | "<=" | ">" | ">=" | "==";
        score: number;
      };
  /** The conditions that the client must match to run the rule. */
  match?: {
    platform?: "windows" | "mac" | "linux" | "android" | "ios" | "chromeos";
  }[];
  /** The name of the device posture rule. */
  name?: string;
  /** Polling frequency for the WARP client posture check. Default: `5m` (poll every five minutes). Minimum: `1m`. */
  schedule?: string;
  /** The type of device posture rule. */
  type?:
    | "file"
    | "application"
    | "tanium"
    | "gateway"
    | "warp"
    | "disk_encryption"
    | "serial_number"
    | "sentinelone"
    | "carbonblack"
    | "firewall"
    | "os_version"
    | "domain_joined"
    | "client_certificate"
    | "client_certificate_v2"
    | "antivirus"
    | "unique_client_id"
    | "kolide"
    | "tanium_s2s"
    | "crowdstrike_s2s"
    | "intune"
    | "workspace_one"
    | "sentinelone_s2s"
    | "custom_s2s";
}

export const CreateDevicePostureResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  expiration: Schema.optional(Schema.String),
  input: Schema.optional(
    Schema.Union([
      Schema.Struct({
        operatingSystem: Schema.Literals(["windows", "linux", "mac"]),
        path: Schema.String,
        exists: Schema.optional(Schema.Boolean),
        sha256: Schema.optional(Schema.String),
        thumbprint: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          path: "path",
          exists: "exists",
          sha256: "sha256",
          thumbprint: "thumbprint",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
        operatingSystem: Schema.Literals(["android", "ios", "chromeos"]),
      }).pipe(
        Schema.encodeKeys({ id: "id", operatingSystem: "operating_system" }),
      ),
      Schema.Struct({
        operatingSystem: Schema.Literal("windows"),
        domain: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          domain: "domain",
        }),
      ),
      Schema.Struct({
        operatingSystem: Schema.Literal("windows"),
        operator: Schema.Literals(["<", "<=", ">", ">=", "=="]),
        version: Schema.String,
        osDistroName: Schema.optional(Schema.String),
        osDistroRevision: Schema.optional(Schema.String),
        osVersionExtra: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          operator: "operator",
          version: "version",
          osDistroName: "os_distro_name",
          osDistroRevision: "os_distro_revision",
          osVersionExtra: "os_version_extra",
        }),
      ),
      Schema.Struct({
        enabled: Schema.Boolean,
        operatingSystem: Schema.Literals(["windows", "mac"]),
      }).pipe(
        Schema.encodeKeys({
          enabled: "enabled",
          operatingSystem: "operating_system",
        }),
      ),
      Schema.Struct({
        operatingSystem: Schema.Literals(["windows", "linux", "mac"]),
        path: Schema.String,
        sha256: Schema.optional(Schema.String),
        thumbprint: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          path: "path",
          sha256: "sha256",
          thumbprint: "thumbprint",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
      }),
      Schema.Struct({
        checkDisks: Schema.optional(Schema.Array(Schema.String)),
        requireAll: Schema.optional(Schema.Boolean),
      }),
      Schema.Struct({
        certificateId: Schema.String,
        cn: Schema.String,
      }).pipe(Schema.encodeKeys({ certificateId: "certificate_id", cn: "cn" })),
      Schema.Struct({
        certificateId: Schema.String,
        checkPrivateKey: Schema.Boolean,
        operatingSystem: Schema.Literals(["windows", "linux", "mac"]),
        cn: Schema.optional(Schema.String),
        extendedKeyUsage: Schema.optional(
          Schema.Array(Schema.Literals(["clientAuth", "emailProtection"])),
        ),
        locations: Schema.optional(
          Schema.Struct({
            paths: Schema.optional(Schema.Array(Schema.String)),
            trustStores: Schema.optional(
              Schema.Array(Schema.Literals(["system", "user"])),
            ),
          }).pipe(
            Schema.encodeKeys({ paths: "paths", trustStores: "trust_stores" }),
          ),
        ),
        subjectAlternativeNames: Schema.optional(Schema.Array(Schema.String)),
      }).pipe(
        Schema.encodeKeys({
          certificateId: "certificate_id",
          checkPrivateKey: "check_private_key",
          operatingSystem: "operating_system",
          cn: "cn",
          extendedKeyUsage: "extended_key_usage",
          locations: "locations",
          subjectAlternativeNames: "subject_alternative_names",
        }),
      ),
      Schema.Struct({
        updateWindowDays: Schema.optional(Schema.Number),
      }).pipe(Schema.encodeKeys({ updateWindowDays: "update_window_days" })),
      Schema.Struct({
        complianceStatus: Schema.Literals([
          "compliant",
          "noncompliant",
          "unknown",
        ]),
        connectionId: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          complianceStatus: "compliance_status",
          connectionId: "connection_id",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        lastSeen: Schema.optional(Schema.String),
        operator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
        os: Schema.optional(Schema.String),
        overall: Schema.optional(Schema.String),
        sensorConfig: Schema.optional(Schema.String),
        state: Schema.optional(
          Schema.Literals(["online", "offline", "unknown"]),
        ),
        version: Schema.optional(Schema.String),
        versionOperator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          lastSeen: "last_seen",
          operator: "operator",
          os: "os",
          overall: "overall",
          sensorConfig: "sensor_config",
          state: "state",
          version: "version",
          versionOperator: "versionOperator",
        }),
      ),
      Schema.Struct({
        complianceStatus: Schema.Literals([
          "compliant",
          "noncompliant",
          "unknown",
          "notapplicable",
          "ingraceperiod",
          "error",
        ]),
        connectionId: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          complianceStatus: "compliance_status",
          connectionId: "connection_id",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        countOperator: Schema.Literals(["<", "<=", ">", ">=", "=="]),
        issueCount: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          countOperator: "countOperator",
          issueCount: "issue_count",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        eidLastSeen: Schema.optional(Schema.String),
        operator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
        riskLevel: Schema.optional(
          Schema.Literals(["low", "medium", "high", "critical"]),
        ),
        scoreOperator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
        totalScore: Schema.optional(Schema.Number),
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          eidLastSeen: "eid_last_seen",
          operator: "operator",
          riskLevel: "risk_level",
          scoreOperator: "scoreOperator",
          totalScore: "total_score",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        activeThreats: Schema.optional(Schema.Number),
        infected: Schema.optional(Schema.Boolean),
        isActive: Schema.optional(Schema.Boolean),
        networkStatus: Schema.optional(
          Schema.Literals([
            "connected",
            "disconnected",
            "disconnecting",
            "connecting",
          ]),
        ),
        operationalState: Schema.optional(
          Schema.Literals([
            "na",
            "partially_disabled",
            "auto_fully_disabled",
            "fully_disabled",
            "auto_partially_disabled",
            "disabled_error",
            "db_corruption",
          ]),
        ),
        operator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          activeThreats: "active_threats",
          infected: "infected",
          isActive: "is_active",
          networkStatus: "network_status",
          operationalState: "operational_state",
          operator: "operator",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        operator: Schema.Literals(["<", "<=", ">", ">=", "=="]),
        score: Schema.Number,
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          operator: "operator",
          score: "score",
        }),
      ),
    ]),
  ),
  match: Schema.optional(
    Schema.Array(
      Schema.Struct({
        platform: Schema.optional(
          Schema.Literals([
            "windows",
            "mac",
            "linux",
            "android",
            "ios",
            "chromeos",
          ]),
        ),
      }),
    ),
  ),
  name: Schema.optional(Schema.String),
  schedule: Schema.optional(Schema.String),
  type: Schema.optional(
    Schema.Literals([
      "file",
      "application",
      "tanium",
      "gateway",
      "warp",
      "disk_encryption",
      "serial_number",
      "sentinelone",
      "carbonblack",
      "firewall",
      "os_version",
      "domain_joined",
      "client_certificate",
      "client_certificate_v2",
      "antivirus",
      "unique_client_id",
      "kolide",
      "tanium_s2s",
      "crowdstrike_s2s",
      "intune",
      "workspace_one",
      "sentinelone_s2s",
      "custom_s2s",
    ]),
  ),
}) as unknown as Schema.Schema<CreateDevicePostureResponse>;

export type CreateDevicePostureError = CommonErrors;

export const createDevicePosture: API.OperationMethod<
  CreateDevicePostureRequest,
  CreateDevicePostureResponse,
  CreateDevicePostureError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDevicePostureRequest,
  output: CreateDevicePostureResponse,
  errors: [],
}));

export interface UpdateDevicePostureRequest {
  ruleId: string;
  /** Path param: */
  accountId: string;
  /** Body param: The name of the device posture rule. */
  name: string;
  /** Body param: The type of device posture rule. */
  type:
    | "file"
    | "application"
    | "tanium"
    | "gateway"
    | "warp"
    | "disk_encryption"
    | "serial_number"
    | "sentinelone"
    | "carbonblack"
    | "firewall"
    | "os_version"
    | "domain_joined"
    | "client_certificate"
    | "client_certificate_v2"
    | "antivirus"
    | "unique_client_id"
    | "kolide"
    | "tanium_s2s"
    | "crowdstrike_s2s"
    | "intune"
    | "workspace_one"
    | "sentinelone_s2s"
    | "custom_s2s";
  /** Body param: The description of the device posture rule. */
  description?: string;
  /** Body param: Sets the expiration time for a posture check result. If empty, the result remains valid until it is overwritten by new data from the WARP client. */
  expiration?: string;
  /** Body param: The value to be checked against. */
  input?:
    | {
        operatingSystem: "windows" | "linux" | "mac";
        path: string;
        exists?: boolean;
        sha256?: string;
        thumbprint?: string;
      }
    | { id: string; operatingSystem: "android" | "ios" | "chromeos" }
    | { operatingSystem: "windows"; domain?: string }
    | {
        operatingSystem: "windows";
        operator: "<" | "<=" | ">" | ">=" | "==";
        version: string;
        osDistroName?: string;
        osDistroRevision?: string;
        osVersionExtra?: string;
      }
    | { enabled: boolean; operatingSystem: "windows" | "mac" }
    | {
        operatingSystem: "windows" | "linux" | "mac";
        path: string;
        sha256?: string;
        thumbprint?: string;
      }
    | { id: string }
    | { checkDisks?: string[]; requireAll?: boolean }
    | { certificateId: string; cn: string }
    | {
        certificateId: string;
        checkPrivateKey: boolean;
        operatingSystem: "windows" | "linux" | "mac";
        cn?: string;
        extendedKeyUsage?: ("clientAuth" | "emailProtection")[];
        locations?: { paths?: string[]; trustStores?: ("system" | "user")[] };
        subjectAlternativeNames?: string[];
      }
    | { updateWindowDays?: number }
    | {
        complianceStatus: "compliant" | "noncompliant" | "unknown";
        connectionId: string;
      }
    | {
        connectionId: string;
        lastSeen?: string;
        operator?: "<" | "<=" | ">" | ">=" | "==";
        os?: string;
        overall?: string;
        sensorConfig?: string;
        state?: "online" | "offline" | "unknown";
        version?: string;
        versionOperator?: "<" | "<=" | ">" | ">=" | "==";
      }
    | {
        complianceStatus:
          | "compliant"
          | "noncompliant"
          | "unknown"
          | "notapplicable"
          | "ingraceperiod"
          | "error";
        connectionId: string;
      }
    | {
        connectionId: string;
        countOperator: "<" | "<=" | ">" | ">=" | "==";
        issueCount: string;
      }
    | {
        connectionId: string;
        eidLastSeen?: string;
        operator?: "<" | "<=" | ">" | ">=" | "==";
        riskLevel?: "low" | "medium" | "high" | "critical";
        scoreOperator?: "<" | "<=" | ">" | ">=" | "==";
        totalScore?: number;
      }
    | {
        connectionId: string;
        activeThreats?: number;
        infected?: boolean;
        isActive?: boolean;
        networkStatus?:
          | "connected"
          | "disconnected"
          | "disconnecting"
          | "connecting";
        operationalState?:
          | "na"
          | "partially_disabled"
          | "auto_fully_disabled"
          | "fully_disabled"
          | "auto_partially_disabled"
          | "disabled_error"
          | "db_corruption";
        operator?: "<" | "<=" | ">" | ">=" | "==";
      }
    | {
        connectionId: string;
        operator: "<" | "<=" | ">" | ">=" | "==";
        score: number;
      };
  /** Body param: The conditions that the client must match to run the rule. */
  match?: {
    platform?: "windows" | "mac" | "linux" | "android" | "ios" | "chromeos";
  }[];
  /** Body param: Polling frequency for the WARP client posture check. Default: `5m` (poll every five minutes). Minimum: `1m`. */
  schedule?: string;
}

export const UpdateDevicePostureRequest = Schema.Struct({
  ruleId: Schema.String.pipe(T.HttpPath("ruleId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.String,
  type: Schema.Literals([
    "file",
    "application",
    "tanium",
    "gateway",
    "warp",
    "disk_encryption",
    "serial_number",
    "sentinelone",
    "carbonblack",
    "firewall",
    "os_version",
    "domain_joined",
    "client_certificate",
    "client_certificate_v2",
    "antivirus",
    "unique_client_id",
    "kolide",
    "tanium_s2s",
    "crowdstrike_s2s",
    "intune",
    "workspace_one",
    "sentinelone_s2s",
    "custom_s2s",
  ]),
  description: Schema.optional(Schema.String),
  expiration: Schema.optional(Schema.String),
  input: Schema.optional(
    Schema.Union([
      Schema.Struct({
        operatingSystem: Schema.Literals(["windows", "linux", "mac"]),
        path: Schema.String,
        exists: Schema.optional(Schema.Boolean),
        sha256: Schema.optional(Schema.String),
        thumbprint: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          path: "path",
          exists: "exists",
          sha256: "sha256",
          thumbprint: "thumbprint",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
        operatingSystem: Schema.Literals(["android", "ios", "chromeos"]),
      }).pipe(
        Schema.encodeKeys({ id: "id", operatingSystem: "operating_system" }),
      ),
      Schema.Struct({
        operatingSystem: Schema.Literal("windows"),
        domain: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          domain: "domain",
        }),
      ),
      Schema.Struct({
        operatingSystem: Schema.Literal("windows"),
        operator: Schema.Literals(["<", "<=", ">", ">=", "=="]),
        version: Schema.String,
        osDistroName: Schema.optional(Schema.String),
        osDistroRevision: Schema.optional(Schema.String),
        osVersionExtra: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          operator: "operator",
          version: "version",
          osDistroName: "os_distro_name",
          osDistroRevision: "os_distro_revision",
          osVersionExtra: "os_version_extra",
        }),
      ),
      Schema.Struct({
        enabled: Schema.Boolean,
        operatingSystem: Schema.Literals(["windows", "mac"]),
      }).pipe(
        Schema.encodeKeys({
          enabled: "enabled",
          operatingSystem: "operating_system",
        }),
      ),
      Schema.Struct({
        operatingSystem: Schema.Literals(["windows", "linux", "mac"]),
        path: Schema.String,
        sha256: Schema.optional(Schema.String),
        thumbprint: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          path: "path",
          sha256: "sha256",
          thumbprint: "thumbprint",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
      }),
      Schema.Struct({
        checkDisks: Schema.optional(Schema.Array(Schema.String)),
        requireAll: Schema.optional(Schema.Boolean),
      }),
      Schema.Struct({
        certificateId: Schema.String,
        cn: Schema.String,
      }).pipe(Schema.encodeKeys({ certificateId: "certificate_id", cn: "cn" })),
      Schema.Struct({
        certificateId: Schema.String,
        checkPrivateKey: Schema.Boolean,
        operatingSystem: Schema.Literals(["windows", "linux", "mac"]),
        cn: Schema.optional(Schema.String),
        extendedKeyUsage: Schema.optional(
          Schema.Array(Schema.Literals(["clientAuth", "emailProtection"])),
        ),
        locations: Schema.optional(
          Schema.Struct({
            paths: Schema.optional(Schema.Array(Schema.String)),
            trustStores: Schema.optional(
              Schema.Array(Schema.Literals(["system", "user"])),
            ),
          }).pipe(
            Schema.encodeKeys({ paths: "paths", trustStores: "trust_stores" }),
          ),
        ),
        subjectAlternativeNames: Schema.optional(Schema.Array(Schema.String)),
      }).pipe(
        Schema.encodeKeys({
          certificateId: "certificate_id",
          checkPrivateKey: "check_private_key",
          operatingSystem: "operating_system",
          cn: "cn",
          extendedKeyUsage: "extended_key_usage",
          locations: "locations",
          subjectAlternativeNames: "subject_alternative_names",
        }),
      ),
      Schema.Struct({
        updateWindowDays: Schema.optional(Schema.Number),
      }).pipe(Schema.encodeKeys({ updateWindowDays: "update_window_days" })),
      Schema.Struct({
        complianceStatus: Schema.Literals([
          "compliant",
          "noncompliant",
          "unknown",
        ]),
        connectionId: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          complianceStatus: "compliance_status",
          connectionId: "connection_id",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        lastSeen: Schema.optional(Schema.String),
        operator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
        os: Schema.optional(Schema.String),
        overall: Schema.optional(Schema.String),
        sensorConfig: Schema.optional(Schema.String),
        state: Schema.optional(
          Schema.Literals(["online", "offline", "unknown"]),
        ),
        version: Schema.optional(Schema.String),
        versionOperator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          lastSeen: "last_seen",
          operator: "operator",
          os: "os",
          overall: "overall",
          sensorConfig: "sensor_config",
          state: "state",
          version: "version",
          versionOperator: "versionOperator",
        }),
      ),
      Schema.Struct({
        complianceStatus: Schema.Literals([
          "compliant",
          "noncompliant",
          "unknown",
          "notapplicable",
          "ingraceperiod",
          "error",
        ]),
        connectionId: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          complianceStatus: "compliance_status",
          connectionId: "connection_id",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        countOperator: Schema.Literals(["<", "<=", ">", ">=", "=="]),
        issueCount: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          countOperator: "countOperator",
          issueCount: "issue_count",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        eidLastSeen: Schema.optional(Schema.String),
        operator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
        riskLevel: Schema.optional(
          Schema.Literals(["low", "medium", "high", "critical"]),
        ),
        scoreOperator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
        totalScore: Schema.optional(Schema.Number),
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          eidLastSeen: "eid_last_seen",
          operator: "operator",
          riskLevel: "risk_level",
          scoreOperator: "scoreOperator",
          totalScore: "total_score",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        activeThreats: Schema.optional(Schema.Number),
        infected: Schema.optional(Schema.Boolean),
        isActive: Schema.optional(Schema.Boolean),
        networkStatus: Schema.optional(
          Schema.Literals([
            "connected",
            "disconnected",
            "disconnecting",
            "connecting",
          ]),
        ),
        operationalState: Schema.optional(
          Schema.Literals([
            "na",
            "partially_disabled",
            "auto_fully_disabled",
            "fully_disabled",
            "auto_partially_disabled",
            "disabled_error",
            "db_corruption",
          ]),
        ),
        operator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          activeThreats: "active_threats",
          infected: "infected",
          isActive: "is_active",
          networkStatus: "network_status",
          operationalState: "operational_state",
          operator: "operator",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        operator: Schema.Literals(["<", "<=", ">", ">=", "=="]),
        score: Schema.Number,
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          operator: "operator",
          score: "score",
        }),
      ),
    ]),
  ),
  match: Schema.optional(
    Schema.Array(
      Schema.Struct({
        platform: Schema.optional(
          Schema.Literals([
            "windows",
            "mac",
            "linux",
            "android",
            "ios",
            "chromeos",
          ]),
        ),
      }),
    ),
  ),
  schedule: Schema.optional(Schema.String),
}).pipe(
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/devices/posture/{ruleId}",
  }),
) as unknown as Schema.Schema<UpdateDevicePostureRequest>;

export interface UpdateDevicePostureResponse {
  /** API UUID. */
  id?: string;
  /** The description of the device posture rule. */
  description?: string;
  /** Sets the expiration time for a posture check result. If empty, the result remains valid until it is overwritten by new data from the WARP client. */
  expiration?: string;
  /** The value to be checked against. */
  input?:
    | {
        operatingSystem: "windows" | "linux" | "mac";
        path: string;
        exists?: boolean;
        sha256?: string;
        thumbprint?: string;
      }
    | { id: string; operatingSystem: "android" | "ios" | "chromeos" }
    | { operatingSystem: "windows"; domain?: string }
    | {
        operatingSystem: "windows";
        operator: "<" | "<=" | ">" | ">=" | "==";
        version: string;
        osDistroName?: string;
        osDistroRevision?: string;
        osVersionExtra?: string;
      }
    | { enabled: boolean; operatingSystem: "windows" | "mac" }
    | {
        operatingSystem: "windows" | "linux" | "mac";
        path: string;
        sha256?: string;
        thumbprint?: string;
      }
    | { id: string }
    | { checkDisks?: string[]; requireAll?: boolean }
    | { certificateId: string; cn: string }
    | {
        certificateId: string;
        checkPrivateKey: boolean;
        operatingSystem: "windows" | "linux" | "mac";
        cn?: string;
        extendedKeyUsage?: ("clientAuth" | "emailProtection")[];
        locations?: { paths?: string[]; trustStores?: ("system" | "user")[] };
        subjectAlternativeNames?: string[];
      }
    | { updateWindowDays?: number }
    | {
        complianceStatus: "compliant" | "noncompliant" | "unknown";
        connectionId: string;
      }
    | {
        connectionId: string;
        lastSeen?: string;
        operator?: "<" | "<=" | ">" | ">=" | "==";
        os?: string;
        overall?: string;
        sensorConfig?: string;
        state?: "online" | "offline" | "unknown";
        version?: string;
        versionOperator?: "<" | "<=" | ">" | ">=" | "==";
      }
    | {
        complianceStatus:
          | "compliant"
          | "noncompliant"
          | "unknown"
          | "notapplicable"
          | "ingraceperiod"
          | "error";
        connectionId: string;
      }
    | {
        connectionId: string;
        countOperator: "<" | "<=" | ">" | ">=" | "==";
        issueCount: string;
      }
    | {
        connectionId: string;
        eidLastSeen?: string;
        operator?: "<" | "<=" | ">" | ">=" | "==";
        riskLevel?: "low" | "medium" | "high" | "critical";
        scoreOperator?: "<" | "<=" | ">" | ">=" | "==";
        totalScore?: number;
      }
    | {
        connectionId: string;
        activeThreats?: number;
        infected?: boolean;
        isActive?: boolean;
        networkStatus?:
          | "connected"
          | "disconnected"
          | "disconnecting"
          | "connecting";
        operationalState?:
          | "na"
          | "partially_disabled"
          | "auto_fully_disabled"
          | "fully_disabled"
          | "auto_partially_disabled"
          | "disabled_error"
          | "db_corruption";
        operator?: "<" | "<=" | ">" | ">=" | "==";
      }
    | {
        connectionId: string;
        operator: "<" | "<=" | ">" | ">=" | "==";
        score: number;
      };
  /** The conditions that the client must match to run the rule. */
  match?: {
    platform?: "windows" | "mac" | "linux" | "android" | "ios" | "chromeos";
  }[];
  /** The name of the device posture rule. */
  name?: string;
  /** Polling frequency for the WARP client posture check. Default: `5m` (poll every five minutes). Minimum: `1m`. */
  schedule?: string;
  /** The type of device posture rule. */
  type?:
    | "file"
    | "application"
    | "tanium"
    | "gateway"
    | "warp"
    | "disk_encryption"
    | "serial_number"
    | "sentinelone"
    | "carbonblack"
    | "firewall"
    | "os_version"
    | "domain_joined"
    | "client_certificate"
    | "client_certificate_v2"
    | "antivirus"
    | "unique_client_id"
    | "kolide"
    | "tanium_s2s"
    | "crowdstrike_s2s"
    | "intune"
    | "workspace_one"
    | "sentinelone_s2s"
    | "custom_s2s";
}

export const UpdateDevicePostureResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  expiration: Schema.optional(Schema.String),
  input: Schema.optional(
    Schema.Union([
      Schema.Struct({
        operatingSystem: Schema.Literals(["windows", "linux", "mac"]),
        path: Schema.String,
        exists: Schema.optional(Schema.Boolean),
        sha256: Schema.optional(Schema.String),
        thumbprint: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          path: "path",
          exists: "exists",
          sha256: "sha256",
          thumbprint: "thumbprint",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
        operatingSystem: Schema.Literals(["android", "ios", "chromeos"]),
      }).pipe(
        Schema.encodeKeys({ id: "id", operatingSystem: "operating_system" }),
      ),
      Schema.Struct({
        operatingSystem: Schema.Literal("windows"),
        domain: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          domain: "domain",
        }),
      ),
      Schema.Struct({
        operatingSystem: Schema.Literal("windows"),
        operator: Schema.Literals(["<", "<=", ">", ">=", "=="]),
        version: Schema.String,
        osDistroName: Schema.optional(Schema.String),
        osDistroRevision: Schema.optional(Schema.String),
        osVersionExtra: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          operator: "operator",
          version: "version",
          osDistroName: "os_distro_name",
          osDistroRevision: "os_distro_revision",
          osVersionExtra: "os_version_extra",
        }),
      ),
      Schema.Struct({
        enabled: Schema.Boolean,
        operatingSystem: Schema.Literals(["windows", "mac"]),
      }).pipe(
        Schema.encodeKeys({
          enabled: "enabled",
          operatingSystem: "operating_system",
        }),
      ),
      Schema.Struct({
        operatingSystem: Schema.Literals(["windows", "linux", "mac"]),
        path: Schema.String,
        sha256: Schema.optional(Schema.String),
        thumbprint: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          operatingSystem: "operating_system",
          path: "path",
          sha256: "sha256",
          thumbprint: "thumbprint",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
      }),
      Schema.Struct({
        checkDisks: Schema.optional(Schema.Array(Schema.String)),
        requireAll: Schema.optional(Schema.Boolean),
      }),
      Schema.Struct({
        certificateId: Schema.String,
        cn: Schema.String,
      }).pipe(Schema.encodeKeys({ certificateId: "certificate_id", cn: "cn" })),
      Schema.Struct({
        certificateId: Schema.String,
        checkPrivateKey: Schema.Boolean,
        operatingSystem: Schema.Literals(["windows", "linux", "mac"]),
        cn: Schema.optional(Schema.String),
        extendedKeyUsage: Schema.optional(
          Schema.Array(Schema.Literals(["clientAuth", "emailProtection"])),
        ),
        locations: Schema.optional(
          Schema.Struct({
            paths: Schema.optional(Schema.Array(Schema.String)),
            trustStores: Schema.optional(
              Schema.Array(Schema.Literals(["system", "user"])),
            ),
          }).pipe(
            Schema.encodeKeys({ paths: "paths", trustStores: "trust_stores" }),
          ),
        ),
        subjectAlternativeNames: Schema.optional(Schema.Array(Schema.String)),
      }).pipe(
        Schema.encodeKeys({
          certificateId: "certificate_id",
          checkPrivateKey: "check_private_key",
          operatingSystem: "operating_system",
          cn: "cn",
          extendedKeyUsage: "extended_key_usage",
          locations: "locations",
          subjectAlternativeNames: "subject_alternative_names",
        }),
      ),
      Schema.Struct({
        updateWindowDays: Schema.optional(Schema.Number),
      }).pipe(Schema.encodeKeys({ updateWindowDays: "update_window_days" })),
      Schema.Struct({
        complianceStatus: Schema.Literals([
          "compliant",
          "noncompliant",
          "unknown",
        ]),
        connectionId: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          complianceStatus: "compliance_status",
          connectionId: "connection_id",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        lastSeen: Schema.optional(Schema.String),
        operator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
        os: Schema.optional(Schema.String),
        overall: Schema.optional(Schema.String),
        sensorConfig: Schema.optional(Schema.String),
        state: Schema.optional(
          Schema.Literals(["online", "offline", "unknown"]),
        ),
        version: Schema.optional(Schema.String),
        versionOperator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          lastSeen: "last_seen",
          operator: "operator",
          os: "os",
          overall: "overall",
          sensorConfig: "sensor_config",
          state: "state",
          version: "version",
          versionOperator: "versionOperator",
        }),
      ),
      Schema.Struct({
        complianceStatus: Schema.Literals([
          "compliant",
          "noncompliant",
          "unknown",
          "notapplicable",
          "ingraceperiod",
          "error",
        ]),
        connectionId: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          complianceStatus: "compliance_status",
          connectionId: "connection_id",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        countOperator: Schema.Literals(["<", "<=", ">", ">=", "=="]),
        issueCount: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          countOperator: "countOperator",
          issueCount: "issue_count",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        eidLastSeen: Schema.optional(Schema.String),
        operator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
        riskLevel: Schema.optional(
          Schema.Literals(["low", "medium", "high", "critical"]),
        ),
        scoreOperator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
        totalScore: Schema.optional(Schema.Number),
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          eidLastSeen: "eid_last_seen",
          operator: "operator",
          riskLevel: "risk_level",
          scoreOperator: "scoreOperator",
          totalScore: "total_score",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        activeThreats: Schema.optional(Schema.Number),
        infected: Schema.optional(Schema.Boolean),
        isActive: Schema.optional(Schema.Boolean),
        networkStatus: Schema.optional(
          Schema.Literals([
            "connected",
            "disconnected",
            "disconnecting",
            "connecting",
          ]),
        ),
        operationalState: Schema.optional(
          Schema.Literals([
            "na",
            "partially_disabled",
            "auto_fully_disabled",
            "fully_disabled",
            "auto_partially_disabled",
            "disabled_error",
            "db_corruption",
          ]),
        ),
        operator: Schema.optional(
          Schema.Literals(["<", "<=", ">", ">=", "=="]),
        ),
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          activeThreats: "active_threats",
          infected: "infected",
          isActive: "is_active",
          networkStatus: "network_status",
          operationalState: "operational_state",
          operator: "operator",
        }),
      ),
      Schema.Struct({
        connectionId: Schema.String,
        operator: Schema.Literals(["<", "<=", ">", ">=", "=="]),
        score: Schema.Number,
      }).pipe(
        Schema.encodeKeys({
          connectionId: "connection_id",
          operator: "operator",
          score: "score",
        }),
      ),
    ]),
  ),
  match: Schema.optional(
    Schema.Array(
      Schema.Struct({
        platform: Schema.optional(
          Schema.Literals([
            "windows",
            "mac",
            "linux",
            "android",
            "ios",
            "chromeos",
          ]),
        ),
      }),
    ),
  ),
  name: Schema.optional(Schema.String),
  schedule: Schema.optional(Schema.String),
  type: Schema.optional(
    Schema.Literals([
      "file",
      "application",
      "tanium",
      "gateway",
      "warp",
      "disk_encryption",
      "serial_number",
      "sentinelone",
      "carbonblack",
      "firewall",
      "os_version",
      "domain_joined",
      "client_certificate",
      "client_certificate_v2",
      "antivirus",
      "unique_client_id",
      "kolide",
      "tanium_s2s",
      "crowdstrike_s2s",
      "intune",
      "workspace_one",
      "sentinelone_s2s",
      "custom_s2s",
    ]),
  ),
}) as unknown as Schema.Schema<UpdateDevicePostureResponse>;

export type UpdateDevicePostureError = CommonErrors;

export const updateDevicePosture: API.OperationMethod<
  UpdateDevicePostureRequest,
  UpdateDevicePostureResponse,
  UpdateDevicePostureError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDevicePostureRequest,
  output: UpdateDevicePostureResponse,
  errors: [],
}));

export interface DeleteDevicePostureRequest {
  ruleId: string;
  accountId: string;
}

export const DeleteDevicePostureRequest = Schema.Struct({
  ruleId: Schema.String.pipe(T.HttpPath("ruleId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/devices/posture/{ruleId}",
  }),
) as unknown as Schema.Schema<DeleteDevicePostureRequest>;

export interface DeleteDevicePostureResponse {
  /** API UUID. */
  id?: string;
}

export const DeleteDevicePostureResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
}) as unknown as Schema.Schema<DeleteDevicePostureResponse>;

export type DeleteDevicePostureError = CommonErrors;

export const deleteDevicePosture: API.OperationMethod<
  DeleteDevicePostureRequest,
  DeleteDevicePostureResponse,
  DeleteDevicePostureError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDevicePostureRequest,
  output: DeleteDevicePostureResponse,
  errors: [],
}));

// =============================================================================
// DevicePostureIntegration
// =============================================================================

export interface GetDevicePostureIntegrationRequest {
  integrationId: string;
  accountId: string;
}

export const GetDevicePostureIntegrationRequest = Schema.Struct({
  integrationId: Schema.String.pipe(T.HttpPath("integrationId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/posture/integration/{integrationId}",
  }),
) as unknown as Schema.Schema<GetDevicePostureIntegrationRequest>;

export interface GetDevicePostureIntegrationResponse {
  /** API UUID. */
  id?: string;
  /** The configuration object containing third-party integration information. */
  config?: { apiUrl: string; authUrl: string; clientId: string };
  /** The interval between each posture check with the third-party API. Use `m` for minutes (e.g. `5m`) and `h` for hours (e.g. `12h`). */
  interval?: string;
  /** The name of the device posture integration. */
  name?: string;
  /** The type of device posture integration. */
  type?:
    | "workspace_one"
    | "crowdstrike_s2s"
    | "uptycs"
    | "intune"
    | "kolide"
    | "tanium_s2s"
    | "sentinelone_s2s"
    | "custom_s2s";
}

export const GetDevicePostureIntegrationResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  config: Schema.optional(
    Schema.Struct({
      apiUrl: Schema.String,
      authUrl: Schema.String,
      clientId: Schema.String,
    }).pipe(
      Schema.encodeKeys({
        apiUrl: "api_url",
        authUrl: "auth_url",
        clientId: "client_id",
      }),
    ),
  ),
  interval: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  type: Schema.optional(
    Schema.Literals([
      "workspace_one",
      "crowdstrike_s2s",
      "uptycs",
      "intune",
      "kolide",
      "tanium_s2s",
      "sentinelone_s2s",
      "custom_s2s",
    ]),
  ),
}) as unknown as Schema.Schema<GetDevicePostureIntegrationResponse>;

export type GetDevicePostureIntegrationError = CommonErrors;

export const getDevicePostureIntegration: API.OperationMethod<
  GetDevicePostureIntegrationRequest,
  GetDevicePostureIntegrationResponse,
  GetDevicePostureIntegrationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDevicePostureIntegrationRequest,
  output: GetDevicePostureIntegrationResponse,
  errors: [],
}));

export interface ListDevicePostureIntegrationsRequest {
  accountId: string;
}

export const ListDevicePostureIntegrationsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/posture/integration",
  }),
) as unknown as Schema.Schema<ListDevicePostureIntegrationsRequest>;

export type ListDevicePostureIntegrationsResponse = {
  id?: string;
  config?: { apiUrl: string; authUrl: string; clientId: string };
  interval?: string;
  name?: string;
  type?:
    | "workspace_one"
    | "crowdstrike_s2s"
    | "uptycs"
    | "intune"
    | "kolide"
    | "tanium_s2s"
    | "sentinelone_s2s"
    | "custom_s2s";
}[];

export const ListDevicePostureIntegrationsResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    config: Schema.optional(
      Schema.Struct({
        apiUrl: Schema.String,
        authUrl: Schema.String,
        clientId: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          apiUrl: "api_url",
          authUrl: "auth_url",
          clientId: "client_id",
        }),
      ),
    ),
    interval: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    type: Schema.optional(
      Schema.Literals([
        "workspace_one",
        "crowdstrike_s2s",
        "uptycs",
        "intune",
        "kolide",
        "tanium_s2s",
        "sentinelone_s2s",
        "custom_s2s",
      ]),
    ),
  }),
) as unknown as Schema.Schema<ListDevicePostureIntegrationsResponse>;

export type ListDevicePostureIntegrationsError = CommonErrors;

export const listDevicePostureIntegrations: API.OperationMethod<
  ListDevicePostureIntegrationsRequest,
  ListDevicePostureIntegrationsResponse,
  ListDevicePostureIntegrationsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDevicePostureIntegrationsRequest,
  output: ListDevicePostureIntegrationsResponse,
  errors: [],
}));

export interface CreateDevicePostureIntegrationRequest {
  /** Path param: */
  accountId: string;
  /** Body param: The configuration object containing third-party integration information. */
  config:
    | {
        apiUrl: string;
        authUrl: string;
        clientId: string;
        clientSecret: string;
      }
    | {
        apiUrl: string;
        clientId: string;
        clientSecret: string;
        customerId: string;
      }
    | {
        apiUrl: string;
        clientKey: string;
        clientSecret: string;
        customerId: string;
      }
    | { clientId: string; clientSecret: string; customerId: string }
    | { clientId: string; clientSecret: string }
    | {
        apiUrl: string;
        clientSecret: string;
        accessClientId?: string;
        accessClientSecret?: string;
      }
    | { apiUrl: string; clientSecret: string }
    | { accessClientId: string; accessClientSecret: string; apiUrl: string };
  /** Body param: The interval between each posture check with the third-party API. Use `m` for minutes (e.g. `5m`) and `h` for hours (e.g. `12h`). */
  interval: string;
  /** Body param: The name of the device posture integration. */
  name: string;
  /** Body param: The type of device posture integration. */
  type:
    | "workspace_one"
    | "crowdstrike_s2s"
    | "uptycs"
    | "intune"
    | "kolide"
    | "tanium_s2s"
    | "sentinelone_s2s"
    | "custom_s2s";
}

export const CreateDevicePostureIntegrationRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  config: Schema.Union([
    Schema.Struct({
      apiUrl: Schema.String,
      authUrl: Schema.String,
      clientId: Schema.String,
      clientSecret: Schema.String,
    }).pipe(
      Schema.encodeKeys({
        apiUrl: "api_url",
        authUrl: "auth_url",
        clientId: "client_id",
        clientSecret: "client_secret",
      }),
    ),
    Schema.Struct({
      apiUrl: Schema.String,
      clientId: Schema.String,
      clientSecret: Schema.String,
      customerId: Schema.String,
    }).pipe(
      Schema.encodeKeys({
        apiUrl: "api_url",
        clientId: "client_id",
        clientSecret: "client_secret",
        customerId: "customer_id",
      }),
    ),
    Schema.Struct({
      apiUrl: Schema.String,
      clientKey: Schema.String,
      clientSecret: Schema.String,
      customerId: Schema.String,
    }).pipe(
      Schema.encodeKeys({
        apiUrl: "api_url",
        clientKey: "client_key",
        clientSecret: "client_secret",
        customerId: "customer_id",
      }),
    ),
    Schema.Struct({
      clientId: Schema.String,
      clientSecret: Schema.String,
      customerId: Schema.String,
    }).pipe(
      Schema.encodeKeys({
        clientId: "client_id",
        clientSecret: "client_secret",
        customerId: "customer_id",
      }),
    ),
    Schema.Struct({
      clientId: Schema.String,
      clientSecret: Schema.String,
    }).pipe(
      Schema.encodeKeys({
        clientId: "client_id",
        clientSecret: "client_secret",
      }),
    ),
    Schema.Struct({
      apiUrl: Schema.String,
      clientSecret: Schema.String,
      accessClientId: Schema.optional(Schema.String),
      accessClientSecret: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        apiUrl: "api_url",
        clientSecret: "client_secret",
        accessClientId: "access_client_id",
        accessClientSecret: "access_client_secret",
      }),
    ),
    Schema.Struct({
      apiUrl: Schema.String,
      clientSecret: Schema.String,
    }).pipe(
      Schema.encodeKeys({ apiUrl: "api_url", clientSecret: "client_secret" }),
    ),
    Schema.Struct({
      accessClientId: Schema.String,
      accessClientSecret: Schema.String,
      apiUrl: Schema.String,
    }).pipe(
      Schema.encodeKeys({
        accessClientId: "access_client_id",
        accessClientSecret: "access_client_secret",
        apiUrl: "api_url",
      }),
    ),
  ]),
  interval: Schema.String,
  name: Schema.String,
  type: Schema.Literals([
    "workspace_one",
    "crowdstrike_s2s",
    "uptycs",
    "intune",
    "kolide",
    "tanium_s2s",
    "sentinelone_s2s",
    "custom_s2s",
  ]),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/devices/posture/integration",
  }),
) as unknown as Schema.Schema<CreateDevicePostureIntegrationRequest>;

export interface CreateDevicePostureIntegrationResponse {
  /** API UUID. */
  id?: string;
  /** The configuration object containing third-party integration information. */
  config?: { apiUrl: string; authUrl: string; clientId: string };
  /** The interval between each posture check with the third-party API. Use `m` for minutes (e.g. `5m`) and `h` for hours (e.g. `12h`). */
  interval?: string;
  /** The name of the device posture integration. */
  name?: string;
  /** The type of device posture integration. */
  type?:
    | "workspace_one"
    | "crowdstrike_s2s"
    | "uptycs"
    | "intune"
    | "kolide"
    | "tanium_s2s"
    | "sentinelone_s2s"
    | "custom_s2s";
}

export const CreateDevicePostureIntegrationResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  config: Schema.optional(
    Schema.Struct({
      apiUrl: Schema.String,
      authUrl: Schema.String,
      clientId: Schema.String,
    }).pipe(
      Schema.encodeKeys({
        apiUrl: "api_url",
        authUrl: "auth_url",
        clientId: "client_id",
      }),
    ),
  ),
  interval: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  type: Schema.optional(
    Schema.Literals([
      "workspace_one",
      "crowdstrike_s2s",
      "uptycs",
      "intune",
      "kolide",
      "tanium_s2s",
      "sentinelone_s2s",
      "custom_s2s",
    ]),
  ),
}) as unknown as Schema.Schema<CreateDevicePostureIntegrationResponse>;

export type CreateDevicePostureIntegrationError = CommonErrors;

export const createDevicePostureIntegration: API.OperationMethod<
  CreateDevicePostureIntegrationRequest,
  CreateDevicePostureIntegrationResponse,
  CreateDevicePostureIntegrationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDevicePostureIntegrationRequest,
  output: CreateDevicePostureIntegrationResponse,
  errors: [],
}));

export interface PatchDevicePostureIntegrationRequest {
  integrationId: string;
  /** Path param: */
  accountId: string;
  /** Body param: The configuration object containing third-party integration information. */
  config?:
    | {
        apiUrl: string;
        authUrl: string;
        clientId: string;
        clientSecret: string;
      }
    | {
        apiUrl: string;
        clientId: string;
        clientSecret: string;
        customerId: string;
      }
    | {
        apiUrl: string;
        clientKey: string;
        clientSecret: string;
        customerId: string;
      }
    | { clientId: string; clientSecret: string; customerId: string }
    | { clientId: string; clientSecret: string }
    | {
        apiUrl: string;
        clientSecret: string;
        accessClientId?: string;
        accessClientSecret?: string;
      }
    | { apiUrl: string; clientSecret: string }
    | { accessClientId: string; accessClientSecret: string; apiUrl: string };
  /** Body param: The interval between each posture check with the third-party API. Use `m` for minutes (e.g. `5m`) and `h` for hours (e.g. `12h`). */
  interval?: string;
  /** Body param: The name of the device posture integration. */
  name?: string;
  /** Body param: The type of device posture integration. */
  type?:
    | "workspace_one"
    | "crowdstrike_s2s"
    | "uptycs"
    | "intune"
    | "kolide"
    | "tanium_s2s"
    | "sentinelone_s2s"
    | "custom_s2s";
}

export const PatchDevicePostureIntegrationRequest = Schema.Struct({
  integrationId: Schema.String.pipe(T.HttpPath("integrationId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  config: Schema.optional(
    Schema.Union([
      Schema.Struct({
        apiUrl: Schema.String,
        authUrl: Schema.String,
        clientId: Schema.String,
        clientSecret: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          apiUrl: "api_url",
          authUrl: "auth_url",
          clientId: "client_id",
          clientSecret: "client_secret",
        }),
      ),
      Schema.Struct({
        apiUrl: Schema.String,
        clientId: Schema.String,
        clientSecret: Schema.String,
        customerId: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          apiUrl: "api_url",
          clientId: "client_id",
          clientSecret: "client_secret",
          customerId: "customer_id",
        }),
      ),
      Schema.Struct({
        apiUrl: Schema.String,
        clientKey: Schema.String,
        clientSecret: Schema.String,
        customerId: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          apiUrl: "api_url",
          clientKey: "client_key",
          clientSecret: "client_secret",
          customerId: "customer_id",
        }),
      ),
      Schema.Struct({
        clientId: Schema.String,
        clientSecret: Schema.String,
        customerId: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          clientId: "client_id",
          clientSecret: "client_secret",
          customerId: "customer_id",
        }),
      ),
      Schema.Struct({
        clientId: Schema.String,
        clientSecret: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          clientId: "client_id",
          clientSecret: "client_secret",
        }),
      ),
      Schema.Struct({
        apiUrl: Schema.String,
        clientSecret: Schema.String,
        accessClientId: Schema.optional(Schema.String),
        accessClientSecret: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          apiUrl: "api_url",
          clientSecret: "client_secret",
          accessClientId: "access_client_id",
          accessClientSecret: "access_client_secret",
        }),
      ),
      Schema.Struct({
        apiUrl: Schema.String,
        clientSecret: Schema.String,
      }).pipe(
        Schema.encodeKeys({ apiUrl: "api_url", clientSecret: "client_secret" }),
      ),
      Schema.Struct({
        accessClientId: Schema.String,
        accessClientSecret: Schema.String,
        apiUrl: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          accessClientId: "access_client_id",
          accessClientSecret: "access_client_secret",
          apiUrl: "api_url",
        }),
      ),
    ]),
  ),
  interval: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  type: Schema.optional(
    Schema.Literals([
      "workspace_one",
      "crowdstrike_s2s",
      "uptycs",
      "intune",
      "kolide",
      "tanium_s2s",
      "sentinelone_s2s",
      "custom_s2s",
    ]),
  ),
}).pipe(
  T.Http({
    method: "PATCH",
    path: "/accounts/{account_id}/devices/posture/integration/{integrationId}",
  }),
) as unknown as Schema.Schema<PatchDevicePostureIntegrationRequest>;

export interface PatchDevicePostureIntegrationResponse {
  /** API UUID. */
  id?: string;
  /** The configuration object containing third-party integration information. */
  config?: { apiUrl: string; authUrl: string; clientId: string };
  /** The interval between each posture check with the third-party API. Use `m` for minutes (e.g. `5m`) and `h` for hours (e.g. `12h`). */
  interval?: string;
  /** The name of the device posture integration. */
  name?: string;
  /** The type of device posture integration. */
  type?:
    | "workspace_one"
    | "crowdstrike_s2s"
    | "uptycs"
    | "intune"
    | "kolide"
    | "tanium_s2s"
    | "sentinelone_s2s"
    | "custom_s2s";
}

export const PatchDevicePostureIntegrationResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  config: Schema.optional(
    Schema.Struct({
      apiUrl: Schema.String,
      authUrl: Schema.String,
      clientId: Schema.String,
    }).pipe(
      Schema.encodeKeys({
        apiUrl: "api_url",
        authUrl: "auth_url",
        clientId: "client_id",
      }),
    ),
  ),
  interval: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  type: Schema.optional(
    Schema.Literals([
      "workspace_one",
      "crowdstrike_s2s",
      "uptycs",
      "intune",
      "kolide",
      "tanium_s2s",
      "sentinelone_s2s",
      "custom_s2s",
    ]),
  ),
}) as unknown as Schema.Schema<PatchDevicePostureIntegrationResponse>;

export type PatchDevicePostureIntegrationError = CommonErrors;

export const patchDevicePostureIntegration: API.OperationMethod<
  PatchDevicePostureIntegrationRequest,
  PatchDevicePostureIntegrationResponse,
  PatchDevicePostureIntegrationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchDevicePostureIntegrationRequest,
  output: PatchDevicePostureIntegrationResponse,
  errors: [],
}));

export interface DeleteDevicePostureIntegrationRequest {
  integrationId: string;
  accountId: string;
}

export const DeleteDevicePostureIntegrationRequest = Schema.Struct({
  integrationId: Schema.String.pipe(T.HttpPath("integrationId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/devices/posture/integration/{integrationId}",
  }),
) as unknown as Schema.Schema<DeleteDevicePostureIntegrationRequest>;

export type DeleteDevicePostureIntegrationResponse = string;

export const DeleteDevicePostureIntegrationResponse =
  Schema.String as unknown as Schema.Schema<DeleteDevicePostureIntegrationResponse>;

export type DeleteDevicePostureIntegrationError = CommonErrors;

export const deleteDevicePostureIntegration: API.OperationMethod<
  DeleteDevicePostureIntegrationRequest,
  DeleteDevicePostureIntegrationResponse,
  DeleteDevicePostureIntegrationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDevicePostureIntegrationRequest,
  output: DeleteDevicePostureIntegrationResponse,
  errors: [],
}));

// =============================================================================
// DeviceRegistration
// =============================================================================

export interface GetDeviceRegistrationRequest {
  registrationId: string;
  /** Path param: */
  accountId: string;
  /** Query param: Comma-separated list of additional information that should be included in the registration response. Supported values are: "policy". */
  include?: string;
}

export const GetDeviceRegistrationRequest = Schema.Struct({
  registrationId: Schema.String.pipe(T.HttpPath("registrationId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  include: Schema.optional(Schema.String).pipe(T.HttpQuery("include")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/registrations/{registrationId}",
  }),
) as unknown as Schema.Schema<GetDeviceRegistrationRequest>;

export interface GetDeviceRegistrationResponse {
  /** The ID of the registration. */
  id: string;
  /** The RFC3339 timestamp when the registration was created. */
  createdAt: string;
  /** Device details embedded inside of a registration. */
  device: { id: string; name: string; clientVersion?: string };
  /** The public key used to connect to the Cloudflare network. */
  key: string;
  /** The RFC3339 timestamp when the registration was last seen. */
  lastSeenAt: string;
  /** The RFC3339 timestamp when the registration was last updated. */
  updatedAt: string;
  /** The RFC3339 timestamp when the registration was deleted. */
  deletedAt?: string | null;
  /** The type of encryption key used by the WARP client for the active key. Currently 'curve25519' for WireGuard and 'secp256r1' for MASQUE. */
  keyType?: string | null;
  /** The device settings profile assigned to this registration. */
  policy?: {
    id: string;
    default: boolean;
    deleted: boolean;
    name: string;
    updatedAt: string;
  };
  /** The RFC3339 timestamp when the registration was revoked. */
  revokedAt?: string | null;
  /** Type of the tunnel - wireguard or masque. */
  tunnelType?: string | null;
  user?: { id?: string; email?: string; name?: string };
}

export const GetDeviceRegistrationResponse = Schema.Struct({
  id: Schema.String,
  createdAt: Schema.String,
  device: Schema.Struct({
    id: Schema.String,
    name: Schema.String,
    clientVersion: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      name: "name",
      clientVersion: "client_version",
    }),
  ),
  key: Schema.String,
  lastSeenAt: Schema.String,
  updatedAt: Schema.String,
  deletedAt: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  keyType: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  policy: Schema.optional(
    Schema.Struct({
      id: Schema.String,
      default: Schema.Boolean,
      deleted: Schema.Boolean,
      name: Schema.String,
      updatedAt: Schema.String,
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        default: "default",
        deleted: "deleted",
        name: "name",
        updatedAt: "updated_at",
      }),
    ),
  ),
  revokedAt: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  tunnelType: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  user: Schema.optional(
    Schema.Struct({
      id: Schema.optional(Schema.String),
      email: Schema.optional(Schema.String),
      name: Schema.optional(Schema.String),
    }),
  ),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    createdAt: "created_at",
    device: "device",
    key: "key",
    lastSeenAt: "last_seen_at",
    updatedAt: "updated_at",
    deletedAt: "deleted_at",
    keyType: "key_type",
    policy: "policy",
    revokedAt: "revoked_at",
    tunnelType: "tunnel_type",
    user: "user",
  }),
) as unknown as Schema.Schema<GetDeviceRegistrationResponse>;

export type GetDeviceRegistrationError = CommonErrors;

export const getDeviceRegistration: API.OperationMethod<
  GetDeviceRegistrationRequest,
  GetDeviceRegistrationResponse,
  GetDeviceRegistrationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDeviceRegistrationRequest,
  output: GetDeviceRegistrationResponse,
  errors: [],
}));

export interface ListDeviceRegistrationsRequest {
  /** Path param: */
  accountId: string;
  /** Query param: Filter by registration ID. */
  id?: string[];
  /** Query param: */
  device?: { id?: string };
  /** Query param: Comma-separated list of additional information that should be included in the registration response. Supported values are: "policy". */
  include?: string;
  /** Query param: Filter by registration details. */
  search?: string;
  /** Query param: Filter by the last_seen timestamp - returns only registrations last seen after this timestamp. */
  seenAfter?: string;
  /** Query param: Filter by the last_seen timestamp - returns only registrations last seen before this timestamp. */
  seenBefore?: string;
  /** Query param: The registration field to order results by. */
  sortBy?: "id" | "user.name" | "user.email" | "last_seen_at" | "created_at";
  /** Query param: Sort direction. */
  sortOrder?: "asc" | "desc";
  /** Query param: Filter by registration status. Defaults to 'active'. */
  status?: "active" | "all" | "revoked";
  /** Query param: */
  user?: { id?: string[] };
}

export const ListDeviceRegistrationsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.optional(Schema.Array(Schema.String)).pipe(T.HttpQuery("id")),
  device: Schema.optional(
    Schema.Struct({
      id: Schema.optional(Schema.String),
    }),
  ).pipe(T.HttpQuery("device")),
  include: Schema.optional(Schema.String).pipe(T.HttpQuery("include")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
  seenAfter: Schema.optional(Schema.String).pipe(T.HttpQuery("seen_after")),
  seenBefore: Schema.optional(Schema.String).pipe(T.HttpQuery("seen_before")),
  sortBy: Schema.optional(
    Schema.Literals([
      "id",
      "user.name",
      "user.email",
      "last_seen_at",
      "created_at",
    ]),
  ).pipe(T.HttpQuery("sort_by")),
  sortOrder: Schema.optional(Schema.Literals(["asc", "desc"])).pipe(
    T.HttpQuery("sort_order"),
  ),
  status: Schema.optional(Schema.Literals(["active", "all", "revoked"])).pipe(
    T.HttpQuery("status"),
  ),
  user: Schema.optional(
    Schema.Struct({
      id: Schema.optional(Schema.Array(Schema.String)),
    }),
  ).pipe(T.HttpQuery("user")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/registrations",
  }),
) as unknown as Schema.Schema<ListDeviceRegistrationsRequest>;

export type ListDeviceRegistrationsResponse = {
  id: string;
  createdAt: string;
  device: { id: string; name: string; clientVersion?: string };
  key: string;
  lastSeenAt: string;
  updatedAt: string;
  deletedAt?: string | null;
  keyType?: string | null;
  policy?: {
    id: string;
    default: boolean;
    deleted: boolean;
    name: string;
    updatedAt: string;
  };
  revokedAt?: string | null;
  tunnelType?: string | null;
  user?: { id?: string; email?: string; name?: string };
}[];

export const ListDeviceRegistrationsResponse = Schema.Array(
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    device: Schema.Struct({
      id: Schema.String,
      name: Schema.String,
      clientVersion: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        name: "name",
        clientVersion: "client_version",
      }),
    ),
    key: Schema.String,
    lastSeenAt: Schema.String,
    updatedAt: Schema.String,
    deletedAt: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    keyType: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    policy: Schema.optional(
      Schema.Struct({
        id: Schema.String,
        default: Schema.Boolean,
        deleted: Schema.Boolean,
        name: Schema.String,
        updatedAt: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          default: "default",
          deleted: "deleted",
          name: "name",
          updatedAt: "updated_at",
        }),
      ),
    ),
    revokedAt: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    tunnelType: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    user: Schema.optional(
      Schema.Struct({
        id: Schema.optional(Schema.String),
        email: Schema.optional(Schema.String),
        name: Schema.optional(Schema.String),
      }),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      device: "device",
      key: "key",
      lastSeenAt: "last_seen_at",
      updatedAt: "updated_at",
      deletedAt: "deleted_at",
      keyType: "key_type",
      policy: "policy",
      revokedAt: "revoked_at",
      tunnelType: "tunnel_type",
      user: "user",
    }),
  ),
) as unknown as Schema.Schema<ListDeviceRegistrationsResponse>;

export type ListDeviceRegistrationsError = CommonErrors;

export const listDeviceRegistrations: API.OperationMethod<
  ListDeviceRegistrationsRequest,
  ListDeviceRegistrationsResponse,
  ListDeviceRegistrationsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDeviceRegistrationsRequest,
  output: ListDeviceRegistrationsResponse,
  errors: [],
}));

export interface DeleteDeviceRegistrationRequest {
  registrationId: string;
  accountId: string;
}

export const DeleteDeviceRegistrationRequest = Schema.Struct({
  registrationId: Schema.String.pipe(T.HttpPath("registrationId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/devices/registrations/{registrationId}",
  }),
) as unknown as Schema.Schema<DeleteDeviceRegistrationRequest>;

export type DeleteDeviceRegistrationResponse = unknown;

export const DeleteDeviceRegistrationResponse =
  Schema.Unknown as unknown as Schema.Schema<DeleteDeviceRegistrationResponse>;

export type DeleteDeviceRegistrationError = CommonErrors;

export const deleteDeviceRegistration: API.OperationMethod<
  DeleteDeviceRegistrationRequest,
  DeleteDeviceRegistrationResponse,
  DeleteDeviceRegistrationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDeviceRegistrationRequest,
  output: DeleteDeviceRegistrationResponse,
  errors: [],
}));

export interface BulkDeleteDeviceRegistrationsRequest {
  /** Path param: */
  accountId: string;
  /** Query param: A list of registration IDs to delete. */
  id: string[];
}

export const BulkDeleteDeviceRegistrationsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.Array(Schema.String).pipe(T.HttpQuery("id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/devices/registrations",
  }),
) as unknown as Schema.Schema<BulkDeleteDeviceRegistrationsRequest>;

export type BulkDeleteDeviceRegistrationsResponse = unknown;

export const BulkDeleteDeviceRegistrationsResponse =
  Schema.Unknown as unknown as Schema.Schema<BulkDeleteDeviceRegistrationsResponse>;

export type BulkDeleteDeviceRegistrationsError = CommonErrors;

export const bulkDeleteDeviceRegistrations: API.OperationMethod<
  BulkDeleteDeviceRegistrationsRequest,
  BulkDeleteDeviceRegistrationsResponse,
  BulkDeleteDeviceRegistrationsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: BulkDeleteDeviceRegistrationsRequest,
  output: BulkDeleteDeviceRegistrationsResponse,
  errors: [],
}));

export interface RevokeDeviceRegistrationRequest {
  /** Path param: */
  accountId: string;
  /** Query param: A list of registration IDs to revoke. */
  id: string[];
}

export const RevokeDeviceRegistrationRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.Array(Schema.String).pipe(T.HttpQuery("id")),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/devices/registrations/revoke",
  }),
) as unknown as Schema.Schema<RevokeDeviceRegistrationRequest>;

export type RevokeDeviceRegistrationResponse = unknown;

export const RevokeDeviceRegistrationResponse =
  Schema.Unknown as unknown as Schema.Schema<RevokeDeviceRegistrationResponse>;

export type RevokeDeviceRegistrationError = CommonErrors;

export const revokeDeviceRegistration: API.OperationMethod<
  RevokeDeviceRegistrationRequest,
  RevokeDeviceRegistrationResponse,
  RevokeDeviceRegistrationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: RevokeDeviceRegistrationRequest,
  output: RevokeDeviceRegistrationResponse,
  errors: [],
}));

export interface UnrevokeDeviceRegistrationRequest {
  /** Path param: */
  accountId: string;
  /** Query param: A list of registration IDs to unrevoke. */
  id: string[];
}

export const UnrevokeDeviceRegistrationRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.Array(Schema.String).pipe(T.HttpQuery("id")),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/devices/registrations/unrevoke",
  }),
) as unknown as Schema.Schema<UnrevokeDeviceRegistrationRequest>;

export type UnrevokeDeviceRegistrationResponse = unknown;

export const UnrevokeDeviceRegistrationResponse =
  Schema.Unknown as unknown as Schema.Schema<UnrevokeDeviceRegistrationResponse>;

export type UnrevokeDeviceRegistrationError = CommonErrors;

export const unrevokeDeviceRegistration: API.OperationMethod<
  UnrevokeDeviceRegistrationRequest,
  UnrevokeDeviceRegistrationResponse,
  UnrevokeDeviceRegistrationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UnrevokeDeviceRegistrationRequest,
  output: UnrevokeDeviceRegistrationResponse,
  errors: [],
}));

// =============================================================================
// DeviceResilienceGlobalWarpOverride
// =============================================================================

export interface GetDeviceResilienceGlobalWarpOverrideRequest {
  accountId: string;
}

export const GetDeviceResilienceGlobalWarpOverrideRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/devices/resilience/disconnect",
  }),
) as unknown as Schema.Schema<GetDeviceResilienceGlobalWarpOverrideRequest>;

export interface GetDeviceResilienceGlobalWarpOverrideResponse {
  /** Disconnects all devices on the account using Global WARP override. */
  disconnect?: boolean;
  /** When the Global WARP override state was updated. */
  timestamp?: string;
}

export const GetDeviceResilienceGlobalWarpOverrideResponse = Schema.Struct({
  disconnect: Schema.optional(Schema.Boolean),
  timestamp: Schema.optional(Schema.String),
}) as unknown as Schema.Schema<GetDeviceResilienceGlobalWarpOverrideResponse>;

export type GetDeviceResilienceGlobalWarpOverrideError = CommonErrors;

export const getDeviceResilienceGlobalWarpOverride: API.OperationMethod<
  GetDeviceResilienceGlobalWarpOverrideRequest,
  GetDeviceResilienceGlobalWarpOverrideResponse,
  GetDeviceResilienceGlobalWarpOverrideError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDeviceResilienceGlobalWarpOverrideRequest,
  output: GetDeviceResilienceGlobalWarpOverrideResponse,
  errors: [],
}));

export interface CreateDeviceResilienceGlobalWarpOverrideRequest {
  /** Path param: */
  accountId: string;
  /** Body param: Disconnects all devices on the account using Global WARP override. */
  disconnect: boolean;
  /** Body param: Reasoning for setting the Global WARP override state. This will be surfaced in the audit log. */
  justification?: string;
}

export const CreateDeviceResilienceGlobalWarpOverrideRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  disconnect: Schema.Boolean,
  justification: Schema.optional(Schema.String),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/devices/resilience/disconnect",
  }),
) as unknown as Schema.Schema<CreateDeviceResilienceGlobalWarpOverrideRequest>;

export interface CreateDeviceResilienceGlobalWarpOverrideResponse {
  /** Disconnects all devices on the account using Global WARP override. */
  disconnect?: boolean;
  /** When the Global WARP override state was updated. */
  timestamp?: string;
}

export const CreateDeviceResilienceGlobalWarpOverrideResponse = Schema.Struct({
  disconnect: Schema.optional(Schema.Boolean),
  timestamp: Schema.optional(Schema.String),
}) as unknown as Schema.Schema<CreateDeviceResilienceGlobalWarpOverrideResponse>;

export type CreateDeviceResilienceGlobalWarpOverrideError = CommonErrors;

export const createDeviceResilienceGlobalWarpOverride: API.OperationMethod<
  CreateDeviceResilienceGlobalWarpOverrideRequest,
  CreateDeviceResilienceGlobalWarpOverrideResponse,
  CreateDeviceResilienceGlobalWarpOverrideError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDeviceResilienceGlobalWarpOverrideRequest,
  output: CreateDeviceResilienceGlobalWarpOverrideResponse,
  errors: [],
}));

// =============================================================================
// DeviceRevoke
// =============================================================================

export interface CreateDeviceRevokeRequest {
  /** Path param: */
  accountId: string;
  /** Body param: A list of Registration IDs to revoke. */
  body: string[];
}

export const CreateDeviceRevokeRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.String).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/devices/revoke" }),
) as unknown as Schema.Schema<CreateDeviceRevokeRequest>;

export type CreateDeviceRevokeResponse = string;

export const CreateDeviceRevokeResponse =
  Schema.String as unknown as Schema.Schema<CreateDeviceRevokeResponse>;

export type CreateDeviceRevokeError = CommonErrors;

export const createDeviceRevoke: API.OperationMethod<
  CreateDeviceRevokeRequest,
  CreateDeviceRevokeResponse,
  CreateDeviceRevokeError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDeviceRevokeRequest,
  output: CreateDeviceRevokeResponse,
  errors: [],
}));

// =============================================================================
// DeviceSetting
// =============================================================================

export interface GetDeviceSettingRequest {
  accountId: string;
}

export const GetDeviceSettingRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/devices/settings" }),
) as unknown as Schema.Schema<GetDeviceSettingRequest>;

export interface GetDeviceSettingResponse {
  /** Sets the time limit, in seconds, that a user can use an override code to bypass WARP. */
  disableForTime?: number;
  /** Controls whether the external emergency disconnect feature is enabled. */
  externalEmergencySignalEnabled?: boolean;
  /** The SHA256 fingerprint (64 hexadecimal characters) of the HTTPS server certificate for the external_emergency_signal_url. If provided, the WARP client will use this value to verify the server's identi */
  externalEmergencySignalFingerprint?: string;
  /** The interval at which the WARP client fetches the emergency disconnect signal, formatted as a duration string (e.g., "5m", "2m30s", "1h"). Minimum 30 seconds. */
  externalEmergencySignalInterval?: string;
  /** The HTTPS URL from which to fetch the emergency disconnect signal. Must use HTTPS and have an IPv4 or IPv6 address as the host. */
  externalEmergencySignalUrl?: string;
  /** Enable gateway proxy filtering on TCP. */
  gatewayProxyEnabled?: boolean;
  /** Enable gateway proxy filtering on UDP. */
  gatewayUdpProxyEnabled?: boolean;
  /** Enable installation of cloudflare managed root certificate. */
  rootCertificateInstallationEnabled?: boolean;
  /** Enable using CGNAT virtual IPv4. */
  useZtVirtualIp?: boolean;
}

export const GetDeviceSettingResponse = Schema.Struct({
  disableForTime: Schema.optional(Schema.Number),
  externalEmergencySignalEnabled: Schema.optional(Schema.Boolean),
  externalEmergencySignalFingerprint: Schema.optional(Schema.String),
  externalEmergencySignalInterval: Schema.optional(Schema.String),
  externalEmergencySignalUrl: Schema.optional(Schema.String),
  gatewayProxyEnabled: Schema.optional(Schema.Boolean),
  gatewayUdpProxyEnabled: Schema.optional(Schema.Boolean),
  rootCertificateInstallationEnabled: Schema.optional(Schema.Boolean),
  useZtVirtualIp: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    disableForTime: "disable_for_time",
    externalEmergencySignalEnabled: "external_emergency_signal_enabled",
    externalEmergencySignalFingerprint: "external_emergency_signal_fingerprint",
    externalEmergencySignalInterval: "external_emergency_signal_interval",
    externalEmergencySignalUrl: "external_emergency_signal_url",
    gatewayProxyEnabled: "gateway_proxy_enabled",
    gatewayUdpProxyEnabled: "gateway_udp_proxy_enabled",
    rootCertificateInstallationEnabled: "root_certificate_installation_enabled",
    useZtVirtualIp: "use_zt_virtual_ip",
  }),
) as unknown as Schema.Schema<GetDeviceSettingResponse>;

export type GetDeviceSettingError = CommonErrors;

export const getDeviceSetting: API.OperationMethod<
  GetDeviceSettingRequest,
  GetDeviceSettingResponse,
  GetDeviceSettingError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDeviceSettingRequest,
  output: GetDeviceSettingResponse,
  errors: [],
}));

export interface PutDeviceSettingRequest {
  /** Path param: */
  accountId: string;
  /** Body param: Sets the time limit, in seconds, that a user can use an override code to bypass WARP. */
  disableForTime?: number;
  /** Body param: Controls whether the external emergency disconnect feature is enabled. */
  externalEmergencySignalEnabled?: boolean;
  /** Body param: The SHA256 fingerprint (64 hexadecimal characters) of the HTTPS server certificate for the external_emergency_signal_url. If provided, the WARP client will use this value to verify the ser */
  externalEmergencySignalFingerprint?: string;
  /** Body param: The interval at which the WARP client fetches the emergency disconnect signal, formatted as a duration string (e.g., "5m", "2m30s", "1h"). Minimum 30 seconds. */
  externalEmergencySignalInterval?: string;
  /** Body param: The HTTPS URL from which to fetch the emergency disconnect signal. Must use HTTPS and have an IPv4 or IPv6 address as the host. */
  externalEmergencySignalUrl?: string;
  /** Body param: Enable gateway proxy filtering on TCP. */
  gatewayProxyEnabled?: boolean;
  /** Body param: Enable gateway proxy filtering on UDP. */
  gatewayUdpProxyEnabled?: boolean;
  /** Body param: Enable installation of cloudflare managed root certificate. */
  rootCertificateInstallationEnabled?: boolean;
  /** Body param: Enable using CGNAT virtual IPv4. */
  useZtVirtualIp?: boolean;
}

export const PutDeviceSettingRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  disableForTime: Schema.optional(Schema.Number),
  externalEmergencySignalEnabled: Schema.optional(Schema.Boolean),
  externalEmergencySignalFingerprint: Schema.optional(Schema.String),
  externalEmergencySignalInterval: Schema.optional(Schema.String),
  externalEmergencySignalUrl: Schema.optional(Schema.String),
  gatewayProxyEnabled: Schema.optional(Schema.Boolean),
  gatewayUdpProxyEnabled: Schema.optional(Schema.Boolean),
  rootCertificateInstallationEnabled: Schema.optional(Schema.Boolean),
  useZtVirtualIp: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    disableForTime: "disable_for_time",
    externalEmergencySignalEnabled: "external_emergency_signal_enabled",
    externalEmergencySignalFingerprint: "external_emergency_signal_fingerprint",
    externalEmergencySignalInterval: "external_emergency_signal_interval",
    externalEmergencySignalUrl: "external_emergency_signal_url",
    gatewayProxyEnabled: "gateway_proxy_enabled",
    gatewayUdpProxyEnabled: "gateway_udp_proxy_enabled",
    rootCertificateInstallationEnabled: "root_certificate_installation_enabled",
    useZtVirtualIp: "use_zt_virtual_ip",
  }),
  T.Http({ method: "PUT", path: "/accounts/{account_id}/devices/settings" }),
) as unknown as Schema.Schema<PutDeviceSettingRequest>;

export interface PutDeviceSettingResponse {
  /** Sets the time limit, in seconds, that a user can use an override code to bypass WARP. */
  disableForTime?: number;
  /** Controls whether the external emergency disconnect feature is enabled. */
  externalEmergencySignalEnabled?: boolean;
  /** The SHA256 fingerprint (64 hexadecimal characters) of the HTTPS server certificate for the external_emergency_signal_url. If provided, the WARP client will use this value to verify the server's identi */
  externalEmergencySignalFingerprint?: string;
  /** The interval at which the WARP client fetches the emergency disconnect signal, formatted as a duration string (e.g., "5m", "2m30s", "1h"). Minimum 30 seconds. */
  externalEmergencySignalInterval?: string;
  /** The HTTPS URL from which to fetch the emergency disconnect signal. Must use HTTPS and have an IPv4 or IPv6 address as the host. */
  externalEmergencySignalUrl?: string;
  /** Enable gateway proxy filtering on TCP. */
  gatewayProxyEnabled?: boolean;
  /** Enable gateway proxy filtering on UDP. */
  gatewayUdpProxyEnabled?: boolean;
  /** Enable installation of cloudflare managed root certificate. */
  rootCertificateInstallationEnabled?: boolean;
  /** Enable using CGNAT virtual IPv4. */
  useZtVirtualIp?: boolean;
}

export const PutDeviceSettingResponse = Schema.Struct({
  disableForTime: Schema.optional(Schema.Number),
  externalEmergencySignalEnabled: Schema.optional(Schema.Boolean),
  externalEmergencySignalFingerprint: Schema.optional(Schema.String),
  externalEmergencySignalInterval: Schema.optional(Schema.String),
  externalEmergencySignalUrl: Schema.optional(Schema.String),
  gatewayProxyEnabled: Schema.optional(Schema.Boolean),
  gatewayUdpProxyEnabled: Schema.optional(Schema.Boolean),
  rootCertificateInstallationEnabled: Schema.optional(Schema.Boolean),
  useZtVirtualIp: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    disableForTime: "disable_for_time",
    externalEmergencySignalEnabled: "external_emergency_signal_enabled",
    externalEmergencySignalFingerprint: "external_emergency_signal_fingerprint",
    externalEmergencySignalInterval: "external_emergency_signal_interval",
    externalEmergencySignalUrl: "external_emergency_signal_url",
    gatewayProxyEnabled: "gateway_proxy_enabled",
    gatewayUdpProxyEnabled: "gateway_udp_proxy_enabled",
    rootCertificateInstallationEnabled: "root_certificate_installation_enabled",
    useZtVirtualIp: "use_zt_virtual_ip",
  }),
) as unknown as Schema.Schema<PutDeviceSettingResponse>;

export type PutDeviceSettingError = CommonErrors;

export const putDeviceSetting: API.OperationMethod<
  PutDeviceSettingRequest,
  PutDeviceSettingResponse,
  PutDeviceSettingError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutDeviceSettingRequest,
  output: PutDeviceSettingResponse,
  errors: [],
}));

export interface PatchDeviceSettingRequest {
  /** Path param: */
  accountId: string;
  /** Body param: Sets the time limit, in seconds, that a user can use an override code to bypass WARP. */
  disableForTime?: number;
  /** Body param: Controls whether the external emergency disconnect feature is enabled. */
  externalEmergencySignalEnabled?: boolean;
  /** Body param: The SHA256 fingerprint (64 hexadecimal characters) of the HTTPS server certificate for the external_emergency_signal_url. If provided, the WARP client will use this value to verify the ser */
  externalEmergencySignalFingerprint?: string;
  /** Body param: The interval at which the WARP client fetches the emergency disconnect signal, formatted as a duration string (e.g., "5m", "2m30s", "1h"). Minimum 30 seconds. */
  externalEmergencySignalInterval?: string;
  /** Body param: The HTTPS URL from which to fetch the emergency disconnect signal. Must use HTTPS and have an IPv4 or IPv6 address as the host. */
  externalEmergencySignalUrl?: string;
  /** Body param: Enable gateway proxy filtering on TCP. */
  gatewayProxyEnabled?: boolean;
  /** Body param: Enable gateway proxy filtering on UDP. */
  gatewayUdpProxyEnabled?: boolean;
  /** Body param: Enable installation of cloudflare managed root certificate. */
  rootCertificateInstallationEnabled?: boolean;
  /** Body param: Enable using CGNAT virtual IPv4. */
  useZtVirtualIp?: boolean;
}

export const PatchDeviceSettingRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  disableForTime: Schema.optional(Schema.Number),
  externalEmergencySignalEnabled: Schema.optional(Schema.Boolean),
  externalEmergencySignalFingerprint: Schema.optional(Schema.String),
  externalEmergencySignalInterval: Schema.optional(Schema.String),
  externalEmergencySignalUrl: Schema.optional(Schema.String),
  gatewayProxyEnabled: Schema.optional(Schema.Boolean),
  gatewayUdpProxyEnabled: Schema.optional(Schema.Boolean),
  rootCertificateInstallationEnabled: Schema.optional(Schema.Boolean),
  useZtVirtualIp: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    disableForTime: "disable_for_time",
    externalEmergencySignalEnabled: "external_emergency_signal_enabled",
    externalEmergencySignalFingerprint: "external_emergency_signal_fingerprint",
    externalEmergencySignalInterval: "external_emergency_signal_interval",
    externalEmergencySignalUrl: "external_emergency_signal_url",
    gatewayProxyEnabled: "gateway_proxy_enabled",
    gatewayUdpProxyEnabled: "gateway_udp_proxy_enabled",
    rootCertificateInstallationEnabled: "root_certificate_installation_enabled",
    useZtVirtualIp: "use_zt_virtual_ip",
  }),
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/devices/settings" }),
) as unknown as Schema.Schema<PatchDeviceSettingRequest>;

export interface PatchDeviceSettingResponse {
  /** Sets the time limit, in seconds, that a user can use an override code to bypass WARP. */
  disableForTime?: number;
  /** Controls whether the external emergency disconnect feature is enabled. */
  externalEmergencySignalEnabled?: boolean;
  /** The SHA256 fingerprint (64 hexadecimal characters) of the HTTPS server certificate for the external_emergency_signal_url. If provided, the WARP client will use this value to verify the server's identi */
  externalEmergencySignalFingerprint?: string;
  /** The interval at which the WARP client fetches the emergency disconnect signal, formatted as a duration string (e.g., "5m", "2m30s", "1h"). Minimum 30 seconds. */
  externalEmergencySignalInterval?: string;
  /** The HTTPS URL from which to fetch the emergency disconnect signal. Must use HTTPS and have an IPv4 or IPv6 address as the host. */
  externalEmergencySignalUrl?: string;
  /** Enable gateway proxy filtering on TCP. */
  gatewayProxyEnabled?: boolean;
  /** Enable gateway proxy filtering on UDP. */
  gatewayUdpProxyEnabled?: boolean;
  /** Enable installation of cloudflare managed root certificate. */
  rootCertificateInstallationEnabled?: boolean;
  /** Enable using CGNAT virtual IPv4. */
  useZtVirtualIp?: boolean;
}

export const PatchDeviceSettingResponse = Schema.Struct({
  disableForTime: Schema.optional(Schema.Number),
  externalEmergencySignalEnabled: Schema.optional(Schema.Boolean),
  externalEmergencySignalFingerprint: Schema.optional(Schema.String),
  externalEmergencySignalInterval: Schema.optional(Schema.String),
  externalEmergencySignalUrl: Schema.optional(Schema.String),
  gatewayProxyEnabled: Schema.optional(Schema.Boolean),
  gatewayUdpProxyEnabled: Schema.optional(Schema.Boolean),
  rootCertificateInstallationEnabled: Schema.optional(Schema.Boolean),
  useZtVirtualIp: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    disableForTime: "disable_for_time",
    externalEmergencySignalEnabled: "external_emergency_signal_enabled",
    externalEmergencySignalFingerprint: "external_emergency_signal_fingerprint",
    externalEmergencySignalInterval: "external_emergency_signal_interval",
    externalEmergencySignalUrl: "external_emergency_signal_url",
    gatewayProxyEnabled: "gateway_proxy_enabled",
    gatewayUdpProxyEnabled: "gateway_udp_proxy_enabled",
    rootCertificateInstallationEnabled: "root_certificate_installation_enabled",
    useZtVirtualIp: "use_zt_virtual_ip",
  }),
) as unknown as Schema.Schema<PatchDeviceSettingResponse>;

export type PatchDeviceSettingError = CommonErrors;

export const patchDeviceSetting: API.OperationMethod<
  PatchDeviceSettingRequest,
  PatchDeviceSettingResponse,
  PatchDeviceSettingError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchDeviceSettingRequest,
  output: PatchDeviceSettingResponse,
  errors: [],
}));

export interface DeleteDeviceSettingRequest {
  accountId: string;
}

export const DeleteDeviceSettingRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "DELETE", path: "/accounts/{account_id}/devices/settings" }),
) as unknown as Schema.Schema<DeleteDeviceSettingRequest>;

export interface DeleteDeviceSettingResponse {
  /** Sets the time limit, in seconds, that a user can use an override code to bypass WARP. */
  disableForTime?: number;
  /** Controls whether the external emergency disconnect feature is enabled. */
  externalEmergencySignalEnabled?: boolean;
  /** The SHA256 fingerprint (64 hexadecimal characters) of the HTTPS server certificate for the external_emergency_signal_url. If provided, the WARP client will use this value to verify the server's identi */
  externalEmergencySignalFingerprint?: string;
  /** The interval at which the WARP client fetches the emergency disconnect signal, formatted as a duration string (e.g., "5m", "2m30s", "1h"). Minimum 30 seconds. */
  externalEmergencySignalInterval?: string;
  /** The HTTPS URL from which to fetch the emergency disconnect signal. Must use HTTPS and have an IPv4 or IPv6 address as the host. */
  externalEmergencySignalUrl?: string;
  /** Enable gateway proxy filtering on TCP. */
  gatewayProxyEnabled?: boolean;
  /** Enable gateway proxy filtering on UDP. */
  gatewayUdpProxyEnabled?: boolean;
  /** Enable installation of cloudflare managed root certificate. */
  rootCertificateInstallationEnabled?: boolean;
  /** Enable using CGNAT virtual IPv4. */
  useZtVirtualIp?: boolean;
}

export const DeleteDeviceSettingResponse = Schema.Struct({
  disableForTime: Schema.optional(Schema.Number),
  externalEmergencySignalEnabled: Schema.optional(Schema.Boolean),
  externalEmergencySignalFingerprint: Schema.optional(Schema.String),
  externalEmergencySignalInterval: Schema.optional(Schema.String),
  externalEmergencySignalUrl: Schema.optional(Schema.String),
  gatewayProxyEnabled: Schema.optional(Schema.Boolean),
  gatewayUdpProxyEnabled: Schema.optional(Schema.Boolean),
  rootCertificateInstallationEnabled: Schema.optional(Schema.Boolean),
  useZtVirtualIp: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    disableForTime: "disable_for_time",
    externalEmergencySignalEnabled: "external_emergency_signal_enabled",
    externalEmergencySignalFingerprint: "external_emergency_signal_fingerprint",
    externalEmergencySignalInterval: "external_emergency_signal_interval",
    externalEmergencySignalUrl: "external_emergency_signal_url",
    gatewayProxyEnabled: "gateway_proxy_enabled",
    gatewayUdpProxyEnabled: "gateway_udp_proxy_enabled",
    rootCertificateInstallationEnabled: "root_certificate_installation_enabled",
    useZtVirtualIp: "use_zt_virtual_ip",
  }),
) as unknown as Schema.Schema<DeleteDeviceSettingResponse>;

export type DeleteDeviceSettingError = CommonErrors;

export const deleteDeviceSetting: API.OperationMethod<
  DeleteDeviceSettingRequest,
  DeleteDeviceSettingResponse,
  DeleteDeviceSettingError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDeviceSettingRequest,
  output: DeleteDeviceSettingResponse,
  errors: [],
}));

// =============================================================================
// DeviceUnrevoke
// =============================================================================

export interface CreateDeviceUnrevokeRequest {
  /** Path param: */
  accountId: string;
  /** Body param: A list of Registration IDs to unrevoke. */
  body: string[];
}

export const CreateDeviceUnrevokeRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(Schema.String).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/devices/unrevoke" }),
) as unknown as Schema.Schema<CreateDeviceUnrevokeRequest>;

export type CreateDeviceUnrevokeResponse = string;

export const CreateDeviceUnrevokeResponse =
  Schema.String as unknown as Schema.Schema<CreateDeviceUnrevokeResponse>;

export type CreateDeviceUnrevokeError = CommonErrors;

export const createDeviceUnrevoke: API.OperationMethod<
  CreateDeviceUnrevokeRequest,
  CreateDeviceUnrevokeResponse,
  CreateDeviceUnrevokeError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDeviceUnrevokeRequest,
  output: CreateDeviceUnrevokeResponse,
  errors: [],
}));

// =============================================================================
// DexColo
// =============================================================================

export interface ListDexColosRequest {
  /** Path param: unique identifier linked to an account in the API request path. */
  accountId: string;
  /** Query param: Start time for connection period in ISO (RFC3339 - ISO 8601) format */
  from: string;
  /** Query param: End time for connection period in ISO (RFC3339 - ISO 8601) format */
  to: string;
  /** Query param: Type of usage that colos should be sorted by. If unspecified, returns all Cloudflare colos sorted alphabetically. */
  sortBy?: "fleet-status-usage" | "application-tests-usage";
}

export const ListDexColosRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  from: Schema.String.pipe(T.HttpQuery("from")),
  to: Schema.String.pipe(T.HttpQuery("to")),
  sortBy: Schema.optional(
    Schema.Literals(["fleet-status-usage", "application-tests-usage"]),
  ).pipe(T.HttpQuery("sortBy")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/colos" }),
) as unknown as Schema.Schema<ListDexColosRequest>;

export type ListDexColosResponse = unknown[];

export const ListDexColosResponse = Schema.Array(
  Schema.Unknown,
) as unknown as Schema.Schema<ListDexColosResponse>;

export type ListDexColosError = CommonErrors;

export const listDexColos: API.OperationMethod<
  ListDexColosRequest,
  ListDexColosResponse,
  ListDexColosError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDexColosRequest,
  output: ListDexColosResponse,
  errors: [],
}));

// =============================================================================
// DexCommand
// =============================================================================

export interface ListDexCommandsRequest {
  /** Path param: unique identifier linked to an account in the API request path */
  accountId: string;
  /** Query param: Optionally filter executed commands by command type */
  commandType?: string;
  /** Query param: Unique identifier for a device */
  deviceId?: string;
  /** Query param: Start time for the query in ISO (RFC3339 - ISO 8601) format */
  from?: string;
  /** Query param: Optionally filter executed commands by status */
  status?: "PENDING_EXEC" | "PENDING_UPLOAD" | "SUCCESS" | "FAILED";
  /** Query param: End time for the query in ISO (RFC3339 - ISO 8601) format */
  to?: string;
  /** Query param: Email tied to the device */
  userEmail?: string;
}

export const ListDexCommandsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  commandType: Schema.optional(Schema.String).pipe(T.HttpQuery("command_type")),
  deviceId: Schema.optional(Schema.String).pipe(T.HttpQuery("device_id")),
  from: Schema.optional(Schema.String).pipe(T.HttpQuery("from")),
  status: Schema.optional(
    Schema.Literals(["PENDING_EXEC", "PENDING_UPLOAD", "SUCCESS", "FAILED"]),
  ).pipe(T.HttpQuery("status")),
  to: Schema.optional(Schema.String).pipe(T.HttpQuery("to")),
  userEmail: Schema.optional(Schema.String).pipe(T.HttpQuery("user_email")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/commands" }),
) as unknown as Schema.Schema<ListDexCommandsRequest>;

export type ListDexCommandsResponse = {
  commands?: {
    id?: string;
    completedDate?: string | null;
    createdDate?: string;
    deviceId?: string;
    filename?: string | null;
    status?: string;
    type?: string;
    userEmail?: string;
  }[];
}[];

export const ListDexCommandsResponse = Schema.Array(
  Schema.Struct({
    commands: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          completedDate: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
          createdDate: Schema.optional(Schema.String),
          deviceId: Schema.optional(Schema.String),
          filename: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          status: Schema.optional(Schema.String),
          type: Schema.optional(Schema.String),
          userEmail: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            completedDate: "completed_date",
            createdDate: "created_date",
            deviceId: "device_id",
            filename: "filename",
            status: "status",
            type: "type",
            userEmail: "user_email",
          }),
        ),
      ),
    ),
  }),
) as unknown as Schema.Schema<ListDexCommandsResponse>;

export type ListDexCommandsError = CommonErrors;

export const listDexCommands: API.OperationMethod<
  ListDexCommandsRequest,
  ListDexCommandsResponse,
  ListDexCommandsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDexCommandsRequest,
  output: ListDexCommandsResponse,
  errors: [],
}));

export interface CreateDexCommandRequest {
  /** Path param: unique identifier linked to an account in the API request path */
  accountId: string;
  /** Body param: List of device-level commands to execute */
  commands: {
    commandType: "pcap" | "warp-diag";
    deviceId: string;
    userEmail: string;
    commandArgs?: {
      interfaces?: ("default" | "tunnel")[];
      maxFileSizeMb?: number;
      packetSizeBytes?: number;
      testAllRoutes?: boolean;
      timeLimitMin?: number;
    };
  }[];
}

export const CreateDexCommandRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  commands: Schema.Array(
    Schema.Struct({
      commandType: Schema.Literals(["pcap", "warp-diag"]),
      deviceId: Schema.String,
      userEmail: Schema.String,
      commandArgs: Schema.optional(
        Schema.Struct({
          interfaces: Schema.optional(
            Schema.Array(Schema.Literals(["default", "tunnel"])),
          ),
          maxFileSizeMb: Schema.optional(Schema.Number),
          packetSizeBytes: Schema.optional(Schema.Number),
          testAllRoutes: Schema.optional(Schema.Boolean),
          timeLimitMin: Schema.optional(Schema.Number),
        }).pipe(
          Schema.encodeKeys({
            interfaces: "interfaces",
            maxFileSizeMb: "'max-file-size-mb'",
            packetSizeBytes: "'packet-size-bytes'",
            testAllRoutes: "'test-all-routes'",
            timeLimitMin: "'time-limit-min'",
          }),
        ),
      ),
    }).pipe(
      Schema.encodeKeys({
        commandType: "command_type",
        deviceId: "device_id",
        userEmail: "user_email",
        commandArgs: "command_args",
      }),
    ),
  ),
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dex/commands" }),
) as unknown as Schema.Schema<CreateDexCommandRequest>;

export interface CreateDexCommandResponse {
  /** List of created commands */
  commands?: {
    id?: string;
    args?: Record<string, unknown>;
    deviceId?: string;
    status?: "PENDING_EXEC" | "PENDING_UPLOAD" | "SUCCESS" | "FAILED";
    type?: string;
  }[];
}

export const CreateDexCommandResponse = Schema.Struct({
  commands: Schema.optional(
    Schema.Array(
      Schema.Struct({
        id: Schema.optional(Schema.String),
        args: Schema.optional(Schema.Struct({})),
        deviceId: Schema.optional(Schema.String),
        status: Schema.optional(
          Schema.Literals([
            "PENDING_EXEC",
            "PENDING_UPLOAD",
            "SUCCESS",
            "FAILED",
          ]),
        ),
        type: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          args: "args",
          deviceId: "device_id",
          status: "status",
          type: "type",
        }),
      ),
    ),
  ),
}) as unknown as Schema.Schema<CreateDexCommandResponse>;

export type CreateDexCommandError = CommonErrors;

export const createDexCommand: API.OperationMethod<
  CreateDexCommandRequest,
  CreateDexCommandResponse,
  CreateDexCommandError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDexCommandRequest,
  output: CreateDexCommandResponse,
  errors: [],
}));

// =============================================================================
// DexCommandDevice
// =============================================================================

export interface ListDexCommandDevicesRequest {
  /** Path param: unique identifier linked to an account in the API request path */
  accountId: string;
  /** Query param: Filter devices by name or email */
  search?: string;
}

export const ListDexCommandDevicesRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  search: Schema.optional(Schema.String).pipe(T.HttpQuery("search")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dex/commands/devices",
  }),
) as unknown as Schema.Schema<ListDexCommandDevicesRequest>;

export type ListDexCommandDevicesResponse = {
  devices?: {
    deviceId?: string;
    deviceName?: string;
    eligible?: boolean;
    ineligibleReason?: string;
    personEmail?: string;
    platform?: string;
    status?: string;
    timestamp?: string;
    version?: string;
  }[];
}[];

export const ListDexCommandDevicesResponse = Schema.Array(
  Schema.Struct({
    devices: Schema.optional(
      Schema.Array(
        Schema.Struct({
          deviceId: Schema.optional(Schema.String),
          deviceName: Schema.optional(Schema.String),
          eligible: Schema.optional(Schema.Boolean),
          ineligibleReason: Schema.optional(Schema.String),
          personEmail: Schema.optional(Schema.String),
          platform: Schema.optional(Schema.String),
          status: Schema.optional(Schema.String),
          timestamp: Schema.optional(Schema.String),
          version: Schema.optional(Schema.String),
        }),
      ),
    ),
  }),
) as unknown as Schema.Schema<ListDexCommandDevicesResponse>;

export type ListDexCommandDevicesError = CommonErrors;

export const listDexCommandDevices: API.OperationMethod<
  ListDexCommandDevicesRequest,
  ListDexCommandDevicesResponse,
  ListDexCommandDevicesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDexCommandDevicesRequest,
  output: ListDexCommandDevicesResponse,
  errors: [],
}));

// =============================================================================
// DexCommandDownload
// =============================================================================

export interface GetDexCommandDownloadRequest {
  commandId: string;
  filename: string;
  /** unique identifier linked to an account in the API request path */
  accountId: string;
}

export const GetDexCommandDownloadRequest = Schema.Struct({
  commandId: Schema.String.pipe(T.HttpPath("commandId")),
  filename: Schema.String.pipe(T.HttpPath("filename")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dex/commands/{commandId}/downloads/{filename}",
  }),
) as unknown as Schema.Schema<GetDexCommandDownloadRequest>;

export type GetDexCommandDownloadResponse = unknown;

export const GetDexCommandDownloadResponse =
  Schema.Unknown as unknown as Schema.Schema<GetDexCommandDownloadResponse>;

export type GetDexCommandDownloadError = CommonErrors;

export const getDexCommandDownload: API.OperationMethod<
  GetDexCommandDownloadRequest,
  GetDexCommandDownloadResponse,
  GetDexCommandDownloadError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDexCommandDownloadRequest,
  output: GetDexCommandDownloadResponse,
  errors: [],
}));

// =============================================================================
// DexCommandQuota
// =============================================================================

export interface GetDexCommandQuotaRequest {
  /** unique identifier linked to an account in the API request path */
  accountId: string;
}

export const GetDexCommandQuotaRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/commands/quota" }),
) as unknown as Schema.Schema<GetDexCommandQuotaRequest>;

export interface GetDexCommandQuotaResponse {
  /** The remaining number of commands that can be initiated for an account */
  quota: number;
  /** The number of commands that have been initiated for an account */
  quotaUsage: number;
  /** The time when the quota resets */
  resetTime: string;
}

export const GetDexCommandQuotaResponse = Schema.Struct({
  quota: Schema.Number,
  quotaUsage: Schema.Number,
  resetTime: Schema.String,
}).pipe(
  Schema.encodeKeys({
    quota: "quota",
    quotaUsage: "quota_usage",
    resetTime: "reset_time",
  }),
) as unknown as Schema.Schema<GetDexCommandQuotaResponse>;

export type GetDexCommandQuotaError = CommonErrors;

export const getDexCommandQuota: API.OperationMethod<
  GetDexCommandQuotaRequest,
  GetDexCommandQuotaResponse,
  GetDexCommandQuotaError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDexCommandQuotaRequest,
  output: GetDexCommandQuotaResponse,
  errors: [],
}));

// =============================================================================
// DexFleetStatus
// =============================================================================

export interface LiveDexFleetStatusRequest {
  /** Path param: Unique identifier for account */
  accountId: string;
  /** Query param: Number of minutes before current time */
  sinceMinutes: number;
}

export const LiveDexFleetStatusRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  sinceMinutes: Schema.Number.pipe(T.HttpQuery("since_minutes")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dex/fleet-status/live",
  }),
) as unknown as Schema.Schema<LiveDexFleetStatusRequest>;

export interface LiveDexFleetStatusResponse {
  deviceStats?: {
    byColo?: unknown[] | null;
    byMode?: unknown[] | null;
    byPlatform?: unknown[] | null;
    byStatus?: unknown[] | null;
    byVersion?: unknown[] | null;
    uniqueDevicesTotal?: number;
  };
}

export const LiveDexFleetStatusResponse = Schema.Struct({
  deviceStats: Schema.optional(
    Schema.Struct({
      byColo: Schema.optional(
        Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]),
      ),
      byMode: Schema.optional(
        Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]),
      ),
      byPlatform: Schema.optional(
        Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]),
      ),
      byStatus: Schema.optional(
        Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]),
      ),
      byVersion: Schema.optional(
        Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]),
      ),
      uniqueDevicesTotal: Schema.optional(Schema.Number),
    }),
  ),
}) as unknown as Schema.Schema<LiveDexFleetStatusResponse>;

export type LiveDexFleetStatusError = CommonErrors;

export const liveDexFleetStatus: API.OperationMethod<
  LiveDexFleetStatusRequest,
  LiveDexFleetStatusResponse,
  LiveDexFleetStatusError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: LiveDexFleetStatusRequest,
  output: LiveDexFleetStatusResponse,
  errors: [],
}));

// =============================================================================
// DexFleetStatusDevice
// =============================================================================

export interface ListDexFleetStatusDevicesRequest {
  /** Path param: Unique identifier for account */
  accountId: string;
  /** Query param: Time range beginning in ISO format */
  from: string;
  /** Query param: Time range end in ISO format */
  to: string;
  /** Query param: Cloudflare colo */
  colo?: string;
  /** Query param: Device-specific ID, given as UUID v4 */
  deviceId?: string;
  /** Query param: The mode under which the WARP client is run */
  mode?: string;
  /** Query param: Operating system */
  platform?: string;
  /** Query param: Dimension to sort results by */
  sortBy?:
    | "colo"
    | "device_id"
    | "mode"
    | "platform"
    | "status"
    | "timestamp"
    | "version";
  /** Query param: Source:  - `hourly` - device details aggregated hourly, up to 7 days prior - `last_seen` - device details, up to 24 hours prior - `raw` - device details, up to 7 days prior */
  source?: "last_seen" | "hourly" | "raw";
  /** Query param: Network status */
  status?: string;
  /** Query param: WARP client version */
  version?: string;
}

export const ListDexFleetStatusDevicesRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  from: Schema.String.pipe(T.HttpQuery("from")),
  to: Schema.String.pipe(T.HttpQuery("to")),
  colo: Schema.optional(Schema.String).pipe(T.HttpQuery("colo")),
  deviceId: Schema.optional(Schema.String).pipe(T.HttpQuery("device_id")),
  mode: Schema.optional(Schema.String).pipe(T.HttpQuery("mode")),
  platform: Schema.optional(Schema.String).pipe(T.HttpQuery("platform")),
  sortBy: Schema.optional(
    Schema.Literals([
      "colo",
      "device_id",
      "mode",
      "platform",
      "status",
      "timestamp",
      "version",
    ]),
  ).pipe(T.HttpQuery("sort_by")),
  source: Schema.optional(Schema.Literals(["last_seen", "hourly", "raw"])).pipe(
    T.HttpQuery("source"),
  ),
  status: Schema.optional(Schema.String).pipe(T.HttpQuery("status")),
  version: Schema.optional(Schema.String).pipe(T.HttpQuery("version")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dex/fleet-status/devices",
  }),
) as unknown as Schema.Schema<ListDexFleetStatusDevicesRequest>;

export type ListDexFleetStatusDevicesResponse = {
  colo: string;
  deviceId: string;
  mode: string;
  platform: string;
  status: string;
  timestamp: string;
  version: string;
  alwaysOn?: boolean | null;
  batteryCharging?: boolean | null;
  batteryCycles?: number | null;
  batteryPct?: number | null;
  connectionType?: string | null;
  cpuPct?: number | null;
  cpuPctByApp?: { cpuPct?: number; name?: string }[][] | null;
  deviceIpv4?: {
    address?: string | null;
    asn?: number | null;
    aso?: string | null;
    location?: {
      city?: string | null;
      countryIso?: string | null;
      stateIso?: string | null;
      zip?: string | null;
    };
    netmask?: string | null;
    version?: string | null;
  };
  deviceIpv6?: {
    address?: string | null;
    asn?: number | null;
    aso?: string | null;
    location?: {
      city?: string | null;
      countryIso?: string | null;
      stateIso?: string | null;
      zip?: string | null;
    };
    netmask?: string | null;
    version?: string | null;
  };
  deviceName?: string;
  diskReadBps?: number | null;
  diskUsagePct?: number | null;
  diskWriteBps?: number | null;
  dohSubdomain?: string | null;
  estimatedLossPct?: number | null;
  firewallEnabled?: boolean | null;
  gatewayIpv4?: {
    address?: string | null;
    asn?: number | null;
    aso?: string | null;
    location?: {
      city?: string | null;
      countryIso?: string | null;
      stateIso?: string | null;
      zip?: string | null;
    };
    netmask?: string | null;
    version?: string | null;
  };
  gatewayIpv6?: {
    address?: string | null;
    asn?: number | null;
    aso?: string | null;
    location?: {
      city?: string | null;
      countryIso?: string | null;
      stateIso?: string | null;
      zip?: string | null;
    };
    netmask?: string | null;
    version?: string | null;
  };
  handshakeLatencyMs?: number | null;
  ispIpv4?: {
    address?: string | null;
    asn?: number | null;
    aso?: string | null;
    location?: {
      city?: string | null;
      countryIso?: string | null;
      stateIso?: string | null;
      zip?: string | null;
    };
    netmask?: string | null;
    version?: string | null;
  };
  ispIpv6?: {
    address?: string | null;
    asn?: number | null;
    aso?: string | null;
    location?: {
      city?: string | null;
      countryIso?: string | null;
      stateIso?: string | null;
      zip?: string | null;
    };
    netmask?: string | null;
    version?: string | null;
  };
  metal?: string | null;
  networkRcvdBps?: number | null;
  networkSentBps?: number | null;
  networkSsid?: string | null;
  personEmail?: string;
  ramAvailableKb?: number | null;
  ramUsedPct?: number | null;
  ramUsedPctByApp?: { name?: string; ramUsedPct?: number }[][] | null;
  switchLocked?: boolean | null;
  wifiStrengthDbm?: number | null;
}[];

export const ListDexFleetStatusDevicesResponse = Schema.Array(
  Schema.Struct({
    colo: Schema.String,
    deviceId: Schema.String,
    mode: Schema.String,
    platform: Schema.String,
    status: Schema.String,
    timestamp: Schema.String,
    version: Schema.String,
    alwaysOn: Schema.optional(Schema.Union([Schema.Boolean, Schema.Null])),
    batteryCharging: Schema.optional(
      Schema.Union([Schema.Boolean, Schema.Null]),
    ),
    batteryCycles: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
    batteryPct: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
    connectionType: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    cpuPct: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
    cpuPctByApp: Schema.optional(
      Schema.Union([
        Schema.Array(
          Schema.Array(
            Schema.Struct({
              cpuPct: Schema.optional(Schema.Number),
              name: Schema.optional(Schema.String),
            }).pipe(Schema.encodeKeys({ cpuPct: "cpu_pct", name: "name" })),
          ),
        ),
        Schema.Null,
      ]),
    ),
    deviceIpv4: Schema.optional(
      Schema.Struct({
        address: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        asn: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
        aso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        location: Schema.optional(
          Schema.Struct({
            city: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
            countryIso: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            stateIso: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            zip: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          }).pipe(
            Schema.encodeKeys({
              city: "city",
              countryIso: "country_iso",
              stateIso: "state_iso",
              zip: "zip",
            }),
          ),
        ),
        netmask: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        version: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      }),
    ),
    deviceIpv6: Schema.optional(
      Schema.Struct({
        address: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        asn: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
        aso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        location: Schema.optional(
          Schema.Struct({
            city: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
            countryIso: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            stateIso: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            zip: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          }).pipe(
            Schema.encodeKeys({
              city: "city",
              countryIso: "country_iso",
              stateIso: "state_iso",
              zip: "zip",
            }),
          ),
        ),
        netmask: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        version: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      }),
    ),
    deviceName: Schema.optional(Schema.String),
    diskReadBps: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
    diskUsagePct: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
    diskWriteBps: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
    dohSubdomain: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    estimatedLossPct: Schema.optional(
      Schema.Union([Schema.Number, Schema.Null]),
    ),
    firewallEnabled: Schema.optional(
      Schema.Union([Schema.Boolean, Schema.Null]),
    ),
    gatewayIpv4: Schema.optional(
      Schema.Struct({
        address: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        asn: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
        aso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        location: Schema.optional(
          Schema.Struct({
            city: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
            countryIso: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            stateIso: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            zip: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          }).pipe(
            Schema.encodeKeys({
              city: "city",
              countryIso: "country_iso",
              stateIso: "state_iso",
              zip: "zip",
            }),
          ),
        ),
        netmask: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        version: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      }),
    ),
    gatewayIpv6: Schema.optional(
      Schema.Struct({
        address: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        asn: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
        aso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        location: Schema.optional(
          Schema.Struct({
            city: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
            countryIso: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            stateIso: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            zip: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          }).pipe(
            Schema.encodeKeys({
              city: "city",
              countryIso: "country_iso",
              stateIso: "state_iso",
              zip: "zip",
            }),
          ),
        ),
        netmask: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        version: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      }),
    ),
    handshakeLatencyMs: Schema.optional(
      Schema.Union([Schema.Number, Schema.Null]),
    ),
    ispIpv4: Schema.optional(
      Schema.Struct({
        address: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        asn: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
        aso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        location: Schema.optional(
          Schema.Struct({
            city: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
            countryIso: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            stateIso: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            zip: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          }).pipe(
            Schema.encodeKeys({
              city: "city",
              countryIso: "country_iso",
              stateIso: "state_iso",
              zip: "zip",
            }),
          ),
        ),
        netmask: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        version: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      }),
    ),
    ispIpv6: Schema.optional(
      Schema.Struct({
        address: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        asn: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
        aso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        location: Schema.optional(
          Schema.Struct({
            city: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
            countryIso: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            stateIso: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            zip: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          }).pipe(
            Schema.encodeKeys({
              city: "city",
              countryIso: "country_iso",
              stateIso: "state_iso",
              zip: "zip",
            }),
          ),
        ),
        netmask: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        version: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      }),
    ),
    metal: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    networkRcvdBps: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
    networkSentBps: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
    networkSsid: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    personEmail: Schema.optional(Schema.String),
    ramAvailableKb: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
    ramUsedPct: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
    ramUsedPctByApp: Schema.optional(
      Schema.Union([
        Schema.Array(
          Schema.Array(
            Schema.Struct({
              name: Schema.optional(Schema.String),
              ramUsedPct: Schema.optional(Schema.Number),
            }).pipe(
              Schema.encodeKeys({ name: "name", ramUsedPct: "ram_used_pct" }),
            ),
          ),
        ),
        Schema.Null,
      ]),
    ),
    switchLocked: Schema.optional(Schema.Union([Schema.Boolean, Schema.Null])),
    wifiStrengthDbm: Schema.optional(
      Schema.Union([Schema.Number, Schema.Null]),
    ),
  }),
) as unknown as Schema.Schema<ListDexFleetStatusDevicesResponse>;

export type ListDexFleetStatusDevicesError = CommonErrors;

export const listDexFleetStatusDevices: API.OperationMethod<
  ListDexFleetStatusDevicesRequest,
  ListDexFleetStatusDevicesResponse,
  ListDexFleetStatusDevicesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDexFleetStatusDevicesRequest,
  output: ListDexFleetStatusDevicesResponse,
  errors: [],
}));

// =============================================================================
// DexHttpTest
// =============================================================================

export interface GetDexHttpTestRequest {
  testId: string;
  /** Path param: unique identifier linked to an account in the API request path. */
  accountId: string;
  /** Query param: Start time for aggregate metrics in ISO ms */
  from: string;
  /** Query param: Time interval for aggregate time slots. */
  interval: "minute" | "hour";
  /** Query param: End time for aggregate metrics in ISO ms */
  to: string;
  /** Query param: Optionally filter result stats to a Cloudflare colo. Cannot be used in combination with deviceId param. */
  colo?: string;
  /** Query param: Optionally filter result stats to a specific device(s). Cannot be used in combination with colo param. */
  deviceId?: string[];
}

export const GetDexHttpTestRequest = Schema.Struct({
  testId: Schema.String.pipe(T.HttpPath("testId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  from: Schema.String.pipe(T.HttpQuery("from")),
  interval: Schema.Literals(["minute", "hour"]).pipe(T.HttpQuery("interval")),
  to: Schema.String.pipe(T.HttpQuery("to")),
  colo: Schema.optional(Schema.String).pipe(T.HttpQuery("colo")),
  deviceId: Schema.optional(Schema.Array(Schema.String)).pipe(
    T.HttpQuery("deviceId"),
  ),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dex/http-tests/{testId}",
  }),
) as unknown as Schema.Schema<GetDexHttpTestRequest>;

export interface GetDexHttpTestResponse {
  /** The url of the HTTP synthetic application test */
  host?: string;
  httpStats?: {
    availabilityPct: {
      slots: { timestamp: string; value: number }[];
      avg?: number | null;
      max?: number | null;
      min?: number | null;
    };
    dnsResponseTimeMs: unknown;
    httpStatusCode: {
      status200: number;
      status300: number;
      status400: number;
      status500: number;
      timestamp: string;
    }[];
    resourceFetchTimeMs: unknown;
    serverResponseTimeMs: unknown;
    uniqueDevicesTotal: number;
  } | null;
  httpStatsByColo?: {
    availabilityPct: {
      slots: { timestamp: string; value: number }[];
      avg?: number | null;
      max?: number | null;
      min?: number | null;
    };
    colo: string;
    dnsResponseTimeMs: unknown;
    httpStatusCode: {
      status200: number;
      status300: number;
      status400: number;
      status500: number;
      timestamp: string;
    }[];
    resourceFetchTimeMs: unknown;
    serverResponseTimeMs: unknown;
    uniqueDevicesTotal: number;
  }[];
  /** The interval at which the HTTP synthetic application test is set to run. */
  interval?: string;
  kind?: "http";
  /** The HTTP method to use when running the test */
  method?: string;
  /** The name of the HTTP synthetic application test */
  name?: string;
  targetPolicies?: unknown[] | null;
  targeted?: boolean;
}

export const GetDexHttpTestResponse = Schema.Struct({
  host: Schema.optional(Schema.String),
  httpStats: Schema.optional(
    Schema.Union([
      Schema.Struct({
        availabilityPct: Schema.Struct({
          slots: Schema.Array(
            Schema.Struct({
              timestamp: Schema.String,
              value: Schema.Number,
            }),
          ),
          avg: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
          max: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
          min: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
        }),
        dnsResponseTimeMs: Schema.Unknown,
        httpStatusCode: Schema.Array(
          Schema.Struct({
            status200: Schema.Number,
            status300: Schema.Number,
            status400: Schema.Number,
            status500: Schema.Number,
            timestamp: Schema.String,
          }),
        ),
        resourceFetchTimeMs: Schema.Unknown,
        serverResponseTimeMs: Schema.Unknown,
        uniqueDevicesTotal: Schema.Number,
      }),
      Schema.Null,
    ]),
  ),
  httpStatsByColo: Schema.optional(
    Schema.Array(
      Schema.Struct({
        availabilityPct: Schema.Struct({
          slots: Schema.Array(
            Schema.Struct({
              timestamp: Schema.String,
              value: Schema.Number,
            }),
          ),
          avg: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
          max: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
          min: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
        }),
        colo: Schema.String,
        dnsResponseTimeMs: Schema.Unknown,
        httpStatusCode: Schema.Array(
          Schema.Struct({
            status200: Schema.Number,
            status300: Schema.Number,
            status400: Schema.Number,
            status500: Schema.Number,
            timestamp: Schema.String,
          }),
        ),
        resourceFetchTimeMs: Schema.Unknown,
        serverResponseTimeMs: Schema.Unknown,
        uniqueDevicesTotal: Schema.Number,
      }),
    ),
  ),
  interval: Schema.optional(Schema.String),
  kind: Schema.optional(Schema.Literal("http")),
  method: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  targetPolicies: Schema.optional(
    Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]),
  ),
  targeted: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    host: "host",
    httpStats: "httpStats",
    httpStatsByColo: "httpStatsByColo",
    interval: "interval",
    kind: "kind",
    method: "method",
    name: "name",
    targetPolicies: "target_policies",
    targeted: "targeted",
  }),
) as unknown as Schema.Schema<GetDexHttpTestResponse>;

export type GetDexHttpTestError = CommonErrors;

export const getDexHttpTest: API.OperationMethod<
  GetDexHttpTestRequest,
  GetDexHttpTestResponse,
  GetDexHttpTestError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDexHttpTestRequest,
  output: GetDexHttpTestResponse,
  errors: [],
}));

// =============================================================================
// DexHttpTestPercentile
// =============================================================================

export interface GetDexHttpTestPercentileRequest {
  testId: string;
  /** Path param: unique identifier linked to an account in the API request path. */
  accountId: string;
  /** Query param: Start time for the query in ISO (RFC3339 - ISO 8601) format */
  from: string;
  /** Query param: End time for the query in ISO (RFC3339 - ISO 8601) format */
  to: string;
  /** Query param: Optionally filter result stats to a Cloudflare colo. Cannot be used in combination with deviceId param. */
  colo?: string;
  /** Query param: Optionally filter result stats to a specific device(s). Cannot be used in combination with colo param. */
  deviceId?: string[];
}

export const GetDexHttpTestPercentileRequest = Schema.Struct({
  testId: Schema.String.pipe(T.HttpPath("testId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  from: Schema.String.pipe(T.HttpQuery("from")),
  to: Schema.String.pipe(T.HttpQuery("to")),
  colo: Schema.optional(Schema.String).pipe(T.HttpQuery("colo")),
  deviceId: Schema.optional(Schema.Array(Schema.String)).pipe(
    T.HttpQuery("deviceId"),
  ),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dex/http-tests/{testId}/percentiles",
  }),
) as unknown as Schema.Schema<GetDexHttpTestPercentileRequest>;

export interface GetDexHttpTestPercentileResponse {
  dnsResponseTimeMs?: unknown;
  resourceFetchTimeMs?: unknown;
  serverResponseTimeMs?: unknown;
}

export const GetDexHttpTestPercentileResponse = Schema.Struct({
  dnsResponseTimeMs: Schema.optional(Schema.Unknown),
  resourceFetchTimeMs: Schema.optional(Schema.Unknown),
  serverResponseTimeMs: Schema.optional(Schema.Unknown),
}) as unknown as Schema.Schema<GetDexHttpTestPercentileResponse>;

export type GetDexHttpTestPercentileError = CommonErrors;

export const getDexHttpTestPercentile: API.OperationMethod<
  GetDexHttpTestPercentileRequest,
  GetDexHttpTestPercentileResponse,
  GetDexHttpTestPercentileError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDexHttpTestPercentileRequest,
  output: GetDexHttpTestPercentileResponse,
  errors: [],
}));

// =============================================================================
// DexTest
// =============================================================================

export interface ListDexTestsRequest {
  /** Path param: unique identifier linked to an account in the API request path. */
  accountId: string;
  /** Query param: Optionally filter result stats to a Cloudflare colo. Cannot be used in combination with deviceId param. */
  colo?: string;
  /** Query param: Optionally filter result stats to a specific device(s). Cannot be used in combination with colo param. */
  deviceId?: string[];
  /** Query param: Optionally filter results by test name */
  testName?: string;
}

export const ListDexTestsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  colo: Schema.optional(Schema.String).pipe(T.HttpQuery("colo")),
  deviceId: Schema.optional(Schema.Array(Schema.String)).pipe(
    T.HttpQuery("deviceId"),
  ),
  testName: Schema.optional(Schema.String).pipe(T.HttpQuery("testName")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dex/tests/overview" }),
) as unknown as Schema.Schema<ListDexTestsRequest>;

export type ListDexTestsResponse = {
  overviewMetrics: {
    testsTotal: number;
    avgHttpAvailabilityPct?: number | null;
    avgTracerouteAvailabilityPct?: number | null;
  };
  tests: {
    id: string;
    created: string;
    description: string;
    enabled: boolean;
    host: string;
    interval: string;
    kind: "http" | "traceroute";
    name: string;
    updated: string;
    httpResults?: {
      resourceFetchTime: {
        history: {
          timePeriod: unknown;
          avgMs?: number | null;
          deltaPct?: number | null;
        }[];
        avgMs?: number | null;
        overTime?: {
          timePeriod: unknown;
          values: { avgMs: unknown; timestamp: unknown }[];
        } | null;
      };
    } | null;
    httpResultsByColo?: {
      colo: string;
      resourceFetchTime: {
        history: {
          timePeriod: unknown;
          avgMs?: number | null;
          deltaPct?: number | null;
        }[];
        avgMs?: number | null;
        overTime?: {
          timePeriod: unknown;
          values: { avgMs: unknown; timestamp: unknown }[];
        } | null;
      };
    }[];
    method?: string;
    targetPolicies?: unknown[] | null;
    targeted?: boolean;
    tracerouteResults?: {
      roundTripTime: {
        history: {
          timePeriod: unknown;
          avgMs?: number | null;
          deltaPct?: number | null;
        }[];
        avgMs?: number | null;
        overTime?: {
          timePeriod: unknown;
          values: { avgMs: unknown; timestamp: unknown }[];
        } | null;
      };
    } | null;
    tracerouteResultsByColo?: {
      colo: string;
      roundTripTime: {
        history: {
          timePeriod: unknown;
          avgMs?: number | null;
          deltaPct?: number | null;
        }[];
        avgMs?: number | null;
        overTime?: {
          timePeriod: unknown;
          values: { avgMs: unknown; timestamp: unknown }[];
        } | null;
      };
    }[];
  }[];
}[];

export const ListDexTestsResponse = Schema.Array(
  Schema.Struct({
    overviewMetrics: Schema.Struct({
      testsTotal: Schema.Number,
      avgHttpAvailabilityPct: Schema.optional(
        Schema.Union([Schema.Number, Schema.Null]),
      ),
      avgTracerouteAvailabilityPct: Schema.optional(
        Schema.Union([Schema.Number, Schema.Null]),
      ),
    }),
    tests: Schema.Array(
      Schema.Struct({
        id: Schema.String,
        created: Schema.String,
        description: Schema.String,
        enabled: Schema.Boolean,
        host: Schema.String,
        interval: Schema.String,
        kind: Schema.Literals(["http", "traceroute"]),
        name: Schema.String,
        updated: Schema.String,
        httpResults: Schema.optional(
          Schema.Union([
            Schema.Struct({
              resourceFetchTime: Schema.Struct({
                history: Schema.Array(
                  Schema.Struct({
                    timePeriod: Schema.Unknown,
                    avgMs: Schema.optional(
                      Schema.Union([Schema.Number, Schema.Null]),
                    ),
                    deltaPct: Schema.optional(
                      Schema.Union([Schema.Number, Schema.Null]),
                    ),
                  }),
                ),
                avgMs: Schema.optional(
                  Schema.Union([Schema.Number, Schema.Null]),
                ),
                overTime: Schema.optional(
                  Schema.Union([
                    Schema.Struct({
                      timePeriod: Schema.Unknown,
                      values: Schema.Array(
                        Schema.Struct({
                          avgMs: Schema.Unknown,
                          timestamp: Schema.Unknown,
                        }),
                      ),
                    }),
                    Schema.Null,
                  ]),
                ),
              }),
            }),
            Schema.Null,
          ]),
        ),
        httpResultsByColo: Schema.optional(
          Schema.Array(
            Schema.Struct({
              colo: Schema.String,
              resourceFetchTime: Schema.Struct({
                history: Schema.Array(
                  Schema.Struct({
                    timePeriod: Schema.Unknown,
                    avgMs: Schema.optional(
                      Schema.Union([Schema.Number, Schema.Null]),
                    ),
                    deltaPct: Schema.optional(
                      Schema.Union([Schema.Number, Schema.Null]),
                    ),
                  }),
                ),
                avgMs: Schema.optional(
                  Schema.Union([Schema.Number, Schema.Null]),
                ),
                overTime: Schema.optional(
                  Schema.Union([
                    Schema.Struct({
                      timePeriod: Schema.Unknown,
                      values: Schema.Array(
                        Schema.Struct({
                          avgMs: Schema.Unknown,
                          timestamp: Schema.Unknown,
                        }),
                      ),
                    }),
                    Schema.Null,
                  ]),
                ),
              }),
            }),
          ),
        ),
        method: Schema.optional(Schema.String),
        targetPolicies: Schema.optional(
          Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]),
        ),
        targeted: Schema.optional(Schema.Boolean),
        tracerouteResults: Schema.optional(
          Schema.Union([
            Schema.Struct({
              roundTripTime: Schema.Struct({
                history: Schema.Array(
                  Schema.Struct({
                    timePeriod: Schema.Unknown,
                    avgMs: Schema.optional(
                      Schema.Union([Schema.Number, Schema.Null]),
                    ),
                    deltaPct: Schema.optional(
                      Schema.Union([Schema.Number, Schema.Null]),
                    ),
                  }),
                ),
                avgMs: Schema.optional(
                  Schema.Union([Schema.Number, Schema.Null]),
                ),
                overTime: Schema.optional(
                  Schema.Union([
                    Schema.Struct({
                      timePeriod: Schema.Unknown,
                      values: Schema.Array(
                        Schema.Struct({
                          avgMs: Schema.Unknown,
                          timestamp: Schema.Unknown,
                        }),
                      ),
                    }),
                    Schema.Null,
                  ]),
                ),
              }),
            }),
            Schema.Null,
          ]),
        ),
        tracerouteResultsByColo: Schema.optional(
          Schema.Array(
            Schema.Struct({
              colo: Schema.String,
              roundTripTime: Schema.Struct({
                history: Schema.Array(
                  Schema.Struct({
                    timePeriod: Schema.Unknown,
                    avgMs: Schema.optional(
                      Schema.Union([Schema.Number, Schema.Null]),
                    ),
                    deltaPct: Schema.optional(
                      Schema.Union([Schema.Number, Schema.Null]),
                    ),
                  }),
                ),
                avgMs: Schema.optional(
                  Schema.Union([Schema.Number, Schema.Null]),
                ),
                overTime: Schema.optional(
                  Schema.Union([
                    Schema.Struct({
                      timePeriod: Schema.Unknown,
                      values: Schema.Array(
                        Schema.Struct({
                          avgMs: Schema.Unknown,
                          timestamp: Schema.Unknown,
                        }),
                      ),
                    }),
                    Schema.Null,
                  ]),
                ),
              }),
            }),
          ),
        ),
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          created: "created",
          description: "description",
          enabled: "enabled",
          host: "host",
          interval: "interval",
          kind: "kind",
          name: "name",
          updated: "updated",
          httpResults: "httpResults",
          httpResultsByColo: "httpResultsByColo",
          method: "method",
          targetPolicies: "target_policies",
          targeted: "targeted",
          tracerouteResults: "tracerouteResults",
          tracerouteResultsByColo: "tracerouteResultsByColo",
        }),
      ),
    ),
  }),
) as unknown as Schema.Schema<ListDexTestsResponse>;

export type ListDexTestsError = CommonErrors;

export const listDexTests: API.OperationMethod<
  ListDexTestsRequest,
  ListDexTestsResponse,
  ListDexTestsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDexTestsRequest,
  output: ListDexTestsResponse,
  errors: [],
}));

// =============================================================================
// DexTestUniqueDevice
// =============================================================================

export interface ListDexTestUniqueDevicesRequest {
  /** Path param: unique identifier linked to an account in the API request path. */
  accountId: string;
  /** Query param: Optionally filter result stats to a specific device(s). Cannot be used in combination with colo param. */
  deviceId?: string[];
  /** Query param: Optionally filter results by test name */
  testName?: string;
}

export const ListDexTestUniqueDevicesRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  deviceId: Schema.optional(Schema.Array(Schema.String)).pipe(
    T.HttpQuery("deviceId"),
  ),
  testName: Schema.optional(Schema.String).pipe(T.HttpQuery("testName")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dex/tests/unique-devices",
  }),
) as unknown as Schema.Schema<ListDexTestUniqueDevicesRequest>;

export interface ListDexTestUniqueDevicesResponse {
  /** total number of unique devices */
  uniqueDevicesTotal: number;
}

export const ListDexTestUniqueDevicesResponse = Schema.Struct({
  uniqueDevicesTotal: Schema.Number,
}) as unknown as Schema.Schema<ListDexTestUniqueDevicesResponse>;

export type ListDexTestUniqueDevicesError = CommonErrors;

export const listDexTestUniqueDevices: API.OperationMethod<
  ListDexTestUniqueDevicesRequest,
  ListDexTestUniqueDevicesResponse,
  ListDexTestUniqueDevicesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDexTestUniqueDevicesRequest,
  output: ListDexTestUniqueDevicesResponse,
  errors: [],
}));

// =============================================================================
// DexTracerouteTest
// =============================================================================

export interface GetDexTracerouteTestRequest {
  testId: string;
  /** Path param: Unique identifier linked to an account */
  accountId: string;
  /** Query param: Start time for aggregate metrics in ISO ms */
  from: string;
  /** Query param: Time interval for aggregate time slots. */
  interval: "minute" | "hour";
  /** Query param: End time for aggregate metrics in ISO ms */
  to: string;
  /** Query param: Optionally filter result stats to a Cloudflare colo. Cannot be used in combination with deviceId param. */
  colo?: string;
  /** Query param: Optionally filter result stats to a specific device(s). Cannot be used in combination with colo param. */
  deviceId?: string[];
}

export const GetDexTracerouteTestRequest = Schema.Struct({
  testId: Schema.String.pipe(T.HttpPath("testId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  from: Schema.String.pipe(T.HttpQuery("from")),
  interval: Schema.Literals(["minute", "hour"]).pipe(T.HttpQuery("interval")),
  to: Schema.String.pipe(T.HttpQuery("to")),
  colo: Schema.optional(Schema.String).pipe(T.HttpQuery("colo")),
  deviceId: Schema.optional(Schema.Array(Schema.String)).pipe(
    T.HttpQuery("deviceId"),
  ),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dex/traceroute-tests/{testId}",
  }),
) as unknown as Schema.Schema<GetDexTracerouteTestRequest>;

export interface GetDexTracerouteTestResponse {
  /** The host of the Traceroute synthetic application test */
  host: string;
  /** The interval at which the Traceroute synthetic application test is set to run. */
  interval: string;
  kind: "traceroute";
  /** The name of the Traceroute synthetic application test */
  name: string;
  targetPolicies?: unknown[] | null;
  targeted?: boolean;
  tracerouteStats?: {
    availabilityPct: {
      slots: { timestamp: string; value: number }[];
      avg?: number | null;
      max?: number | null;
      min?: number | null;
    };
    hopsCount: unknown;
    packetLossPct: {
      slots: { timestamp: string; value: number }[];
      avg?: number | null;
      max?: number | null;
      min?: number | null;
    };
    roundTripTimeMs: unknown;
    uniqueDevicesTotal: number;
  } | null;
  tracerouteStatsByColo?: {
    availabilityPct: {
      slots: { timestamp: string; value: number }[];
      avg?: number | null;
      max?: number | null;
      min?: number | null;
    };
    colo: string;
    hopsCount: unknown;
    packetLossPct: {
      slots: { timestamp: string; value: number }[];
      avg?: number | null;
      max?: number | null;
      min?: number | null;
    };
    roundTripTimeMs: unknown;
    uniqueDevicesTotal: number;
  }[];
}

export const GetDexTracerouteTestResponse = Schema.Struct({
  host: Schema.String,
  interval: Schema.String,
  kind: Schema.Literal("traceroute"),
  name: Schema.String,
  targetPolicies: Schema.optional(
    Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]),
  ),
  targeted: Schema.optional(Schema.Boolean),
  tracerouteStats: Schema.optional(
    Schema.Union([
      Schema.Struct({
        availabilityPct: Schema.Struct({
          slots: Schema.Array(
            Schema.Struct({
              timestamp: Schema.String,
              value: Schema.Number,
            }),
          ),
          avg: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
          max: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
          min: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
        }),
        hopsCount: Schema.Unknown,
        packetLossPct: Schema.Struct({
          slots: Schema.Array(
            Schema.Struct({
              timestamp: Schema.String,
              value: Schema.Number,
            }),
          ),
          avg: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
          max: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
          min: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
        }),
        roundTripTimeMs: Schema.Unknown,
        uniqueDevicesTotal: Schema.Number,
      }),
      Schema.Null,
    ]),
  ),
  tracerouteStatsByColo: Schema.optional(
    Schema.Array(
      Schema.Struct({
        availabilityPct: Schema.Struct({
          slots: Schema.Array(
            Schema.Struct({
              timestamp: Schema.String,
              value: Schema.Number,
            }),
          ),
          avg: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
          max: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
          min: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
        }),
        colo: Schema.String,
        hopsCount: Schema.Unknown,
        packetLossPct: Schema.Struct({
          slots: Schema.Array(
            Schema.Struct({
              timestamp: Schema.String,
              value: Schema.Number,
            }),
          ),
          avg: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
          max: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
          min: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
        }),
        roundTripTimeMs: Schema.Unknown,
        uniqueDevicesTotal: Schema.Number,
      }),
    ),
  ),
}).pipe(
  Schema.encodeKeys({
    host: "host",
    interval: "interval",
    kind: "kind",
    name: "name",
    targetPolicies: "target_policies",
    targeted: "targeted",
    tracerouteStats: "tracerouteStats",
    tracerouteStatsByColo: "tracerouteStatsByColo",
  }),
) as unknown as Schema.Schema<GetDexTracerouteTestResponse>;

export type GetDexTracerouteTestError = CommonErrors;

export const getDexTracerouteTest: API.OperationMethod<
  GetDexTracerouteTestRequest,
  GetDexTracerouteTestResponse,
  GetDexTracerouteTestError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDexTracerouteTestRequest,
  output: GetDexTracerouteTestResponse,
  errors: [],
}));

export interface PercentilesDexTracerouteTestRequest {
  testId: string;
  /** Path param: unique identifier linked to an account in the API request path. */
  accountId: string;
  /** Query param: Start time for the query in ISO (RFC3339 - ISO 8601) format */
  from: string;
  /** Query param: End time for the query in ISO (RFC3339 - ISO 8601) format */
  to: string;
  /** Query param: Optionally filter result stats to a Cloudflare colo. Cannot be used in combination with deviceId param. */
  colo?: string;
  /** Query param: Optionally filter result stats to a specific device(s). Cannot be used in combination with colo param. */
  deviceId?: string[];
}

export const PercentilesDexTracerouteTestRequest = Schema.Struct({
  testId: Schema.String.pipe(T.HttpPath("testId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  from: Schema.String.pipe(T.HttpQuery("from")),
  to: Schema.String.pipe(T.HttpQuery("to")),
  colo: Schema.optional(Schema.String).pipe(T.HttpQuery("colo")),
  deviceId: Schema.optional(Schema.Array(Schema.String)).pipe(
    T.HttpQuery("deviceId"),
  ),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dex/traceroute-tests/{testId}/percentiles",
  }),
) as unknown as Schema.Schema<PercentilesDexTracerouteTestRequest>;

export interface PercentilesDexTracerouteTestResponse {
  hopsCount?: unknown;
  packetLossPct?: unknown;
  roundTripTimeMs?: unknown;
}

export const PercentilesDexTracerouteTestResponse = Schema.Struct({
  hopsCount: Schema.optional(Schema.Unknown),
  packetLossPct: Schema.optional(Schema.Unknown),
  roundTripTimeMs: Schema.optional(Schema.Unknown),
}) as unknown as Schema.Schema<PercentilesDexTracerouteTestResponse>;

export type PercentilesDexTracerouteTestError = CommonErrors;

export const percentilesDexTracerouteTest: API.OperationMethod<
  PercentilesDexTracerouteTestRequest,
  PercentilesDexTracerouteTestResponse,
  PercentilesDexTracerouteTestError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PercentilesDexTracerouteTestRequest,
  output: PercentilesDexTracerouteTestResponse,
  errors: [],
}));

// =============================================================================
// DexTracerouteTestResultNetworkPath
// =============================================================================

export interface GetDexTracerouteTestResultNetworkPathRequest {
  testResultId: string;
  /** unique identifier linked to an account */
  accountId: string;
}

export const GetDexTracerouteTestResultNetworkPathRequest = Schema.Struct({
  testResultId: Schema.String.pipe(T.HttpPath("testResultId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dex/traceroute-test-results/{testResultId}/network-path",
  }),
) as unknown as Schema.Schema<GetDexTracerouteTestResultNetworkPathRequest>;

export interface GetDexTracerouteTestResultNetworkPathResponse {
  /** an array of the hops taken by the device to reach the end destination */
  hops: {
    ttl: number;
    asn?: number | null;
    aso?: string | null;
    ipAddress?: string | null;
    location?: {
      city?: string | null;
      state?: string | null;
      zip?: string | null;
    } | null;
    mile?:
      | "client-to-app"
      | "client-to-cf-egress"
      | "client-to-cf-ingress"
      | "client-to-isp"
      | null;
    name?: string | null;
    packetLossPct?: number | null;
    rttMs?: number | null;
  }[];
  /** API Resource UUID tag. */
  resultId: string;
  /** name of the device associated with this network path response */
  deviceName?: string;
  /** API Resource UUID tag. */
  testId?: string;
  /** name of the tracroute test */
  testName?: string;
}

export const GetDexTracerouteTestResultNetworkPathResponse = Schema.Struct({
  hops: Schema.Array(
    Schema.Struct({
      ttl: Schema.Number,
      asn: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
      aso: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      ipAddress: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      location: Schema.optional(
        Schema.Union([
          Schema.Struct({
            city: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
            state: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
            zip: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
          }),
          Schema.Null,
        ]),
      ),
      mile: Schema.optional(
        Schema.Union([
          Schema.Literal("client-to-app"),
          Schema.Literal("client-to-cf-egress"),
          Schema.Literal("client-to-cf-ingress"),
          Schema.Literal("client-to-isp"),
          Schema.Null,
        ]),
      ),
      name: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      packetLossPct: Schema.optional(
        Schema.Union([Schema.Number, Schema.Null]),
      ),
      rttMs: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
    }),
  ),
  resultId: Schema.String,
  deviceName: Schema.optional(Schema.String),
  testId: Schema.optional(Schema.String),
  testName: Schema.optional(Schema.String),
}) as unknown as Schema.Schema<GetDexTracerouteTestResultNetworkPathResponse>;

export type GetDexTracerouteTestResultNetworkPathError = CommonErrors;

export const getDexTracerouteTestResultNetworkPath: API.OperationMethod<
  GetDexTracerouteTestResultNetworkPathRequest,
  GetDexTracerouteTestResultNetworkPathResponse,
  GetDexTracerouteTestResultNetworkPathError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDexTracerouteTestResultNetworkPathRequest,
  output: GetDexTracerouteTestResultNetworkPathResponse,
  errors: [],
}));

// =============================================================================
// DexWarpChangeEvent
// =============================================================================

export interface GetDexWarpChangeEventRequest {
  /** Path param: unique identifier linked to an account in the API request path */
  accountId: string;
  /** Query param: Start time for the query in ISO (RFC3339 - ISO 8601) format */
  from: string;
  /** Query param: Page number of paginated results */
  page: number;
  /** Query param: Number of items per page */
  perPage: number;
  /** Query param: End time for the query in ISO (RFC3339 - ISO 8601) format */
  to: string;
  /** Query param: Filter events by account name. */
  accountName?: string;
  /** Query param: Filter events by WARP configuration name changed from or to. Applicable to type='config' events only. */
  configName?: string;
  /** Query param: Sort response by event timestamp. */
  sortOrder?: "ASC" | "DESC";
  /** Query param: Filter events by type toggle value. Applicable to type='toggle' events only. */
  toggle?: "on" | "off";
  /** Query param: Filter events by type 'config' or 'toggle' */
  type?: "config" | "toggle";
}

export const GetDexWarpChangeEventRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  from: Schema.String.pipe(T.HttpQuery("from")),
  page: Schema.Number.pipe(T.HttpQuery("page")),
  perPage: Schema.Number.pipe(T.HttpQuery("per_page")),
  to: Schema.String.pipe(T.HttpQuery("to")),
  accountName: Schema.optional(Schema.String).pipe(T.HttpQuery("account_name")),
  configName: Schema.optional(Schema.String).pipe(T.HttpQuery("config_name")),
  sortOrder: Schema.optional(Schema.Literals(["ASC", "DESC"])).pipe(
    T.HttpQuery("sort_order"),
  ),
  toggle: Schema.optional(Schema.Literals(["on", "off"])).pipe(
    T.HttpQuery("toggle"),
  ),
  type: Schema.optional(Schema.Literals(["config", "toggle"])).pipe(
    T.HttpQuery("type"),
  ),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dex/warp-change-events",
  }),
) as unknown as Schema.Schema<GetDexWarpChangeEventRequest>;

export type GetDexWarpChangeEventResponse = (
  | {
      accountName?: string;
      accountTag?: string;
      deviceId?: string;
      deviceRegistration?: string;
      hostname?: string;
      serialNumber?: string;
      timestamp?: string;
      toggle?: "on" | "off";
      userEmail?: string;
    }
  | {
      deviceId?: string;
      deviceRegistration?: string;
      from?: { accountName?: string; accountTag?: string; configName?: string };
      hostname?: string;
      serialNumber?: string;
      timestamp?: string;
      to?: { accountName?: string; accountTag?: string; configName?: string };
      userEmail?: string;
    }
)[];

export const GetDexWarpChangeEventResponse = Schema.Array(
  Schema.Union([
    Schema.Struct({
      accountName: Schema.optional(Schema.String),
      accountTag: Schema.optional(Schema.String),
      deviceId: Schema.optional(Schema.String),
      deviceRegistration: Schema.optional(Schema.String),
      hostname: Schema.optional(Schema.String),
      serialNumber: Schema.optional(Schema.String),
      timestamp: Schema.optional(Schema.String),
      toggle: Schema.optional(Schema.Literals(["on", "off"])),
      userEmail: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        accountName: "account_name",
        accountTag: "account_tag",
        deviceId: "device_id",
        deviceRegistration: "device_registration",
        hostname: "hostname",
        serialNumber: "serial_number",
        timestamp: "timestamp",
        toggle: "toggle",
        userEmail: "user_email",
      }),
    ),
    Schema.Struct({
      deviceId: Schema.optional(Schema.String),
      deviceRegistration: Schema.optional(Schema.String),
      from: Schema.optional(
        Schema.Struct({
          accountName: Schema.optional(Schema.String),
          accountTag: Schema.optional(Schema.String),
          configName: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            accountName: "account_name",
            accountTag: "account_tag",
            configName: "config_name",
          }),
        ),
      ),
      hostname: Schema.optional(Schema.String),
      serialNumber: Schema.optional(Schema.String),
      timestamp: Schema.optional(Schema.String),
      to: Schema.optional(
        Schema.Struct({
          accountName: Schema.optional(Schema.String),
          accountTag: Schema.optional(Schema.String),
          configName: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            accountName: "account_name",
            accountTag: "account_tag",
            configName: "config_name",
          }),
        ),
      ),
      userEmail: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        deviceId: "device_id",
        deviceRegistration: "device_registration",
        from: "from",
        hostname: "hostname",
        serialNumber: "serial_number",
        timestamp: "timestamp",
        to: "to",
        userEmail: "user_email",
      }),
    ),
  ]),
) as unknown as Schema.Schema<GetDexWarpChangeEventResponse>;

export type GetDexWarpChangeEventError = CommonErrors;

export const getDexWarpChangeEvent: API.OperationMethod<
  GetDexWarpChangeEventRequest,
  GetDexWarpChangeEventResponse,
  GetDexWarpChangeEventError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDexWarpChangeEventRequest,
  output: GetDexWarpChangeEventResponse,
  errors: [],
}));

// =============================================================================
// DlpDataset
// =============================================================================

export interface GetDlpDatasetRequest {
  datasetId: string;
  accountId: string;
}

export const GetDlpDatasetRequest = Schema.Struct({
  datasetId: Schema.String.pipe(T.HttpPath("datasetId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dlp/datasets/{datasetId}",
  }),
) as unknown as Schema.Schema<GetDlpDatasetRequest>;

export interface GetDlpDatasetResponse {
  id: string;
  columns: {
    entryId: string;
    headerName: string;
    numCells: number;
    uploadStatus:
      | "empty"
      | "uploading"
      | "pending"
      | "processing"
      | "failed"
      | "complete";
  }[];
  createdAt: string;
  encodingVersion: number;
  name: string;
  numCells: number;
  secret: boolean;
  status:
    | "empty"
    | "uploading"
    | "pending"
    | "processing"
    | "failed"
    | "complete";
  /** Stores when the dataset was last updated.  This includes name or description changes as well as uploads. */
  updatedAt: string;
  uploads: {
    numCells: number;
    status:
      | "empty"
      | "uploading"
      | "pending"
      | "processing"
      | "failed"
      | "complete";
    version: number;
  }[];
  caseSensitive?: boolean;
  /** The description of the dataset. */
  description?: string | null;
}

export const GetDlpDatasetResponse = Schema.Struct({
  id: Schema.String,
  columns: Schema.Array(
    Schema.Struct({
      entryId: Schema.String,
      headerName: Schema.String,
      numCells: Schema.Number,
      uploadStatus: Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    }).pipe(
      Schema.encodeKeys({
        entryId: "entry_id",
        headerName: "header_name",
        numCells: "num_cells",
        uploadStatus: "upload_status",
      }),
    ),
  ),
  createdAt: Schema.String,
  encodingVersion: Schema.Number,
  name: Schema.String,
  numCells: Schema.Number,
  secret: Schema.Boolean,
  status: Schema.Literals([
    "empty",
    "uploading",
    "pending",
    "processing",
    "failed",
    "complete",
  ]),
  updatedAt: Schema.String,
  uploads: Schema.Array(
    Schema.Struct({
      numCells: Schema.Number,
      status: Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
      version: Schema.Number,
    }).pipe(
      Schema.encodeKeys({
        numCells: "num_cells",
        status: "status",
        version: "version",
      }),
    ),
  ),
  caseSensitive: Schema.optional(Schema.Boolean),
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    columns: "columns",
    createdAt: "created_at",
    encodingVersion: "encoding_version",
    name: "name",
    numCells: "num_cells",
    secret: "secret",
    status: "status",
    updatedAt: "updated_at",
    uploads: "uploads",
    caseSensitive: "case_sensitive",
    description: "description",
  }),
) as unknown as Schema.Schema<GetDlpDatasetResponse>;

export type GetDlpDatasetError = CommonErrors;

export const getDlpDataset: API.OperationMethod<
  GetDlpDatasetRequest,
  GetDlpDatasetResponse,
  GetDlpDatasetError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDlpDatasetRequest,
  output: GetDlpDatasetResponse,
  errors: [],
}));

export interface ListDlpDatasetsRequest {
  accountId: string;
}

export const ListDlpDatasetsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/datasets" }),
) as unknown as Schema.Schema<ListDlpDatasetsRequest>;

export type ListDlpDatasetsResponse = {
  id: string;
  columns: {
    entryId: string;
    headerName: string;
    numCells: number;
    uploadStatus:
      | "empty"
      | "uploading"
      | "pending"
      | "processing"
      | "failed"
      | "complete";
  }[];
  createdAt: string;
  encodingVersion: number;
  name: string;
  numCells: number;
  secret: boolean;
  status:
    | "empty"
    | "uploading"
    | "pending"
    | "processing"
    | "failed"
    | "complete";
  updatedAt: string;
  uploads: {
    numCells: number;
    status:
      | "empty"
      | "uploading"
      | "pending"
      | "processing"
      | "failed"
      | "complete";
    version: number;
  }[];
  caseSensitive?: boolean;
  description?: string | null;
}[];

export const ListDlpDatasetsResponse = Schema.Array(
  Schema.Struct({
    id: Schema.String,
    columns: Schema.Array(
      Schema.Struct({
        entryId: Schema.String,
        headerName: Schema.String,
        numCells: Schema.Number,
        uploadStatus: Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      }).pipe(
        Schema.encodeKeys({
          entryId: "entry_id",
          headerName: "header_name",
          numCells: "num_cells",
          uploadStatus: "upload_status",
        }),
      ),
    ),
    createdAt: Schema.String,
    encodingVersion: Schema.Number,
    name: Schema.String,
    numCells: Schema.Number,
    secret: Schema.Boolean,
    status: Schema.Literals([
      "empty",
      "uploading",
      "pending",
      "processing",
      "failed",
      "complete",
    ]),
    updatedAt: Schema.String,
    uploads: Schema.Array(
      Schema.Struct({
        numCells: Schema.Number,
        status: Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
        version: Schema.Number,
      }).pipe(
        Schema.encodeKeys({
          numCells: "num_cells",
          status: "status",
          version: "version",
        }),
      ),
    ),
    caseSensitive: Schema.optional(Schema.Boolean),
    description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      columns: "columns",
      createdAt: "created_at",
      encodingVersion: "encoding_version",
      name: "name",
      numCells: "num_cells",
      secret: "secret",
      status: "status",
      updatedAt: "updated_at",
      uploads: "uploads",
      caseSensitive: "case_sensitive",
      description: "description",
    }),
  ),
) as unknown as Schema.Schema<ListDlpDatasetsResponse>;

export type ListDlpDatasetsError = CommonErrors;

export const listDlpDatasets: API.OperationMethod<
  ListDlpDatasetsRequest,
  ListDlpDatasetsResponse,
  ListDlpDatasetsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDlpDatasetsRequest,
  output: ListDlpDatasetsResponse,
  errors: [],
}));

export interface CreateDlpDatasetRequest {
  /** Path param: */
  accountId: string;
  /** Body param: */
  name: string;
  /** Body param: Only applies to custom word lists. Determines if the words should be matched in a case-sensitive manner Cannot be set to false if `secret` is true or undefined */
  caseSensitive?: boolean;
  /** Body param: The description of the dataset. */
  description?: string | null;
  /** Body param: Dataset encoding version  Non-secret custom word lists with no header are always version 1. Secret EDM lists with no header are version 1. Multicolumn CSV with headers are version 2. Omitt */
  encodingVersion?: number;
  /** Body param: Generate a secret dataset.  If true, the response will include a secret to use with the EDM encoder. If false, the response has no secret and the dataset is uploaded in plaintext. */
  secret?: boolean;
}

export const CreateDlpDatasetRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.String,
  caseSensitive: Schema.optional(Schema.Boolean),
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  encodingVersion: Schema.optional(Schema.Number),
  secret: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    name: "name",
    caseSensitive: "case_sensitive",
    description: "description",
    encodingVersion: "encoding_version",
    secret: "secret",
  }),
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/datasets" }),
) as unknown as Schema.Schema<CreateDlpDatasetRequest>;

export interface CreateDlpDatasetResponse {
  dataset: {
    id: string;
    columns: {
      entryId: string;
      headerName: string;
      numCells: number;
      uploadStatus:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }[];
    createdAt: string;
    encodingVersion: number;
    name: string;
    numCells: number;
    secret: boolean;
    status:
      | "empty"
      | "uploading"
      | "pending"
      | "processing"
      | "failed"
      | "complete";
    updatedAt: string;
    uploads: {
      numCells: number;
      status:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
      version: number;
    }[];
    caseSensitive?: boolean;
    description?: string | null;
  };
  /** Encoding version to use for dataset. */
  encodingVersion: number;
  maxCells: number;
  /** The version to use when uploading the dataset. */
  version: number;
  /** The secret to use for Exact Data Match datasets.  This is not present in Custom Wordlists. */
  secret?: string;
}

export const CreateDlpDatasetResponse = Schema.Struct({
  dataset: Schema.Struct({
    id: Schema.String,
    columns: Schema.Array(
      Schema.Struct({
        entryId: Schema.String,
        headerName: Schema.String,
        numCells: Schema.Number,
        uploadStatus: Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      }).pipe(
        Schema.encodeKeys({
          entryId: "entry_id",
          headerName: "header_name",
          numCells: "num_cells",
          uploadStatus: "upload_status",
        }),
      ),
    ),
    createdAt: Schema.String,
    encodingVersion: Schema.Number,
    name: Schema.String,
    numCells: Schema.Number,
    secret: Schema.Boolean,
    status: Schema.Literals([
      "empty",
      "uploading",
      "pending",
      "processing",
      "failed",
      "complete",
    ]),
    updatedAt: Schema.String,
    uploads: Schema.Array(
      Schema.Struct({
        numCells: Schema.Number,
        status: Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
        version: Schema.Number,
      }).pipe(
        Schema.encodeKeys({
          numCells: "num_cells",
          status: "status",
          version: "version",
        }),
      ),
    ),
    caseSensitive: Schema.optional(Schema.Boolean),
    description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      columns: "columns",
      createdAt: "created_at",
      encodingVersion: "encoding_version",
      name: "name",
      numCells: "num_cells",
      secret: "secret",
      status: "status",
      updatedAt: "updated_at",
      uploads: "uploads",
      caseSensitive: "case_sensitive",
      description: "description",
    }),
  ),
  encodingVersion: Schema.Number,
  maxCells: Schema.Number,
  version: Schema.Number,
  secret: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    dataset: "dataset",
    encodingVersion: "encoding_version",
    maxCells: "max_cells",
    version: "version",
    secret: "secret",
  }),
) as unknown as Schema.Schema<CreateDlpDatasetResponse>;

export type CreateDlpDatasetError = CommonErrors;

export const createDlpDataset: API.OperationMethod<
  CreateDlpDatasetRequest,
  CreateDlpDatasetResponse,
  CreateDlpDatasetError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDlpDatasetRequest,
  output: CreateDlpDatasetResponse,
  errors: [],
}));

export interface UpdateDlpDatasetRequest {
  datasetId: string;
  /** Path param: */
  accountId: string;
  /** Body param: Determines if the words should be matched in a case-sensitive manner.  Only required for custom word lists. */
  caseSensitive?: boolean;
  /** Body param: The description of the dataset. */
  description?: string | null;
  /** Body param: The name of the dataset, must be unique. */
  name?: string | null;
}

export const UpdateDlpDatasetRequest = Schema.Struct({
  datasetId: Schema.String.pipe(T.HttpPath("datasetId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  caseSensitive: Schema.optional(Schema.Boolean),
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  name: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    caseSensitive: "case_sensitive",
    description: "description",
    name: "name",
  }),
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/dlp/datasets/{datasetId}",
  }),
) as unknown as Schema.Schema<UpdateDlpDatasetRequest>;

export interface UpdateDlpDatasetResponse {
  id: string;
  columns: {
    entryId: string;
    headerName: string;
    numCells: number;
    uploadStatus:
      | "empty"
      | "uploading"
      | "pending"
      | "processing"
      | "failed"
      | "complete";
  }[];
  createdAt: string;
  encodingVersion: number;
  name: string;
  numCells: number;
  secret: boolean;
  status:
    | "empty"
    | "uploading"
    | "pending"
    | "processing"
    | "failed"
    | "complete";
  /** Stores when the dataset was last updated.  This includes name or description changes as well as uploads. */
  updatedAt: string;
  uploads: {
    numCells: number;
    status:
      | "empty"
      | "uploading"
      | "pending"
      | "processing"
      | "failed"
      | "complete";
    version: number;
  }[];
  caseSensitive?: boolean;
  /** The description of the dataset. */
  description?: string | null;
}

export const UpdateDlpDatasetResponse = Schema.Struct({
  id: Schema.String,
  columns: Schema.Array(
    Schema.Struct({
      entryId: Schema.String,
      headerName: Schema.String,
      numCells: Schema.Number,
      uploadStatus: Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    }).pipe(
      Schema.encodeKeys({
        entryId: "entry_id",
        headerName: "header_name",
        numCells: "num_cells",
        uploadStatus: "upload_status",
      }),
    ),
  ),
  createdAt: Schema.String,
  encodingVersion: Schema.Number,
  name: Schema.String,
  numCells: Schema.Number,
  secret: Schema.Boolean,
  status: Schema.Literals([
    "empty",
    "uploading",
    "pending",
    "processing",
    "failed",
    "complete",
  ]),
  updatedAt: Schema.String,
  uploads: Schema.Array(
    Schema.Struct({
      numCells: Schema.Number,
      status: Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
      version: Schema.Number,
    }).pipe(
      Schema.encodeKeys({
        numCells: "num_cells",
        status: "status",
        version: "version",
      }),
    ),
  ),
  caseSensitive: Schema.optional(Schema.Boolean),
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    columns: "columns",
    createdAt: "created_at",
    encodingVersion: "encoding_version",
    name: "name",
    numCells: "num_cells",
    secret: "secret",
    status: "status",
    updatedAt: "updated_at",
    uploads: "uploads",
    caseSensitive: "case_sensitive",
    description: "description",
  }),
) as unknown as Schema.Schema<UpdateDlpDatasetResponse>;

export type UpdateDlpDatasetError = CommonErrors;

export const updateDlpDataset: API.OperationMethod<
  UpdateDlpDatasetRequest,
  UpdateDlpDatasetResponse,
  UpdateDlpDatasetError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDlpDatasetRequest,
  output: UpdateDlpDatasetResponse,
  errors: [],
}));

export interface DeleteDlpDatasetRequest {
  datasetId: string;
  accountId: string;
}

export const DeleteDlpDatasetRequest = Schema.Struct({
  datasetId: Schema.String.pipe(T.HttpPath("datasetId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/dlp/datasets/{datasetId}",
  }),
) as unknown as Schema.Schema<DeleteDlpDatasetRequest>;

export type DeleteDlpDatasetResponse = unknown;

export const DeleteDlpDatasetResponse =
  Schema.Unknown as unknown as Schema.Schema<DeleteDlpDatasetResponse>;

export type DeleteDlpDatasetError = CommonErrors;

export const deleteDlpDataset: API.OperationMethod<
  DeleteDlpDatasetRequest,
  DeleteDlpDatasetResponse,
  DeleteDlpDatasetError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDlpDatasetRequest,
  output: DeleteDlpDatasetResponse,
  errors: [],
}));

// =============================================================================
// DlpDatasetUpload
// =============================================================================

export interface CreateDlpDatasetUploadRequest {
  datasetId: string;
  accountId: string;
}

export const CreateDlpDatasetUploadRequest = Schema.Struct({
  datasetId: Schema.String.pipe(T.HttpPath("datasetId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/dlp/datasets/{datasetId}/upload",
  }),
) as unknown as Schema.Schema<CreateDlpDatasetUploadRequest>;

export interface CreateDlpDatasetUploadResponse {
  encodingVersion: number;
  maxCells: number;
  version: number;
  caseSensitive?: boolean;
  columns?: {
    entryId: string;
    headerName: string;
    numCells: number;
    uploadStatus:
      | "empty"
      | "uploading"
      | "pending"
      | "processing"
      | "failed"
      | "complete";
  }[];
  secret?: string;
}

export const CreateDlpDatasetUploadResponse = Schema.Struct({
  encodingVersion: Schema.Number,
  maxCells: Schema.Number,
  version: Schema.Number,
  caseSensitive: Schema.optional(Schema.Boolean),
  columns: Schema.optional(
    Schema.Array(
      Schema.Struct({
        entryId: Schema.String,
        headerName: Schema.String,
        numCells: Schema.Number,
        uploadStatus: Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      }).pipe(
        Schema.encodeKeys({
          entryId: "entry_id",
          headerName: "header_name",
          numCells: "num_cells",
          uploadStatus: "upload_status",
        }),
      ),
    ),
  ),
  secret: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    encodingVersion: "encoding_version",
    maxCells: "max_cells",
    version: "version",
    caseSensitive: "case_sensitive",
    columns: "columns",
    secret: "secret",
  }),
) as unknown as Schema.Schema<CreateDlpDatasetUploadResponse>;

export type CreateDlpDatasetUploadError = CommonErrors;

export const createDlpDatasetUpload: API.OperationMethod<
  CreateDlpDatasetUploadRequest,
  CreateDlpDatasetUploadResponse,
  CreateDlpDatasetUploadError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDlpDatasetUploadRequest,
  output: CreateDlpDatasetUploadResponse,
  errors: [],
}));

export interface EditDlpDatasetUploadRequest {
  datasetId: string;
  version: number;
  /** Path param: */
  accountId: string;
}

export const EditDlpDatasetUploadRequest = Schema.Struct({
  datasetId: Schema.String.pipe(T.HttpPath("datasetId")),
  version: Schema.Number.pipe(T.HttpPath("version")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/dlp/datasets/{datasetId}/upload/{version}",
  }),
) as unknown as Schema.Schema<EditDlpDatasetUploadRequest>;

export interface EditDlpDatasetUploadResponse {
  id: string;
  columns: {
    entryId: string;
    headerName: string;
    numCells: number;
    uploadStatus:
      | "empty"
      | "uploading"
      | "pending"
      | "processing"
      | "failed"
      | "complete";
  }[];
  createdAt: string;
  encodingVersion: number;
  name: string;
  numCells: number;
  secret: boolean;
  status:
    | "empty"
    | "uploading"
    | "pending"
    | "processing"
    | "failed"
    | "complete";
  /** Stores when the dataset was last updated.  This includes name or description changes as well as uploads. */
  updatedAt: string;
  uploads: {
    numCells: number;
    status:
      | "empty"
      | "uploading"
      | "pending"
      | "processing"
      | "failed"
      | "complete";
    version: number;
  }[];
  caseSensitive?: boolean;
  /** The description of the dataset. */
  description?: string | null;
}

export const EditDlpDatasetUploadResponse = Schema.Struct({
  id: Schema.String,
  columns: Schema.Array(
    Schema.Struct({
      entryId: Schema.String,
      headerName: Schema.String,
      numCells: Schema.Number,
      uploadStatus: Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    }).pipe(
      Schema.encodeKeys({
        entryId: "entry_id",
        headerName: "header_name",
        numCells: "num_cells",
        uploadStatus: "upload_status",
      }),
    ),
  ),
  createdAt: Schema.String,
  encodingVersion: Schema.Number,
  name: Schema.String,
  numCells: Schema.Number,
  secret: Schema.Boolean,
  status: Schema.Literals([
    "empty",
    "uploading",
    "pending",
    "processing",
    "failed",
    "complete",
  ]),
  updatedAt: Schema.String,
  uploads: Schema.Array(
    Schema.Struct({
      numCells: Schema.Number,
      status: Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
      version: Schema.Number,
    }).pipe(
      Schema.encodeKeys({
        numCells: "num_cells",
        status: "status",
        version: "version",
      }),
    ),
  ),
  caseSensitive: Schema.optional(Schema.Boolean),
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    columns: "columns",
    createdAt: "created_at",
    encodingVersion: "encoding_version",
    name: "name",
    numCells: "num_cells",
    secret: "secret",
    status: "status",
    updatedAt: "updated_at",
    uploads: "uploads",
    caseSensitive: "case_sensitive",
    description: "description",
  }),
) as unknown as Schema.Schema<EditDlpDatasetUploadResponse>;

export type EditDlpDatasetUploadError = CommonErrors;

export const editDlpDatasetUpload: API.OperationMethod<
  EditDlpDatasetUploadRequest,
  EditDlpDatasetUploadResponse,
  EditDlpDatasetUploadError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: EditDlpDatasetUploadRequest,
  output: EditDlpDatasetUploadResponse,
  errors: [],
}));

// =============================================================================
// DlpDatasetVersion
// =============================================================================

export interface CreateDlpDatasetVersionRequest {
  datasetId: string;
  version: number;
  /** Path param: */
  accountId: string;
  /** Body param: */
  body: (
    | { entryId: string; headerName?: string; numCells?: number }
    | { entryName: string; headerName?: string; numCells?: number }
  )[];
}

export const CreateDlpDatasetVersionRequest = Schema.Struct({
  datasetId: Schema.String.pipe(T.HttpPath("datasetId")),
  version: Schema.Number.pipe(T.HttpPath("version")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(
    Schema.Union([
      Schema.Struct({
        entryId: Schema.String,
        headerName: Schema.optional(Schema.String),
        numCells: Schema.optional(Schema.Number),
      }).pipe(
        Schema.encodeKeys({
          entryId: "entry_id",
          headerName: "header_name",
          numCells: "num_cells",
        }),
      ),
      Schema.Struct({
        entryName: Schema.String,
        headerName: Schema.optional(Schema.String),
        numCells: Schema.optional(Schema.Number),
      }).pipe(
        Schema.encodeKeys({
          entryName: "entry_name",
          headerName: "header_name",
          numCells: "num_cells",
        }),
      ),
    ]),
  ).pipe(T.HttpBody()),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dlp/datasets/{datasetId}/versions/{version}",
  }),
) as unknown as Schema.Schema<CreateDlpDatasetVersionRequest>;

export type CreateDlpDatasetVersionResponse = {
  entryId: string;
  headerName: string;
  numCells: number;
  uploadStatus:
    | "empty"
    | "uploading"
    | "pending"
    | "processing"
    | "failed"
    | "complete";
}[];

export const CreateDlpDatasetVersionResponse = Schema.Array(
  Schema.Struct({
    entryId: Schema.String,
    headerName: Schema.String,
    numCells: Schema.Number,
    uploadStatus: Schema.Literals([
      "empty",
      "uploading",
      "pending",
      "processing",
      "failed",
      "complete",
    ]),
  }).pipe(
    Schema.encodeKeys({
      entryId: "entry_id",
      headerName: "header_name",
      numCells: "num_cells",
      uploadStatus: "upload_status",
    }),
  ),
) as unknown as Schema.Schema<CreateDlpDatasetVersionResponse>;

export type CreateDlpDatasetVersionError = CommonErrors;

export const createDlpDatasetVersion: API.OperationMethod<
  CreateDlpDatasetVersionRequest,
  CreateDlpDatasetVersionResponse,
  CreateDlpDatasetVersionError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDlpDatasetVersionRequest,
  output: CreateDlpDatasetVersionResponse,
  errors: [],
}));

// =============================================================================
// DlpDatasetVersionEntry
// =============================================================================

export interface CreateDlpDatasetVersionEntryRequest {
  datasetId: string;
  version: number;
  entryId: string;
  /** Path param: */
  accountId: string;
}

export const CreateDlpDatasetVersionEntryRequest = Schema.Struct({
  datasetId: Schema.String.pipe(T.HttpPath("datasetId")),
  version: Schema.Number.pipe(T.HttpPath("version")),
  entryId: Schema.String.pipe(T.HttpPath("entryId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/dlp/datasets/{datasetId}/versions/{version}/entries/{entryId}",
  }),
) as unknown as Schema.Schema<CreateDlpDatasetVersionEntryRequest>;

export interface CreateDlpDatasetVersionEntryResponse {
  entryId: string;
  headerName: string;
  numCells: number;
  uploadStatus:
    | "empty"
    | "uploading"
    | "pending"
    | "processing"
    | "failed"
    | "complete";
}

export const CreateDlpDatasetVersionEntryResponse = Schema.Struct({
  entryId: Schema.String,
  headerName: Schema.String,
  numCells: Schema.Number,
  uploadStatus: Schema.Literals([
    "empty",
    "uploading",
    "pending",
    "processing",
    "failed",
    "complete",
  ]),
}).pipe(
  Schema.encodeKeys({
    entryId: "entry_id",
    headerName: "header_name",
    numCells: "num_cells",
    uploadStatus: "upload_status",
  }),
) as unknown as Schema.Schema<CreateDlpDatasetVersionEntryResponse>;

export type CreateDlpDatasetVersionEntryError = CommonErrors;

export const createDlpDatasetVersionEntry: API.OperationMethod<
  CreateDlpDatasetVersionEntryRequest,
  CreateDlpDatasetVersionEntryResponse,
  CreateDlpDatasetVersionEntryError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDlpDatasetVersionEntryRequest,
  output: CreateDlpDatasetVersionEntryResponse,
  errors: [],
}));

// =============================================================================
// DlpEmailAccountMapping
// =============================================================================

export interface GetDlpEmailAccountMappingRequest {
  accountId: string;
}

export const GetDlpEmailAccountMappingRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dlp/email/account_mapping",
  }),
) as unknown as Schema.Schema<GetDlpEmailAccountMappingRequest>;

export interface GetDlpEmailAccountMappingResponse {
  addinIdentifierToken: string;
  authRequirements:
    | { allowedMicrosoftOrganizations: string[]; type: "Org" }
    | { type: "NoAuth" };
}

export const GetDlpEmailAccountMappingResponse = Schema.Struct({
  addinIdentifierToken: Schema.String,
  authRequirements: Schema.Union([
    Schema.Struct({
      allowedMicrosoftOrganizations: Schema.Array(Schema.String),
      type: Schema.Literal("Org"),
    }).pipe(
      Schema.encodeKeys({
        allowedMicrosoftOrganizations: "allowed_microsoft_organizations",
        type: "type",
      }),
    ),
    Schema.Struct({
      type: Schema.Literal("NoAuth"),
    }),
  ]),
}).pipe(
  Schema.encodeKeys({
    addinIdentifierToken: "addin_identifier_token",
    authRequirements: "auth_requirements",
  }),
) as unknown as Schema.Schema<GetDlpEmailAccountMappingResponse>;

export type GetDlpEmailAccountMappingError = CommonErrors;

export const getDlpEmailAccountMapping: API.OperationMethod<
  GetDlpEmailAccountMappingRequest,
  GetDlpEmailAccountMappingResponse,
  GetDlpEmailAccountMappingError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDlpEmailAccountMappingRequest,
  output: GetDlpEmailAccountMappingResponse,
  errors: [],
}));

export interface CreateDlpEmailAccountMappingRequest {
  /** Path param: */
  accountId: string;
  /** Body param: */
  authRequirements:
    | { allowedMicrosoftOrganizations: string[]; type: "Org" }
    | { type: "NoAuth" };
}

export const CreateDlpEmailAccountMappingRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  authRequirements: Schema.Union([
    Schema.Struct({
      allowedMicrosoftOrganizations: Schema.Array(Schema.String),
      type: Schema.Literal("Org"),
    }).pipe(
      Schema.encodeKeys({
        allowedMicrosoftOrganizations: "allowed_microsoft_organizations",
        type: "type",
      }),
    ),
    Schema.Struct({
      type: Schema.Literal("NoAuth"),
    }),
  ]),
}).pipe(
  Schema.encodeKeys({ authRequirements: "auth_requirements" }),
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/dlp/email/account_mapping",
  }),
) as unknown as Schema.Schema<CreateDlpEmailAccountMappingRequest>;

export interface CreateDlpEmailAccountMappingResponse {
  addinIdentifierToken: string;
  authRequirements:
    | { allowedMicrosoftOrganizations: string[]; type: "Org" }
    | { type: "NoAuth" };
}

export const CreateDlpEmailAccountMappingResponse = Schema.Struct({
  addinIdentifierToken: Schema.String,
  authRequirements: Schema.Union([
    Schema.Struct({
      allowedMicrosoftOrganizations: Schema.Array(Schema.String),
      type: Schema.Literal("Org"),
    }).pipe(
      Schema.encodeKeys({
        allowedMicrosoftOrganizations: "allowed_microsoft_organizations",
        type: "type",
      }),
    ),
    Schema.Struct({
      type: Schema.Literal("NoAuth"),
    }),
  ]),
}).pipe(
  Schema.encodeKeys({
    addinIdentifierToken: "addin_identifier_token",
    authRequirements: "auth_requirements",
  }),
) as unknown as Schema.Schema<CreateDlpEmailAccountMappingResponse>;

export type CreateDlpEmailAccountMappingError = CommonErrors;

export const createDlpEmailAccountMapping: API.OperationMethod<
  CreateDlpEmailAccountMappingRequest,
  CreateDlpEmailAccountMappingResponse,
  CreateDlpEmailAccountMappingError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDlpEmailAccountMappingRequest,
  output: CreateDlpEmailAccountMappingResponse,
  errors: [],
}));

// =============================================================================
// DlpEmailRule
// =============================================================================

export interface GetDlpEmailRuleRequest {
  ruleId: string;
  accountId: string;
}

export const GetDlpEmailRuleRequest = Schema.Struct({
  ruleId: Schema.String.pipe(T.HttpPath("ruleId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dlp/email/rules/{ruleId}",
  }),
) as unknown as Schema.Schema<GetDlpEmailRuleRequest>;

export interface GetDlpEmailRuleResponse {
  action: { action: "Block"; message?: string | null };
  /** Triggered if all conditions match. */
  conditions: {
    operator: "InList" | "NotInList" | "MatchRegex" | "NotMatchRegex";
    selector: "Recipients" | "Sender" | "DLPProfiles";
    value: string[] | string;
  }[];
  createdAt: string;
  enabled: boolean;
  name: string;
  priority: number;
  ruleId: string;
  updatedAt: string;
  description?: string | null;
}

export const GetDlpEmailRuleResponse = Schema.Struct({
  action: Schema.Struct({
    action: Schema.Literal("Block"),
    message: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }),
  conditions: Schema.Array(
    Schema.Struct({
      operator: Schema.Literals([
        "InList",
        "NotInList",
        "MatchRegex",
        "NotMatchRegex",
      ]),
      selector: Schema.Literals(["Recipients", "Sender", "DLPProfiles"]),
      value: Schema.Union([Schema.Array(Schema.String), Schema.String]),
    }),
  ),
  createdAt: Schema.String,
  enabled: Schema.Boolean,
  name: Schema.String,
  priority: Schema.Number,
  ruleId: Schema.String,
  updatedAt: Schema.String,
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    action: "action",
    conditions: "conditions",
    createdAt: "created_at",
    enabled: "enabled",
    name: "name",
    priority: "priority",
    ruleId: "rule_id",
    updatedAt: "updated_at",
    description: "description",
  }),
) as unknown as Schema.Schema<GetDlpEmailRuleResponse>;

export type GetDlpEmailRuleError = CommonErrors;

export const getDlpEmailRule: API.OperationMethod<
  GetDlpEmailRuleRequest,
  GetDlpEmailRuleResponse,
  GetDlpEmailRuleError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDlpEmailRuleRequest,
  output: GetDlpEmailRuleResponse,
  errors: [],
}));

export interface ListDlpEmailRulesRequest {
  accountId: string;
}

export const ListDlpEmailRulesRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/email/rules" }),
) as unknown as Schema.Schema<ListDlpEmailRulesRequest>;

export type ListDlpEmailRulesResponse = {
  action: { action: "Block"; message?: string | null };
  conditions: {
    operator: "InList" | "NotInList" | "MatchRegex" | "NotMatchRegex";
    selector: "Recipients" | "Sender" | "DLPProfiles";
    value: string[] | string;
  }[];
  createdAt: string;
  enabled: boolean;
  name: string;
  priority: number;
  ruleId: string;
  updatedAt: string;
  description?: string | null;
}[];

export const ListDlpEmailRulesResponse = Schema.Array(
  Schema.Struct({
    action: Schema.Struct({
      action: Schema.Literal("Block"),
      message: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    }),
    conditions: Schema.Array(
      Schema.Struct({
        operator: Schema.Literals([
          "InList",
          "NotInList",
          "MatchRegex",
          "NotMatchRegex",
        ]),
        selector: Schema.Literals(["Recipients", "Sender", "DLPProfiles"]),
        value: Schema.Union([Schema.Array(Schema.String), Schema.String]),
      }),
    ),
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    priority: Schema.Number,
    ruleId: Schema.String,
    updatedAt: Schema.String,
    description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }).pipe(
    Schema.encodeKeys({
      action: "action",
      conditions: "conditions",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      priority: "priority",
      ruleId: "rule_id",
      updatedAt: "updated_at",
      description: "description",
    }),
  ),
) as unknown as Schema.Schema<ListDlpEmailRulesResponse>;

export type ListDlpEmailRulesError = CommonErrors;

export const listDlpEmailRules: API.OperationMethod<
  ListDlpEmailRulesRequest,
  ListDlpEmailRulesResponse,
  ListDlpEmailRulesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDlpEmailRulesRequest,
  output: ListDlpEmailRulesResponse,
  errors: [],
}));

export interface CreateDlpEmailRuleRequest {
  /** Path param: */
  accountId: string;
  /** Body param: */
  action: { action: "Block"; message?: string | null };
  /** Body param: Triggered if all conditions match. */
  conditions: {
    operator: "InList" | "NotInList" | "MatchRegex" | "NotMatchRegex";
    selector: "Recipients" | "Sender" | "DLPProfiles";
    value: string[] | string;
  }[];
  /** Body param: */
  enabled: boolean;
  /** Body param: */
  name: string;
  /** Body param: */
  description?: string | null;
}

export const CreateDlpEmailRuleRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  action: Schema.Struct({
    action: Schema.Literal("Block"),
    message: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }),
  conditions: Schema.Array(
    Schema.Struct({
      operator: Schema.Literals([
        "InList",
        "NotInList",
        "MatchRegex",
        "NotMatchRegex",
      ]),
      selector: Schema.Literals(["Recipients", "Sender", "DLPProfiles"]),
      value: Schema.Union([Schema.Array(Schema.String), Schema.String]),
    }),
  ),
  enabled: Schema.Boolean,
  name: Schema.String,
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/email/rules" }),
) as unknown as Schema.Schema<CreateDlpEmailRuleRequest>;

export interface CreateDlpEmailRuleResponse {
  action: { action: "Block"; message?: string | null };
  /** Triggered if all conditions match. */
  conditions: {
    operator: "InList" | "NotInList" | "MatchRegex" | "NotMatchRegex";
    selector: "Recipients" | "Sender" | "DLPProfiles";
    value: string[] | string;
  }[];
  createdAt: string;
  enabled: boolean;
  name: string;
  priority: number;
  ruleId: string;
  updatedAt: string;
  description?: string | null;
}

export const CreateDlpEmailRuleResponse = Schema.Struct({
  action: Schema.Struct({
    action: Schema.Literal("Block"),
    message: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }),
  conditions: Schema.Array(
    Schema.Struct({
      operator: Schema.Literals([
        "InList",
        "NotInList",
        "MatchRegex",
        "NotMatchRegex",
      ]),
      selector: Schema.Literals(["Recipients", "Sender", "DLPProfiles"]),
      value: Schema.Union([Schema.Array(Schema.String), Schema.String]),
    }),
  ),
  createdAt: Schema.String,
  enabled: Schema.Boolean,
  name: Schema.String,
  priority: Schema.Number,
  ruleId: Schema.String,
  updatedAt: Schema.String,
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    action: "action",
    conditions: "conditions",
    createdAt: "created_at",
    enabled: "enabled",
    name: "name",
    priority: "priority",
    ruleId: "rule_id",
    updatedAt: "updated_at",
    description: "description",
  }),
) as unknown as Schema.Schema<CreateDlpEmailRuleResponse>;

export type CreateDlpEmailRuleError = CommonErrors;

export const createDlpEmailRule: API.OperationMethod<
  CreateDlpEmailRuleRequest,
  CreateDlpEmailRuleResponse,
  CreateDlpEmailRuleError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDlpEmailRuleRequest,
  output: CreateDlpEmailRuleResponse,
  errors: [],
}));

export interface UpdateDlpEmailRuleRequest {
  ruleId: string;
  /** Path param: */
  accountId: string;
  /** Body param: */
  action: { action: "Block"; message?: string | null };
  /** Body param: Triggered if all conditions match. */
  conditions: {
    operator: "InList" | "NotInList" | "MatchRegex" | "NotMatchRegex";
    selector: "Recipients" | "Sender" | "DLPProfiles";
    value: string[] | string;
  }[];
  /** Body param: */
  enabled: boolean;
  /** Body param: */
  name: string;
  /** Body param: */
  description?: string | null;
}

export const UpdateDlpEmailRuleRequest = Schema.Struct({
  ruleId: Schema.String.pipe(T.HttpPath("ruleId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  action: Schema.Struct({
    action: Schema.Literal("Block"),
    message: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }),
  conditions: Schema.Array(
    Schema.Struct({
      operator: Schema.Literals([
        "InList",
        "NotInList",
        "MatchRegex",
        "NotMatchRegex",
      ]),
      selector: Schema.Literals(["Recipients", "Sender", "DLPProfiles"]),
      value: Schema.Union([Schema.Array(Schema.String), Schema.String]),
    }),
  ),
  enabled: Schema.Boolean,
  name: Schema.String,
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/dlp/email/rules/{ruleId}",
  }),
) as unknown as Schema.Schema<UpdateDlpEmailRuleRequest>;

export interface UpdateDlpEmailRuleResponse {
  action: { action: "Block"; message?: string | null };
  /** Triggered if all conditions match. */
  conditions: {
    operator: "InList" | "NotInList" | "MatchRegex" | "NotMatchRegex";
    selector: "Recipients" | "Sender" | "DLPProfiles";
    value: string[] | string;
  }[];
  createdAt: string;
  enabled: boolean;
  name: string;
  priority: number;
  ruleId: string;
  updatedAt: string;
  description?: string | null;
}

export const UpdateDlpEmailRuleResponse = Schema.Struct({
  action: Schema.Struct({
    action: Schema.Literal("Block"),
    message: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }),
  conditions: Schema.Array(
    Schema.Struct({
      operator: Schema.Literals([
        "InList",
        "NotInList",
        "MatchRegex",
        "NotMatchRegex",
      ]),
      selector: Schema.Literals(["Recipients", "Sender", "DLPProfiles"]),
      value: Schema.Union([Schema.Array(Schema.String), Schema.String]),
    }),
  ),
  createdAt: Schema.String,
  enabled: Schema.Boolean,
  name: Schema.String,
  priority: Schema.Number,
  ruleId: Schema.String,
  updatedAt: Schema.String,
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    action: "action",
    conditions: "conditions",
    createdAt: "created_at",
    enabled: "enabled",
    name: "name",
    priority: "priority",
    ruleId: "rule_id",
    updatedAt: "updated_at",
    description: "description",
  }),
) as unknown as Schema.Schema<UpdateDlpEmailRuleResponse>;

export type UpdateDlpEmailRuleError = CommonErrors;

export const updateDlpEmailRule: API.OperationMethod<
  UpdateDlpEmailRuleRequest,
  UpdateDlpEmailRuleResponse,
  UpdateDlpEmailRuleError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDlpEmailRuleRequest,
  output: UpdateDlpEmailRuleResponse,
  errors: [],
}));

export interface DeleteDlpEmailRuleRequest {
  ruleId: string;
  accountId: string;
}

export const DeleteDlpEmailRuleRequest = Schema.Struct({
  ruleId: Schema.String.pipe(T.HttpPath("ruleId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/dlp/email/rules/{ruleId}",
  }),
) as unknown as Schema.Schema<DeleteDlpEmailRuleRequest>;

export interface DeleteDlpEmailRuleResponse {
  action: { action: "Block"; message?: string | null };
  /** Triggered if all conditions match. */
  conditions: {
    operator: "InList" | "NotInList" | "MatchRegex" | "NotMatchRegex";
    selector: "Recipients" | "Sender" | "DLPProfiles";
    value: string[] | string;
  }[];
  createdAt: string;
  enabled: boolean;
  name: string;
  priority: number;
  ruleId: string;
  updatedAt: string;
  description?: string | null;
}

export const DeleteDlpEmailRuleResponse = Schema.Struct({
  action: Schema.Struct({
    action: Schema.Literal("Block"),
    message: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }),
  conditions: Schema.Array(
    Schema.Struct({
      operator: Schema.Literals([
        "InList",
        "NotInList",
        "MatchRegex",
        "NotMatchRegex",
      ]),
      selector: Schema.Literals(["Recipients", "Sender", "DLPProfiles"]),
      value: Schema.Union([Schema.Array(Schema.String), Schema.String]),
    }),
  ),
  createdAt: Schema.String,
  enabled: Schema.Boolean,
  name: Schema.String,
  priority: Schema.Number,
  ruleId: Schema.String,
  updatedAt: Schema.String,
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    action: "action",
    conditions: "conditions",
    createdAt: "created_at",
    enabled: "enabled",
    name: "name",
    priority: "priority",
    ruleId: "rule_id",
    updatedAt: "updated_at",
    description: "description",
  }),
) as unknown as Schema.Schema<DeleteDlpEmailRuleResponse>;

export type DeleteDlpEmailRuleError = CommonErrors;

export const deleteDlpEmailRule: API.OperationMethod<
  DeleteDlpEmailRuleRequest,
  DeleteDlpEmailRuleResponse,
  DeleteDlpEmailRuleError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDlpEmailRuleRequest,
  output: DeleteDlpEmailRuleResponse,
  errors: [],
}));

export interface BulkPatchDlpEmailRulesRequest {
  /** Path param: */
  accountId: string;
  /** Body param: */
  newPriorities: Record<string, unknown>;
}

export const BulkPatchDlpEmailRulesRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  newPriorities: Schema.Struct({}),
}).pipe(
  Schema.encodeKeys({ newPriorities: "new_priorities" }),
  T.Http({ method: "PATCH", path: "/accounts/{account_id}/dlp/email/rules" }),
) as unknown as Schema.Schema<BulkPatchDlpEmailRulesRequest>;

export interface BulkPatchDlpEmailRulesResponse {
  action: { action: "Block"; message?: string | null };
  /** Triggered if all conditions match. */
  conditions: {
    operator: "InList" | "NotInList" | "MatchRegex" | "NotMatchRegex";
    selector: "Recipients" | "Sender" | "DLPProfiles";
    value: string[] | string;
  }[];
  createdAt: string;
  enabled: boolean;
  name: string;
  priority: number;
  ruleId: string;
  updatedAt: string;
  description?: string | null;
}

export const BulkPatchDlpEmailRulesResponse = Schema.Struct({
  action: Schema.Struct({
    action: Schema.Literal("Block"),
    message: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }),
  conditions: Schema.Array(
    Schema.Struct({
      operator: Schema.Literals([
        "InList",
        "NotInList",
        "MatchRegex",
        "NotMatchRegex",
      ]),
      selector: Schema.Literals(["Recipients", "Sender", "DLPProfiles"]),
      value: Schema.Union([Schema.Array(Schema.String), Schema.String]),
    }),
  ),
  createdAt: Schema.String,
  enabled: Schema.Boolean,
  name: Schema.String,
  priority: Schema.Number,
  ruleId: Schema.String,
  updatedAt: Schema.String,
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    action: "action",
    conditions: "conditions",
    createdAt: "created_at",
    enabled: "enabled",
    name: "name",
    priority: "priority",
    ruleId: "rule_id",
    updatedAt: "updated_at",
    description: "description",
  }),
) as unknown as Schema.Schema<BulkPatchDlpEmailRulesResponse>;

export type BulkPatchDlpEmailRulesError = CommonErrors;

export const bulkPatchDlpEmailRules: API.OperationMethod<
  BulkPatchDlpEmailRulesRequest,
  BulkPatchDlpEmailRulesResponse,
  BulkPatchDlpEmailRulesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: BulkPatchDlpEmailRulesRequest,
  output: BulkPatchDlpEmailRulesResponse,
  errors: [],
}));

// =============================================================================
// DlpEntry
// =============================================================================

export interface GetDlpEntryRequest {
  entryId: string;
  accountId: string;
}

export const GetDlpEntryRequest = Schema.Struct({
  entryId: Schema.String.pipe(T.HttpPath("entryId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dlp/entries/{entryId}",
  }),
) as unknown as Schema.Schema<GetDlpEntryRequest>;

export type GetDlpEntryResponse =
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      pattern: unknown;
      type: "custom";
      updatedAt: string;
      profileId?: string | null;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      confidence: { aiContextAvailable: boolean; available: boolean };
      enabled: boolean;
      name: string;
      type: "predefined";
      profileId?: string | null;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
      variant?: {
        topicType: "Intent" | "Content";
        type: "PromptTopic";
        description?: string | null;
      };
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "integration";
      updatedAt: string;
      profileId?: string | null;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      caseSensitive: boolean;
      createdAt: string;
      enabled: boolean;
      name: string;
      secret: boolean;
      type: "exact_data";
      updatedAt: string;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "document_fingerprint";
      updatedAt: string;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "word_list";
      updatedAt: string;
      wordList: unknown;
      profileId?: string | null;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    };

export const GetDlpEntryResponse = Schema.Union([
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    pattern: Schema.Unknown,
    type: Schema.Literal("custom"),
    updatedAt: Schema.String,
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      pattern: "pattern",
      type: "type",
      updatedAt: "updated_at",
      profileId: "profile_id",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    confidence: Schema.Struct({
      aiContextAvailable: Schema.Boolean,
      available: Schema.Boolean,
    }).pipe(
      Schema.encodeKeys({
        aiContextAvailable: "ai_context_available",
        available: "available",
      }),
    ),
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("predefined"),
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
    variant: Schema.optional(
      Schema.Struct({
        topicType: Schema.Literals(["Intent", "Content"]),
        type: Schema.Literal("PromptTopic"),
        description: Schema.optional(
          Schema.Union([Schema.String, Schema.Null]),
        ),
      }).pipe(
        Schema.encodeKeys({
          topicType: "topic_type",
          type: "type",
          description: "description",
        }),
      ),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      confidence: "confidence",
      enabled: "enabled",
      name: "name",
      type: "type",
      profileId: "profile_id",
      profiles: "profiles",
      uploadStatus: "upload_status",
      variant: "variant",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("integration"),
    updatedAt: Schema.String,
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
      profileId: "profile_id",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    caseSensitive: Schema.Boolean,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    secret: Schema.Boolean,
    type: Schema.Literal("exact_data"),
    updatedAt: Schema.String,
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      caseSensitive: "case_sensitive",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      secret: "secret",
      type: "type",
      updatedAt: "updated_at",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("document_fingerprint"),
    updatedAt: Schema.String,
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("word_list"),
    updatedAt: Schema.String,
    wordList: Schema.Unknown,
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
      wordList: "word_list",
      profileId: "profile_id",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
]) as unknown as Schema.Schema<GetDlpEntryResponse>;

export type GetDlpEntryError = CommonErrors;

export const getDlpEntry: API.OperationMethod<
  GetDlpEntryRequest,
  GetDlpEntryResponse,
  GetDlpEntryError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDlpEntryRequest,
  output: GetDlpEntryResponse,
  errors: [],
}));

export interface ListDlpEntriesRequest {
  accountId: string;
}

export const ListDlpEntriesRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/entries" }),
) as unknown as Schema.Schema<ListDlpEntriesRequest>;

export type ListDlpEntriesResponse = (
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      pattern: unknown;
      type: "custom";
      updatedAt: string;
      profileId?: string | null;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      confidence: { aiContextAvailable: boolean; available: boolean };
      enabled: boolean;
      name: string;
      type: "predefined";
      profileId?: string | null;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
      variant?: {
        topicType: "Intent" | "Content";
        type: "PromptTopic";
        description?: string | null;
      };
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "integration";
      updatedAt: string;
      profileId?: string | null;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      caseSensitive: boolean;
      createdAt: string;
      enabled: boolean;
      name: string;
      secret: boolean;
      type: "exact_data";
      updatedAt: string;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "document_fingerprint";
      updatedAt: string;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "word_list";
      updatedAt: string;
      wordList: unknown;
      profileId?: string | null;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
)[];

export const ListDlpEntriesResponse = Schema.Array(
  Schema.Union([
    Schema.Struct({
      id: Schema.String,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      pattern: Schema.Unknown,
      type: Schema.Literal("custom"),
      updatedAt: Schema.String,
      profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        pattern: "pattern",
        type: "type",
        updatedAt: "updated_at",
        profileId: "profile_id",
        uploadStatus: "upload_status",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      confidence: Schema.Struct({
        aiContextAvailable: Schema.Boolean,
        available: Schema.Boolean,
      }).pipe(
        Schema.encodeKeys({
          aiContextAvailable: "ai_context_available",
          available: "available",
        }),
      ),
      enabled: Schema.Boolean,
      name: Schema.String,
      type: Schema.Literal("predefined"),
      profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
      variant: Schema.optional(
        Schema.Struct({
          topicType: Schema.Literals(["Intent", "Content"]),
          type: Schema.Literal("PromptTopic"),
          description: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            topicType: "topic_type",
            type: "type",
            description: "description",
          }),
        ),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        confidence: "confidence",
        enabled: "enabled",
        name: "name",
        type: "type",
        profileId: "profile_id",
        uploadStatus: "upload_status",
        variant: "variant",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      type: Schema.Literal("integration"),
      updatedAt: Schema.String,
      profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        type: "type",
        updatedAt: "updated_at",
        profileId: "profile_id",
        uploadStatus: "upload_status",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      caseSensitive: Schema.Boolean,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      secret: Schema.Boolean,
      type: Schema.Literal("exact_data"),
      updatedAt: Schema.String,
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        caseSensitive: "case_sensitive",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        secret: "secret",
        type: "type",
        updatedAt: "updated_at",
        uploadStatus: "upload_status",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      type: Schema.Literal("document_fingerprint"),
      updatedAt: Schema.String,
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        type: "type",
        updatedAt: "updated_at",
        uploadStatus: "upload_status",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      type: Schema.Literal("word_list"),
      updatedAt: Schema.String,
      wordList: Schema.Unknown,
      profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        type: "type",
        updatedAt: "updated_at",
        wordList: "word_list",
        profileId: "profile_id",
        uploadStatus: "upload_status",
      }),
    ),
  ]),
) as unknown as Schema.Schema<ListDlpEntriesResponse>;

export type ListDlpEntriesError = CommonErrors;

export const listDlpEntries: API.OperationMethod<
  ListDlpEntriesRequest,
  ListDlpEntriesResponse,
  ListDlpEntriesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDlpEntriesRequest,
  output: ListDlpEntriesResponse,
  errors: [],
}));

export interface CreateDlpEntryRequest {
  /** Path param: */
  accountId: string;
  /** Body param: */
  enabled: boolean;
  /** Body param: */
  name: string;
  /** Body param: */
  pattern: unknown;
  /** Body param: */
  profileId?: string;
}

export const CreateDlpEntryRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  enabled: Schema.Boolean,
  name: Schema.String,
  pattern: Schema.Unknown,
  profileId: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    enabled: "enabled",
    name: "name",
    pattern: "pattern",
    profileId: "profile_id",
  }),
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/entries" }),
) as unknown as Schema.Schema<CreateDlpEntryRequest>;

export interface CreateDlpEntryResponse {
  id: string;
  createdAt: string;
  enabled: boolean;
  name: string;
  pattern: unknown;
  updatedAt: string;
  profileId?: string | null;
}

export const CreateDlpEntryResponse = Schema.Struct({
  id: Schema.String,
  createdAt: Schema.String,
  enabled: Schema.Boolean,
  name: Schema.String,
  pattern: Schema.Unknown,
  updatedAt: Schema.String,
  profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    createdAt: "created_at",
    enabled: "enabled",
    name: "name",
    pattern: "pattern",
    updatedAt: "updated_at",
    profileId: "profile_id",
  }),
) as unknown as Schema.Schema<CreateDlpEntryResponse>;

export type CreateDlpEntryError = CommonErrors;

export const createDlpEntry: API.OperationMethod<
  CreateDlpEntryRequest,
  CreateDlpEntryResponse,
  CreateDlpEntryError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDlpEntryRequest,
  output: CreateDlpEntryResponse,
  errors: [],
}));

export interface UpdateDlpEntryRequest {
  entryId: string;
  /** Path param: */
  accountId: string;
  /** Body param: */
  name: string;
  /** Body param: */
  pattern: unknown;
  /** Body param: */
  type: "custom";
  /** Body param: */
  enabled?: boolean;
}

export const UpdateDlpEntryRequest = Schema.Struct({
  entryId: Schema.String.pipe(T.HttpPath("entryId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.String,
  pattern: Schema.Unknown,
  type: Schema.Literal("custom"),
  enabled: Schema.optional(Schema.Boolean),
}).pipe(
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/dlp/entries/{entryId}",
  }),
) as unknown as Schema.Schema<UpdateDlpEntryRequest>;

export type UpdateDlpEntryResponse =
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      pattern: unknown;
      type: "custom";
      updatedAt: string;
      profileId?: string | null;
    }
  | {
      id: string;
      confidence: { aiContextAvailable: boolean; available: boolean };
      enabled: boolean;
      name: string;
      type: "predefined";
      profileId?: string | null;
      variant?: {
        topicType: "Intent" | "Content";
        type: "PromptTopic";
        description?: string | null;
      };
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "integration";
      updatedAt: string;
      profileId?: string | null;
    }
  | {
      id: string;
      caseSensitive: boolean;
      createdAt: string;
      enabled: boolean;
      name: string;
      secret: boolean;
      type: "exact_data";
      updatedAt: string;
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "document_fingerprint";
      updatedAt: string;
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "word_list";
      updatedAt: string;
      wordList: unknown;
      profileId?: string | null;
    };

export const UpdateDlpEntryResponse = Schema.Union([
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    pattern: Schema.Unknown,
    type: Schema.Literal("custom"),
    updatedAt: Schema.String,
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      pattern: "pattern",
      type: "type",
      updatedAt: "updated_at",
      profileId: "profile_id",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    confidence: Schema.Struct({
      aiContextAvailable: Schema.Boolean,
      available: Schema.Boolean,
    }).pipe(
      Schema.encodeKeys({
        aiContextAvailable: "ai_context_available",
        available: "available",
      }),
    ),
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("predefined"),
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    variant: Schema.optional(
      Schema.Struct({
        topicType: Schema.Literals(["Intent", "Content"]),
        type: Schema.Literal("PromptTopic"),
        description: Schema.optional(
          Schema.Union([Schema.String, Schema.Null]),
        ),
      }).pipe(
        Schema.encodeKeys({
          topicType: "topic_type",
          type: "type",
          description: "description",
        }),
      ),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      confidence: "confidence",
      enabled: "enabled",
      name: "name",
      type: "type",
      profileId: "profile_id",
      variant: "variant",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("integration"),
    updatedAt: Schema.String,
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
      profileId: "profile_id",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    caseSensitive: Schema.Boolean,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    secret: Schema.Boolean,
    type: Schema.Literal("exact_data"),
    updatedAt: Schema.String,
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      caseSensitive: "case_sensitive",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      secret: "secret",
      type: "type",
      updatedAt: "updated_at",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("document_fingerprint"),
    updatedAt: Schema.String,
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("word_list"),
    updatedAt: Schema.String,
    wordList: Schema.Unknown,
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
      wordList: "word_list",
      profileId: "profile_id",
    }),
  ),
]) as unknown as Schema.Schema<UpdateDlpEntryResponse>;

export type UpdateDlpEntryError = CommonErrors;

export const updateDlpEntry: API.OperationMethod<
  UpdateDlpEntryRequest,
  UpdateDlpEntryResponse,
  UpdateDlpEntryError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDlpEntryRequest,
  output: UpdateDlpEntryResponse,
  errors: [],
}));

export interface DeleteDlpEntryRequest {
  entryId: string;
  accountId: string;
}

export const DeleteDlpEntryRequest = Schema.Struct({
  entryId: Schema.String.pipe(T.HttpPath("entryId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/dlp/entries/{entryId}",
  }),
) as unknown as Schema.Schema<DeleteDlpEntryRequest>;

export type DeleteDlpEntryResponse = unknown;

export const DeleteDlpEntryResponse =
  Schema.Unknown as unknown as Schema.Schema<DeleteDlpEntryResponse>;

export type DeleteDlpEntryError = CommonErrors;

export const deleteDlpEntry: API.OperationMethod<
  DeleteDlpEntryRequest,
  DeleteDlpEntryResponse,
  DeleteDlpEntryError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDlpEntryRequest,
  output: DeleteDlpEntryResponse,
  errors: [],
}));

// =============================================================================
// DlpEntryCustom
// =============================================================================

export interface GetDlpEntryCustomRequest {
  entryId: string;
  accountId: string;
}

export const GetDlpEntryCustomRequest = Schema.Struct({
  entryId: Schema.String.pipe(T.HttpPath("entryId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dlp/entries/{entryId}",
  }),
) as unknown as Schema.Schema<GetDlpEntryCustomRequest>;

export type GetDlpEntryCustomResponse =
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      pattern: unknown;
      type: "custom";
      updatedAt: string;
      profileId?: string | null;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      confidence: { aiContextAvailable: boolean; available: boolean };
      enabled: boolean;
      name: string;
      type: "predefined";
      profileId?: string | null;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
      variant?: {
        topicType: "Intent" | "Content";
        type: "PromptTopic";
        description?: string | null;
      };
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "integration";
      updatedAt: string;
      profileId?: string | null;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      caseSensitive: boolean;
      createdAt: string;
      enabled: boolean;
      name: string;
      secret: boolean;
      type: "exact_data";
      updatedAt: string;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "document_fingerprint";
      updatedAt: string;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "word_list";
      updatedAt: string;
      wordList: unknown;
      profileId?: string | null;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    };

export const GetDlpEntryCustomResponse = Schema.Union([
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    pattern: Schema.Unknown,
    type: Schema.Literal("custom"),
    updatedAt: Schema.String,
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      pattern: "pattern",
      type: "type",
      updatedAt: "updated_at",
      profileId: "profile_id",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    confidence: Schema.Struct({
      aiContextAvailable: Schema.Boolean,
      available: Schema.Boolean,
    }).pipe(
      Schema.encodeKeys({
        aiContextAvailable: "ai_context_available",
        available: "available",
      }),
    ),
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("predefined"),
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
    variant: Schema.optional(
      Schema.Struct({
        topicType: Schema.Literals(["Intent", "Content"]),
        type: Schema.Literal("PromptTopic"),
        description: Schema.optional(
          Schema.Union([Schema.String, Schema.Null]),
        ),
      }).pipe(
        Schema.encodeKeys({
          topicType: "topic_type",
          type: "type",
          description: "description",
        }),
      ),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      confidence: "confidence",
      enabled: "enabled",
      name: "name",
      type: "type",
      profileId: "profile_id",
      profiles: "profiles",
      uploadStatus: "upload_status",
      variant: "variant",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("integration"),
    updatedAt: Schema.String,
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
      profileId: "profile_id",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    caseSensitive: Schema.Boolean,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    secret: Schema.Boolean,
    type: Schema.Literal("exact_data"),
    updatedAt: Schema.String,
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      caseSensitive: "case_sensitive",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      secret: "secret",
      type: "type",
      updatedAt: "updated_at",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("document_fingerprint"),
    updatedAt: Schema.String,
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("word_list"),
    updatedAt: Schema.String,
    wordList: Schema.Unknown,
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
      wordList: "word_list",
      profileId: "profile_id",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
]) as unknown as Schema.Schema<GetDlpEntryCustomResponse>;

export type GetDlpEntryCustomError = CommonErrors;

export const getDlpEntryCustom: API.OperationMethod<
  GetDlpEntryCustomRequest,
  GetDlpEntryCustomResponse,
  GetDlpEntryCustomError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDlpEntryCustomRequest,
  output: GetDlpEntryCustomResponse,
  errors: [],
}));

export interface ListDlpEntryCustomsRequest {
  accountId: string;
}

export const ListDlpEntryCustomsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/entries" }),
) as unknown as Schema.Schema<ListDlpEntryCustomsRequest>;

export type ListDlpEntryCustomsResponse = (
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      pattern: unknown;
      type: "custom";
      updatedAt: string;
      profileId?: string | null;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      confidence: { aiContextAvailable: boolean; available: boolean };
      enabled: boolean;
      name: string;
      type: "predefined";
      profileId?: string | null;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
      variant?: {
        topicType: "Intent" | "Content";
        type: "PromptTopic";
        description?: string | null;
      };
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "integration";
      updatedAt: string;
      profileId?: string | null;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      caseSensitive: boolean;
      createdAt: string;
      enabled: boolean;
      name: string;
      secret: boolean;
      type: "exact_data";
      updatedAt: string;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "document_fingerprint";
      updatedAt: string;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "word_list";
      updatedAt: string;
      wordList: unknown;
      profileId?: string | null;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
)[];

export const ListDlpEntryCustomsResponse = Schema.Array(
  Schema.Union([
    Schema.Struct({
      id: Schema.String,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      pattern: Schema.Unknown,
      type: Schema.Literal("custom"),
      updatedAt: Schema.String,
      profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        pattern: "pattern",
        type: "type",
        updatedAt: "updated_at",
        profileId: "profile_id",
        uploadStatus: "upload_status",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      confidence: Schema.Struct({
        aiContextAvailable: Schema.Boolean,
        available: Schema.Boolean,
      }).pipe(
        Schema.encodeKeys({
          aiContextAvailable: "ai_context_available",
          available: "available",
        }),
      ),
      enabled: Schema.Boolean,
      name: Schema.String,
      type: Schema.Literal("predefined"),
      profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
      variant: Schema.optional(
        Schema.Struct({
          topicType: Schema.Literals(["Intent", "Content"]),
          type: Schema.Literal("PromptTopic"),
          description: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            topicType: "topic_type",
            type: "type",
            description: "description",
          }),
        ),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        confidence: "confidence",
        enabled: "enabled",
        name: "name",
        type: "type",
        profileId: "profile_id",
        uploadStatus: "upload_status",
        variant: "variant",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      type: Schema.Literal("integration"),
      updatedAt: Schema.String,
      profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        type: "type",
        updatedAt: "updated_at",
        profileId: "profile_id",
        uploadStatus: "upload_status",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      caseSensitive: Schema.Boolean,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      secret: Schema.Boolean,
      type: Schema.Literal("exact_data"),
      updatedAt: Schema.String,
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        caseSensitive: "case_sensitive",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        secret: "secret",
        type: "type",
        updatedAt: "updated_at",
        uploadStatus: "upload_status",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      type: Schema.Literal("document_fingerprint"),
      updatedAt: Schema.String,
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        type: "type",
        updatedAt: "updated_at",
        uploadStatus: "upload_status",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      type: Schema.Literal("word_list"),
      updatedAt: Schema.String,
      wordList: Schema.Unknown,
      profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        type: "type",
        updatedAt: "updated_at",
        wordList: "word_list",
        profileId: "profile_id",
        uploadStatus: "upload_status",
      }),
    ),
  ]),
) as unknown as Schema.Schema<ListDlpEntryCustomsResponse>;

export type ListDlpEntryCustomsError = CommonErrors;

export const listDlpEntryCustoms: API.OperationMethod<
  ListDlpEntryCustomsRequest,
  ListDlpEntryCustomsResponse,
  ListDlpEntryCustomsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDlpEntryCustomsRequest,
  output: ListDlpEntryCustomsResponse,
  errors: [],
}));

export interface CreateDlpEntryCustomRequest {
  /** Path param: */
  accountId: string;
  /** Body param: */
  enabled: boolean;
  /** Body param: */
  name: string;
  /** Body param: */
  pattern: unknown;
  /** Body param: */
  profileId?: string;
}

export const CreateDlpEntryCustomRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  enabled: Schema.Boolean,
  name: Schema.String,
  pattern: Schema.Unknown,
  profileId: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    enabled: "enabled",
    name: "name",
    pattern: "pattern",
    profileId: "profile_id",
  }),
  T.Http({ method: "POST", path: "/accounts/{account_id}/dlp/entries" }),
) as unknown as Schema.Schema<CreateDlpEntryCustomRequest>;

export interface CreateDlpEntryCustomResponse {
  id: string;
  createdAt: string;
  enabled: boolean;
  name: string;
  pattern: unknown;
  updatedAt: string;
  profileId?: string | null;
}

export const CreateDlpEntryCustomResponse = Schema.Struct({
  id: Schema.String,
  createdAt: Schema.String,
  enabled: Schema.Boolean,
  name: Schema.String,
  pattern: Schema.Unknown,
  updatedAt: Schema.String,
  profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    createdAt: "created_at",
    enabled: "enabled",
    name: "name",
    pattern: "pattern",
    updatedAt: "updated_at",
    profileId: "profile_id",
  }),
) as unknown as Schema.Schema<CreateDlpEntryCustomResponse>;

export type CreateDlpEntryCustomError = CommonErrors;

export const createDlpEntryCustom: API.OperationMethod<
  CreateDlpEntryCustomRequest,
  CreateDlpEntryCustomResponse,
  CreateDlpEntryCustomError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDlpEntryCustomRequest,
  output: CreateDlpEntryCustomResponse,
  errors: [],
}));

export interface UpdateDlpEntryCustomRequest {
  entryId: string;
  /** Path param: */
  accountId: string;
  /** Body param: */
  enabled: boolean;
  /** Body param: */
  name: string;
  /** Body param: */
  pattern: unknown;
}

export const UpdateDlpEntryCustomRequest = Schema.Struct({
  entryId: Schema.String.pipe(T.HttpPath("entryId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  enabled: Schema.Boolean,
  name: Schema.String,
  pattern: Schema.Unknown,
}).pipe(
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/dlp/entries/custom/{entryId}",
  }),
) as unknown as Schema.Schema<UpdateDlpEntryCustomRequest>;

export interface UpdateDlpEntryCustomResponse {
  id: string;
  createdAt: string;
  enabled: boolean;
  name: string;
  pattern: unknown;
  updatedAt: string;
  profileId?: string | null;
}

export const UpdateDlpEntryCustomResponse = Schema.Struct({
  id: Schema.String,
  createdAt: Schema.String,
  enabled: Schema.Boolean,
  name: Schema.String,
  pattern: Schema.Unknown,
  updatedAt: Schema.String,
  profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    createdAt: "created_at",
    enabled: "enabled",
    name: "name",
    pattern: "pattern",
    updatedAt: "updated_at",
    profileId: "profile_id",
  }),
) as unknown as Schema.Schema<UpdateDlpEntryCustomResponse>;

export type UpdateDlpEntryCustomError = CommonErrors;

export const updateDlpEntryCustom: API.OperationMethod<
  UpdateDlpEntryCustomRequest,
  UpdateDlpEntryCustomResponse,
  UpdateDlpEntryCustomError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDlpEntryCustomRequest,
  output: UpdateDlpEntryCustomResponse,
  errors: [],
}));

export interface DeleteDlpEntryCustomRequest {
  entryId: string;
  accountId: string;
}

export const DeleteDlpEntryCustomRequest = Schema.Struct({
  entryId: Schema.String.pipe(T.HttpPath("entryId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/dlp/entries/{entryId}",
  }),
) as unknown as Schema.Schema<DeleteDlpEntryCustomRequest>;

export type DeleteDlpEntryCustomResponse = unknown;

export const DeleteDlpEntryCustomResponse =
  Schema.Unknown as unknown as Schema.Schema<DeleteDlpEntryCustomResponse>;

export type DeleteDlpEntryCustomError = CommonErrors;

export const deleteDlpEntryCustom: API.OperationMethod<
  DeleteDlpEntryCustomRequest,
  DeleteDlpEntryCustomResponse,
  DeleteDlpEntryCustomError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDlpEntryCustomRequest,
  output: DeleteDlpEntryCustomResponse,
  errors: [],
}));

// =============================================================================
// DlpEntryIntegration
// =============================================================================

export interface GetDlpEntryIntegrationRequest {
  entryId: string;
  accountId: string;
}

export const GetDlpEntryIntegrationRequest = Schema.Struct({
  entryId: Schema.String.pipe(T.HttpPath("entryId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dlp/entries/{entryId}",
  }),
) as unknown as Schema.Schema<GetDlpEntryIntegrationRequest>;

export type GetDlpEntryIntegrationResponse =
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      pattern: unknown;
      type: "custom";
      updatedAt: string;
      profileId?: string | null;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      confidence: { aiContextAvailable: boolean; available: boolean };
      enabled: boolean;
      name: string;
      type: "predefined";
      profileId?: string | null;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
      variant?: {
        topicType: "Intent" | "Content";
        type: "PromptTopic";
        description?: string | null;
      };
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "integration";
      updatedAt: string;
      profileId?: string | null;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      caseSensitive: boolean;
      createdAt: string;
      enabled: boolean;
      name: string;
      secret: boolean;
      type: "exact_data";
      updatedAt: string;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "document_fingerprint";
      updatedAt: string;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "word_list";
      updatedAt: string;
      wordList: unknown;
      profileId?: string | null;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    };

export const GetDlpEntryIntegrationResponse = Schema.Union([
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    pattern: Schema.Unknown,
    type: Schema.Literal("custom"),
    updatedAt: Schema.String,
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      pattern: "pattern",
      type: "type",
      updatedAt: "updated_at",
      profileId: "profile_id",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    confidence: Schema.Struct({
      aiContextAvailable: Schema.Boolean,
      available: Schema.Boolean,
    }).pipe(
      Schema.encodeKeys({
        aiContextAvailable: "ai_context_available",
        available: "available",
      }),
    ),
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("predefined"),
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
    variant: Schema.optional(
      Schema.Struct({
        topicType: Schema.Literals(["Intent", "Content"]),
        type: Schema.Literal("PromptTopic"),
        description: Schema.optional(
          Schema.Union([Schema.String, Schema.Null]),
        ),
      }).pipe(
        Schema.encodeKeys({
          topicType: "topic_type",
          type: "type",
          description: "description",
        }),
      ),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      confidence: "confidence",
      enabled: "enabled",
      name: "name",
      type: "type",
      profileId: "profile_id",
      profiles: "profiles",
      uploadStatus: "upload_status",
      variant: "variant",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("integration"),
    updatedAt: Schema.String,
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
      profileId: "profile_id",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    caseSensitive: Schema.Boolean,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    secret: Schema.Boolean,
    type: Schema.Literal("exact_data"),
    updatedAt: Schema.String,
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      caseSensitive: "case_sensitive",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      secret: "secret",
      type: "type",
      updatedAt: "updated_at",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("document_fingerprint"),
    updatedAt: Schema.String,
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("word_list"),
    updatedAt: Schema.String,
    wordList: Schema.Unknown,
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
      wordList: "word_list",
      profileId: "profile_id",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
]) as unknown as Schema.Schema<GetDlpEntryIntegrationResponse>;

export type GetDlpEntryIntegrationError = CommonErrors;

export const getDlpEntryIntegration: API.OperationMethod<
  GetDlpEntryIntegrationRequest,
  GetDlpEntryIntegrationResponse,
  GetDlpEntryIntegrationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDlpEntryIntegrationRequest,
  output: GetDlpEntryIntegrationResponse,
  errors: [],
}));

export interface ListDlpEntryIntegrationsRequest {
  accountId: string;
}

export const ListDlpEntryIntegrationsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/entries" }),
) as unknown as Schema.Schema<ListDlpEntryIntegrationsRequest>;

export type ListDlpEntryIntegrationsResponse = (
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      pattern: unknown;
      type: "custom";
      updatedAt: string;
      profileId?: string | null;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      confidence: { aiContextAvailable: boolean; available: boolean };
      enabled: boolean;
      name: string;
      type: "predefined";
      profileId?: string | null;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
      variant?: {
        topicType: "Intent" | "Content";
        type: "PromptTopic";
        description?: string | null;
      };
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "integration";
      updatedAt: string;
      profileId?: string | null;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      caseSensitive: boolean;
      createdAt: string;
      enabled: boolean;
      name: string;
      secret: boolean;
      type: "exact_data";
      updatedAt: string;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "document_fingerprint";
      updatedAt: string;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "word_list";
      updatedAt: string;
      wordList: unknown;
      profileId?: string | null;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
)[];

export const ListDlpEntryIntegrationsResponse = Schema.Array(
  Schema.Union([
    Schema.Struct({
      id: Schema.String,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      pattern: Schema.Unknown,
      type: Schema.Literal("custom"),
      updatedAt: Schema.String,
      profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        pattern: "pattern",
        type: "type",
        updatedAt: "updated_at",
        profileId: "profile_id",
        uploadStatus: "upload_status",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      confidence: Schema.Struct({
        aiContextAvailable: Schema.Boolean,
        available: Schema.Boolean,
      }).pipe(
        Schema.encodeKeys({
          aiContextAvailable: "ai_context_available",
          available: "available",
        }),
      ),
      enabled: Schema.Boolean,
      name: Schema.String,
      type: Schema.Literal("predefined"),
      profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
      variant: Schema.optional(
        Schema.Struct({
          topicType: Schema.Literals(["Intent", "Content"]),
          type: Schema.Literal("PromptTopic"),
          description: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            topicType: "topic_type",
            type: "type",
            description: "description",
          }),
        ),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        confidence: "confidence",
        enabled: "enabled",
        name: "name",
        type: "type",
        profileId: "profile_id",
        uploadStatus: "upload_status",
        variant: "variant",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      type: Schema.Literal("integration"),
      updatedAt: Schema.String,
      profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        type: "type",
        updatedAt: "updated_at",
        profileId: "profile_id",
        uploadStatus: "upload_status",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      caseSensitive: Schema.Boolean,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      secret: Schema.Boolean,
      type: Schema.Literal("exact_data"),
      updatedAt: Schema.String,
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        caseSensitive: "case_sensitive",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        secret: "secret",
        type: "type",
        updatedAt: "updated_at",
        uploadStatus: "upload_status",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      type: Schema.Literal("document_fingerprint"),
      updatedAt: Schema.String,
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        type: "type",
        updatedAt: "updated_at",
        uploadStatus: "upload_status",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      type: Schema.Literal("word_list"),
      updatedAt: Schema.String,
      wordList: Schema.Unknown,
      profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        type: "type",
        updatedAt: "updated_at",
        wordList: "word_list",
        profileId: "profile_id",
        uploadStatus: "upload_status",
      }),
    ),
  ]),
) as unknown as Schema.Schema<ListDlpEntryIntegrationsResponse>;

export type ListDlpEntryIntegrationsError = CommonErrors;

export const listDlpEntryIntegrations: API.OperationMethod<
  ListDlpEntryIntegrationsRequest,
  ListDlpEntryIntegrationsResponse,
  ListDlpEntryIntegrationsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDlpEntryIntegrationsRequest,
  output: ListDlpEntryIntegrationsResponse,
  errors: [],
}));

export interface CreateDlpEntryIntegrationRequest {
  /** Path param: */
  accountId: string;
  /** Body param: */
  enabled: boolean;
  /** Body param: */
  entryId: string;
  /** Body param: This field is not used as the owning profile. For predefined entries it is already set to a predefined profile. */
  profileId?: string | null;
}

export const CreateDlpEntryIntegrationRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  enabled: Schema.Boolean,
  entryId: Schema.String,
  profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    enabled: "enabled",
    entryId: "entry_id",
    profileId: "profile_id",
  }),
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/dlp/entries/integration",
  }),
) as unknown as Schema.Schema<CreateDlpEntryIntegrationRequest>;

export interface CreateDlpEntryIntegrationResponse {
  id: string;
  createdAt: string;
  enabled: boolean;
  name: string;
  updatedAt: string;
  profileId?: string | null;
}

export const CreateDlpEntryIntegrationResponse = Schema.Struct({
  id: Schema.String,
  createdAt: Schema.String,
  enabled: Schema.Boolean,
  name: Schema.String,
  updatedAt: Schema.String,
  profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    createdAt: "created_at",
    enabled: "enabled",
    name: "name",
    updatedAt: "updated_at",
    profileId: "profile_id",
  }),
) as unknown as Schema.Schema<CreateDlpEntryIntegrationResponse>;

export type CreateDlpEntryIntegrationError = CommonErrors;

export const createDlpEntryIntegration: API.OperationMethod<
  CreateDlpEntryIntegrationRequest,
  CreateDlpEntryIntegrationResponse,
  CreateDlpEntryIntegrationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDlpEntryIntegrationRequest,
  output: CreateDlpEntryIntegrationResponse,
  errors: [],
}));

export interface UpdateDlpEntryIntegrationRequest {
  entryId: string;
  /** Path param: */
  accountId: string;
  /** Body param: */
  enabled: boolean;
}

export const UpdateDlpEntryIntegrationRequest = Schema.Struct({
  entryId: Schema.String.pipe(T.HttpPath("entryId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  enabled: Schema.Boolean,
}).pipe(
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/dlp/entries/integration/{entryId}",
  }),
) as unknown as Schema.Schema<UpdateDlpEntryIntegrationRequest>;

export interface UpdateDlpEntryIntegrationResponse {
  id: string;
  createdAt: string;
  enabled: boolean;
  name: string;
  updatedAt: string;
  profileId?: string | null;
}

export const UpdateDlpEntryIntegrationResponse = Schema.Struct({
  id: Schema.String,
  createdAt: Schema.String,
  enabled: Schema.Boolean,
  name: Schema.String,
  updatedAt: Schema.String,
  profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    createdAt: "created_at",
    enabled: "enabled",
    name: "name",
    updatedAt: "updated_at",
    profileId: "profile_id",
  }),
) as unknown as Schema.Schema<UpdateDlpEntryIntegrationResponse>;

export type UpdateDlpEntryIntegrationError = CommonErrors;

export const updateDlpEntryIntegration: API.OperationMethod<
  UpdateDlpEntryIntegrationRequest,
  UpdateDlpEntryIntegrationResponse,
  UpdateDlpEntryIntegrationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDlpEntryIntegrationRequest,
  output: UpdateDlpEntryIntegrationResponse,
  errors: [],
}));

export interface DeleteDlpEntryIntegrationRequest {
  entryId: string;
  accountId: string;
}

export const DeleteDlpEntryIntegrationRequest = Schema.Struct({
  entryId: Schema.String.pipe(T.HttpPath("entryId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/dlp/entries/integration/{entryId}",
  }),
) as unknown as Schema.Schema<DeleteDlpEntryIntegrationRequest>;

export type DeleteDlpEntryIntegrationResponse = unknown;

export const DeleteDlpEntryIntegrationResponse =
  Schema.Unknown as unknown as Schema.Schema<DeleteDlpEntryIntegrationResponse>;

export type DeleteDlpEntryIntegrationError = CommonErrors;

export const deleteDlpEntryIntegration: API.OperationMethod<
  DeleteDlpEntryIntegrationRequest,
  DeleteDlpEntryIntegrationResponse,
  DeleteDlpEntryIntegrationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDlpEntryIntegrationRequest,
  output: DeleteDlpEntryIntegrationResponse,
  errors: [],
}));

// =============================================================================
// DlpEntryPredefined
// =============================================================================

export interface GetDlpEntryPredefinedRequest {
  entryId: string;
  accountId: string;
}

export const GetDlpEntryPredefinedRequest = Schema.Struct({
  entryId: Schema.String.pipe(T.HttpPath("entryId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dlp/entries/{entryId}",
  }),
) as unknown as Schema.Schema<GetDlpEntryPredefinedRequest>;

export type GetDlpEntryPredefinedResponse =
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      pattern: unknown;
      type: "custom";
      updatedAt: string;
      profileId?: string | null;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      confidence: { aiContextAvailable: boolean; available: boolean };
      enabled: boolean;
      name: string;
      type: "predefined";
      profileId?: string | null;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
      variant?: {
        topicType: "Intent" | "Content";
        type: "PromptTopic";
        description?: string | null;
      };
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "integration";
      updatedAt: string;
      profileId?: string | null;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      caseSensitive: boolean;
      createdAt: string;
      enabled: boolean;
      name: string;
      secret: boolean;
      type: "exact_data";
      updatedAt: string;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "document_fingerprint";
      updatedAt: string;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "word_list";
      updatedAt: string;
      wordList: unknown;
      profileId?: string | null;
      profiles?: { id: string; name: string }[];
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    };

export const GetDlpEntryPredefinedResponse = Schema.Union([
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    pattern: Schema.Unknown,
    type: Schema.Literal("custom"),
    updatedAt: Schema.String,
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      pattern: "pattern",
      type: "type",
      updatedAt: "updated_at",
      profileId: "profile_id",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    confidence: Schema.Struct({
      aiContextAvailable: Schema.Boolean,
      available: Schema.Boolean,
    }).pipe(
      Schema.encodeKeys({
        aiContextAvailable: "ai_context_available",
        available: "available",
      }),
    ),
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("predefined"),
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
    variant: Schema.optional(
      Schema.Struct({
        topicType: Schema.Literals(["Intent", "Content"]),
        type: Schema.Literal("PromptTopic"),
        description: Schema.optional(
          Schema.Union([Schema.String, Schema.Null]),
        ),
      }).pipe(
        Schema.encodeKeys({
          topicType: "topic_type",
          type: "type",
          description: "description",
        }),
      ),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      confidence: "confidence",
      enabled: "enabled",
      name: "name",
      type: "type",
      profileId: "profile_id",
      profiles: "profiles",
      uploadStatus: "upload_status",
      variant: "variant",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("integration"),
    updatedAt: Schema.String,
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
      profileId: "profile_id",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    caseSensitive: Schema.Boolean,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    secret: Schema.Boolean,
    type: Schema.Literal("exact_data"),
    updatedAt: Schema.String,
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      caseSensitive: "case_sensitive",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      secret: "secret",
      type: "type",
      updatedAt: "updated_at",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("document_fingerprint"),
    updatedAt: Schema.String,
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    enabled: Schema.Boolean,
    name: Schema.String,
    type: Schema.Literal("word_list"),
    updatedAt: Schema.String,
    wordList: Schema.Unknown,
    profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    profiles: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.String,
          name: Schema.String,
        }),
      ),
    ),
    uploadStatus: Schema.optional(
      Schema.Literals([
        "empty",
        "uploading",
        "pending",
        "processing",
        "failed",
        "complete",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      enabled: "enabled",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
      wordList: "word_list",
      profileId: "profile_id",
      profiles: "profiles",
      uploadStatus: "upload_status",
    }),
  ),
]) as unknown as Schema.Schema<GetDlpEntryPredefinedResponse>;

export type GetDlpEntryPredefinedError = CommonErrors;

export const getDlpEntryPredefined: API.OperationMethod<
  GetDlpEntryPredefinedRequest,
  GetDlpEntryPredefinedResponse,
  GetDlpEntryPredefinedError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDlpEntryPredefinedRequest,
  output: GetDlpEntryPredefinedResponse,
  errors: [],
}));

export interface ListDlpEntryPredefinedsRequest {
  accountId: string;
}

export const ListDlpEntryPredefinedsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/entries" }),
) as unknown as Schema.Schema<ListDlpEntryPredefinedsRequest>;

export type ListDlpEntryPredefinedsResponse = (
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      pattern: unknown;
      type: "custom";
      updatedAt: string;
      profileId?: string | null;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      confidence: { aiContextAvailable: boolean; available: boolean };
      enabled: boolean;
      name: string;
      type: "predefined";
      profileId?: string | null;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
      variant?: {
        topicType: "Intent" | "Content";
        type: "PromptTopic";
        description?: string | null;
      };
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "integration";
      updatedAt: string;
      profileId?: string | null;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      caseSensitive: boolean;
      createdAt: string;
      enabled: boolean;
      name: string;
      secret: boolean;
      type: "exact_data";
      updatedAt: string;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "document_fingerprint";
      updatedAt: string;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
  | {
      id: string;
      createdAt: string;
      enabled: boolean;
      name: string;
      type: "word_list";
      updatedAt: string;
      wordList: unknown;
      profileId?: string | null;
      uploadStatus?:
        | "empty"
        | "uploading"
        | "pending"
        | "processing"
        | "failed"
        | "complete";
    }
)[];

export const ListDlpEntryPredefinedsResponse = Schema.Array(
  Schema.Union([
    Schema.Struct({
      id: Schema.String,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      pattern: Schema.Unknown,
      type: Schema.Literal("custom"),
      updatedAt: Schema.String,
      profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        pattern: "pattern",
        type: "type",
        updatedAt: "updated_at",
        profileId: "profile_id",
        uploadStatus: "upload_status",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      confidence: Schema.Struct({
        aiContextAvailable: Schema.Boolean,
        available: Schema.Boolean,
      }).pipe(
        Schema.encodeKeys({
          aiContextAvailable: "ai_context_available",
          available: "available",
        }),
      ),
      enabled: Schema.Boolean,
      name: Schema.String,
      type: Schema.Literal("predefined"),
      profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
      variant: Schema.optional(
        Schema.Struct({
          topicType: Schema.Literals(["Intent", "Content"]),
          type: Schema.Literal("PromptTopic"),
          description: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            topicType: "topic_type",
            type: "type",
            description: "description",
          }),
        ),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        confidence: "confidence",
        enabled: "enabled",
        name: "name",
        type: "type",
        profileId: "profile_id",
        uploadStatus: "upload_status",
        variant: "variant",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      type: Schema.Literal("integration"),
      updatedAt: Schema.String,
      profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        type: "type",
        updatedAt: "updated_at",
        profileId: "profile_id",
        uploadStatus: "upload_status",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      caseSensitive: Schema.Boolean,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      secret: Schema.Boolean,
      type: Schema.Literal("exact_data"),
      updatedAt: Schema.String,
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        caseSensitive: "case_sensitive",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        secret: "secret",
        type: "type",
        updatedAt: "updated_at",
        uploadStatus: "upload_status",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      type: Schema.Literal("document_fingerprint"),
      updatedAt: Schema.String,
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        type: "type",
        updatedAt: "updated_at",
        uploadStatus: "upload_status",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      createdAt: Schema.String,
      enabled: Schema.Boolean,
      name: Schema.String,
      type: Schema.Literal("word_list"),
      updatedAt: Schema.String,
      wordList: Schema.Unknown,
      profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      uploadStatus: Schema.optional(
        Schema.Literals([
          "empty",
          "uploading",
          "pending",
          "processing",
          "failed",
          "complete",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        createdAt: "created_at",
        enabled: "enabled",
        name: "name",
        type: "type",
        updatedAt: "updated_at",
        wordList: "word_list",
        profileId: "profile_id",
        uploadStatus: "upload_status",
      }),
    ),
  ]),
) as unknown as Schema.Schema<ListDlpEntryPredefinedsResponse>;

export type ListDlpEntryPredefinedsError = CommonErrors;

export const listDlpEntryPredefineds: API.OperationMethod<
  ListDlpEntryPredefinedsRequest,
  ListDlpEntryPredefinedsResponse,
  ListDlpEntryPredefinedsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDlpEntryPredefinedsRequest,
  output: ListDlpEntryPredefinedsResponse,
  errors: [],
}));

export interface CreateDlpEntryPredefinedRequest {
  /** Path param: */
  accountId: string;
  /** Body param: */
  enabled: boolean;
  /** Body param: */
  entryId: string;
  /** Body param: This field is not used as the owning profile. For predefined entries it is already set to a predefined profile. */
  profileId?: string | null;
}

export const CreateDlpEntryPredefinedRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  enabled: Schema.Boolean,
  entryId: Schema.String,
  profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    enabled: "enabled",
    entryId: "entry_id",
    profileId: "profile_id",
  }),
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/dlp/entries/predefined",
  }),
) as unknown as Schema.Schema<CreateDlpEntryPredefinedRequest>;

export interface CreateDlpEntryPredefinedResponse {
  id: string;
  confidence: { aiContextAvailable: boolean; available: boolean };
  enabled: boolean;
  name: string;
  profileId?: string | null;
  variant?: {
    topicType: "Intent" | "Content";
    type: "PromptTopic";
    description?: string | null;
  };
}

export const CreateDlpEntryPredefinedResponse = Schema.Struct({
  id: Schema.String,
  confidence: Schema.Struct({
    aiContextAvailable: Schema.Boolean,
    available: Schema.Boolean,
  }).pipe(
    Schema.encodeKeys({
      aiContextAvailable: "ai_context_available",
      available: "available",
    }),
  ),
  enabled: Schema.Boolean,
  name: Schema.String,
  profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  variant: Schema.optional(
    Schema.Struct({
      topicType: Schema.Literals(["Intent", "Content"]),
      type: Schema.Literal("PromptTopic"),
      description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    }).pipe(
      Schema.encodeKeys({
        topicType: "topic_type",
        type: "type",
        description: "description",
      }),
    ),
  ),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    confidence: "confidence",
    enabled: "enabled",
    name: "name",
    profileId: "profile_id",
    variant: "variant",
  }),
) as unknown as Schema.Schema<CreateDlpEntryPredefinedResponse>;

export type CreateDlpEntryPredefinedError = CommonErrors;

export const createDlpEntryPredefined: API.OperationMethod<
  CreateDlpEntryPredefinedRequest,
  CreateDlpEntryPredefinedResponse,
  CreateDlpEntryPredefinedError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDlpEntryPredefinedRequest,
  output: CreateDlpEntryPredefinedResponse,
  errors: [],
}));

export interface UpdateDlpEntryPredefinedRequest {
  entryId: string;
  /** Path param: */
  accountId: string;
  /** Body param: */
  enabled: boolean;
}

export const UpdateDlpEntryPredefinedRequest = Schema.Struct({
  entryId: Schema.String.pipe(T.HttpPath("entryId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  enabled: Schema.Boolean,
}).pipe(
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/dlp/entries/predefined/{entryId}",
  }),
) as unknown as Schema.Schema<UpdateDlpEntryPredefinedRequest>;

export interface UpdateDlpEntryPredefinedResponse {
  id: string;
  confidence: { aiContextAvailable: boolean; available: boolean };
  enabled: boolean;
  name: string;
  profileId?: string | null;
  variant?: {
    topicType: "Intent" | "Content";
    type: "PromptTopic";
    description?: string | null;
  };
}

export const UpdateDlpEntryPredefinedResponse = Schema.Struct({
  id: Schema.String,
  confidence: Schema.Struct({
    aiContextAvailable: Schema.Boolean,
    available: Schema.Boolean,
  }).pipe(
    Schema.encodeKeys({
      aiContextAvailable: "ai_context_available",
      available: "available",
    }),
  ),
  enabled: Schema.Boolean,
  name: Schema.String,
  profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  variant: Schema.optional(
    Schema.Struct({
      topicType: Schema.Literals(["Intent", "Content"]),
      type: Schema.Literal("PromptTopic"),
      description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    }).pipe(
      Schema.encodeKeys({
        topicType: "topic_type",
        type: "type",
        description: "description",
      }),
    ),
  ),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    confidence: "confidence",
    enabled: "enabled",
    name: "name",
    profileId: "profile_id",
    variant: "variant",
  }),
) as unknown as Schema.Schema<UpdateDlpEntryPredefinedResponse>;

export type UpdateDlpEntryPredefinedError = CommonErrors;

export const updateDlpEntryPredefined: API.OperationMethod<
  UpdateDlpEntryPredefinedRequest,
  UpdateDlpEntryPredefinedResponse,
  UpdateDlpEntryPredefinedError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDlpEntryPredefinedRequest,
  output: UpdateDlpEntryPredefinedResponse,
  errors: [],
}));

export interface DeleteDlpEntryPredefinedRequest {
  entryId: string;
  accountId: string;
}

export const DeleteDlpEntryPredefinedRequest = Schema.Struct({
  entryId: Schema.String.pipe(T.HttpPath("entryId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/dlp/entries/predefined/{entryId}",
  }),
) as unknown as Schema.Schema<DeleteDlpEntryPredefinedRequest>;

export type DeleteDlpEntryPredefinedResponse = unknown;

export const DeleteDlpEntryPredefinedResponse =
  Schema.Unknown as unknown as Schema.Schema<DeleteDlpEntryPredefinedResponse>;

export type DeleteDlpEntryPredefinedError = CommonErrors;

export const deleteDlpEntryPredefined: API.OperationMethod<
  DeleteDlpEntryPredefinedRequest,
  DeleteDlpEntryPredefinedResponse,
  DeleteDlpEntryPredefinedError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDlpEntryPredefinedRequest,
  output: DeleteDlpEntryPredefinedResponse,
  errors: [],
}));

// =============================================================================
// DlpLimit
// =============================================================================

export interface ListDlpLimitsRequest {
  accountId: string;
}

export const ListDlpLimitsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/limits" }),
) as unknown as Schema.Schema<ListDlpLimitsRequest>;

export interface ListDlpLimitsResponse {
  maxDatasetCells: number;
}

export const ListDlpLimitsResponse = Schema.Struct({
  maxDatasetCells: Schema.Number,
}).pipe(
  Schema.encodeKeys({ maxDatasetCells: "max_dataset_cells" }),
) as unknown as Schema.Schema<ListDlpLimitsResponse>;

export type ListDlpLimitsError = CommonErrors;

export const listDlpLimits: API.OperationMethod<
  ListDlpLimitsRequest,
  ListDlpLimitsResponse,
  ListDlpLimitsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDlpLimitsRequest,
  output: ListDlpLimitsResponse,
  errors: [],
}));

// =============================================================================
// DlpPattern
// =============================================================================

export interface ValidateDlpPatternRequest {
  /** Path param: Account ID. */
  accountId: string;
  /** Body param: */
  regex: string;
  /** Body param: Maximum number of bytes that the regular expression can match.  If this is `null` then there is no limit on the length. Patterns can use ` ` and `+`. Otherwise repeats should use a range ` */
  maxMatchBytes?: number | null;
}

export const ValidateDlpPatternRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  regex: Schema.String,
  maxMatchBytes: Schema.optional(Schema.Union([Schema.Number, Schema.Null])),
}).pipe(
  Schema.encodeKeys({ regex: "regex", maxMatchBytes: "max_match_bytes" }),
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/dlp/patterns/validate",
  }),
) as unknown as Schema.Schema<ValidateDlpPatternRequest>;

export interface ValidateDlpPatternResponse {
  valid: boolean;
}

export const ValidateDlpPatternResponse = Schema.Struct({
  valid: Schema.Boolean,
}) as unknown as Schema.Schema<ValidateDlpPatternResponse>;

export type ValidateDlpPatternError = CommonErrors;

export const validateDlpPattern: API.OperationMethod<
  ValidateDlpPatternRequest,
  ValidateDlpPatternResponse,
  ValidateDlpPatternError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ValidateDlpPatternRequest,
  output: ValidateDlpPatternResponse,
  errors: [],
}));

// =============================================================================
// DlpPayloadLog
// =============================================================================

export interface GetDlpPayloadLogRequest {
  accountId: string;
}

export const GetDlpPayloadLogRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/payload_log" }),
) as unknown as Schema.Schema<GetDlpPayloadLogRequest>;

export interface GetDlpPayloadLogResponse {
  updatedAt: string;
  publicKey?: string | null;
}

export const GetDlpPayloadLogResponse = Schema.Struct({
  updatedAt: Schema.String,
  publicKey: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({ updatedAt: "updated_at", publicKey: "public_key" }),
) as unknown as Schema.Schema<GetDlpPayloadLogResponse>;

export type GetDlpPayloadLogError = CommonErrors;

export const getDlpPayloadLog: API.OperationMethod<
  GetDlpPayloadLogRequest,
  GetDlpPayloadLogResponse,
  GetDlpPayloadLogError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDlpPayloadLogRequest,
  output: GetDlpPayloadLogResponse,
  errors: [],
}));

export interface PutDlpPayloadLogRequest {
  /** Path param: */
  accountId: string;
  /** Body param: */
  publicKey?: string | null;
}

export const PutDlpPayloadLogRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  publicKey: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({ publicKey: "public_key" }),
  T.Http({ method: "PUT", path: "/accounts/{account_id}/dlp/payload_log" }),
) as unknown as Schema.Schema<PutDlpPayloadLogRequest>;

export interface PutDlpPayloadLogResponse {
  updatedAt: string;
  publicKey?: string | null;
}

export const PutDlpPayloadLogResponse = Schema.Struct({
  updatedAt: Schema.String,
  publicKey: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({ updatedAt: "updated_at", publicKey: "public_key" }),
) as unknown as Schema.Schema<PutDlpPayloadLogResponse>;

export type PutDlpPayloadLogError = CommonErrors;

export const putDlpPayloadLog: API.OperationMethod<
  PutDlpPayloadLogRequest,
  PutDlpPayloadLogResponse,
  PutDlpPayloadLogError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutDlpPayloadLogRequest,
  output: PutDlpPayloadLogResponse,
  errors: [],
}));

// =============================================================================
// DlpProfile
// =============================================================================

export interface GetDlpProfileRequest {
  profileId: string;
  accountId: string;
}

export const GetDlpProfileRequest = Schema.Struct({
  profileId: Schema.String.pipe(T.HttpPath("profileId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dlp/profiles/{profileId}",
  }),
) as unknown as Schema.Schema<GetDlpProfileRequest>;

export type GetDlpProfileResponse =
  | {
      id: string;
      allowedMatchCount: number;
      createdAt: string;
      name: string;
      ocrEnabled: boolean;
      type: "custom";
      updatedAt: string;
      aiContextEnabled?: boolean;
      confidenceThreshold?: "low" | "medium" | "high" | "very_high";
      contextAwareness?: unknown;
      description?: string | null;
      entries?: (
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            pattern: unknown;
            type: "custom";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            confidence: { aiContextAvailable: boolean; available: boolean };
            enabled: boolean;
            name: string;
            type: "predefined";
            profileId?: string | null;
            variant?: {
              topicType: "Intent" | "Content";
              type: "PromptTopic";
              description?: string | null;
            };
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "integration";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            caseSensitive: boolean;
            createdAt: string;
            enabled: boolean;
            name: string;
            secret: boolean;
            type: "exact_data";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "document_fingerprint";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "word_list";
            updatedAt: string;
            wordList: unknown;
            profileId?: string | null;
          }
      )[];
    }
  | {
      id: string;
      allowedMatchCount: number;
      entries: (
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            pattern: unknown;
            type: "custom";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            confidence: { aiContextAvailable: boolean; available: boolean };
            enabled: boolean;
            name: string;
            type: "predefined";
            profileId?: string | null;
            variant?: {
              topicType: "Intent" | "Content";
              type: "PromptTopic";
              description?: string | null;
            };
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "integration";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            caseSensitive: boolean;
            createdAt: string;
            enabled: boolean;
            name: string;
            secret: boolean;
            type: "exact_data";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "document_fingerprint";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "word_list";
            updatedAt: string;
            wordList: unknown;
            profileId?: string | null;
          }
      )[];
      name: string;
      type: "predefined";
      aiContextEnabled?: boolean;
      confidenceThreshold?: "low" | "medium" | "high" | "very_high";
      contextAwareness?: unknown;
      ocrEnabled?: boolean;
      openAccess?: boolean;
    }
  | {
      id: string;
      createdAt: string;
      entries: (
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            pattern: unknown;
            type: "custom";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            confidence: { aiContextAvailable: boolean; available: boolean };
            enabled: boolean;
            name: string;
            type: "predefined";
            profileId?: string | null;
            variant?: {
              topicType: "Intent" | "Content";
              type: "PromptTopic";
              description?: string | null;
            };
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "integration";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            caseSensitive: boolean;
            createdAt: string;
            enabled: boolean;
            name: string;
            secret: boolean;
            type: "exact_data";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "document_fingerprint";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "word_list";
            updatedAt: string;
            wordList: unknown;
            profileId?: string | null;
          }
      )[];
      name: string;
      type: "integration";
      updatedAt: string;
      description?: string | null;
    };

export const GetDlpProfileResponse = Schema.Union([
  Schema.Struct({
    id: Schema.String,
    allowedMatchCount: Schema.Number,
    createdAt: Schema.String,
    name: Schema.String,
    ocrEnabled: Schema.Boolean,
    type: Schema.Literal("custom"),
    updatedAt: Schema.String,
    aiContextEnabled: Schema.optional(Schema.Boolean),
    confidenceThreshold: Schema.optional(
      Schema.Literals(["low", "medium", "high", "very_high"]),
    ),
    contextAwareness: Schema.optional(Schema.Unknown),
    description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    entries: Schema.optional(
      Schema.Array(
        Schema.Union([
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            pattern: Schema.Unknown,
            type: Schema.Literal("custom"),
            updatedAt: Schema.String,
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              pattern: "pattern",
              type: "type",
              updatedAt: "updated_at",
              profileId: "profile_id",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            confidence: Schema.Struct({
              aiContextAvailable: Schema.Boolean,
              available: Schema.Boolean,
            }).pipe(
              Schema.encodeKeys({
                aiContextAvailable: "ai_context_available",
                available: "available",
              }),
            ),
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("predefined"),
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            variant: Schema.optional(
              Schema.Struct({
                topicType: Schema.Literals(["Intent", "Content"]),
                type: Schema.Literal("PromptTopic"),
                description: Schema.optional(
                  Schema.Union([Schema.String, Schema.Null]),
                ),
              }).pipe(
                Schema.encodeKeys({
                  topicType: "topic_type",
                  type: "type",
                  description: "description",
                }),
              ),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              confidence: "confidence",
              enabled: "enabled",
              name: "name",
              type: "type",
              profileId: "profile_id",
              variant: "variant",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("integration"),
            updatedAt: Schema.String,
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              type: "type",
              updatedAt: "updated_at",
              profileId: "profile_id",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            caseSensitive: Schema.Boolean,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            secret: Schema.Boolean,
            type: Schema.Literal("exact_data"),
            updatedAt: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              caseSensitive: "case_sensitive",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              secret: "secret",
              type: "type",
              updatedAt: "updated_at",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("document_fingerprint"),
            updatedAt: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              type: "type",
              updatedAt: "updated_at",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("word_list"),
            updatedAt: Schema.String,
            wordList: Schema.Unknown,
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              type: "type",
              updatedAt: "updated_at",
              wordList: "word_list",
              profileId: "profile_id",
            }),
          ),
        ]),
      ),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      allowedMatchCount: "allowed_match_count",
      createdAt: "created_at",
      name: "name",
      ocrEnabled: "ocr_enabled",
      type: "type",
      updatedAt: "updated_at",
      aiContextEnabled: "ai_context_enabled",
      confidenceThreshold: "confidence_threshold",
      contextAwareness: "context_awareness",
      description: "description",
      entries: "entries",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    allowedMatchCount: Schema.Number,
    entries: Schema.Array(
      Schema.Union([
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          pattern: Schema.Unknown,
          type: Schema.Literal("custom"),
          updatedAt: Schema.String,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            pattern: "pattern",
            type: "type",
            updatedAt: "updated_at",
            profileId: "profile_id",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          confidence: Schema.Struct({
            aiContextAvailable: Schema.Boolean,
            available: Schema.Boolean,
          }).pipe(
            Schema.encodeKeys({
              aiContextAvailable: "ai_context_available",
              available: "available",
            }),
          ),
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("predefined"),
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
          variant: Schema.optional(
            Schema.Struct({
              topicType: Schema.Literals(["Intent", "Content"]),
              type: Schema.Literal("PromptTopic"),
              description: Schema.optional(
                Schema.Union([Schema.String, Schema.Null]),
              ),
            }).pipe(
              Schema.encodeKeys({
                topicType: "topic_type",
                type: "type",
                description: "description",
              }),
            ),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            confidence: "confidence",
            enabled: "enabled",
            name: "name",
            type: "type",
            profileId: "profile_id",
            variant: "variant",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("integration"),
          updatedAt: Schema.String,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
            profileId: "profile_id",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          caseSensitive: Schema.Boolean,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          secret: Schema.Boolean,
          type: Schema.Literal("exact_data"),
          updatedAt: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            caseSensitive: "case_sensitive",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            secret: "secret",
            type: "type",
            updatedAt: "updated_at",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("document_fingerprint"),
          updatedAt: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("word_list"),
          updatedAt: Schema.String,
          wordList: Schema.Unknown,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
            wordList: "word_list",
            profileId: "profile_id",
          }),
        ),
      ]),
    ),
    name: Schema.String,
    type: Schema.Literal("predefined"),
    aiContextEnabled: Schema.optional(Schema.Boolean),
    confidenceThreshold: Schema.optional(
      Schema.Literals(["low", "medium", "high", "very_high"]),
    ),
    contextAwareness: Schema.optional(Schema.Unknown),
    ocrEnabled: Schema.optional(Schema.Boolean),
    openAccess: Schema.optional(Schema.Boolean),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      allowedMatchCount: "allowed_match_count",
      entries: "entries",
      name: "name",
      type: "type",
      aiContextEnabled: "ai_context_enabled",
      confidenceThreshold: "confidence_threshold",
      contextAwareness: "context_awareness",
      ocrEnabled: "ocr_enabled",
      openAccess: "open_access",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    entries: Schema.Array(
      Schema.Union([
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          pattern: Schema.Unknown,
          type: Schema.Literal("custom"),
          updatedAt: Schema.String,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            pattern: "pattern",
            type: "type",
            updatedAt: "updated_at",
            profileId: "profile_id",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          confidence: Schema.Struct({
            aiContextAvailable: Schema.Boolean,
            available: Schema.Boolean,
          }).pipe(
            Schema.encodeKeys({
              aiContextAvailable: "ai_context_available",
              available: "available",
            }),
          ),
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("predefined"),
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
          variant: Schema.optional(
            Schema.Struct({
              topicType: Schema.Literals(["Intent", "Content"]),
              type: Schema.Literal("PromptTopic"),
              description: Schema.optional(
                Schema.Union([Schema.String, Schema.Null]),
              ),
            }).pipe(
              Schema.encodeKeys({
                topicType: "topic_type",
                type: "type",
                description: "description",
              }),
            ),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            confidence: "confidence",
            enabled: "enabled",
            name: "name",
            type: "type",
            profileId: "profile_id",
            variant: "variant",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("integration"),
          updatedAt: Schema.String,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
            profileId: "profile_id",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          caseSensitive: Schema.Boolean,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          secret: Schema.Boolean,
          type: Schema.Literal("exact_data"),
          updatedAt: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            caseSensitive: "case_sensitive",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            secret: "secret",
            type: "type",
            updatedAt: "updated_at",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("document_fingerprint"),
          updatedAt: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("word_list"),
          updatedAt: Schema.String,
          wordList: Schema.Unknown,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
            wordList: "word_list",
            profileId: "profile_id",
          }),
        ),
      ]),
    ),
    name: Schema.String,
    type: Schema.Literal("integration"),
    updatedAt: Schema.String,
    description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      entries: "entries",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
      description: "description",
    }),
  ),
]) as unknown as Schema.Schema<GetDlpProfileResponse>;

export type GetDlpProfileError = CommonErrors;

export const getDlpProfile: API.OperationMethod<
  GetDlpProfileRequest,
  GetDlpProfileResponse,
  GetDlpProfileError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDlpProfileRequest,
  output: GetDlpProfileResponse,
  errors: [],
}));

export interface ListDlpProfilesRequest {
  /** Path param: */
  accountId: string;
  /** Query param: Return all profiles, including those that current account does not have access to. */
  all?: boolean;
}

export const ListDlpProfilesRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  all: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("all")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/dlp/profiles" }),
) as unknown as Schema.Schema<ListDlpProfilesRequest>;

export type ListDlpProfilesResponse = (
  | {
      id: string;
      allowedMatchCount: number;
      createdAt: string;
      name: string;
      ocrEnabled: boolean;
      type: "custom";
      updatedAt: string;
      aiContextEnabled?: boolean;
      confidenceThreshold?: "low" | "medium" | "high" | "very_high";
      contextAwareness?: unknown;
      description?: string | null;
      entries?: (
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            pattern: unknown;
            type: "custom";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            confidence: { aiContextAvailable: boolean; available: boolean };
            enabled: boolean;
            name: string;
            type: "predefined";
            profileId?: string | null;
            variant?: {
              topicType: "Intent" | "Content";
              type: "PromptTopic";
              description?: string | null;
            };
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "integration";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            caseSensitive: boolean;
            createdAt: string;
            enabled: boolean;
            name: string;
            secret: boolean;
            type: "exact_data";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "document_fingerprint";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "word_list";
            updatedAt: string;
            wordList: unknown;
            profileId?: string | null;
          }
      )[];
    }
  | {
      id: string;
      allowedMatchCount: number;
      entries: (
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            pattern: unknown;
            type: "custom";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            confidence: { aiContextAvailable: boolean; available: boolean };
            enabled: boolean;
            name: string;
            type: "predefined";
            profileId?: string | null;
            variant?: {
              topicType: "Intent" | "Content";
              type: "PromptTopic";
              description?: string | null;
            };
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "integration";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            caseSensitive: boolean;
            createdAt: string;
            enabled: boolean;
            name: string;
            secret: boolean;
            type: "exact_data";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "document_fingerprint";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "word_list";
            updatedAt: string;
            wordList: unknown;
            profileId?: string | null;
          }
      )[];
      name: string;
      type: "predefined";
      aiContextEnabled?: boolean;
      confidenceThreshold?: "low" | "medium" | "high" | "very_high";
      contextAwareness?: unknown;
      ocrEnabled?: boolean;
      openAccess?: boolean;
    }
  | {
      id: string;
      createdAt: string;
      entries: (
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            pattern: unknown;
            type: "custom";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            confidence: { aiContextAvailable: boolean; available: boolean };
            enabled: boolean;
            name: string;
            type: "predefined";
            profileId?: string | null;
            variant?: {
              topicType: "Intent" | "Content";
              type: "PromptTopic";
              description?: string | null;
            };
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "integration";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            caseSensitive: boolean;
            createdAt: string;
            enabled: boolean;
            name: string;
            secret: boolean;
            type: "exact_data";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "document_fingerprint";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "word_list";
            updatedAt: string;
            wordList: unknown;
            profileId?: string | null;
          }
      )[];
      name: string;
      type: "integration";
      updatedAt: string;
      description?: string | null;
    }
)[];

export const ListDlpProfilesResponse = Schema.Array(
  Schema.Union([
    Schema.Struct({
      id: Schema.String,
      allowedMatchCount: Schema.Number,
      createdAt: Schema.String,
      name: Schema.String,
      ocrEnabled: Schema.Boolean,
      type: Schema.Literal("custom"),
      updatedAt: Schema.String,
      aiContextEnabled: Schema.optional(Schema.Boolean),
      confidenceThreshold: Schema.optional(
        Schema.Literals(["low", "medium", "high", "very_high"]),
      ),
      contextAwareness: Schema.optional(Schema.Unknown),
      description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      entries: Schema.optional(
        Schema.Array(
          Schema.Union([
            Schema.Struct({
              id: Schema.String,
              createdAt: Schema.String,
              enabled: Schema.Boolean,
              name: Schema.String,
              pattern: Schema.Unknown,
              type: Schema.Literal("custom"),
              updatedAt: Schema.String,
              profileId: Schema.optional(
                Schema.Union([Schema.String, Schema.Null]),
              ),
            }).pipe(
              Schema.encodeKeys({
                id: "id",
                createdAt: "created_at",
                enabled: "enabled",
                name: "name",
                pattern: "pattern",
                type: "type",
                updatedAt: "updated_at",
                profileId: "profile_id",
              }),
            ),
            Schema.Struct({
              id: Schema.String,
              confidence: Schema.Struct({
                aiContextAvailable: Schema.Boolean,
                available: Schema.Boolean,
              }).pipe(
                Schema.encodeKeys({
                  aiContextAvailable: "ai_context_available",
                  available: "available",
                }),
              ),
              enabled: Schema.Boolean,
              name: Schema.String,
              type: Schema.Literal("predefined"),
              profileId: Schema.optional(
                Schema.Union([Schema.String, Schema.Null]),
              ),
              variant: Schema.optional(
                Schema.Struct({
                  topicType: Schema.Literals(["Intent", "Content"]),
                  type: Schema.Literal("PromptTopic"),
                  description: Schema.optional(
                    Schema.Union([Schema.String, Schema.Null]),
                  ),
                }).pipe(
                  Schema.encodeKeys({
                    topicType: "topic_type",
                    type: "type",
                    description: "description",
                  }),
                ),
              ),
            }).pipe(
              Schema.encodeKeys({
                id: "id",
                confidence: "confidence",
                enabled: "enabled",
                name: "name",
                type: "type",
                profileId: "profile_id",
                variant: "variant",
              }),
            ),
            Schema.Struct({
              id: Schema.String,
              createdAt: Schema.String,
              enabled: Schema.Boolean,
              name: Schema.String,
              type: Schema.Literal("integration"),
              updatedAt: Schema.String,
              profileId: Schema.optional(
                Schema.Union([Schema.String, Schema.Null]),
              ),
            }).pipe(
              Schema.encodeKeys({
                id: "id",
                createdAt: "created_at",
                enabled: "enabled",
                name: "name",
                type: "type",
                updatedAt: "updated_at",
                profileId: "profile_id",
              }),
            ),
            Schema.Struct({
              id: Schema.String,
              caseSensitive: Schema.Boolean,
              createdAt: Schema.String,
              enabled: Schema.Boolean,
              name: Schema.String,
              secret: Schema.Boolean,
              type: Schema.Literal("exact_data"),
              updatedAt: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                id: "id",
                caseSensitive: "case_sensitive",
                createdAt: "created_at",
                enabled: "enabled",
                name: "name",
                secret: "secret",
                type: "type",
                updatedAt: "updated_at",
              }),
            ),
            Schema.Struct({
              id: Schema.String,
              createdAt: Schema.String,
              enabled: Schema.Boolean,
              name: Schema.String,
              type: Schema.Literal("document_fingerprint"),
              updatedAt: Schema.String,
            }).pipe(
              Schema.encodeKeys({
                id: "id",
                createdAt: "created_at",
                enabled: "enabled",
                name: "name",
                type: "type",
                updatedAt: "updated_at",
              }),
            ),
            Schema.Struct({
              id: Schema.String,
              createdAt: Schema.String,
              enabled: Schema.Boolean,
              name: Schema.String,
              type: Schema.Literal("word_list"),
              updatedAt: Schema.String,
              wordList: Schema.Unknown,
              profileId: Schema.optional(
                Schema.Union([Schema.String, Schema.Null]),
              ),
            }).pipe(
              Schema.encodeKeys({
                id: "id",
                createdAt: "created_at",
                enabled: "enabled",
                name: "name",
                type: "type",
                updatedAt: "updated_at",
                wordList: "word_list",
                profileId: "profile_id",
              }),
            ),
          ]),
        ),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        allowedMatchCount: "allowed_match_count",
        createdAt: "created_at",
        name: "name",
        ocrEnabled: "ocr_enabled",
        type: "type",
        updatedAt: "updated_at",
        aiContextEnabled: "ai_context_enabled",
        confidenceThreshold: "confidence_threshold",
        contextAwareness: "context_awareness",
        description: "description",
        entries: "entries",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      allowedMatchCount: Schema.Number,
      entries: Schema.Array(
        Schema.Union([
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            pattern: Schema.Unknown,
            type: Schema.Literal("custom"),
            updatedAt: Schema.String,
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              pattern: "pattern",
              type: "type",
              updatedAt: "updated_at",
              profileId: "profile_id",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            confidence: Schema.Struct({
              aiContextAvailable: Schema.Boolean,
              available: Schema.Boolean,
            }).pipe(
              Schema.encodeKeys({
                aiContextAvailable: "ai_context_available",
                available: "available",
              }),
            ),
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("predefined"),
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            variant: Schema.optional(
              Schema.Struct({
                topicType: Schema.Literals(["Intent", "Content"]),
                type: Schema.Literal("PromptTopic"),
                description: Schema.optional(
                  Schema.Union([Schema.String, Schema.Null]),
                ),
              }).pipe(
                Schema.encodeKeys({
                  topicType: "topic_type",
                  type: "type",
                  description: "description",
                }),
              ),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              confidence: "confidence",
              enabled: "enabled",
              name: "name",
              type: "type",
              profileId: "profile_id",
              variant: "variant",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("integration"),
            updatedAt: Schema.String,
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              type: "type",
              updatedAt: "updated_at",
              profileId: "profile_id",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            caseSensitive: Schema.Boolean,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            secret: Schema.Boolean,
            type: Schema.Literal("exact_data"),
            updatedAt: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              caseSensitive: "case_sensitive",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              secret: "secret",
              type: "type",
              updatedAt: "updated_at",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("document_fingerprint"),
            updatedAt: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              type: "type",
              updatedAt: "updated_at",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("word_list"),
            updatedAt: Schema.String,
            wordList: Schema.Unknown,
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              type: "type",
              updatedAt: "updated_at",
              wordList: "word_list",
              profileId: "profile_id",
            }),
          ),
        ]),
      ),
      name: Schema.String,
      type: Schema.Literal("predefined"),
      aiContextEnabled: Schema.optional(Schema.Boolean),
      confidenceThreshold: Schema.optional(
        Schema.Literals(["low", "medium", "high", "very_high"]),
      ),
      contextAwareness: Schema.optional(Schema.Unknown),
      ocrEnabled: Schema.optional(Schema.Boolean),
      openAccess: Schema.optional(Schema.Boolean),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        allowedMatchCount: "allowed_match_count",
        entries: "entries",
        name: "name",
        type: "type",
        aiContextEnabled: "ai_context_enabled",
        confidenceThreshold: "confidence_threshold",
        contextAwareness: "context_awareness",
        ocrEnabled: "ocr_enabled",
        openAccess: "open_access",
      }),
    ),
    Schema.Struct({
      id: Schema.String,
      createdAt: Schema.String,
      entries: Schema.Array(
        Schema.Union([
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            pattern: Schema.Unknown,
            type: Schema.Literal("custom"),
            updatedAt: Schema.String,
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              pattern: "pattern",
              type: "type",
              updatedAt: "updated_at",
              profileId: "profile_id",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            confidence: Schema.Struct({
              aiContextAvailable: Schema.Boolean,
              available: Schema.Boolean,
            }).pipe(
              Schema.encodeKeys({
                aiContextAvailable: "ai_context_available",
                available: "available",
              }),
            ),
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("predefined"),
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            variant: Schema.optional(
              Schema.Struct({
                topicType: Schema.Literals(["Intent", "Content"]),
                type: Schema.Literal("PromptTopic"),
                description: Schema.optional(
                  Schema.Union([Schema.String, Schema.Null]),
                ),
              }).pipe(
                Schema.encodeKeys({
                  topicType: "topic_type",
                  type: "type",
                  description: "description",
                }),
              ),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              confidence: "confidence",
              enabled: "enabled",
              name: "name",
              type: "type",
              profileId: "profile_id",
              variant: "variant",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("integration"),
            updatedAt: Schema.String,
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              type: "type",
              updatedAt: "updated_at",
              profileId: "profile_id",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            caseSensitive: Schema.Boolean,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            secret: Schema.Boolean,
            type: Schema.Literal("exact_data"),
            updatedAt: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              caseSensitive: "case_sensitive",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              secret: "secret",
              type: "type",
              updatedAt: "updated_at",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("document_fingerprint"),
            updatedAt: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              type: "type",
              updatedAt: "updated_at",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("word_list"),
            updatedAt: Schema.String,
            wordList: Schema.Unknown,
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              type: "type",
              updatedAt: "updated_at",
              wordList: "word_list",
              profileId: "profile_id",
            }),
          ),
        ]),
      ),
      name: Schema.String,
      type: Schema.Literal("integration"),
      updatedAt: Schema.String,
      description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        createdAt: "created_at",
        entries: "entries",
        name: "name",
        type: "type",
        updatedAt: "updated_at",
        description: "description",
      }),
    ),
  ]),
) as unknown as Schema.Schema<ListDlpProfilesResponse>;

export type ListDlpProfilesError = CommonErrors;

export const listDlpProfiles: API.OperationMethod<
  ListDlpProfilesRequest,
  ListDlpProfilesResponse,
  ListDlpProfilesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListDlpProfilesRequest,
  output: ListDlpProfilesResponse,
  errors: [],
}));

// =============================================================================
// DlpProfileCustom
// =============================================================================

export interface GetDlpProfileCustomRequest {
  profileId: string;
  accountId: string;
}

export const GetDlpProfileCustomRequest = Schema.Struct({
  profileId: Schema.String.pipe(T.HttpPath("profileId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dlp/profiles/custom/{profileId}",
  }),
) as unknown as Schema.Schema<GetDlpProfileCustomRequest>;

export type GetDlpProfileCustomResponse =
  | {
      id: string;
      allowedMatchCount: number;
      createdAt: string;
      name: string;
      ocrEnabled: boolean;
      type: "custom";
      updatedAt: string;
      aiContextEnabled?: boolean;
      confidenceThreshold?: "low" | "medium" | "high" | "very_high";
      contextAwareness?: unknown;
      description?: string | null;
      entries?: (
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            pattern: unknown;
            type: "custom";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            confidence: { aiContextAvailable: boolean; available: boolean };
            enabled: boolean;
            name: string;
            type: "predefined";
            profileId?: string | null;
            variant?: {
              topicType: "Intent" | "Content";
              type: "PromptTopic";
              description?: string | null;
            };
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "integration";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            caseSensitive: boolean;
            createdAt: string;
            enabled: boolean;
            name: string;
            secret: boolean;
            type: "exact_data";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "document_fingerprint";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "word_list";
            updatedAt: string;
            wordList: unknown;
            profileId?: string | null;
          }
      )[];
    }
  | {
      id: string;
      allowedMatchCount: number;
      entries: (
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            pattern: unknown;
            type: "custom";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            confidence: { aiContextAvailable: boolean; available: boolean };
            enabled: boolean;
            name: string;
            type: "predefined";
            profileId?: string | null;
            variant?: {
              topicType: "Intent" | "Content";
              type: "PromptTopic";
              description?: string | null;
            };
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "integration";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            caseSensitive: boolean;
            createdAt: string;
            enabled: boolean;
            name: string;
            secret: boolean;
            type: "exact_data";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "document_fingerprint";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "word_list";
            updatedAt: string;
            wordList: unknown;
            profileId?: string | null;
          }
      )[];
      name: string;
      type: "predefined";
      aiContextEnabled?: boolean;
      confidenceThreshold?: "low" | "medium" | "high" | "very_high";
      contextAwareness?: unknown;
      ocrEnabled?: boolean;
      openAccess?: boolean;
    }
  | {
      id: string;
      createdAt: string;
      entries: (
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            pattern: unknown;
            type: "custom";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            confidence: { aiContextAvailable: boolean; available: boolean };
            enabled: boolean;
            name: string;
            type: "predefined";
            profileId?: string | null;
            variant?: {
              topicType: "Intent" | "Content";
              type: "PromptTopic";
              description?: string | null;
            };
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "integration";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            caseSensitive: boolean;
            createdAt: string;
            enabled: boolean;
            name: string;
            secret: boolean;
            type: "exact_data";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "document_fingerprint";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "word_list";
            updatedAt: string;
            wordList: unknown;
            profileId?: string | null;
          }
      )[];
      name: string;
      type: "integration";
      updatedAt: string;
      description?: string | null;
    };

export const GetDlpProfileCustomResponse = Schema.Union([
  Schema.Struct({
    id: Schema.String,
    allowedMatchCount: Schema.Number,
    createdAt: Schema.String,
    name: Schema.String,
    ocrEnabled: Schema.Boolean,
    type: Schema.Literal("custom"),
    updatedAt: Schema.String,
    aiContextEnabled: Schema.optional(Schema.Boolean),
    confidenceThreshold: Schema.optional(
      Schema.Literals(["low", "medium", "high", "very_high"]),
    ),
    contextAwareness: Schema.optional(Schema.Unknown),
    description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    entries: Schema.optional(
      Schema.Array(
        Schema.Union([
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            pattern: Schema.Unknown,
            type: Schema.Literal("custom"),
            updatedAt: Schema.String,
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              pattern: "pattern",
              type: "type",
              updatedAt: "updated_at",
              profileId: "profile_id",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            confidence: Schema.Struct({
              aiContextAvailable: Schema.Boolean,
              available: Schema.Boolean,
            }).pipe(
              Schema.encodeKeys({
                aiContextAvailable: "ai_context_available",
                available: "available",
              }),
            ),
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("predefined"),
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            variant: Schema.optional(
              Schema.Struct({
                topicType: Schema.Literals(["Intent", "Content"]),
                type: Schema.Literal("PromptTopic"),
                description: Schema.optional(
                  Schema.Union([Schema.String, Schema.Null]),
                ),
              }).pipe(
                Schema.encodeKeys({
                  topicType: "topic_type",
                  type: "type",
                  description: "description",
                }),
              ),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              confidence: "confidence",
              enabled: "enabled",
              name: "name",
              type: "type",
              profileId: "profile_id",
              variant: "variant",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("integration"),
            updatedAt: Schema.String,
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              type: "type",
              updatedAt: "updated_at",
              profileId: "profile_id",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            caseSensitive: Schema.Boolean,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            secret: Schema.Boolean,
            type: Schema.Literal("exact_data"),
            updatedAt: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              caseSensitive: "case_sensitive",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              secret: "secret",
              type: "type",
              updatedAt: "updated_at",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("document_fingerprint"),
            updatedAt: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              type: "type",
              updatedAt: "updated_at",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("word_list"),
            updatedAt: Schema.String,
            wordList: Schema.Unknown,
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              type: "type",
              updatedAt: "updated_at",
              wordList: "word_list",
              profileId: "profile_id",
            }),
          ),
        ]),
      ),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      allowedMatchCount: "allowed_match_count",
      createdAt: "created_at",
      name: "name",
      ocrEnabled: "ocr_enabled",
      type: "type",
      updatedAt: "updated_at",
      aiContextEnabled: "ai_context_enabled",
      confidenceThreshold: "confidence_threshold",
      contextAwareness: "context_awareness",
      description: "description",
      entries: "entries",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    allowedMatchCount: Schema.Number,
    entries: Schema.Array(
      Schema.Union([
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          pattern: Schema.Unknown,
          type: Schema.Literal("custom"),
          updatedAt: Schema.String,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            pattern: "pattern",
            type: "type",
            updatedAt: "updated_at",
            profileId: "profile_id",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          confidence: Schema.Struct({
            aiContextAvailable: Schema.Boolean,
            available: Schema.Boolean,
          }).pipe(
            Schema.encodeKeys({
              aiContextAvailable: "ai_context_available",
              available: "available",
            }),
          ),
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("predefined"),
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
          variant: Schema.optional(
            Schema.Struct({
              topicType: Schema.Literals(["Intent", "Content"]),
              type: Schema.Literal("PromptTopic"),
              description: Schema.optional(
                Schema.Union([Schema.String, Schema.Null]),
              ),
            }).pipe(
              Schema.encodeKeys({
                topicType: "topic_type",
                type: "type",
                description: "description",
              }),
            ),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            confidence: "confidence",
            enabled: "enabled",
            name: "name",
            type: "type",
            profileId: "profile_id",
            variant: "variant",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("integration"),
          updatedAt: Schema.String,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
            profileId: "profile_id",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          caseSensitive: Schema.Boolean,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          secret: Schema.Boolean,
          type: Schema.Literal("exact_data"),
          updatedAt: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            caseSensitive: "case_sensitive",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            secret: "secret",
            type: "type",
            updatedAt: "updated_at",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("document_fingerprint"),
          updatedAt: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("word_list"),
          updatedAt: Schema.String,
          wordList: Schema.Unknown,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
            wordList: "word_list",
            profileId: "profile_id",
          }),
        ),
      ]),
    ),
    name: Schema.String,
    type: Schema.Literal("predefined"),
    aiContextEnabled: Schema.optional(Schema.Boolean),
    confidenceThreshold: Schema.optional(
      Schema.Literals(["low", "medium", "high", "very_high"]),
    ),
    contextAwareness: Schema.optional(Schema.Unknown),
    ocrEnabled: Schema.optional(Schema.Boolean),
    openAccess: Schema.optional(Schema.Boolean),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      allowedMatchCount: "allowed_match_count",
      entries: "entries",
      name: "name",
      type: "type",
      aiContextEnabled: "ai_context_enabled",
      confidenceThreshold: "confidence_threshold",
      contextAwareness: "context_awareness",
      ocrEnabled: "ocr_enabled",
      openAccess: "open_access",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    entries: Schema.Array(
      Schema.Union([
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          pattern: Schema.Unknown,
          type: Schema.Literal("custom"),
          updatedAt: Schema.String,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            pattern: "pattern",
            type: "type",
            updatedAt: "updated_at",
            profileId: "profile_id",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          confidence: Schema.Struct({
            aiContextAvailable: Schema.Boolean,
            available: Schema.Boolean,
          }).pipe(
            Schema.encodeKeys({
              aiContextAvailable: "ai_context_available",
              available: "available",
            }),
          ),
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("predefined"),
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
          variant: Schema.optional(
            Schema.Struct({
              topicType: Schema.Literals(["Intent", "Content"]),
              type: Schema.Literal("PromptTopic"),
              description: Schema.optional(
                Schema.Union([Schema.String, Schema.Null]),
              ),
            }).pipe(
              Schema.encodeKeys({
                topicType: "topic_type",
                type: "type",
                description: "description",
              }),
            ),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            confidence: "confidence",
            enabled: "enabled",
            name: "name",
            type: "type",
            profileId: "profile_id",
            variant: "variant",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("integration"),
          updatedAt: Schema.String,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
            profileId: "profile_id",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          caseSensitive: Schema.Boolean,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          secret: Schema.Boolean,
          type: Schema.Literal("exact_data"),
          updatedAt: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            caseSensitive: "case_sensitive",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            secret: "secret",
            type: "type",
            updatedAt: "updated_at",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("document_fingerprint"),
          updatedAt: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("word_list"),
          updatedAt: Schema.String,
          wordList: Schema.Unknown,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
            wordList: "word_list",
            profileId: "profile_id",
          }),
        ),
      ]),
    ),
    name: Schema.String,
    type: Schema.Literal("integration"),
    updatedAt: Schema.String,
    description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      entries: "entries",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
      description: "description",
    }),
  ),
]) as unknown as Schema.Schema<GetDlpProfileCustomResponse>;

export type GetDlpProfileCustomError = CommonErrors;

export const getDlpProfileCustom: API.OperationMethod<
  GetDlpProfileCustomRequest,
  GetDlpProfileCustomResponse,
  GetDlpProfileCustomError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDlpProfileCustomRequest,
  output: GetDlpProfileCustomResponse,
  errors: [],
}));

export interface CreateDlpProfileCustomRequest {
  /** Path param: */
  accountId: string;
  /** Body param: */
  name: string;
  /** Body param: */
  aiContextEnabled?: boolean;
  /** Body param: Related DLP policies will trigger when the match count exceeds the number set. */
  allowedMatchCount?: number;
  /** Body param: */
  confidenceThreshold?: string | null;
  /** @deprecated Body param: Scan the context of predefined entries to only return matches surrounded by keywords. */
  contextAwareness?: unknown;
  /** Body param: The description of the profile. */
  description?: string | null;
  /** Body param: */
  entries?: (
    | { enabled: boolean; name: string; pattern: unknown }
    | { enabled: boolean; name: string; words: string[] }
  )[];
  /** Body param: */
  ocrEnabled?: boolean;
  /** Body param: Entries from other profiles (e.g. pre-defined Cloudflare profiles, or your Microsoft Information Protection profiles). */
  sharedEntries?: { enabled: boolean; entryId: string }[];
}

export const CreateDlpProfileCustomRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.String,
  aiContextEnabled: Schema.optional(Schema.Boolean),
  allowedMatchCount: Schema.optional(Schema.Number),
  confidenceThreshold: Schema.optional(
    Schema.Union([Schema.String, Schema.Null]),
  ),
  contextAwareness: Schema.optional(Schema.Unknown),
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  entries: Schema.optional(
    Schema.Array(
      Schema.Union([
        Schema.Struct({
          enabled: Schema.Boolean,
          name: Schema.String,
          pattern: Schema.Unknown,
        }),
        Schema.Struct({
          enabled: Schema.Boolean,
          name: Schema.String,
          words: Schema.Array(Schema.String),
        }),
      ]),
    ),
  ),
  ocrEnabled: Schema.optional(Schema.Boolean),
  sharedEntries: Schema.optional(
    Schema.Array(
      Schema.Struct({
        enabled: Schema.Boolean,
        entryId: Schema.String,
      }).pipe(Schema.encodeKeys({ enabled: "enabled", entryId: "entry_id" })),
    ),
  ),
}).pipe(
  Schema.encodeKeys({
    name: "name",
    aiContextEnabled: "ai_context_enabled",
    allowedMatchCount: "allowed_match_count",
    confidenceThreshold: "confidence_threshold",
    contextAwareness: "context_awareness",
    description: "description",
    entries: "entries",
    ocrEnabled: "ocr_enabled",
    sharedEntries: "shared_entries",
  }),
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/dlp/profiles/custom",
  }),
) as unknown as Schema.Schema<CreateDlpProfileCustomRequest>;

export type CreateDlpProfileCustomResponse =
  | {
      id: string;
      allowedMatchCount: number;
      createdAt: string;
      name: string;
      ocrEnabled: boolean;
      type: "custom";
      updatedAt: string;
      aiContextEnabled?: boolean;
      confidenceThreshold?: "low" | "medium" | "high" | "very_high";
      contextAwareness?: unknown;
      description?: string | null;
      entries?: (
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            pattern: unknown;
            type: "custom";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            confidence: { aiContextAvailable: boolean; available: boolean };
            enabled: boolean;
            name: string;
            type: "predefined";
            profileId?: string | null;
            variant?: {
              topicType: "Intent" | "Content";
              type: "PromptTopic";
              description?: string | null;
            };
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "integration";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            caseSensitive: boolean;
            createdAt: string;
            enabled: boolean;
            name: string;
            secret: boolean;
            type: "exact_data";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "document_fingerprint";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "word_list";
            updatedAt: string;
            wordList: unknown;
            profileId?: string | null;
          }
      )[];
    }
  | {
      id: string;
      allowedMatchCount: number;
      entries: (
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            pattern: unknown;
            type: "custom";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            confidence: { aiContextAvailable: boolean; available: boolean };
            enabled: boolean;
            name: string;
            type: "predefined";
            profileId?: string | null;
            variant?: {
              topicType: "Intent" | "Content";
              type: "PromptTopic";
              description?: string | null;
            };
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "integration";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            caseSensitive: boolean;
            createdAt: string;
            enabled: boolean;
            name: string;
            secret: boolean;
            type: "exact_data";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "document_fingerprint";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "word_list";
            updatedAt: string;
            wordList: unknown;
            profileId?: string | null;
          }
      )[];
      name: string;
      type: "predefined";
      aiContextEnabled?: boolean;
      confidenceThreshold?: "low" | "medium" | "high" | "very_high";
      contextAwareness?: unknown;
      ocrEnabled?: boolean;
      openAccess?: boolean;
    }
  | {
      id: string;
      createdAt: string;
      entries: (
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            pattern: unknown;
            type: "custom";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            confidence: { aiContextAvailable: boolean; available: boolean };
            enabled: boolean;
            name: string;
            type: "predefined";
            profileId?: string | null;
            variant?: {
              topicType: "Intent" | "Content";
              type: "PromptTopic";
              description?: string | null;
            };
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "integration";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            caseSensitive: boolean;
            createdAt: string;
            enabled: boolean;
            name: string;
            secret: boolean;
            type: "exact_data";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "document_fingerprint";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "word_list";
            updatedAt: string;
            wordList: unknown;
            profileId?: string | null;
          }
      )[];
      name: string;
      type: "integration";
      updatedAt: string;
      description?: string | null;
    };

export const CreateDlpProfileCustomResponse = Schema.Union([
  Schema.Struct({
    id: Schema.String,
    allowedMatchCount: Schema.Number,
    createdAt: Schema.String,
    name: Schema.String,
    ocrEnabled: Schema.Boolean,
    type: Schema.Literal("custom"),
    updatedAt: Schema.String,
    aiContextEnabled: Schema.optional(Schema.Boolean),
    confidenceThreshold: Schema.optional(
      Schema.Literals(["low", "medium", "high", "very_high"]),
    ),
    contextAwareness: Schema.optional(Schema.Unknown),
    description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    entries: Schema.optional(
      Schema.Array(
        Schema.Union([
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            pattern: Schema.Unknown,
            type: Schema.Literal("custom"),
            updatedAt: Schema.String,
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              pattern: "pattern",
              type: "type",
              updatedAt: "updated_at",
              profileId: "profile_id",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            confidence: Schema.Struct({
              aiContextAvailable: Schema.Boolean,
              available: Schema.Boolean,
            }).pipe(
              Schema.encodeKeys({
                aiContextAvailable: "ai_context_available",
                available: "available",
              }),
            ),
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("predefined"),
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            variant: Schema.optional(
              Schema.Struct({
                topicType: Schema.Literals(["Intent", "Content"]),
                type: Schema.Literal("PromptTopic"),
                description: Schema.optional(
                  Schema.Union([Schema.String, Schema.Null]),
                ),
              }).pipe(
                Schema.encodeKeys({
                  topicType: "topic_type",
                  type: "type",
                  description: "description",
                }),
              ),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              confidence: "confidence",
              enabled: "enabled",
              name: "name",
              type: "type",
              profileId: "profile_id",
              variant: "variant",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("integration"),
            updatedAt: Schema.String,
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              type: "type",
              updatedAt: "updated_at",
              profileId: "profile_id",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            caseSensitive: Schema.Boolean,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            secret: Schema.Boolean,
            type: Schema.Literal("exact_data"),
            updatedAt: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              caseSensitive: "case_sensitive",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              secret: "secret",
              type: "type",
              updatedAt: "updated_at",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("document_fingerprint"),
            updatedAt: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              type: "type",
              updatedAt: "updated_at",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("word_list"),
            updatedAt: Schema.String,
            wordList: Schema.Unknown,
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              type: "type",
              updatedAt: "updated_at",
              wordList: "word_list",
              profileId: "profile_id",
            }),
          ),
        ]),
      ),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      allowedMatchCount: "allowed_match_count",
      createdAt: "created_at",
      name: "name",
      ocrEnabled: "ocr_enabled",
      type: "type",
      updatedAt: "updated_at",
      aiContextEnabled: "ai_context_enabled",
      confidenceThreshold: "confidence_threshold",
      contextAwareness: "context_awareness",
      description: "description",
      entries: "entries",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    allowedMatchCount: Schema.Number,
    entries: Schema.Array(
      Schema.Union([
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          pattern: Schema.Unknown,
          type: Schema.Literal("custom"),
          updatedAt: Schema.String,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            pattern: "pattern",
            type: "type",
            updatedAt: "updated_at",
            profileId: "profile_id",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          confidence: Schema.Struct({
            aiContextAvailable: Schema.Boolean,
            available: Schema.Boolean,
          }).pipe(
            Schema.encodeKeys({
              aiContextAvailable: "ai_context_available",
              available: "available",
            }),
          ),
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("predefined"),
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
          variant: Schema.optional(
            Schema.Struct({
              topicType: Schema.Literals(["Intent", "Content"]),
              type: Schema.Literal("PromptTopic"),
              description: Schema.optional(
                Schema.Union([Schema.String, Schema.Null]),
              ),
            }).pipe(
              Schema.encodeKeys({
                topicType: "topic_type",
                type: "type",
                description: "description",
              }),
            ),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            confidence: "confidence",
            enabled: "enabled",
            name: "name",
            type: "type",
            profileId: "profile_id",
            variant: "variant",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("integration"),
          updatedAt: Schema.String,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
            profileId: "profile_id",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          caseSensitive: Schema.Boolean,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          secret: Schema.Boolean,
          type: Schema.Literal("exact_data"),
          updatedAt: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            caseSensitive: "case_sensitive",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            secret: "secret",
            type: "type",
            updatedAt: "updated_at",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("document_fingerprint"),
          updatedAt: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("word_list"),
          updatedAt: Schema.String,
          wordList: Schema.Unknown,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
            wordList: "word_list",
            profileId: "profile_id",
          }),
        ),
      ]),
    ),
    name: Schema.String,
    type: Schema.Literal("predefined"),
    aiContextEnabled: Schema.optional(Schema.Boolean),
    confidenceThreshold: Schema.optional(
      Schema.Literals(["low", "medium", "high", "very_high"]),
    ),
    contextAwareness: Schema.optional(Schema.Unknown),
    ocrEnabled: Schema.optional(Schema.Boolean),
    openAccess: Schema.optional(Schema.Boolean),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      allowedMatchCount: "allowed_match_count",
      entries: "entries",
      name: "name",
      type: "type",
      aiContextEnabled: "ai_context_enabled",
      confidenceThreshold: "confidence_threshold",
      contextAwareness: "context_awareness",
      ocrEnabled: "ocr_enabled",
      openAccess: "open_access",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    entries: Schema.Array(
      Schema.Union([
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          pattern: Schema.Unknown,
          type: Schema.Literal("custom"),
          updatedAt: Schema.String,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            pattern: "pattern",
            type: "type",
            updatedAt: "updated_at",
            profileId: "profile_id",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          confidence: Schema.Struct({
            aiContextAvailable: Schema.Boolean,
            available: Schema.Boolean,
          }).pipe(
            Schema.encodeKeys({
              aiContextAvailable: "ai_context_available",
              available: "available",
            }),
          ),
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("predefined"),
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
          variant: Schema.optional(
            Schema.Struct({
              topicType: Schema.Literals(["Intent", "Content"]),
              type: Schema.Literal("PromptTopic"),
              description: Schema.optional(
                Schema.Union([Schema.String, Schema.Null]),
              ),
            }).pipe(
              Schema.encodeKeys({
                topicType: "topic_type",
                type: "type",
                description: "description",
              }),
            ),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            confidence: "confidence",
            enabled: "enabled",
            name: "name",
            type: "type",
            profileId: "profile_id",
            variant: "variant",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("integration"),
          updatedAt: Schema.String,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
            profileId: "profile_id",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          caseSensitive: Schema.Boolean,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          secret: Schema.Boolean,
          type: Schema.Literal("exact_data"),
          updatedAt: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            caseSensitive: "case_sensitive",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            secret: "secret",
            type: "type",
            updatedAt: "updated_at",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("document_fingerprint"),
          updatedAt: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("word_list"),
          updatedAt: Schema.String,
          wordList: Schema.Unknown,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
            wordList: "word_list",
            profileId: "profile_id",
          }),
        ),
      ]),
    ),
    name: Schema.String,
    type: Schema.Literal("integration"),
    updatedAt: Schema.String,
    description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      entries: "entries",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
      description: "description",
    }),
  ),
]) as unknown as Schema.Schema<CreateDlpProfileCustomResponse>;

export type CreateDlpProfileCustomError = CommonErrors;

export const createDlpProfileCustom: API.OperationMethod<
  CreateDlpProfileCustomRequest,
  CreateDlpProfileCustomResponse,
  CreateDlpProfileCustomError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateDlpProfileCustomRequest,
  output: CreateDlpProfileCustomResponse,
  errors: [],
}));

export interface UpdateDlpProfileCustomRequest {
  profileId: string;
  /** Path param: */
  accountId: string;
  /** Body param: */
  name: string;
  /** Body param: */
  aiContextEnabled?: boolean;
  /** Body param: */
  allowedMatchCount?: number | null;
  /** Body param: */
  confidenceThreshold?: string | null;
  /** @deprecated Body param: Scan the context of predefined entries to only return matches surrounded by keywords. */
  contextAwareness?: unknown;
  /** Body param: The description of the profile. */
  description?: string | null;
  /** @deprecated Body param: Custom entries from this profile. If this field is omitted, entries owned by this profile will not be changed. */
  entries?:
    | (
        | { enabled: boolean; entryId: string; name: string; pattern: unknown }
        | { enabled: boolean; name: string; pattern: unknown }
      )[]
    | null;
  /** Body param: */
  ocrEnabled?: boolean;
  /** Body param: Other entries, e.g. predefined or integration. */
  sharedEntries?: { enabled: boolean; entryId: string }[];
}

export const UpdateDlpProfileCustomRequest = Schema.Struct({
  profileId: Schema.String.pipe(T.HttpPath("profileId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.String,
  aiContextEnabled: Schema.optional(Schema.Boolean),
  allowedMatchCount: Schema.optional(
    Schema.Union([Schema.Number, Schema.Null]),
  ),
  confidenceThreshold: Schema.optional(
    Schema.Union([Schema.String, Schema.Null]),
  ),
  contextAwareness: Schema.optional(Schema.Unknown),
  description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  entries: Schema.optional(
    Schema.Union([
      Schema.Array(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.Boolean,
            entryId: Schema.String,
            name: Schema.String,
            pattern: Schema.Unknown,
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              entryId: "entry_id",
              name: "name",
              pattern: "pattern",
            }),
          ),
          Schema.Struct({
            enabled: Schema.Boolean,
            name: Schema.String,
            pattern: Schema.Unknown,
          }),
        ]),
      ),
      Schema.Null,
    ]),
  ),
  ocrEnabled: Schema.optional(Schema.Boolean),
  sharedEntries: Schema.optional(
    Schema.Array(
      Schema.Struct({
        enabled: Schema.Boolean,
        entryId: Schema.String,
      }).pipe(Schema.encodeKeys({ enabled: "enabled", entryId: "entry_id" })),
    ),
  ),
}).pipe(
  Schema.encodeKeys({
    name: "name",
    aiContextEnabled: "ai_context_enabled",
    allowedMatchCount: "allowed_match_count",
    confidenceThreshold: "confidence_threshold",
    contextAwareness: "context_awareness",
    description: "description",
    entries: "entries",
    ocrEnabled: "ocr_enabled",
    sharedEntries: "shared_entries",
  }),
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/dlp/profiles/custom/{profileId}",
  }),
) as unknown as Schema.Schema<UpdateDlpProfileCustomRequest>;

export type UpdateDlpProfileCustomResponse =
  | {
      id: string;
      allowedMatchCount: number;
      createdAt: string;
      name: string;
      ocrEnabled: boolean;
      type: "custom";
      updatedAt: string;
      aiContextEnabled?: boolean;
      confidenceThreshold?: "low" | "medium" | "high" | "very_high";
      contextAwareness?: unknown;
      description?: string | null;
      entries?: (
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            pattern: unknown;
            type: "custom";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            confidence: { aiContextAvailable: boolean; available: boolean };
            enabled: boolean;
            name: string;
            type: "predefined";
            profileId?: string | null;
            variant?: {
              topicType: "Intent" | "Content";
              type: "PromptTopic";
              description?: string | null;
            };
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "integration";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            caseSensitive: boolean;
            createdAt: string;
            enabled: boolean;
            name: string;
            secret: boolean;
            type: "exact_data";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "document_fingerprint";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "word_list";
            updatedAt: string;
            wordList: unknown;
            profileId?: string | null;
          }
      )[];
    }
  | {
      id: string;
      allowedMatchCount: number;
      entries: (
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            pattern: unknown;
            type: "custom";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            confidence: { aiContextAvailable: boolean; available: boolean };
            enabled: boolean;
            name: string;
            type: "predefined";
            profileId?: string | null;
            variant?: {
              topicType: "Intent" | "Content";
              type: "PromptTopic";
              description?: string | null;
            };
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "integration";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            caseSensitive: boolean;
            createdAt: string;
            enabled: boolean;
            name: string;
            secret: boolean;
            type: "exact_data";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "document_fingerprint";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "word_list";
            updatedAt: string;
            wordList: unknown;
            profileId?: string | null;
          }
      )[];
      name: string;
      type: "predefined";
      aiContextEnabled?: boolean;
      confidenceThreshold?: "low" | "medium" | "high" | "very_high";
      contextAwareness?: unknown;
      ocrEnabled?: boolean;
      openAccess?: boolean;
    }
  | {
      id: string;
      createdAt: string;
      entries: (
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            pattern: unknown;
            type: "custom";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            confidence: { aiContextAvailable: boolean; available: boolean };
            enabled: boolean;
            name: string;
            type: "predefined";
            profileId?: string | null;
            variant?: {
              topicType: "Intent" | "Content";
              type: "PromptTopic";
              description?: string | null;
            };
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "integration";
            updatedAt: string;
            profileId?: string | null;
          }
        | {
            id: string;
            caseSensitive: boolean;
            createdAt: string;
            enabled: boolean;
            name: string;
            secret: boolean;
            type: "exact_data";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "document_fingerprint";
            updatedAt: string;
          }
        | {
            id: string;
            createdAt: string;
            enabled: boolean;
            name: string;
            type: "word_list";
            updatedAt: string;
            wordList: unknown;
            profileId?: string | null;
          }
      )[];
      name: string;
      type: "integration";
      updatedAt: string;
      description?: string | null;
    };

export const UpdateDlpProfileCustomResponse = Schema.Union([
  Schema.Struct({
    id: Schema.String,
    allowedMatchCount: Schema.Number,
    createdAt: Schema.String,
    name: Schema.String,
    ocrEnabled: Schema.Boolean,
    type: Schema.Literal("custom"),
    updatedAt: Schema.String,
    aiContextEnabled: Schema.optional(Schema.Boolean),
    confidenceThreshold: Schema.optional(
      Schema.Literals(["low", "medium", "high", "very_high"]),
    ),
    contextAwareness: Schema.optional(Schema.Unknown),
    description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    entries: Schema.optional(
      Schema.Array(
        Schema.Union([
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            pattern: Schema.Unknown,
            type: Schema.Literal("custom"),
            updatedAt: Schema.String,
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              pattern: "pattern",
              type: "type",
              updatedAt: "updated_at",
              profileId: "profile_id",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            confidence: Schema.Struct({
              aiContextAvailable: Schema.Boolean,
              available: Schema.Boolean,
            }).pipe(
              Schema.encodeKeys({
                aiContextAvailable: "ai_context_available",
                available: "available",
              }),
            ),
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("predefined"),
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            variant: Schema.optional(
              Schema.Struct({
                topicType: Schema.Literals(["Intent", "Content"]),
                type: Schema.Literal("PromptTopic"),
                description: Schema.optional(
                  Schema.Union([Schema.String, Schema.Null]),
                ),
              }).pipe(
                Schema.encodeKeys({
                  topicType: "topic_type",
                  type: "type",
                  description: "description",
                }),
              ),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              confidence: "confidence",
              enabled: "enabled",
              name: "name",
              type: "type",
              profileId: "profile_id",
              variant: "variant",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("integration"),
            updatedAt: Schema.String,
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              type: "type",
              updatedAt: "updated_at",
              profileId: "profile_id",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            caseSensitive: Schema.Boolean,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            secret: Schema.Boolean,
            type: Schema.Literal("exact_data"),
            updatedAt: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              caseSensitive: "case_sensitive",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              secret: "secret",
              type: "type",
              updatedAt: "updated_at",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("document_fingerprint"),
            updatedAt: Schema.String,
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              type: "type",
              updatedAt: "updated_at",
            }),
          ),
          Schema.Struct({
            id: Schema.String,
            createdAt: Schema.String,
            enabled: Schema.Boolean,
            name: Schema.String,
            type: Schema.Literal("word_list"),
            updatedAt: Schema.String,
            wordList: Schema.Unknown,
            profileId: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              createdAt: "created_at",
              enabled: "enabled",
              name: "name",
              type: "type",
              updatedAt: "updated_at",
              wordList: "word_list",
              profileId: "profile_id",
            }),
          ),
        ]),
      ),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      allowedMatchCount: "allowed_match_count",
      createdAt: "created_at",
      name: "name",
      ocrEnabled: "ocr_enabled",
      type: "type",
      updatedAt: "updated_at",
      aiContextEnabled: "ai_context_enabled",
      confidenceThreshold: "confidence_threshold",
      contextAwareness: "context_awareness",
      description: "description",
      entries: "entries",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    allowedMatchCount: Schema.Number,
    entries: Schema.Array(
      Schema.Union([
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          pattern: Schema.Unknown,
          type: Schema.Literal("custom"),
          updatedAt: Schema.String,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            pattern: "pattern",
            type: "type",
            updatedAt: "updated_at",
            profileId: "profile_id",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          confidence: Schema.Struct({
            aiContextAvailable: Schema.Boolean,
            available: Schema.Boolean,
          }).pipe(
            Schema.encodeKeys({
              aiContextAvailable: "ai_context_available",
              available: "available",
            }),
          ),
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("predefined"),
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
          variant: Schema.optional(
            Schema.Struct({
              topicType: Schema.Literals(["Intent", "Content"]),
              type: Schema.Literal("PromptTopic"),
              description: Schema.optional(
                Schema.Union([Schema.String, Schema.Null]),
              ),
            }).pipe(
              Schema.encodeKeys({
                topicType: "topic_type",
                type: "type",
                description: "description",
              }),
            ),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            confidence: "confidence",
            enabled: "enabled",
            name: "name",
            type: "type",
            profileId: "profile_id",
            variant: "variant",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("integration"),
          updatedAt: Schema.String,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
            profileId: "profile_id",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          caseSensitive: Schema.Boolean,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          secret: Schema.Boolean,
          type: Schema.Literal("exact_data"),
          updatedAt: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            caseSensitive: "case_sensitive",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            secret: "secret",
            type: "type",
            updatedAt: "updated_at",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("document_fingerprint"),
          updatedAt: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("word_list"),
          updatedAt: Schema.String,
          wordList: Schema.Unknown,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
            wordList: "word_list",
            profileId: "profile_id",
          }),
        ),
      ]),
    ),
    name: Schema.String,
    type: Schema.Literal("predefined"),
    aiContextEnabled: Schema.optional(Schema.Boolean),
    confidenceThreshold: Schema.optional(
      Schema.Literals(["low", "medium", "high", "very_high"]),
    ),
    contextAwareness: Schema.optional(Schema.Unknown),
    ocrEnabled: Schema.optional(Schema.Boolean),
    openAccess: Schema.optional(Schema.Boolean),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      allowedMatchCount: "allowed_match_count",
      entries: "entries",
      name: "name",
      type: "type",
      aiContextEnabled: "ai_context_enabled",
      confidenceThreshold: "confidence_threshold",
      contextAwareness: "context_awareness",
      ocrEnabled: "ocr_enabled",
      openAccess: "open_access",
    }),
  ),
  Schema.Struct({
    id: Schema.String,
    createdAt: Schema.String,
    entries: Schema.Array(
      Schema.Union([
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          pattern: Schema.Unknown,
          type: Schema.Literal("custom"),
          updatedAt: Schema.String,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            pattern: "pattern",
            type: "type",
            updatedAt: "updated_at",
            profileId: "profile_id",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          confidence: Schema.Struct({
            aiContextAvailable: Schema.Boolean,
            available: Schema.Boolean,
          }).pipe(
            Schema.encodeKeys({
              aiContextAvailable: "ai_context_available",
              available: "available",
            }),
          ),
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("predefined"),
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
          variant: Schema.optional(
            Schema.Struct({
              topicType: Schema.Literals(["Intent", "Content"]),
              type: Schema.Literal("PromptTopic"),
              description: Schema.optional(
                Schema.Union([Schema.String, Schema.Null]),
              ),
            }).pipe(
              Schema.encodeKeys({
                topicType: "topic_type",
                type: "type",
                description: "description",
              }),
            ),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            confidence: "confidence",
            enabled: "enabled",
            name: "name",
            type: "type",
            profileId: "profile_id",
            variant: "variant",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("integration"),
          updatedAt: Schema.String,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
            profileId: "profile_id",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          caseSensitive: Schema.Boolean,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          secret: Schema.Boolean,
          type: Schema.Literal("exact_data"),
          updatedAt: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            caseSensitive: "case_sensitive",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            secret: "secret",
            type: "type",
            updatedAt: "updated_at",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("document_fingerprint"),
          updatedAt: Schema.String,
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
          }),
        ),
        Schema.Struct({
          id: Schema.String,
          createdAt: Schema.String,
          enabled: Schema.Boolean,
          name: Schema.String,
          type: Schema.Literal("word_list"),
          updatedAt: Schema.String,
          wordList: Schema.Unknown,
          profileId: Schema.optional(
            Schema.Union([Schema.String, Schema.Null]),
          ),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            createdAt: "created_at",
            enabled: "enabled",
            name: "name",
            type: "type",
            updatedAt: "updated_at",
            wordList: "word_list",
            profileId: "profile_id",
          }),
        ),
      ]),
    ),
    name: Schema.String,
    type: Schema.Literal("integration"),
    updatedAt: Schema.String,
    description: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      createdAt: "created_at",
      entries: "entries",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
      description: "description",
    }),
  ),
]) as unknown as Schema.Schema<UpdateDlpProfileCustomResponse>;

export type UpdateDlpProfileCustomError = CommonErrors;

export const updateDlpProfileCustom: API.OperationMethod<
  UpdateDlpProfileCustomRequest,
  UpdateDlpProfileCustomResponse,
  UpdateDlpProfileCustomError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateDlpProfileCustomRequest,
  output: UpdateDlpProfileCustomResponse,
  errors: [],
}));

export interface DeleteDlpProfileCustomRequest {
  profileId: string;
  accountId: string;
}

export const DeleteDlpProfileCustomRequest = Schema.Struct({
  profileId: Schema.String.pipe(T.HttpPath("profileId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/dlp/profiles/custom/{profileId}",
  }),
) as unknown as Schema.Schema<DeleteDlpProfileCustomRequest>;

export type DeleteDlpProfileCustomResponse = unknown;

export const DeleteDlpProfileCustomResponse =
  Schema.Unknown as unknown as Schema.Schema<DeleteDlpProfileCustomResponse>;

export type DeleteDlpProfileCustomError = CommonErrors;

export const deleteDlpProfileCustom: API.OperationMethod<
  DeleteDlpProfileCustomRequest,
  DeleteDlpProfileCustomResponse,
  DeleteDlpProfileCustomError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDlpProfileCustomRequest,
  output: DeleteDlpProfileCustomResponse,
  errors: [],
}));

// =============================================================================
// DlpProfilePredefined
// =============================================================================

export interface GetDlpProfilePredefinedRequest {
  profileId: string;
  accountId: string;
}

export const GetDlpProfilePredefinedRequest = Schema.Struct({
  profileId: Schema.String.pipe(T.HttpPath("profileId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dlp/profiles/predefined/{profileId}/config",
  }),
) as unknown as Schema.Schema<GetDlpProfilePredefinedRequest>;

export interface GetDlpProfilePredefinedResponse {
  /** The id of the predefined profile (uuid). */
  id: string;
  allowedMatchCount: number;
  confidenceThreshold: string | null;
  enabledEntries: string[];
  /** @deprecated */
  entries: (
    | {
        id: string;
        createdAt: string;
        enabled: boolean;
        name: string;
        pattern: unknown;
        type: "custom";
        updatedAt: string;
        profileId?: string | null;
      }
    | {
        id: string;
        confidence: { aiContextAvailable: boolean; available: boolean };
        enabled: boolean;
        name: string;
        type: "predefined";
        profileId?: string | null;
        variant?: {
          topicType: "Intent" | "Content";
          type: "PromptTopic";
          description?: string | null;
        };
      }
    | {
        id: string;
        createdAt: string;
        enabled: boolean;
        name: string;
        type: "integration";
        updatedAt: string;
        profileId?: string | null;
      }
    | {
        id: string;
        caseSensitive: boolean;
        createdAt: string;
        enabled: boolean;
        name: string;
        secret: boolean;
        type: "exact_data";
        updatedAt: string;
      }
    | {
        id: string;
        createdAt: string;
        enabled: boolean;
        name: string;
        type: "document_fingerprint";
        updatedAt: string;
      }
    | {
        id: string;
        createdAt: string;
        enabled: boolean;
        name: string;
        type: "word_list";
        updatedAt: string;
        wordList: unknown;
        profileId?: string | null;
      }
  )[];
  /** The name of the predefined profile. */
  name: string;
  aiContextEnabled?: boolean;
  ocrEnabled?: boolean;
  /** Whether this profile can be accessed by anyone. */
  openAccess?: boolean;
}

export const GetDlpProfilePredefinedResponse = Schema.Struct({
  id: Schema.String,
  allowedMatchCount: Schema.Number,
  confidenceThreshold: Schema.Union([Schema.String, Schema.Null]),
  enabledEntries: Schema.Array(Schema.String),
  entries: Schema.Array(
    Schema.Union([
      Schema.Struct({
        id: Schema.String,
        createdAt: Schema.String,
        enabled: Schema.Boolean,
        name: Schema.String,
        pattern: Schema.Unknown,
        type: Schema.Literal("custom"),
        updatedAt: Schema.String,
        profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          createdAt: "created_at",
          enabled: "enabled",
          name: "name",
          pattern: "pattern",
          type: "type",
          updatedAt: "updated_at",
          profileId: "profile_id",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
        confidence: Schema.Struct({
          aiContextAvailable: Schema.Boolean,
          available: Schema.Boolean,
        }).pipe(
          Schema.encodeKeys({
            aiContextAvailable: "ai_context_available",
            available: "available",
          }),
        ),
        enabled: Schema.Boolean,
        name: Schema.String,
        type: Schema.Literal("predefined"),
        profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        variant: Schema.optional(
          Schema.Struct({
            topicType: Schema.Literals(["Intent", "Content"]),
            type: Schema.Literal("PromptTopic"),
            description: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              topicType: "topic_type",
              type: "type",
              description: "description",
            }),
          ),
        ),
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          confidence: "confidence",
          enabled: "enabled",
          name: "name",
          type: "type",
          profileId: "profile_id",
          variant: "variant",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
        createdAt: Schema.String,
        enabled: Schema.Boolean,
        name: Schema.String,
        type: Schema.Literal("integration"),
        updatedAt: Schema.String,
        profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          createdAt: "created_at",
          enabled: "enabled",
          name: "name",
          type: "type",
          updatedAt: "updated_at",
          profileId: "profile_id",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
        caseSensitive: Schema.Boolean,
        createdAt: Schema.String,
        enabled: Schema.Boolean,
        name: Schema.String,
        secret: Schema.Boolean,
        type: Schema.Literal("exact_data"),
        updatedAt: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          caseSensitive: "case_sensitive",
          createdAt: "created_at",
          enabled: "enabled",
          name: "name",
          secret: "secret",
          type: "type",
          updatedAt: "updated_at",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
        createdAt: Schema.String,
        enabled: Schema.Boolean,
        name: Schema.String,
        type: Schema.Literal("document_fingerprint"),
        updatedAt: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          createdAt: "created_at",
          enabled: "enabled",
          name: "name",
          type: "type",
          updatedAt: "updated_at",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
        createdAt: Schema.String,
        enabled: Schema.Boolean,
        name: Schema.String,
        type: Schema.Literal("word_list"),
        updatedAt: Schema.String,
        wordList: Schema.Unknown,
        profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          createdAt: "created_at",
          enabled: "enabled",
          name: "name",
          type: "type",
          updatedAt: "updated_at",
          wordList: "word_list",
          profileId: "profile_id",
        }),
      ),
    ]),
  ),
  name: Schema.String,
  aiContextEnabled: Schema.optional(Schema.Boolean),
  ocrEnabled: Schema.optional(Schema.Boolean),
  openAccess: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    allowedMatchCount: "allowed_match_count",
    confidenceThreshold: "confidence_threshold",
    enabledEntries: "enabled_entries",
    entries: "entries",
    name: "name",
    aiContextEnabled: "ai_context_enabled",
    ocrEnabled: "ocr_enabled",
    openAccess: "open_access",
  }),
) as unknown as Schema.Schema<GetDlpProfilePredefinedResponse>;

export type GetDlpProfilePredefinedError = CommonErrors;

export const getDlpProfilePredefined: API.OperationMethod<
  GetDlpProfilePredefinedRequest,
  GetDlpProfilePredefinedResponse,
  GetDlpProfilePredefinedError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetDlpProfilePredefinedRequest,
  output: GetDlpProfilePredefinedResponse,
  errors: [],
}));

export interface PutDlpProfilePredefinedRequest {
  profileId: string;
  /** Path param: */
  accountId: string;
  /** Body param: */
  aiContextEnabled?: boolean;
  /** Body param: */
  allowedMatchCount?: number | null;
  /** Body param: */
  confidenceThreshold?: string | null;
  /** Body param: */
  enabledEntries?: string[] | null;
  /** @deprecated Body param: */
  entries?: { id: string; enabled: boolean }[];
  /** Body param: */
  ocrEnabled?: boolean;
}

export const PutDlpProfilePredefinedRequest = Schema.Struct({
  profileId: Schema.String.pipe(T.HttpPath("profileId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  aiContextEnabled: Schema.optional(Schema.Boolean),
  allowedMatchCount: Schema.optional(
    Schema.Union([Schema.Number, Schema.Null]),
  ),
  confidenceThreshold: Schema.optional(
    Schema.Union([Schema.String, Schema.Null]),
  ),
  enabledEntries: Schema.optional(
    Schema.Union([Schema.Array(Schema.String), Schema.Null]),
  ),
  entries: Schema.optional(
    Schema.Array(
      Schema.Struct({
        id: Schema.String,
        enabled: Schema.Boolean,
      }),
    ),
  ),
  ocrEnabled: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    aiContextEnabled: "ai_context_enabled",
    allowedMatchCount: "allowed_match_count",
    confidenceThreshold: "confidence_threshold",
    enabledEntries: "enabled_entries",
    entries: "entries",
    ocrEnabled: "ocr_enabled",
  }),
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/dlp/profiles/predefined/{profileId}/config",
  }),
) as unknown as Schema.Schema<PutDlpProfilePredefinedRequest>;

export interface PutDlpProfilePredefinedResponse {
  /** The id of the predefined profile (uuid). */
  id: string;
  allowedMatchCount: number;
  confidenceThreshold: string | null;
  enabledEntries: string[];
  /** @deprecated */
  entries: (
    | {
        id: string;
        createdAt: string;
        enabled: boolean;
        name: string;
        pattern: unknown;
        type: "custom";
        updatedAt: string;
        profileId?: string | null;
      }
    | {
        id: string;
        confidence: { aiContextAvailable: boolean; available: boolean };
        enabled: boolean;
        name: string;
        type: "predefined";
        profileId?: string | null;
        variant?: {
          topicType: "Intent" | "Content";
          type: "PromptTopic";
          description?: string | null;
        };
      }
    | {
        id: string;
        createdAt: string;
        enabled: boolean;
        name: string;
        type: "integration";
        updatedAt: string;
        profileId?: string | null;
      }
    | {
        id: string;
        caseSensitive: boolean;
        createdAt: string;
        enabled: boolean;
        name: string;
        secret: boolean;
        type: "exact_data";
        updatedAt: string;
      }
    | {
        id: string;
        createdAt: string;
        enabled: boolean;
        name: string;
        type: "document_fingerprint";
        updatedAt: string;
      }
    | {
        id: string;
        createdAt: string;
        enabled: boolean;
        name: string;
        type: "word_list";
        updatedAt: string;
        wordList: unknown;
        profileId?: string | null;
      }
  )[];
  /** The name of the predefined profile. */
  name: string;
  aiContextEnabled?: boolean;
  ocrEnabled?: boolean;
  /** Whether this profile can be accessed by anyone. */
  openAccess?: boolean;
}

export const PutDlpProfilePredefinedResponse = Schema.Struct({
  id: Schema.String,
  allowedMatchCount: Schema.Number,
  confidenceThreshold: Schema.Union([Schema.String, Schema.Null]),
  enabledEntries: Schema.Array(Schema.String),
  entries: Schema.Array(
    Schema.Union([
      Schema.Struct({
        id: Schema.String,
        createdAt: Schema.String,
        enabled: Schema.Boolean,
        name: Schema.String,
        pattern: Schema.Unknown,
        type: Schema.Literal("custom"),
        updatedAt: Schema.String,
        profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          createdAt: "created_at",
          enabled: "enabled",
          name: "name",
          pattern: "pattern",
          type: "type",
          updatedAt: "updated_at",
          profileId: "profile_id",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
        confidence: Schema.Struct({
          aiContextAvailable: Schema.Boolean,
          available: Schema.Boolean,
        }).pipe(
          Schema.encodeKeys({
            aiContextAvailable: "ai_context_available",
            available: "available",
          }),
        ),
        enabled: Schema.Boolean,
        name: Schema.String,
        type: Schema.Literal("predefined"),
        profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
        variant: Schema.optional(
          Schema.Struct({
            topicType: Schema.Literals(["Intent", "Content"]),
            type: Schema.Literal("PromptTopic"),
            description: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              topicType: "topic_type",
              type: "type",
              description: "description",
            }),
          ),
        ),
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          confidence: "confidence",
          enabled: "enabled",
          name: "name",
          type: "type",
          profileId: "profile_id",
          variant: "variant",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
        createdAt: Schema.String,
        enabled: Schema.Boolean,
        name: Schema.String,
        type: Schema.Literal("integration"),
        updatedAt: Schema.String,
        profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          createdAt: "created_at",
          enabled: "enabled",
          name: "name",
          type: "type",
          updatedAt: "updated_at",
          profileId: "profile_id",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
        caseSensitive: Schema.Boolean,
        createdAt: Schema.String,
        enabled: Schema.Boolean,
        name: Schema.String,
        secret: Schema.Boolean,
        type: Schema.Literal("exact_data"),
        updatedAt: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          caseSensitive: "case_sensitive",
          createdAt: "created_at",
          enabled: "enabled",
          name: "name",
          secret: "secret",
          type: "type",
          updatedAt: "updated_at",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
        createdAt: Schema.String,
        enabled: Schema.Boolean,
        name: Schema.String,
        type: Schema.Literal("document_fingerprint"),
        updatedAt: Schema.String,
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          createdAt: "created_at",
          enabled: "enabled",
          name: "name",
          type: "type",
          updatedAt: "updated_at",
        }),
      ),
      Schema.Struct({
        id: Schema.String,
        createdAt: Schema.String,
        enabled: Schema.Boolean,
        name: Schema.String,
        type: Schema.Literal("word_list"),
        updatedAt: Schema.String,
        wordList: Schema.Unknown,
        profileId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          createdAt: "created_at",
          enabled: "enabled",
          name: "name",
          type: "type",
          updatedAt: "updated_at",
          wordList: "word_list",
          profileId: "profile_id",
        }),
      ),
    ]),
  ),
  name: Schema.String,
  aiContextEnabled: Schema.optional(Schema.Boolean),
  ocrEnabled: Schema.optional(Schema.Boolean),
  openAccess: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    allowedMatchCount: "allowed_match_count",
    confidenceThreshold: "confidence_threshold",
    enabledEntries: "enabled_entries",
    entries: "entries",
    name: "name",
    aiContextEnabled: "ai_context_enabled",
    ocrEnabled: "ocr_enabled",
    openAccess: "open_access",
  }),
) as unknown as Schema.Schema<PutDlpProfilePredefinedResponse>;

export type PutDlpProfilePredefinedError = CommonErrors;

export const putDlpProfilePredefined: API.OperationMethod<
  PutDlpProfilePredefinedRequest,
  PutDlpProfilePredefinedResponse,
  PutDlpProfilePredefinedError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutDlpProfilePredefinedRequest,
  output: PutDlpProfilePredefinedResponse,
  errors: [],
}));

export interface DeleteDlpProfilePredefinedRequest {
  profileId: string;
  accountId: string;
}

export const DeleteDlpProfilePredefinedRequest = Schema.Struct({
  profileId: Schema.String.pipe(T.HttpPath("profileId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/dlp/profiles/predefined/{profileId}",
  }),
) as unknown as Schema.Schema<DeleteDlpProfilePredefinedRequest>;

export type DeleteDlpProfilePredefinedResponse = unknown;

export const DeleteDlpProfilePredefinedResponse =
  Schema.Unknown as unknown as Schema.Schema<DeleteDlpProfilePredefinedResponse>;

export type DeleteDlpProfilePredefinedError = CommonErrors;

export const deleteDlpProfilePredefined: API.OperationMethod<
  DeleteDlpProfilePredefinedRequest,
  DeleteDlpProfilePredefinedResponse,
  DeleteDlpProfilePredefinedError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteDlpProfilePredefinedRequest,
  output: DeleteDlpProfilePredefinedResponse,
  errors: [],
}));

// =============================================================================
// ExpirationGatewayRule
// =============================================================================

export interface ResetExpirationGatewayRuleRequest {
  ruleId: string;
  accountId: string;
}

export const ResetExpirationGatewayRuleRequest = Schema.Struct({
  ruleId: Schema.String.pipe(T.HttpPath("ruleId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/gateway/rules/{ruleId}/reset_expiration",
  }),
) as unknown as Schema.Schema<ResetExpirationGatewayRuleRequest>;

export interface ResetExpirationGatewayRuleResponse {
  /** Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`. */
  action:
    | "on"
    | "off"
    | "allow"
    | "block"
    | "scan"
    | "noscan"
    | "safesearch"
    | "ytrestricted"
    | "isolate"
    | "noisolate"
    | "override"
    | "l4_override"
    | "egress"
    | "resolve"
    | "quarantine"
    | "redirect";
  /** Specify whether the rule is enabled. */
  enabled: boolean;
  /** Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value. */
  filters: ("http" | "dns" | "l4" | "egress" | "dns_resolver")[];
  /** Specify the rule name. */
  name: string;
  /** Set the order of your rules. Lower values indicate higher precedence. At each processing phase, evaluate applicable rules in ascending order of this value. Refer to [Order of enforcement](http://devel */
  precedence: number;
  /** Specify the wirefilter expression used for traffic matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression */
  traffic: string;
  /** Identify the API resource with a UUID. */
  id?: string;
  createdAt?: string;
  /** Indicate the date of deletion, if any. */
  deletedAt?: string | null;
  /** Specify the rule description. */
  description?: string;
  /** Specify the wirefilter expression used for device posture check. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expres */
  devicePosture?: string;
  /** Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This does not apply to HTTP or network policies. Settable o */
  expiration?: {
    expiresAt: string;
    duration?: number;
    expired?: boolean;
  } | null;
  /** Specify the wirefilter expression used for identity matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expressio */
  identity?: string;
  /** Indicate that this rule is shared via the Orgs API and read only. */
  readOnly?: boolean;
  /** Defines settings for this rule. Settings apply only to specific rule types and must use compatible selectors. If Terraform detects drift, confirm the setting supports your rule type and check whether  */
  ruleSettings?: {
    addHeaders?: Record<string, unknown> | null;
    allowChildBypass?: boolean | null;
    auditSsh?: { commandLogging?: boolean } | null;
    bisoAdminControls?: {
      copy?: "enabled" | "disabled" | "remote_only";
      dcp?: boolean;
      dd?: boolean;
      dk?: boolean;
      download?: "enabled" | "disabled" | "remote_only";
      dp?: boolean;
      du?: boolean;
      keyboard?: "enabled" | "disabled";
      paste?: "enabled" | "disabled" | "remote_only";
      printing?: "enabled" | "disabled";
      upload?: "enabled" | "disabled";
      version?: "v1" | "v2";
    };
    blockPage?: { targetUri: string; includeContext?: boolean } | null;
    blockPageEnabled?: boolean;
    blockReason?: string | null;
    bypassParentRule?: boolean | null;
    checkSession?: { duration?: string; enforce?: boolean } | null;
    dnsResolvers?: { ipv4?: unknown[]; ipv6?: unknown[] } | null;
    egress?: { ipv4?: string; ipv4Fallback?: string; ipv6?: string } | null;
    forensicCopy?: { enabled?: boolean } | null;
    ignoreCnameCategoryMatches?: boolean;
    insecureDisableDnssecValidation?: boolean;
    ipCategories?: boolean;
    ipIndicatorFeeds?: boolean;
    l4override?: { ip?: string; port?: number } | null;
    notificationSettings?: {
      enabled?: boolean;
      includeContext?: boolean;
      msg?: string;
      supportUrl?: string;
    } | null;
    overrideHost?: string;
    overrideIps?: string[] | null;
    payloadLog?: { enabled?: boolean } | null;
    quarantine?: {
      fileTypes?: (
        | "exe"
        | "pdf"
        | "doc"
        | "docm"
        | "docx"
        | "rtf"
        | "ppt"
        | "pptx"
        | "xls"
        | "xlsm"
        | "xlsx"
        | "zip"
        | "rar"
      )[];
    } | null;
    redirect?: {
      targetUri: string;
      includeContext?: boolean;
      preservePathAndQuery?: boolean;
    } | null;
    resolveDnsInternally?: {
      fallback?: "none" | "public_dns";
      viewId?: string;
    } | null;
    resolveDnsThroughCloudflare?: boolean | null;
    untrustedCert?: { action?: "pass_through" | "block" | "error" } | null;
  };
  /** Defines the schedule for activating DNS policies. Settable only for `dns` and `dns_resolver` rules. */
  schedule?: {
    fri?: string;
    mon?: string;
    sat?: string;
    sun?: string;
    thu?: string;
    timeZone?: string;
    tue?: string;
    wed?: string;
  } | null;
  /** Indicate that this rule is sharable via the Orgs API. */
  sharable?: boolean;
  /** Provide the account tag of the account that created the rule. */
  sourceAccount?: string;
  updatedAt?: string;
  /** Indicate the version number of the rule(read-only). */
  version?: number;
  /** Indicate a warning for a misconfigured rule, if any. */
  warningStatus?: string | null;
}

export const ResetExpirationGatewayRuleResponse = Schema.Struct({
  action: Schema.Literals([
    "on",
    "off",
    "allow",
    "block",
    "scan",
    "noscan",
    "safesearch",
    "ytrestricted",
    "isolate",
    "noisolate",
    "override",
    "l4_override",
    "egress",
    "resolve",
    "quarantine",
    "redirect",
  ]),
  enabled: Schema.Boolean,
  filters: Schema.Array(
    Schema.Literals(["http", "dns", "l4", "egress", "dns_resolver"]),
  ),
  name: Schema.String,
  precedence: Schema.Number,
  traffic: Schema.String,
  id: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  deletedAt: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  description: Schema.optional(Schema.String),
  devicePosture: Schema.optional(Schema.String),
  expiration: Schema.optional(
    Schema.Union([
      Schema.Struct({
        expiresAt: Schema.String,
        duration: Schema.optional(Schema.Number),
        expired: Schema.optional(Schema.Boolean),
      }).pipe(
        Schema.encodeKeys({
          expiresAt: "expires_at",
          duration: "duration",
          expired: "expired",
        }),
      ),
      Schema.Null,
    ]),
  ),
  identity: Schema.optional(Schema.String),
  readOnly: Schema.optional(Schema.Boolean),
  ruleSettings: Schema.optional(
    Schema.Struct({
      addHeaders: Schema.optional(
        Schema.Union([Schema.Struct({}), Schema.Null]),
      ),
      allowChildBypass: Schema.optional(
        Schema.Union([Schema.Boolean, Schema.Null]),
      ),
      auditSsh: Schema.optional(
        Schema.Union([
          Schema.Struct({
            commandLogging: Schema.optional(Schema.Boolean),
          }).pipe(Schema.encodeKeys({ commandLogging: "command_logging" })),
          Schema.Null,
        ]),
      ),
      bisoAdminControls: Schema.optional(
        Schema.Struct({
          copy: Schema.optional(
            Schema.Literals(["enabled", "disabled", "remote_only"]),
          ),
          dcp: Schema.optional(Schema.Boolean),
          dd: Schema.optional(Schema.Boolean),
          dk: Schema.optional(Schema.Boolean),
          download: Schema.optional(
            Schema.Literals(["enabled", "disabled", "remote_only"]),
          ),
          dp: Schema.optional(Schema.Boolean),
          du: Schema.optional(Schema.Boolean),
          keyboard: Schema.optional(Schema.Literals(["enabled", "disabled"])),
          paste: Schema.optional(
            Schema.Literals(["enabled", "disabled", "remote_only"]),
          ),
          printing: Schema.optional(Schema.Literals(["enabled", "disabled"])),
          upload: Schema.optional(Schema.Literals(["enabled", "disabled"])),
          version: Schema.optional(Schema.Literals(["v1", "v2"])),
        }),
      ),
      blockPage: Schema.optional(
        Schema.Union([
          Schema.Struct({
            targetUri: Schema.String,
            includeContext: Schema.optional(Schema.Boolean),
          }).pipe(
            Schema.encodeKeys({
              targetUri: "target_uri",
              includeContext: "include_context",
            }),
          ),
          Schema.Null,
        ]),
      ),
      blockPageEnabled: Schema.optional(Schema.Boolean),
      blockReason: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      bypassParentRule: Schema.optional(
        Schema.Union([Schema.Boolean, Schema.Null]),
      ),
      checkSession: Schema.optional(
        Schema.Union([
          Schema.Struct({
            duration: Schema.optional(Schema.String),
            enforce: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      dnsResolvers: Schema.optional(
        Schema.Union([
          Schema.Struct({
            ipv4: Schema.optional(Schema.Array(Schema.Unknown)),
            ipv6: Schema.optional(Schema.Array(Schema.Unknown)),
          }),
          Schema.Null,
        ]),
      ),
      egress: Schema.optional(
        Schema.Union([
          Schema.Struct({
            ipv4: Schema.optional(Schema.String),
            ipv4Fallback: Schema.optional(Schema.String),
            ipv6: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              ipv4: "ipv4",
              ipv4Fallback: "ipv4_fallback",
              ipv6: "ipv6",
            }),
          ),
          Schema.Null,
        ]),
      ),
      forensicCopy: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      ignoreCnameCategoryMatches: Schema.optional(Schema.Boolean),
      insecureDisableDnssecValidation: Schema.optional(Schema.Boolean),
      ipCategories: Schema.optional(Schema.Boolean),
      ipIndicatorFeeds: Schema.optional(Schema.Boolean),
      l4override: Schema.optional(
        Schema.Union([
          Schema.Struct({
            ip: Schema.optional(Schema.String),
            port: Schema.optional(Schema.Number),
          }),
          Schema.Null,
        ]),
      ),
      notificationSettings: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
            includeContext: Schema.optional(Schema.Boolean),
            msg: Schema.optional(Schema.String),
            supportUrl: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              includeContext: "include_context",
              msg: "msg",
              supportUrl: "support_url",
            }),
          ),
          Schema.Null,
        ]),
      ),
      overrideHost: Schema.optional(Schema.String),
      overrideIps: Schema.optional(
        Schema.Union([Schema.Array(Schema.String), Schema.Null]),
      ),
      payloadLog: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      quarantine: Schema.optional(
        Schema.Union([
          Schema.Struct({
            fileTypes: Schema.optional(
              Schema.Array(
                Schema.Literals([
                  "exe",
                  "pdf",
                  "doc",
                  "docm",
                  "docx",
                  "rtf",
                  "ppt",
                  "pptx",
                  "xls",
                  "xlsm",
                  "xlsx",
                  "zip",
                  "rar",
                ]),
              ),
            ),
          }).pipe(Schema.encodeKeys({ fileTypes: "file_types" })),
          Schema.Null,
        ]),
      ),
      redirect: Schema.optional(
        Schema.Union([
          Schema.Struct({
            targetUri: Schema.String,
            includeContext: Schema.optional(Schema.Boolean),
            preservePathAndQuery: Schema.optional(Schema.Boolean),
          }).pipe(
            Schema.encodeKeys({
              targetUri: "target_uri",
              includeContext: "include_context",
              preservePathAndQuery: "preserve_path_and_query",
            }),
          ),
          Schema.Null,
        ]),
      ),
      resolveDnsInternally: Schema.optional(
        Schema.Union([
          Schema.Struct({
            fallback: Schema.optional(Schema.Literals(["none", "public_dns"])),
            viewId: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({ fallback: "fallback", viewId: "view_id" }),
          ),
          Schema.Null,
        ]),
      ),
      resolveDnsThroughCloudflare: Schema.optional(
        Schema.Union([Schema.Boolean, Schema.Null]),
      ),
      untrustedCert: Schema.optional(
        Schema.Union([
          Schema.Struct({
            action: Schema.optional(
              Schema.Literals(["pass_through", "block", "error"]),
            ),
          }),
          Schema.Null,
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        addHeaders: "add_headers",
        allowChildBypass: "allow_child_bypass",
        auditSsh: "audit_ssh",
        bisoAdminControls: "biso_admin_controls",
        blockPage: "block_page",
        blockPageEnabled: "block_page_enabled",
        blockReason: "block_reason",
        bypassParentRule: "bypass_parent_rule",
        checkSession: "check_session",
        dnsResolvers: "dns_resolvers",
        egress: "egress",
        forensicCopy: "forensic_copy",
        ignoreCnameCategoryMatches: "ignore_cname_category_matches",
        insecureDisableDnssecValidation: "insecure_disable_dnssec_validation",
        ipCategories: "ip_categories",
        ipIndicatorFeeds: "ip_indicator_feeds",
        l4override: "l4override",
        notificationSettings: "notification_settings",
        overrideHost: "override_host",
        overrideIps: "override_ips",
        payloadLog: "payload_log",
        quarantine: "quarantine",
        redirect: "redirect",
        resolveDnsInternally: "resolve_dns_internally",
        resolveDnsThroughCloudflare: "resolve_dns_through_cloudflare",
        untrustedCert: "untrusted_cert",
      }),
    ),
  ),
  schedule: Schema.optional(
    Schema.Union([
      Schema.Struct({
        fri: Schema.optional(Schema.String),
        mon: Schema.optional(Schema.String),
        sat: Schema.optional(Schema.String),
        sun: Schema.optional(Schema.String),
        thu: Schema.optional(Schema.String),
        timeZone: Schema.optional(Schema.String),
        tue: Schema.optional(Schema.String),
        wed: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          fri: "fri",
          mon: "mon",
          sat: "sat",
          sun: "sun",
          thu: "thu",
          timeZone: "time_zone",
          tue: "tue",
          wed: "wed",
        }),
      ),
      Schema.Null,
    ]),
  ),
  sharable: Schema.optional(Schema.Boolean),
  sourceAccount: Schema.optional(Schema.String),
  updatedAt: Schema.optional(Schema.String),
  version: Schema.optional(Schema.Number),
  warningStatus: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    action: "action",
    enabled: "enabled",
    filters: "filters",
    name: "name",
    precedence: "precedence",
    traffic: "traffic",
    id: "id",
    createdAt: "created_at",
    deletedAt: "deleted_at",
    description: "description",
    devicePosture: "device_posture",
    expiration: "expiration",
    identity: "identity",
    readOnly: "read_only",
    ruleSettings: "rule_settings",
    schedule: "schedule",
    sharable: "sharable",
    sourceAccount: "source_account",
    updatedAt: "updated_at",
    version: "version",
    warningStatus: "warning_status",
  }),
) as unknown as Schema.Schema<ResetExpirationGatewayRuleResponse>;

export type ResetExpirationGatewayRuleError = CommonErrors;

export const resetExpirationGatewayRule: API.OperationMethod<
  ResetExpirationGatewayRuleRequest,
  ResetExpirationGatewayRuleResponse,
  ResetExpirationGatewayRuleError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ResetExpirationGatewayRuleRequest,
  output: ResetExpirationGatewayRuleResponse,
  errors: [],
}));

// =============================================================================
// Gateway
// =============================================================================

export interface ListGatewaysRequest {
  accountId: string;
}

export const ListGatewaysRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway" }),
) as unknown as Schema.Schema<ListGatewaysRequest>;

export interface ListGatewaysResponse {
  /** Specify the Cloudflare account ID. */
  id?: string;
  /** Specify the gateway internal ID. */
  gatewayTag?: string;
  /** Specify the provider name (usually Cloudflare). */
  providerName?: string;
}

export const ListGatewaysResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  gatewayTag: Schema.optional(Schema.String),
  providerName: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    gatewayTag: "gateway_tag",
    providerName: "provider_name",
  }),
) as unknown as Schema.Schema<ListGatewaysResponse>;

export type ListGatewaysError = CommonErrors;

export const listGateways: API.OperationMethod<
  ListGatewaysRequest,
  ListGatewaysResponse,
  ListGatewaysError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListGatewaysRequest,
  output: ListGatewaysResponse,
  errors: [],
}));

export interface CreateGatewayRequest {
  accountId: string;
}

export const CreateGatewayRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/gateway" }),
) as unknown as Schema.Schema<CreateGatewayRequest>;

export interface CreateGatewayResponse {
  /** Specify the Cloudflare account ID. */
  id?: string;
  /** Specify the gateway internal ID. */
  gatewayTag?: string;
  /** Specify the provider name (usually Cloudflare). */
  providerName?: string;
}

export const CreateGatewayResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  gatewayTag: Schema.optional(Schema.String),
  providerName: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    gatewayTag: "gateway_tag",
    providerName: "provider_name",
  }),
) as unknown as Schema.Schema<CreateGatewayResponse>;

export type CreateGatewayError = CommonErrors;

export const createGateway: API.OperationMethod<
  CreateGatewayRequest,
  CreateGatewayResponse,
  CreateGatewayError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateGatewayRequest,
  output: CreateGatewayResponse,
  errors: [],
}));

// =============================================================================
// GatewayAppType
// =============================================================================

export interface ListGatewayAppTypesRequest {
  /** Provide the identifier string. */
  accountId: string;
}

export const ListGatewayAppTypesRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/app_types" }),
) as unknown as Schema.Schema<ListGatewayAppTypesRequest>;

export type ListGatewayAppTypesResponse = (
  | {
      id?: number;
      applicationTypeId?: number;
      createdAt?: string;
      name?: string;
    }
  | { id?: number; createdAt?: string; description?: string; name?: string }
)[];

export const ListGatewayAppTypesResponse = Schema.Array(
  Schema.Union([
    Schema.Struct({
      id: Schema.optional(Schema.Number),
      applicationTypeId: Schema.optional(Schema.Number),
      createdAt: Schema.optional(Schema.String),
      name: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        applicationTypeId: "application_type_id",
        createdAt: "created_at",
        name: "name",
      }),
    ),
    Schema.Struct({
      id: Schema.optional(Schema.Number),
      createdAt: Schema.optional(Schema.String),
      description: Schema.optional(Schema.String),
      name: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        createdAt: "created_at",
        description: "description",
        name: "name",
      }),
    ),
  ]),
) as unknown as Schema.Schema<ListGatewayAppTypesResponse>;

export type ListGatewayAppTypesError = CommonErrors;

export const listGatewayAppTypes: API.OperationMethod<
  ListGatewayAppTypesRequest,
  ListGatewayAppTypesResponse,
  ListGatewayAppTypesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListGatewayAppTypesRequest,
  output: ListGatewayAppTypesResponse,
  errors: [],
}));

// =============================================================================
// GatewayAuditSshSetting
// =============================================================================

export interface GetGatewayAuditSshSettingRequest {
  accountId: string;
}

export const GetGatewayAuditSshSettingRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/gateway/audit_ssh_settings",
  }),
) as unknown as Schema.Schema<GetGatewayAuditSshSettingRequest>;

export interface GetGatewayAuditSshSettingResponse {
  createdAt?: string;
  /** Provide the Base64-encoded HPKE public key that encrypts SSH session logs. See https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/use-cases/ssh/ssh-infrastructure-access/#en */
  publicKey?: string;
  /** Identify the seed ID. */
  seedId?: string;
  updatedAt?: string;
}

export const GetGatewayAuditSshSettingResponse = Schema.Struct({
  createdAt: Schema.optional(Schema.String),
  publicKey: Schema.optional(Schema.String),
  seedId: Schema.optional(Schema.String),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    createdAt: "created_at",
    publicKey: "public_key",
    seedId: "seed_id",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<GetGatewayAuditSshSettingResponse>;

export type GetGatewayAuditSshSettingError = CommonErrors;

export const getGatewayAuditSshSetting: API.OperationMethod<
  GetGatewayAuditSshSettingRequest,
  GetGatewayAuditSshSettingResponse,
  GetGatewayAuditSshSettingError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetGatewayAuditSshSettingRequest,
  output: GetGatewayAuditSshSettingResponse,
  errors: [],
}));

export interface PutGatewayAuditSshSettingRequest {
  /** Path param: */
  accountId: string;
  /** Body param: Provide the Base64-encoded HPKE public key that encrypts SSH session logs. See https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/use-cases/ssh/ssh-infrastructur */
  publicKey: string;
}

export const PutGatewayAuditSshSettingRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  publicKey: Schema.String,
}).pipe(
  Schema.encodeKeys({ publicKey: "public_key" }),
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/gateway/audit_ssh_settings",
  }),
) as unknown as Schema.Schema<PutGatewayAuditSshSettingRequest>;

export interface PutGatewayAuditSshSettingResponse {
  createdAt?: string;
  /** Provide the Base64-encoded HPKE public key that encrypts SSH session logs. See https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/use-cases/ssh/ssh-infrastructure-access/#en */
  publicKey?: string;
  /** Identify the seed ID. */
  seedId?: string;
  updatedAt?: string;
}

export const PutGatewayAuditSshSettingResponse = Schema.Struct({
  createdAt: Schema.optional(Schema.String),
  publicKey: Schema.optional(Schema.String),
  seedId: Schema.optional(Schema.String),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    createdAt: "created_at",
    publicKey: "public_key",
    seedId: "seed_id",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<PutGatewayAuditSshSettingResponse>;

export type PutGatewayAuditSshSettingError = CommonErrors;

export const putGatewayAuditSshSetting: API.OperationMethod<
  PutGatewayAuditSshSettingRequest,
  PutGatewayAuditSshSettingResponse,
  PutGatewayAuditSshSettingError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutGatewayAuditSshSettingRequest,
  output: PutGatewayAuditSshSettingResponse,
  errors: [],
}));

// =============================================================================
// GatewayCategory
// =============================================================================

export interface ListGatewayCategoriesRequest {
  /** Provide the identifier string. */
  accountId: string;
}

export const ListGatewayCategoriesRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/categories" }),
) as unknown as Schema.Schema<ListGatewayCategoriesRequest>;

export type ListGatewayCategoriesResponse = {
  id?: number;
  beta?: boolean;
  class?: "free" | "premium" | "blocked" | "removalPending" | "noBlock";
  description?: string;
  name?: string;
  subcategories?: {
    id?: number;
    beta?: boolean;
    class?: "free" | "premium" | "blocked" | "removalPending" | "noBlock";
    description?: string;
    name?: string;
  }[];
}[];

export const ListGatewayCategoriesResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.Number),
    beta: Schema.optional(Schema.Boolean),
    class: Schema.optional(
      Schema.Literals([
        "free",
        "premium",
        "blocked",
        "removalPending",
        "noBlock",
      ]),
    ),
    description: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    subcategories: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.Number),
          beta: Schema.optional(Schema.Boolean),
          class: Schema.optional(
            Schema.Literals([
              "free",
              "premium",
              "blocked",
              "removalPending",
              "noBlock",
            ]),
          ),
          description: Schema.optional(Schema.String),
          name: Schema.optional(Schema.String),
        }),
      ),
    ),
  }),
) as unknown as Schema.Schema<ListGatewayCategoriesResponse>;

export type ListGatewayCategoriesError = CommonErrors;

export const listGatewayCategories: API.OperationMethod<
  ListGatewayCategoriesRequest,
  ListGatewayCategoriesResponse,
  ListGatewayCategoriesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListGatewayCategoriesRequest,
  output: ListGatewayCategoriesResponse,
  errors: [],
}));

// =============================================================================
// GatewayCertificate
// =============================================================================

export interface GetGatewayCertificateRequest {
  certificateId: string;
  accountId: string;
}

export const GetGatewayCertificateRequest = Schema.Struct({
  certificateId: Schema.String.pipe(T.HttpPath("certificateId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/gateway/certificates/{certificateId}",
  }),
) as unknown as Schema.Schema<GetGatewayCertificateRequest>;

export interface GetGatewayCertificateResponse {
  /** Identify the certificate with a UUID. */
  id?: string;
  /** Indicate the read-only deployment status of the certificate on Cloudflare's edge. Gateway TLS interception can use certificates in the 'available' (previously called 'active') state. */
  bindingStatus?:
    | "pending_deployment"
    | "available"
    | "pending_deletion"
    | "inactive";
  /** Provide the CA certificate (read-only). */
  certificate?: string;
  createdAt?: string;
  expiresOn?: string;
  /** Provide the SHA256 fingerprint of the certificate (read-only). */
  fingerprint?: string;
  /** Indicate whether Gateway TLS interception uses this certificate (read-only). You cannot set this value directly. To configure interception, use the Gateway configuration setting named `certificate` (r */
  inUse?: boolean;
  /** Indicate the organization that issued the certificate (read-only). */
  issuerOrg?: string;
  /** Provide the entire issuer field of the certificate (read-only). */
  issuerRaw?: string;
  /** Indicate the read-only certificate type, BYO-PKI (custom) or Gateway-managed. */
  type?: "custom" | "gateway_managed";
  updatedAt?: string;
  uploadedOn?: string;
}

export const GetGatewayCertificateResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  bindingStatus: Schema.optional(
    Schema.Literals([
      "pending_deployment",
      "available",
      "pending_deletion",
      "inactive",
    ]),
  ),
  certificate: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  expiresOn: Schema.optional(Schema.String),
  fingerprint: Schema.optional(Schema.String),
  inUse: Schema.optional(Schema.Boolean),
  issuerOrg: Schema.optional(Schema.String),
  issuerRaw: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literals(["custom", "gateway_managed"])),
  updatedAt: Schema.optional(Schema.String),
  uploadedOn: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    bindingStatus: "binding_status",
    certificate: "certificate",
    createdAt: "created_at",
    expiresOn: "expires_on",
    fingerprint: "fingerprint",
    inUse: "in_use",
    issuerOrg: "issuer_org",
    issuerRaw: "issuer_raw",
    type: "type",
    updatedAt: "updated_at",
    uploadedOn: "uploaded_on",
  }),
) as unknown as Schema.Schema<GetGatewayCertificateResponse>;

export type GetGatewayCertificateError = CommonErrors;

export const getGatewayCertificate: API.OperationMethod<
  GetGatewayCertificateRequest,
  GetGatewayCertificateResponse,
  GetGatewayCertificateError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetGatewayCertificateRequest,
  output: GetGatewayCertificateResponse,
  errors: [],
}));

export interface ListGatewayCertificatesRequest {
  accountId: string;
}

export const ListGatewayCertificatesRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/gateway/certificates",
  }),
) as unknown as Schema.Schema<ListGatewayCertificatesRequest>;

export type ListGatewayCertificatesResponse = {
  id?: string;
  bindingStatus?:
    | "pending_deployment"
    | "available"
    | "pending_deletion"
    | "inactive";
  certificate?: string;
  createdAt?: string;
  expiresOn?: string;
  fingerprint?: string;
  inUse?: boolean;
  issuerOrg?: string;
  issuerRaw?: string;
  type?: "custom" | "gateway_managed";
  updatedAt?: string;
  uploadedOn?: string;
}[];

export const ListGatewayCertificatesResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    bindingStatus: Schema.optional(
      Schema.Literals([
        "pending_deployment",
        "available",
        "pending_deletion",
        "inactive",
      ]),
    ),
    certificate: Schema.optional(Schema.String),
    createdAt: Schema.optional(Schema.String),
    expiresOn: Schema.optional(Schema.String),
    fingerprint: Schema.optional(Schema.String),
    inUse: Schema.optional(Schema.Boolean),
    issuerOrg: Schema.optional(Schema.String),
    issuerRaw: Schema.optional(Schema.String),
    type: Schema.optional(Schema.Literals(["custom", "gateway_managed"])),
    updatedAt: Schema.optional(Schema.String),
    uploadedOn: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      bindingStatus: "binding_status",
      certificate: "certificate",
      createdAt: "created_at",
      expiresOn: "expires_on",
      fingerprint: "fingerprint",
      inUse: "in_use",
      issuerOrg: "issuer_org",
      issuerRaw: "issuer_raw",
      type: "type",
      updatedAt: "updated_at",
      uploadedOn: "uploaded_on",
    }),
  ),
) as unknown as Schema.Schema<ListGatewayCertificatesResponse>;

export type ListGatewayCertificatesError = CommonErrors;

export const listGatewayCertificates: API.OperationMethod<
  ListGatewayCertificatesRequest,
  ListGatewayCertificatesResponse,
  ListGatewayCertificatesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListGatewayCertificatesRequest,
  output: ListGatewayCertificatesResponse,
  errors: [],
}));

export interface CreateGatewayCertificateRequest {
  /** Path param: */
  accountId: string;
  /** Body param: Sets the certificate validity period in days (range: 1-10,950 days / ~30 years). Defaults to 1,825 days (5 years).  Important  : This field is only settable during the certificate creation */
  validityPeriodDays?: number;
}

export const CreateGatewayCertificateRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  validityPeriodDays: Schema.optional(Schema.Number),
}).pipe(
  Schema.encodeKeys({ validityPeriodDays: "validity_period_days" }),
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/gateway/certificates",
  }),
) as unknown as Schema.Schema<CreateGatewayCertificateRequest>;

export interface CreateGatewayCertificateResponse {
  /** Identify the certificate with a UUID. */
  id?: string;
  /** Indicate the read-only deployment status of the certificate on Cloudflare's edge. Gateway TLS interception can use certificates in the 'available' (previously called 'active') state. */
  bindingStatus?:
    | "pending_deployment"
    | "available"
    | "pending_deletion"
    | "inactive";
  /** Provide the CA certificate (read-only). */
  certificate?: string;
  createdAt?: string;
  expiresOn?: string;
  /** Provide the SHA256 fingerprint of the certificate (read-only). */
  fingerprint?: string;
  /** Indicate whether Gateway TLS interception uses this certificate (read-only). You cannot set this value directly. To configure interception, use the Gateway configuration setting named `certificate` (r */
  inUse?: boolean;
  /** Indicate the organization that issued the certificate (read-only). */
  issuerOrg?: string;
  /** Provide the entire issuer field of the certificate (read-only). */
  issuerRaw?: string;
  /** Indicate the read-only certificate type, BYO-PKI (custom) or Gateway-managed. */
  type?: "custom" | "gateway_managed";
  updatedAt?: string;
  uploadedOn?: string;
}

export const CreateGatewayCertificateResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  bindingStatus: Schema.optional(
    Schema.Literals([
      "pending_deployment",
      "available",
      "pending_deletion",
      "inactive",
    ]),
  ),
  certificate: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  expiresOn: Schema.optional(Schema.String),
  fingerprint: Schema.optional(Schema.String),
  inUse: Schema.optional(Schema.Boolean),
  issuerOrg: Schema.optional(Schema.String),
  issuerRaw: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literals(["custom", "gateway_managed"])),
  updatedAt: Schema.optional(Schema.String),
  uploadedOn: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    bindingStatus: "binding_status",
    certificate: "certificate",
    createdAt: "created_at",
    expiresOn: "expires_on",
    fingerprint: "fingerprint",
    inUse: "in_use",
    issuerOrg: "issuer_org",
    issuerRaw: "issuer_raw",
    type: "type",
    updatedAt: "updated_at",
    uploadedOn: "uploaded_on",
  }),
) as unknown as Schema.Schema<CreateGatewayCertificateResponse>;

export type CreateGatewayCertificateError = CommonErrors;

export const createGatewayCertificate: API.OperationMethod<
  CreateGatewayCertificateRequest,
  CreateGatewayCertificateResponse,
  CreateGatewayCertificateError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateGatewayCertificateRequest,
  output: CreateGatewayCertificateResponse,
  errors: [],
}));

export interface DeleteGatewayCertificateRequest {
  certificateId: string;
  accountId: string;
}

export const DeleteGatewayCertificateRequest = Schema.Struct({
  certificateId: Schema.String.pipe(T.HttpPath("certificateId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/gateway/certificates/{certificateId}",
  }),
) as unknown as Schema.Schema<DeleteGatewayCertificateRequest>;

export interface DeleteGatewayCertificateResponse {
  /** Identify the certificate with a UUID. */
  id?: string;
  /** Indicate the read-only deployment status of the certificate on Cloudflare's edge. Gateway TLS interception can use certificates in the 'available' (previously called 'active') state. */
  bindingStatus?:
    | "pending_deployment"
    | "available"
    | "pending_deletion"
    | "inactive";
  /** Provide the CA certificate (read-only). */
  certificate?: string;
  createdAt?: string;
  expiresOn?: string;
  /** Provide the SHA256 fingerprint of the certificate (read-only). */
  fingerprint?: string;
  /** Indicate whether Gateway TLS interception uses this certificate (read-only). You cannot set this value directly. To configure interception, use the Gateway configuration setting named `certificate` (r */
  inUse?: boolean;
  /** Indicate the organization that issued the certificate (read-only). */
  issuerOrg?: string;
  /** Provide the entire issuer field of the certificate (read-only). */
  issuerRaw?: string;
  /** Indicate the read-only certificate type, BYO-PKI (custom) or Gateway-managed. */
  type?: "custom" | "gateway_managed";
  updatedAt?: string;
  uploadedOn?: string;
}

export const DeleteGatewayCertificateResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  bindingStatus: Schema.optional(
    Schema.Literals([
      "pending_deployment",
      "available",
      "pending_deletion",
      "inactive",
    ]),
  ),
  certificate: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  expiresOn: Schema.optional(Schema.String),
  fingerprint: Schema.optional(Schema.String),
  inUse: Schema.optional(Schema.Boolean),
  issuerOrg: Schema.optional(Schema.String),
  issuerRaw: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literals(["custom", "gateway_managed"])),
  updatedAt: Schema.optional(Schema.String),
  uploadedOn: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    bindingStatus: "binding_status",
    certificate: "certificate",
    createdAt: "created_at",
    expiresOn: "expires_on",
    fingerprint: "fingerprint",
    inUse: "in_use",
    issuerOrg: "issuer_org",
    issuerRaw: "issuer_raw",
    type: "type",
    updatedAt: "updated_at",
    uploadedOn: "uploaded_on",
  }),
) as unknown as Schema.Schema<DeleteGatewayCertificateResponse>;

export type DeleteGatewayCertificateError = CommonErrors;

export const deleteGatewayCertificate: API.OperationMethod<
  DeleteGatewayCertificateRequest,
  DeleteGatewayCertificateResponse,
  DeleteGatewayCertificateError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteGatewayCertificateRequest,
  output: DeleteGatewayCertificateResponse,
  errors: [],
}));

export interface ActivateGatewayCertificateRequest {
  certificateId: string;
  /** Path param: */
  accountId: string;
  /** Body param: */
  body: unknown;
}

export const ActivateGatewayCertificateRequest = Schema.Struct({
  certificateId: Schema.String.pipe(T.HttpPath("certificateId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody()),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/gateway/certificates/{certificateId}/activate",
  }),
) as unknown as Schema.Schema<ActivateGatewayCertificateRequest>;

export interface ActivateGatewayCertificateResponse {
  /** Identify the certificate with a UUID. */
  id?: string;
  /** Indicate the read-only deployment status of the certificate on Cloudflare's edge. Gateway TLS interception can use certificates in the 'available' (previously called 'active') state. */
  bindingStatus?:
    | "pending_deployment"
    | "available"
    | "pending_deletion"
    | "inactive";
  /** Provide the CA certificate (read-only). */
  certificate?: string;
  createdAt?: string;
  expiresOn?: string;
  /** Provide the SHA256 fingerprint of the certificate (read-only). */
  fingerprint?: string;
  /** Indicate whether Gateway TLS interception uses this certificate (read-only). You cannot set this value directly. To configure interception, use the Gateway configuration setting named `certificate` (r */
  inUse?: boolean;
  /** Indicate the organization that issued the certificate (read-only). */
  issuerOrg?: string;
  /** Provide the entire issuer field of the certificate (read-only). */
  issuerRaw?: string;
  /** Indicate the read-only certificate type, BYO-PKI (custom) or Gateway-managed. */
  type?: "custom" | "gateway_managed";
  updatedAt?: string;
  uploadedOn?: string;
}

export const ActivateGatewayCertificateResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  bindingStatus: Schema.optional(
    Schema.Literals([
      "pending_deployment",
      "available",
      "pending_deletion",
      "inactive",
    ]),
  ),
  certificate: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  expiresOn: Schema.optional(Schema.String),
  fingerprint: Schema.optional(Schema.String),
  inUse: Schema.optional(Schema.Boolean),
  issuerOrg: Schema.optional(Schema.String),
  issuerRaw: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literals(["custom", "gateway_managed"])),
  updatedAt: Schema.optional(Schema.String),
  uploadedOn: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    bindingStatus: "binding_status",
    certificate: "certificate",
    createdAt: "created_at",
    expiresOn: "expires_on",
    fingerprint: "fingerprint",
    inUse: "in_use",
    issuerOrg: "issuer_org",
    issuerRaw: "issuer_raw",
    type: "type",
    updatedAt: "updated_at",
    uploadedOn: "uploaded_on",
  }),
) as unknown as Schema.Schema<ActivateGatewayCertificateResponse>;

export type ActivateGatewayCertificateError = CommonErrors;

export const activateGatewayCertificate: API.OperationMethod<
  ActivateGatewayCertificateRequest,
  ActivateGatewayCertificateResponse,
  ActivateGatewayCertificateError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ActivateGatewayCertificateRequest,
  output: ActivateGatewayCertificateResponse,
  errors: [],
}));

export interface DeactivateGatewayCertificateRequest {
  certificateId: string;
  /** Path param: */
  accountId: string;
  /** Body param: */
  body: unknown;
}

export const DeactivateGatewayCertificateRequest = Schema.Struct({
  certificateId: Schema.String.pipe(T.HttpPath("certificateId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Unknown.pipe(T.HttpBody()),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/gateway/certificates/{certificateId}/deactivate",
  }),
) as unknown as Schema.Schema<DeactivateGatewayCertificateRequest>;

export interface DeactivateGatewayCertificateResponse {
  /** Identify the certificate with a UUID. */
  id?: string;
  /** Indicate the read-only deployment status of the certificate on Cloudflare's edge. Gateway TLS interception can use certificates in the 'available' (previously called 'active') state. */
  bindingStatus?:
    | "pending_deployment"
    | "available"
    | "pending_deletion"
    | "inactive";
  /** Provide the CA certificate (read-only). */
  certificate?: string;
  createdAt?: string;
  expiresOn?: string;
  /** Provide the SHA256 fingerprint of the certificate (read-only). */
  fingerprint?: string;
  /** Indicate whether Gateway TLS interception uses this certificate (read-only). You cannot set this value directly. To configure interception, use the Gateway configuration setting named `certificate` (r */
  inUse?: boolean;
  /** Indicate the organization that issued the certificate (read-only). */
  issuerOrg?: string;
  /** Provide the entire issuer field of the certificate (read-only). */
  issuerRaw?: string;
  /** Indicate the read-only certificate type, BYO-PKI (custom) or Gateway-managed. */
  type?: "custom" | "gateway_managed";
  updatedAt?: string;
  uploadedOn?: string;
}

export const DeactivateGatewayCertificateResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  bindingStatus: Schema.optional(
    Schema.Literals([
      "pending_deployment",
      "available",
      "pending_deletion",
      "inactive",
    ]),
  ),
  certificate: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  expiresOn: Schema.optional(Schema.String),
  fingerprint: Schema.optional(Schema.String),
  inUse: Schema.optional(Schema.Boolean),
  issuerOrg: Schema.optional(Schema.String),
  issuerRaw: Schema.optional(Schema.String),
  type: Schema.optional(Schema.Literals(["custom", "gateway_managed"])),
  updatedAt: Schema.optional(Schema.String),
  uploadedOn: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    bindingStatus: "binding_status",
    certificate: "certificate",
    createdAt: "created_at",
    expiresOn: "expires_on",
    fingerprint: "fingerprint",
    inUse: "in_use",
    issuerOrg: "issuer_org",
    issuerRaw: "issuer_raw",
    type: "type",
    updatedAt: "updated_at",
    uploadedOn: "uploaded_on",
  }),
) as unknown as Schema.Schema<DeactivateGatewayCertificateResponse>;

export type DeactivateGatewayCertificateError = CommonErrors;

export const deactivateGatewayCertificate: API.OperationMethod<
  DeactivateGatewayCertificateRequest,
  DeactivateGatewayCertificateResponse,
  DeactivateGatewayCertificateError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeactivateGatewayCertificateRequest,
  output: DeactivateGatewayCertificateResponse,
  errors: [],
}));

// =============================================================================
// GatewayConfiguration
// =============================================================================

export interface GetGatewayConfigurationRequest {
  accountId: string;
}

export const GetGatewayConfigurationRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/gateway/configuration",
  }),
) as unknown as Schema.Schema<GetGatewayConfigurationRequest>;

export interface GetGatewayConfigurationResponse {
  createdAt?: string;
  /** Specify account settings. */
  settings?: {
    activityLog?: { enabled?: boolean | null } | null;
    antivirus?: {
      enabledDownloadPhase?: boolean | null;
      enabledUploadPhase?: boolean | null;
      failClosed?: boolean | null;
      notificationSettings?: {
        enabled?: boolean;
        includeContext?: boolean;
        msg?: string;
        supportUrl?: string;
      } | null;
    } | null;
    blockPage?: {
      backgroundColor?: string;
      enabled?: boolean | null;
      footerText?: string;
      headerText?: string;
      includeContext?: boolean;
      logoPath?: string;
      mailtoAddress?: string;
      mailtoSubject?: string;
      mode?: "" | "customized_block_page" | "redirect_uri";
      name?: string;
      readOnly?: boolean | null;
      sourceAccount?: string | null;
      suppressFooter?: boolean;
      targetUri?: string;
      version?: number | null;
    } | null;
    bodyScanning?: { inspectionMode?: "deep" | "shallow" } | null;
    browserIsolation?: {
      nonIdentityEnabled?: boolean;
      urlBrowserIsolationEnabled?: boolean;
    } | null;
    certificate?: { id: string } | null;
    customCertificate?: {
      enabled: boolean | null;
      id?: string;
      bindingStatus?: string;
      updatedAt?: string;
    } | null;
    extendedEmailMatching?: {
      enabled?: boolean | null;
      readOnly?: boolean;
      sourceAccount?: string;
      version?: number;
    } | null;
    fips?: { tls?: boolean } | null;
    hostSelector?: { enabled?: boolean | null } | null;
    inspection?: { mode?: "static" | "dynamic" } | null;
    protocolDetection?: { enabled?: boolean | null } | null;
    sandbox?: {
      enabled?: boolean | null;
      fallbackAction?: "allow" | "block";
    } | null;
    tlsDecrypt?: { enabled?: boolean } | null;
  };
  updatedAt?: string;
}

export const GetGatewayConfigurationResponse = Schema.Struct({
  createdAt: Schema.optional(Schema.String),
  settings: Schema.optional(
    Schema.Struct({
      activityLog: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
          }),
          Schema.Null,
        ]),
      ),
      antivirus: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabledDownloadPhase: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            enabledUploadPhase: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            failClosed: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            notificationSettings: Schema.optional(
              Schema.Union([
                Schema.Struct({
                  enabled: Schema.optional(Schema.Boolean),
                  includeContext: Schema.optional(Schema.Boolean),
                  msg: Schema.optional(Schema.String),
                  supportUrl: Schema.optional(Schema.String),
                }).pipe(
                  Schema.encodeKeys({
                    enabled: "enabled",
                    includeContext: "include_context",
                    msg: "msg",
                    supportUrl: "support_url",
                  }),
                ),
                Schema.Null,
              ]),
            ),
          }).pipe(
            Schema.encodeKeys({
              enabledDownloadPhase: "enabled_download_phase",
              enabledUploadPhase: "enabled_upload_phase",
              failClosed: "fail_closed",
              notificationSettings: "notification_settings",
            }),
          ),
          Schema.Null,
        ]),
      ),
      blockPage: Schema.optional(
        Schema.Union([
          Schema.Struct({
            backgroundColor: Schema.optional(Schema.String),
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            footerText: Schema.optional(Schema.String),
            headerText: Schema.optional(Schema.String),
            includeContext: Schema.optional(Schema.Boolean),
            logoPath: Schema.optional(Schema.String),
            mailtoAddress: Schema.optional(Schema.String),
            mailtoSubject: Schema.optional(Schema.String),
            mode: Schema.optional(
              Schema.Literals(["", "customized_block_page", "redirect_uri"]),
            ),
            name: Schema.optional(Schema.String),
            readOnly: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            sourceAccount: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            suppressFooter: Schema.optional(Schema.Boolean),
            targetUri: Schema.optional(Schema.String),
            version: Schema.optional(
              Schema.Union([Schema.Number, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              backgroundColor: "background_color",
              enabled: "enabled",
              footerText: "footer_text",
              headerText: "header_text",
              includeContext: "include_context",
              logoPath: "logo_path",
              mailtoAddress: "mailto_address",
              mailtoSubject: "mailto_subject",
              mode: "mode",
              name: "name",
              readOnly: "read_only",
              sourceAccount: "source_account",
              suppressFooter: "suppress_footer",
              targetUri: "target_uri",
              version: "version",
            }),
          ),
          Schema.Null,
        ]),
      ),
      bodyScanning: Schema.optional(
        Schema.Union([
          Schema.Struct({
            inspectionMode: Schema.optional(
              Schema.Literals(["deep", "shallow"]),
            ),
          }).pipe(Schema.encodeKeys({ inspectionMode: "inspection_mode" })),
          Schema.Null,
        ]),
      ),
      browserIsolation: Schema.optional(
        Schema.Union([
          Schema.Struct({
            nonIdentityEnabled: Schema.optional(Schema.Boolean),
            urlBrowserIsolationEnabled: Schema.optional(Schema.Boolean),
          }).pipe(
            Schema.encodeKeys({
              nonIdentityEnabled: "non_identity_enabled",
              urlBrowserIsolationEnabled: "url_browser_isolation_enabled",
            }),
          ),
          Schema.Null,
        ]),
      ),
      certificate: Schema.optional(
        Schema.Union([
          Schema.Struct({
            id: Schema.String,
          }),
          Schema.Null,
        ]),
      ),
      customCertificate: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.Union([Schema.Boolean, Schema.Null]),
            id: Schema.optional(Schema.String),
            bindingStatus: Schema.optional(Schema.String),
            updatedAt: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              id: "id",
              bindingStatus: "binding_status",
              updatedAt: "updated_at",
            }),
          ),
          Schema.Null,
        ]),
      ),
      extendedEmailMatching: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            readOnly: Schema.optional(Schema.Boolean),
            sourceAccount: Schema.optional(Schema.String),
            version: Schema.optional(Schema.Number),
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              readOnly: "read_only",
              sourceAccount: "source_account",
              version: "version",
            }),
          ),
          Schema.Null,
        ]),
      ),
      fips: Schema.optional(
        Schema.Union([
          Schema.Struct({
            tls: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      hostSelector: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
          }),
          Schema.Null,
        ]),
      ),
      inspection: Schema.optional(
        Schema.Union([
          Schema.Struct({
            mode: Schema.optional(Schema.Literals(["static", "dynamic"])),
          }),
          Schema.Null,
        ]),
      ),
      protocolDetection: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
          }),
          Schema.Null,
        ]),
      ),
      sandbox: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            fallbackAction: Schema.optional(
              Schema.Literals(["allow", "block"]),
            ),
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              fallbackAction: "fallback_action",
            }),
          ),
          Schema.Null,
        ]),
      ),
      tlsDecrypt: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        activityLog: "activity_log",
        antivirus: "antivirus",
        blockPage: "block_page",
        bodyScanning: "body_scanning",
        browserIsolation: "browser_isolation",
        certificate: "certificate",
        customCertificate: "custom_certificate",
        extendedEmailMatching: "extended_email_matching",
        fips: "fips",
        hostSelector: "host_selector",
        inspection: "inspection",
        protocolDetection: "protocol_detection",
        sandbox: "sandbox",
        tlsDecrypt: "tls_decrypt",
      }),
    ),
  ),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    createdAt: "created_at",
    settings: "settings",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<GetGatewayConfigurationResponse>;

export type GetGatewayConfigurationError = CommonErrors;

export const getGatewayConfiguration: API.OperationMethod<
  GetGatewayConfigurationRequest,
  GetGatewayConfigurationResponse,
  GetGatewayConfigurationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetGatewayConfigurationRequest,
  output: GetGatewayConfigurationResponse,
  errors: [],
}));

export interface PutGatewayConfigurationRequest {
  /** Path param: */
  accountId: string;
  /** Body param: Specify account settings. */
  settings?: {
    activityLog?: { enabled?: boolean | null } | null;
    antivirus?: {
      enabledDownloadPhase?: boolean | null;
      enabledUploadPhase?: boolean | null;
      failClosed?: boolean | null;
      notificationSettings?: {
        enabled?: boolean;
        includeContext?: boolean;
        msg?: string;
        supportUrl?: string;
      } | null;
    } | null;
    blockPage?: {
      backgroundColor?: string;
      enabled?: boolean | null;
      footerText?: string;
      headerText?: string;
      includeContext?: boolean;
      logoPath?: string;
      mailtoAddress?: string;
      mailtoSubject?: string;
      mode?: "" | "customized_block_page" | "redirect_uri";
      name?: string;
      suppressFooter?: boolean;
      targetUri?: string;
    } | null;
    bodyScanning?: { inspectionMode?: "deep" | "shallow" } | null;
    browserIsolation?: {
      nonIdentityEnabled?: boolean;
      urlBrowserIsolationEnabled?: boolean;
    } | null;
    certificate?: { id: string } | null;
    customCertificate?: { enabled: boolean | null; id?: string } | null;
    extendedEmailMatching?: { enabled?: boolean | null } | null;
    fips?: { tls?: boolean } | null;
    hostSelector?: { enabled?: boolean | null } | null;
    inspection?: { mode?: "static" | "dynamic" } | null;
    protocolDetection?: { enabled?: boolean | null } | null;
    sandbox?: {
      enabled?: boolean | null;
      fallbackAction?: "allow" | "block";
    } | null;
    tlsDecrypt?: { enabled?: boolean } | null;
  };
}

export const PutGatewayConfigurationRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  settings: Schema.optional(
    Schema.Struct({
      activityLog: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
          }),
          Schema.Null,
        ]),
      ),
      antivirus: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabledDownloadPhase: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            enabledUploadPhase: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            failClosed: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            notificationSettings: Schema.optional(
              Schema.Union([
                Schema.Struct({
                  enabled: Schema.optional(Schema.Boolean),
                  includeContext: Schema.optional(Schema.Boolean),
                  msg: Schema.optional(Schema.String),
                  supportUrl: Schema.optional(Schema.String),
                }).pipe(
                  Schema.encodeKeys({
                    enabled: "enabled",
                    includeContext: "include_context",
                    msg: "msg",
                    supportUrl: "support_url",
                  }),
                ),
                Schema.Null,
              ]),
            ),
          }).pipe(
            Schema.encodeKeys({
              enabledDownloadPhase: "enabled_download_phase",
              enabledUploadPhase: "enabled_upload_phase",
              failClosed: "fail_closed",
              notificationSettings: "notification_settings",
            }),
          ),
          Schema.Null,
        ]),
      ),
      blockPage: Schema.optional(
        Schema.Union([
          Schema.Struct({
            backgroundColor: Schema.optional(Schema.String),
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            footerText: Schema.optional(Schema.String),
            headerText: Schema.optional(Schema.String),
            includeContext: Schema.optional(Schema.Boolean),
            logoPath: Schema.optional(Schema.String),
            mailtoAddress: Schema.optional(Schema.String),
            mailtoSubject: Schema.optional(Schema.String),
            mode: Schema.optional(
              Schema.Literals(["", "customized_block_page", "redirect_uri"]),
            ),
            name: Schema.optional(Schema.String),
            suppressFooter: Schema.optional(Schema.Boolean),
            targetUri: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              backgroundColor: "background_color",
              enabled: "enabled",
              footerText: "footer_text",
              headerText: "header_text",
              includeContext: "include_context",
              logoPath: "logo_path",
              mailtoAddress: "mailto_address",
              mailtoSubject: "mailto_subject",
              mode: "mode",
              name: "name",
              suppressFooter: "suppress_footer",
              targetUri: "target_uri",
            }),
          ),
          Schema.Null,
        ]),
      ),
      bodyScanning: Schema.optional(
        Schema.Union([
          Schema.Struct({
            inspectionMode: Schema.optional(
              Schema.Literals(["deep", "shallow"]),
            ),
          }).pipe(Schema.encodeKeys({ inspectionMode: "inspection_mode" })),
          Schema.Null,
        ]),
      ),
      browserIsolation: Schema.optional(
        Schema.Union([
          Schema.Struct({
            nonIdentityEnabled: Schema.optional(Schema.Boolean),
            urlBrowserIsolationEnabled: Schema.optional(Schema.Boolean),
          }).pipe(
            Schema.encodeKeys({
              nonIdentityEnabled: "non_identity_enabled",
              urlBrowserIsolationEnabled: "url_browser_isolation_enabled",
            }),
          ),
          Schema.Null,
        ]),
      ),
      certificate: Schema.optional(
        Schema.Union([
          Schema.Struct({
            id: Schema.String,
          }),
          Schema.Null,
        ]),
      ),
      customCertificate: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.Union([Schema.Boolean, Schema.Null]),
            id: Schema.optional(Schema.String),
          }),
          Schema.Null,
        ]),
      ),
      extendedEmailMatching: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
          }),
          Schema.Null,
        ]),
      ),
      fips: Schema.optional(
        Schema.Union([
          Schema.Struct({
            tls: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      hostSelector: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
          }),
          Schema.Null,
        ]),
      ),
      inspection: Schema.optional(
        Schema.Union([
          Schema.Struct({
            mode: Schema.optional(Schema.Literals(["static", "dynamic"])),
          }),
          Schema.Null,
        ]),
      ),
      protocolDetection: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
          }),
          Schema.Null,
        ]),
      ),
      sandbox: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            fallbackAction: Schema.optional(
              Schema.Literals(["allow", "block"]),
            ),
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              fallbackAction: "fallback_action",
            }),
          ),
          Schema.Null,
        ]),
      ),
      tlsDecrypt: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        activityLog: "activity_log",
        antivirus: "antivirus",
        blockPage: "block_page",
        bodyScanning: "body_scanning",
        browserIsolation: "browser_isolation",
        certificate: "certificate",
        customCertificate: "custom_certificate",
        extendedEmailMatching: "extended_email_matching",
        fips: "fips",
        hostSelector: "host_selector",
        inspection: "inspection",
        protocolDetection: "protocol_detection",
        sandbox: "sandbox",
        tlsDecrypt: "tls_decrypt",
      }),
    ),
  ),
}).pipe(
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/gateway/configuration",
  }),
) as unknown as Schema.Schema<PutGatewayConfigurationRequest>;

export interface PutGatewayConfigurationResponse {
  createdAt?: string;
  /** Specify account settings. */
  settings?: {
    activityLog?: { enabled?: boolean | null } | null;
    antivirus?: {
      enabledDownloadPhase?: boolean | null;
      enabledUploadPhase?: boolean | null;
      failClosed?: boolean | null;
      notificationSettings?: {
        enabled?: boolean;
        includeContext?: boolean;
        msg?: string;
        supportUrl?: string;
      } | null;
    } | null;
    blockPage?: {
      backgroundColor?: string;
      enabled?: boolean | null;
      footerText?: string;
      headerText?: string;
      includeContext?: boolean;
      logoPath?: string;
      mailtoAddress?: string;
      mailtoSubject?: string;
      mode?: "" | "customized_block_page" | "redirect_uri";
      name?: string;
      readOnly?: boolean | null;
      sourceAccount?: string | null;
      suppressFooter?: boolean;
      targetUri?: string;
      version?: number | null;
    } | null;
    bodyScanning?: { inspectionMode?: "deep" | "shallow" } | null;
    browserIsolation?: {
      nonIdentityEnabled?: boolean;
      urlBrowserIsolationEnabled?: boolean;
    } | null;
    certificate?: { id: string } | null;
    customCertificate?: {
      enabled: boolean | null;
      id?: string;
      bindingStatus?: string;
      updatedAt?: string;
    } | null;
    extendedEmailMatching?: {
      enabled?: boolean | null;
      readOnly?: boolean;
      sourceAccount?: string;
      version?: number;
    } | null;
    fips?: { tls?: boolean } | null;
    hostSelector?: { enabled?: boolean | null } | null;
    inspection?: { mode?: "static" | "dynamic" } | null;
    protocolDetection?: { enabled?: boolean | null } | null;
    sandbox?: {
      enabled?: boolean | null;
      fallbackAction?: "allow" | "block";
    } | null;
    tlsDecrypt?: { enabled?: boolean } | null;
  };
  updatedAt?: string;
}

export const PutGatewayConfigurationResponse = Schema.Struct({
  createdAt: Schema.optional(Schema.String),
  settings: Schema.optional(
    Schema.Struct({
      activityLog: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
          }),
          Schema.Null,
        ]),
      ),
      antivirus: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabledDownloadPhase: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            enabledUploadPhase: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            failClosed: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            notificationSettings: Schema.optional(
              Schema.Union([
                Schema.Struct({
                  enabled: Schema.optional(Schema.Boolean),
                  includeContext: Schema.optional(Schema.Boolean),
                  msg: Schema.optional(Schema.String),
                  supportUrl: Schema.optional(Schema.String),
                }).pipe(
                  Schema.encodeKeys({
                    enabled: "enabled",
                    includeContext: "include_context",
                    msg: "msg",
                    supportUrl: "support_url",
                  }),
                ),
                Schema.Null,
              ]),
            ),
          }).pipe(
            Schema.encodeKeys({
              enabledDownloadPhase: "enabled_download_phase",
              enabledUploadPhase: "enabled_upload_phase",
              failClosed: "fail_closed",
              notificationSettings: "notification_settings",
            }),
          ),
          Schema.Null,
        ]),
      ),
      blockPage: Schema.optional(
        Schema.Union([
          Schema.Struct({
            backgroundColor: Schema.optional(Schema.String),
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            footerText: Schema.optional(Schema.String),
            headerText: Schema.optional(Schema.String),
            includeContext: Schema.optional(Schema.Boolean),
            logoPath: Schema.optional(Schema.String),
            mailtoAddress: Schema.optional(Schema.String),
            mailtoSubject: Schema.optional(Schema.String),
            mode: Schema.optional(
              Schema.Literals(["", "customized_block_page", "redirect_uri"]),
            ),
            name: Schema.optional(Schema.String),
            readOnly: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            sourceAccount: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            suppressFooter: Schema.optional(Schema.Boolean),
            targetUri: Schema.optional(Schema.String),
            version: Schema.optional(
              Schema.Union([Schema.Number, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              backgroundColor: "background_color",
              enabled: "enabled",
              footerText: "footer_text",
              headerText: "header_text",
              includeContext: "include_context",
              logoPath: "logo_path",
              mailtoAddress: "mailto_address",
              mailtoSubject: "mailto_subject",
              mode: "mode",
              name: "name",
              readOnly: "read_only",
              sourceAccount: "source_account",
              suppressFooter: "suppress_footer",
              targetUri: "target_uri",
              version: "version",
            }),
          ),
          Schema.Null,
        ]),
      ),
      bodyScanning: Schema.optional(
        Schema.Union([
          Schema.Struct({
            inspectionMode: Schema.optional(
              Schema.Literals(["deep", "shallow"]),
            ),
          }).pipe(Schema.encodeKeys({ inspectionMode: "inspection_mode" })),
          Schema.Null,
        ]),
      ),
      browserIsolation: Schema.optional(
        Schema.Union([
          Schema.Struct({
            nonIdentityEnabled: Schema.optional(Schema.Boolean),
            urlBrowserIsolationEnabled: Schema.optional(Schema.Boolean),
          }).pipe(
            Schema.encodeKeys({
              nonIdentityEnabled: "non_identity_enabled",
              urlBrowserIsolationEnabled: "url_browser_isolation_enabled",
            }),
          ),
          Schema.Null,
        ]),
      ),
      certificate: Schema.optional(
        Schema.Union([
          Schema.Struct({
            id: Schema.String,
          }),
          Schema.Null,
        ]),
      ),
      customCertificate: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.Union([Schema.Boolean, Schema.Null]),
            id: Schema.optional(Schema.String),
            bindingStatus: Schema.optional(Schema.String),
            updatedAt: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              id: "id",
              bindingStatus: "binding_status",
              updatedAt: "updated_at",
            }),
          ),
          Schema.Null,
        ]),
      ),
      extendedEmailMatching: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            readOnly: Schema.optional(Schema.Boolean),
            sourceAccount: Schema.optional(Schema.String),
            version: Schema.optional(Schema.Number),
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              readOnly: "read_only",
              sourceAccount: "source_account",
              version: "version",
            }),
          ),
          Schema.Null,
        ]),
      ),
      fips: Schema.optional(
        Schema.Union([
          Schema.Struct({
            tls: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      hostSelector: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
          }),
          Schema.Null,
        ]),
      ),
      inspection: Schema.optional(
        Schema.Union([
          Schema.Struct({
            mode: Schema.optional(Schema.Literals(["static", "dynamic"])),
          }),
          Schema.Null,
        ]),
      ),
      protocolDetection: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
          }),
          Schema.Null,
        ]),
      ),
      sandbox: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            fallbackAction: Schema.optional(
              Schema.Literals(["allow", "block"]),
            ),
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              fallbackAction: "fallback_action",
            }),
          ),
          Schema.Null,
        ]),
      ),
      tlsDecrypt: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        activityLog: "activity_log",
        antivirus: "antivirus",
        blockPage: "block_page",
        bodyScanning: "body_scanning",
        browserIsolation: "browser_isolation",
        certificate: "certificate",
        customCertificate: "custom_certificate",
        extendedEmailMatching: "extended_email_matching",
        fips: "fips",
        hostSelector: "host_selector",
        inspection: "inspection",
        protocolDetection: "protocol_detection",
        sandbox: "sandbox",
        tlsDecrypt: "tls_decrypt",
      }),
    ),
  ),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    createdAt: "created_at",
    settings: "settings",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<PutGatewayConfigurationResponse>;

export type PutGatewayConfigurationError = CommonErrors;

export const putGatewayConfiguration: API.OperationMethod<
  PutGatewayConfigurationRequest,
  PutGatewayConfigurationResponse,
  PutGatewayConfigurationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutGatewayConfigurationRequest,
  output: PutGatewayConfigurationResponse,
  errors: [],
}));

export interface PatchGatewayConfigurationRequest {
  /** Path param: */
  accountId: string;
  /** Body param: Specify account settings. */
  settings?: {
    activityLog?: { enabled?: boolean | null } | null;
    antivirus?: {
      enabledDownloadPhase?: boolean | null;
      enabledUploadPhase?: boolean | null;
      failClosed?: boolean | null;
      notificationSettings?: {
        enabled?: boolean;
        includeContext?: boolean;
        msg?: string;
        supportUrl?: string;
      } | null;
    } | null;
    blockPage?: {
      backgroundColor?: string;
      enabled?: boolean | null;
      footerText?: string;
      headerText?: string;
      includeContext?: boolean;
      logoPath?: string;
      mailtoAddress?: string;
      mailtoSubject?: string;
      mode?: "" | "customized_block_page" | "redirect_uri";
      name?: string;
      suppressFooter?: boolean;
      targetUri?: string;
    } | null;
    bodyScanning?: { inspectionMode?: "deep" | "shallow" } | null;
    browserIsolation?: {
      nonIdentityEnabled?: boolean;
      urlBrowserIsolationEnabled?: boolean;
    } | null;
    certificate?: { id: string } | null;
    customCertificate?: { enabled: boolean | null; id?: string } | null;
    extendedEmailMatching?: { enabled?: boolean | null } | null;
    fips?: { tls?: boolean } | null;
    hostSelector?: { enabled?: boolean | null } | null;
    inspection?: { mode?: "static" | "dynamic" } | null;
    protocolDetection?: { enabled?: boolean | null } | null;
    sandbox?: {
      enabled?: boolean | null;
      fallbackAction?: "allow" | "block";
    } | null;
    tlsDecrypt?: { enabled?: boolean } | null;
  };
}

export const PatchGatewayConfigurationRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  settings: Schema.optional(
    Schema.Struct({
      activityLog: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
          }),
          Schema.Null,
        ]),
      ),
      antivirus: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabledDownloadPhase: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            enabledUploadPhase: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            failClosed: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            notificationSettings: Schema.optional(
              Schema.Union([
                Schema.Struct({
                  enabled: Schema.optional(Schema.Boolean),
                  includeContext: Schema.optional(Schema.Boolean),
                  msg: Schema.optional(Schema.String),
                  supportUrl: Schema.optional(Schema.String),
                }).pipe(
                  Schema.encodeKeys({
                    enabled: "enabled",
                    includeContext: "include_context",
                    msg: "msg",
                    supportUrl: "support_url",
                  }),
                ),
                Schema.Null,
              ]),
            ),
          }).pipe(
            Schema.encodeKeys({
              enabledDownloadPhase: "enabled_download_phase",
              enabledUploadPhase: "enabled_upload_phase",
              failClosed: "fail_closed",
              notificationSettings: "notification_settings",
            }),
          ),
          Schema.Null,
        ]),
      ),
      blockPage: Schema.optional(
        Schema.Union([
          Schema.Struct({
            backgroundColor: Schema.optional(Schema.String),
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            footerText: Schema.optional(Schema.String),
            headerText: Schema.optional(Schema.String),
            includeContext: Schema.optional(Schema.Boolean),
            logoPath: Schema.optional(Schema.String),
            mailtoAddress: Schema.optional(Schema.String),
            mailtoSubject: Schema.optional(Schema.String),
            mode: Schema.optional(
              Schema.Literals(["", "customized_block_page", "redirect_uri"]),
            ),
            name: Schema.optional(Schema.String),
            suppressFooter: Schema.optional(Schema.Boolean),
            targetUri: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              backgroundColor: "background_color",
              enabled: "enabled",
              footerText: "footer_text",
              headerText: "header_text",
              includeContext: "include_context",
              logoPath: "logo_path",
              mailtoAddress: "mailto_address",
              mailtoSubject: "mailto_subject",
              mode: "mode",
              name: "name",
              suppressFooter: "suppress_footer",
              targetUri: "target_uri",
            }),
          ),
          Schema.Null,
        ]),
      ),
      bodyScanning: Schema.optional(
        Schema.Union([
          Schema.Struct({
            inspectionMode: Schema.optional(
              Schema.Literals(["deep", "shallow"]),
            ),
          }).pipe(Schema.encodeKeys({ inspectionMode: "inspection_mode" })),
          Schema.Null,
        ]),
      ),
      browserIsolation: Schema.optional(
        Schema.Union([
          Schema.Struct({
            nonIdentityEnabled: Schema.optional(Schema.Boolean),
            urlBrowserIsolationEnabled: Schema.optional(Schema.Boolean),
          }).pipe(
            Schema.encodeKeys({
              nonIdentityEnabled: "non_identity_enabled",
              urlBrowserIsolationEnabled: "url_browser_isolation_enabled",
            }),
          ),
          Schema.Null,
        ]),
      ),
      certificate: Schema.optional(
        Schema.Union([
          Schema.Struct({
            id: Schema.String,
          }),
          Schema.Null,
        ]),
      ),
      customCertificate: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.Union([Schema.Boolean, Schema.Null]),
            id: Schema.optional(Schema.String),
          }),
          Schema.Null,
        ]),
      ),
      extendedEmailMatching: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
          }),
          Schema.Null,
        ]),
      ),
      fips: Schema.optional(
        Schema.Union([
          Schema.Struct({
            tls: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      hostSelector: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
          }),
          Schema.Null,
        ]),
      ),
      inspection: Schema.optional(
        Schema.Union([
          Schema.Struct({
            mode: Schema.optional(Schema.Literals(["static", "dynamic"])),
          }),
          Schema.Null,
        ]),
      ),
      protocolDetection: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
          }),
          Schema.Null,
        ]),
      ),
      sandbox: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            fallbackAction: Schema.optional(
              Schema.Literals(["allow", "block"]),
            ),
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              fallbackAction: "fallback_action",
            }),
          ),
          Schema.Null,
        ]),
      ),
      tlsDecrypt: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        activityLog: "activity_log",
        antivirus: "antivirus",
        blockPage: "block_page",
        bodyScanning: "body_scanning",
        browserIsolation: "browser_isolation",
        certificate: "certificate",
        customCertificate: "custom_certificate",
        extendedEmailMatching: "extended_email_matching",
        fips: "fips",
        hostSelector: "host_selector",
        inspection: "inspection",
        protocolDetection: "protocol_detection",
        sandbox: "sandbox",
        tlsDecrypt: "tls_decrypt",
      }),
    ),
  ),
}).pipe(
  T.Http({
    method: "PATCH",
    path: "/accounts/{account_id}/gateway/configuration",
  }),
) as unknown as Schema.Schema<PatchGatewayConfigurationRequest>;

export interface PatchGatewayConfigurationResponse {
  createdAt?: string;
  /** Specify account settings. */
  settings?: {
    activityLog?: { enabled?: boolean | null } | null;
    antivirus?: {
      enabledDownloadPhase?: boolean | null;
      enabledUploadPhase?: boolean | null;
      failClosed?: boolean | null;
      notificationSettings?: {
        enabled?: boolean;
        includeContext?: boolean;
        msg?: string;
        supportUrl?: string;
      } | null;
    } | null;
    blockPage?: {
      backgroundColor?: string;
      enabled?: boolean | null;
      footerText?: string;
      headerText?: string;
      includeContext?: boolean;
      logoPath?: string;
      mailtoAddress?: string;
      mailtoSubject?: string;
      mode?: "" | "customized_block_page" | "redirect_uri";
      name?: string;
      readOnly?: boolean | null;
      sourceAccount?: string | null;
      suppressFooter?: boolean;
      targetUri?: string;
      version?: number | null;
    } | null;
    bodyScanning?: { inspectionMode?: "deep" | "shallow" } | null;
    browserIsolation?: {
      nonIdentityEnabled?: boolean;
      urlBrowserIsolationEnabled?: boolean;
    } | null;
    certificate?: { id: string } | null;
    customCertificate?: {
      enabled: boolean | null;
      id?: string;
      bindingStatus?: string;
      updatedAt?: string;
    } | null;
    extendedEmailMatching?: {
      enabled?: boolean | null;
      readOnly?: boolean;
      sourceAccount?: string;
      version?: number;
    } | null;
    fips?: { tls?: boolean } | null;
    hostSelector?: { enabled?: boolean | null } | null;
    inspection?: { mode?: "static" | "dynamic" } | null;
    protocolDetection?: { enabled?: boolean | null } | null;
    sandbox?: {
      enabled?: boolean | null;
      fallbackAction?: "allow" | "block";
    } | null;
    tlsDecrypt?: { enabled?: boolean } | null;
  };
  updatedAt?: string;
}

export const PatchGatewayConfigurationResponse = Schema.Struct({
  createdAt: Schema.optional(Schema.String),
  settings: Schema.optional(
    Schema.Struct({
      activityLog: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
          }),
          Schema.Null,
        ]),
      ),
      antivirus: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabledDownloadPhase: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            enabledUploadPhase: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            failClosed: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            notificationSettings: Schema.optional(
              Schema.Union([
                Schema.Struct({
                  enabled: Schema.optional(Schema.Boolean),
                  includeContext: Schema.optional(Schema.Boolean),
                  msg: Schema.optional(Schema.String),
                  supportUrl: Schema.optional(Schema.String),
                }).pipe(
                  Schema.encodeKeys({
                    enabled: "enabled",
                    includeContext: "include_context",
                    msg: "msg",
                    supportUrl: "support_url",
                  }),
                ),
                Schema.Null,
              ]),
            ),
          }).pipe(
            Schema.encodeKeys({
              enabledDownloadPhase: "enabled_download_phase",
              enabledUploadPhase: "enabled_upload_phase",
              failClosed: "fail_closed",
              notificationSettings: "notification_settings",
            }),
          ),
          Schema.Null,
        ]),
      ),
      blockPage: Schema.optional(
        Schema.Union([
          Schema.Struct({
            backgroundColor: Schema.optional(Schema.String),
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            footerText: Schema.optional(Schema.String),
            headerText: Schema.optional(Schema.String),
            includeContext: Schema.optional(Schema.Boolean),
            logoPath: Schema.optional(Schema.String),
            mailtoAddress: Schema.optional(Schema.String),
            mailtoSubject: Schema.optional(Schema.String),
            mode: Schema.optional(
              Schema.Literals(["", "customized_block_page", "redirect_uri"]),
            ),
            name: Schema.optional(Schema.String),
            readOnly: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            sourceAccount: Schema.optional(
              Schema.Union([Schema.String, Schema.Null]),
            ),
            suppressFooter: Schema.optional(Schema.Boolean),
            targetUri: Schema.optional(Schema.String),
            version: Schema.optional(
              Schema.Union([Schema.Number, Schema.Null]),
            ),
          }).pipe(
            Schema.encodeKeys({
              backgroundColor: "background_color",
              enabled: "enabled",
              footerText: "footer_text",
              headerText: "header_text",
              includeContext: "include_context",
              logoPath: "logo_path",
              mailtoAddress: "mailto_address",
              mailtoSubject: "mailto_subject",
              mode: "mode",
              name: "name",
              readOnly: "read_only",
              sourceAccount: "source_account",
              suppressFooter: "suppress_footer",
              targetUri: "target_uri",
              version: "version",
            }),
          ),
          Schema.Null,
        ]),
      ),
      bodyScanning: Schema.optional(
        Schema.Union([
          Schema.Struct({
            inspectionMode: Schema.optional(
              Schema.Literals(["deep", "shallow"]),
            ),
          }).pipe(Schema.encodeKeys({ inspectionMode: "inspection_mode" })),
          Schema.Null,
        ]),
      ),
      browserIsolation: Schema.optional(
        Schema.Union([
          Schema.Struct({
            nonIdentityEnabled: Schema.optional(Schema.Boolean),
            urlBrowserIsolationEnabled: Schema.optional(Schema.Boolean),
          }).pipe(
            Schema.encodeKeys({
              nonIdentityEnabled: "non_identity_enabled",
              urlBrowserIsolationEnabled: "url_browser_isolation_enabled",
            }),
          ),
          Schema.Null,
        ]),
      ),
      certificate: Schema.optional(
        Schema.Union([
          Schema.Struct({
            id: Schema.String,
          }),
          Schema.Null,
        ]),
      ),
      customCertificate: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.Union([Schema.Boolean, Schema.Null]),
            id: Schema.optional(Schema.String),
            bindingStatus: Schema.optional(Schema.String),
            updatedAt: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              id: "id",
              bindingStatus: "binding_status",
              updatedAt: "updated_at",
            }),
          ),
          Schema.Null,
        ]),
      ),
      extendedEmailMatching: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            readOnly: Schema.optional(Schema.Boolean),
            sourceAccount: Schema.optional(Schema.String),
            version: Schema.optional(Schema.Number),
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              readOnly: "read_only",
              sourceAccount: "source_account",
              version: "version",
            }),
          ),
          Schema.Null,
        ]),
      ),
      fips: Schema.optional(
        Schema.Union([
          Schema.Struct({
            tls: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      hostSelector: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
          }),
          Schema.Null,
        ]),
      ),
      inspection: Schema.optional(
        Schema.Union([
          Schema.Struct({
            mode: Schema.optional(Schema.Literals(["static", "dynamic"])),
          }),
          Schema.Null,
        ]),
      ),
      protocolDetection: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
          }),
          Schema.Null,
        ]),
      ),
      sandbox: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(
              Schema.Union([Schema.Boolean, Schema.Null]),
            ),
            fallbackAction: Schema.optional(
              Schema.Literals(["allow", "block"]),
            ),
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              fallbackAction: "fallback_action",
            }),
          ),
          Schema.Null,
        ]),
      ),
      tlsDecrypt: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        activityLog: "activity_log",
        antivirus: "antivirus",
        blockPage: "block_page",
        bodyScanning: "body_scanning",
        browserIsolation: "browser_isolation",
        certificate: "certificate",
        customCertificate: "custom_certificate",
        extendedEmailMatching: "extended_email_matching",
        fips: "fips",
        hostSelector: "host_selector",
        inspection: "inspection",
        protocolDetection: "protocol_detection",
        sandbox: "sandbox",
        tlsDecrypt: "tls_decrypt",
      }),
    ),
  ),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    createdAt: "created_at",
    settings: "settings",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<PatchGatewayConfigurationResponse>;

export type PatchGatewayConfigurationError = CommonErrors;

export const patchGatewayConfiguration: API.OperationMethod<
  PatchGatewayConfigurationRequest,
  PatchGatewayConfigurationResponse,
  PatchGatewayConfigurationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchGatewayConfigurationRequest,
  output: PatchGatewayConfigurationResponse,
  errors: [],
}));

// =============================================================================
// GatewayConfigurationCustomCertificate
// =============================================================================

export interface GetGatewayConfigurationCustomCertificateRequest {
  accountId: string;
}

export const GetGatewayConfigurationCustomCertificateRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/gateway/configuration/custom_certificate",
  }),
) as unknown as Schema.Schema<GetGatewayConfigurationCustomCertificateRequest>;

export type GetGatewayConfigurationCustomCertificateResponse = unknown;

export const GetGatewayConfigurationCustomCertificateResponse =
  Schema.Unknown as unknown as Schema.Schema<GetGatewayConfigurationCustomCertificateResponse>;

export type GetGatewayConfigurationCustomCertificateError = CommonErrors;

export const getGatewayConfigurationCustomCertificate: API.OperationMethod<
  GetGatewayConfigurationCustomCertificateRequest,
  GetGatewayConfigurationCustomCertificateResponse,
  GetGatewayConfigurationCustomCertificateError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetGatewayConfigurationCustomCertificateRequest,
  output: GetGatewayConfigurationCustomCertificateResponse,
  errors: [],
}));

// =============================================================================
// GatewayList
// =============================================================================

export interface GetGatewayListRequest {
  listId: string;
  accountId: string;
}

export const GetGatewayListRequest = Schema.Struct({
  listId: Schema.String.pipe(T.HttpPath("listId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/gateway/lists/{listId}",
  }),
) as unknown as Schema.Schema<GetGatewayListRequest>;

export interface GetGatewayListResponse {
  /** Identify the API resource with a UUID. */
  id?: string;
  /** Indicate the number of items in the list. */
  count?: number;
  createdAt?: string;
  /** Provide the list description. */
  description?: string;
  /** Provide the list items. */
  items?: { createdAt?: string; description?: string; value?: string }[];
  /** Specify the list name. */
  name?: string;
  /** Specify the list type. */
  type?:
    | "SERIAL"
    | "URL"
    | "DOMAIN"
    | "EMAIL"
    | "IP"
    | "CATEGORY"
    | "LOCATION"
    | "DEVICE";
  updatedAt?: string;
}

export const GetGatewayListResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  count: Schema.optional(Schema.Number),
  createdAt: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  items: Schema.optional(
    Schema.Array(
      Schema.Struct({
        createdAt: Schema.optional(Schema.String),
        description: Schema.optional(Schema.String),
        value: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          createdAt: "created_at",
          description: "description",
          value: "value",
        }),
      ),
    ),
  ),
  name: Schema.optional(Schema.String),
  type: Schema.optional(
    Schema.Literals([
      "SERIAL",
      "URL",
      "DOMAIN",
      "EMAIL",
      "IP",
      "CATEGORY",
      "LOCATION",
      "DEVICE",
    ]),
  ),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    count: "count",
    createdAt: "created_at",
    description: "description",
    items: "items",
    name: "name",
    type: "type",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<GetGatewayListResponse>;

export type GetGatewayListError = CommonErrors;

export const getGatewayList: API.OperationMethod<
  GetGatewayListRequest,
  GetGatewayListResponse,
  GetGatewayListError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetGatewayListRequest,
  output: GetGatewayListResponse,
  errors: [],
}));

export interface ListGatewayListsRequest {
  /** Path param: */
  accountId: string;
  /** Query param: Specify the list type. */
  type?:
    | "SERIAL"
    | "URL"
    | "DOMAIN"
    | "EMAIL"
    | "IP"
    | "CATEGORY"
    | "LOCATION"
    | "DEVICE";
}

export const ListGatewayListsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  type: Schema.optional(
    Schema.Literals([
      "SERIAL",
      "URL",
      "DOMAIN",
      "EMAIL",
      "IP",
      "CATEGORY",
      "LOCATION",
      "DEVICE",
    ]),
  ).pipe(T.HttpQuery("type")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/lists" }),
) as unknown as Schema.Schema<ListGatewayListsRequest>;

export type ListGatewayListsResponse = {
  id?: string;
  count?: number;
  createdAt?: string;
  description?: string;
  items?: { createdAt?: string; description?: string; value?: string }[];
  name?: string;
  type?:
    | "SERIAL"
    | "URL"
    | "DOMAIN"
    | "EMAIL"
    | "IP"
    | "CATEGORY"
    | "LOCATION"
    | "DEVICE";
  updatedAt?: string;
}[];

export const ListGatewayListsResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    count: Schema.optional(Schema.Number),
    createdAt: Schema.optional(Schema.String),
    description: Schema.optional(Schema.String),
    items: Schema.optional(
      Schema.Array(
        Schema.Struct({
          createdAt: Schema.optional(Schema.String),
          description: Schema.optional(Schema.String),
          value: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            createdAt: "created_at",
            description: "description",
            value: "value",
          }),
        ),
      ),
    ),
    name: Schema.optional(Schema.String),
    type: Schema.optional(
      Schema.Literals([
        "SERIAL",
        "URL",
        "DOMAIN",
        "EMAIL",
        "IP",
        "CATEGORY",
        "LOCATION",
        "DEVICE",
      ]),
    ),
    updatedAt: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      count: "count",
      createdAt: "created_at",
      description: "description",
      items: "items",
      name: "name",
      type: "type",
      updatedAt: "updated_at",
    }),
  ),
) as unknown as Schema.Schema<ListGatewayListsResponse>;

export type ListGatewayListsError = CommonErrors;

export const listGatewayLists: API.OperationMethod<
  ListGatewayListsRequest,
  ListGatewayListsResponse,
  ListGatewayListsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListGatewayListsRequest,
  output: ListGatewayListsResponse,
  errors: [],
}));

export interface CreateGatewayListRequest {
  /** Path param: */
  accountId: string;
  /** Body param: Specify the list name. */
  name: string;
  /** Body param: Specify the list type. */
  type:
    | "SERIAL"
    | "URL"
    | "DOMAIN"
    | "EMAIL"
    | "IP"
    | "CATEGORY"
    | "LOCATION"
    | "DEVICE";
  /** Body param: Provide the list description. */
  description?: string;
  /** Body param: Add items to the list. */
  items?: { description?: string; value?: string }[];
}

export const CreateGatewayListRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.String,
  type: Schema.Literals([
    "SERIAL",
    "URL",
    "DOMAIN",
    "EMAIL",
    "IP",
    "CATEGORY",
    "LOCATION",
    "DEVICE",
  ]),
  description: Schema.optional(Schema.String),
  items: Schema.optional(
    Schema.Array(
      Schema.Struct({
        description: Schema.optional(Schema.String),
        value: Schema.optional(Schema.String),
      }),
    ),
  ),
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/gateway/lists" }),
) as unknown as Schema.Schema<CreateGatewayListRequest>;

export interface CreateGatewayListResponse {
  /** Identify the API resource with a UUID. */
  id?: string;
  createdAt?: string;
  /** Provide the list description. */
  description?: string;
  /** Provide the list items. */
  items?: { createdAt?: string; description?: string; value?: string }[];
  /** Specify the list name. */
  name?: string;
  /** Specify the list type. */
  type?:
    | "SERIAL"
    | "URL"
    | "DOMAIN"
    | "EMAIL"
    | "IP"
    | "CATEGORY"
    | "LOCATION"
    | "DEVICE";
  updatedAt?: string;
}

export const CreateGatewayListResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  items: Schema.optional(
    Schema.Array(
      Schema.Struct({
        createdAt: Schema.optional(Schema.String),
        description: Schema.optional(Schema.String),
        value: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          createdAt: "created_at",
          description: "description",
          value: "value",
        }),
      ),
    ),
  ),
  name: Schema.optional(Schema.String),
  type: Schema.optional(
    Schema.Literals([
      "SERIAL",
      "URL",
      "DOMAIN",
      "EMAIL",
      "IP",
      "CATEGORY",
      "LOCATION",
      "DEVICE",
    ]),
  ),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    createdAt: "created_at",
    description: "description",
    items: "items",
    name: "name",
    type: "type",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<CreateGatewayListResponse>;

export type CreateGatewayListError = CommonErrors;

export const createGatewayList: API.OperationMethod<
  CreateGatewayListRequest,
  CreateGatewayListResponse,
  CreateGatewayListError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateGatewayListRequest,
  output: CreateGatewayListResponse,
  errors: [],
}));

export interface UpdateGatewayListRequest {
  listId: string;
  /** Path param: */
  accountId: string;
  /** Body param: Specify the list name. */
  name: string;
  /** Body param: Provide the list description. */
  description?: string;
  /** Body param: Add items to the list. */
  items?: { description?: string; value?: string }[];
}

export const UpdateGatewayListRequest = Schema.Struct({
  listId: Schema.String.pipe(T.HttpPath("listId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.String,
  description: Schema.optional(Schema.String),
  items: Schema.optional(
    Schema.Array(
      Schema.Struct({
        description: Schema.optional(Schema.String),
        value: Schema.optional(Schema.String),
      }),
    ),
  ),
}).pipe(
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/gateway/lists/{listId}",
  }),
) as unknown as Schema.Schema<UpdateGatewayListRequest>;

export interface UpdateGatewayListResponse {
  /** Identify the API resource with a UUID. */
  id?: string;
  /** Indicate the number of items in the list. */
  count?: number;
  createdAt?: string;
  /** Provide the list description. */
  description?: string;
  /** Provide the list items. */
  items?: { createdAt?: string; description?: string; value?: string }[];
  /** Specify the list name. */
  name?: string;
  /** Specify the list type. */
  type?:
    | "SERIAL"
    | "URL"
    | "DOMAIN"
    | "EMAIL"
    | "IP"
    | "CATEGORY"
    | "LOCATION"
    | "DEVICE";
  updatedAt?: string;
}

export const UpdateGatewayListResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  count: Schema.optional(Schema.Number),
  createdAt: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  items: Schema.optional(
    Schema.Array(
      Schema.Struct({
        createdAt: Schema.optional(Schema.String),
        description: Schema.optional(Schema.String),
        value: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          createdAt: "created_at",
          description: "description",
          value: "value",
        }),
      ),
    ),
  ),
  name: Schema.optional(Schema.String),
  type: Schema.optional(
    Schema.Literals([
      "SERIAL",
      "URL",
      "DOMAIN",
      "EMAIL",
      "IP",
      "CATEGORY",
      "LOCATION",
      "DEVICE",
    ]),
  ),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    count: "count",
    createdAt: "created_at",
    description: "description",
    items: "items",
    name: "name",
    type: "type",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<UpdateGatewayListResponse>;

export type UpdateGatewayListError = CommonErrors;

export const updateGatewayList: API.OperationMethod<
  UpdateGatewayListRequest,
  UpdateGatewayListResponse,
  UpdateGatewayListError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateGatewayListRequest,
  output: UpdateGatewayListResponse,
  errors: [],
}));

export interface PatchGatewayListRequest {
  listId: string;
  /** Path param: */
  accountId: string;
  /** Body param: Add items to the list. */
  append?: { description?: string; value?: string }[];
  /** Body param: Lists of item values you want to remove. */
  remove?: string[];
}

export const PatchGatewayListRequest = Schema.Struct({
  listId: Schema.String.pipe(T.HttpPath("listId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  append: Schema.optional(
    Schema.Array(
      Schema.Struct({
        description: Schema.optional(Schema.String),
        value: Schema.optional(Schema.String),
      }),
    ),
  ),
  remove: Schema.optional(Schema.Array(Schema.String)),
}).pipe(
  T.Http({
    method: "PATCH",
    path: "/accounts/{account_id}/gateway/lists/{listId}",
  }),
) as unknown as Schema.Schema<PatchGatewayListRequest>;

export interface PatchGatewayListResponse {
  /** Identify the API resource with a UUID. */
  id?: string;
  /** Indicate the number of items in the list. */
  count?: number;
  createdAt?: string;
  /** Provide the list description. */
  description?: string;
  /** Provide the list items. */
  items?: { createdAt?: string; description?: string; value?: string }[];
  /** Specify the list name. */
  name?: string;
  /** Specify the list type. */
  type?:
    | "SERIAL"
    | "URL"
    | "DOMAIN"
    | "EMAIL"
    | "IP"
    | "CATEGORY"
    | "LOCATION"
    | "DEVICE";
  updatedAt?: string;
}

export const PatchGatewayListResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  count: Schema.optional(Schema.Number),
  createdAt: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String),
  items: Schema.optional(
    Schema.Array(
      Schema.Struct({
        createdAt: Schema.optional(Schema.String),
        description: Schema.optional(Schema.String),
        value: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          createdAt: "created_at",
          description: "description",
          value: "value",
        }),
      ),
    ),
  ),
  name: Schema.optional(Schema.String),
  type: Schema.optional(
    Schema.Literals([
      "SERIAL",
      "URL",
      "DOMAIN",
      "EMAIL",
      "IP",
      "CATEGORY",
      "LOCATION",
      "DEVICE",
    ]),
  ),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    count: "count",
    createdAt: "created_at",
    description: "description",
    items: "items",
    name: "name",
    type: "type",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<PatchGatewayListResponse>;

export type PatchGatewayListError = CommonErrors;

export const patchGatewayList: API.OperationMethod<
  PatchGatewayListRequest,
  PatchGatewayListResponse,
  PatchGatewayListError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchGatewayListRequest,
  output: PatchGatewayListResponse,
  errors: [],
}));

export interface DeleteGatewayListRequest {
  listId: string;
  accountId: string;
}

export const DeleteGatewayListRequest = Schema.Struct({
  listId: Schema.String.pipe(T.HttpPath("listId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/gateway/lists/{listId}",
  }),
) as unknown as Schema.Schema<DeleteGatewayListRequest>;

export type DeleteGatewayListResponse = unknown;

export const DeleteGatewayListResponse =
  Schema.Unknown as unknown as Schema.Schema<DeleteGatewayListResponse>;

export type DeleteGatewayListError = CommonErrors;

export const deleteGatewayList: API.OperationMethod<
  DeleteGatewayListRequest,
  DeleteGatewayListResponse,
  DeleteGatewayListError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteGatewayListRequest,
  output: DeleteGatewayListResponse,
  errors: [],
}));

// =============================================================================
// GatewayListItem
// =============================================================================

export interface ListGatewayListItemsRequest {
  listId: string;
  accountId: string;
}

export const ListGatewayListItemsRequest = Schema.Struct({
  listId: Schema.String.pipe(T.HttpPath("listId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/gateway/lists/{listId}/items",
  }),
) as unknown as Schema.Schema<ListGatewayListItemsRequest>;

export type ListGatewayListItemsResponse = unknown[];

export const ListGatewayListItemsResponse = Schema.Array(
  Schema.Unknown,
) as unknown as Schema.Schema<ListGatewayListItemsResponse>;

export type ListGatewayListItemsError = CommonErrors;

export const listGatewayListItems: API.OperationMethod<
  ListGatewayListItemsRequest,
  ListGatewayListItemsResponse,
  ListGatewayListItemsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListGatewayListItemsRequest,
  output: ListGatewayListItemsResponse,
  errors: [],
}));

// =============================================================================
// GatewayLocation
// =============================================================================

export interface GetGatewayLocationRequest {
  locationId: string;
  accountId: string;
}

export const GetGatewayLocationRequest = Schema.Struct({
  locationId: Schema.String.pipe(T.HttpPath("locationId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/gateway/locations/{locationId}",
  }),
) as unknown as Schema.Schema<GetGatewayLocationRequest>;

export interface GetGatewayLocationResponse {
  id?: string;
  /** Indicate whether this location is the default location. */
  clientDefault?: boolean;
  createdAt?: string;
  /** Indicate the identifier of the pair of IPv4 addresses assigned to this location. */
  dnsDestinationIpsId?: string;
  /** Specify the UUID of the IPv6 block brought to the gateway so that this location's IPv6 address is allocated from the Bring Your Own IPv6 (BYOIPv6) block rather than the standard Cloudflare IPv6 block. */
  dnsDestinationIpv6BlockId?: string | null;
  /** Specify the DNS over HTTPS domain that receives DNS requests. Gateway automatically generates this value. */
  dohSubdomain?: string;
  /** Indicate whether the location must resolve EDNS queries. */
  ecsSupport?: boolean;
  /** Configure the destination endpoints for this location. */
  endpoints?: {
    doh: {
      enabled?: boolean;
      networks?: { network: string }[] | null;
      requireToken?: boolean;
    };
    dot: { enabled?: boolean; networks?: { network: string }[] | null };
    ipv4: { enabled?: boolean };
    ipv6: { enabled?: boolean; networks?: { network: string }[] | null };
  } | null;
  /** Defines the automatically generated IPv6 destination IP assigned to this location. Gateway counts all DNS requests sent to this IP as requests under this location. */
  ip?: string;
  /** Show the primary destination IPv4 address from the pair identified dns_destination_ips_id. This field read-only. */
  ipv4Destination?: string;
  /** Show the backup destination IPv4 address from the pair identified dns_destination_ips_id. This field read-only. */
  ipv4DestinationBackup?: string;
  /** Specify the location name. */
  name?: string;
  /** Specify the list of network ranges from which requests at this location originate. The list takes effect only if it is non-empty and the IPv4 endpoint is enabled for this location. */
  networks?: { network: string }[] | null;
  updatedAt?: string;
}

export const GetGatewayLocationResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  clientDefault: Schema.optional(Schema.Boolean),
  createdAt: Schema.optional(Schema.String),
  dnsDestinationIpsId: Schema.optional(Schema.String),
  dnsDestinationIpv6BlockId: Schema.optional(
    Schema.Union([Schema.String, Schema.Null]),
  ),
  dohSubdomain: Schema.optional(Schema.String),
  ecsSupport: Schema.optional(Schema.Boolean),
  endpoints: Schema.optional(
    Schema.Union([
      Schema.Struct({
        doh: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
          networks: Schema.optional(
            Schema.Union([
              Schema.Array(
                Schema.Struct({
                  network: Schema.String,
                }),
              ),
              Schema.Null,
            ]),
          ),
          requireToken: Schema.optional(Schema.Boolean),
        }).pipe(
          Schema.encodeKeys({
            enabled: "enabled",
            networks: "networks",
            requireToken: "require_token",
          }),
        ),
        dot: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
          networks: Schema.optional(
            Schema.Union([
              Schema.Array(
                Schema.Struct({
                  network: Schema.String,
                }),
              ),
              Schema.Null,
            ]),
          ),
        }),
        ipv4: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
        }),
        ipv6: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
          networks: Schema.optional(
            Schema.Union([
              Schema.Array(
                Schema.Struct({
                  network: Schema.String,
                }),
              ),
              Schema.Null,
            ]),
          ),
        }),
      }),
      Schema.Null,
    ]),
  ),
  ip: Schema.optional(Schema.String),
  ipv4Destination: Schema.optional(Schema.String),
  ipv4DestinationBackup: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  networks: Schema.optional(
    Schema.Union([
      Schema.Array(
        Schema.Struct({
          network: Schema.String,
        }),
      ),
      Schema.Null,
    ]),
  ),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    clientDefault: "client_default",
    createdAt: "created_at",
    dnsDestinationIpsId: "dns_destination_ips_id",
    dnsDestinationIpv6BlockId: "dns_destination_ipv6_block_id",
    dohSubdomain: "doh_subdomain",
    ecsSupport: "ecs_support",
    endpoints: "endpoints",
    ip: "ip",
    ipv4Destination: "ipv4_destination",
    ipv4DestinationBackup: "ipv4_destination_backup",
    name: "name",
    networks: "networks",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<GetGatewayLocationResponse>;

export type GetGatewayLocationError = CommonErrors;

export const getGatewayLocation: API.OperationMethod<
  GetGatewayLocationRequest,
  GetGatewayLocationResponse,
  GetGatewayLocationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetGatewayLocationRequest,
  output: GetGatewayLocationResponse,
  errors: [],
}));

export interface ListGatewayLocationsRequest {
  accountId: string;
}

export const ListGatewayLocationsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/locations" }),
) as unknown as Schema.Schema<ListGatewayLocationsRequest>;

export type ListGatewayLocationsResponse = {
  id?: string;
  clientDefault?: boolean;
  createdAt?: string;
  dnsDestinationIpsId?: string;
  dnsDestinationIpv6BlockId?: string | null;
  dohSubdomain?: string;
  ecsSupport?: boolean;
  endpoints?: {
    doh: {
      enabled?: boolean;
      networks?: { network: string }[] | null;
      requireToken?: boolean;
    };
    dot: { enabled?: boolean; networks?: { network: string }[] | null };
    ipv4: { enabled?: boolean };
    ipv6: { enabled?: boolean; networks?: { network: string }[] | null };
  } | null;
  ip?: string;
  ipv4Destination?: string;
  ipv4DestinationBackup?: string;
  name?: string;
  networks?: { network: string }[] | null;
  updatedAt?: string;
}[];

export const ListGatewayLocationsResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    clientDefault: Schema.optional(Schema.Boolean),
    createdAt: Schema.optional(Schema.String),
    dnsDestinationIpsId: Schema.optional(Schema.String),
    dnsDestinationIpv6BlockId: Schema.optional(
      Schema.Union([Schema.String, Schema.Null]),
    ),
    dohSubdomain: Schema.optional(Schema.String),
    ecsSupport: Schema.optional(Schema.Boolean),
    endpoints: Schema.optional(
      Schema.Union([
        Schema.Struct({
          doh: Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
            networks: Schema.optional(
              Schema.Union([
                Schema.Array(
                  Schema.Struct({
                    network: Schema.String,
                  }),
                ),
                Schema.Null,
              ]),
            ),
            requireToken: Schema.optional(Schema.Boolean),
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              networks: "networks",
              requireToken: "require_token",
            }),
          ),
          dot: Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
            networks: Schema.optional(
              Schema.Union([
                Schema.Array(
                  Schema.Struct({
                    network: Schema.String,
                  }),
                ),
                Schema.Null,
              ]),
            ),
          }),
          ipv4: Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
          }),
          ipv6: Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
            networks: Schema.optional(
              Schema.Union([
                Schema.Array(
                  Schema.Struct({
                    network: Schema.String,
                  }),
                ),
                Schema.Null,
              ]),
            ),
          }),
        }),
        Schema.Null,
      ]),
    ),
    ip: Schema.optional(Schema.String),
    ipv4Destination: Schema.optional(Schema.String),
    ipv4DestinationBackup: Schema.optional(Schema.String),
    name: Schema.optional(Schema.String),
    networks: Schema.optional(
      Schema.Union([
        Schema.Array(
          Schema.Struct({
            network: Schema.String,
          }),
        ),
        Schema.Null,
      ]),
    ),
    updatedAt: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      clientDefault: "client_default",
      createdAt: "created_at",
      dnsDestinationIpsId: "dns_destination_ips_id",
      dnsDestinationIpv6BlockId: "dns_destination_ipv6_block_id",
      dohSubdomain: "doh_subdomain",
      ecsSupport: "ecs_support",
      endpoints: "endpoints",
      ip: "ip",
      ipv4Destination: "ipv4_destination",
      ipv4DestinationBackup: "ipv4_destination_backup",
      name: "name",
      networks: "networks",
      updatedAt: "updated_at",
    }),
  ),
) as unknown as Schema.Schema<ListGatewayLocationsResponse>;

export type ListGatewayLocationsError = CommonErrors;

export const listGatewayLocations: API.OperationMethod<
  ListGatewayLocationsRequest,
  ListGatewayLocationsResponse,
  ListGatewayLocationsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListGatewayLocationsRequest,
  output: ListGatewayLocationsResponse,
  errors: [],
}));

export interface CreateGatewayLocationRequest {
  /** Path param: */
  accountId: string;
  /** Body param: Specify the location name. */
  name: string;
  /** Body param: Indicate whether this location is the default location. */
  clientDefault?: boolean;
  /** Body param: Specify the identifier of the pair of IPv4 addresses assigned to this location. When creating a location, if this field is absent or set to null, the pair of shared IPv4 addresses (0e4a32c */
  dnsDestinationIpsId?: string;
  /** Body param: Indicate whether the location must resolve EDNS queries. */
  ecsSupport?: boolean;
  /** Body param: Configure the destination endpoints for this location. */
  endpoints?: {
    doh: {
      enabled?: boolean;
      networks?: { network: string }[] | null;
      requireToken?: boolean;
    };
    dot: { enabled?: boolean; networks?: { network: string }[] | null };
    ipv4: { enabled?: boolean };
    ipv6: { enabled?: boolean; networks?: { network: string }[] | null };
  } | null;
  /** Body param: Specify the list of network ranges from which requests at this location originate. The list takes effect only if it is non-empty and the IPv4 endpoint is enabled for this location. */
  networks?: { network: string }[] | null;
}

export const CreateGatewayLocationRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.String,
  clientDefault: Schema.optional(Schema.Boolean),
  dnsDestinationIpsId: Schema.optional(Schema.String),
  ecsSupport: Schema.optional(Schema.Boolean),
  endpoints: Schema.optional(
    Schema.Union([
      Schema.Struct({
        doh: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
          networks: Schema.optional(
            Schema.Union([
              Schema.Array(
                Schema.Struct({
                  network: Schema.String,
                }),
              ),
              Schema.Null,
            ]),
          ),
          requireToken: Schema.optional(Schema.Boolean),
        }).pipe(
          Schema.encodeKeys({
            enabled: "enabled",
            networks: "networks",
            requireToken: "require_token",
          }),
        ),
        dot: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
          networks: Schema.optional(
            Schema.Union([
              Schema.Array(
                Schema.Struct({
                  network: Schema.String,
                }),
              ),
              Schema.Null,
            ]),
          ),
        }),
        ipv4: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
        }),
        ipv6: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
          networks: Schema.optional(
            Schema.Union([
              Schema.Array(
                Schema.Struct({
                  network: Schema.String,
                }),
              ),
              Schema.Null,
            ]),
          ),
        }),
      }),
      Schema.Null,
    ]),
  ),
  networks: Schema.optional(
    Schema.Union([
      Schema.Array(
        Schema.Struct({
          network: Schema.String,
        }),
      ),
      Schema.Null,
    ]),
  ),
}).pipe(
  Schema.encodeKeys({
    name: "name",
    clientDefault: "client_default",
    dnsDestinationIpsId: "dns_destination_ips_id",
    ecsSupport: "ecs_support",
    endpoints: "endpoints",
    networks: "networks",
  }),
  T.Http({ method: "POST", path: "/accounts/{account_id}/gateway/locations" }),
) as unknown as Schema.Schema<CreateGatewayLocationRequest>;

export interface CreateGatewayLocationResponse {
  id?: string;
  /** Indicate whether this location is the default location. */
  clientDefault?: boolean;
  createdAt?: string;
  /** Indicate the identifier of the pair of IPv4 addresses assigned to this location. */
  dnsDestinationIpsId?: string;
  /** Specify the UUID of the IPv6 block brought to the gateway so that this location's IPv6 address is allocated from the Bring Your Own IPv6 (BYOIPv6) block rather than the standard Cloudflare IPv6 block. */
  dnsDestinationIpv6BlockId?: string | null;
  /** Specify the DNS over HTTPS domain that receives DNS requests. Gateway automatically generates this value. */
  dohSubdomain?: string;
  /** Indicate whether the location must resolve EDNS queries. */
  ecsSupport?: boolean;
  /** Configure the destination endpoints for this location. */
  endpoints?: {
    doh: {
      enabled?: boolean;
      networks?: { network: string }[] | null;
      requireToken?: boolean;
    };
    dot: { enabled?: boolean; networks?: { network: string }[] | null };
    ipv4: { enabled?: boolean };
    ipv6: { enabled?: boolean; networks?: { network: string }[] | null };
  } | null;
  /** Defines the automatically generated IPv6 destination IP assigned to this location. Gateway counts all DNS requests sent to this IP as requests under this location. */
  ip?: string;
  /** Show the primary destination IPv4 address from the pair identified dns_destination_ips_id. This field read-only. */
  ipv4Destination?: string;
  /** Show the backup destination IPv4 address from the pair identified dns_destination_ips_id. This field read-only. */
  ipv4DestinationBackup?: string;
  /** Specify the location name. */
  name?: string;
  /** Specify the list of network ranges from which requests at this location originate. The list takes effect only if it is non-empty and the IPv4 endpoint is enabled for this location. */
  networks?: { network: string }[] | null;
  updatedAt?: string;
}

export const CreateGatewayLocationResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  clientDefault: Schema.optional(Schema.Boolean),
  createdAt: Schema.optional(Schema.String),
  dnsDestinationIpsId: Schema.optional(Schema.String),
  dnsDestinationIpv6BlockId: Schema.optional(
    Schema.Union([Schema.String, Schema.Null]),
  ),
  dohSubdomain: Schema.optional(Schema.String),
  ecsSupport: Schema.optional(Schema.Boolean),
  endpoints: Schema.optional(
    Schema.Union([
      Schema.Struct({
        doh: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
          networks: Schema.optional(
            Schema.Union([
              Schema.Array(
                Schema.Struct({
                  network: Schema.String,
                }),
              ),
              Schema.Null,
            ]),
          ),
          requireToken: Schema.optional(Schema.Boolean),
        }).pipe(
          Schema.encodeKeys({
            enabled: "enabled",
            networks: "networks",
            requireToken: "require_token",
          }),
        ),
        dot: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
          networks: Schema.optional(
            Schema.Union([
              Schema.Array(
                Schema.Struct({
                  network: Schema.String,
                }),
              ),
              Schema.Null,
            ]),
          ),
        }),
        ipv4: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
        }),
        ipv6: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
          networks: Schema.optional(
            Schema.Union([
              Schema.Array(
                Schema.Struct({
                  network: Schema.String,
                }),
              ),
              Schema.Null,
            ]),
          ),
        }),
      }),
      Schema.Null,
    ]),
  ),
  ip: Schema.optional(Schema.String),
  ipv4Destination: Schema.optional(Schema.String),
  ipv4DestinationBackup: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  networks: Schema.optional(
    Schema.Union([
      Schema.Array(
        Schema.Struct({
          network: Schema.String,
        }),
      ),
      Schema.Null,
    ]),
  ),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    clientDefault: "client_default",
    createdAt: "created_at",
    dnsDestinationIpsId: "dns_destination_ips_id",
    dnsDestinationIpv6BlockId: "dns_destination_ipv6_block_id",
    dohSubdomain: "doh_subdomain",
    ecsSupport: "ecs_support",
    endpoints: "endpoints",
    ip: "ip",
    ipv4Destination: "ipv4_destination",
    ipv4DestinationBackup: "ipv4_destination_backup",
    name: "name",
    networks: "networks",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<CreateGatewayLocationResponse>;

export type CreateGatewayLocationError = CommonErrors;

export const createGatewayLocation: API.OperationMethod<
  CreateGatewayLocationRequest,
  CreateGatewayLocationResponse,
  CreateGatewayLocationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateGatewayLocationRequest,
  output: CreateGatewayLocationResponse,
  errors: [],
}));

export interface UpdateGatewayLocationRequest {
  locationId: string;
  /** Path param: */
  accountId: string;
  /** Body param: Specify the location name. */
  name: string;
  /** Body param: Indicate whether this location is the default location. */
  clientDefault?: boolean;
  /** Body param: Specify the identifier of the pair of IPv4 addresses assigned to this location. When creating a location, if this field is absent or set to null, the pair of shared IPv4 addresses (0e4a32c */
  dnsDestinationIpsId?: string;
  /** Body param: Indicate whether the location must resolve EDNS queries. */
  ecsSupport?: boolean;
  /** Body param: Configure the destination endpoints for this location. */
  endpoints?: {
    doh: {
      enabled?: boolean;
      networks?: { network: string }[] | null;
      requireToken?: boolean;
    };
    dot: { enabled?: boolean; networks?: { network: string }[] | null };
    ipv4: { enabled?: boolean };
    ipv6: { enabled?: boolean; networks?: { network: string }[] | null };
  } | null;
  /** Body param: Specify the list of network ranges from which requests at this location originate. The list takes effect only if it is non-empty and the IPv4 endpoint is enabled for this location. */
  networks?: { network: string }[] | null;
}

export const UpdateGatewayLocationRequest = Schema.Struct({
  locationId: Schema.String.pipe(T.HttpPath("locationId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.String,
  clientDefault: Schema.optional(Schema.Boolean),
  dnsDestinationIpsId: Schema.optional(Schema.String),
  ecsSupport: Schema.optional(Schema.Boolean),
  endpoints: Schema.optional(
    Schema.Union([
      Schema.Struct({
        doh: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
          networks: Schema.optional(
            Schema.Union([
              Schema.Array(
                Schema.Struct({
                  network: Schema.String,
                }),
              ),
              Schema.Null,
            ]),
          ),
          requireToken: Schema.optional(Schema.Boolean),
        }).pipe(
          Schema.encodeKeys({
            enabled: "enabled",
            networks: "networks",
            requireToken: "require_token",
          }),
        ),
        dot: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
          networks: Schema.optional(
            Schema.Union([
              Schema.Array(
                Schema.Struct({
                  network: Schema.String,
                }),
              ),
              Schema.Null,
            ]),
          ),
        }),
        ipv4: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
        }),
        ipv6: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
          networks: Schema.optional(
            Schema.Union([
              Schema.Array(
                Schema.Struct({
                  network: Schema.String,
                }),
              ),
              Schema.Null,
            ]),
          ),
        }),
      }),
      Schema.Null,
    ]),
  ),
  networks: Schema.optional(
    Schema.Union([
      Schema.Array(
        Schema.Struct({
          network: Schema.String,
        }),
      ),
      Schema.Null,
    ]),
  ),
}).pipe(
  Schema.encodeKeys({
    name: "name",
    clientDefault: "client_default",
    dnsDestinationIpsId: "dns_destination_ips_id",
    ecsSupport: "ecs_support",
    endpoints: "endpoints",
    networks: "networks",
  }),
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/gateway/locations/{locationId}",
  }),
) as unknown as Schema.Schema<UpdateGatewayLocationRequest>;

export interface UpdateGatewayLocationResponse {
  id?: string;
  /** Indicate whether this location is the default location. */
  clientDefault?: boolean;
  createdAt?: string;
  /** Indicate the identifier of the pair of IPv4 addresses assigned to this location. */
  dnsDestinationIpsId?: string;
  /** Specify the UUID of the IPv6 block brought to the gateway so that this location's IPv6 address is allocated from the Bring Your Own IPv6 (BYOIPv6) block rather than the standard Cloudflare IPv6 block. */
  dnsDestinationIpv6BlockId?: string | null;
  /** Specify the DNS over HTTPS domain that receives DNS requests. Gateway automatically generates this value. */
  dohSubdomain?: string;
  /** Indicate whether the location must resolve EDNS queries. */
  ecsSupport?: boolean;
  /** Configure the destination endpoints for this location. */
  endpoints?: {
    doh: {
      enabled?: boolean;
      networks?: { network: string }[] | null;
      requireToken?: boolean;
    };
    dot: { enabled?: boolean; networks?: { network: string }[] | null };
    ipv4: { enabled?: boolean };
    ipv6: { enabled?: boolean; networks?: { network: string }[] | null };
  } | null;
  /** Defines the automatically generated IPv6 destination IP assigned to this location. Gateway counts all DNS requests sent to this IP as requests under this location. */
  ip?: string;
  /** Show the primary destination IPv4 address from the pair identified dns_destination_ips_id. This field read-only. */
  ipv4Destination?: string;
  /** Show the backup destination IPv4 address from the pair identified dns_destination_ips_id. This field read-only. */
  ipv4DestinationBackup?: string;
  /** Specify the location name. */
  name?: string;
  /** Specify the list of network ranges from which requests at this location originate. The list takes effect only if it is non-empty and the IPv4 endpoint is enabled for this location. */
  networks?: { network: string }[] | null;
  updatedAt?: string;
}

export const UpdateGatewayLocationResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  clientDefault: Schema.optional(Schema.Boolean),
  createdAt: Schema.optional(Schema.String),
  dnsDestinationIpsId: Schema.optional(Schema.String),
  dnsDestinationIpv6BlockId: Schema.optional(
    Schema.Union([Schema.String, Schema.Null]),
  ),
  dohSubdomain: Schema.optional(Schema.String),
  ecsSupport: Schema.optional(Schema.Boolean),
  endpoints: Schema.optional(
    Schema.Union([
      Schema.Struct({
        doh: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
          networks: Schema.optional(
            Schema.Union([
              Schema.Array(
                Schema.Struct({
                  network: Schema.String,
                }),
              ),
              Schema.Null,
            ]),
          ),
          requireToken: Schema.optional(Schema.Boolean),
        }).pipe(
          Schema.encodeKeys({
            enabled: "enabled",
            networks: "networks",
            requireToken: "require_token",
          }),
        ),
        dot: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
          networks: Schema.optional(
            Schema.Union([
              Schema.Array(
                Schema.Struct({
                  network: Schema.String,
                }),
              ),
              Schema.Null,
            ]),
          ),
        }),
        ipv4: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
        }),
        ipv6: Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
          networks: Schema.optional(
            Schema.Union([
              Schema.Array(
                Schema.Struct({
                  network: Schema.String,
                }),
              ),
              Schema.Null,
            ]),
          ),
        }),
      }),
      Schema.Null,
    ]),
  ),
  ip: Schema.optional(Schema.String),
  ipv4Destination: Schema.optional(Schema.String),
  ipv4DestinationBackup: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  networks: Schema.optional(
    Schema.Union([
      Schema.Array(
        Schema.Struct({
          network: Schema.String,
        }),
      ),
      Schema.Null,
    ]),
  ),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    clientDefault: "client_default",
    createdAt: "created_at",
    dnsDestinationIpsId: "dns_destination_ips_id",
    dnsDestinationIpv6BlockId: "dns_destination_ipv6_block_id",
    dohSubdomain: "doh_subdomain",
    ecsSupport: "ecs_support",
    endpoints: "endpoints",
    ip: "ip",
    ipv4Destination: "ipv4_destination",
    ipv4DestinationBackup: "ipv4_destination_backup",
    name: "name",
    networks: "networks",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<UpdateGatewayLocationResponse>;

export type UpdateGatewayLocationError = CommonErrors;

export const updateGatewayLocation: API.OperationMethod<
  UpdateGatewayLocationRequest,
  UpdateGatewayLocationResponse,
  UpdateGatewayLocationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateGatewayLocationRequest,
  output: UpdateGatewayLocationResponse,
  errors: [],
}));

export interface DeleteGatewayLocationRequest {
  locationId: string;
  accountId: string;
}

export const DeleteGatewayLocationRequest = Schema.Struct({
  locationId: Schema.String.pipe(T.HttpPath("locationId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/gateway/locations/{locationId}",
  }),
) as unknown as Schema.Schema<DeleteGatewayLocationRequest>;

export type DeleteGatewayLocationResponse = unknown;

export const DeleteGatewayLocationResponse =
  Schema.Unknown as unknown as Schema.Schema<DeleteGatewayLocationResponse>;

export type DeleteGatewayLocationError = CommonErrors;

export const deleteGatewayLocation: API.OperationMethod<
  DeleteGatewayLocationRequest,
  DeleteGatewayLocationResponse,
  DeleteGatewayLocationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteGatewayLocationRequest,
  output: DeleteGatewayLocationResponse,
  errors: [],
}));

// =============================================================================
// GatewayLogging
// =============================================================================

export interface GetGatewayLoggingRequest {
  accountId: string;
}

export const GetGatewayLoggingRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/logging" }),
) as unknown as Schema.Schema<GetGatewayLoggingRequest>;

export interface GetGatewayLoggingResponse {
  /** Indicate whether to redact personally identifiable information from activity logging (PII fields include source IP, user email, user ID, device ID, URL, referrer, and user agent). */
  redactPii?: boolean;
  /** Configure logging settings for each rule type. */
  settingsByRuleType?: {
    dns?: { logAll?: boolean; logBlocks?: boolean };
    http?: { logAll?: boolean; logBlocks?: boolean };
    l4?: { logAll?: boolean; logBlocks?: boolean };
  };
}

export const GetGatewayLoggingResponse = Schema.Struct({
  redactPii: Schema.optional(Schema.Boolean),
  settingsByRuleType: Schema.optional(
    Schema.Struct({
      dns: Schema.optional(
        Schema.Struct({
          logAll: Schema.optional(Schema.Boolean),
          logBlocks: Schema.optional(Schema.Boolean),
        }).pipe(
          Schema.encodeKeys({ logAll: "log_all", logBlocks: "log_blocks" }),
        ),
      ),
      http: Schema.optional(
        Schema.Struct({
          logAll: Schema.optional(Schema.Boolean),
          logBlocks: Schema.optional(Schema.Boolean),
        }).pipe(
          Schema.encodeKeys({ logAll: "log_all", logBlocks: "log_blocks" }),
        ),
      ),
      l4: Schema.optional(
        Schema.Struct({
          logAll: Schema.optional(Schema.Boolean),
          logBlocks: Schema.optional(Schema.Boolean),
        }).pipe(
          Schema.encodeKeys({ logAll: "log_all", logBlocks: "log_blocks" }),
        ),
      ),
    }),
  ),
}).pipe(
  Schema.encodeKeys({
    redactPii: "redact_pii",
    settingsByRuleType: "settings_by_rule_type",
  }),
) as unknown as Schema.Schema<GetGatewayLoggingResponse>;

export type GetGatewayLoggingError = CommonErrors;

export const getGatewayLogging: API.OperationMethod<
  GetGatewayLoggingRequest,
  GetGatewayLoggingResponse,
  GetGatewayLoggingError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetGatewayLoggingRequest,
  output: GetGatewayLoggingResponse,
  errors: [],
}));

export interface PutGatewayLoggingRequest {
  /** Path param: */
  accountId: string;
  /** Body param: Indicate whether to redact personally identifiable information from activity logging (PII fields include source IP, user email, user ID, device ID, URL, referrer, and user agent). */
  redactPii?: boolean;
  /** Body param: Configure logging settings for each rule type. */
  settingsByRuleType?: {
    dns?: { logAll?: boolean; logBlocks?: boolean };
    http?: { logAll?: boolean; logBlocks?: boolean };
    l4?: { logAll?: boolean; logBlocks?: boolean };
  };
}

export const PutGatewayLoggingRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  redactPii: Schema.optional(Schema.Boolean),
  settingsByRuleType: Schema.optional(
    Schema.Struct({
      dns: Schema.optional(
        Schema.Struct({
          logAll: Schema.optional(Schema.Boolean),
          logBlocks: Schema.optional(Schema.Boolean),
        }).pipe(
          Schema.encodeKeys({ logAll: "log_all", logBlocks: "log_blocks" }),
        ),
      ),
      http: Schema.optional(
        Schema.Struct({
          logAll: Schema.optional(Schema.Boolean),
          logBlocks: Schema.optional(Schema.Boolean),
        }).pipe(
          Schema.encodeKeys({ logAll: "log_all", logBlocks: "log_blocks" }),
        ),
      ),
      l4: Schema.optional(
        Schema.Struct({
          logAll: Schema.optional(Schema.Boolean),
          logBlocks: Schema.optional(Schema.Boolean),
        }).pipe(
          Schema.encodeKeys({ logAll: "log_all", logBlocks: "log_blocks" }),
        ),
      ),
    }),
  ),
}).pipe(
  Schema.encodeKeys({
    redactPii: "redact_pii",
    settingsByRuleType: "settings_by_rule_type",
  }),
  T.Http({ method: "PUT", path: "/accounts/{account_id}/gateway/logging" }),
) as unknown as Schema.Schema<PutGatewayLoggingRequest>;

export interface PutGatewayLoggingResponse {
  /** Indicate whether to redact personally identifiable information from activity logging (PII fields include source IP, user email, user ID, device ID, URL, referrer, and user agent). */
  redactPii?: boolean;
  /** Configure logging settings for each rule type. */
  settingsByRuleType?: {
    dns?: { logAll?: boolean; logBlocks?: boolean };
    http?: { logAll?: boolean; logBlocks?: boolean };
    l4?: { logAll?: boolean; logBlocks?: boolean };
  };
}

export const PutGatewayLoggingResponse = Schema.Struct({
  redactPii: Schema.optional(Schema.Boolean),
  settingsByRuleType: Schema.optional(
    Schema.Struct({
      dns: Schema.optional(
        Schema.Struct({
          logAll: Schema.optional(Schema.Boolean),
          logBlocks: Schema.optional(Schema.Boolean),
        }).pipe(
          Schema.encodeKeys({ logAll: "log_all", logBlocks: "log_blocks" }),
        ),
      ),
      http: Schema.optional(
        Schema.Struct({
          logAll: Schema.optional(Schema.Boolean),
          logBlocks: Schema.optional(Schema.Boolean),
        }).pipe(
          Schema.encodeKeys({ logAll: "log_all", logBlocks: "log_blocks" }),
        ),
      ),
      l4: Schema.optional(
        Schema.Struct({
          logAll: Schema.optional(Schema.Boolean),
          logBlocks: Schema.optional(Schema.Boolean),
        }).pipe(
          Schema.encodeKeys({ logAll: "log_all", logBlocks: "log_blocks" }),
        ),
      ),
    }),
  ),
}).pipe(
  Schema.encodeKeys({
    redactPii: "redact_pii",
    settingsByRuleType: "settings_by_rule_type",
  }),
) as unknown as Schema.Schema<PutGatewayLoggingResponse>;

export type PutGatewayLoggingError = CommonErrors;

export const putGatewayLogging: API.OperationMethod<
  PutGatewayLoggingRequest,
  PutGatewayLoggingResponse,
  PutGatewayLoggingError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutGatewayLoggingRequest,
  output: PutGatewayLoggingResponse,
  errors: [],
}));

// =============================================================================
// GatewayProxyEndpoint
// =============================================================================

export interface GetGatewayProxyEndpointRequest {
  proxyEndpointId: string;
  accountId: string;
}

export const GetGatewayProxyEndpointRequest = Schema.Struct({
  proxyEndpointId: Schema.String.pipe(T.HttpPath("proxyEndpointId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/gateway/proxy_endpoints/{proxyEndpointId}",
  }),
) as unknown as Schema.Schema<GetGatewayProxyEndpointRequest>;

export type GetGatewayProxyEndpointResponse =
  | {
      ips: string[];
      name: string;
      id?: string;
      createdAt?: string;
      kind?: "ip";
      subdomain?: string;
      updatedAt?: string;
    }
  | {
      kind: "identity";
      name: string;
      id?: string;
      createdAt?: string;
      subdomain?: string;
      updatedAt?: string;
    };

export const GetGatewayProxyEndpointResponse = Schema.Union([
  Schema.Struct({
    ips: Schema.Array(Schema.String),
    name: Schema.String,
    id: Schema.optional(Schema.String),
    createdAt: Schema.optional(Schema.String),
    kind: Schema.optional(Schema.Literal("ip")),
    subdomain: Schema.optional(Schema.String),
    updatedAt: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      ips: "ips",
      name: "name",
      id: "id",
      createdAt: "created_at",
      kind: "kind",
      subdomain: "subdomain",
      updatedAt: "updated_at",
    }),
  ),
  Schema.Struct({
    kind: Schema.Literal("identity"),
    name: Schema.String,
    id: Schema.optional(Schema.String),
    createdAt: Schema.optional(Schema.String),
    subdomain: Schema.optional(Schema.String),
    updatedAt: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      kind: "kind",
      name: "name",
      id: "id",
      createdAt: "created_at",
      subdomain: "subdomain",
      updatedAt: "updated_at",
    }),
  ),
]) as unknown as Schema.Schema<GetGatewayProxyEndpointResponse>;

export type GetGatewayProxyEndpointError = CommonErrors;

export const getGatewayProxyEndpoint: API.OperationMethod<
  GetGatewayProxyEndpointRequest,
  GetGatewayProxyEndpointResponse,
  GetGatewayProxyEndpointError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetGatewayProxyEndpointRequest,
  output: GetGatewayProxyEndpointResponse,
  errors: [],
}));

export interface ListGatewayProxyEndpointsRequest {
  accountId: string;
}

export const ListGatewayProxyEndpointsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/gateway/proxy_endpoints",
  }),
) as unknown as Schema.Schema<ListGatewayProxyEndpointsRequest>;

export type ListGatewayProxyEndpointsResponse = (
  | {
      ips: string[];
      name: string;
      id?: string;
      createdAt?: string;
      kind?: "ip";
      subdomain?: string;
      updatedAt?: string;
    }
  | {
      kind: "identity";
      name: string;
      id?: string;
      createdAt?: string;
      subdomain?: string;
      updatedAt?: string;
    }
)[];

export const ListGatewayProxyEndpointsResponse = Schema.Array(
  Schema.Union([
    Schema.Struct({
      ips: Schema.Array(Schema.String),
      name: Schema.String,
      id: Schema.optional(Schema.String),
      createdAt: Schema.optional(Schema.String),
      kind: Schema.optional(Schema.Literal("ip")),
      subdomain: Schema.optional(Schema.String),
      updatedAt: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        ips: "ips",
        name: "name",
        id: "id",
        createdAt: "created_at",
        kind: "kind",
        subdomain: "subdomain",
        updatedAt: "updated_at",
      }),
    ),
    Schema.Struct({
      kind: Schema.Literal("identity"),
      name: Schema.String,
      id: Schema.optional(Schema.String),
      createdAt: Schema.optional(Schema.String),
      subdomain: Schema.optional(Schema.String),
      updatedAt: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        kind: "kind",
        name: "name",
        id: "id",
        createdAt: "created_at",
        subdomain: "subdomain",
        updatedAt: "updated_at",
      }),
    ),
  ]),
) as unknown as Schema.Schema<ListGatewayProxyEndpointsResponse>;

export type ListGatewayProxyEndpointsError = CommonErrors;

export const listGatewayProxyEndpoints: API.OperationMethod<
  ListGatewayProxyEndpointsRequest,
  ListGatewayProxyEndpointsResponse,
  ListGatewayProxyEndpointsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListGatewayProxyEndpointsRequest,
  output: ListGatewayProxyEndpointsResponse,
  errors: [],
}));

export interface CreateGatewayProxyEndpointRequest {
  /** Path param: */
  accountId: string;
  /** Body param: Specify the name of the proxy endpoint. */
  name: string;
  /** Body param: The proxy endpoint kind */
  kind?: "ip";
}

export const CreateGatewayProxyEndpointRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.String,
  kind: Schema.optional(Schema.Literal("ip")),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/gateway/proxy_endpoints",
  }),
) as unknown as Schema.Schema<CreateGatewayProxyEndpointRequest>;

export type CreateGatewayProxyEndpointResponse =
  | {
      ips: string[];
      name: string;
      id?: string;
      createdAt?: string;
      kind?: "ip";
      subdomain?: string;
      updatedAt?: string;
    }
  | {
      kind: "identity";
      name: string;
      id?: string;
      createdAt?: string;
      subdomain?: string;
      updatedAt?: string;
    };

export const CreateGatewayProxyEndpointResponse = Schema.Union([
  Schema.Struct({
    ips: Schema.Array(Schema.String),
    name: Schema.String,
    id: Schema.optional(Schema.String),
    createdAt: Schema.optional(Schema.String),
    kind: Schema.optional(Schema.Literal("ip")),
    subdomain: Schema.optional(Schema.String),
    updatedAt: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      ips: "ips",
      name: "name",
      id: "id",
      createdAt: "created_at",
      kind: "kind",
      subdomain: "subdomain",
      updatedAt: "updated_at",
    }),
  ),
  Schema.Struct({
    kind: Schema.Literal("identity"),
    name: Schema.String,
    id: Schema.optional(Schema.String),
    createdAt: Schema.optional(Schema.String),
    subdomain: Schema.optional(Schema.String),
    updatedAt: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      kind: "kind",
      name: "name",
      id: "id",
      createdAt: "created_at",
      subdomain: "subdomain",
      updatedAt: "updated_at",
    }),
  ),
]) as unknown as Schema.Schema<CreateGatewayProxyEndpointResponse>;

export type CreateGatewayProxyEndpointError = CommonErrors;

export const createGatewayProxyEndpoint: API.OperationMethod<
  CreateGatewayProxyEndpointRequest,
  CreateGatewayProxyEndpointResponse,
  CreateGatewayProxyEndpointError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateGatewayProxyEndpointRequest,
  output: CreateGatewayProxyEndpointResponse,
  errors: [],
}));

export interface PatchGatewayProxyEndpointRequest {
  proxyEndpointId: string;
  /** Path param: */
  accountId: string;
  /** Body param: Specify the list of CIDRs to restrict ingress connections. */
  ips?: string[];
  /** Body param: Specify the name of the proxy endpoint. */
  name?: string;
}

export const PatchGatewayProxyEndpointRequest = Schema.Struct({
  proxyEndpointId: Schema.String.pipe(T.HttpPath("proxyEndpointId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  ips: Schema.optional(Schema.Array(Schema.String)),
  name: Schema.optional(Schema.String),
}).pipe(
  T.Http({
    method: "PATCH",
    path: "/accounts/{account_id}/gateway/proxy_endpoints/{proxyEndpointId}",
  }),
) as unknown as Schema.Schema<PatchGatewayProxyEndpointRequest>;

export type PatchGatewayProxyEndpointResponse =
  | {
      ips: string[];
      name: string;
      id?: string;
      createdAt?: string;
      kind?: "ip";
      subdomain?: string;
      updatedAt?: string;
    }
  | {
      kind: "identity";
      name: string;
      id?: string;
      createdAt?: string;
      subdomain?: string;
      updatedAt?: string;
    };

export const PatchGatewayProxyEndpointResponse = Schema.Union([
  Schema.Struct({
    ips: Schema.Array(Schema.String),
    name: Schema.String,
    id: Schema.optional(Schema.String),
    createdAt: Schema.optional(Schema.String),
    kind: Schema.optional(Schema.Literal("ip")),
    subdomain: Schema.optional(Schema.String),
    updatedAt: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      ips: "ips",
      name: "name",
      id: "id",
      createdAt: "created_at",
      kind: "kind",
      subdomain: "subdomain",
      updatedAt: "updated_at",
    }),
  ),
  Schema.Struct({
    kind: Schema.Literal("identity"),
    name: Schema.String,
    id: Schema.optional(Schema.String),
    createdAt: Schema.optional(Schema.String),
    subdomain: Schema.optional(Schema.String),
    updatedAt: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      kind: "kind",
      name: "name",
      id: "id",
      createdAt: "created_at",
      subdomain: "subdomain",
      updatedAt: "updated_at",
    }),
  ),
]) as unknown as Schema.Schema<PatchGatewayProxyEndpointResponse>;

export type PatchGatewayProxyEndpointError = CommonErrors;

export const patchGatewayProxyEndpoint: API.OperationMethod<
  PatchGatewayProxyEndpointRequest,
  PatchGatewayProxyEndpointResponse,
  PatchGatewayProxyEndpointError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchGatewayProxyEndpointRequest,
  output: PatchGatewayProxyEndpointResponse,
  errors: [],
}));

export interface DeleteGatewayProxyEndpointRequest {
  proxyEndpointId: string;
  accountId: string;
}

export const DeleteGatewayProxyEndpointRequest = Schema.Struct({
  proxyEndpointId: Schema.String.pipe(T.HttpPath("proxyEndpointId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/gateway/proxy_endpoints/{proxyEndpointId}",
  }),
) as unknown as Schema.Schema<DeleteGatewayProxyEndpointRequest>;

export type DeleteGatewayProxyEndpointResponse = unknown;

export const DeleteGatewayProxyEndpointResponse =
  Schema.Unknown as unknown as Schema.Schema<DeleteGatewayProxyEndpointResponse>;

export type DeleteGatewayProxyEndpointError = CommonErrors;

export const deleteGatewayProxyEndpoint: API.OperationMethod<
  DeleteGatewayProxyEndpointRequest,
  DeleteGatewayProxyEndpointResponse,
  DeleteGatewayProxyEndpointError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteGatewayProxyEndpointRequest,
  output: DeleteGatewayProxyEndpointResponse,
  errors: [],
}));

// =============================================================================
// GatewayRule
// =============================================================================

export interface GetGatewayRuleRequest {
  ruleId: string;
  accountId: string;
}

export const GetGatewayRuleRequest = Schema.Struct({
  ruleId: Schema.String.pipe(T.HttpPath("ruleId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/gateway/rules/{ruleId}",
  }),
) as unknown as Schema.Schema<GetGatewayRuleRequest>;

export interface GetGatewayRuleResponse {
  /** Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`. */
  action:
    | "on"
    | "off"
    | "allow"
    | "block"
    | "scan"
    | "noscan"
    | "safesearch"
    | "ytrestricted"
    | "isolate"
    | "noisolate"
    | "override"
    | "l4_override"
    | "egress"
    | "resolve"
    | "quarantine"
    | "redirect";
  /** Specify whether the rule is enabled. */
  enabled: boolean;
  /** Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value. */
  filters: ("http" | "dns" | "l4" | "egress" | "dns_resolver")[];
  /** Specify the rule name. */
  name: string;
  /** Set the order of your rules. Lower values indicate higher precedence. At each processing phase, evaluate applicable rules in ascending order of this value. Refer to [Order of enforcement](http://devel */
  precedence: number;
  /** Specify the wirefilter expression used for traffic matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression */
  traffic: string;
  /** Identify the API resource with a UUID. */
  id?: string;
  createdAt?: string;
  /** Indicate the date of deletion, if any. */
  deletedAt?: string | null;
  /** Specify the rule description. */
  description?: string;
  /** Specify the wirefilter expression used for device posture check. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expres */
  devicePosture?: string;
  /** Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This does not apply to HTTP or network policies. Settable o */
  expiration?: {
    expiresAt: string;
    duration?: number;
    expired?: boolean;
  } | null;
  /** Specify the wirefilter expression used for identity matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expressio */
  identity?: string;
  /** Indicate that this rule is shared via the Orgs API and read only. */
  readOnly?: boolean;
  /** Defines settings for this rule. Settings apply only to specific rule types and must use compatible selectors. If Terraform detects drift, confirm the setting supports your rule type and check whether  */
  ruleSettings?: {
    addHeaders?: Record<string, unknown> | null;
    allowChildBypass?: boolean | null;
    auditSsh?: { commandLogging?: boolean } | null;
    bisoAdminControls?: {
      copy?: "enabled" | "disabled" | "remote_only";
      dcp?: boolean;
      dd?: boolean;
      dk?: boolean;
      download?: "enabled" | "disabled" | "remote_only";
      dp?: boolean;
      du?: boolean;
      keyboard?: "enabled" | "disabled";
      paste?: "enabled" | "disabled" | "remote_only";
      printing?: "enabled" | "disabled";
      upload?: "enabled" | "disabled";
      version?: "v1" | "v2";
    };
    blockPage?: { targetUri: string; includeContext?: boolean } | null;
    blockPageEnabled?: boolean;
    blockReason?: string | null;
    bypassParentRule?: boolean | null;
    checkSession?: { duration?: string; enforce?: boolean } | null;
    dnsResolvers?: { ipv4?: unknown[]; ipv6?: unknown[] } | null;
    egress?: { ipv4?: string; ipv4Fallback?: string; ipv6?: string } | null;
    forensicCopy?: { enabled?: boolean } | null;
    ignoreCnameCategoryMatches?: boolean;
    insecureDisableDnssecValidation?: boolean;
    ipCategories?: boolean;
    ipIndicatorFeeds?: boolean;
    l4override?: { ip?: string; port?: number } | null;
    notificationSettings?: {
      enabled?: boolean;
      includeContext?: boolean;
      msg?: string;
      supportUrl?: string;
    } | null;
    overrideHost?: string;
    overrideIps?: string[] | null;
    payloadLog?: { enabled?: boolean } | null;
    quarantine?: {
      fileTypes?: (
        | "exe"
        | "pdf"
        | "doc"
        | "docm"
        | "docx"
        | "rtf"
        | "ppt"
        | "pptx"
        | "xls"
        | "xlsm"
        | "xlsx"
        | "zip"
        | "rar"
      )[];
    } | null;
    redirect?: {
      targetUri: string;
      includeContext?: boolean;
      preservePathAndQuery?: boolean;
    } | null;
    resolveDnsInternally?: {
      fallback?: "none" | "public_dns";
      viewId?: string;
    } | null;
    resolveDnsThroughCloudflare?: boolean | null;
    untrustedCert?: { action?: "pass_through" | "block" | "error" } | null;
  };
  /** Defines the schedule for activating DNS policies. Settable only for `dns` and `dns_resolver` rules. */
  schedule?: {
    fri?: string;
    mon?: string;
    sat?: string;
    sun?: string;
    thu?: string;
    timeZone?: string;
    tue?: string;
    wed?: string;
  } | null;
  /** Indicate that this rule is sharable via the Orgs API. */
  sharable?: boolean;
  /** Provide the account tag of the account that created the rule. */
  sourceAccount?: string;
  updatedAt?: string;
  /** Indicate the version number of the rule(read-only). */
  version?: number;
  /** Indicate a warning for a misconfigured rule, if any. */
  warningStatus?: string | null;
}

export const GetGatewayRuleResponse = Schema.Struct({
  action: Schema.Literals([
    "on",
    "off",
    "allow",
    "block",
    "scan",
    "noscan",
    "safesearch",
    "ytrestricted",
    "isolate",
    "noisolate",
    "override",
    "l4_override",
    "egress",
    "resolve",
    "quarantine",
    "redirect",
  ]),
  enabled: Schema.Boolean,
  filters: Schema.Array(
    Schema.Literals(["http", "dns", "l4", "egress", "dns_resolver"]),
  ),
  name: Schema.String,
  precedence: Schema.Number,
  traffic: Schema.String,
  id: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  deletedAt: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  description: Schema.optional(Schema.String),
  devicePosture: Schema.optional(Schema.String),
  expiration: Schema.optional(
    Schema.Union([
      Schema.Struct({
        expiresAt: Schema.String,
        duration: Schema.optional(Schema.Number),
        expired: Schema.optional(Schema.Boolean),
      }).pipe(
        Schema.encodeKeys({
          expiresAt: "expires_at",
          duration: "duration",
          expired: "expired",
        }),
      ),
      Schema.Null,
    ]),
  ),
  identity: Schema.optional(Schema.String),
  readOnly: Schema.optional(Schema.Boolean),
  ruleSettings: Schema.optional(
    Schema.Struct({
      addHeaders: Schema.optional(
        Schema.Union([Schema.Struct({}), Schema.Null]),
      ),
      allowChildBypass: Schema.optional(
        Schema.Union([Schema.Boolean, Schema.Null]),
      ),
      auditSsh: Schema.optional(
        Schema.Union([
          Schema.Struct({
            commandLogging: Schema.optional(Schema.Boolean),
          }).pipe(Schema.encodeKeys({ commandLogging: "command_logging" })),
          Schema.Null,
        ]),
      ),
      bisoAdminControls: Schema.optional(
        Schema.Struct({
          copy: Schema.optional(
            Schema.Literals(["enabled", "disabled", "remote_only"]),
          ),
          dcp: Schema.optional(Schema.Boolean),
          dd: Schema.optional(Schema.Boolean),
          dk: Schema.optional(Schema.Boolean),
          download: Schema.optional(
            Schema.Literals(["enabled", "disabled", "remote_only"]),
          ),
          dp: Schema.optional(Schema.Boolean),
          du: Schema.optional(Schema.Boolean),
          keyboard: Schema.optional(Schema.Literals(["enabled", "disabled"])),
          paste: Schema.optional(
            Schema.Literals(["enabled", "disabled", "remote_only"]),
          ),
          printing: Schema.optional(Schema.Literals(["enabled", "disabled"])),
          upload: Schema.optional(Schema.Literals(["enabled", "disabled"])),
          version: Schema.optional(Schema.Literals(["v1", "v2"])),
        }),
      ),
      blockPage: Schema.optional(
        Schema.Union([
          Schema.Struct({
            targetUri: Schema.String,
            includeContext: Schema.optional(Schema.Boolean),
          }).pipe(
            Schema.encodeKeys({
              targetUri: "target_uri",
              includeContext: "include_context",
            }),
          ),
          Schema.Null,
        ]),
      ),
      blockPageEnabled: Schema.optional(Schema.Boolean),
      blockReason: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      bypassParentRule: Schema.optional(
        Schema.Union([Schema.Boolean, Schema.Null]),
      ),
      checkSession: Schema.optional(
        Schema.Union([
          Schema.Struct({
            duration: Schema.optional(Schema.String),
            enforce: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      dnsResolvers: Schema.optional(
        Schema.Union([
          Schema.Struct({
            ipv4: Schema.optional(Schema.Array(Schema.Unknown)),
            ipv6: Schema.optional(Schema.Array(Schema.Unknown)),
          }),
          Schema.Null,
        ]),
      ),
      egress: Schema.optional(
        Schema.Union([
          Schema.Struct({
            ipv4: Schema.optional(Schema.String),
            ipv4Fallback: Schema.optional(Schema.String),
            ipv6: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              ipv4: "ipv4",
              ipv4Fallback: "ipv4_fallback",
              ipv6: "ipv6",
            }),
          ),
          Schema.Null,
        ]),
      ),
      forensicCopy: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      ignoreCnameCategoryMatches: Schema.optional(Schema.Boolean),
      insecureDisableDnssecValidation: Schema.optional(Schema.Boolean),
      ipCategories: Schema.optional(Schema.Boolean),
      ipIndicatorFeeds: Schema.optional(Schema.Boolean),
      l4override: Schema.optional(
        Schema.Union([
          Schema.Struct({
            ip: Schema.optional(Schema.String),
            port: Schema.optional(Schema.Number),
          }),
          Schema.Null,
        ]),
      ),
      notificationSettings: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
            includeContext: Schema.optional(Schema.Boolean),
            msg: Schema.optional(Schema.String),
            supportUrl: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              includeContext: "include_context",
              msg: "msg",
              supportUrl: "support_url",
            }),
          ),
          Schema.Null,
        ]),
      ),
      overrideHost: Schema.optional(Schema.String),
      overrideIps: Schema.optional(
        Schema.Union([Schema.Array(Schema.String), Schema.Null]),
      ),
      payloadLog: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      quarantine: Schema.optional(
        Schema.Union([
          Schema.Struct({
            fileTypes: Schema.optional(
              Schema.Array(
                Schema.Literals([
                  "exe",
                  "pdf",
                  "doc",
                  "docm",
                  "docx",
                  "rtf",
                  "ppt",
                  "pptx",
                  "xls",
                  "xlsm",
                  "xlsx",
                  "zip",
                  "rar",
                ]),
              ),
            ),
          }).pipe(Schema.encodeKeys({ fileTypes: "file_types" })),
          Schema.Null,
        ]),
      ),
      redirect: Schema.optional(
        Schema.Union([
          Schema.Struct({
            targetUri: Schema.String,
            includeContext: Schema.optional(Schema.Boolean),
            preservePathAndQuery: Schema.optional(Schema.Boolean),
          }).pipe(
            Schema.encodeKeys({
              targetUri: "target_uri",
              includeContext: "include_context",
              preservePathAndQuery: "preserve_path_and_query",
            }),
          ),
          Schema.Null,
        ]),
      ),
      resolveDnsInternally: Schema.optional(
        Schema.Union([
          Schema.Struct({
            fallback: Schema.optional(Schema.Literals(["none", "public_dns"])),
            viewId: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({ fallback: "fallback", viewId: "view_id" }),
          ),
          Schema.Null,
        ]),
      ),
      resolveDnsThroughCloudflare: Schema.optional(
        Schema.Union([Schema.Boolean, Schema.Null]),
      ),
      untrustedCert: Schema.optional(
        Schema.Union([
          Schema.Struct({
            action: Schema.optional(
              Schema.Literals(["pass_through", "block", "error"]),
            ),
          }),
          Schema.Null,
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        addHeaders: "add_headers",
        allowChildBypass: "allow_child_bypass",
        auditSsh: "audit_ssh",
        bisoAdminControls: "biso_admin_controls",
        blockPage: "block_page",
        blockPageEnabled: "block_page_enabled",
        blockReason: "block_reason",
        bypassParentRule: "bypass_parent_rule",
        checkSession: "check_session",
        dnsResolvers: "dns_resolvers",
        egress: "egress",
        forensicCopy: "forensic_copy",
        ignoreCnameCategoryMatches: "ignore_cname_category_matches",
        insecureDisableDnssecValidation: "insecure_disable_dnssec_validation",
        ipCategories: "ip_categories",
        ipIndicatorFeeds: "ip_indicator_feeds",
        l4override: "l4override",
        notificationSettings: "notification_settings",
        overrideHost: "override_host",
        overrideIps: "override_ips",
        payloadLog: "payload_log",
        quarantine: "quarantine",
        redirect: "redirect",
        resolveDnsInternally: "resolve_dns_internally",
        resolveDnsThroughCloudflare: "resolve_dns_through_cloudflare",
        untrustedCert: "untrusted_cert",
      }),
    ),
  ),
  schedule: Schema.optional(
    Schema.Union([
      Schema.Struct({
        fri: Schema.optional(Schema.String),
        mon: Schema.optional(Schema.String),
        sat: Schema.optional(Schema.String),
        sun: Schema.optional(Schema.String),
        thu: Schema.optional(Schema.String),
        timeZone: Schema.optional(Schema.String),
        tue: Schema.optional(Schema.String),
        wed: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          fri: "fri",
          mon: "mon",
          sat: "sat",
          sun: "sun",
          thu: "thu",
          timeZone: "time_zone",
          tue: "tue",
          wed: "wed",
        }),
      ),
      Schema.Null,
    ]),
  ),
  sharable: Schema.optional(Schema.Boolean),
  sourceAccount: Schema.optional(Schema.String),
  updatedAt: Schema.optional(Schema.String),
  version: Schema.optional(Schema.Number),
  warningStatus: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    action: "action",
    enabled: "enabled",
    filters: "filters",
    name: "name",
    precedence: "precedence",
    traffic: "traffic",
    id: "id",
    createdAt: "created_at",
    deletedAt: "deleted_at",
    description: "description",
    devicePosture: "device_posture",
    expiration: "expiration",
    identity: "identity",
    readOnly: "read_only",
    ruleSettings: "rule_settings",
    schedule: "schedule",
    sharable: "sharable",
    sourceAccount: "source_account",
    updatedAt: "updated_at",
    version: "version",
    warningStatus: "warning_status",
  }),
) as unknown as Schema.Schema<GetGatewayRuleResponse>;

export type GetGatewayRuleError = CommonErrors;

export const getGatewayRule: API.OperationMethod<
  GetGatewayRuleRequest,
  GetGatewayRuleResponse,
  GetGatewayRuleError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetGatewayRuleRequest,
  output: GetGatewayRuleResponse,
  errors: [],
}));

export interface ListGatewayRulesRequest {
  accountId: string;
}

export const ListGatewayRulesRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/gateway/rules" }),
) as unknown as Schema.Schema<ListGatewayRulesRequest>;

export type ListGatewayRulesResponse = {
  action:
    | "on"
    | "off"
    | "allow"
    | "block"
    | "scan"
    | "noscan"
    | "safesearch"
    | "ytrestricted"
    | "isolate"
    | "noisolate"
    | "override"
    | "l4_override"
    | "egress"
    | "resolve"
    | "quarantine"
    | "redirect";
  enabled: boolean;
  filters: ("http" | "dns" | "l4" | "egress" | "dns_resolver")[];
  name: string;
  precedence: number;
  traffic: string;
  id?: string;
  createdAt?: string;
  deletedAt?: string | null;
  description?: string;
  devicePosture?: string;
  expiration?: {
    expiresAt: string;
    duration?: number;
    expired?: boolean;
  } | null;
  identity?: string;
  readOnly?: boolean;
  ruleSettings?: {
    addHeaders?: Record<string, unknown> | null;
    allowChildBypass?: boolean | null;
    auditSsh?: { commandLogging?: boolean } | null;
    bisoAdminControls?: {
      copy?: "enabled" | "disabled" | "remote_only";
      dcp?: boolean;
      dd?: boolean;
      dk?: boolean;
      download?: "enabled" | "disabled" | "remote_only";
      dp?: boolean;
      du?: boolean;
      keyboard?: "enabled" | "disabled";
      paste?: "enabled" | "disabled" | "remote_only";
      printing?: "enabled" | "disabled";
      upload?: "enabled" | "disabled";
      version?: "v1" | "v2";
    };
    blockPage?: { targetUri: string; includeContext?: boolean } | null;
    blockPageEnabled?: boolean;
    blockReason?: string | null;
    bypassParentRule?: boolean | null;
    checkSession?: { duration?: string; enforce?: boolean } | null;
    dnsResolvers?: { ipv4?: unknown[]; ipv6?: unknown[] } | null;
    egress?: { ipv4?: string; ipv4Fallback?: string; ipv6?: string } | null;
    forensicCopy?: { enabled?: boolean } | null;
    ignoreCnameCategoryMatches?: boolean;
    insecureDisableDnssecValidation?: boolean;
    ipCategories?: boolean;
    ipIndicatorFeeds?: boolean;
    l4override?: { ip?: string; port?: number } | null;
    notificationSettings?: {
      enabled?: boolean;
      includeContext?: boolean;
      msg?: string;
      supportUrl?: string;
    } | null;
    overrideHost?: string;
    overrideIps?: string[] | null;
    payloadLog?: { enabled?: boolean } | null;
    quarantine?: {
      fileTypes?: (
        | "exe"
        | "pdf"
        | "doc"
        | "docm"
        | "docx"
        | "rtf"
        | "ppt"
        | "pptx"
        | "xls"
        | "xlsm"
        | "xlsx"
        | "zip"
        | "rar"
      )[];
    } | null;
    redirect?: {
      targetUri: string;
      includeContext?: boolean;
      preservePathAndQuery?: boolean;
    } | null;
    resolveDnsInternally?: {
      fallback?: "none" | "public_dns";
      viewId?: string;
    } | null;
    resolveDnsThroughCloudflare?: boolean | null;
    untrustedCert?: { action?: "pass_through" | "block" | "error" } | null;
  };
  schedule?: {
    fri?: string;
    mon?: string;
    sat?: string;
    sun?: string;
    thu?: string;
    timeZone?: string;
    tue?: string;
    wed?: string;
  } | null;
  sharable?: boolean;
  sourceAccount?: string;
  updatedAt?: string;
  version?: number;
  warningStatus?: string | null;
}[];

export const ListGatewayRulesResponse = Schema.Array(
  Schema.Struct({
    action: Schema.Literals([
      "on",
      "off",
      "allow",
      "block",
      "scan",
      "noscan",
      "safesearch",
      "ytrestricted",
      "isolate",
      "noisolate",
      "override",
      "l4_override",
      "egress",
      "resolve",
      "quarantine",
      "redirect",
    ]),
    enabled: Schema.Boolean,
    filters: Schema.Array(
      Schema.Literals(["http", "dns", "l4", "egress", "dns_resolver"]),
    ),
    name: Schema.String,
    precedence: Schema.Number,
    traffic: Schema.String,
    id: Schema.optional(Schema.String),
    createdAt: Schema.optional(Schema.String),
    deletedAt: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    description: Schema.optional(Schema.String),
    devicePosture: Schema.optional(Schema.String),
    expiration: Schema.optional(
      Schema.Union([
        Schema.Struct({
          expiresAt: Schema.String,
          duration: Schema.optional(Schema.Number),
          expired: Schema.optional(Schema.Boolean),
        }).pipe(
          Schema.encodeKeys({
            expiresAt: "expires_at",
            duration: "duration",
            expired: "expired",
          }),
        ),
        Schema.Null,
      ]),
    ),
    identity: Schema.optional(Schema.String),
    readOnly: Schema.optional(Schema.Boolean),
    ruleSettings: Schema.optional(
      Schema.Struct({
        addHeaders: Schema.optional(
          Schema.Union([Schema.Struct({}), Schema.Null]),
        ),
        allowChildBypass: Schema.optional(
          Schema.Union([Schema.Boolean, Schema.Null]),
        ),
        auditSsh: Schema.optional(
          Schema.Union([
            Schema.Struct({
              commandLogging: Schema.optional(Schema.Boolean),
            }).pipe(Schema.encodeKeys({ commandLogging: "command_logging" })),
            Schema.Null,
          ]),
        ),
        bisoAdminControls: Schema.optional(
          Schema.Struct({
            copy: Schema.optional(
              Schema.Literals(["enabled", "disabled", "remote_only"]),
            ),
            dcp: Schema.optional(Schema.Boolean),
            dd: Schema.optional(Schema.Boolean),
            dk: Schema.optional(Schema.Boolean),
            download: Schema.optional(
              Schema.Literals(["enabled", "disabled", "remote_only"]),
            ),
            dp: Schema.optional(Schema.Boolean),
            du: Schema.optional(Schema.Boolean),
            keyboard: Schema.optional(Schema.Literals(["enabled", "disabled"])),
            paste: Schema.optional(
              Schema.Literals(["enabled", "disabled", "remote_only"]),
            ),
            printing: Schema.optional(Schema.Literals(["enabled", "disabled"])),
            upload: Schema.optional(Schema.Literals(["enabled", "disabled"])),
            version: Schema.optional(Schema.Literals(["v1", "v2"])),
          }),
        ),
        blockPage: Schema.optional(
          Schema.Union([
            Schema.Struct({
              targetUri: Schema.String,
              includeContext: Schema.optional(Schema.Boolean),
            }).pipe(
              Schema.encodeKeys({
                targetUri: "target_uri",
                includeContext: "include_context",
              }),
            ),
            Schema.Null,
          ]),
        ),
        blockPageEnabled: Schema.optional(Schema.Boolean),
        blockReason: Schema.optional(
          Schema.Union([Schema.String, Schema.Null]),
        ),
        bypassParentRule: Schema.optional(
          Schema.Union([Schema.Boolean, Schema.Null]),
        ),
        checkSession: Schema.optional(
          Schema.Union([
            Schema.Struct({
              duration: Schema.optional(Schema.String),
              enforce: Schema.optional(Schema.Boolean),
            }),
            Schema.Null,
          ]),
        ),
        dnsResolvers: Schema.optional(
          Schema.Union([
            Schema.Struct({
              ipv4: Schema.optional(Schema.Array(Schema.Unknown)),
              ipv6: Schema.optional(Schema.Array(Schema.Unknown)),
            }),
            Schema.Null,
          ]),
        ),
        egress: Schema.optional(
          Schema.Union([
            Schema.Struct({
              ipv4: Schema.optional(Schema.String),
              ipv4Fallback: Schema.optional(Schema.String),
              ipv6: Schema.optional(Schema.String),
            }).pipe(
              Schema.encodeKeys({
                ipv4: "ipv4",
                ipv4Fallback: "ipv4_fallback",
                ipv6: "ipv6",
              }),
            ),
            Schema.Null,
          ]),
        ),
        forensicCopy: Schema.optional(
          Schema.Union([
            Schema.Struct({
              enabled: Schema.optional(Schema.Boolean),
            }),
            Schema.Null,
          ]),
        ),
        ignoreCnameCategoryMatches: Schema.optional(Schema.Boolean),
        insecureDisableDnssecValidation: Schema.optional(Schema.Boolean),
        ipCategories: Schema.optional(Schema.Boolean),
        ipIndicatorFeeds: Schema.optional(Schema.Boolean),
        l4override: Schema.optional(
          Schema.Union([
            Schema.Struct({
              ip: Schema.optional(Schema.String),
              port: Schema.optional(Schema.Number),
            }),
            Schema.Null,
          ]),
        ),
        notificationSettings: Schema.optional(
          Schema.Union([
            Schema.Struct({
              enabled: Schema.optional(Schema.Boolean),
              includeContext: Schema.optional(Schema.Boolean),
              msg: Schema.optional(Schema.String),
              supportUrl: Schema.optional(Schema.String),
            }).pipe(
              Schema.encodeKeys({
                enabled: "enabled",
                includeContext: "include_context",
                msg: "msg",
                supportUrl: "support_url",
              }),
            ),
            Schema.Null,
          ]),
        ),
        overrideHost: Schema.optional(Schema.String),
        overrideIps: Schema.optional(
          Schema.Union([Schema.Array(Schema.String), Schema.Null]),
        ),
        payloadLog: Schema.optional(
          Schema.Union([
            Schema.Struct({
              enabled: Schema.optional(Schema.Boolean),
            }),
            Schema.Null,
          ]),
        ),
        quarantine: Schema.optional(
          Schema.Union([
            Schema.Struct({
              fileTypes: Schema.optional(
                Schema.Array(
                  Schema.Literals([
                    "exe",
                    "pdf",
                    "doc",
                    "docm",
                    "docx",
                    "rtf",
                    "ppt",
                    "pptx",
                    "xls",
                    "xlsm",
                    "xlsx",
                    "zip",
                    "rar",
                  ]),
                ),
              ),
            }).pipe(Schema.encodeKeys({ fileTypes: "file_types" })),
            Schema.Null,
          ]),
        ),
        redirect: Schema.optional(
          Schema.Union([
            Schema.Struct({
              targetUri: Schema.String,
              includeContext: Schema.optional(Schema.Boolean),
              preservePathAndQuery: Schema.optional(Schema.Boolean),
            }).pipe(
              Schema.encodeKeys({
                targetUri: "target_uri",
                includeContext: "include_context",
                preservePathAndQuery: "preserve_path_and_query",
              }),
            ),
            Schema.Null,
          ]),
        ),
        resolveDnsInternally: Schema.optional(
          Schema.Union([
            Schema.Struct({
              fallback: Schema.optional(
                Schema.Literals(["none", "public_dns"]),
              ),
              viewId: Schema.optional(Schema.String),
            }).pipe(
              Schema.encodeKeys({ fallback: "fallback", viewId: "view_id" }),
            ),
            Schema.Null,
          ]),
        ),
        resolveDnsThroughCloudflare: Schema.optional(
          Schema.Union([Schema.Boolean, Schema.Null]),
        ),
        untrustedCert: Schema.optional(
          Schema.Union([
            Schema.Struct({
              action: Schema.optional(
                Schema.Literals(["pass_through", "block", "error"]),
              ),
            }),
            Schema.Null,
          ]),
        ),
      }).pipe(
        Schema.encodeKeys({
          addHeaders: "add_headers",
          allowChildBypass: "allow_child_bypass",
          auditSsh: "audit_ssh",
          bisoAdminControls: "biso_admin_controls",
          blockPage: "block_page",
          blockPageEnabled: "block_page_enabled",
          blockReason: "block_reason",
          bypassParentRule: "bypass_parent_rule",
          checkSession: "check_session",
          dnsResolvers: "dns_resolvers",
          egress: "egress",
          forensicCopy: "forensic_copy",
          ignoreCnameCategoryMatches: "ignore_cname_category_matches",
          insecureDisableDnssecValidation: "insecure_disable_dnssec_validation",
          ipCategories: "ip_categories",
          ipIndicatorFeeds: "ip_indicator_feeds",
          l4override: "l4override",
          notificationSettings: "notification_settings",
          overrideHost: "override_host",
          overrideIps: "override_ips",
          payloadLog: "payload_log",
          quarantine: "quarantine",
          redirect: "redirect",
          resolveDnsInternally: "resolve_dns_internally",
          resolveDnsThroughCloudflare: "resolve_dns_through_cloudflare",
          untrustedCert: "untrusted_cert",
        }),
      ),
    ),
    schedule: Schema.optional(
      Schema.Union([
        Schema.Struct({
          fri: Schema.optional(Schema.String),
          mon: Schema.optional(Schema.String),
          sat: Schema.optional(Schema.String),
          sun: Schema.optional(Schema.String),
          thu: Schema.optional(Schema.String),
          timeZone: Schema.optional(Schema.String),
          tue: Schema.optional(Schema.String),
          wed: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            fri: "fri",
            mon: "mon",
            sat: "sat",
            sun: "sun",
            thu: "thu",
            timeZone: "time_zone",
            tue: "tue",
            wed: "wed",
          }),
        ),
        Schema.Null,
      ]),
    ),
    sharable: Schema.optional(Schema.Boolean),
    sourceAccount: Schema.optional(Schema.String),
    updatedAt: Schema.optional(Schema.String),
    version: Schema.optional(Schema.Number),
    warningStatus: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }).pipe(
    Schema.encodeKeys({
      action: "action",
      enabled: "enabled",
      filters: "filters",
      name: "name",
      precedence: "precedence",
      traffic: "traffic",
      id: "id",
      createdAt: "created_at",
      deletedAt: "deleted_at",
      description: "description",
      devicePosture: "device_posture",
      expiration: "expiration",
      identity: "identity",
      readOnly: "read_only",
      ruleSettings: "rule_settings",
      schedule: "schedule",
      sharable: "sharable",
      sourceAccount: "source_account",
      updatedAt: "updated_at",
      version: "version",
      warningStatus: "warning_status",
    }),
  ),
) as unknown as Schema.Schema<ListGatewayRulesResponse>;

export type ListGatewayRulesError = CommonErrors;

export const listGatewayRules: API.OperationMethod<
  ListGatewayRulesRequest,
  ListGatewayRulesResponse,
  ListGatewayRulesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListGatewayRulesRequest,
  output: ListGatewayRulesResponse,
  errors: [],
}));

export interface CreateGatewayRuleRequest {
  /** Path param: */
  accountId: string;
  /** Body param: Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`. */
  action:
    | "on"
    | "off"
    | "allow"
    | "block"
    | "scan"
    | "noscan"
    | "safesearch"
    | "ytrestricted"
    | "isolate"
    | "noisolate"
    | "override"
    | "l4_override"
    | "egress"
    | "resolve"
    | "quarantine"
    | "redirect";
  /** Body param: Specify the rule name. */
  name: string;
  /** Body param: Specify the rule description. */
  description?: string;
  /** Body param: Specify the wirefilter expression used for device posture check. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the form */
  devicePosture?: string;
  /** Body param: Specify whether the rule is enabled. */
  enabled?: boolean;
  /** Body param: Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This does not apply to HTTP or network policies */
  expiration?: { expiresAt: string; duration?: number } | null;
  /** Body param: Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value. */
  filters?: ("http" | "dns" | "l4" | "egress" | "dns_resolver")[];
  /** Body param: Specify the wirefilter expression used for identity matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatt */
  identity?: string;
  /** Body param: Set the order of your rules. Lower values indicate higher precedence. At each processing phase, evaluate applicable rules in ascending order of this value. Refer to [Order of enforcement]( */
  precedence?: number;
  /** Body param: Defines settings for this rule. Settings apply only to specific rule types and must use compatible selectors. If Terraform detects drift, confirm the setting supports your rule type and ch */
  ruleSettings?: {
    addHeaders?: Record<string, unknown> | null;
    allowChildBypass?: boolean | null;
    auditSsh?: { commandLogging?: boolean } | null;
    bisoAdminControls?: {
      copy?: "enabled" | "disabled" | "remote_only";
      dcp?: boolean;
      dd?: boolean;
      dk?: boolean;
      download?: "enabled" | "disabled" | "remote_only";
      dp?: boolean;
      du?: boolean;
      keyboard?: "enabled" | "disabled";
      paste?: "enabled" | "disabled" | "remote_only";
      printing?: "enabled" | "disabled";
      upload?: "enabled" | "disabled";
      version?: "v1" | "v2";
    };
    blockPage?: { targetUri: string; includeContext?: boolean } | null;
    blockPageEnabled?: boolean;
    blockReason?: string | null;
    bypassParentRule?: boolean | null;
    checkSession?: { duration?: string; enforce?: boolean } | null;
    dnsResolvers?: { ipv4?: unknown[]; ipv6?: unknown[] } | null;
    egress?: { ipv4?: string; ipv4Fallback?: string; ipv6?: string } | null;
    forensicCopy?: { enabled?: boolean } | null;
    ignoreCnameCategoryMatches?: boolean;
    insecureDisableDnssecValidation?: boolean;
    ipCategories?: boolean;
    ipIndicatorFeeds?: boolean;
    l4override?: { ip?: string; port?: number } | null;
    notificationSettings?: {
      enabled?: boolean;
      includeContext?: boolean;
      msg?: string;
      supportUrl?: string;
    } | null;
    overrideHost?: string;
    overrideIps?: string[] | null;
    payloadLog?: { enabled?: boolean } | null;
    quarantine?: {
      fileTypes?: (
        | "exe"
        | "pdf"
        | "doc"
        | "docm"
        | "docx"
        | "rtf"
        | "ppt"
        | "pptx"
        | "xls"
        | "xlsm"
        | "xlsx"
        | "zip"
        | "rar"
      )[];
    } | null;
    redirect?: {
      targetUri: string;
      includeContext?: boolean;
      preservePathAndQuery?: boolean;
    } | null;
    resolveDnsInternally?: {
      fallback?: "none" | "public_dns";
      viewId?: string;
    } | null;
    resolveDnsThroughCloudflare?: boolean | null;
    untrustedCert?: { action?: "pass_through" | "block" | "error" } | null;
  };
  /** Body param: Defines the schedule for activating DNS policies. Settable only for `dns` and `dns_resolver` rules. */
  schedule?: {
    fri?: string;
    mon?: string;
    sat?: string;
    sun?: string;
    thu?: string;
    timeZone?: string;
    tue?: string;
    wed?: string;
  } | null;
  /** Body param: Specify the wirefilter expression used for traffic matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatte */
  traffic?: string;
}

export const CreateGatewayRuleRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  action: Schema.Literals([
    "on",
    "off",
    "allow",
    "block",
    "scan",
    "noscan",
    "safesearch",
    "ytrestricted",
    "isolate",
    "noisolate",
    "override",
    "l4_override",
    "egress",
    "resolve",
    "quarantine",
    "redirect",
  ]),
  name: Schema.String,
  description: Schema.optional(Schema.String),
  devicePosture: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  expiration: Schema.optional(
    Schema.Union([
      Schema.Struct({
        expiresAt: Schema.String,
        duration: Schema.optional(Schema.Number),
      }).pipe(
        Schema.encodeKeys({ expiresAt: "expires_at", duration: "duration" }),
      ),
      Schema.Null,
    ]),
  ),
  filters: Schema.optional(
    Schema.Array(
      Schema.Literals(["http", "dns", "l4", "egress", "dns_resolver"]),
    ),
  ),
  identity: Schema.optional(Schema.String),
  precedence: Schema.optional(Schema.Number),
  ruleSettings: Schema.optional(
    Schema.Struct({
      addHeaders: Schema.optional(
        Schema.Union([Schema.Struct({}), Schema.Null]),
      ),
      allowChildBypass: Schema.optional(
        Schema.Union([Schema.Boolean, Schema.Null]),
      ),
      auditSsh: Schema.optional(
        Schema.Union([
          Schema.Struct({
            commandLogging: Schema.optional(Schema.Boolean),
          }).pipe(Schema.encodeKeys({ commandLogging: "command_logging" })),
          Schema.Null,
        ]),
      ),
      bisoAdminControls: Schema.optional(
        Schema.Struct({
          copy: Schema.optional(
            Schema.Literals(["enabled", "disabled", "remote_only"]),
          ),
          dcp: Schema.optional(Schema.Boolean),
          dd: Schema.optional(Schema.Boolean),
          dk: Schema.optional(Schema.Boolean),
          download: Schema.optional(
            Schema.Literals(["enabled", "disabled", "remote_only"]),
          ),
          dp: Schema.optional(Schema.Boolean),
          du: Schema.optional(Schema.Boolean),
          keyboard: Schema.optional(Schema.Literals(["enabled", "disabled"])),
          paste: Schema.optional(
            Schema.Literals(["enabled", "disabled", "remote_only"]),
          ),
          printing: Schema.optional(Schema.Literals(["enabled", "disabled"])),
          upload: Schema.optional(Schema.Literals(["enabled", "disabled"])),
          version: Schema.optional(Schema.Literals(["v1", "v2"])),
        }),
      ),
      blockPage: Schema.optional(
        Schema.Union([
          Schema.Struct({
            targetUri: Schema.String,
            includeContext: Schema.optional(Schema.Boolean),
          }).pipe(
            Schema.encodeKeys({
              targetUri: "target_uri",
              includeContext: "include_context",
            }),
          ),
          Schema.Null,
        ]),
      ),
      blockPageEnabled: Schema.optional(Schema.Boolean),
      blockReason: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      bypassParentRule: Schema.optional(
        Schema.Union([Schema.Boolean, Schema.Null]),
      ),
      checkSession: Schema.optional(
        Schema.Union([
          Schema.Struct({
            duration: Schema.optional(Schema.String),
            enforce: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      dnsResolvers: Schema.optional(
        Schema.Union([
          Schema.Struct({
            ipv4: Schema.optional(Schema.Array(Schema.Unknown)),
            ipv6: Schema.optional(Schema.Array(Schema.Unknown)),
          }),
          Schema.Null,
        ]),
      ),
      egress: Schema.optional(
        Schema.Union([
          Schema.Struct({
            ipv4: Schema.optional(Schema.String),
            ipv4Fallback: Schema.optional(Schema.String),
            ipv6: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              ipv4: "ipv4",
              ipv4Fallback: "ipv4_fallback",
              ipv6: "ipv6",
            }),
          ),
          Schema.Null,
        ]),
      ),
      forensicCopy: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      ignoreCnameCategoryMatches: Schema.optional(Schema.Boolean),
      insecureDisableDnssecValidation: Schema.optional(Schema.Boolean),
      ipCategories: Schema.optional(Schema.Boolean),
      ipIndicatorFeeds: Schema.optional(Schema.Boolean),
      l4override: Schema.optional(
        Schema.Union([
          Schema.Struct({
            ip: Schema.optional(Schema.String),
            port: Schema.optional(Schema.Number),
          }),
          Schema.Null,
        ]),
      ),
      notificationSettings: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
            includeContext: Schema.optional(Schema.Boolean),
            msg: Schema.optional(Schema.String),
            supportUrl: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              includeContext: "include_context",
              msg: "msg",
              supportUrl: "support_url",
            }),
          ),
          Schema.Null,
        ]),
      ),
      overrideHost: Schema.optional(Schema.String),
      overrideIps: Schema.optional(
        Schema.Union([Schema.Array(Schema.String), Schema.Null]),
      ),
      payloadLog: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      quarantine: Schema.optional(
        Schema.Union([
          Schema.Struct({
            fileTypes: Schema.optional(
              Schema.Array(
                Schema.Literals([
                  "exe",
                  "pdf",
                  "doc",
                  "docm",
                  "docx",
                  "rtf",
                  "ppt",
                  "pptx",
                  "xls",
                  "xlsm",
                  "xlsx",
                  "zip",
                  "rar",
                ]),
              ),
            ),
          }).pipe(Schema.encodeKeys({ fileTypes: "file_types" })),
          Schema.Null,
        ]),
      ),
      redirect: Schema.optional(
        Schema.Union([
          Schema.Struct({
            targetUri: Schema.String,
            includeContext: Schema.optional(Schema.Boolean),
            preservePathAndQuery: Schema.optional(Schema.Boolean),
          }).pipe(
            Schema.encodeKeys({
              targetUri: "target_uri",
              includeContext: "include_context",
              preservePathAndQuery: "preserve_path_and_query",
            }),
          ),
          Schema.Null,
        ]),
      ),
      resolveDnsInternally: Schema.optional(
        Schema.Union([
          Schema.Struct({
            fallback: Schema.optional(Schema.Literals(["none", "public_dns"])),
            viewId: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({ fallback: "fallback", viewId: "view_id" }),
          ),
          Schema.Null,
        ]),
      ),
      resolveDnsThroughCloudflare: Schema.optional(
        Schema.Union([Schema.Boolean, Schema.Null]),
      ),
      untrustedCert: Schema.optional(
        Schema.Union([
          Schema.Struct({
            action: Schema.optional(
              Schema.Literals(["pass_through", "block", "error"]),
            ),
          }),
          Schema.Null,
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        addHeaders: "add_headers",
        allowChildBypass: "allow_child_bypass",
        auditSsh: "audit_ssh",
        bisoAdminControls: "biso_admin_controls",
        blockPage: "block_page",
        blockPageEnabled: "block_page_enabled",
        blockReason: "block_reason",
        bypassParentRule: "bypass_parent_rule",
        checkSession: "check_session",
        dnsResolvers: "dns_resolvers",
        egress: "egress",
        forensicCopy: "forensic_copy",
        ignoreCnameCategoryMatches: "ignore_cname_category_matches",
        insecureDisableDnssecValidation: "insecure_disable_dnssec_validation",
        ipCategories: "ip_categories",
        ipIndicatorFeeds: "ip_indicator_feeds",
        l4override: "l4override",
        notificationSettings: "notification_settings",
        overrideHost: "override_host",
        overrideIps: "override_ips",
        payloadLog: "payload_log",
        quarantine: "quarantine",
        redirect: "redirect",
        resolveDnsInternally: "resolve_dns_internally",
        resolveDnsThroughCloudflare: "resolve_dns_through_cloudflare",
        untrustedCert: "untrusted_cert",
      }),
    ),
  ),
  schedule: Schema.optional(
    Schema.Union([
      Schema.Struct({
        fri: Schema.optional(Schema.String),
        mon: Schema.optional(Schema.String),
        sat: Schema.optional(Schema.String),
        sun: Schema.optional(Schema.String),
        thu: Schema.optional(Schema.String),
        timeZone: Schema.optional(Schema.String),
        tue: Schema.optional(Schema.String),
        wed: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          fri: "fri",
          mon: "mon",
          sat: "sat",
          sun: "sun",
          thu: "thu",
          timeZone: "time_zone",
          tue: "tue",
          wed: "wed",
        }),
      ),
      Schema.Null,
    ]),
  ),
  traffic: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    action: "action",
    name: "name",
    description: "description",
    devicePosture: "device_posture",
    enabled: "enabled",
    expiration: "expiration",
    filters: "filters",
    identity: "identity",
    precedence: "precedence",
    ruleSettings: "rule_settings",
    schedule: "schedule",
    traffic: "traffic",
  }),
  T.Http({ method: "POST", path: "/accounts/{account_id}/gateway/rules" }),
) as unknown as Schema.Schema<CreateGatewayRuleRequest>;

export interface CreateGatewayRuleResponse {
  /** Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`. */
  action:
    | "on"
    | "off"
    | "allow"
    | "block"
    | "scan"
    | "noscan"
    | "safesearch"
    | "ytrestricted"
    | "isolate"
    | "noisolate"
    | "override"
    | "l4_override"
    | "egress"
    | "resolve"
    | "quarantine"
    | "redirect";
  /** Specify whether the rule is enabled. */
  enabled: boolean;
  /** Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value. */
  filters: ("http" | "dns" | "l4" | "egress" | "dns_resolver")[];
  /** Specify the rule name. */
  name: string;
  /** Set the order of your rules. Lower values indicate higher precedence. At each processing phase, evaluate applicable rules in ascending order of this value. Refer to [Order of enforcement](http://devel */
  precedence: number;
  /** Specify the wirefilter expression used for traffic matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression */
  traffic: string;
  /** Identify the API resource with a UUID. */
  id?: string;
  createdAt?: string;
  /** Indicate the date of deletion, if any. */
  deletedAt?: string | null;
  /** Specify the rule description. */
  description?: string;
  /** Specify the wirefilter expression used for device posture check. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expres */
  devicePosture?: string;
  /** Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This does not apply to HTTP or network policies. Settable o */
  expiration?: {
    expiresAt: string;
    duration?: number;
    expired?: boolean;
  } | null;
  /** Specify the wirefilter expression used for identity matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expressio */
  identity?: string;
  /** Indicate that this rule is shared via the Orgs API and read only. */
  readOnly?: boolean;
  /** Defines settings for this rule. Settings apply only to specific rule types and must use compatible selectors. If Terraform detects drift, confirm the setting supports your rule type and check whether  */
  ruleSettings?: {
    addHeaders?: Record<string, unknown> | null;
    allowChildBypass?: boolean | null;
    auditSsh?: { commandLogging?: boolean } | null;
    bisoAdminControls?: {
      copy?: "enabled" | "disabled" | "remote_only";
      dcp?: boolean;
      dd?: boolean;
      dk?: boolean;
      download?: "enabled" | "disabled" | "remote_only";
      dp?: boolean;
      du?: boolean;
      keyboard?: "enabled" | "disabled";
      paste?: "enabled" | "disabled" | "remote_only";
      printing?: "enabled" | "disabled";
      upload?: "enabled" | "disabled";
      version?: "v1" | "v2";
    };
    blockPage?: { targetUri: string; includeContext?: boolean } | null;
    blockPageEnabled?: boolean;
    blockReason?: string | null;
    bypassParentRule?: boolean | null;
    checkSession?: { duration?: string; enforce?: boolean } | null;
    dnsResolvers?: { ipv4?: unknown[]; ipv6?: unknown[] } | null;
    egress?: { ipv4?: string; ipv4Fallback?: string; ipv6?: string } | null;
    forensicCopy?: { enabled?: boolean } | null;
    ignoreCnameCategoryMatches?: boolean;
    insecureDisableDnssecValidation?: boolean;
    ipCategories?: boolean;
    ipIndicatorFeeds?: boolean;
    l4override?: { ip?: string; port?: number } | null;
    notificationSettings?: {
      enabled?: boolean;
      includeContext?: boolean;
      msg?: string;
      supportUrl?: string;
    } | null;
    overrideHost?: string;
    overrideIps?: string[] | null;
    payloadLog?: { enabled?: boolean } | null;
    quarantine?: {
      fileTypes?: (
        | "exe"
        | "pdf"
        | "doc"
        | "docm"
        | "docx"
        | "rtf"
        | "ppt"
        | "pptx"
        | "xls"
        | "xlsm"
        | "xlsx"
        | "zip"
        | "rar"
      )[];
    } | null;
    redirect?: {
      targetUri: string;
      includeContext?: boolean;
      preservePathAndQuery?: boolean;
    } | null;
    resolveDnsInternally?: {
      fallback?: "none" | "public_dns";
      viewId?: string;
    } | null;
    resolveDnsThroughCloudflare?: boolean | null;
    untrustedCert?: { action?: "pass_through" | "block" | "error" } | null;
  };
  /** Defines the schedule for activating DNS policies. Settable only for `dns` and `dns_resolver` rules. */
  schedule?: {
    fri?: string;
    mon?: string;
    sat?: string;
    sun?: string;
    thu?: string;
    timeZone?: string;
    tue?: string;
    wed?: string;
  } | null;
  /** Indicate that this rule is sharable via the Orgs API. */
  sharable?: boolean;
  /** Provide the account tag of the account that created the rule. */
  sourceAccount?: string;
  updatedAt?: string;
  /** Indicate the version number of the rule(read-only). */
  version?: number;
  /** Indicate a warning for a misconfigured rule, if any. */
  warningStatus?: string | null;
}

export const CreateGatewayRuleResponse = Schema.Struct({
  action: Schema.Literals([
    "on",
    "off",
    "allow",
    "block",
    "scan",
    "noscan",
    "safesearch",
    "ytrestricted",
    "isolate",
    "noisolate",
    "override",
    "l4_override",
    "egress",
    "resolve",
    "quarantine",
    "redirect",
  ]),
  enabled: Schema.Boolean,
  filters: Schema.Array(
    Schema.Literals(["http", "dns", "l4", "egress", "dns_resolver"]),
  ),
  name: Schema.String,
  precedence: Schema.Number,
  traffic: Schema.String,
  id: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  deletedAt: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  description: Schema.optional(Schema.String),
  devicePosture: Schema.optional(Schema.String),
  expiration: Schema.optional(
    Schema.Union([
      Schema.Struct({
        expiresAt: Schema.String,
        duration: Schema.optional(Schema.Number),
        expired: Schema.optional(Schema.Boolean),
      }).pipe(
        Schema.encodeKeys({
          expiresAt: "expires_at",
          duration: "duration",
          expired: "expired",
        }),
      ),
      Schema.Null,
    ]),
  ),
  identity: Schema.optional(Schema.String),
  readOnly: Schema.optional(Schema.Boolean),
  ruleSettings: Schema.optional(
    Schema.Struct({
      addHeaders: Schema.optional(
        Schema.Union([Schema.Struct({}), Schema.Null]),
      ),
      allowChildBypass: Schema.optional(
        Schema.Union([Schema.Boolean, Schema.Null]),
      ),
      auditSsh: Schema.optional(
        Schema.Union([
          Schema.Struct({
            commandLogging: Schema.optional(Schema.Boolean),
          }).pipe(Schema.encodeKeys({ commandLogging: "command_logging" })),
          Schema.Null,
        ]),
      ),
      bisoAdminControls: Schema.optional(
        Schema.Struct({
          copy: Schema.optional(
            Schema.Literals(["enabled", "disabled", "remote_only"]),
          ),
          dcp: Schema.optional(Schema.Boolean),
          dd: Schema.optional(Schema.Boolean),
          dk: Schema.optional(Schema.Boolean),
          download: Schema.optional(
            Schema.Literals(["enabled", "disabled", "remote_only"]),
          ),
          dp: Schema.optional(Schema.Boolean),
          du: Schema.optional(Schema.Boolean),
          keyboard: Schema.optional(Schema.Literals(["enabled", "disabled"])),
          paste: Schema.optional(
            Schema.Literals(["enabled", "disabled", "remote_only"]),
          ),
          printing: Schema.optional(Schema.Literals(["enabled", "disabled"])),
          upload: Schema.optional(Schema.Literals(["enabled", "disabled"])),
          version: Schema.optional(Schema.Literals(["v1", "v2"])),
        }),
      ),
      blockPage: Schema.optional(
        Schema.Union([
          Schema.Struct({
            targetUri: Schema.String,
            includeContext: Schema.optional(Schema.Boolean),
          }).pipe(
            Schema.encodeKeys({
              targetUri: "target_uri",
              includeContext: "include_context",
            }),
          ),
          Schema.Null,
        ]),
      ),
      blockPageEnabled: Schema.optional(Schema.Boolean),
      blockReason: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      bypassParentRule: Schema.optional(
        Schema.Union([Schema.Boolean, Schema.Null]),
      ),
      checkSession: Schema.optional(
        Schema.Union([
          Schema.Struct({
            duration: Schema.optional(Schema.String),
            enforce: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      dnsResolvers: Schema.optional(
        Schema.Union([
          Schema.Struct({
            ipv4: Schema.optional(Schema.Array(Schema.Unknown)),
            ipv6: Schema.optional(Schema.Array(Schema.Unknown)),
          }),
          Schema.Null,
        ]),
      ),
      egress: Schema.optional(
        Schema.Union([
          Schema.Struct({
            ipv4: Schema.optional(Schema.String),
            ipv4Fallback: Schema.optional(Schema.String),
            ipv6: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              ipv4: "ipv4",
              ipv4Fallback: "ipv4_fallback",
              ipv6: "ipv6",
            }),
          ),
          Schema.Null,
        ]),
      ),
      forensicCopy: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      ignoreCnameCategoryMatches: Schema.optional(Schema.Boolean),
      insecureDisableDnssecValidation: Schema.optional(Schema.Boolean),
      ipCategories: Schema.optional(Schema.Boolean),
      ipIndicatorFeeds: Schema.optional(Schema.Boolean),
      l4override: Schema.optional(
        Schema.Union([
          Schema.Struct({
            ip: Schema.optional(Schema.String),
            port: Schema.optional(Schema.Number),
          }),
          Schema.Null,
        ]),
      ),
      notificationSettings: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
            includeContext: Schema.optional(Schema.Boolean),
            msg: Schema.optional(Schema.String),
            supportUrl: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              includeContext: "include_context",
              msg: "msg",
              supportUrl: "support_url",
            }),
          ),
          Schema.Null,
        ]),
      ),
      overrideHost: Schema.optional(Schema.String),
      overrideIps: Schema.optional(
        Schema.Union([Schema.Array(Schema.String), Schema.Null]),
      ),
      payloadLog: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      quarantine: Schema.optional(
        Schema.Union([
          Schema.Struct({
            fileTypes: Schema.optional(
              Schema.Array(
                Schema.Literals([
                  "exe",
                  "pdf",
                  "doc",
                  "docm",
                  "docx",
                  "rtf",
                  "ppt",
                  "pptx",
                  "xls",
                  "xlsm",
                  "xlsx",
                  "zip",
                  "rar",
                ]),
              ),
            ),
          }).pipe(Schema.encodeKeys({ fileTypes: "file_types" })),
          Schema.Null,
        ]),
      ),
      redirect: Schema.optional(
        Schema.Union([
          Schema.Struct({
            targetUri: Schema.String,
            includeContext: Schema.optional(Schema.Boolean),
            preservePathAndQuery: Schema.optional(Schema.Boolean),
          }).pipe(
            Schema.encodeKeys({
              targetUri: "target_uri",
              includeContext: "include_context",
              preservePathAndQuery: "preserve_path_and_query",
            }),
          ),
          Schema.Null,
        ]),
      ),
      resolveDnsInternally: Schema.optional(
        Schema.Union([
          Schema.Struct({
            fallback: Schema.optional(Schema.Literals(["none", "public_dns"])),
            viewId: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({ fallback: "fallback", viewId: "view_id" }),
          ),
          Schema.Null,
        ]),
      ),
      resolveDnsThroughCloudflare: Schema.optional(
        Schema.Union([Schema.Boolean, Schema.Null]),
      ),
      untrustedCert: Schema.optional(
        Schema.Union([
          Schema.Struct({
            action: Schema.optional(
              Schema.Literals(["pass_through", "block", "error"]),
            ),
          }),
          Schema.Null,
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        addHeaders: "add_headers",
        allowChildBypass: "allow_child_bypass",
        auditSsh: "audit_ssh",
        bisoAdminControls: "biso_admin_controls",
        blockPage: "block_page",
        blockPageEnabled: "block_page_enabled",
        blockReason: "block_reason",
        bypassParentRule: "bypass_parent_rule",
        checkSession: "check_session",
        dnsResolvers: "dns_resolvers",
        egress: "egress",
        forensicCopy: "forensic_copy",
        ignoreCnameCategoryMatches: "ignore_cname_category_matches",
        insecureDisableDnssecValidation: "insecure_disable_dnssec_validation",
        ipCategories: "ip_categories",
        ipIndicatorFeeds: "ip_indicator_feeds",
        l4override: "l4override",
        notificationSettings: "notification_settings",
        overrideHost: "override_host",
        overrideIps: "override_ips",
        payloadLog: "payload_log",
        quarantine: "quarantine",
        redirect: "redirect",
        resolveDnsInternally: "resolve_dns_internally",
        resolveDnsThroughCloudflare: "resolve_dns_through_cloudflare",
        untrustedCert: "untrusted_cert",
      }),
    ),
  ),
  schedule: Schema.optional(
    Schema.Union([
      Schema.Struct({
        fri: Schema.optional(Schema.String),
        mon: Schema.optional(Schema.String),
        sat: Schema.optional(Schema.String),
        sun: Schema.optional(Schema.String),
        thu: Schema.optional(Schema.String),
        timeZone: Schema.optional(Schema.String),
        tue: Schema.optional(Schema.String),
        wed: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          fri: "fri",
          mon: "mon",
          sat: "sat",
          sun: "sun",
          thu: "thu",
          timeZone: "time_zone",
          tue: "tue",
          wed: "wed",
        }),
      ),
      Schema.Null,
    ]),
  ),
  sharable: Schema.optional(Schema.Boolean),
  sourceAccount: Schema.optional(Schema.String),
  updatedAt: Schema.optional(Schema.String),
  version: Schema.optional(Schema.Number),
  warningStatus: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    action: "action",
    enabled: "enabled",
    filters: "filters",
    name: "name",
    precedence: "precedence",
    traffic: "traffic",
    id: "id",
    createdAt: "created_at",
    deletedAt: "deleted_at",
    description: "description",
    devicePosture: "device_posture",
    expiration: "expiration",
    identity: "identity",
    readOnly: "read_only",
    ruleSettings: "rule_settings",
    schedule: "schedule",
    sharable: "sharable",
    sourceAccount: "source_account",
    updatedAt: "updated_at",
    version: "version",
    warningStatus: "warning_status",
  }),
) as unknown as Schema.Schema<CreateGatewayRuleResponse>;

export type CreateGatewayRuleError = CommonErrors;

export const createGatewayRule: API.OperationMethod<
  CreateGatewayRuleRequest,
  CreateGatewayRuleResponse,
  CreateGatewayRuleError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateGatewayRuleRequest,
  output: CreateGatewayRuleResponse,
  errors: [],
}));

export interface UpdateGatewayRuleRequest {
  ruleId: string;
  /** Path param: */
  accountId: string;
  /** Body param: Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`. */
  action:
    | "on"
    | "off"
    | "allow"
    | "block"
    | "scan"
    | "noscan"
    | "safesearch"
    | "ytrestricted"
    | "isolate"
    | "noisolate"
    | "override"
    | "l4_override"
    | "egress"
    | "resolve"
    | "quarantine"
    | "redirect";
  /** Body param: Specify the rule name. */
  name: string;
  /** Body param: Specify the rule description. */
  description?: string;
  /** Body param: Specify the wirefilter expression used for device posture check. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the form */
  devicePosture?: string;
  /** Body param: Specify whether the rule is enabled. */
  enabled?: boolean;
  /** Body param: Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This does not apply to HTTP or network policies */
  expiration?: { expiresAt: string; duration?: number } | null;
  /** Body param: Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value. */
  filters?: ("http" | "dns" | "l4" | "egress" | "dns_resolver")[];
  /** Body param: Specify the wirefilter expression used for identity matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatt */
  identity?: string;
  /** Body param: Set the order of your rules. Lower values indicate higher precedence. At each processing phase, evaluate applicable rules in ascending order of this value. Refer to [Order of enforcement]( */
  precedence?: number;
  /** Body param: Defines settings for this rule. Settings apply only to specific rule types and must use compatible selectors. If Terraform detects drift, confirm the setting supports your rule type and ch */
  ruleSettings?: {
    addHeaders?: Record<string, unknown> | null;
    allowChildBypass?: boolean | null;
    auditSsh?: { commandLogging?: boolean } | null;
    bisoAdminControls?: {
      copy?: "enabled" | "disabled" | "remote_only";
      dcp?: boolean;
      dd?: boolean;
      dk?: boolean;
      download?: "enabled" | "disabled" | "remote_only";
      dp?: boolean;
      du?: boolean;
      keyboard?: "enabled" | "disabled";
      paste?: "enabled" | "disabled" | "remote_only";
      printing?: "enabled" | "disabled";
      upload?: "enabled" | "disabled";
      version?: "v1" | "v2";
    };
    blockPage?: { targetUri: string; includeContext?: boolean } | null;
    blockPageEnabled?: boolean;
    blockReason?: string | null;
    bypassParentRule?: boolean | null;
    checkSession?: { duration?: string; enforce?: boolean } | null;
    dnsResolvers?: { ipv4?: unknown[]; ipv6?: unknown[] } | null;
    egress?: { ipv4?: string; ipv4Fallback?: string; ipv6?: string } | null;
    forensicCopy?: { enabled?: boolean } | null;
    ignoreCnameCategoryMatches?: boolean;
    insecureDisableDnssecValidation?: boolean;
    ipCategories?: boolean;
    ipIndicatorFeeds?: boolean;
    l4override?: { ip?: string; port?: number } | null;
    notificationSettings?: {
      enabled?: boolean;
      includeContext?: boolean;
      msg?: string;
      supportUrl?: string;
    } | null;
    overrideHost?: string;
    overrideIps?: string[] | null;
    payloadLog?: { enabled?: boolean } | null;
    quarantine?: {
      fileTypes?: (
        | "exe"
        | "pdf"
        | "doc"
        | "docm"
        | "docx"
        | "rtf"
        | "ppt"
        | "pptx"
        | "xls"
        | "xlsm"
        | "xlsx"
        | "zip"
        | "rar"
      )[];
    } | null;
    redirect?: {
      targetUri: string;
      includeContext?: boolean;
      preservePathAndQuery?: boolean;
    } | null;
    resolveDnsInternally?: {
      fallback?: "none" | "public_dns";
      viewId?: string;
    } | null;
    resolveDnsThroughCloudflare?: boolean | null;
    untrustedCert?: { action?: "pass_through" | "block" | "error" } | null;
  };
  /** Body param: Defines the schedule for activating DNS policies. Settable only for `dns` and `dns_resolver` rules. */
  schedule?: {
    fri?: string;
    mon?: string;
    sat?: string;
    sun?: string;
    thu?: string;
    timeZone?: string;
    tue?: string;
    wed?: string;
  } | null;
  /** Body param: Specify the wirefilter expression used for traffic matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatte */
  traffic?: string;
}

export const UpdateGatewayRuleRequest = Schema.Struct({
  ruleId: Schema.String.pipe(T.HttpPath("ruleId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  action: Schema.Literals([
    "on",
    "off",
    "allow",
    "block",
    "scan",
    "noscan",
    "safesearch",
    "ytrestricted",
    "isolate",
    "noisolate",
    "override",
    "l4_override",
    "egress",
    "resolve",
    "quarantine",
    "redirect",
  ]),
  name: Schema.String,
  description: Schema.optional(Schema.String),
  devicePosture: Schema.optional(Schema.String),
  enabled: Schema.optional(Schema.Boolean),
  expiration: Schema.optional(
    Schema.Union([
      Schema.Struct({
        expiresAt: Schema.String,
        duration: Schema.optional(Schema.Number),
      }).pipe(
        Schema.encodeKeys({ expiresAt: "expires_at", duration: "duration" }),
      ),
      Schema.Null,
    ]),
  ),
  filters: Schema.optional(
    Schema.Array(
      Schema.Literals(["http", "dns", "l4", "egress", "dns_resolver"]),
    ),
  ),
  identity: Schema.optional(Schema.String),
  precedence: Schema.optional(Schema.Number),
  ruleSettings: Schema.optional(
    Schema.Struct({
      addHeaders: Schema.optional(
        Schema.Union([Schema.Struct({}), Schema.Null]),
      ),
      allowChildBypass: Schema.optional(
        Schema.Union([Schema.Boolean, Schema.Null]),
      ),
      auditSsh: Schema.optional(
        Schema.Union([
          Schema.Struct({
            commandLogging: Schema.optional(Schema.Boolean),
          }).pipe(Schema.encodeKeys({ commandLogging: "command_logging" })),
          Schema.Null,
        ]),
      ),
      bisoAdminControls: Schema.optional(
        Schema.Struct({
          copy: Schema.optional(
            Schema.Literals(["enabled", "disabled", "remote_only"]),
          ),
          dcp: Schema.optional(Schema.Boolean),
          dd: Schema.optional(Schema.Boolean),
          dk: Schema.optional(Schema.Boolean),
          download: Schema.optional(
            Schema.Literals(["enabled", "disabled", "remote_only"]),
          ),
          dp: Schema.optional(Schema.Boolean),
          du: Schema.optional(Schema.Boolean),
          keyboard: Schema.optional(Schema.Literals(["enabled", "disabled"])),
          paste: Schema.optional(
            Schema.Literals(["enabled", "disabled", "remote_only"]),
          ),
          printing: Schema.optional(Schema.Literals(["enabled", "disabled"])),
          upload: Schema.optional(Schema.Literals(["enabled", "disabled"])),
          version: Schema.optional(Schema.Literals(["v1", "v2"])),
        }),
      ),
      blockPage: Schema.optional(
        Schema.Union([
          Schema.Struct({
            targetUri: Schema.String,
            includeContext: Schema.optional(Schema.Boolean),
          }).pipe(
            Schema.encodeKeys({
              targetUri: "target_uri",
              includeContext: "include_context",
            }),
          ),
          Schema.Null,
        ]),
      ),
      blockPageEnabled: Schema.optional(Schema.Boolean),
      blockReason: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      bypassParentRule: Schema.optional(
        Schema.Union([Schema.Boolean, Schema.Null]),
      ),
      checkSession: Schema.optional(
        Schema.Union([
          Schema.Struct({
            duration: Schema.optional(Schema.String),
            enforce: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      dnsResolvers: Schema.optional(
        Schema.Union([
          Schema.Struct({
            ipv4: Schema.optional(Schema.Array(Schema.Unknown)),
            ipv6: Schema.optional(Schema.Array(Schema.Unknown)),
          }),
          Schema.Null,
        ]),
      ),
      egress: Schema.optional(
        Schema.Union([
          Schema.Struct({
            ipv4: Schema.optional(Schema.String),
            ipv4Fallback: Schema.optional(Schema.String),
            ipv6: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              ipv4: "ipv4",
              ipv4Fallback: "ipv4_fallback",
              ipv6: "ipv6",
            }),
          ),
          Schema.Null,
        ]),
      ),
      forensicCopy: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      ignoreCnameCategoryMatches: Schema.optional(Schema.Boolean),
      insecureDisableDnssecValidation: Schema.optional(Schema.Boolean),
      ipCategories: Schema.optional(Schema.Boolean),
      ipIndicatorFeeds: Schema.optional(Schema.Boolean),
      l4override: Schema.optional(
        Schema.Union([
          Schema.Struct({
            ip: Schema.optional(Schema.String),
            port: Schema.optional(Schema.Number),
          }),
          Schema.Null,
        ]),
      ),
      notificationSettings: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
            includeContext: Schema.optional(Schema.Boolean),
            msg: Schema.optional(Schema.String),
            supportUrl: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              includeContext: "include_context",
              msg: "msg",
              supportUrl: "support_url",
            }),
          ),
          Schema.Null,
        ]),
      ),
      overrideHost: Schema.optional(Schema.String),
      overrideIps: Schema.optional(
        Schema.Union([Schema.Array(Schema.String), Schema.Null]),
      ),
      payloadLog: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      quarantine: Schema.optional(
        Schema.Union([
          Schema.Struct({
            fileTypes: Schema.optional(
              Schema.Array(
                Schema.Literals([
                  "exe",
                  "pdf",
                  "doc",
                  "docm",
                  "docx",
                  "rtf",
                  "ppt",
                  "pptx",
                  "xls",
                  "xlsm",
                  "xlsx",
                  "zip",
                  "rar",
                ]),
              ),
            ),
          }).pipe(Schema.encodeKeys({ fileTypes: "file_types" })),
          Schema.Null,
        ]),
      ),
      redirect: Schema.optional(
        Schema.Union([
          Schema.Struct({
            targetUri: Schema.String,
            includeContext: Schema.optional(Schema.Boolean),
            preservePathAndQuery: Schema.optional(Schema.Boolean),
          }).pipe(
            Schema.encodeKeys({
              targetUri: "target_uri",
              includeContext: "include_context",
              preservePathAndQuery: "preserve_path_and_query",
            }),
          ),
          Schema.Null,
        ]),
      ),
      resolveDnsInternally: Schema.optional(
        Schema.Union([
          Schema.Struct({
            fallback: Schema.optional(Schema.Literals(["none", "public_dns"])),
            viewId: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({ fallback: "fallback", viewId: "view_id" }),
          ),
          Schema.Null,
        ]),
      ),
      resolveDnsThroughCloudflare: Schema.optional(
        Schema.Union([Schema.Boolean, Schema.Null]),
      ),
      untrustedCert: Schema.optional(
        Schema.Union([
          Schema.Struct({
            action: Schema.optional(
              Schema.Literals(["pass_through", "block", "error"]),
            ),
          }),
          Schema.Null,
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        addHeaders: "add_headers",
        allowChildBypass: "allow_child_bypass",
        auditSsh: "audit_ssh",
        bisoAdminControls: "biso_admin_controls",
        blockPage: "block_page",
        blockPageEnabled: "block_page_enabled",
        blockReason: "block_reason",
        bypassParentRule: "bypass_parent_rule",
        checkSession: "check_session",
        dnsResolvers: "dns_resolvers",
        egress: "egress",
        forensicCopy: "forensic_copy",
        ignoreCnameCategoryMatches: "ignore_cname_category_matches",
        insecureDisableDnssecValidation: "insecure_disable_dnssec_validation",
        ipCategories: "ip_categories",
        ipIndicatorFeeds: "ip_indicator_feeds",
        l4override: "l4override",
        notificationSettings: "notification_settings",
        overrideHost: "override_host",
        overrideIps: "override_ips",
        payloadLog: "payload_log",
        quarantine: "quarantine",
        redirect: "redirect",
        resolveDnsInternally: "resolve_dns_internally",
        resolveDnsThroughCloudflare: "resolve_dns_through_cloudflare",
        untrustedCert: "untrusted_cert",
      }),
    ),
  ),
  schedule: Schema.optional(
    Schema.Union([
      Schema.Struct({
        fri: Schema.optional(Schema.String),
        mon: Schema.optional(Schema.String),
        sat: Schema.optional(Schema.String),
        sun: Schema.optional(Schema.String),
        thu: Schema.optional(Schema.String),
        timeZone: Schema.optional(Schema.String),
        tue: Schema.optional(Schema.String),
        wed: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          fri: "fri",
          mon: "mon",
          sat: "sat",
          sun: "sun",
          thu: "thu",
          timeZone: "time_zone",
          tue: "tue",
          wed: "wed",
        }),
      ),
      Schema.Null,
    ]),
  ),
  traffic: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    action: "action",
    name: "name",
    description: "description",
    devicePosture: "device_posture",
    enabled: "enabled",
    expiration: "expiration",
    filters: "filters",
    identity: "identity",
    precedence: "precedence",
    ruleSettings: "rule_settings",
    schedule: "schedule",
    traffic: "traffic",
  }),
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/gateway/rules/{ruleId}",
  }),
) as unknown as Schema.Schema<UpdateGatewayRuleRequest>;

export interface UpdateGatewayRuleResponse {
  /** Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`. */
  action:
    | "on"
    | "off"
    | "allow"
    | "block"
    | "scan"
    | "noscan"
    | "safesearch"
    | "ytrestricted"
    | "isolate"
    | "noisolate"
    | "override"
    | "l4_override"
    | "egress"
    | "resolve"
    | "quarantine"
    | "redirect";
  /** Specify whether the rule is enabled. */
  enabled: boolean;
  /** Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value. */
  filters: ("http" | "dns" | "l4" | "egress" | "dns_resolver")[];
  /** Specify the rule name. */
  name: string;
  /** Set the order of your rules. Lower values indicate higher precedence. At each processing phase, evaluate applicable rules in ascending order of this value. Refer to [Order of enforcement](http://devel */
  precedence: number;
  /** Specify the wirefilter expression used for traffic matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression */
  traffic: string;
  /** Identify the API resource with a UUID. */
  id?: string;
  createdAt?: string;
  /** Indicate the date of deletion, if any. */
  deletedAt?: string | null;
  /** Specify the rule description. */
  description?: string;
  /** Specify the wirefilter expression used for device posture check. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expres */
  devicePosture?: string;
  /** Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This does not apply to HTTP or network policies. Settable o */
  expiration?: {
    expiresAt: string;
    duration?: number;
    expired?: boolean;
  } | null;
  /** Specify the wirefilter expression used for identity matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expressio */
  identity?: string;
  /** Indicate that this rule is shared via the Orgs API and read only. */
  readOnly?: boolean;
  /** Defines settings for this rule. Settings apply only to specific rule types and must use compatible selectors. If Terraform detects drift, confirm the setting supports your rule type and check whether  */
  ruleSettings?: {
    addHeaders?: Record<string, unknown> | null;
    allowChildBypass?: boolean | null;
    auditSsh?: { commandLogging?: boolean } | null;
    bisoAdminControls?: {
      copy?: "enabled" | "disabled" | "remote_only";
      dcp?: boolean;
      dd?: boolean;
      dk?: boolean;
      download?: "enabled" | "disabled" | "remote_only";
      dp?: boolean;
      du?: boolean;
      keyboard?: "enabled" | "disabled";
      paste?: "enabled" | "disabled" | "remote_only";
      printing?: "enabled" | "disabled";
      upload?: "enabled" | "disabled";
      version?: "v1" | "v2";
    };
    blockPage?: { targetUri: string; includeContext?: boolean } | null;
    blockPageEnabled?: boolean;
    blockReason?: string | null;
    bypassParentRule?: boolean | null;
    checkSession?: { duration?: string; enforce?: boolean } | null;
    dnsResolvers?: { ipv4?: unknown[]; ipv6?: unknown[] } | null;
    egress?: { ipv4?: string; ipv4Fallback?: string; ipv6?: string } | null;
    forensicCopy?: { enabled?: boolean } | null;
    ignoreCnameCategoryMatches?: boolean;
    insecureDisableDnssecValidation?: boolean;
    ipCategories?: boolean;
    ipIndicatorFeeds?: boolean;
    l4override?: { ip?: string; port?: number } | null;
    notificationSettings?: {
      enabled?: boolean;
      includeContext?: boolean;
      msg?: string;
      supportUrl?: string;
    } | null;
    overrideHost?: string;
    overrideIps?: string[] | null;
    payloadLog?: { enabled?: boolean } | null;
    quarantine?: {
      fileTypes?: (
        | "exe"
        | "pdf"
        | "doc"
        | "docm"
        | "docx"
        | "rtf"
        | "ppt"
        | "pptx"
        | "xls"
        | "xlsm"
        | "xlsx"
        | "zip"
        | "rar"
      )[];
    } | null;
    redirect?: {
      targetUri: string;
      includeContext?: boolean;
      preservePathAndQuery?: boolean;
    } | null;
    resolveDnsInternally?: {
      fallback?: "none" | "public_dns";
      viewId?: string;
    } | null;
    resolveDnsThroughCloudflare?: boolean | null;
    untrustedCert?: { action?: "pass_through" | "block" | "error" } | null;
  };
  /** Defines the schedule for activating DNS policies. Settable only for `dns` and `dns_resolver` rules. */
  schedule?: {
    fri?: string;
    mon?: string;
    sat?: string;
    sun?: string;
    thu?: string;
    timeZone?: string;
    tue?: string;
    wed?: string;
  } | null;
  /** Indicate that this rule is sharable via the Orgs API. */
  sharable?: boolean;
  /** Provide the account tag of the account that created the rule. */
  sourceAccount?: string;
  updatedAt?: string;
  /** Indicate the version number of the rule(read-only). */
  version?: number;
  /** Indicate a warning for a misconfigured rule, if any. */
  warningStatus?: string | null;
}

export const UpdateGatewayRuleResponse = Schema.Struct({
  action: Schema.Literals([
    "on",
    "off",
    "allow",
    "block",
    "scan",
    "noscan",
    "safesearch",
    "ytrestricted",
    "isolate",
    "noisolate",
    "override",
    "l4_override",
    "egress",
    "resolve",
    "quarantine",
    "redirect",
  ]),
  enabled: Schema.Boolean,
  filters: Schema.Array(
    Schema.Literals(["http", "dns", "l4", "egress", "dns_resolver"]),
  ),
  name: Schema.String,
  precedence: Schema.Number,
  traffic: Schema.String,
  id: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  deletedAt: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  description: Schema.optional(Schema.String),
  devicePosture: Schema.optional(Schema.String),
  expiration: Schema.optional(
    Schema.Union([
      Schema.Struct({
        expiresAt: Schema.String,
        duration: Schema.optional(Schema.Number),
        expired: Schema.optional(Schema.Boolean),
      }).pipe(
        Schema.encodeKeys({
          expiresAt: "expires_at",
          duration: "duration",
          expired: "expired",
        }),
      ),
      Schema.Null,
    ]),
  ),
  identity: Schema.optional(Schema.String),
  readOnly: Schema.optional(Schema.Boolean),
  ruleSettings: Schema.optional(
    Schema.Struct({
      addHeaders: Schema.optional(
        Schema.Union([Schema.Struct({}), Schema.Null]),
      ),
      allowChildBypass: Schema.optional(
        Schema.Union([Schema.Boolean, Schema.Null]),
      ),
      auditSsh: Schema.optional(
        Schema.Union([
          Schema.Struct({
            commandLogging: Schema.optional(Schema.Boolean),
          }).pipe(Schema.encodeKeys({ commandLogging: "command_logging" })),
          Schema.Null,
        ]),
      ),
      bisoAdminControls: Schema.optional(
        Schema.Struct({
          copy: Schema.optional(
            Schema.Literals(["enabled", "disabled", "remote_only"]),
          ),
          dcp: Schema.optional(Schema.Boolean),
          dd: Schema.optional(Schema.Boolean),
          dk: Schema.optional(Schema.Boolean),
          download: Schema.optional(
            Schema.Literals(["enabled", "disabled", "remote_only"]),
          ),
          dp: Schema.optional(Schema.Boolean),
          du: Schema.optional(Schema.Boolean),
          keyboard: Schema.optional(Schema.Literals(["enabled", "disabled"])),
          paste: Schema.optional(
            Schema.Literals(["enabled", "disabled", "remote_only"]),
          ),
          printing: Schema.optional(Schema.Literals(["enabled", "disabled"])),
          upload: Schema.optional(Schema.Literals(["enabled", "disabled"])),
          version: Schema.optional(Schema.Literals(["v1", "v2"])),
        }),
      ),
      blockPage: Schema.optional(
        Schema.Union([
          Schema.Struct({
            targetUri: Schema.String,
            includeContext: Schema.optional(Schema.Boolean),
          }).pipe(
            Schema.encodeKeys({
              targetUri: "target_uri",
              includeContext: "include_context",
            }),
          ),
          Schema.Null,
        ]),
      ),
      blockPageEnabled: Schema.optional(Schema.Boolean),
      blockReason: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
      bypassParentRule: Schema.optional(
        Schema.Union([Schema.Boolean, Schema.Null]),
      ),
      checkSession: Schema.optional(
        Schema.Union([
          Schema.Struct({
            duration: Schema.optional(Schema.String),
            enforce: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      dnsResolvers: Schema.optional(
        Schema.Union([
          Schema.Struct({
            ipv4: Schema.optional(Schema.Array(Schema.Unknown)),
            ipv6: Schema.optional(Schema.Array(Schema.Unknown)),
          }),
          Schema.Null,
        ]),
      ),
      egress: Schema.optional(
        Schema.Union([
          Schema.Struct({
            ipv4: Schema.optional(Schema.String),
            ipv4Fallback: Schema.optional(Schema.String),
            ipv6: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              ipv4: "ipv4",
              ipv4Fallback: "ipv4_fallback",
              ipv6: "ipv6",
            }),
          ),
          Schema.Null,
        ]),
      ),
      forensicCopy: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      ignoreCnameCategoryMatches: Schema.optional(Schema.Boolean),
      insecureDisableDnssecValidation: Schema.optional(Schema.Boolean),
      ipCategories: Schema.optional(Schema.Boolean),
      ipIndicatorFeeds: Schema.optional(Schema.Boolean),
      l4override: Schema.optional(
        Schema.Union([
          Schema.Struct({
            ip: Schema.optional(Schema.String),
            port: Schema.optional(Schema.Number),
          }),
          Schema.Null,
        ]),
      ),
      notificationSettings: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
            includeContext: Schema.optional(Schema.Boolean),
            msg: Schema.optional(Schema.String),
            supportUrl: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              enabled: "enabled",
              includeContext: "include_context",
              msg: "msg",
              supportUrl: "support_url",
            }),
          ),
          Schema.Null,
        ]),
      ),
      overrideHost: Schema.optional(Schema.String),
      overrideIps: Schema.optional(
        Schema.Union([Schema.Array(Schema.String), Schema.Null]),
      ),
      payloadLog: Schema.optional(
        Schema.Union([
          Schema.Struct({
            enabled: Schema.optional(Schema.Boolean),
          }),
          Schema.Null,
        ]),
      ),
      quarantine: Schema.optional(
        Schema.Union([
          Schema.Struct({
            fileTypes: Schema.optional(
              Schema.Array(
                Schema.Literals([
                  "exe",
                  "pdf",
                  "doc",
                  "docm",
                  "docx",
                  "rtf",
                  "ppt",
                  "pptx",
                  "xls",
                  "xlsm",
                  "xlsx",
                  "zip",
                  "rar",
                ]),
              ),
            ),
          }).pipe(Schema.encodeKeys({ fileTypes: "file_types" })),
          Schema.Null,
        ]),
      ),
      redirect: Schema.optional(
        Schema.Union([
          Schema.Struct({
            targetUri: Schema.String,
            includeContext: Schema.optional(Schema.Boolean),
            preservePathAndQuery: Schema.optional(Schema.Boolean),
          }).pipe(
            Schema.encodeKeys({
              targetUri: "target_uri",
              includeContext: "include_context",
              preservePathAndQuery: "preserve_path_and_query",
            }),
          ),
          Schema.Null,
        ]),
      ),
      resolveDnsInternally: Schema.optional(
        Schema.Union([
          Schema.Struct({
            fallback: Schema.optional(Schema.Literals(["none", "public_dns"])),
            viewId: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({ fallback: "fallback", viewId: "view_id" }),
          ),
          Schema.Null,
        ]),
      ),
      resolveDnsThroughCloudflare: Schema.optional(
        Schema.Union([Schema.Boolean, Schema.Null]),
      ),
      untrustedCert: Schema.optional(
        Schema.Union([
          Schema.Struct({
            action: Schema.optional(
              Schema.Literals(["pass_through", "block", "error"]),
            ),
          }),
          Schema.Null,
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        addHeaders: "add_headers",
        allowChildBypass: "allow_child_bypass",
        auditSsh: "audit_ssh",
        bisoAdminControls: "biso_admin_controls",
        blockPage: "block_page",
        blockPageEnabled: "block_page_enabled",
        blockReason: "block_reason",
        bypassParentRule: "bypass_parent_rule",
        checkSession: "check_session",
        dnsResolvers: "dns_resolvers",
        egress: "egress",
        forensicCopy: "forensic_copy",
        ignoreCnameCategoryMatches: "ignore_cname_category_matches",
        insecureDisableDnssecValidation: "insecure_disable_dnssec_validation",
        ipCategories: "ip_categories",
        ipIndicatorFeeds: "ip_indicator_feeds",
        l4override: "l4override",
        notificationSettings: "notification_settings",
        overrideHost: "override_host",
        overrideIps: "override_ips",
        payloadLog: "payload_log",
        quarantine: "quarantine",
        redirect: "redirect",
        resolveDnsInternally: "resolve_dns_internally",
        resolveDnsThroughCloudflare: "resolve_dns_through_cloudflare",
        untrustedCert: "untrusted_cert",
      }),
    ),
  ),
  schedule: Schema.optional(
    Schema.Union([
      Schema.Struct({
        fri: Schema.optional(Schema.String),
        mon: Schema.optional(Schema.String),
        sat: Schema.optional(Schema.String),
        sun: Schema.optional(Schema.String),
        thu: Schema.optional(Schema.String),
        timeZone: Schema.optional(Schema.String),
        tue: Schema.optional(Schema.String),
        wed: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          fri: "fri",
          mon: "mon",
          sat: "sat",
          sun: "sun",
          thu: "thu",
          timeZone: "time_zone",
          tue: "tue",
          wed: "wed",
        }),
      ),
      Schema.Null,
    ]),
  ),
  sharable: Schema.optional(Schema.Boolean),
  sourceAccount: Schema.optional(Schema.String),
  updatedAt: Schema.optional(Schema.String),
  version: Schema.optional(Schema.Number),
  warningStatus: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    action: "action",
    enabled: "enabled",
    filters: "filters",
    name: "name",
    precedence: "precedence",
    traffic: "traffic",
    id: "id",
    createdAt: "created_at",
    deletedAt: "deleted_at",
    description: "description",
    devicePosture: "device_posture",
    expiration: "expiration",
    identity: "identity",
    readOnly: "read_only",
    ruleSettings: "rule_settings",
    schedule: "schedule",
    sharable: "sharable",
    sourceAccount: "source_account",
    updatedAt: "updated_at",
    version: "version",
    warningStatus: "warning_status",
  }),
) as unknown as Schema.Schema<UpdateGatewayRuleResponse>;

export type UpdateGatewayRuleError = CommonErrors;

export const updateGatewayRule: API.OperationMethod<
  UpdateGatewayRuleRequest,
  UpdateGatewayRuleResponse,
  UpdateGatewayRuleError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateGatewayRuleRequest,
  output: UpdateGatewayRuleResponse,
  errors: [],
}));

export interface DeleteGatewayRuleRequest {
  ruleId: string;
  accountId: string;
}

export const DeleteGatewayRuleRequest = Schema.Struct({
  ruleId: Schema.String.pipe(T.HttpPath("ruleId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/gateway/rules/{ruleId}",
  }),
) as unknown as Schema.Schema<DeleteGatewayRuleRequest>;

export type DeleteGatewayRuleResponse = unknown;

export const DeleteGatewayRuleResponse =
  Schema.Unknown as unknown as Schema.Schema<DeleteGatewayRuleResponse>;

export type DeleteGatewayRuleError = CommonErrors;

export const deleteGatewayRule: API.OperationMethod<
  DeleteGatewayRuleRequest,
  DeleteGatewayRuleResponse,
  DeleteGatewayRuleError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteGatewayRuleRequest,
  output: DeleteGatewayRuleResponse,
  errors: [],
}));

// =============================================================================
// IdentityProvider
// =============================================================================

export interface GetIdentityProviderRequest {
  identityProviderId: string;
}

export const GetIdentityProviderRequest = Schema.Struct({
  identityProviderId: Schema.String.pipe(T.HttpPath("identityProviderId")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/{accountOrZone}/{accountOrZoneId}/access/identity_providers/{identityProviderId}",
  }),
) as unknown as Schema.Schema<GetIdentityProviderRequest>;

export type GetIdentityProviderResponse =
  | {
      config: {
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        conditionalAccessEnabled?: boolean;
        directoryId?: string;
        emailClaimName?: string;
        prompt?: "login" | "select_account" | "none";
        supportGroups?: boolean;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      accountId?: string;
      zoneId?: string;
      scimConfig?: {
        enabled?: boolean;
        identityUpdateBehavior?: "automatic" | "reauth" | "no_action";
        seatDeprovision?: boolean;
        userDeprovision?: boolean;
      };
    }
  | {
      config: {
        centrifyAccount?: string;
        centrifyAppId?: string;
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: unknown;
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        appsDomain?: string;
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        authUrl?: string;
        certsUrl?: string;
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
        pkceEnabled?: boolean;
        scopes?: string[];
        tokenUrl?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        authorizationServerId?: string;
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
        oktaAccount?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
        oneloginAccount?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
        pingEnvId?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        attributes?: string[];
        emailAttributeName?: string;
        headerAttributes?: { attributeName?: string; headerName?: string }[];
        idpPublicCerts?: string[];
        issuerUrl?: string;
        signRequest?: boolean;
        ssoTargetUrl?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    };

export const GetIdentityProviderResponse = Schema.Union([
  Schema.Struct({
    config: Schema.Struct({
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      conditionalAccessEnabled: Schema.optional(Schema.Boolean),
      directoryId: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
      prompt: Schema.optional(
        Schema.Literals(["login", "select_account", "none"]),
      ),
      supportGroups: Schema.optional(Schema.Boolean),
    }).pipe(
      Schema.encodeKeys({
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        conditionalAccessEnabled: "conditional_access_enabled",
        directoryId: "directory_id",
        emailClaimName: "email_claim_name",
        prompt: "prompt",
        supportGroups: "support_groups",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    accountId: Schema.optional(Schema.String),
    zoneId: Schema.optional(Schema.String),
    scimConfig: Schema.optional(
      Schema.Struct({
        enabled: Schema.optional(Schema.Boolean),
        identityUpdateBehavior: Schema.optional(
          Schema.Literals(["automatic", "reauth", "no_action"]),
        ),
        seatDeprovision: Schema.optional(Schema.Boolean),
        userDeprovision: Schema.optional(Schema.Boolean),
      }).pipe(
        Schema.encodeKeys({
          enabled: "enabled",
          identityUpdateBehavior: "identity_update_behavior",
          seatDeprovision: "seat_deprovision",
          userDeprovision: "user_deprovision",
        }),
      ),
    ),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      accountId: "account_id",
      zoneId: "zone_id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      centrifyAccount: Schema.optional(Schema.String),
      centrifyAppId: Schema.optional(Schema.String),
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        centrifyAccount: "centrify_account",
        centrifyAppId: "centrify_app_id",
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Unknown,
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      appsDomain: Schema.optional(Schema.String),
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        appsDomain: "apps_domain",
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      authUrl: Schema.optional(Schema.String),
      certsUrl: Schema.optional(Schema.String),
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
      pkceEnabled: Schema.optional(Schema.Boolean),
      scopes: Schema.optional(Schema.Array(Schema.String)),
      tokenUrl: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        authUrl: "auth_url",
        certsUrl: "certs_url",
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
        pkceEnabled: "pkce_enabled",
        scopes: "scopes",
        tokenUrl: "token_url",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      authorizationServerId: Schema.optional(Schema.String),
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
      oktaAccount: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        authorizationServerId: "authorization_server_id",
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
        oktaAccount: "okta_account",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
      oneloginAccount: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
        oneloginAccount: "onelogin_account",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
      pingEnvId: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
        pingEnvId: "ping_env_id",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      attributes: Schema.optional(Schema.Array(Schema.String)),
      emailAttributeName: Schema.optional(Schema.String),
      headerAttributes: Schema.optional(
        Schema.Array(
          Schema.Struct({
            attributeName: Schema.optional(Schema.String),
            headerName: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              attributeName: "attribute_name",
              headerName: "header_name",
            }),
          ),
        ),
      ),
      idpPublicCerts: Schema.optional(Schema.Array(Schema.String)),
      issuerUrl: Schema.optional(Schema.String),
      signRequest: Schema.optional(Schema.Boolean),
      ssoTargetUrl: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        attributes: "attributes",
        emailAttributeName: "email_attribute_name",
        headerAttributes: "header_attributes",
        idpPublicCerts: "idp_public_certs",
        issuerUrl: "issuer_url",
        signRequest: "sign_request",
        ssoTargetUrl: "sso_target_url",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
]) as unknown as Schema.Schema<GetIdentityProviderResponse>;

export type GetIdentityProviderError = CommonErrors;

export const getIdentityProvider: API.OperationMethod<
  GetIdentityProviderRequest,
  GetIdentityProviderResponse,
  GetIdentityProviderError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetIdentityProviderRequest,
  output: GetIdentityProviderResponse,
  errors: [],
}));

export interface ListIdentityProvidersRequest {}

export const ListIdentityProvidersRequest = Schema.Struct({}).pipe(
  T.Http({
    method: "GET",
    path: "/{accountOrZone}/{accountOrZoneId}/access/identity_providers",
  }),
) as unknown as Schema.Schema<ListIdentityProvidersRequest>;

export type ListIdentityProvidersResponse = (
  | {
      config: {
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        conditionalAccessEnabled?: boolean;
        directoryId?: string;
        emailClaimName?: string;
        prompt?: "login" | "select_account" | "none";
        supportGroups?: boolean;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      accountId?: string;
      zoneId?: string;
      scimConfig?: {
        enabled?: boolean;
        identityUpdateBehavior?: "automatic" | "reauth" | "no_action";
        seatDeprovision?: boolean;
        userDeprovision?: boolean;
      };
    }
  | {
      config: {
        centrifyAccount?: string;
        centrifyAppId?: string;
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: unknown;
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        appsDomain?: string;
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        authUrl?: string;
        certsUrl?: string;
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
        pkceEnabled?: boolean;
        scopes?: string[];
        tokenUrl?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        authorizationServerId?: string;
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
        oktaAccount?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
        oneloginAccount?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
        pingEnvId?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        attributes?: string[];
        emailAttributeName?: string;
        headerAttributes?: { attributeName?: string; headerName?: string }[];
        idpPublicCerts?: string[];
        issuerUrl?: string;
        signRequest?: boolean;
        ssoTargetUrl?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
)[];

export const ListIdentityProvidersResponse = Schema.Array(
  Schema.Union([
    Schema.Struct({
      config: Schema.Struct({
        claims: Schema.optional(Schema.Array(Schema.String)),
        clientId: Schema.optional(Schema.String),
        clientSecret: Schema.optional(Schema.String),
        conditionalAccessEnabled: Schema.optional(Schema.Boolean),
        directoryId: Schema.optional(Schema.String),
        emailClaimName: Schema.optional(Schema.String),
        prompt: Schema.optional(
          Schema.Literals(["login", "select_account", "none"]),
        ),
        supportGroups: Schema.optional(Schema.Boolean),
      }).pipe(
        Schema.encodeKeys({
          claims: "claims",
          clientId: "client_id",
          clientSecret: "client_secret",
          conditionalAccessEnabled: "conditional_access_enabled",
          directoryId: "directory_id",
          emailClaimName: "email_claim_name",
          prompt: "prompt",
          supportGroups: "support_groups",
        }),
      ),
      name: Schema.String,
      type: Schema.Literals([
        "google",
        "onetimepin",
        "azureAD",
        "saml",
        "centrify",
        "facebook",
        "github",
        "google-apps",
        "linkedin",
        "oidc",
        "okta",
        "onelogin",
        "pingone",
        "yandex",
      ]),
      accountId: Schema.optional(Schema.String),
      zoneId: Schema.optional(Schema.String),
      scimConfig: Schema.optional(
        Schema.Struct({
          enabled: Schema.optional(Schema.Boolean),
          identityUpdateBehavior: Schema.optional(
            Schema.Literals(["automatic", "reauth", "no_action"]),
          ),
          seatDeprovision: Schema.optional(Schema.Boolean),
          userDeprovision: Schema.optional(Schema.Boolean),
        }).pipe(
          Schema.encodeKeys({
            enabled: "enabled",
            identityUpdateBehavior: "identity_update_behavior",
            seatDeprovision: "seat_deprovision",
            userDeprovision: "user_deprovision",
          }),
        ),
      ),
    }).pipe(
      Schema.encodeKeys({
        config: "config",
        name: "name",
        type: "type",
        accountId: "account_id",
        zoneId: "zone_id",
        scimConfig: "scim_config",
      }),
    ),
    Schema.Struct({
      config: Schema.Struct({
        centrifyAccount: Schema.optional(Schema.String),
        centrifyAppId: Schema.optional(Schema.String),
        claims: Schema.optional(Schema.Array(Schema.String)),
        clientId: Schema.optional(Schema.String),
        clientSecret: Schema.optional(Schema.String),
        emailClaimName: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          centrifyAccount: "centrify_account",
          centrifyAppId: "centrify_app_id",
          claims: "claims",
          clientId: "client_id",
          clientSecret: "client_secret",
          emailClaimName: "email_claim_name",
        }),
      ),
      name: Schema.String,
      type: Schema.Literals([
        "google",
        "onetimepin",
        "azureAD",
        "saml",
        "centrify",
        "facebook",
        "github",
        "google-apps",
        "linkedin",
        "oidc",
        "okta",
        "onelogin",
        "pingone",
        "yandex",
      ]),
      id: Schema.optional(Schema.String),
      scimConfig: Schema.optional(Schema.Unknown),
    }).pipe(
      Schema.encodeKeys({
        config: "config",
        name: "name",
        type: "type",
        id: "id",
        scimConfig: "scim_config",
      }),
    ),
    Schema.Struct({
      config: Schema.Unknown,
      name: Schema.String,
      type: Schema.Literals([
        "google",
        "onetimepin",
        "azureAD",
        "saml",
        "centrify",
        "facebook",
        "github",
        "google-apps",
        "linkedin",
        "oidc",
        "okta",
        "onelogin",
        "pingone",
        "yandex",
      ]),
      id: Schema.optional(Schema.String),
      scimConfig: Schema.optional(Schema.Unknown),
    }).pipe(
      Schema.encodeKeys({
        config: "config",
        name: "name",
        type: "type",
        id: "id",
        scimConfig: "scim_config",
      }),
    ),
    Schema.Struct({
      config: Schema.Struct({
        claims: Schema.optional(Schema.Array(Schema.String)),
        clientId: Schema.optional(Schema.String),
        clientSecret: Schema.optional(Schema.String),
        emailClaimName: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          claims: "claims",
          clientId: "client_id",
          clientSecret: "client_secret",
          emailClaimName: "email_claim_name",
        }),
      ),
      name: Schema.String,
      type: Schema.Literals([
        "google",
        "onetimepin",
        "azureAD",
        "saml",
        "centrify",
        "facebook",
        "github",
        "google-apps",
        "linkedin",
        "oidc",
        "okta",
        "onelogin",
        "pingone",
        "yandex",
      ]),
      id: Schema.optional(Schema.String),
      scimConfig: Schema.optional(Schema.Unknown),
    }).pipe(
      Schema.encodeKeys({
        config: "config",
        name: "name",
        type: "type",
        id: "id",
        scimConfig: "scim_config",
      }),
    ),
    Schema.Struct({
      config: Schema.Struct({
        appsDomain: Schema.optional(Schema.String),
        claims: Schema.optional(Schema.Array(Schema.String)),
        clientId: Schema.optional(Schema.String),
        clientSecret: Schema.optional(Schema.String),
        emailClaimName: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          appsDomain: "apps_domain",
          claims: "claims",
          clientId: "client_id",
          clientSecret: "client_secret",
          emailClaimName: "email_claim_name",
        }),
      ),
      name: Schema.String,
      type: Schema.Literals([
        "google",
        "onetimepin",
        "azureAD",
        "saml",
        "centrify",
        "facebook",
        "github",
        "google-apps",
        "linkedin",
        "oidc",
        "okta",
        "onelogin",
        "pingone",
        "yandex",
      ]),
      id: Schema.optional(Schema.String),
      scimConfig: Schema.optional(Schema.Unknown),
    }).pipe(
      Schema.encodeKeys({
        config: "config",
        name: "name",
        type: "type",
        id: "id",
        scimConfig: "scim_config",
      }),
    ),
    Schema.Struct({
      config: Schema.Struct({
        authUrl: Schema.optional(Schema.String),
        certsUrl: Schema.optional(Schema.String),
        claims: Schema.optional(Schema.Array(Schema.String)),
        clientId: Schema.optional(Schema.String),
        clientSecret: Schema.optional(Schema.String),
        emailClaimName: Schema.optional(Schema.String),
        pkceEnabled: Schema.optional(Schema.Boolean),
        scopes: Schema.optional(Schema.Array(Schema.String)),
        tokenUrl: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          authUrl: "auth_url",
          certsUrl: "certs_url",
          claims: "claims",
          clientId: "client_id",
          clientSecret: "client_secret",
          emailClaimName: "email_claim_name",
          pkceEnabled: "pkce_enabled",
          scopes: "scopes",
          tokenUrl: "token_url",
        }),
      ),
      name: Schema.String,
      type: Schema.Literals([
        "google",
        "onetimepin",
        "azureAD",
        "saml",
        "centrify",
        "facebook",
        "github",
        "google-apps",
        "linkedin",
        "oidc",
        "okta",
        "onelogin",
        "pingone",
        "yandex",
      ]),
      id: Schema.optional(Schema.String),
      scimConfig: Schema.optional(Schema.Unknown),
    }).pipe(
      Schema.encodeKeys({
        config: "config",
        name: "name",
        type: "type",
        id: "id",
        scimConfig: "scim_config",
      }),
    ),
    Schema.Struct({
      config: Schema.Struct({
        authorizationServerId: Schema.optional(Schema.String),
        claims: Schema.optional(Schema.Array(Schema.String)),
        clientId: Schema.optional(Schema.String),
        clientSecret: Schema.optional(Schema.String),
        emailClaimName: Schema.optional(Schema.String),
        oktaAccount: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          authorizationServerId: "authorization_server_id",
          claims: "claims",
          clientId: "client_id",
          clientSecret: "client_secret",
          emailClaimName: "email_claim_name",
          oktaAccount: "okta_account",
        }),
      ),
      name: Schema.String,
      type: Schema.Literals([
        "google",
        "onetimepin",
        "azureAD",
        "saml",
        "centrify",
        "facebook",
        "github",
        "google-apps",
        "linkedin",
        "oidc",
        "okta",
        "onelogin",
        "pingone",
        "yandex",
      ]),
      id: Schema.optional(Schema.String),
      scimConfig: Schema.optional(Schema.Unknown),
    }).pipe(
      Schema.encodeKeys({
        config: "config",
        name: "name",
        type: "type",
        id: "id",
        scimConfig: "scim_config",
      }),
    ),
    Schema.Struct({
      config: Schema.Struct({
        claims: Schema.optional(Schema.Array(Schema.String)),
        clientId: Schema.optional(Schema.String),
        clientSecret: Schema.optional(Schema.String),
        emailClaimName: Schema.optional(Schema.String),
        oneloginAccount: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          claims: "claims",
          clientId: "client_id",
          clientSecret: "client_secret",
          emailClaimName: "email_claim_name",
          oneloginAccount: "onelogin_account",
        }),
      ),
      name: Schema.String,
      type: Schema.Literals([
        "google",
        "onetimepin",
        "azureAD",
        "saml",
        "centrify",
        "facebook",
        "github",
        "google-apps",
        "linkedin",
        "oidc",
        "okta",
        "onelogin",
        "pingone",
        "yandex",
      ]),
      id: Schema.optional(Schema.String),
      scimConfig: Schema.optional(Schema.Unknown),
    }).pipe(
      Schema.encodeKeys({
        config: "config",
        name: "name",
        type: "type",
        id: "id",
        scimConfig: "scim_config",
      }),
    ),
    Schema.Struct({
      config: Schema.Struct({
        claims: Schema.optional(Schema.Array(Schema.String)),
        clientId: Schema.optional(Schema.String),
        clientSecret: Schema.optional(Schema.String),
        emailClaimName: Schema.optional(Schema.String),
        pingEnvId: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          claims: "claims",
          clientId: "client_id",
          clientSecret: "client_secret",
          emailClaimName: "email_claim_name",
          pingEnvId: "ping_env_id",
        }),
      ),
      name: Schema.String,
      type: Schema.Literals([
        "google",
        "onetimepin",
        "azureAD",
        "saml",
        "centrify",
        "facebook",
        "github",
        "google-apps",
        "linkedin",
        "oidc",
        "okta",
        "onelogin",
        "pingone",
        "yandex",
      ]),
      id: Schema.optional(Schema.String),
      scimConfig: Schema.optional(Schema.Unknown),
    }).pipe(
      Schema.encodeKeys({
        config: "config",
        name: "name",
        type: "type",
        id: "id",
        scimConfig: "scim_config",
      }),
    ),
    Schema.Struct({
      config: Schema.Struct({
        attributes: Schema.optional(Schema.Array(Schema.String)),
        emailAttributeName: Schema.optional(Schema.String),
        headerAttributes: Schema.optional(
          Schema.Array(
            Schema.Struct({
              attributeName: Schema.optional(Schema.String),
              headerName: Schema.optional(Schema.String),
            }).pipe(
              Schema.encodeKeys({
                attributeName: "attribute_name",
                headerName: "header_name",
              }),
            ),
          ),
        ),
        idpPublicCerts: Schema.optional(Schema.Array(Schema.String)),
        issuerUrl: Schema.optional(Schema.String),
        signRequest: Schema.optional(Schema.Boolean),
        ssoTargetUrl: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          attributes: "attributes",
          emailAttributeName: "email_attribute_name",
          headerAttributes: "header_attributes",
          idpPublicCerts: "idp_public_certs",
          issuerUrl: "issuer_url",
          signRequest: "sign_request",
          ssoTargetUrl: "sso_target_url",
        }),
      ),
      name: Schema.String,
      type: Schema.Literals([
        "google",
        "onetimepin",
        "azureAD",
        "saml",
        "centrify",
        "facebook",
        "github",
        "google-apps",
        "linkedin",
        "oidc",
        "okta",
        "onelogin",
        "pingone",
        "yandex",
      ]),
      id: Schema.optional(Schema.String),
      scimConfig: Schema.optional(Schema.Unknown),
    }).pipe(
      Schema.encodeKeys({
        config: "config",
        name: "name",
        type: "type",
        id: "id",
        scimConfig: "scim_config",
      }),
    ),
  ]),
) as unknown as Schema.Schema<ListIdentityProvidersResponse>;

export type ListIdentityProvidersError = CommonErrors;

export const listIdentityProviders: API.OperationMethod<
  ListIdentityProvidersRequest,
  ListIdentityProvidersResponse,
  ListIdentityProvidersError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListIdentityProvidersRequest,
  output: ListIdentityProvidersResponse,
  errors: [],
}));

export interface CreateIdentityProviderRequest {
  /** Path param: The Account ID to use for this endpoint. Mutually exclusive with the Zone ID. */
  accountId?: string;
  /** Path param: The Zone ID to use for this endpoint. Mutually exclusive with the Account ID. */
  zoneId?: string;
  /** Body param: The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cl */
  config: {
    claims?: string[];
    clientId?: string;
    clientSecret?: string;
    conditionalAccessEnabled?: boolean;
    directoryId?: string;
    emailClaimName?: string;
    prompt?: "login" | "select_account" | "none";
    supportGroups?: boolean;
  };
  /** Body param: The name of the identity provider, shown to users on the login page. */
  name: string;
  /** Body param: The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integrat */
  type:
    | "google"
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
  /** Body param: The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider. */
  scimConfig?: {
    enabled?: boolean;
    identityUpdateBehavior?: "automatic" | "reauth" | "no_action";
    seatDeprovision?: boolean;
    userDeprovision?: boolean;
  };
}

export const CreateIdentityProviderRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  config: Schema.Struct({
    claims: Schema.optional(Schema.Array(Schema.String)),
    clientId: Schema.optional(Schema.String),
    clientSecret: Schema.optional(Schema.String),
    conditionalAccessEnabled: Schema.optional(Schema.Boolean),
    directoryId: Schema.optional(Schema.String),
    emailClaimName: Schema.optional(Schema.String),
    prompt: Schema.optional(
      Schema.Literals(["login", "select_account", "none"]),
    ),
    supportGroups: Schema.optional(Schema.Boolean),
  }).pipe(
    Schema.encodeKeys({
      claims: "claims",
      clientId: "client_id",
      clientSecret: "client_secret",
      conditionalAccessEnabled: "conditional_access_enabled",
      directoryId: "directory_id",
      emailClaimName: "email_claim_name",
      prompt: "prompt",
      supportGroups: "support_groups",
    }),
  ),
  name: Schema.String,
  type: Schema.Literals([
    "google",
    "onetimepin",
    "azureAD",
    "saml",
    "centrify",
    "facebook",
    "github",
    "google-apps",
    "linkedin",
    "oidc",
    "okta",
    "onelogin",
    "pingone",
    "yandex",
  ]),
  scimConfig: Schema.optional(
    Schema.Struct({
      enabled: Schema.optional(Schema.Boolean),
      identityUpdateBehavior: Schema.optional(
        Schema.Literals(["automatic", "reauth", "no_action"]),
      ),
      seatDeprovision: Schema.optional(Schema.Boolean),
      userDeprovision: Schema.optional(Schema.Boolean),
    }).pipe(
      Schema.encodeKeys({
        enabled: "enabled",
        identityUpdateBehavior: "identity_update_behavior",
        seatDeprovision: "seat_deprovision",
        userDeprovision: "user_deprovision",
      }),
    ),
  ),
}).pipe(
  Schema.encodeKeys({
    config: "config",
    name: "name",
    type: "type",
    scimConfig: "scim_config",
  }),
  T.Http({
    method: "POST",
    path: "/{accountOrZone}/{accountOrZoneId}/access/identity_providers",
  }),
) as unknown as Schema.Schema<CreateIdentityProviderRequest>;

export type CreateIdentityProviderResponse =
  | {
      config: {
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        conditionalAccessEnabled?: boolean;
        directoryId?: string;
        emailClaimName?: string;
        prompt?: "login" | "select_account" | "none";
        supportGroups?: boolean;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      accountId?: string;
      zoneId?: string;
      scimConfig?: {
        enabled?: boolean;
        identityUpdateBehavior?: "automatic" | "reauth" | "no_action";
        seatDeprovision?: boolean;
        userDeprovision?: boolean;
      };
    }
  | {
      config: {
        centrifyAccount?: string;
        centrifyAppId?: string;
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: unknown;
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        appsDomain?: string;
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        authUrl?: string;
        certsUrl?: string;
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
        pkceEnabled?: boolean;
        scopes?: string[];
        tokenUrl?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        authorizationServerId?: string;
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
        oktaAccount?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
        oneloginAccount?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
        pingEnvId?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        attributes?: string[];
        emailAttributeName?: string;
        headerAttributes?: { attributeName?: string; headerName?: string }[];
        idpPublicCerts?: string[];
        issuerUrl?: string;
        signRequest?: boolean;
        ssoTargetUrl?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    };

export const CreateIdentityProviderResponse = Schema.Union([
  Schema.Struct({
    config: Schema.Struct({
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      conditionalAccessEnabled: Schema.optional(Schema.Boolean),
      directoryId: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
      prompt: Schema.optional(
        Schema.Literals(["login", "select_account", "none"]),
      ),
      supportGroups: Schema.optional(Schema.Boolean),
    }).pipe(
      Schema.encodeKeys({
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        conditionalAccessEnabled: "conditional_access_enabled",
        directoryId: "directory_id",
        emailClaimName: "email_claim_name",
        prompt: "prompt",
        supportGroups: "support_groups",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    accountId: Schema.optional(Schema.String),
    zoneId: Schema.optional(Schema.String),
    scimConfig: Schema.optional(
      Schema.Struct({
        enabled: Schema.optional(Schema.Boolean),
        identityUpdateBehavior: Schema.optional(
          Schema.Literals(["automatic", "reauth", "no_action"]),
        ),
        seatDeprovision: Schema.optional(Schema.Boolean),
        userDeprovision: Schema.optional(Schema.Boolean),
      }).pipe(
        Schema.encodeKeys({
          enabled: "enabled",
          identityUpdateBehavior: "identity_update_behavior",
          seatDeprovision: "seat_deprovision",
          userDeprovision: "user_deprovision",
        }),
      ),
    ),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      accountId: "account_id",
      zoneId: "zone_id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      centrifyAccount: Schema.optional(Schema.String),
      centrifyAppId: Schema.optional(Schema.String),
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        centrifyAccount: "centrify_account",
        centrifyAppId: "centrify_app_id",
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Unknown,
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      appsDomain: Schema.optional(Schema.String),
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        appsDomain: "apps_domain",
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      authUrl: Schema.optional(Schema.String),
      certsUrl: Schema.optional(Schema.String),
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
      pkceEnabled: Schema.optional(Schema.Boolean),
      scopes: Schema.optional(Schema.Array(Schema.String)),
      tokenUrl: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        authUrl: "auth_url",
        certsUrl: "certs_url",
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
        pkceEnabled: "pkce_enabled",
        scopes: "scopes",
        tokenUrl: "token_url",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      authorizationServerId: Schema.optional(Schema.String),
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
      oktaAccount: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        authorizationServerId: "authorization_server_id",
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
        oktaAccount: "okta_account",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
      oneloginAccount: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
        oneloginAccount: "onelogin_account",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
      pingEnvId: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
        pingEnvId: "ping_env_id",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      attributes: Schema.optional(Schema.Array(Schema.String)),
      emailAttributeName: Schema.optional(Schema.String),
      headerAttributes: Schema.optional(
        Schema.Array(
          Schema.Struct({
            attributeName: Schema.optional(Schema.String),
            headerName: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              attributeName: "attribute_name",
              headerName: "header_name",
            }),
          ),
        ),
      ),
      idpPublicCerts: Schema.optional(Schema.Array(Schema.String)),
      issuerUrl: Schema.optional(Schema.String),
      signRequest: Schema.optional(Schema.Boolean),
      ssoTargetUrl: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        attributes: "attributes",
        emailAttributeName: "email_attribute_name",
        headerAttributes: "header_attributes",
        idpPublicCerts: "idp_public_certs",
        issuerUrl: "issuer_url",
        signRequest: "sign_request",
        ssoTargetUrl: "sso_target_url",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
]) as unknown as Schema.Schema<CreateIdentityProviderResponse>;

export type CreateIdentityProviderError = CommonErrors;

export const createIdentityProvider: API.OperationMethod<
  CreateIdentityProviderRequest,
  CreateIdentityProviderResponse,
  CreateIdentityProviderError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateIdentityProviderRequest,
  output: CreateIdentityProviderResponse,
  errors: [],
}));

export interface UpdateIdentityProviderRequest {
  identityProviderId: string;
  /** Path param: The Account ID to use for this endpoint. Mutually exclusive with the Zone ID. */
  accountId?: string;
  /** Path param: The Zone ID to use for this endpoint. Mutually exclusive with the Account ID. */
  zoneId?: string;
  /** Body param: The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cl */
  config: {
    claims?: string[];
    clientId?: string;
    clientSecret?: string;
    conditionalAccessEnabled?: boolean;
    directoryId?: string;
    emailClaimName?: string;
    prompt?: "login" | "select_account" | "none";
    supportGroups?: boolean;
  };
  /** Body param: The name of the identity provider, shown to users on the login page. */
  name: string;
  /** Body param: The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integrat */
  type:
    | "google"
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
  /** Body param: The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider. */
  scimConfig?: {
    enabled?: boolean;
    identityUpdateBehavior?: "automatic" | "reauth" | "no_action";
    seatDeprovision?: boolean;
    userDeprovision?: boolean;
  };
}

export const UpdateIdentityProviderRequest = Schema.Struct({
  identityProviderId: Schema.String.pipe(T.HttpPath("identityProviderId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  config: Schema.Struct({
    claims: Schema.optional(Schema.Array(Schema.String)),
    clientId: Schema.optional(Schema.String),
    clientSecret: Schema.optional(Schema.String),
    conditionalAccessEnabled: Schema.optional(Schema.Boolean),
    directoryId: Schema.optional(Schema.String),
    emailClaimName: Schema.optional(Schema.String),
    prompt: Schema.optional(
      Schema.Literals(["login", "select_account", "none"]),
    ),
    supportGroups: Schema.optional(Schema.Boolean),
  }).pipe(
    Schema.encodeKeys({
      claims: "claims",
      clientId: "client_id",
      clientSecret: "client_secret",
      conditionalAccessEnabled: "conditional_access_enabled",
      directoryId: "directory_id",
      emailClaimName: "email_claim_name",
      prompt: "prompt",
      supportGroups: "support_groups",
    }),
  ),
  name: Schema.String,
  type: Schema.Literals([
    "google",
    "onetimepin",
    "azureAD",
    "saml",
    "centrify",
    "facebook",
    "github",
    "google-apps",
    "linkedin",
    "oidc",
    "okta",
    "onelogin",
    "pingone",
    "yandex",
  ]),
  scimConfig: Schema.optional(
    Schema.Struct({
      enabled: Schema.optional(Schema.Boolean),
      identityUpdateBehavior: Schema.optional(
        Schema.Literals(["automatic", "reauth", "no_action"]),
      ),
      seatDeprovision: Schema.optional(Schema.Boolean),
      userDeprovision: Schema.optional(Schema.Boolean),
    }).pipe(
      Schema.encodeKeys({
        enabled: "enabled",
        identityUpdateBehavior: "identity_update_behavior",
        seatDeprovision: "seat_deprovision",
        userDeprovision: "user_deprovision",
      }),
    ),
  ),
}).pipe(
  Schema.encodeKeys({
    config: "config",
    name: "name",
    type: "type",
    scimConfig: "scim_config",
  }),
  T.Http({
    method: "PUT",
    path: "/{accountOrZone}/{accountOrZoneId}/access/identity_providers/{identityProviderId}",
  }),
) as unknown as Schema.Schema<UpdateIdentityProviderRequest>;

export type UpdateIdentityProviderResponse =
  | {
      config: {
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        conditionalAccessEnabled?: boolean;
        directoryId?: string;
        emailClaimName?: string;
        prompt?: "login" | "select_account" | "none";
        supportGroups?: boolean;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      accountId?: string;
      zoneId?: string;
      scimConfig?: {
        enabled?: boolean;
        identityUpdateBehavior?: "automatic" | "reauth" | "no_action";
        seatDeprovision?: boolean;
        userDeprovision?: boolean;
      };
    }
  | {
      config: {
        centrifyAccount?: string;
        centrifyAppId?: string;
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: unknown;
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        appsDomain?: string;
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        authUrl?: string;
        certsUrl?: string;
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
        pkceEnabled?: boolean;
        scopes?: string[];
        tokenUrl?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        authorizationServerId?: string;
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
        oktaAccount?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
        oneloginAccount?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        claims?: string[];
        clientId?: string;
        clientSecret?: string;
        emailClaimName?: string;
        pingEnvId?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    }
  | {
      config: {
        attributes?: string[];
        emailAttributeName?: string;
        headerAttributes?: { attributeName?: string; headerName?: string }[];
        idpPublicCerts?: string[];
        issuerUrl?: string;
        signRequest?: boolean;
        ssoTargetUrl?: string;
      };
      name: string;
      type:
        | "google"
        | "onetimepin"
        | "azureAD"
        | "saml"
        | "centrify"
        | "facebook"
        | "github"
        | "google-apps"
        | "linkedin"
        | "oidc"
        | "okta"
        | "onelogin"
        | "pingone"
        | "yandex";
      id?: string;
      scimConfig?: unknown;
    };

export const UpdateIdentityProviderResponse = Schema.Union([
  Schema.Struct({
    config: Schema.Struct({
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      conditionalAccessEnabled: Schema.optional(Schema.Boolean),
      directoryId: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
      prompt: Schema.optional(
        Schema.Literals(["login", "select_account", "none"]),
      ),
      supportGroups: Schema.optional(Schema.Boolean),
    }).pipe(
      Schema.encodeKeys({
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        conditionalAccessEnabled: "conditional_access_enabled",
        directoryId: "directory_id",
        emailClaimName: "email_claim_name",
        prompt: "prompt",
        supportGroups: "support_groups",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    accountId: Schema.optional(Schema.String),
    zoneId: Schema.optional(Schema.String),
    scimConfig: Schema.optional(
      Schema.Struct({
        enabled: Schema.optional(Schema.Boolean),
        identityUpdateBehavior: Schema.optional(
          Schema.Literals(["automatic", "reauth", "no_action"]),
        ),
        seatDeprovision: Schema.optional(Schema.Boolean),
        userDeprovision: Schema.optional(Schema.Boolean),
      }).pipe(
        Schema.encodeKeys({
          enabled: "enabled",
          identityUpdateBehavior: "identity_update_behavior",
          seatDeprovision: "seat_deprovision",
          userDeprovision: "user_deprovision",
        }),
      ),
    ),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      accountId: "account_id",
      zoneId: "zone_id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      centrifyAccount: Schema.optional(Schema.String),
      centrifyAppId: Schema.optional(Schema.String),
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        centrifyAccount: "centrify_account",
        centrifyAppId: "centrify_app_id",
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Unknown,
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      appsDomain: Schema.optional(Schema.String),
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        appsDomain: "apps_domain",
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      authUrl: Schema.optional(Schema.String),
      certsUrl: Schema.optional(Schema.String),
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
      pkceEnabled: Schema.optional(Schema.Boolean),
      scopes: Schema.optional(Schema.Array(Schema.String)),
      tokenUrl: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        authUrl: "auth_url",
        certsUrl: "certs_url",
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
        pkceEnabled: "pkce_enabled",
        scopes: "scopes",
        tokenUrl: "token_url",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      authorizationServerId: Schema.optional(Schema.String),
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
      oktaAccount: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        authorizationServerId: "authorization_server_id",
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
        oktaAccount: "okta_account",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
      oneloginAccount: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
        oneloginAccount: "onelogin_account",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      claims: Schema.optional(Schema.Array(Schema.String)),
      clientId: Schema.optional(Schema.String),
      clientSecret: Schema.optional(Schema.String),
      emailClaimName: Schema.optional(Schema.String),
      pingEnvId: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        claims: "claims",
        clientId: "client_id",
        clientSecret: "client_secret",
        emailClaimName: "email_claim_name",
        pingEnvId: "ping_env_id",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
  Schema.Struct({
    config: Schema.Struct({
      attributes: Schema.optional(Schema.Array(Schema.String)),
      emailAttributeName: Schema.optional(Schema.String),
      headerAttributes: Schema.optional(
        Schema.Array(
          Schema.Struct({
            attributeName: Schema.optional(Schema.String),
            headerName: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              attributeName: "attribute_name",
              headerName: "header_name",
            }),
          ),
        ),
      ),
      idpPublicCerts: Schema.optional(Schema.Array(Schema.String)),
      issuerUrl: Schema.optional(Schema.String),
      signRequest: Schema.optional(Schema.Boolean),
      ssoTargetUrl: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        attributes: "attributes",
        emailAttributeName: "email_attribute_name",
        headerAttributes: "header_attributes",
        idpPublicCerts: "idp_public_certs",
        issuerUrl: "issuer_url",
        signRequest: "sign_request",
        ssoTargetUrl: "sso_target_url",
      }),
    ),
    name: Schema.String,
    type: Schema.Literals([
      "google",
      "onetimepin",
      "azureAD",
      "saml",
      "centrify",
      "facebook",
      "github",
      "google-apps",
      "linkedin",
      "oidc",
      "okta",
      "onelogin",
      "pingone",
      "yandex",
    ]),
    id: Schema.optional(Schema.String),
    scimConfig: Schema.optional(Schema.Unknown),
  }).pipe(
    Schema.encodeKeys({
      config: "config",
      name: "name",
      type: "type",
      id: "id",
      scimConfig: "scim_config",
    }),
  ),
]) as unknown as Schema.Schema<UpdateIdentityProviderResponse>;

export type UpdateIdentityProviderError = CommonErrors;

export const updateIdentityProvider: API.OperationMethod<
  UpdateIdentityProviderRequest,
  UpdateIdentityProviderResponse,
  UpdateIdentityProviderError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateIdentityProviderRequest,
  output: UpdateIdentityProviderResponse,
  errors: [],
}));

export interface DeleteIdentityProviderRequest {
  identityProviderId: string;
}

export const DeleteIdentityProviderRequest = Schema.Struct({
  identityProviderId: Schema.String.pipe(T.HttpPath("identityProviderId")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/{accountOrZone}/{accountOrZoneId}/access/identity_providers/{identityProviderId}",
  }),
) as unknown as Schema.Schema<DeleteIdentityProviderRequest>;

export interface DeleteIdentityProviderResponse {
  /** UUID. */
  id?: string;
}

export const DeleteIdentityProviderResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
}) as unknown as Schema.Schema<DeleteIdentityProviderResponse>;

export type DeleteIdentityProviderError = CommonErrors;

export const deleteIdentityProvider: API.OperationMethod<
  DeleteIdentityProviderRequest,
  DeleteIdentityProviderResponse,
  DeleteIdentityProviderError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteIdentityProviderRequest,
  output: DeleteIdentityProviderResponse,
  errors: [],
}));

// =============================================================================
// IdentityProviderScimGroup
// =============================================================================

export interface ListIdentityProviderScimGroupsRequest {
  identityProviderId: string;
  /** Path param: Identifier. */
  accountId: string;
  /** Query param: The unique Cloudflare-generated Id of the SCIM Group resource; also known as the "Id". */
  cfResourceId?: string;
  /** Query param: The IdP-generated Id of the SCIM Group resource; also known as the "external Id". */
  idpResourceId?: string;
  /** Query param: The display name of the SCIM Group resource. */
  name?: string;
}

export const ListIdentityProviderScimGroupsRequest = Schema.Struct({
  identityProviderId: Schema.String.pipe(T.HttpPath("identityProviderId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  cfResourceId: Schema.optional(Schema.String).pipe(
    T.HttpQuery("cf_resource_id"),
  ),
  idpResourceId: Schema.optional(Schema.String).pipe(
    T.HttpQuery("idp_resource_id"),
  ),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/identity_providers/{identityProviderId}/scim/groups",
  }),
) as unknown as Schema.Schema<ListIdentityProviderScimGroupsRequest>;

export type ListIdentityProviderScimGroupsResponse = unknown;

export const ListIdentityProviderScimGroupsResponse =
  Schema.Unknown as unknown as Schema.Schema<ListIdentityProviderScimGroupsResponse>;

export type ListIdentityProviderScimGroupsError = CommonErrors;

export const listIdentityProviderScimGroups: API.OperationMethod<
  ListIdentityProviderScimGroupsRequest,
  ListIdentityProviderScimGroupsResponse,
  ListIdentityProviderScimGroupsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListIdentityProviderScimGroupsRequest,
  output: ListIdentityProviderScimGroupsResponse,
  errors: [],
}));

// =============================================================================
// IdentityProviderScimUser
// =============================================================================

export interface ListIdentityProviderScimUsersRequest {
  identityProviderId: string;
  /** Path param: Identifier. */
  accountId: string;
  /** Query param: The unique Cloudflare-generated Id of the SCIM User resource; also known as the "Id". */
  cfResourceId?: string;
  /** Query param: The email address of the SCIM User resource. */
  email?: string;
  /** Query param: The IdP-generated Id of the SCIM User resource; also known as the "external Id". */
  idpResourceId?: string;
  /** Query param: The name of the SCIM User resource. */
  name?: string;
  /** Query param: The username of the SCIM User resource. */
  username?: string;
}

export const ListIdentityProviderScimUsersRequest = Schema.Struct({
  identityProviderId: Schema.String.pipe(T.HttpPath("identityProviderId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  cfResourceId: Schema.optional(Schema.String).pipe(
    T.HttpQuery("cf_resource_id"),
  ),
  email: Schema.optional(Schema.String).pipe(T.HttpQuery("email")),
  idpResourceId: Schema.optional(Schema.String).pipe(
    T.HttpQuery("idp_resource_id"),
  ),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  username: Schema.optional(Schema.String).pipe(T.HttpQuery("username")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/identity_providers/{identityProviderId}/scim/users",
  }),
) as unknown as Schema.Schema<ListIdentityProviderScimUsersRequest>;

export type ListIdentityProviderScimUsersResponse = unknown;

export const ListIdentityProviderScimUsersResponse =
  Schema.Unknown as unknown as Schema.Schema<ListIdentityProviderScimUsersResponse>;

export type ListIdentityProviderScimUsersError = CommonErrors;

export const listIdentityProviderScimUsers: API.OperationMethod<
  ListIdentityProviderScimUsersRequest,
  ListIdentityProviderScimUsersResponse,
  ListIdentityProviderScimUsersError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListIdentityProviderScimUsersRequest,
  output: ListIdentityProviderScimUsersResponse,
  errors: [],
}));

// =============================================================================
// NetworkHostnameRoute
// =============================================================================

export interface GetNetworkHostnameRouteRequest {
  hostnameRouteId: string;
  /** Cloudflare account ID */
  accountId: string;
}

export const GetNetworkHostnameRouteRequest = Schema.Struct({
  hostnameRouteId: Schema.String.pipe(T.HttpPath("hostnameRouteId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/zerotrust/routes/hostname/{hostnameRouteId}",
  }),
) as unknown as Schema.Schema<GetNetworkHostnameRouteRequest>;

export interface GetNetworkHostnameRouteResponse {
  /** The hostname route ID. */
  id?: string;
  /** An optional description of the hostname route. */
  comment?: string;
  /** Timestamp of when the resource was created. */
  createdAt?: string;
  /** Timestamp of when the resource was deleted. If `null`, the resource has not been deleted. */
  deletedAt?: string;
  /** The hostname of the route. */
  hostname?: string;
  /** UUID of the tunnel. */
  tunnelId?: string;
  /** A user-friendly name for a tunnel. */
  tunnelName?: string;
}

export const GetNetworkHostnameRouteResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  comment: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  deletedAt: Schema.optional(Schema.String),
  hostname: Schema.optional(Schema.String),
  tunnelId: Schema.optional(Schema.String),
  tunnelName: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    comment: "comment",
    createdAt: "created_at",
    deletedAt: "deleted_at",
    hostname: "hostname",
    tunnelId: "tunnel_id",
    tunnelName: "tunnel_name",
  }),
) as unknown as Schema.Schema<GetNetworkHostnameRouteResponse>;

export type GetNetworkHostnameRouteError = CommonErrors;

export const getNetworkHostnameRoute: API.OperationMethod<
  GetNetworkHostnameRouteRequest,
  GetNetworkHostnameRouteResponse,
  GetNetworkHostnameRouteError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetNetworkHostnameRouteRequest,
  output: GetNetworkHostnameRouteResponse,
  errors: [],
}));

export interface ListNetworkHostnameRoutesRequest {
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Query param: The hostname route ID. */
  id?: string;
  /** Query param: If set, only list hostname routes with the given comment. */
  comment?: string;
  /** Query param: If provided, include only resources that were created (and not deleted) before this time. URL encoded. */
  existedAt?: string;
  /** Query param: If set, only list hostname routes that contain a substring of the given value, the filter is case-insensitive. */
  hostname?: string;
  /** Query param: If `true`, only return deleted hostname routes. If `false`, exclude deleted hostname routes. */
  isDeleted?: boolean;
  /** Query param: If set, only list hostname routes that point to a specific tunnel. */
  tunnelId?: string;
}

export const ListNetworkHostnameRoutesRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.optional(Schema.String).pipe(T.HttpQuery("id")),
  comment: Schema.optional(Schema.String).pipe(T.HttpQuery("comment")),
  existedAt: Schema.optional(Schema.String).pipe(T.HttpQuery("existed_at")),
  hostname: Schema.optional(Schema.String).pipe(T.HttpQuery("hostname")),
  isDeleted: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_deleted")),
  tunnelId: Schema.optional(Schema.String).pipe(T.HttpQuery("tunnel_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/zerotrust/routes/hostname",
  }),
) as unknown as Schema.Schema<ListNetworkHostnameRoutesRequest>;

export type ListNetworkHostnameRoutesResponse = {
  id?: string;
  comment?: string;
  createdAt?: string;
  deletedAt?: string;
  hostname?: string;
  tunnelId?: string;
  tunnelName?: string;
}[];

export const ListNetworkHostnameRoutesResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    comment: Schema.optional(Schema.String),
    createdAt: Schema.optional(Schema.String),
    deletedAt: Schema.optional(Schema.String),
    hostname: Schema.optional(Schema.String),
    tunnelId: Schema.optional(Schema.String),
    tunnelName: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      comment: "comment",
      createdAt: "created_at",
      deletedAt: "deleted_at",
      hostname: "hostname",
      tunnelId: "tunnel_id",
      tunnelName: "tunnel_name",
    }),
  ),
) as unknown as Schema.Schema<ListNetworkHostnameRoutesResponse>;

export type ListNetworkHostnameRoutesError = CommonErrors;

export const listNetworkHostnameRoutes: API.OperationMethod<
  ListNetworkHostnameRoutesRequest,
  ListNetworkHostnameRoutesResponse,
  ListNetworkHostnameRoutesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListNetworkHostnameRoutesRequest,
  output: ListNetworkHostnameRoutesResponse,
  errors: [],
}));

export interface CreateNetworkHostnameRouteRequest {
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Body param: An optional description of the hostname route. */
  comment?: string;
  /** Body param: The hostname of the route. */
  hostname?: string;
  /** Body param: UUID of the tunnel. */
  tunnelId?: string;
}

export const CreateNetworkHostnameRouteRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  comment: Schema.optional(Schema.String),
  hostname: Schema.optional(Schema.String),
  tunnelId: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    comment: "comment",
    hostname: "hostname",
    tunnelId: "tunnel_id",
  }),
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/zerotrust/routes/hostname",
  }),
) as unknown as Schema.Schema<CreateNetworkHostnameRouteRequest>;

export interface CreateNetworkHostnameRouteResponse {
  /** The hostname route ID. */
  id?: string;
  /** An optional description of the hostname route. */
  comment?: string;
  /** Timestamp of when the resource was created. */
  createdAt?: string;
  /** Timestamp of when the resource was deleted. If `null`, the resource has not been deleted. */
  deletedAt?: string;
  /** The hostname of the route. */
  hostname?: string;
  /** UUID of the tunnel. */
  tunnelId?: string;
  /** A user-friendly name for a tunnel. */
  tunnelName?: string;
}

export const CreateNetworkHostnameRouteResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  comment: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  deletedAt: Schema.optional(Schema.String),
  hostname: Schema.optional(Schema.String),
  tunnelId: Schema.optional(Schema.String),
  tunnelName: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    comment: "comment",
    createdAt: "created_at",
    deletedAt: "deleted_at",
    hostname: "hostname",
    tunnelId: "tunnel_id",
    tunnelName: "tunnel_name",
  }),
) as unknown as Schema.Schema<CreateNetworkHostnameRouteResponse>;

export type CreateNetworkHostnameRouteError = CommonErrors;

export const createNetworkHostnameRoute: API.OperationMethod<
  CreateNetworkHostnameRouteRequest,
  CreateNetworkHostnameRouteResponse,
  CreateNetworkHostnameRouteError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateNetworkHostnameRouteRequest,
  output: CreateNetworkHostnameRouteResponse,
  errors: [],
}));

export interface PatchNetworkHostnameRouteRequest {
  hostnameRouteId: string;
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Body param: An optional description of the hostname route. */
  comment?: string;
  /** Body param: The hostname of the route. */
  hostname?: string;
  /** Body param: UUID of the tunnel. */
  tunnelId?: string;
}

export const PatchNetworkHostnameRouteRequest = Schema.Struct({
  hostnameRouteId: Schema.String.pipe(T.HttpPath("hostnameRouteId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  comment: Schema.optional(Schema.String),
  hostname: Schema.optional(Schema.String),
  tunnelId: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    comment: "comment",
    hostname: "hostname",
    tunnelId: "tunnel_id",
  }),
  T.Http({
    method: "PATCH",
    path: "/accounts/{account_id}/zerotrust/routes/hostname/{hostnameRouteId}",
  }),
) as unknown as Schema.Schema<PatchNetworkHostnameRouteRequest>;

export interface PatchNetworkHostnameRouteResponse {
  /** The hostname route ID. */
  id?: string;
  /** An optional description of the hostname route. */
  comment?: string;
  /** Timestamp of when the resource was created. */
  createdAt?: string;
  /** Timestamp of when the resource was deleted. If `null`, the resource has not been deleted. */
  deletedAt?: string;
  /** The hostname of the route. */
  hostname?: string;
  /** UUID of the tunnel. */
  tunnelId?: string;
  /** A user-friendly name for a tunnel. */
  tunnelName?: string;
}

export const PatchNetworkHostnameRouteResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  comment: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  deletedAt: Schema.optional(Schema.String),
  hostname: Schema.optional(Schema.String),
  tunnelId: Schema.optional(Schema.String),
  tunnelName: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    comment: "comment",
    createdAt: "created_at",
    deletedAt: "deleted_at",
    hostname: "hostname",
    tunnelId: "tunnel_id",
    tunnelName: "tunnel_name",
  }),
) as unknown as Schema.Schema<PatchNetworkHostnameRouteResponse>;

export type PatchNetworkHostnameRouteError = CommonErrors;

export const patchNetworkHostnameRoute: API.OperationMethod<
  PatchNetworkHostnameRouteRequest,
  PatchNetworkHostnameRouteResponse,
  PatchNetworkHostnameRouteError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchNetworkHostnameRouteRequest,
  output: PatchNetworkHostnameRouteResponse,
  errors: [],
}));

export interface DeleteNetworkHostnameRouteRequest {
  hostnameRouteId: string;
  /** Cloudflare account ID */
  accountId: string;
}

export const DeleteNetworkHostnameRouteRequest = Schema.Struct({
  hostnameRouteId: Schema.String.pipe(T.HttpPath("hostnameRouteId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/zerotrust/routes/hostname/{hostnameRouteId}",
  }),
) as unknown as Schema.Schema<DeleteNetworkHostnameRouteRequest>;

export interface DeleteNetworkHostnameRouteResponse {
  /** The hostname route ID. */
  id?: string;
  /** An optional description of the hostname route. */
  comment?: string;
  /** Timestamp of when the resource was created. */
  createdAt?: string;
  /** Timestamp of when the resource was deleted. If `null`, the resource has not been deleted. */
  deletedAt?: string;
  /** The hostname of the route. */
  hostname?: string;
  /** UUID of the tunnel. */
  tunnelId?: string;
  /** A user-friendly name for a tunnel. */
  tunnelName?: string;
}

export const DeleteNetworkHostnameRouteResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  comment: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  deletedAt: Schema.optional(Schema.String),
  hostname: Schema.optional(Schema.String),
  tunnelId: Schema.optional(Schema.String),
  tunnelName: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    comment: "comment",
    createdAt: "created_at",
    deletedAt: "deleted_at",
    hostname: "hostname",
    tunnelId: "tunnel_id",
    tunnelName: "tunnel_name",
  }),
) as unknown as Schema.Schema<DeleteNetworkHostnameRouteResponse>;

export type DeleteNetworkHostnameRouteError = CommonErrors;

export const deleteNetworkHostnameRoute: API.OperationMethod<
  DeleteNetworkHostnameRouteRequest,
  DeleteNetworkHostnameRouteResponse,
  DeleteNetworkHostnameRouteError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteNetworkHostnameRouteRequest,
  output: DeleteNetworkHostnameRouteResponse,
  errors: [],
}));

// =============================================================================
// NetworkRoute
// =============================================================================

export interface GetNetworkRouteRequest {
  routeId: string;
  /** Cloudflare account ID */
  accountId: string;
}

export const GetNetworkRouteRequest = Schema.Struct({
  routeId: Schema.String.pipe(T.HttpPath("routeId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/teamnet/routes/{routeId}",
  }),
) as unknown as Schema.Schema<GetNetworkRouteRequest>;

export interface GetNetworkRouteResponse {
  /** UUID of the route. */
  id?: string;
  /** Optional remark describing the route. */
  comment?: string;
  /** Timestamp of when the resource was created. */
  createdAt?: string;
  /** Timestamp of when the resource was deleted. If `null`, the resource has not been deleted. */
  deletedAt?: string;
  /** The private IPv4 or IPv6 range connected by the route, in CIDR notation. */
  network?: string;
  /** UUID of the tunnel. */
  tunnelId?: string;
  /** UUID of the virtual network. */
  virtualNetworkId?: string;
}

export const GetNetworkRouteResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  comment: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  deletedAt: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
  tunnelId: Schema.optional(Schema.String),
  virtualNetworkId: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    comment: "comment",
    createdAt: "created_at",
    deletedAt: "deleted_at",
    network: "network",
    tunnelId: "tunnel_id",
    virtualNetworkId: "virtual_network_id",
  }),
) as unknown as Schema.Schema<GetNetworkRouteResponse>;

export type GetNetworkRouteError = CommonErrors;

export const getNetworkRoute: API.OperationMethod<
  GetNetworkRouteRequest,
  GetNetworkRouteResponse,
  GetNetworkRouteError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetNetworkRouteRequest,
  output: GetNetworkRouteResponse,
  errors: [],
}));

export interface ListNetworkRoutesRequest {
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Query param: Optional remark describing the route. */
  comment?: string;
  /** Query param: If provided, include only resources that were created (and not deleted) before this time. URL encoded. */
  existedAt?: string;
  /** Query param: If `true`, only include deleted routes. If `false`, exclude deleted routes. If empty, all routes will be included. */
  isDeleted?: boolean;
  /** Query param: If set, only list routes that are contained within this IP range. */
  networkSubset?: string;
  /** Query param: If set, only list routes that contain this IP range. */
  networkSuperset?: string;
  /** Query param: UUID of the route. */
  routeId?: string;
  /** Query param: The types of tunnels to filter by, separated by commas. */
  tunTypes?: (
    | "cfd_tunnel"
    | "warp_connector"
    | "warp"
    | "magic"
    | "ip_sec"
    | "gre"
    | "cni"
  )[];
  /** Query param: UUID of the tunnel. */
  tunnelId?: string;
  /** Query param: UUID of the virtual network. */
  virtualNetworkId?: string;
}

export const ListNetworkRoutesRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  comment: Schema.optional(Schema.String).pipe(T.HttpQuery("comment")),
  existedAt: Schema.optional(Schema.String).pipe(T.HttpQuery("existed_at")),
  isDeleted: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_deleted")),
  networkSubset: Schema.optional(Schema.String).pipe(
    T.HttpQuery("network_subset"),
  ),
  networkSuperset: Schema.optional(Schema.String).pipe(
    T.HttpQuery("network_superset"),
  ),
  routeId: Schema.optional(Schema.String).pipe(T.HttpQuery("route_id")),
  tunTypes: Schema.optional(
    Schema.Array(
      Schema.Literals([
        "cfd_tunnel",
        "warp_connector",
        "warp",
        "magic",
        "ip_sec",
        "gre",
        "cni",
      ]),
    ),
  ).pipe(T.HttpQuery("tun_types")),
  tunnelId: Schema.optional(Schema.String).pipe(T.HttpQuery("tunnel_id")),
  virtualNetworkId: Schema.optional(Schema.String).pipe(
    T.HttpQuery("virtual_network_id"),
  ),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/teamnet/routes" }),
) as unknown as Schema.Schema<ListNetworkRoutesRequest>;

export type ListNetworkRoutesResponse = {
  id?: string;
  comment?: string;
  createdAt?: string;
  deletedAt?: string;
  network?: string;
  tunType?:
    | "cfd_tunnel"
    | "warp_connector"
    | "warp"
    | "magic"
    | "ip_sec"
    | "gre"
    | "cni";
  tunnelId?: string;
  tunnelName?: string;
  virtualNetworkId?: string;
  virtualNetworkName?: string;
}[];

export const ListNetworkRoutesResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    comment: Schema.optional(Schema.String),
    createdAt: Schema.optional(Schema.String),
    deletedAt: Schema.optional(Schema.String),
    network: Schema.optional(Schema.String),
    tunType: Schema.optional(
      Schema.Literals([
        "cfd_tunnel",
        "warp_connector",
        "warp",
        "magic",
        "ip_sec",
        "gre",
        "cni",
      ]),
    ),
    tunnelId: Schema.optional(Schema.String),
    tunnelName: Schema.optional(Schema.String),
    virtualNetworkId: Schema.optional(Schema.String),
    virtualNetworkName: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      comment: "comment",
      createdAt: "created_at",
      deletedAt: "deleted_at",
      network: "network",
      tunType: "tun_type",
      tunnelId: "tunnel_id",
      tunnelName: "tunnel_name",
      virtualNetworkId: "virtual_network_id",
      virtualNetworkName: "virtual_network_name",
    }),
  ),
) as unknown as Schema.Schema<ListNetworkRoutesResponse>;

export type ListNetworkRoutesError = CommonErrors;

export const listNetworkRoutes: API.OperationMethod<
  ListNetworkRoutesRequest,
  ListNetworkRoutesResponse,
  ListNetworkRoutesError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListNetworkRoutesRequest,
  output: ListNetworkRoutesResponse,
  errors: [],
}));

export interface CreateNetworkRouteRequest {
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Body param: The private IPv4 or IPv6 range connected by the route, in CIDR notation. */
  network: string;
  /** Body param: UUID of the tunnel. */
  tunnelId: string;
  /** Body param: Optional remark describing the route. */
  comment?: string;
  /** Body param: UUID of the virtual network. */
  virtualNetworkId?: string;
}

export const CreateNetworkRouteRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  network: Schema.String,
  tunnelId: Schema.String,
  comment: Schema.optional(Schema.String),
  virtualNetworkId: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    network: "network",
    tunnelId: "tunnel_id",
    comment: "comment",
    virtualNetworkId: "virtual_network_id",
  }),
  T.Http({ method: "POST", path: "/accounts/{account_id}/teamnet/routes" }),
) as unknown as Schema.Schema<CreateNetworkRouteRequest>;

export interface CreateNetworkRouteResponse {
  /** UUID of the route. */
  id?: string;
  /** Optional remark describing the route. */
  comment?: string;
  /** Timestamp of when the resource was created. */
  createdAt?: string;
  /** Timestamp of when the resource was deleted. If `null`, the resource has not been deleted. */
  deletedAt?: string;
  /** The private IPv4 or IPv6 range connected by the route, in CIDR notation. */
  network?: string;
  /** UUID of the tunnel. */
  tunnelId?: string;
  /** UUID of the virtual network. */
  virtualNetworkId?: string;
}

export const CreateNetworkRouteResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  comment: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  deletedAt: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
  tunnelId: Schema.optional(Schema.String),
  virtualNetworkId: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    comment: "comment",
    createdAt: "created_at",
    deletedAt: "deleted_at",
    network: "network",
    tunnelId: "tunnel_id",
    virtualNetworkId: "virtual_network_id",
  }),
) as unknown as Schema.Schema<CreateNetworkRouteResponse>;

export type CreateNetworkRouteError = CommonErrors;

export const createNetworkRoute: API.OperationMethod<
  CreateNetworkRouteRequest,
  CreateNetworkRouteResponse,
  CreateNetworkRouteError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateNetworkRouteRequest,
  output: CreateNetworkRouteResponse,
  errors: [],
}));

export interface PatchNetworkRouteRequest {
  routeId: string;
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Body param: Optional remark describing the route. */
  comment?: string;
  /** Body param: The private IPv4 or IPv6 range connected by the route, in CIDR notation. */
  network?: string;
  /** Body param: UUID of the tunnel. */
  tunnelId?: string;
  /** Body param: UUID of the virtual network. */
  virtualNetworkId?: string;
}

export const PatchNetworkRouteRequest = Schema.Struct({
  routeId: Schema.String.pipe(T.HttpPath("routeId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  comment: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
  tunnelId: Schema.optional(Schema.String),
  virtualNetworkId: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    comment: "comment",
    network: "network",
    tunnelId: "tunnel_id",
    virtualNetworkId: "virtual_network_id",
  }),
  T.Http({
    method: "PATCH",
    path: "/accounts/{account_id}/teamnet/routes/{routeId}",
  }),
) as unknown as Schema.Schema<PatchNetworkRouteRequest>;

export interface PatchNetworkRouteResponse {
  /** UUID of the route. */
  id?: string;
  /** Optional remark describing the route. */
  comment?: string;
  /** Timestamp of when the resource was created. */
  createdAt?: string;
  /** Timestamp of when the resource was deleted. If `null`, the resource has not been deleted. */
  deletedAt?: string;
  /** The private IPv4 or IPv6 range connected by the route, in CIDR notation. */
  network?: string;
  /** UUID of the tunnel. */
  tunnelId?: string;
  /** UUID of the virtual network. */
  virtualNetworkId?: string;
}

export const PatchNetworkRouteResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  comment: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  deletedAt: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
  tunnelId: Schema.optional(Schema.String),
  virtualNetworkId: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    comment: "comment",
    createdAt: "created_at",
    deletedAt: "deleted_at",
    network: "network",
    tunnelId: "tunnel_id",
    virtualNetworkId: "virtual_network_id",
  }),
) as unknown as Schema.Schema<PatchNetworkRouteResponse>;

export type PatchNetworkRouteError = CommonErrors;

export const patchNetworkRoute: API.OperationMethod<
  PatchNetworkRouteRequest,
  PatchNetworkRouteResponse,
  PatchNetworkRouteError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchNetworkRouteRequest,
  output: PatchNetworkRouteResponse,
  errors: [],
}));

export interface DeleteNetworkRouteRequest {
  routeId: string;
  /** Cloudflare account ID */
  accountId: string;
}

export const DeleteNetworkRouteRequest = Schema.Struct({
  routeId: Schema.String.pipe(T.HttpPath("routeId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/teamnet/routes/{routeId}",
  }),
) as unknown as Schema.Schema<DeleteNetworkRouteRequest>;

export interface DeleteNetworkRouteResponse {
  /** UUID of the route. */
  id?: string;
  /** Optional remark describing the route. */
  comment?: string;
  /** Timestamp of when the resource was created. */
  createdAt?: string;
  /** Timestamp of when the resource was deleted. If `null`, the resource has not been deleted. */
  deletedAt?: string;
  /** The private IPv4 or IPv6 range connected by the route, in CIDR notation. */
  network?: string;
  /** UUID of the tunnel. */
  tunnelId?: string;
  /** UUID of the virtual network. */
  virtualNetworkId?: string;
}

export const DeleteNetworkRouteResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  comment: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  deletedAt: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
  tunnelId: Schema.optional(Schema.String),
  virtualNetworkId: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    comment: "comment",
    createdAt: "created_at",
    deletedAt: "deleted_at",
    network: "network",
    tunnelId: "tunnel_id",
    virtualNetworkId: "virtual_network_id",
  }),
) as unknown as Schema.Schema<DeleteNetworkRouteResponse>;

export type DeleteNetworkRouteError = CommonErrors;

export const deleteNetworkRoute: API.OperationMethod<
  DeleteNetworkRouteRequest,
  DeleteNetworkRouteResponse,
  DeleteNetworkRouteError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteNetworkRouteRequest,
  output: DeleteNetworkRouteResponse,
  errors: [],
}));

// =============================================================================
// NetworkRouteIp
// =============================================================================

export interface GetNetworkRouteIpRequest {
  ip: string;
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Query param: When the virtual_network_id parameter is not provided the request filter will default search routes that are in the default virtual network for the account. If this parameter is set to fa */
  defaultVirtualNetworkFallback?: boolean;
  /** Query param: UUID of the virtual network. */
  virtualNetworkId?: string;
}

export const GetNetworkRouteIpRequest = Schema.Struct({
  ip: Schema.String.pipe(T.HttpPath("ip")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  defaultVirtualNetworkFallback: Schema.optional(Schema.Boolean).pipe(
    T.HttpQuery("default_virtual_network_fallback"),
  ),
  virtualNetworkId: Schema.optional(Schema.String).pipe(
    T.HttpQuery("virtual_network_id"),
  ),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/teamnet/routes/ip/{ip}",
  }),
) as unknown as Schema.Schema<GetNetworkRouteIpRequest>;

export type GetNetworkRouteIpResponse = unknown;

export const GetNetworkRouteIpResponse =
  Schema.Unknown as unknown as Schema.Schema<GetNetworkRouteIpResponse>;

export type GetNetworkRouteIpError = CommonErrors;

export const getNetworkRouteIp: API.OperationMethod<
  GetNetworkRouteIpRequest,
  GetNetworkRouteIpResponse,
  GetNetworkRouteIpError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetNetworkRouteIpRequest,
  output: GetNetworkRouteIpResponse,
  errors: [],
}));

// =============================================================================
// NetworkRouteNetwork
// =============================================================================

export interface CreateNetworkRouteNetworkRequest {
  ipNetworkEncoded: string;
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Body param: UUID of the tunnel. */
  tunnelId: string;
  /** Body param: Optional remark describing the route. */
  comment?: string;
  /** Body param: UUID of the virtual network. */
  virtualNetworkId?: string;
}

export const CreateNetworkRouteNetworkRequest = Schema.Struct({
  ipNetworkEncoded: Schema.String.pipe(T.HttpPath("ipNetworkEncoded")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  tunnelId: Schema.String,
  comment: Schema.optional(Schema.String),
  virtualNetworkId: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    tunnelId: "tunnel_id",
    comment: "comment",
    virtualNetworkId: "virtual_network_id",
  }),
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/teamnet/routes/network/{ipNetworkEncoded}",
  }),
) as unknown as Schema.Schema<CreateNetworkRouteNetworkRequest>;

export type CreateNetworkRouteNetworkResponse = unknown;

export const CreateNetworkRouteNetworkResponse =
  Schema.Unknown as unknown as Schema.Schema<CreateNetworkRouteNetworkResponse>;

export type CreateNetworkRouteNetworkError = CommonErrors;

export const createNetworkRouteNetwork: API.OperationMethod<
  CreateNetworkRouteNetworkRequest,
  CreateNetworkRouteNetworkResponse,
  CreateNetworkRouteNetworkError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateNetworkRouteNetworkRequest,
  output: CreateNetworkRouteNetworkResponse,
  errors: [],
}));

export interface PatchNetworkRouteNetworkRequest {
  ipNetworkEncoded: string;
  /** Cloudflare account ID */
  accountId: string;
}

export const PatchNetworkRouteNetworkRequest = Schema.Struct({
  ipNetworkEncoded: Schema.String.pipe(T.HttpPath("ipNetworkEncoded")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "PATCH",
    path: "/accounts/{account_id}/teamnet/routes/network/{ipNetworkEncoded}",
  }),
) as unknown as Schema.Schema<PatchNetworkRouteNetworkRequest>;

export type PatchNetworkRouteNetworkResponse = unknown;

export const PatchNetworkRouteNetworkResponse =
  Schema.Unknown as unknown as Schema.Schema<PatchNetworkRouteNetworkResponse>;

export type PatchNetworkRouteNetworkError = CommonErrors;

export const patchNetworkRouteNetwork: API.OperationMethod<
  PatchNetworkRouteNetworkRequest,
  PatchNetworkRouteNetworkResponse,
  PatchNetworkRouteNetworkError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchNetworkRouteNetworkRequest,
  output: PatchNetworkRouteNetworkResponse,
  errors: [],
}));

export interface DeleteNetworkRouteNetworkRequest {
  ipNetworkEncoded: string;
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Query param: The type of tunnel. */
  tunType?:
    | "cfd_tunnel"
    | "warp_connector"
    | "warp"
    | "magic"
    | "ip_sec"
    | "gre"
    | "cni";
  /** Query param: UUID of the tunnel. */
  tunnelId?: string;
  /** Query param: UUID of the virtual network. */
  virtualNetworkId?: string;
}

export const DeleteNetworkRouteNetworkRequest = Schema.Struct({
  ipNetworkEncoded: Schema.String.pipe(T.HttpPath("ipNetworkEncoded")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  tunType: Schema.optional(
    Schema.Literals([
      "cfd_tunnel",
      "warp_connector",
      "warp",
      "magic",
      "ip_sec",
      "gre",
      "cni",
    ]),
  ).pipe(T.HttpQuery("tun_type")),
  tunnelId: Schema.optional(Schema.String).pipe(T.HttpQuery("tunnel_id")),
  virtualNetworkId: Schema.optional(Schema.String).pipe(
    T.HttpQuery("virtual_network_id"),
  ),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/teamnet/routes/network/{ipNetworkEncoded}",
  }),
) as unknown as Schema.Schema<DeleteNetworkRouteNetworkRequest>;

export type DeleteNetworkRouteNetworkResponse = unknown;

export const DeleteNetworkRouteNetworkResponse =
  Schema.Unknown as unknown as Schema.Schema<DeleteNetworkRouteNetworkResponse>;

export type DeleteNetworkRouteNetworkError = CommonErrors;

export const deleteNetworkRouteNetwork: API.OperationMethod<
  DeleteNetworkRouteNetworkRequest,
  DeleteNetworkRouteNetworkResponse,
  DeleteNetworkRouteNetworkError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteNetworkRouteNetworkRequest,
  output: DeleteNetworkRouteNetworkResponse,
  errors: [],
}));

// =============================================================================
// NetworkSubnet
// =============================================================================

export interface ListNetworkSubnetsRequest {
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Query param: If set, only include subnets in the given address family - `v4` or `v6` */
  addressFamily?: "v4" | "v6";
  /** Query param: If set, only list subnets with the given comment. */
  comment?: string;
  /** Query param: If provided, include only resources that were created (and not deleted) before this time. URL encoded. */
  existedAt?: string;
  /** Query param: If `true`, only include default subnets. If `false`, exclude default subnets subnets. If not set, all subnets will be included. */
  isDefaultNetwork?: boolean;
  /** Query param: If `true`, only include deleted subnets. If `false`, exclude deleted subnets. If not set, all subnets will be included. */
  isDeleted?: boolean;
  /** Query param: If set, only list subnets with the given name */
  name?: string;
  /** Query param: If set, only list the subnet whose network exactly matches the given CIDR. */
  network?: string;
  /** Query param: Sort order of the results. `asc` means oldest to newest, `desc` means newest to oldest. If not set, they will not be in any particular order. */
  sortOrder?: "asc" | "desc";
  /** Query param: If set, the types of subnets to include, separated by comma. */
  subnetTypes?: "cloudflare_source" | "warp";
}

export const ListNetworkSubnetsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  addressFamily: Schema.optional(Schema.Literals(["v4", "v6"])).pipe(
    T.HttpQuery("address_family"),
  ),
  comment: Schema.optional(Schema.String).pipe(T.HttpQuery("comment")),
  existedAt: Schema.optional(Schema.String).pipe(T.HttpQuery("existed_at")),
  isDefaultNetwork: Schema.optional(Schema.Boolean).pipe(
    T.HttpQuery("is_default_network"),
  ),
  isDeleted: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_deleted")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  network: Schema.optional(Schema.String).pipe(T.HttpQuery("network")),
  sortOrder: Schema.optional(Schema.Literals(["asc", "desc"])).pipe(
    T.HttpQuery("sort_order"),
  ),
  subnetTypes: Schema.optional(
    Schema.Literals(["cloudflare_source", "warp"]),
  ).pipe(T.HttpQuery("subnet_types")),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/zerotrust/subnets" }),
) as unknown as Schema.Schema<ListNetworkSubnetsRequest>;

export type ListNetworkSubnetsResponse = {
  id?: string;
  comment?: string;
  createdAt?: string;
  deletedAt?: string;
  isDefaultNetwork?: boolean;
  name?: string;
  network?: string;
  subnetType?: "cloudflare_source";
}[];

export const ListNetworkSubnetsResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    comment: Schema.optional(Schema.String),
    createdAt: Schema.optional(Schema.String),
    deletedAt: Schema.optional(Schema.String),
    isDefaultNetwork: Schema.optional(Schema.Boolean),
    name: Schema.optional(Schema.String),
    network: Schema.optional(Schema.String),
    subnetType: Schema.optional(Schema.Literal("cloudflare_source")),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      comment: "comment",
      createdAt: "created_at",
      deletedAt: "deleted_at",
      isDefaultNetwork: "is_default_network",
      name: "name",
      network: "network",
      subnetType: "subnet_type",
    }),
  ),
) as unknown as Schema.Schema<ListNetworkSubnetsResponse>;

export type ListNetworkSubnetsError = CommonErrors;

export const listNetworkSubnets: API.OperationMethod<
  ListNetworkSubnetsRequest,
  ListNetworkSubnetsResponse,
  ListNetworkSubnetsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListNetworkSubnetsRequest,
  output: ListNetworkSubnetsResponse,
  errors: [],
}));

// =============================================================================
// NetworkSubnetCloudflareSource
// =============================================================================

export interface PatchNetworkSubnetCloudflareSourceRequest {
  addressFamily: "v4" | "v6";
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Body param: An optional description of the subnet. */
  comment?: string;
  /** Body param: A user-friendly name for the subnet. */
  name?: string;
  /** Body param: The private IPv4 or IPv6 range defining the subnet, in CIDR notation. */
  network?: string;
}

export const PatchNetworkSubnetCloudflareSourceRequest = Schema.Struct({
  addressFamily: Schema.Literals(["v4", "v6"]).pipe(
    T.HttpPath("addressFamily"),
  ),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  comment: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
}).pipe(
  T.Http({
    method: "PATCH",
    path: "/accounts/{account_id}/zerotrust/subnets/cloudflare_source/{addressFamily}",
  }),
) as unknown as Schema.Schema<PatchNetworkSubnetCloudflareSourceRequest>;

export interface PatchNetworkSubnetCloudflareSourceResponse {
  /** The UUID of the subnet. */
  id?: string;
  /** An optional description of the subnet. */
  comment?: string;
  /** Timestamp of when the resource was created. */
  createdAt?: string;
  /** Timestamp of when the resource was deleted. If `null`, the resource has not been deleted. */
  deletedAt?: string;
  /** If `true`, this is the default subnet for the account. There can only be one default subnet per account. */
  isDefaultNetwork?: boolean;
  /** A user-friendly name for the subnet. */
  name?: string;
  /** The private IPv4 or IPv6 range defining the subnet, in CIDR notation. */
  network?: string;
  /** The type of subnet. */
  subnetType?: "cloudflare_source";
}

export const PatchNetworkSubnetCloudflareSourceResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  comment: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  deletedAt: Schema.optional(Schema.String),
  isDefaultNetwork: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
  network: Schema.optional(Schema.String),
  subnetType: Schema.optional(Schema.Literal("cloudflare_source")),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    comment: "comment",
    createdAt: "created_at",
    deletedAt: "deleted_at",
    isDefaultNetwork: "is_default_network",
    name: "name",
    network: "network",
    subnetType: "subnet_type",
  }),
) as unknown as Schema.Schema<PatchNetworkSubnetCloudflareSourceResponse>;

export type PatchNetworkSubnetCloudflareSourceError = CommonErrors;

export const patchNetworkSubnetCloudflareSource: API.OperationMethod<
  PatchNetworkSubnetCloudflareSourceRequest,
  PatchNetworkSubnetCloudflareSourceResponse,
  PatchNetworkSubnetCloudflareSourceError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchNetworkSubnetCloudflareSourceRequest,
  output: PatchNetworkSubnetCloudflareSourceResponse,
  errors: [],
}));

// =============================================================================
// NetworkVirtualNetwork
// =============================================================================

export interface GetNetworkVirtualNetworkRequest {
  virtualNetworkId: string;
  /** Cloudflare account ID */
  accountId: string;
}

export const GetNetworkVirtualNetworkRequest = Schema.Struct({
  virtualNetworkId: Schema.String.pipe(T.HttpPath("virtualNetworkId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/teamnet/virtual_networks/{virtualNetworkId}",
  }),
) as unknown as Schema.Schema<GetNetworkVirtualNetworkRequest>;

export interface GetNetworkVirtualNetworkResponse {
  /** UUID of the virtual network. */
  id: string;
  /** Optional remark describing the virtual network. */
  comment: string;
  /** Timestamp of when the resource was created. */
  createdAt: string;
  /** If `true`, this virtual network is the default for the account. */
  isDefaultNetwork: boolean;
  /** A user-friendly name for the virtual network. */
  name: string;
  /** Timestamp of when the resource was deleted. If `null`, the resource has not been deleted. */
  deletedAt?: string;
}

export const GetNetworkVirtualNetworkResponse = Schema.Struct({
  id: Schema.String,
  comment: Schema.String,
  createdAt: Schema.String,
  isDefaultNetwork: Schema.Boolean,
  name: Schema.String,
  deletedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    comment: "comment",
    createdAt: "created_at",
    isDefaultNetwork: "is_default_network",
    name: "name",
    deletedAt: "deleted_at",
  }),
) as unknown as Schema.Schema<GetNetworkVirtualNetworkResponse>;

export type GetNetworkVirtualNetworkError = CommonErrors;

export const getNetworkVirtualNetwork: API.OperationMethod<
  GetNetworkVirtualNetworkRequest,
  GetNetworkVirtualNetworkResponse,
  GetNetworkVirtualNetworkError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetNetworkVirtualNetworkRequest,
  output: GetNetworkVirtualNetworkResponse,
  errors: [],
}));

export interface ListNetworkVirtualNetworksRequest {
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Query param: UUID of the virtual network. */
  id?: string;
  /** Query param: If `true`, only include the default virtual network. If `false`, exclude the default virtual network. If empty, all virtual networks will be included. */
  isDefault?: boolean;
  /** Query param: If `true`, only include the default virtual network. If `false`, exclude the default virtual network. If empty, all virtual networks will be included. */
  isDefaultNetwork?: boolean;
  /** Query param: If `true`, only include deleted virtual networks. If `false`, exclude deleted virtual networks. If empty, all virtual networks will be included. */
  isDeleted?: boolean;
  /** Query param: A user-friendly name for the virtual network. */
  name?: string;
}

export const ListNetworkVirtualNetworksRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  id: Schema.optional(Schema.String).pipe(T.HttpQuery("id")),
  isDefault: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_default")),
  isDefaultNetwork: Schema.optional(Schema.Boolean).pipe(
    T.HttpQuery("is_default_network"),
  ),
  isDeleted: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_deleted")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/teamnet/virtual_networks",
  }),
) as unknown as Schema.Schema<ListNetworkVirtualNetworksRequest>;

export type ListNetworkVirtualNetworksResponse = {
  id: string;
  comment: string;
  createdAt: string;
  isDefaultNetwork: boolean;
  name: string;
  deletedAt?: string;
}[];

export const ListNetworkVirtualNetworksResponse = Schema.Array(
  Schema.Struct({
    id: Schema.String,
    comment: Schema.String,
    createdAt: Schema.String,
    isDefaultNetwork: Schema.Boolean,
    name: Schema.String,
    deletedAt: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      comment: "comment",
      createdAt: "created_at",
      isDefaultNetwork: "is_default_network",
      name: "name",
      deletedAt: "deleted_at",
    }),
  ),
) as unknown as Schema.Schema<ListNetworkVirtualNetworksResponse>;

export type ListNetworkVirtualNetworksError = CommonErrors;

export const listNetworkVirtualNetworks: API.OperationMethod<
  ListNetworkVirtualNetworksRequest,
  ListNetworkVirtualNetworksResponse,
  ListNetworkVirtualNetworksError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListNetworkVirtualNetworksRequest,
  output: ListNetworkVirtualNetworksResponse,
  errors: [],
}));

export interface CreateNetworkVirtualNetworkRequest {
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Body param: A user-friendly name for the virtual network. */
  name: string;
  /** Body param: Optional remark describing the virtual network. */
  comment?: string;
  /** @deprecated Use the is_default_network property instead. */
  isDefault?: boolean;
  /** Body param: If `true`, this virtual network is the default for the account. */
  isDefaultNetwork?: boolean;
}

export const CreateNetworkVirtualNetworkRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.String,
  comment: Schema.optional(Schema.String),
  isDefault: Schema.optional(Schema.Boolean),
  isDefaultNetwork: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    name: "name",
    comment: "comment",
    isDefault: "is_default",
    isDefaultNetwork: "is_default_network",
  }),
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/teamnet/virtual_networks",
  }),
) as unknown as Schema.Schema<CreateNetworkVirtualNetworkRequest>;

export interface CreateNetworkVirtualNetworkResponse {
  /** UUID of the virtual network. */
  id: string;
  /** Optional remark describing the virtual network. */
  comment: string;
  /** Timestamp of when the resource was created. */
  createdAt: string;
  /** If `true`, this virtual network is the default for the account. */
  isDefaultNetwork: boolean;
  /** A user-friendly name for the virtual network. */
  name: string;
  /** Timestamp of when the resource was deleted. If `null`, the resource has not been deleted. */
  deletedAt?: string;
}

export const CreateNetworkVirtualNetworkResponse = Schema.Struct({
  id: Schema.String,
  comment: Schema.String,
  createdAt: Schema.String,
  isDefaultNetwork: Schema.Boolean,
  name: Schema.String,
  deletedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    comment: "comment",
    createdAt: "created_at",
    isDefaultNetwork: "is_default_network",
    name: "name",
    deletedAt: "deleted_at",
  }),
) as unknown as Schema.Schema<CreateNetworkVirtualNetworkResponse>;

export type CreateNetworkVirtualNetworkError = CommonErrors;

export const createNetworkVirtualNetwork: API.OperationMethod<
  CreateNetworkVirtualNetworkRequest,
  CreateNetworkVirtualNetworkResponse,
  CreateNetworkVirtualNetworkError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateNetworkVirtualNetworkRequest,
  output: CreateNetworkVirtualNetworkResponse,
  errors: [],
}));

export interface PatchNetworkVirtualNetworkRequest {
  virtualNetworkId: string;
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Body param: Optional remark describing the virtual network. */
  comment?: string;
  /** Body param: If `true`, this virtual network is the default for the account. */
  isDefaultNetwork?: boolean;
  /** Body param: A user-friendly name for the virtual network. */
  name?: string;
}

export const PatchNetworkVirtualNetworkRequest = Schema.Struct({
  virtualNetworkId: Schema.String.pipe(T.HttpPath("virtualNetworkId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  comment: Schema.optional(Schema.String),
  isDefaultNetwork: Schema.optional(Schema.Boolean),
  name: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    comment: "comment",
    isDefaultNetwork: "is_default_network",
    name: "name",
  }),
  T.Http({
    method: "PATCH",
    path: "/accounts/{account_id}/teamnet/virtual_networks/{virtualNetworkId}",
  }),
) as unknown as Schema.Schema<PatchNetworkVirtualNetworkRequest>;

export interface PatchNetworkVirtualNetworkResponse {
  /** UUID of the virtual network. */
  id: string;
  /** Optional remark describing the virtual network. */
  comment: string;
  /** Timestamp of when the resource was created. */
  createdAt: string;
  /** If `true`, this virtual network is the default for the account. */
  isDefaultNetwork: boolean;
  /** A user-friendly name for the virtual network. */
  name: string;
  /** Timestamp of when the resource was deleted. If `null`, the resource has not been deleted. */
  deletedAt?: string;
}

export const PatchNetworkVirtualNetworkResponse = Schema.Struct({
  id: Schema.String,
  comment: Schema.String,
  createdAt: Schema.String,
  isDefaultNetwork: Schema.Boolean,
  name: Schema.String,
  deletedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    comment: "comment",
    createdAt: "created_at",
    isDefaultNetwork: "is_default_network",
    name: "name",
    deletedAt: "deleted_at",
  }),
) as unknown as Schema.Schema<PatchNetworkVirtualNetworkResponse>;

export type PatchNetworkVirtualNetworkError = CommonErrors;

export const patchNetworkVirtualNetwork: API.OperationMethod<
  PatchNetworkVirtualNetworkRequest,
  PatchNetworkVirtualNetworkResponse,
  PatchNetworkVirtualNetworkError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchNetworkVirtualNetworkRequest,
  output: PatchNetworkVirtualNetworkResponse,
  errors: [],
}));

export interface DeleteNetworkVirtualNetworkRequest {
  virtualNetworkId: string;
  /** Cloudflare account ID */
  accountId: string;
}

export const DeleteNetworkVirtualNetworkRequest = Schema.Struct({
  virtualNetworkId: Schema.String.pipe(T.HttpPath("virtualNetworkId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/teamnet/virtual_networks/{virtualNetworkId}",
  }),
) as unknown as Schema.Schema<DeleteNetworkVirtualNetworkRequest>;

export interface DeleteNetworkVirtualNetworkResponse {
  /** UUID of the virtual network. */
  id: string;
  /** Optional remark describing the virtual network. */
  comment: string;
  /** Timestamp of when the resource was created. */
  createdAt: string;
  /** If `true`, this virtual network is the default for the account. */
  isDefaultNetwork: boolean;
  /** A user-friendly name for the virtual network. */
  name: string;
  /** Timestamp of when the resource was deleted. If `null`, the resource has not been deleted. */
  deletedAt?: string;
}

export const DeleteNetworkVirtualNetworkResponse = Schema.Struct({
  id: Schema.String,
  comment: Schema.String,
  createdAt: Schema.String,
  isDefaultNetwork: Schema.Boolean,
  name: Schema.String,
  deletedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    comment: "comment",
    createdAt: "created_at",
    isDefaultNetwork: "is_default_network",
    name: "name",
    deletedAt: "deleted_at",
  }),
) as unknown as Schema.Schema<DeleteNetworkVirtualNetworkResponse>;

export type DeleteNetworkVirtualNetworkError = CommonErrors;

export const deleteNetworkVirtualNetwork: API.OperationMethod<
  DeleteNetworkVirtualNetworkRequest,
  DeleteNetworkVirtualNetworkResponse,
  DeleteNetworkVirtualNetworkError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteNetworkVirtualNetworkRequest,
  output: DeleteNetworkVirtualNetworkResponse,
  errors: [],
}));

// =============================================================================
// Organization
// =============================================================================

export interface ListOrganizationsRequest {}

export const ListOrganizationsRequest = Schema.Struct({}).pipe(
  T.Http({
    method: "GET",
    path: "/{accountOrZone}/{accountOrZoneId}/access/organizations",
  }),
) as unknown as Schema.Schema<ListOrganizationsRequest>;

export interface ListOrganizationsResponse {
  /** When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value. */
  allowAuthenticateViaWarp?: boolean;
  /** The unique subdomain assigned to your Zero Trust organization. */
  authDomain?: string;
  /** When set to `true`, users skip the identity provider selection step during login. */
  autoRedirectToIdentity?: boolean;
  customPages?: { forbidden?: string; identityDenied?: string };
  /** Lock all settings as Read-Only in the Dashboard, regardless of user permission. Updates may only be made via the API or Terraform for this account when enabled. */
  isUiReadOnly?: boolean;
  loginDesign?: {
    backgroundColor?: string;
    footerText?: string;
    headerText?: string;
    logoPath?: string;
    textColor?: string;
  };
  /** The name of your Zero Trust organization. */
  name?: string;
  /** The amount of time that tokens issued for applications will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. */
  sessionDuration?: string;
  /** A description of the reason why the UI read only field is being toggled. */
  uiReadOnlyToggleReason?: string;
  /** The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat  */
  userSeatExpirationInactiveTime?: string;
  /** The amount of time that tokens issued for applications will be valid. Must be in the format `30m` or `2h45m`. Valid time units are: m, h. */
  warpAuthSessionDuration?: string;
}

export const ListOrganizationsResponse = Schema.Struct({
  allowAuthenticateViaWarp: Schema.optional(Schema.Boolean),
  authDomain: Schema.optional(Schema.String),
  autoRedirectToIdentity: Schema.optional(Schema.Boolean),
  customPages: Schema.optional(
    Schema.Struct({
      forbidden: Schema.optional(Schema.String),
      identityDenied: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        forbidden: "forbidden",
        identityDenied: "identity_denied",
      }),
    ),
  ),
  isUiReadOnly: Schema.optional(Schema.Boolean),
  loginDesign: Schema.optional(
    Schema.Struct({
      backgroundColor: Schema.optional(Schema.String),
      footerText: Schema.optional(Schema.String),
      headerText: Schema.optional(Schema.String),
      logoPath: Schema.optional(Schema.String),
      textColor: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        backgroundColor: "background_color",
        footerText: "footer_text",
        headerText: "header_text",
        logoPath: "logo_path",
        textColor: "text_color",
      }),
    ),
  ),
  name: Schema.optional(Schema.String),
  sessionDuration: Schema.optional(Schema.String),
  uiReadOnlyToggleReason: Schema.optional(Schema.String),
  userSeatExpirationInactiveTime: Schema.optional(Schema.String),
  warpAuthSessionDuration: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    allowAuthenticateViaWarp: "allow_authenticate_via_warp",
    authDomain: "auth_domain",
    autoRedirectToIdentity: "auto_redirect_to_identity",
    customPages: "custom_pages",
    isUiReadOnly: "is_ui_read_only",
    loginDesign: "login_design",
    name: "name",
    sessionDuration: "session_duration",
    uiReadOnlyToggleReason: "ui_read_only_toggle_reason",
    userSeatExpirationInactiveTime: "user_seat_expiration_inactive_time",
    warpAuthSessionDuration: "warp_auth_session_duration",
  }),
) as unknown as Schema.Schema<ListOrganizationsResponse>;

export type ListOrganizationsError = CommonErrors;

export const listOrganizations: API.OperationMethod<
  ListOrganizationsRequest,
  ListOrganizationsResponse,
  ListOrganizationsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListOrganizationsRequest,
  output: ListOrganizationsResponse,
  errors: [],
}));

export interface CreateOrganizationRequest {
  /** Path param: The Account ID to use for this endpoint. Mutually exclusive with the Zone ID. */
  accountId?: string;
  /** Path param: The Zone ID to use for this endpoint. Mutually exclusive with the Account ID. */
  zoneId?: string;
  /** Body param: The unique subdomain assigned to your Zero Trust organization. */
  authDomain: string;
  /** Body param: The name of your Zero Trust organization. */
  name: string;
  /** Body param: When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value. */
  allowAuthenticateViaWarp?: boolean;
  /** Body param: When set to `true`, users skip the identity provider selection step during login. */
  autoRedirectToIdentity?: boolean;
  /** Body param: Lock all settings as Read-Only in the Dashboard, regardless of user permission. Updates may only be made via the API or Terraform for this account when enabled. */
  isUiReadOnly?: boolean;
  /** Body param: */
  loginDesign?: {
    backgroundColor?: string;
    footerText?: string;
    headerText?: string;
    logoPath?: string;
    textColor?: string;
  };
  /** Body param: The amount of time that tokens issued for applications will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. */
  sessionDuration?: string;
  /** Body param: A description of the reason why the UI read only field is being toggled. */
  uiReadOnlyToggleReason?: string;
  /** Body param: The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your */
  userSeatExpirationInactiveTime?: string;
  /** Body param: The amount of time that tokens issued for applications will be valid. Must be in the format `30m` or `2h45m`. Valid time units are: m, h. */
  warpAuthSessionDuration?: string;
}

export const CreateOrganizationRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  authDomain: Schema.String,
  name: Schema.String,
  allowAuthenticateViaWarp: Schema.optional(Schema.Boolean),
  autoRedirectToIdentity: Schema.optional(Schema.Boolean),
  isUiReadOnly: Schema.optional(Schema.Boolean),
  loginDesign: Schema.optional(
    Schema.Struct({
      backgroundColor: Schema.optional(Schema.String),
      footerText: Schema.optional(Schema.String),
      headerText: Schema.optional(Schema.String),
      logoPath: Schema.optional(Schema.String),
      textColor: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        backgroundColor: "background_color",
        footerText: "footer_text",
        headerText: "header_text",
        logoPath: "logo_path",
        textColor: "text_color",
      }),
    ),
  ),
  sessionDuration: Schema.optional(Schema.String),
  uiReadOnlyToggleReason: Schema.optional(Schema.String),
  userSeatExpirationInactiveTime: Schema.optional(Schema.String),
  warpAuthSessionDuration: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    authDomain: "auth_domain",
    name: "name",
    allowAuthenticateViaWarp: "allow_authenticate_via_warp",
    autoRedirectToIdentity: "auto_redirect_to_identity",
    isUiReadOnly: "is_ui_read_only",
    loginDesign: "login_design",
    sessionDuration: "session_duration",
    uiReadOnlyToggleReason: "ui_read_only_toggle_reason",
    userSeatExpirationInactiveTime: "user_seat_expiration_inactive_time",
    warpAuthSessionDuration: "warp_auth_session_duration",
  }),
  T.Http({
    method: "POST",
    path: "/{accountOrZone}/{accountOrZoneId}/access/organizations",
  }),
) as unknown as Schema.Schema<CreateOrganizationRequest>;

export interface CreateOrganizationResponse {
  /** When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value. */
  allowAuthenticateViaWarp?: boolean;
  /** The unique subdomain assigned to your Zero Trust organization. */
  authDomain?: string;
  /** When set to `true`, users skip the identity provider selection step during login. */
  autoRedirectToIdentity?: boolean;
  customPages?: { forbidden?: string; identityDenied?: string };
  /** Lock all settings as Read-Only in the Dashboard, regardless of user permission. Updates may only be made via the API or Terraform for this account when enabled. */
  isUiReadOnly?: boolean;
  loginDesign?: {
    backgroundColor?: string;
    footerText?: string;
    headerText?: string;
    logoPath?: string;
    textColor?: string;
  };
  /** The name of your Zero Trust organization. */
  name?: string;
  /** The amount of time that tokens issued for applications will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. */
  sessionDuration?: string;
  /** A description of the reason why the UI read only field is being toggled. */
  uiReadOnlyToggleReason?: string;
  /** The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat  */
  userSeatExpirationInactiveTime?: string;
  /** The amount of time that tokens issued for applications will be valid. Must be in the format `30m` or `2h45m`. Valid time units are: m, h. */
  warpAuthSessionDuration?: string;
}

export const CreateOrganizationResponse = Schema.Struct({
  allowAuthenticateViaWarp: Schema.optional(Schema.Boolean),
  authDomain: Schema.optional(Schema.String),
  autoRedirectToIdentity: Schema.optional(Schema.Boolean),
  customPages: Schema.optional(
    Schema.Struct({
      forbidden: Schema.optional(Schema.String),
      identityDenied: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        forbidden: "forbidden",
        identityDenied: "identity_denied",
      }),
    ),
  ),
  isUiReadOnly: Schema.optional(Schema.Boolean),
  loginDesign: Schema.optional(
    Schema.Struct({
      backgroundColor: Schema.optional(Schema.String),
      footerText: Schema.optional(Schema.String),
      headerText: Schema.optional(Schema.String),
      logoPath: Schema.optional(Schema.String),
      textColor: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        backgroundColor: "background_color",
        footerText: "footer_text",
        headerText: "header_text",
        logoPath: "logo_path",
        textColor: "text_color",
      }),
    ),
  ),
  name: Schema.optional(Schema.String),
  sessionDuration: Schema.optional(Schema.String),
  uiReadOnlyToggleReason: Schema.optional(Schema.String),
  userSeatExpirationInactiveTime: Schema.optional(Schema.String),
  warpAuthSessionDuration: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    allowAuthenticateViaWarp: "allow_authenticate_via_warp",
    authDomain: "auth_domain",
    autoRedirectToIdentity: "auto_redirect_to_identity",
    customPages: "custom_pages",
    isUiReadOnly: "is_ui_read_only",
    loginDesign: "login_design",
    name: "name",
    sessionDuration: "session_duration",
    uiReadOnlyToggleReason: "ui_read_only_toggle_reason",
    userSeatExpirationInactiveTime: "user_seat_expiration_inactive_time",
    warpAuthSessionDuration: "warp_auth_session_duration",
  }),
) as unknown as Schema.Schema<CreateOrganizationResponse>;

export type CreateOrganizationError = CommonErrors;

export const createOrganization: API.OperationMethod<
  CreateOrganizationRequest,
  CreateOrganizationResponse,
  CreateOrganizationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateOrganizationRequest,
  output: CreateOrganizationResponse,
  errors: [],
}));

export interface UpdateOrganizationRequest {
  /** Path param: The Account ID to use for this endpoint. Mutually exclusive with the Zone ID. */
  accountId?: string;
  /** Path param: The Zone ID to use for this endpoint. Mutually exclusive with the Account ID. */
  zoneId?: string;
  /** Body param: When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value. */
  allowAuthenticateViaWarp?: boolean;
  /** Body param: The unique subdomain assigned to your Zero Trust organization. */
  authDomain?: string;
  /** Body param: When set to `true`, users skip the identity provider selection step during login. */
  autoRedirectToIdentity?: boolean;
  /** Body param: */
  customPages?: { forbidden?: string; identityDenied?: string };
  /** Body param: Lock all settings as Read-Only in the Dashboard, regardless of user permission. Updates may only be made via the API or Terraform for this account when enabled. */
  isUiReadOnly?: boolean;
  /** Body param: */
  loginDesign?: {
    backgroundColor?: string;
    footerText?: string;
    headerText?: string;
    logoPath?: string;
    textColor?: string;
  };
  /** Body param: The name of your Zero Trust organization. */
  name?: string;
  /** Body param: The amount of time that tokens issued for applications will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. */
  sessionDuration?: string;
  /** Body param: A description of the reason why the UI read only field is being toggled. */
  uiReadOnlyToggleReason?: string;
  /** Body param: The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your */
  userSeatExpirationInactiveTime?: string;
  /** Body param: The amount of time that tokens issued for applications will be valid. Must be in the format `30m` or `2h45m`. Valid time units are: m, h. */
  warpAuthSessionDuration?: string;
}

export const UpdateOrganizationRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  allowAuthenticateViaWarp: Schema.optional(Schema.Boolean),
  authDomain: Schema.optional(Schema.String),
  autoRedirectToIdentity: Schema.optional(Schema.Boolean),
  customPages: Schema.optional(
    Schema.Struct({
      forbidden: Schema.optional(Schema.String),
      identityDenied: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        forbidden: "forbidden",
        identityDenied: "identity_denied",
      }),
    ),
  ),
  isUiReadOnly: Schema.optional(Schema.Boolean),
  loginDesign: Schema.optional(
    Schema.Struct({
      backgroundColor: Schema.optional(Schema.String),
      footerText: Schema.optional(Schema.String),
      headerText: Schema.optional(Schema.String),
      logoPath: Schema.optional(Schema.String),
      textColor: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        backgroundColor: "background_color",
        footerText: "footer_text",
        headerText: "header_text",
        logoPath: "logo_path",
        textColor: "text_color",
      }),
    ),
  ),
  name: Schema.optional(Schema.String),
  sessionDuration: Schema.optional(Schema.String),
  uiReadOnlyToggleReason: Schema.optional(Schema.String),
  userSeatExpirationInactiveTime: Schema.optional(Schema.String),
  warpAuthSessionDuration: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    allowAuthenticateViaWarp: "allow_authenticate_via_warp",
    authDomain: "auth_domain",
    autoRedirectToIdentity: "auto_redirect_to_identity",
    customPages: "custom_pages",
    isUiReadOnly: "is_ui_read_only",
    loginDesign: "login_design",
    name: "name",
    sessionDuration: "session_duration",
    uiReadOnlyToggleReason: "ui_read_only_toggle_reason",
    userSeatExpirationInactiveTime: "user_seat_expiration_inactive_time",
    warpAuthSessionDuration: "warp_auth_session_duration",
  }),
  T.Http({
    method: "PUT",
    path: "/{accountOrZone}/{accountOrZoneId}/access/organizations",
  }),
) as unknown as Schema.Schema<UpdateOrganizationRequest>;

export interface UpdateOrganizationResponse {
  /** When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value. */
  allowAuthenticateViaWarp?: boolean;
  /** The unique subdomain assigned to your Zero Trust organization. */
  authDomain?: string;
  /** When set to `true`, users skip the identity provider selection step during login. */
  autoRedirectToIdentity?: boolean;
  customPages?: { forbidden?: string; identityDenied?: string };
  /** Lock all settings as Read-Only in the Dashboard, regardless of user permission. Updates may only be made via the API or Terraform for this account when enabled. */
  isUiReadOnly?: boolean;
  loginDesign?: {
    backgroundColor?: string;
    footerText?: string;
    headerText?: string;
    logoPath?: string;
    textColor?: string;
  };
  /** The name of your Zero Trust organization. */
  name?: string;
  /** The amount of time that tokens issued for applications will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. */
  sessionDuration?: string;
  /** A description of the reason why the UI read only field is being toggled. */
  uiReadOnlyToggleReason?: string;
  /** The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat  */
  userSeatExpirationInactiveTime?: string;
  /** The amount of time that tokens issued for applications will be valid. Must be in the format `30m` or `2h45m`. Valid time units are: m, h. */
  warpAuthSessionDuration?: string;
}

export const UpdateOrganizationResponse = Schema.Struct({
  allowAuthenticateViaWarp: Schema.optional(Schema.Boolean),
  authDomain: Schema.optional(Schema.String),
  autoRedirectToIdentity: Schema.optional(Schema.Boolean),
  customPages: Schema.optional(
    Schema.Struct({
      forbidden: Schema.optional(Schema.String),
      identityDenied: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        forbidden: "forbidden",
        identityDenied: "identity_denied",
      }),
    ),
  ),
  isUiReadOnly: Schema.optional(Schema.Boolean),
  loginDesign: Schema.optional(
    Schema.Struct({
      backgroundColor: Schema.optional(Schema.String),
      footerText: Schema.optional(Schema.String),
      headerText: Schema.optional(Schema.String),
      logoPath: Schema.optional(Schema.String),
      textColor: Schema.optional(Schema.String),
    }).pipe(
      Schema.encodeKeys({
        backgroundColor: "background_color",
        footerText: "footer_text",
        headerText: "header_text",
        logoPath: "logo_path",
        textColor: "text_color",
      }),
    ),
  ),
  name: Schema.optional(Schema.String),
  sessionDuration: Schema.optional(Schema.String),
  uiReadOnlyToggleReason: Schema.optional(Schema.String),
  userSeatExpirationInactiveTime: Schema.optional(Schema.String),
  warpAuthSessionDuration: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    allowAuthenticateViaWarp: "allow_authenticate_via_warp",
    authDomain: "auth_domain",
    autoRedirectToIdentity: "auto_redirect_to_identity",
    customPages: "custom_pages",
    isUiReadOnly: "is_ui_read_only",
    loginDesign: "login_design",
    name: "name",
    sessionDuration: "session_duration",
    uiReadOnlyToggleReason: "ui_read_only_toggle_reason",
    userSeatExpirationInactiveTime: "user_seat_expiration_inactive_time",
    warpAuthSessionDuration: "warp_auth_session_duration",
  }),
) as unknown as Schema.Schema<UpdateOrganizationResponse>;

export type UpdateOrganizationError = CommonErrors;

export const updateOrganization: API.OperationMethod<
  UpdateOrganizationRequest,
  UpdateOrganizationResponse,
  UpdateOrganizationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateOrganizationRequest,
  output: UpdateOrganizationResponse,
  errors: [],
}));

// =============================================================================
// OrganizationDoh
// =============================================================================

export interface GetOrganizationDohRequest {
  /** Identifier. */
  accountId: string;
}

export const GetOrganizationDohRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/access/organizations/doh",
  }),
) as unknown as Schema.Schema<GetOrganizationDohRequest>;

export interface GetOrganizationDohResponse {
  /** The ID of the service token. */
  id?: string;
  /** The Client ID for the service token. Access will check for this value in the `CF-Access-Client-ID` request header. */
  clientId?: string;
  /** The duration the DoH JWT is valid for. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. Note that the maximum duration for this setting is the same as the k */
  dohJwtDuration?: string;
  /** The duration for how long the service token will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. The default is 1 year in hours (8760h). */
  duration?: string;
  expiresAt?: string;
  /** The name of the service token. */
  name?: string;
}

export const GetOrganizationDohResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  clientId: Schema.optional(Schema.String),
  dohJwtDuration: Schema.optional(Schema.String),
  duration: Schema.optional(Schema.String),
  expiresAt: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    clientId: "client_id",
    dohJwtDuration: "doh_jwt_duration",
    duration: "duration",
    expiresAt: "expires_at",
    name: "name",
  }),
) as unknown as Schema.Schema<GetOrganizationDohResponse>;

export type GetOrganizationDohError = CommonErrors;

export const getOrganizationDoh: API.OperationMethod<
  GetOrganizationDohRequest,
  GetOrganizationDohResponse,
  GetOrganizationDohError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetOrganizationDohRequest,
  output: GetOrganizationDohResponse,
  errors: [],
}));

export interface PutOrganizationDohRequest {
  /** Path param: Identifier. */
  accountId: string;
  /** Body param: The duration the DoH JWT is valid for. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. Note that the maximum duration for this setting is the s */
  dohJwtDuration?: string;
  /** Body param: The uuid of the service token you want to use for DoH authentication */
  serviceTokenId?: string;
}

export const PutOrganizationDohRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  dohJwtDuration: Schema.optional(Schema.String),
  serviceTokenId: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    dohJwtDuration: "doh_jwt_duration",
    serviceTokenId: "service_token_id",
  }),
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/access/organizations/doh",
  }),
) as unknown as Schema.Schema<PutOrganizationDohRequest>;

export interface PutOrganizationDohResponse {
  /** The ID of the service token. */
  id?: string;
  /** The Client ID for the service token. Access will check for this value in the `CF-Access-Client-ID` request header. */
  clientId?: string;
  /** The duration the DoH JWT is valid for. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. Note that the maximum duration for this setting is the same as the k */
  dohJwtDuration?: string;
  /** The duration for how long the service token will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or s), ms, s, m, h. The default is 1 year in hours (8760h). */
  duration?: string;
  expiresAt?: string;
  /** The name of the service token. */
  name?: string;
}

export const PutOrganizationDohResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  clientId: Schema.optional(Schema.String),
  dohJwtDuration: Schema.optional(Schema.String),
  duration: Schema.optional(Schema.String),
  expiresAt: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    clientId: "client_id",
    dohJwtDuration: "doh_jwt_duration",
    duration: "duration",
    expiresAt: "expires_at",
    name: "name",
  }),
) as unknown as Schema.Schema<PutOrganizationDohResponse>;

export type PutOrganizationDohError = CommonErrors;

export const putOrganizationDoh: API.OperationMethod<
  PutOrganizationDohRequest,
  PutOrganizationDohResponse,
  PutOrganizationDohError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutOrganizationDohRequest,
  output: PutOrganizationDohResponse,
  errors: [],
}));

// =============================================================================
// PathDexTracerouteTest
// =============================================================================

export interface NetworkPathDexTracerouteTestRequest {
  testId: string;
  /** Path param: unique identifier linked to an account */
  accountId: string;
  /** Query param: Device to filter tracroute result runs to */
  deviceId: string;
  /** Query param: Start time for aggregate metrics in ISO ms */
  from: string;
  /** Query param: Time interval for aggregate time slots. */
  interval: "minute" | "hour";
  /** Query param: End time for aggregate metrics in ISO ms */
  to: string;
}

export const NetworkPathDexTracerouteTestRequest = Schema.Struct({
  testId: Schema.String.pipe(T.HttpPath("testId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  deviceId: Schema.String.pipe(T.HttpQuery("deviceId")),
  from: Schema.String.pipe(T.HttpQuery("from")),
  interval: Schema.Literals(["minute", "hour"]).pipe(T.HttpQuery("interval")),
  to: Schema.String.pipe(T.HttpQuery("to")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dex/traceroute-tests/{testId}/network-path",
  }),
) as unknown as Schema.Schema<NetworkPathDexTracerouteTestRequest>;

export type NetworkPathDexTracerouteTestResponse = unknown;

export const NetworkPathDexTracerouteTestResponse =
  Schema.Unknown as unknown as Schema.Schema<NetworkPathDexTracerouteTestResponse>;

export type NetworkPathDexTracerouteTestError = CommonErrors;

export const networkPathDexTracerouteTest: API.OperationMethod<
  NetworkPathDexTracerouteTestRequest,
  NetworkPathDexTracerouteTestResponse,
  NetworkPathDexTracerouteTestError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: NetworkPathDexTracerouteTestRequest,
  output: NetworkPathDexTracerouteTestResponse,
  errors: [],
}));

// =============================================================================
// RiskScoring
// =============================================================================

export interface GetRiskScoringRequest {
  userId: string;
  accountId: string;
}

export const GetRiskScoringRequest = Schema.Struct({
  userId: Schema.String.pipe(T.HttpPath("userId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/zt_risk_scoring/{userId}",
  }),
) as unknown as Schema.Schema<GetRiskScoringRequest>;

export interface GetRiskScoringResponse {
  email: string;
  events: {
    id: string;
    name: string;
    riskLevel: "low" | "medium" | "high";
    timestamp: string;
    eventDetails?: unknown;
  }[];
  name: string;
  lastResetTime?: string | null;
  riskLevel?: "low" | "medium" | "high";
}

export const GetRiskScoringResponse = Schema.Struct({
  email: Schema.String,
  events: Schema.Array(
    Schema.Struct({
      id: Schema.String,
      name: Schema.String,
      riskLevel: Schema.Literals(["low", "medium", "high"]),
      timestamp: Schema.String,
      eventDetails: Schema.optional(Schema.Unknown),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        name: "name",
        riskLevel: "risk_level",
        timestamp: "timestamp",
        eventDetails: "event_details",
      }),
    ),
  ),
  name: Schema.String,
  lastResetTime: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  riskLevel: Schema.optional(Schema.Literals(["low", "medium", "high"])),
}).pipe(
  Schema.encodeKeys({
    email: "email",
    events: "events",
    name: "name",
    lastResetTime: "last_reset_time",
    riskLevel: "risk_level",
  }),
) as unknown as Schema.Schema<GetRiskScoringResponse>;

export type GetRiskScoringError = CommonErrors;

export const getRiskScoring: API.OperationMethod<
  GetRiskScoringRequest,
  GetRiskScoringResponse,
  GetRiskScoringError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRiskScoringRequest,
  output: GetRiskScoringResponse,
  errors: [],
}));

export interface ResetRiskScoringRequest {
  userId: string;
  accountId: string;
}

export const ResetRiskScoringRequest = Schema.Struct({
  userId: Schema.String.pipe(T.HttpPath("userId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/zt_risk_scoring/{userId}/reset",
  }),
) as unknown as Schema.Schema<ResetRiskScoringRequest>;

export type ResetRiskScoringResponse = unknown;

export const ResetRiskScoringResponse =
  Schema.Unknown as unknown as Schema.Schema<ResetRiskScoringResponse>;

export type ResetRiskScoringError = CommonErrors;

export const resetRiskScoring: API.OperationMethod<
  ResetRiskScoringRequest,
  ResetRiskScoringResponse,
  ResetRiskScoringError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ResetRiskScoringRequest,
  output: ResetRiskScoringResponse,
  errors: [],
}));

// =============================================================================
// RiskScoringBehaviour
// =============================================================================

export interface GetRiskScoringBehaviourRequest {
  accountId: string;
}

export const GetRiskScoringBehaviourRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/zt_risk_scoring/behaviors",
  }),
) as unknown as Schema.Schema<GetRiskScoringBehaviourRequest>;

export interface GetRiskScoringBehaviourResponse {
  behaviors: Record<string, unknown>;
}

export const GetRiskScoringBehaviourResponse = Schema.Struct({
  behaviors: Schema.Struct({}),
}) as unknown as Schema.Schema<GetRiskScoringBehaviourResponse>;

export type GetRiskScoringBehaviourError = CommonErrors;

export const getRiskScoringBehaviour: API.OperationMethod<
  GetRiskScoringBehaviourRequest,
  GetRiskScoringBehaviourResponse,
  GetRiskScoringBehaviourError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRiskScoringBehaviourRequest,
  output: GetRiskScoringBehaviourResponse,
  errors: [],
}));

export interface PutRiskScoringBehaviourRequest {
  /** Path param: Account ID. */
  accountId: string;
  /** Body param: */
  behaviors: Record<string, unknown>;
}

export const PutRiskScoringBehaviourRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  behaviors: Schema.Struct({}),
}).pipe(
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/zt_risk_scoring/behaviors",
  }),
) as unknown as Schema.Schema<PutRiskScoringBehaviourRequest>;

export interface PutRiskScoringBehaviourResponse {
  behaviors: Record<string, unknown>;
}

export const PutRiskScoringBehaviourResponse = Schema.Struct({
  behaviors: Schema.Struct({}),
}) as unknown as Schema.Schema<PutRiskScoringBehaviourResponse>;

export type PutRiskScoringBehaviourError = CommonErrors;

export const putRiskScoringBehaviour: API.OperationMethod<
  PutRiskScoringBehaviourRequest,
  PutRiskScoringBehaviourResponse,
  PutRiskScoringBehaviourError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutRiskScoringBehaviourRequest,
  output: PutRiskScoringBehaviourResponse,
  errors: [],
}));

// =============================================================================
// RiskScoringIntegration
// =============================================================================

export interface GetRiskScoringIntegrationRequest {
  integrationId: string;
  accountId: string;
}

export const GetRiskScoringIntegrationRequest = Schema.Struct({
  integrationId: Schema.String.pipe(T.HttpPath("integrationId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/zt_risk_scoring/integrations/{integrationId}",
  }),
) as unknown as Schema.Schema<GetRiskScoringIntegrationRequest>;

export interface GetRiskScoringIntegrationResponse {
  /** The id of the integration, a UUIDv4. */
  id: string;
  /** The Cloudflare account tag. */
  accountTag: string;
  /** Whether this integration is enabled and should export changes in risk score. */
  active: boolean;
  /** When the integration was created in RFC3339 format. */
  createdAt: string;
  integrationType: "Okta";
  /** A reference ID defined by the client. Should be set to the Access-Okta IDP integration ID. Useful when the risk-score integration needs to be associated with a secondary asset and recalled using that  */
  referenceId: string;
  /** The base URL for the tenant. E.g. "https://tenant.okta.com". */
  tenantUrl: string;
  /** The URL for the Shared Signals Framework configuration, e.g. "/.well-known/sse-configuration/{integration_uuid}/". https://openid.net/specs/openid-sse-framework-1_0.html#rfc.section.6.2.1. */
  wellKnownUrl: string;
}

export const GetRiskScoringIntegrationResponse = Schema.Struct({
  id: Schema.String,
  accountTag: Schema.String,
  active: Schema.Boolean,
  createdAt: Schema.String,
  integrationType: Schema.Literal("Okta"),
  referenceId: Schema.String,
  tenantUrl: Schema.String,
  wellKnownUrl: Schema.String,
}).pipe(
  Schema.encodeKeys({
    id: "id",
    accountTag: "account_tag",
    active: "active",
    createdAt: "created_at",
    integrationType: "integration_type",
    referenceId: "reference_id",
    tenantUrl: "tenant_url",
    wellKnownUrl: "well_known_url",
  }),
) as unknown as Schema.Schema<GetRiskScoringIntegrationResponse>;

export type GetRiskScoringIntegrationError = CommonErrors;

export const getRiskScoringIntegration: API.OperationMethod<
  GetRiskScoringIntegrationRequest,
  GetRiskScoringIntegrationResponse,
  GetRiskScoringIntegrationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRiskScoringIntegrationRequest,
  output: GetRiskScoringIntegrationResponse,
  errors: [],
}));

export interface ListRiskScoringIntegrationsRequest {
  accountId: string;
}

export const ListRiskScoringIntegrationsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/zt_risk_scoring/integrations",
  }),
) as unknown as Schema.Schema<ListRiskScoringIntegrationsRequest>;

export type ListRiskScoringIntegrationsResponse = {
  id: string;
  accountTag: string;
  active: boolean;
  createdAt: string;
  integrationType: "Okta";
  referenceId: string;
  tenantUrl: string;
  wellKnownUrl: string;
}[];

export const ListRiskScoringIntegrationsResponse = Schema.Array(
  Schema.Struct({
    id: Schema.String,
    accountTag: Schema.String,
    active: Schema.Boolean,
    createdAt: Schema.String,
    integrationType: Schema.Literal("Okta"),
    referenceId: Schema.String,
    tenantUrl: Schema.String,
    wellKnownUrl: Schema.String,
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      accountTag: "account_tag",
      active: "active",
      createdAt: "created_at",
      integrationType: "integration_type",
      referenceId: "reference_id",
      tenantUrl: "tenant_url",
      wellKnownUrl: "well_known_url",
    }),
  ),
) as unknown as Schema.Schema<ListRiskScoringIntegrationsResponse>;

export type ListRiskScoringIntegrationsError = CommonErrors;

export const listRiskScoringIntegrations: API.OperationMethod<
  ListRiskScoringIntegrationsRequest,
  ListRiskScoringIntegrationsResponse,
  ListRiskScoringIntegrationsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListRiskScoringIntegrationsRequest,
  output: ListRiskScoringIntegrationsResponse,
  errors: [],
}));

export interface CreateRiskScoringIntegrationRequest {
  /** Path param: */
  accountId: string;
  /** Body param: */
  integrationType: "Okta";
  /** Body param: The base url of the tenant, e.g. "https://tenant.okta.com". */
  tenantUrl: string;
  /** Body param: A reference id that can be supplied by the client. Currently this should be set to the Access-Okta IDP ID (a UUIDv4). https://developers.cloudflare.com/api/operations/access-identity-provi */
  referenceId?: string | null;
}

export const CreateRiskScoringIntegrationRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  integrationType: Schema.Literal("Okta"),
  tenantUrl: Schema.String,
  referenceId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    integrationType: "integration_type",
    tenantUrl: "tenant_url",
    referenceId: "reference_id",
  }),
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/zt_risk_scoring/integrations",
  }),
) as unknown as Schema.Schema<CreateRiskScoringIntegrationRequest>;

export interface CreateRiskScoringIntegrationResponse {
  /** The id of the integration, a UUIDv4. */
  id: string;
  /** The Cloudflare account tag. */
  accountTag: string;
  /** Whether this integration is enabled and should export changes in risk score. */
  active: boolean;
  /** When the integration was created in RFC3339 format. */
  createdAt: string;
  integrationType: "Okta";
  /** A reference ID defined by the client. Should be set to the Access-Okta IDP integration ID. Useful when the risk-score integration needs to be associated with a secondary asset and recalled using that  */
  referenceId: string;
  /** The base URL for the tenant. E.g. "https://tenant.okta.com". */
  tenantUrl: string;
  /** The URL for the Shared Signals Framework configuration, e.g. "/.well-known/sse-configuration/{integration_uuid}/". https://openid.net/specs/openid-sse-framework-1_0.html#rfc.section.6.2.1. */
  wellKnownUrl: string;
}

export const CreateRiskScoringIntegrationResponse = Schema.Struct({
  id: Schema.String,
  accountTag: Schema.String,
  active: Schema.Boolean,
  createdAt: Schema.String,
  integrationType: Schema.Literal("Okta"),
  referenceId: Schema.String,
  tenantUrl: Schema.String,
  wellKnownUrl: Schema.String,
}).pipe(
  Schema.encodeKeys({
    id: "id",
    accountTag: "account_tag",
    active: "active",
    createdAt: "created_at",
    integrationType: "integration_type",
    referenceId: "reference_id",
    tenantUrl: "tenant_url",
    wellKnownUrl: "well_known_url",
  }),
) as unknown as Schema.Schema<CreateRiskScoringIntegrationResponse>;

export type CreateRiskScoringIntegrationError = CommonErrors;

export const createRiskScoringIntegration: API.OperationMethod<
  CreateRiskScoringIntegrationRequest,
  CreateRiskScoringIntegrationResponse,
  CreateRiskScoringIntegrationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateRiskScoringIntegrationRequest,
  output: CreateRiskScoringIntegrationResponse,
  errors: [],
}));

export interface UpdateRiskScoringIntegrationRequest {
  integrationId: string;
  /** Path param: */
  accountId: string;
  /** Body param: Whether this integration is enabled. If disabled, no risk changes will be exported to the third-party. */
  active: boolean;
  /** Body param: The base url of the tenant, e.g. "https://tenant.okta.com". */
  tenantUrl: string;
  /** Body param: A reference id that can be supplied by the client. Currently this should be set to the Access-Okta IDP ID (a UUIDv4). https://developers.cloudflare.com/api/operations/access-identity-provi */
  referenceId?: string | null;
}

export const UpdateRiskScoringIntegrationRequest = Schema.Struct({
  integrationId: Schema.String.pipe(T.HttpPath("integrationId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  active: Schema.Boolean,
  tenantUrl: Schema.String,
  referenceId: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
}).pipe(
  Schema.encodeKeys({
    active: "active",
    tenantUrl: "tenant_url",
    referenceId: "reference_id",
  }),
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/zt_risk_scoring/integrations/{integrationId}",
  }),
) as unknown as Schema.Schema<UpdateRiskScoringIntegrationRequest>;

export interface UpdateRiskScoringIntegrationResponse {
  /** The id of the integration, a UUIDv4. */
  id: string;
  /** The Cloudflare account tag. */
  accountTag: string;
  /** Whether this integration is enabled and should export changes in risk score. */
  active: boolean;
  /** When the integration was created in RFC3339 format. */
  createdAt: string;
  integrationType: "Okta";
  /** A reference ID defined by the client. Should be set to the Access-Okta IDP integration ID. Useful when the risk-score integration needs to be associated with a secondary asset and recalled using that  */
  referenceId: string;
  /** The base URL for the tenant. E.g. "https://tenant.okta.com". */
  tenantUrl: string;
  /** The URL for the Shared Signals Framework configuration, e.g. "/.well-known/sse-configuration/{integration_uuid}/". https://openid.net/specs/openid-sse-framework-1_0.html#rfc.section.6.2.1. */
  wellKnownUrl: string;
}

export const UpdateRiskScoringIntegrationResponse = Schema.Struct({
  id: Schema.String,
  accountTag: Schema.String,
  active: Schema.Boolean,
  createdAt: Schema.String,
  integrationType: Schema.Literal("Okta"),
  referenceId: Schema.String,
  tenantUrl: Schema.String,
  wellKnownUrl: Schema.String,
}).pipe(
  Schema.encodeKeys({
    id: "id",
    accountTag: "account_tag",
    active: "active",
    createdAt: "created_at",
    integrationType: "integration_type",
    referenceId: "reference_id",
    tenantUrl: "tenant_url",
    wellKnownUrl: "well_known_url",
  }),
) as unknown as Schema.Schema<UpdateRiskScoringIntegrationResponse>;

export type UpdateRiskScoringIntegrationError = CommonErrors;

export const updateRiskScoringIntegration: API.OperationMethod<
  UpdateRiskScoringIntegrationRequest,
  UpdateRiskScoringIntegrationResponse,
  UpdateRiskScoringIntegrationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: UpdateRiskScoringIntegrationRequest,
  output: UpdateRiskScoringIntegrationResponse,
  errors: [],
}));

export interface DeleteRiskScoringIntegrationRequest {
  integrationId: string;
  accountId: string;
}

export const DeleteRiskScoringIntegrationRequest = Schema.Struct({
  integrationId: Schema.String.pipe(T.HttpPath("integrationId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/zt_risk_scoring/integrations/{integrationId}",
  }),
) as unknown as Schema.Schema<DeleteRiskScoringIntegrationRequest>;

export type DeleteRiskScoringIntegrationResponse = unknown;

export const DeleteRiskScoringIntegrationResponse =
  Schema.Unknown as unknown as Schema.Schema<DeleteRiskScoringIntegrationResponse>;

export type DeleteRiskScoringIntegrationError = CommonErrors;

export const deleteRiskScoringIntegration: API.OperationMethod<
  DeleteRiskScoringIntegrationRequest,
  DeleteRiskScoringIntegrationResponse,
  DeleteRiskScoringIntegrationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteRiskScoringIntegrationRequest,
  output: DeleteRiskScoringIntegrationResponse,
  errors: [],
}));

// =============================================================================
// RiskScoringIntegrationReference
// =============================================================================

export interface GetRiskScoringIntegrationReferenceRequest {
  referenceId: string;
  accountId: string;
}

export const GetRiskScoringIntegrationReferenceRequest = Schema.Struct({
  referenceId: Schema.String.pipe(T.HttpPath("referenceId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/zt_risk_scoring/integrations/reference_id/{referenceId}",
  }),
) as unknown as Schema.Schema<GetRiskScoringIntegrationReferenceRequest>;

export interface GetRiskScoringIntegrationReferenceResponse {
  /** The id of the integration, a UUIDv4. */
  id: string;
  /** The Cloudflare account tag. */
  accountTag: string;
  /** Whether this integration is enabled and should export changes in risk score. */
  active: boolean;
  /** When the integration was created in RFC3339 format. */
  createdAt: string;
  integrationType: "Okta";
  /** A reference ID defined by the client. Should be set to the Access-Okta IDP integration ID. Useful when the risk-score integration needs to be associated with a secondary asset and recalled using that  */
  referenceId: string;
  /** The base URL for the tenant. E.g. "https://tenant.okta.com". */
  tenantUrl: string;
  /** The URL for the Shared Signals Framework configuration, e.g. "/.well-known/sse-configuration/{integration_uuid}/". https://openid.net/specs/openid-sse-framework-1_0.html#rfc.section.6.2.1. */
  wellKnownUrl: string;
}

export const GetRiskScoringIntegrationReferenceResponse = Schema.Struct({
  id: Schema.String,
  accountTag: Schema.String,
  active: Schema.Boolean,
  createdAt: Schema.String,
  integrationType: Schema.Literal("Okta"),
  referenceId: Schema.String,
  tenantUrl: Schema.String,
  wellKnownUrl: Schema.String,
}).pipe(
  Schema.encodeKeys({
    id: "id",
    accountTag: "account_tag",
    active: "active",
    createdAt: "created_at",
    integrationType: "integration_type",
    referenceId: "reference_id",
    tenantUrl: "tenant_url",
    wellKnownUrl: "well_known_url",
  }),
) as unknown as Schema.Schema<GetRiskScoringIntegrationReferenceResponse>;

export type GetRiskScoringIntegrationReferenceError = CommonErrors;

export const getRiskScoringIntegrationReference: API.OperationMethod<
  GetRiskScoringIntegrationReferenceRequest,
  GetRiskScoringIntegrationReferenceResponse,
  GetRiskScoringIntegrationReferenceError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRiskScoringIntegrationReferenceRequest,
  output: GetRiskScoringIntegrationReferenceResponse,
  errors: [],
}));

// =============================================================================
// RiskScoringSummary
// =============================================================================

export interface GetRiskScoringSummaryRequest {
  accountId: string;
}

export const GetRiskScoringSummaryRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/zt_risk_scoring/summary",
  }),
) as unknown as Schema.Schema<GetRiskScoringSummaryRequest>;

export interface GetRiskScoringSummaryResponse {
  users: {
    email: string;
    eventCount: number;
    lastEvent: string;
    maxRiskLevel: "low" | "medium" | "high";
    name: string;
    userId: string;
  }[];
}

export const GetRiskScoringSummaryResponse = Schema.Struct({
  users: Schema.Array(
    Schema.Struct({
      email: Schema.String,
      eventCount: Schema.Number,
      lastEvent: Schema.String,
      maxRiskLevel: Schema.Literals(["low", "medium", "high"]),
      name: Schema.String,
      userId: Schema.String,
    }).pipe(
      Schema.encodeKeys({
        email: "email",
        eventCount: "event_count",
        lastEvent: "last_event",
        maxRiskLevel: "max_risk_level",
        name: "name",
        userId: "user_id",
      }),
    ),
  ),
}) as unknown as Schema.Schema<GetRiskScoringSummaryResponse>;

export type GetRiskScoringSummaryError = CommonErrors;

export const getRiskScoringSummary: API.OperationMethod<
  GetRiskScoringSummaryRequest,
  GetRiskScoringSummaryResponse,
  GetRiskScoringSummaryError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetRiskScoringSummaryRequest,
  output: GetRiskScoringSummaryResponse,
  errors: [],
}));

// =============================================================================
// Seat
// =============================================================================

export interface EditSeatRequest {
  /** Path param: Identifier. */
  accountId: string;
  /** Body param: */
  body: { accessSeat: boolean; gatewaySeat: boolean; seatUid: string }[];
}

export const EditSeatRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  body: Schema.Array(
    Schema.Struct({
      accessSeat: Schema.Boolean,
      gatewaySeat: Schema.Boolean,
      seatUid: Schema.String,
    }).pipe(
      Schema.encodeKeys({
        accessSeat: "access_seat",
        gatewaySeat: "gateway_seat",
        seatUid: "seat_uid",
      }),
    ),
  ).pipe(T.HttpBody()),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/access/seats" }),
) as unknown as Schema.Schema<EditSeatRequest>;

export type EditSeatResponse = {
  accessSeat?: boolean;
  createdAt?: string;
  gatewaySeat?: boolean;
  seatUid?: string;
  updatedAt?: string;
}[];

export const EditSeatResponse = Schema.Array(
  Schema.Struct({
    accessSeat: Schema.optional(Schema.Boolean),
    createdAt: Schema.optional(Schema.String),
    gatewaySeat: Schema.optional(Schema.Boolean),
    seatUid: Schema.optional(Schema.String),
    updatedAt: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      accessSeat: "access_seat",
      createdAt: "created_at",
      gatewaySeat: "gateway_seat",
      seatUid: "seat_uid",
      updatedAt: "updated_at",
    }),
  ),
) as unknown as Schema.Schema<EditSeatResponse>;

export type EditSeatError = CommonErrors;

export const editSeat: API.OperationMethod<
  EditSeatRequest,
  EditSeatResponse,
  EditSeatError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: EditSeatRequest,
  output: EditSeatResponse,
  errors: [],
}));

// =============================================================================
// SeedGatewayAuditSshSetting
// =============================================================================

export interface RotateSeedGatewayAuditSshSettingRequest {
  accountId: string;
}

export const RotateSeedGatewayAuditSshSettingRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/gateway/audit_ssh_settings/rotate_seed",
  }),
) as unknown as Schema.Schema<RotateSeedGatewayAuditSshSettingRequest>;

export interface RotateSeedGatewayAuditSshSettingResponse {
  createdAt?: string;
  /** Provide the Base64-encoded HPKE public key that encrypts SSH session logs. See https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/use-cases/ssh/ssh-infrastructure-access/#en */
  publicKey?: string;
  /** Identify the seed ID. */
  seedId?: string;
  updatedAt?: string;
}

export const RotateSeedGatewayAuditSshSettingResponse = Schema.Struct({
  createdAt: Schema.optional(Schema.String),
  publicKey: Schema.optional(Schema.String),
  seedId: Schema.optional(Schema.String),
  updatedAt: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    createdAt: "created_at",
    publicKey: "public_key",
    seedId: "seed_id",
    updatedAt: "updated_at",
  }),
) as unknown as Schema.Schema<RotateSeedGatewayAuditSshSettingResponse>;

export type RotateSeedGatewayAuditSshSettingError = CommonErrors;

export const rotateSeedGatewayAuditSshSetting: API.OperationMethod<
  RotateSeedGatewayAuditSshSettingRequest,
  RotateSeedGatewayAuditSshSettingResponse,
  RotateSeedGatewayAuditSshSettingError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: RotateSeedGatewayAuditSshSettingRequest,
  output: RotateSeedGatewayAuditSshSettingResponse,
  errors: [],
}));

// =============================================================================
// TenantGatewayRule
// =============================================================================

export interface ListTenantGatewayRuleRequest {
  accountId: string;
}

export const ListTenantGatewayRuleRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/gateway/rules/tenant",
  }),
) as unknown as Schema.Schema<ListTenantGatewayRuleRequest>;

export type ListTenantGatewayRuleResponse = {
  action:
    | "on"
    | "off"
    | "allow"
    | "block"
    | "scan"
    | "noscan"
    | "safesearch"
    | "ytrestricted"
    | "isolate"
    | "noisolate"
    | "override"
    | "l4_override"
    | "egress"
    | "resolve"
    | "quarantine"
    | "redirect";
  enabled: boolean;
  filters: ("http" | "dns" | "l4" | "egress" | "dns_resolver")[];
  name: string;
  precedence: number;
  traffic: string;
  id?: string;
  createdAt?: string;
  deletedAt?: string | null;
  description?: string;
  devicePosture?: string;
  expiration?: {
    expiresAt: string;
    duration?: number;
    expired?: boolean;
  } | null;
  identity?: string;
  readOnly?: boolean;
  ruleSettings?: {
    addHeaders?: Record<string, unknown> | null;
    allowChildBypass?: boolean | null;
    auditSsh?: { commandLogging?: boolean } | null;
    bisoAdminControls?: {
      copy?: "enabled" | "disabled" | "remote_only";
      dcp?: boolean;
      dd?: boolean;
      dk?: boolean;
      download?: "enabled" | "disabled" | "remote_only";
      dp?: boolean;
      du?: boolean;
      keyboard?: "enabled" | "disabled";
      paste?: "enabled" | "disabled" | "remote_only";
      printing?: "enabled" | "disabled";
      upload?: "enabled" | "disabled";
      version?: "v1" | "v2";
    };
    blockPage?: { targetUri: string; includeContext?: boolean } | null;
    blockPageEnabled?: boolean;
    blockReason?: string | null;
    bypassParentRule?: boolean | null;
    checkSession?: { duration?: string; enforce?: boolean } | null;
    dnsResolvers?: { ipv4?: unknown[]; ipv6?: unknown[] } | null;
    egress?: { ipv4?: string; ipv4Fallback?: string; ipv6?: string } | null;
    forensicCopy?: { enabled?: boolean } | null;
    ignoreCnameCategoryMatches?: boolean;
    insecureDisableDnssecValidation?: boolean;
    ipCategories?: boolean;
    ipIndicatorFeeds?: boolean;
    l4override?: { ip?: string; port?: number } | null;
    notificationSettings?: {
      enabled?: boolean;
      includeContext?: boolean;
      msg?: string;
      supportUrl?: string;
    } | null;
    overrideHost?: string;
    overrideIps?: string[] | null;
    payloadLog?: { enabled?: boolean } | null;
    quarantine?: {
      fileTypes?: (
        | "exe"
        | "pdf"
        | "doc"
        | "docm"
        | "docx"
        | "rtf"
        | "ppt"
        | "pptx"
        | "xls"
        | "xlsm"
        | "xlsx"
        | "zip"
        | "rar"
      )[];
    } | null;
    redirect?: {
      targetUri: string;
      includeContext?: boolean;
      preservePathAndQuery?: boolean;
    } | null;
    resolveDnsInternally?: {
      fallback?: "none" | "public_dns";
      viewId?: string;
    } | null;
    resolveDnsThroughCloudflare?: boolean | null;
    untrustedCert?: { action?: "pass_through" | "block" | "error" } | null;
  };
  schedule?: {
    fri?: string;
    mon?: string;
    sat?: string;
    sun?: string;
    thu?: string;
    timeZone?: string;
    tue?: string;
    wed?: string;
  } | null;
  sharable?: boolean;
  sourceAccount?: string;
  updatedAt?: string;
  version?: number;
  warningStatus?: string | null;
}[];

export const ListTenantGatewayRuleResponse = Schema.Array(
  Schema.Struct({
    action: Schema.Literals([
      "on",
      "off",
      "allow",
      "block",
      "scan",
      "noscan",
      "safesearch",
      "ytrestricted",
      "isolate",
      "noisolate",
      "override",
      "l4_override",
      "egress",
      "resolve",
      "quarantine",
      "redirect",
    ]),
    enabled: Schema.Boolean,
    filters: Schema.Array(
      Schema.Literals(["http", "dns", "l4", "egress", "dns_resolver"]),
    ),
    name: Schema.String,
    precedence: Schema.Number,
    traffic: Schema.String,
    id: Schema.optional(Schema.String),
    createdAt: Schema.optional(Schema.String),
    deletedAt: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
    description: Schema.optional(Schema.String),
    devicePosture: Schema.optional(Schema.String),
    expiration: Schema.optional(
      Schema.Union([
        Schema.Struct({
          expiresAt: Schema.String,
          duration: Schema.optional(Schema.Number),
          expired: Schema.optional(Schema.Boolean),
        }).pipe(
          Schema.encodeKeys({
            expiresAt: "expires_at",
            duration: "duration",
            expired: "expired",
          }),
        ),
        Schema.Null,
      ]),
    ),
    identity: Schema.optional(Schema.String),
    readOnly: Schema.optional(Schema.Boolean),
    ruleSettings: Schema.optional(
      Schema.Struct({
        addHeaders: Schema.optional(
          Schema.Union([Schema.Struct({}), Schema.Null]),
        ),
        allowChildBypass: Schema.optional(
          Schema.Union([Schema.Boolean, Schema.Null]),
        ),
        auditSsh: Schema.optional(
          Schema.Union([
            Schema.Struct({
              commandLogging: Schema.optional(Schema.Boolean),
            }).pipe(Schema.encodeKeys({ commandLogging: "command_logging" })),
            Schema.Null,
          ]),
        ),
        bisoAdminControls: Schema.optional(
          Schema.Struct({
            copy: Schema.optional(
              Schema.Literals(["enabled", "disabled", "remote_only"]),
            ),
            dcp: Schema.optional(Schema.Boolean),
            dd: Schema.optional(Schema.Boolean),
            dk: Schema.optional(Schema.Boolean),
            download: Schema.optional(
              Schema.Literals(["enabled", "disabled", "remote_only"]),
            ),
            dp: Schema.optional(Schema.Boolean),
            du: Schema.optional(Schema.Boolean),
            keyboard: Schema.optional(Schema.Literals(["enabled", "disabled"])),
            paste: Schema.optional(
              Schema.Literals(["enabled", "disabled", "remote_only"]),
            ),
            printing: Schema.optional(Schema.Literals(["enabled", "disabled"])),
            upload: Schema.optional(Schema.Literals(["enabled", "disabled"])),
            version: Schema.optional(Schema.Literals(["v1", "v2"])),
          }),
        ),
        blockPage: Schema.optional(
          Schema.Union([
            Schema.Struct({
              targetUri: Schema.String,
              includeContext: Schema.optional(Schema.Boolean),
            }).pipe(
              Schema.encodeKeys({
                targetUri: "target_uri",
                includeContext: "include_context",
              }),
            ),
            Schema.Null,
          ]),
        ),
        blockPageEnabled: Schema.optional(Schema.Boolean),
        blockReason: Schema.optional(
          Schema.Union([Schema.String, Schema.Null]),
        ),
        bypassParentRule: Schema.optional(
          Schema.Union([Schema.Boolean, Schema.Null]),
        ),
        checkSession: Schema.optional(
          Schema.Union([
            Schema.Struct({
              duration: Schema.optional(Schema.String),
              enforce: Schema.optional(Schema.Boolean),
            }),
            Schema.Null,
          ]),
        ),
        dnsResolvers: Schema.optional(
          Schema.Union([
            Schema.Struct({
              ipv4: Schema.optional(Schema.Array(Schema.Unknown)),
              ipv6: Schema.optional(Schema.Array(Schema.Unknown)),
            }),
            Schema.Null,
          ]),
        ),
        egress: Schema.optional(
          Schema.Union([
            Schema.Struct({
              ipv4: Schema.optional(Schema.String),
              ipv4Fallback: Schema.optional(Schema.String),
              ipv6: Schema.optional(Schema.String),
            }).pipe(
              Schema.encodeKeys({
                ipv4: "ipv4",
                ipv4Fallback: "ipv4_fallback",
                ipv6: "ipv6",
              }),
            ),
            Schema.Null,
          ]),
        ),
        forensicCopy: Schema.optional(
          Schema.Union([
            Schema.Struct({
              enabled: Schema.optional(Schema.Boolean),
            }),
            Schema.Null,
          ]),
        ),
        ignoreCnameCategoryMatches: Schema.optional(Schema.Boolean),
        insecureDisableDnssecValidation: Schema.optional(Schema.Boolean),
        ipCategories: Schema.optional(Schema.Boolean),
        ipIndicatorFeeds: Schema.optional(Schema.Boolean),
        l4override: Schema.optional(
          Schema.Union([
            Schema.Struct({
              ip: Schema.optional(Schema.String),
              port: Schema.optional(Schema.Number),
            }),
            Schema.Null,
          ]),
        ),
        notificationSettings: Schema.optional(
          Schema.Union([
            Schema.Struct({
              enabled: Schema.optional(Schema.Boolean),
              includeContext: Schema.optional(Schema.Boolean),
              msg: Schema.optional(Schema.String),
              supportUrl: Schema.optional(Schema.String),
            }).pipe(
              Schema.encodeKeys({
                enabled: "enabled",
                includeContext: "include_context",
                msg: "msg",
                supportUrl: "support_url",
              }),
            ),
            Schema.Null,
          ]),
        ),
        overrideHost: Schema.optional(Schema.String),
        overrideIps: Schema.optional(
          Schema.Union([Schema.Array(Schema.String), Schema.Null]),
        ),
        payloadLog: Schema.optional(
          Schema.Union([
            Schema.Struct({
              enabled: Schema.optional(Schema.Boolean),
            }),
            Schema.Null,
          ]),
        ),
        quarantine: Schema.optional(
          Schema.Union([
            Schema.Struct({
              fileTypes: Schema.optional(
                Schema.Array(
                  Schema.Literals([
                    "exe",
                    "pdf",
                    "doc",
                    "docm",
                    "docx",
                    "rtf",
                    "ppt",
                    "pptx",
                    "xls",
                    "xlsm",
                    "xlsx",
                    "zip",
                    "rar",
                  ]),
                ),
              ),
            }).pipe(Schema.encodeKeys({ fileTypes: "file_types" })),
            Schema.Null,
          ]),
        ),
        redirect: Schema.optional(
          Schema.Union([
            Schema.Struct({
              targetUri: Schema.String,
              includeContext: Schema.optional(Schema.Boolean),
              preservePathAndQuery: Schema.optional(Schema.Boolean),
            }).pipe(
              Schema.encodeKeys({
                targetUri: "target_uri",
                includeContext: "include_context",
                preservePathAndQuery: "preserve_path_and_query",
              }),
            ),
            Schema.Null,
          ]),
        ),
        resolveDnsInternally: Schema.optional(
          Schema.Union([
            Schema.Struct({
              fallback: Schema.optional(
                Schema.Literals(["none", "public_dns"]),
              ),
              viewId: Schema.optional(Schema.String),
            }).pipe(
              Schema.encodeKeys({ fallback: "fallback", viewId: "view_id" }),
            ),
            Schema.Null,
          ]),
        ),
        resolveDnsThroughCloudflare: Schema.optional(
          Schema.Union([Schema.Boolean, Schema.Null]),
        ),
        untrustedCert: Schema.optional(
          Schema.Union([
            Schema.Struct({
              action: Schema.optional(
                Schema.Literals(["pass_through", "block", "error"]),
              ),
            }),
            Schema.Null,
          ]),
        ),
      }).pipe(
        Schema.encodeKeys({
          addHeaders: "add_headers",
          allowChildBypass: "allow_child_bypass",
          auditSsh: "audit_ssh",
          bisoAdminControls: "biso_admin_controls",
          blockPage: "block_page",
          blockPageEnabled: "block_page_enabled",
          blockReason: "block_reason",
          bypassParentRule: "bypass_parent_rule",
          checkSession: "check_session",
          dnsResolvers: "dns_resolvers",
          egress: "egress",
          forensicCopy: "forensic_copy",
          ignoreCnameCategoryMatches: "ignore_cname_category_matches",
          insecureDisableDnssecValidation: "insecure_disable_dnssec_validation",
          ipCategories: "ip_categories",
          ipIndicatorFeeds: "ip_indicator_feeds",
          l4override: "l4override",
          notificationSettings: "notification_settings",
          overrideHost: "override_host",
          overrideIps: "override_ips",
          payloadLog: "payload_log",
          quarantine: "quarantine",
          redirect: "redirect",
          resolveDnsInternally: "resolve_dns_internally",
          resolveDnsThroughCloudflare: "resolve_dns_through_cloudflare",
          untrustedCert: "untrusted_cert",
        }),
      ),
    ),
    schedule: Schema.optional(
      Schema.Union([
        Schema.Struct({
          fri: Schema.optional(Schema.String),
          mon: Schema.optional(Schema.String),
          sat: Schema.optional(Schema.String),
          sun: Schema.optional(Schema.String),
          thu: Schema.optional(Schema.String),
          timeZone: Schema.optional(Schema.String),
          tue: Schema.optional(Schema.String),
          wed: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            fri: "fri",
            mon: "mon",
            sat: "sat",
            sun: "sun",
            thu: "thu",
            timeZone: "time_zone",
            tue: "tue",
            wed: "wed",
          }),
        ),
        Schema.Null,
      ]),
    ),
    sharable: Schema.optional(Schema.Boolean),
    sourceAccount: Schema.optional(Schema.String),
    updatedAt: Schema.optional(Schema.String),
    version: Schema.optional(Schema.Number),
    warningStatus: Schema.optional(Schema.Union([Schema.String, Schema.Null])),
  }).pipe(
    Schema.encodeKeys({
      action: "action",
      enabled: "enabled",
      filters: "filters",
      name: "name",
      precedence: "precedence",
      traffic: "traffic",
      id: "id",
      createdAt: "created_at",
      deletedAt: "deleted_at",
      description: "description",
      devicePosture: "device_posture",
      expiration: "expiration",
      identity: "identity",
      readOnly: "read_only",
      ruleSettings: "rule_settings",
      schedule: "schedule",
      sharable: "sharable",
      sourceAccount: "source_account",
      updatedAt: "updated_at",
      version: "version",
      warningStatus: "warning_status",
    }),
  ),
) as unknown as Schema.Schema<ListTenantGatewayRuleResponse>;

export type ListTenantGatewayRuleError = CommonErrors;

export const listTenantGatewayRule: API.OperationMethod<
  ListTenantGatewayRuleRequest,
  ListTenantGatewayRuleResponse,
  ListTenantGatewayRuleError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListTenantGatewayRuleRequest,
  output: ListTenantGatewayRuleResponse,
  errors: [],
}));

// =============================================================================
// TimeDexFleetStatus
// =============================================================================

export interface OverTimeDexFleetStatusRequest {
  /** Path param: Unique identifier for account */
  accountId: string;
  /** Query param: Time range beginning in ISO format */
  from: string;
  /** Query param: Time range end in ISO format */
  to: string;
  /** Query param: Cloudflare colo */
  colo?: string;
  /** Query param: Device-specific ID, given as UUID v4 */
  deviceId?: string;
}

export const OverTimeDexFleetStatusRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  from: Schema.String.pipe(T.HttpQuery("from")),
  to: Schema.String.pipe(T.HttpQuery("to")),
  colo: Schema.optional(Schema.String).pipe(T.HttpQuery("colo")),
  deviceId: Schema.optional(Schema.String).pipe(T.HttpQuery("device_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/dex/fleet-status/over-time",
  }),
) as unknown as Schema.Schema<OverTimeDexFleetStatusRequest>;

export type OverTimeDexFleetStatusResponse = unknown;

export const OverTimeDexFleetStatusResponse =
  Schema.Unknown as unknown as Schema.Schema<OverTimeDexFleetStatusResponse>;

export type OverTimeDexFleetStatusError = CommonErrors;

export const overTimeDexFleetStatus: API.OperationMethod<
  OverTimeDexFleetStatusRequest,
  OverTimeDexFleetStatusResponse,
  OverTimeDexFleetStatusError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: OverTimeDexFleetStatusRequest,
  output: OverTimeDexFleetStatusResponse,
  errors: [],
}));

// =============================================================================
// TokensAccessApplication
// =============================================================================

export interface RevokeTokensAccessApplicationRequest {}

export const RevokeTokensAccessApplicationRequest = Schema.Struct({}).pipe(
  T.Http({
    method: "POST",
    path: "/{accountOrZone}/{accountOrZoneId}/access/apps/{appId}/revoke_tokens",
  }),
) as unknown as Schema.Schema<RevokeTokensAccessApplicationRequest>;

export type RevokeTokensAccessApplicationResponse = unknown;

export const RevokeTokensAccessApplicationResponse =
  Schema.Unknown as unknown as Schema.Schema<RevokeTokensAccessApplicationResponse>;

export type RevokeTokensAccessApplicationError = CommonErrors;

export const revokeTokensAccessApplication: API.OperationMethod<
  RevokeTokensAccessApplicationRequest,
  RevokeTokensAccessApplicationResponse,
  RevokeTokensAccessApplicationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: RevokeTokensAccessApplicationRequest,
  output: RevokeTokensAccessApplicationResponse,
  errors: [],
}));

// =============================================================================
// Tunnel
// =============================================================================

export interface ListTunnelsRequest {
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Query param: */
  excludePrefix?: string;
  /** Query param: If provided, include only resources that were created (and not deleted) before this time. URL encoded. */
  existedAt?: string;
  /** Query param: */
  includePrefix?: string;
  /** Query param: If `true`, only include deleted tunnels. If `false`, exclude deleted tunnels. If empty, all tunnels will be included. */
  isDeleted?: boolean;
  /** Query param: A user-friendly name for the tunnel. */
  name?: string;
  /** Query param: The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is  */
  status?: "inactive" | "degraded" | "healthy" | "down";
  /** Query param: The types of tunnels to filter by, separated by commas. */
  tunTypes?: (
    | "cfd_tunnel"
    | "warp_connector"
    | "warp"
    | "magic"
    | "ip_sec"
    | "gre"
    | "cni"
  )[];
  /** Query param: UUID of the tunnel. */
  uuid?: string;
  /** Query param: */
  wasActiveAt?: string;
  /** Query param: */
  wasInactiveAt?: string;
}

export const ListTunnelsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  excludePrefix: Schema.optional(Schema.String).pipe(
    T.HttpQuery("exclude_prefix"),
  ),
  existedAt: Schema.optional(Schema.String).pipe(T.HttpQuery("existed_at")),
  includePrefix: Schema.optional(Schema.String).pipe(
    T.HttpQuery("include_prefix"),
  ),
  isDeleted: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_deleted")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  status: Schema.optional(
    Schema.Literals(["inactive", "degraded", "healthy", "down"]),
  ).pipe(T.HttpQuery("status")),
  tunTypes: Schema.optional(
    Schema.Array(
      Schema.Literals([
        "cfd_tunnel",
        "warp_connector",
        "warp",
        "magic",
        "ip_sec",
        "gre",
        "cni",
      ]),
    ),
  ).pipe(T.HttpQuery("tun_types")),
  uuid: Schema.optional(Schema.String).pipe(T.HttpQuery("uuid")),
  wasActiveAt: Schema.optional(Schema.String).pipe(
    T.HttpQuery("was_active_at"),
  ),
  wasInactiveAt: Schema.optional(Schema.String).pipe(
    T.HttpQuery("was_inactive_at"),
  ),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/tunnels" }),
) as unknown as Schema.Schema<ListTunnelsRequest>;

export type ListTunnelsResponse = (
  | unknown
  | {
      id?: string;
      accountTag?: string;
      connections?: {
        id?: string;
        clientId?: string;
        clientVersion?: string;
        coloName?: string;
        isPendingReconnect?: boolean;
        openedAt?: string;
        originIp?: string;
        uuid?: string;
      }[];
      connsActiveAt?: string;
      connsInactiveAt?: string;
      createdAt?: string;
      deletedAt?: string;
      metadata?: unknown;
      name?: string;
      status?: "inactive" | "degraded" | "healthy" | "down";
      tunType?:
        | "cfd_tunnel"
        | "warp_connector"
        | "warp"
        | "magic"
        | "ip_sec"
        | "gre"
        | "cni";
    }
)[];

export const ListTunnelsResponse = Schema.Array(
  Schema.Union([
    Schema.Unknown,
    Schema.Struct({
      id: Schema.optional(Schema.String),
      accountTag: Schema.optional(Schema.String),
      connections: Schema.optional(
        Schema.Array(
          Schema.Struct({
            id: Schema.optional(Schema.String),
            clientId: Schema.optional(Schema.String),
            clientVersion: Schema.optional(Schema.String),
            coloName: Schema.optional(Schema.String),
            isPendingReconnect: Schema.optional(Schema.Boolean),
            openedAt: Schema.optional(Schema.String),
            originIp: Schema.optional(Schema.String),
            uuid: Schema.optional(Schema.String),
          }).pipe(
            Schema.encodeKeys({
              id: "id",
              clientId: "client_id",
              clientVersion: "client_version",
              coloName: "colo_name",
              isPendingReconnect: "is_pending_reconnect",
              openedAt: "opened_at",
              originIp: "origin_ip",
              uuid: "uuid",
            }),
          ),
        ),
      ),
      connsActiveAt: Schema.optional(Schema.String),
      connsInactiveAt: Schema.optional(Schema.String),
      createdAt: Schema.optional(Schema.String),
      deletedAt: Schema.optional(Schema.String),
      metadata: Schema.optional(Schema.Unknown),
      name: Schema.optional(Schema.String),
      status: Schema.optional(
        Schema.Literals(["inactive", "degraded", "healthy", "down"]),
      ),
      tunType: Schema.optional(
        Schema.Literals([
          "cfd_tunnel",
          "warp_connector",
          "warp",
          "magic",
          "ip_sec",
          "gre",
          "cni",
        ]),
      ),
    }).pipe(
      Schema.encodeKeys({
        id: "id",
        accountTag: "account_tag",
        connections: "connections",
        connsActiveAt: "conns_active_at",
        connsInactiveAt: "conns_inactive_at",
        createdAt: "created_at",
        deletedAt: "deleted_at",
        metadata: "metadata",
        name: "name",
        status: "status",
        tunType: "tun_type",
      }),
    ),
  ]),
) as unknown as Schema.Schema<ListTunnelsResponse>;

export type ListTunnelsError = CommonErrors;

export const listTunnels: API.OperationMethod<
  ListTunnelsRequest,
  ListTunnelsResponse,
  ListTunnelsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListTunnelsRequest,
  output: ListTunnelsResponse,
  errors: [],
}));

// =============================================================================
// TunnelCloudflared
// =============================================================================

export interface GetTunnelCloudflaredRequest {
  tunnelId: string;
  /** Cloudflare account ID */
  accountId: string;
}

export const GetTunnelCloudflaredRequest = Schema.Struct({
  tunnelId: Schema.String.pipe(T.HttpPath("tunnelId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/cfd_tunnel/{tunnelId}",
  }),
) as unknown as Schema.Schema<GetTunnelCloudflaredRequest>;

export type GetTunnelCloudflaredResponse = unknown;

export const GetTunnelCloudflaredResponse =
  Schema.Unknown as unknown as Schema.Schema<GetTunnelCloudflaredResponse>;

export type GetTunnelCloudflaredError = CommonErrors;

export const getTunnelCloudflared: API.OperationMethod<
  GetTunnelCloudflaredRequest,
  GetTunnelCloudflaredResponse,
  GetTunnelCloudflaredError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTunnelCloudflaredRequest,
  output: GetTunnelCloudflaredResponse,
  errors: [],
}));

export interface ListTunnelCloudflaredsRequest {
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Query param: */
  excludePrefix?: string;
  /** Query param: If provided, include only resources that were created (and not deleted) before this time. URL encoded. */
  existedAt?: string;
  /** Query param: */
  includePrefix?: string;
  /** Query param: If `true`, only include deleted tunnels. If `false`, exclude deleted tunnels. If empty, all tunnels will be included. */
  isDeleted?: boolean;
  /** Query param: A user-friendly name for a tunnel. */
  name?: string;
  /** Query param: The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is  */
  status?: "inactive" | "degraded" | "healthy" | "down";
  /** Query param: UUID of the tunnel. */
  uuid?: string;
  /** Query param: */
  wasActiveAt?: string;
  /** Query param: */
  wasInactiveAt?: string;
}

export const ListTunnelCloudflaredsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  excludePrefix: Schema.optional(Schema.String).pipe(
    T.HttpQuery("exclude_prefix"),
  ),
  existedAt: Schema.optional(Schema.String).pipe(T.HttpQuery("existed_at")),
  includePrefix: Schema.optional(Schema.String).pipe(
    T.HttpQuery("include_prefix"),
  ),
  isDeleted: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_deleted")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  status: Schema.optional(
    Schema.Literals(["inactive", "degraded", "healthy", "down"]),
  ).pipe(T.HttpQuery("status")),
  uuid: Schema.optional(Schema.String).pipe(T.HttpQuery("uuid")),
  wasActiveAt: Schema.optional(Schema.String).pipe(
    T.HttpQuery("was_active_at"),
  ),
  wasInactiveAt: Schema.optional(Schema.String).pipe(
    T.HttpQuery("was_inactive_at"),
  ),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/cfd_tunnel" }),
) as unknown as Schema.Schema<ListTunnelCloudflaredsRequest>;

export type ListTunnelCloudflaredsResponse = unknown;

export const ListTunnelCloudflaredsResponse =
  Schema.Unknown as unknown as Schema.Schema<ListTunnelCloudflaredsResponse>;

export type ListTunnelCloudflaredsError = CommonErrors;

export const listTunnelCloudflareds: API.OperationMethod<
  ListTunnelCloudflaredsRequest,
  ListTunnelCloudflaredsResponse,
  ListTunnelCloudflaredsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListTunnelCloudflaredsRequest,
  output: ListTunnelCloudflaredsResponse,
  errors: [],
}));

export interface CreateTunnelCloudflaredRequest {
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Body param: A user-friendly name for a tunnel. */
  name: string;
  /** Body param: Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust da */
  configSrc?: "local" | "cloudflare";
  /** Body param: Sets the password required to run a locally-managed tunnel. Must be at least 32 bytes and encoded as a base64 string. */
  tunnelSecret?: string;
}

export const CreateTunnelCloudflaredRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.String,
  configSrc: Schema.optional(Schema.Literals(["local", "cloudflare"])),
  tunnelSecret: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({
    name: "name",
    configSrc: "config_src",
    tunnelSecret: "tunnel_secret",
  }),
  T.Http({ method: "POST", path: "/accounts/{account_id}/cfd_tunnel" }),
) as unknown as Schema.Schema<CreateTunnelCloudflaredRequest>;

export type CreateTunnelCloudflaredResponse = unknown;

export const CreateTunnelCloudflaredResponse =
  Schema.Unknown as unknown as Schema.Schema<CreateTunnelCloudflaredResponse>;

export type CreateTunnelCloudflaredError = CommonErrors;

export const createTunnelCloudflared: API.OperationMethod<
  CreateTunnelCloudflaredRequest,
  CreateTunnelCloudflaredResponse,
  CreateTunnelCloudflaredError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateTunnelCloudflaredRequest,
  output: CreateTunnelCloudflaredResponse,
  errors: [],
}));

export interface PatchTunnelCloudflaredRequest {
  tunnelId: string;
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Body param: A user-friendly name for a tunnel. */
  name?: string;
  /** Body param: Sets the password required to run a locally-managed tunnel. Must be at least 32 bytes and encoded as a base64 string. */
  tunnelSecret?: string;
}

export const PatchTunnelCloudflaredRequest = Schema.Struct({
  tunnelId: Schema.String.pipe(T.HttpPath("tunnelId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.optional(Schema.String),
  tunnelSecret: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({ name: "name", tunnelSecret: "tunnel_secret" }),
  T.Http({
    method: "PATCH",
    path: "/accounts/{account_id}/cfd_tunnel/{tunnelId}",
  }),
) as unknown as Schema.Schema<PatchTunnelCloudflaredRequest>;

export type PatchTunnelCloudflaredResponse = unknown;

export const PatchTunnelCloudflaredResponse =
  Schema.Unknown as unknown as Schema.Schema<PatchTunnelCloudflaredResponse>;

export type PatchTunnelCloudflaredError = CommonErrors;

export const patchTunnelCloudflared: API.OperationMethod<
  PatchTunnelCloudflaredRequest,
  PatchTunnelCloudflaredResponse,
  PatchTunnelCloudflaredError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchTunnelCloudflaredRequest,
  output: PatchTunnelCloudflaredResponse,
  errors: [],
}));

export interface DeleteTunnelCloudflaredRequest {
  tunnelId: string;
  /** Cloudflare account ID */
  accountId: string;
}

export const DeleteTunnelCloudflaredRequest = Schema.Struct({
  tunnelId: Schema.String.pipe(T.HttpPath("tunnelId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/cfd_tunnel/{tunnelId}",
  }),
) as unknown as Schema.Schema<DeleteTunnelCloudflaredRequest>;

export type DeleteTunnelCloudflaredResponse = unknown;

export const DeleteTunnelCloudflaredResponse =
  Schema.Unknown as unknown as Schema.Schema<DeleteTunnelCloudflaredResponse>;

export type DeleteTunnelCloudflaredError = CommonErrors;

export const deleteTunnelCloudflared: API.OperationMethod<
  DeleteTunnelCloudflaredRequest,
  DeleteTunnelCloudflaredResponse,
  DeleteTunnelCloudflaredError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteTunnelCloudflaredRequest,
  output: DeleteTunnelCloudflaredResponse,
  errors: [],
}));

// =============================================================================
// TunnelCloudflaredConfiguration
// =============================================================================

export interface GetTunnelCloudflaredConfigurationRequest {
  tunnelId: string;
  /** Identifier. */
  accountId: string;
}

export const GetTunnelCloudflaredConfigurationRequest = Schema.Struct({
  tunnelId: Schema.String.pipe(T.HttpPath("tunnelId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/cfd_tunnel/{tunnelId}/configurations",
  }),
) as unknown as Schema.Schema<GetTunnelCloudflaredConfigurationRequest>;

export interface GetTunnelCloudflaredConfigurationResponse {
  /** Identifier. */
  accountId?: string;
  /** The tunnel configuration and ingress rules. */
  config?: {
    ingress?: {
      hostname: string;
      service: string;
      originRequest?: {
        access?: { audTag: string[]; teamName: string; required?: boolean };
        caPool?: string;
        connectTimeout?: number;
        disableChunkedEncoding?: boolean;
        http2Origin?: boolean;
        httpHostHeader?: string;
        keepAliveConnections?: number;
        keepAliveTimeout?: number;
        matchSNItoHost?: boolean;
        noHappyEyeballs?: boolean;
        noTLSVerify?: boolean;
        originServerName?: string;
        proxyType?: string;
        tcpKeepAlive?: number;
        tlsTimeout?: number;
      };
      path?: string;
    }[];
    originRequest?: {
      access?: { audTag: string[]; teamName: string; required?: boolean };
      caPool?: string;
      connectTimeout?: number;
      disableChunkedEncoding?: boolean;
      http2Origin?: boolean;
      httpHostHeader?: string;
      keepAliveConnections?: number;
      keepAliveTimeout?: number;
      matchSNItoHost?: boolean;
      noHappyEyeballs?: boolean;
      noTLSVerify?: boolean;
      originServerName?: string;
      proxyType?: string;
      tcpKeepAlive?: number;
      tlsTimeout?: number;
    };
  };
  createdAt?: string;
  /** Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel's configuration on the Zero Trus */
  source?: "local" | "cloudflare";
  /** UUID of the tunnel. */
  tunnelId?: string;
  /** The version of the Tunnel Configuration. */
  version?: number;
}

export const GetTunnelCloudflaredConfigurationResponse = Schema.Struct({
  accountId: Schema.optional(Schema.String),
  config: Schema.optional(
    Schema.Struct({
      ingress: Schema.optional(
        Schema.Array(
          Schema.Struct({
            hostname: Schema.String,
            service: Schema.String,
            originRequest: Schema.optional(
              Schema.Struct({
                access: Schema.optional(
                  Schema.Struct({
                    audTag: Schema.Array(Schema.String),
                    teamName: Schema.String,
                    required: Schema.optional(Schema.Boolean),
                  }),
                ),
                caPool: Schema.optional(Schema.String),
                connectTimeout: Schema.optional(Schema.Number),
                disableChunkedEncoding: Schema.optional(Schema.Boolean),
                http2Origin: Schema.optional(Schema.Boolean),
                httpHostHeader: Schema.optional(Schema.String),
                keepAliveConnections: Schema.optional(Schema.Number),
                keepAliveTimeout: Schema.optional(Schema.Number),
                matchSNItoHost: Schema.optional(Schema.Boolean),
                noHappyEyeballs: Schema.optional(Schema.Boolean),
                noTLSVerify: Schema.optional(Schema.Boolean),
                originServerName: Schema.optional(Schema.String),
                proxyType: Schema.optional(Schema.String),
                tcpKeepAlive: Schema.optional(Schema.Number),
                tlsTimeout: Schema.optional(Schema.Number),
              }),
            ),
            path: Schema.optional(Schema.String),
          }),
        ),
      ),
      originRequest: Schema.optional(
        Schema.Struct({
          access: Schema.optional(
            Schema.Struct({
              audTag: Schema.Array(Schema.String),
              teamName: Schema.String,
              required: Schema.optional(Schema.Boolean),
            }),
          ),
          caPool: Schema.optional(Schema.String),
          connectTimeout: Schema.optional(Schema.Number),
          disableChunkedEncoding: Schema.optional(Schema.Boolean),
          http2Origin: Schema.optional(Schema.Boolean),
          httpHostHeader: Schema.optional(Schema.String),
          keepAliveConnections: Schema.optional(Schema.Number),
          keepAliveTimeout: Schema.optional(Schema.Number),
          matchSNItoHost: Schema.optional(Schema.Boolean),
          noHappyEyeballs: Schema.optional(Schema.Boolean),
          noTLSVerify: Schema.optional(Schema.Boolean),
          originServerName: Schema.optional(Schema.String),
          proxyType: Schema.optional(Schema.String),
          tcpKeepAlive: Schema.optional(Schema.Number),
          tlsTimeout: Schema.optional(Schema.Number),
        }),
      ),
    }),
  ),
  createdAt: Schema.optional(Schema.String),
  source: Schema.optional(Schema.Literals(["local", "cloudflare"])),
  tunnelId: Schema.optional(Schema.String),
  version: Schema.optional(Schema.Number),
}).pipe(
  Schema.encodeKeys({
    accountId: "account_id",
    config: "config",
    createdAt: "created_at",
    source: "source",
    tunnelId: "tunnel_id",
    version: "version",
  }),
) as unknown as Schema.Schema<GetTunnelCloudflaredConfigurationResponse>;

export type GetTunnelCloudflaredConfigurationError = CommonErrors;

export const getTunnelCloudflaredConfiguration: API.OperationMethod<
  GetTunnelCloudflaredConfigurationRequest,
  GetTunnelCloudflaredConfigurationResponse,
  GetTunnelCloudflaredConfigurationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTunnelCloudflaredConfigurationRequest,
  output: GetTunnelCloudflaredConfigurationResponse,
  errors: [],
}));

export interface PutTunnelCloudflaredConfigurationRequest {
  tunnelId: string;
  /** Path param: Identifier. */
  accountId: string;
  /** Body param: The tunnel configuration and ingress rules. */
  config?: {
    ingress?: {
      hostname: string;
      service: string;
      originRequest?: {
        access?: { audTag: string[]; teamName: string; required?: boolean };
        caPool?: string;
        connectTimeout?: number;
        disableChunkedEncoding?: boolean;
        http2Origin?: boolean;
        httpHostHeader?: string;
        keepAliveConnections?: number;
        keepAliveTimeout?: number;
        matchSNItoHost?: boolean;
        noHappyEyeballs?: boolean;
        noTLSVerify?: boolean;
        originServerName?: string;
        proxyType?: string;
        tcpKeepAlive?: number;
        tlsTimeout?: number;
      };
      path?: string;
    }[];
    originRequest?: {
      access?: { audTag: string[]; teamName: string; required?: boolean };
      caPool?: string;
      connectTimeout?: number;
      disableChunkedEncoding?: boolean;
      http2Origin?: boolean;
      httpHostHeader?: string;
      keepAliveConnections?: number;
      keepAliveTimeout?: number;
      matchSNItoHost?: boolean;
      noHappyEyeballs?: boolean;
      noTLSVerify?: boolean;
      originServerName?: string;
      proxyType?: string;
      tcpKeepAlive?: number;
      tlsTimeout?: number;
    };
  };
}

export const PutTunnelCloudflaredConfigurationRequest = Schema.Struct({
  tunnelId: Schema.String.pipe(T.HttpPath("tunnelId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  config: Schema.optional(
    Schema.Struct({
      ingress: Schema.optional(
        Schema.Array(
          Schema.Struct({
            hostname: Schema.String,
            service: Schema.String,
            originRequest: Schema.optional(
              Schema.Struct({
                access: Schema.optional(
                  Schema.Struct({
                    audTag: Schema.Array(Schema.String),
                    teamName: Schema.String,
                    required: Schema.optional(Schema.Boolean),
                  }),
                ),
                caPool: Schema.optional(Schema.String),
                connectTimeout: Schema.optional(Schema.Number),
                disableChunkedEncoding: Schema.optional(Schema.Boolean),
                http2Origin: Schema.optional(Schema.Boolean),
                httpHostHeader: Schema.optional(Schema.String),
                keepAliveConnections: Schema.optional(Schema.Number),
                keepAliveTimeout: Schema.optional(Schema.Number),
                matchSNItoHost: Schema.optional(Schema.Boolean),
                noHappyEyeballs: Schema.optional(Schema.Boolean),
                noTLSVerify: Schema.optional(Schema.Boolean),
                originServerName: Schema.optional(Schema.String),
                proxyType: Schema.optional(Schema.String),
                tcpKeepAlive: Schema.optional(Schema.Number),
                tlsTimeout: Schema.optional(Schema.Number),
              }),
            ),
            path: Schema.optional(Schema.String),
          }),
        ),
      ),
      originRequest: Schema.optional(
        Schema.Struct({
          access: Schema.optional(
            Schema.Struct({
              audTag: Schema.Array(Schema.String),
              teamName: Schema.String,
              required: Schema.optional(Schema.Boolean),
            }),
          ),
          caPool: Schema.optional(Schema.String),
          connectTimeout: Schema.optional(Schema.Number),
          disableChunkedEncoding: Schema.optional(Schema.Boolean),
          http2Origin: Schema.optional(Schema.Boolean),
          httpHostHeader: Schema.optional(Schema.String),
          keepAliveConnections: Schema.optional(Schema.Number),
          keepAliveTimeout: Schema.optional(Schema.Number),
          matchSNItoHost: Schema.optional(Schema.Boolean),
          noHappyEyeballs: Schema.optional(Schema.Boolean),
          noTLSVerify: Schema.optional(Schema.Boolean),
          originServerName: Schema.optional(Schema.String),
          proxyType: Schema.optional(Schema.String),
          tcpKeepAlive: Schema.optional(Schema.Number),
          tlsTimeout: Schema.optional(Schema.Number),
        }),
      ),
    }),
  ),
}).pipe(
  T.Http({
    method: "PUT",
    path: "/accounts/{account_id}/cfd_tunnel/{tunnelId}/configurations",
  }),
) as unknown as Schema.Schema<PutTunnelCloudflaredConfigurationRequest>;

export interface PutTunnelCloudflaredConfigurationResponse {
  /** Identifier. */
  accountId?: string;
  /** The tunnel configuration and ingress rules. */
  config?: {
    ingress?: {
      hostname: string;
      service: string;
      originRequest?: {
        access?: { audTag: string[]; teamName: string; required?: boolean };
        caPool?: string;
        connectTimeout?: number;
        disableChunkedEncoding?: boolean;
        http2Origin?: boolean;
        httpHostHeader?: string;
        keepAliveConnections?: number;
        keepAliveTimeout?: number;
        matchSNItoHost?: boolean;
        noHappyEyeballs?: boolean;
        noTLSVerify?: boolean;
        originServerName?: string;
        proxyType?: string;
        tcpKeepAlive?: number;
        tlsTimeout?: number;
      };
      path?: string;
    }[];
    originRequest?: {
      access?: { audTag: string[]; teamName: string; required?: boolean };
      caPool?: string;
      connectTimeout?: number;
      disableChunkedEncoding?: boolean;
      http2Origin?: boolean;
      httpHostHeader?: string;
      keepAliveConnections?: number;
      keepAliveTimeout?: number;
      matchSNItoHost?: boolean;
      noHappyEyeballs?: boolean;
      noTLSVerify?: boolean;
      originServerName?: string;
      proxyType?: string;
      tcpKeepAlive?: number;
      tlsTimeout?: number;
    };
  };
  createdAt?: string;
  /** Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel's configuration on the Zero Trus */
  source?: "local" | "cloudflare";
  /** UUID of the tunnel. */
  tunnelId?: string;
  /** The version of the Tunnel Configuration. */
  version?: number;
}

export const PutTunnelCloudflaredConfigurationResponse = Schema.Struct({
  accountId: Schema.optional(Schema.String),
  config: Schema.optional(
    Schema.Struct({
      ingress: Schema.optional(
        Schema.Array(
          Schema.Struct({
            hostname: Schema.String,
            service: Schema.String,
            originRequest: Schema.optional(
              Schema.Struct({
                access: Schema.optional(
                  Schema.Struct({
                    audTag: Schema.Array(Schema.String),
                    teamName: Schema.String,
                    required: Schema.optional(Schema.Boolean),
                  }),
                ),
                caPool: Schema.optional(Schema.String),
                connectTimeout: Schema.optional(Schema.Number),
                disableChunkedEncoding: Schema.optional(Schema.Boolean),
                http2Origin: Schema.optional(Schema.Boolean),
                httpHostHeader: Schema.optional(Schema.String),
                keepAliveConnections: Schema.optional(Schema.Number),
                keepAliveTimeout: Schema.optional(Schema.Number),
                matchSNItoHost: Schema.optional(Schema.Boolean),
                noHappyEyeballs: Schema.optional(Schema.Boolean),
                noTLSVerify: Schema.optional(Schema.Boolean),
                originServerName: Schema.optional(Schema.String),
                proxyType: Schema.optional(Schema.String),
                tcpKeepAlive: Schema.optional(Schema.Number),
                tlsTimeout: Schema.optional(Schema.Number),
              }),
            ),
            path: Schema.optional(Schema.String),
          }),
        ),
      ),
      originRequest: Schema.optional(
        Schema.Struct({
          access: Schema.optional(
            Schema.Struct({
              audTag: Schema.Array(Schema.String),
              teamName: Schema.String,
              required: Schema.optional(Schema.Boolean),
            }),
          ),
          caPool: Schema.optional(Schema.String),
          connectTimeout: Schema.optional(Schema.Number),
          disableChunkedEncoding: Schema.optional(Schema.Boolean),
          http2Origin: Schema.optional(Schema.Boolean),
          httpHostHeader: Schema.optional(Schema.String),
          keepAliveConnections: Schema.optional(Schema.Number),
          keepAliveTimeout: Schema.optional(Schema.Number),
          matchSNItoHost: Schema.optional(Schema.Boolean),
          noHappyEyeballs: Schema.optional(Schema.Boolean),
          noTLSVerify: Schema.optional(Schema.Boolean),
          originServerName: Schema.optional(Schema.String),
          proxyType: Schema.optional(Schema.String),
          tcpKeepAlive: Schema.optional(Schema.Number),
          tlsTimeout: Schema.optional(Schema.Number),
        }),
      ),
    }),
  ),
  createdAt: Schema.optional(Schema.String),
  source: Schema.optional(Schema.Literals(["local", "cloudflare"])),
  tunnelId: Schema.optional(Schema.String),
  version: Schema.optional(Schema.Number),
}).pipe(
  Schema.encodeKeys({
    accountId: "account_id",
    config: "config",
    createdAt: "created_at",
    source: "source",
    tunnelId: "tunnel_id",
    version: "version",
  }),
) as unknown as Schema.Schema<PutTunnelCloudflaredConfigurationResponse>;

export type PutTunnelCloudflaredConfigurationError = CommonErrors;

export const putTunnelCloudflaredConfiguration: API.OperationMethod<
  PutTunnelCloudflaredConfigurationRequest,
  PutTunnelCloudflaredConfigurationResponse,
  PutTunnelCloudflaredConfigurationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PutTunnelCloudflaredConfigurationRequest,
  output: PutTunnelCloudflaredConfigurationResponse,
  errors: [],
}));

// =============================================================================
// TunnelCloudflaredConnection
// =============================================================================

export interface GetTunnelCloudflaredConnectionRequest {
  tunnelId: string;
  /** Cloudflare account ID */
  accountId: string;
}

export const GetTunnelCloudflaredConnectionRequest = Schema.Struct({
  tunnelId: Schema.String.pipe(T.HttpPath("tunnelId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/cfd_tunnel/{tunnelId}/connections",
  }),
) as unknown as Schema.Schema<GetTunnelCloudflaredConnectionRequest>;

export type GetTunnelCloudflaredConnectionResponse = {
  id?: string;
  arch?: string;
  configVersion?: number;
  conns?: {
    id?: string;
    clientId?: string;
    clientVersion?: string;
    coloName?: string;
    isPendingReconnect?: boolean;
    openedAt?: string;
    originIp?: string;
    uuid?: string;
  }[];
  features?: string[];
  runAt?: string;
  version?: string;
}[];

export const GetTunnelCloudflaredConnectionResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    arch: Schema.optional(Schema.String),
    configVersion: Schema.optional(Schema.Number),
    conns: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          clientId: Schema.optional(Schema.String),
          clientVersion: Schema.optional(Schema.String),
          coloName: Schema.optional(Schema.String),
          isPendingReconnect: Schema.optional(Schema.Boolean),
          openedAt: Schema.optional(Schema.String),
          originIp: Schema.optional(Schema.String),
          uuid: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            clientId: "client_id",
            clientVersion: "client_version",
            coloName: "colo_name",
            isPendingReconnect: "is_pending_reconnect",
            openedAt: "opened_at",
            originIp: "origin_ip",
            uuid: "uuid",
          }),
        ),
      ),
    ),
    features: Schema.optional(Schema.Array(Schema.String)),
    runAt: Schema.optional(Schema.String),
    version: Schema.optional(Schema.String),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      arch: "arch",
      configVersion: "config_version",
      conns: "conns",
      features: "features",
      runAt: "run_at",
      version: "version",
    }),
  ),
) as unknown as Schema.Schema<GetTunnelCloudflaredConnectionResponse>;

export type GetTunnelCloudflaredConnectionError = CommonErrors;

export const getTunnelCloudflaredConnection: API.OperationMethod<
  GetTunnelCloudflaredConnectionRequest,
  GetTunnelCloudflaredConnectionResponse,
  GetTunnelCloudflaredConnectionError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTunnelCloudflaredConnectionRequest,
  output: GetTunnelCloudflaredConnectionResponse,
  errors: [],
}));

export interface DeleteTunnelCloudflaredConnectionRequest {
  tunnelId: string;
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Query param: UUID of the Cloudflare Tunnel connector. */
  clientId?: string;
}

export const DeleteTunnelCloudflaredConnectionRequest = Schema.Struct({
  tunnelId: Schema.String.pipe(T.HttpPath("tunnelId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  clientId: Schema.optional(Schema.String).pipe(T.HttpQuery("client_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/cfd_tunnel/{tunnelId}/connections",
  }),
) as unknown as Schema.Schema<DeleteTunnelCloudflaredConnectionRequest>;

export type DeleteTunnelCloudflaredConnectionResponse = unknown;

export const DeleteTunnelCloudflaredConnectionResponse =
  Schema.Unknown as unknown as Schema.Schema<DeleteTunnelCloudflaredConnectionResponse>;

export type DeleteTunnelCloudflaredConnectionError = CommonErrors;

export const deleteTunnelCloudflaredConnection: API.OperationMethod<
  DeleteTunnelCloudflaredConnectionRequest,
  DeleteTunnelCloudflaredConnectionResponse,
  DeleteTunnelCloudflaredConnectionError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteTunnelCloudflaredConnectionRequest,
  output: DeleteTunnelCloudflaredConnectionResponse,
  errors: [],
}));

// =============================================================================
// TunnelCloudflaredConnector
// =============================================================================

export interface GetTunnelCloudflaredConnectorRequest {
  tunnelId: string;
  connectorId: string;
  /** Cloudflare account ID */
  accountId: string;
}

export const GetTunnelCloudflaredConnectorRequest = Schema.Struct({
  tunnelId: Schema.String.pipe(T.HttpPath("tunnelId")),
  connectorId: Schema.String.pipe(T.HttpPath("connectorId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/cfd_tunnel/{tunnelId}/connectors/{connectorId}",
  }),
) as unknown as Schema.Schema<GetTunnelCloudflaredConnectorRequest>;

export type GetTunnelCloudflaredConnectorResponse = unknown;

export const GetTunnelCloudflaredConnectorResponse =
  Schema.Unknown as unknown as Schema.Schema<GetTunnelCloudflaredConnectorResponse>;

export type GetTunnelCloudflaredConnectorError = CommonErrors;

export const getTunnelCloudflaredConnector: API.OperationMethod<
  GetTunnelCloudflaredConnectorRequest,
  GetTunnelCloudflaredConnectorResponse,
  GetTunnelCloudflaredConnectorError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTunnelCloudflaredConnectorRequest,
  output: GetTunnelCloudflaredConnectorResponse,
  errors: [],
}));

// =============================================================================
// TunnelCloudflaredManagement
// =============================================================================

export interface CreateTunnelCloudflaredManagementRequest {
  tunnelId: string;
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Body param: */
  resources: "logs"[];
}

export const CreateTunnelCloudflaredManagementRequest = Schema.Struct({
  tunnelId: Schema.String.pipe(T.HttpPath("tunnelId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  resources: Schema.Array(Schema.Literal("logs")),
}).pipe(
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/cfd_tunnel/{tunnelId}/management",
  }),
) as unknown as Schema.Schema<CreateTunnelCloudflaredManagementRequest>;

export type CreateTunnelCloudflaredManagementResponse = string;

export const CreateTunnelCloudflaredManagementResponse =
  Schema.String as unknown as Schema.Schema<CreateTunnelCloudflaredManagementResponse>;

export type CreateTunnelCloudflaredManagementError = CommonErrors;

export const createTunnelCloudflaredManagement: API.OperationMethod<
  CreateTunnelCloudflaredManagementRequest,
  CreateTunnelCloudflaredManagementResponse,
  CreateTunnelCloudflaredManagementError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateTunnelCloudflaredManagementRequest,
  output: CreateTunnelCloudflaredManagementResponse,
  errors: [],
}));

// =============================================================================
// TunnelCloudflaredToken
// =============================================================================

export interface GetTunnelCloudflaredTokenRequest {
  tunnelId: string;
  /** Cloudflare account ID */
  accountId: string;
}

export const GetTunnelCloudflaredTokenRequest = Schema.Struct({
  tunnelId: Schema.String.pipe(T.HttpPath("tunnelId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/cfd_tunnel/{tunnelId}/token",
  }),
) as unknown as Schema.Schema<GetTunnelCloudflaredTokenRequest>;

export type GetTunnelCloudflaredTokenResponse = string;

export const GetTunnelCloudflaredTokenResponse =
  Schema.String as unknown as Schema.Schema<GetTunnelCloudflaredTokenResponse>;

export type GetTunnelCloudflaredTokenError = CommonErrors;

export const getTunnelCloudflaredToken: API.OperationMethod<
  GetTunnelCloudflaredTokenRequest,
  GetTunnelCloudflaredTokenResponse,
  GetTunnelCloudflaredTokenError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTunnelCloudflaredTokenRequest,
  output: GetTunnelCloudflaredTokenResponse,
  errors: [],
}));

// =============================================================================
// TunnelWarpConnector
// =============================================================================

export interface GetTunnelWarpConnectorRequest {
  tunnelId: string;
  /** Cloudflare account ID */
  accountId: string;
}

export const GetTunnelWarpConnectorRequest = Schema.Struct({
  tunnelId: Schema.String.pipe(T.HttpPath("tunnelId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/warp_connector/{tunnelId}",
  }),
) as unknown as Schema.Schema<GetTunnelWarpConnectorRequest>;

export interface GetTunnelWarpConnectorResponse {
  /** UUID of the tunnel. */
  id?: string;
  /** Cloudflare account ID */
  accountTag?: string;
  /** @deprecated This field will start returning an empty array. To fetch the connections of a given tunnel, please use the dedicated endpoint `/accounts/{account_id}/{tunnel_type}/{tunnel_id}/connections` */
  connections?: {
    id?: string;
    clientId?: string;
    clientVersion?: string;
    coloName?: string;
    isPendingReconnect?: boolean;
    openedAt?: string;
    originIp?: string;
    uuid?: string;
  }[];
  /** Timestamp of when the tunnel established at least one connection to Cloudflare's edge. If `null`, the tunnel is inactive. */
  connsActiveAt?: string;
  /** Timestamp of when the tunnel became inactive (no connections to Cloudflare's edge). If `null`, the tunnel is active. */
  connsInactiveAt?: string;
  /** Timestamp of when the resource was created. */
  createdAt?: string;
  /** Timestamp of when the resource was deleted. If `null`, the resource has not been deleted. */
  deletedAt?: string;
  /** Metadata associated with the tunnel. */
  metadata?: unknown;
  /** A user-friendly name for a tunnel. */
  name?: string;
  /** The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and ab */
  status?: "inactive" | "degraded" | "healthy" | "down";
  /** The type of tunnel. */
  tunType?:
    | "cfd_tunnel"
    | "warp_connector"
    | "warp"
    | "magic"
    | "ip_sec"
    | "gre"
    | "cni";
}

export const GetTunnelWarpConnectorResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  accountTag: Schema.optional(Schema.String),
  connections: Schema.optional(
    Schema.Array(
      Schema.Struct({
        id: Schema.optional(Schema.String),
        clientId: Schema.optional(Schema.String),
        clientVersion: Schema.optional(Schema.String),
        coloName: Schema.optional(Schema.String),
        isPendingReconnect: Schema.optional(Schema.Boolean),
        openedAt: Schema.optional(Schema.String),
        originIp: Schema.optional(Schema.String),
        uuid: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          clientId: "client_id",
          clientVersion: "client_version",
          coloName: "colo_name",
          isPendingReconnect: "is_pending_reconnect",
          openedAt: "opened_at",
          originIp: "origin_ip",
          uuid: "uuid",
        }),
      ),
    ),
  ),
  connsActiveAt: Schema.optional(Schema.String),
  connsInactiveAt: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  deletedAt: Schema.optional(Schema.String),
  metadata: Schema.optional(Schema.Unknown),
  name: Schema.optional(Schema.String),
  status: Schema.optional(
    Schema.Literals(["inactive", "degraded", "healthy", "down"]),
  ),
  tunType: Schema.optional(
    Schema.Literals([
      "cfd_tunnel",
      "warp_connector",
      "warp",
      "magic",
      "ip_sec",
      "gre",
      "cni",
    ]),
  ),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    accountTag: "account_tag",
    connections: "connections",
    connsActiveAt: "conns_active_at",
    connsInactiveAt: "conns_inactive_at",
    createdAt: "created_at",
    deletedAt: "deleted_at",
    metadata: "metadata",
    name: "name",
    status: "status",
    tunType: "tun_type",
  }),
) as unknown as Schema.Schema<GetTunnelWarpConnectorResponse>;

export type GetTunnelWarpConnectorError = CommonErrors;

export const getTunnelWarpConnector: API.OperationMethod<
  GetTunnelWarpConnectorRequest,
  GetTunnelWarpConnectorResponse,
  GetTunnelWarpConnectorError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTunnelWarpConnectorRequest,
  output: GetTunnelWarpConnectorResponse,
  errors: [],
}));

export interface ListTunnelWarpConnectorsRequest {
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Query param: */
  excludePrefix?: string;
  /** Query param: If provided, include only resources that were created (and not deleted) before this time. URL encoded. */
  existedAt?: string;
  /** Query param: */
  includePrefix?: string;
  /** Query param: If `true`, only include deleted tunnels. If `false`, exclude deleted tunnels. If empty, all tunnels will be included. */
  isDeleted?: boolean;
  /** Query param: A user-friendly name for the tunnel. */
  name?: string;
  /** Query param: The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is  */
  status?: "inactive" | "degraded" | "healthy" | "down";
  /** Query param: UUID of the tunnel. */
  uuid?: string;
  /** Query param: */
  wasActiveAt?: string;
  /** Query param: */
  wasInactiveAt?: string;
}

export const ListTunnelWarpConnectorsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  excludePrefix: Schema.optional(Schema.String).pipe(
    T.HttpQuery("exclude_prefix"),
  ),
  existedAt: Schema.optional(Schema.String).pipe(T.HttpQuery("existed_at")),
  includePrefix: Schema.optional(Schema.String).pipe(
    T.HttpQuery("include_prefix"),
  ),
  isDeleted: Schema.optional(Schema.Boolean).pipe(T.HttpQuery("is_deleted")),
  name: Schema.optional(Schema.String).pipe(T.HttpQuery("name")),
  status: Schema.optional(
    Schema.Literals(["inactive", "degraded", "healthy", "down"]),
  ).pipe(T.HttpQuery("status")),
  uuid: Schema.optional(Schema.String).pipe(T.HttpQuery("uuid")),
  wasActiveAt: Schema.optional(Schema.String).pipe(
    T.HttpQuery("was_active_at"),
  ),
  wasInactiveAt: Schema.optional(Schema.String).pipe(
    T.HttpQuery("was_inactive_at"),
  ),
}).pipe(
  T.Http({ method: "GET", path: "/accounts/{account_id}/warp_connector" }),
) as unknown as Schema.Schema<ListTunnelWarpConnectorsRequest>;

export type ListTunnelWarpConnectorsResponse = {
  id?: string;
  accountTag?: string;
  connections?: {
    id?: string;
    clientId?: string;
    clientVersion?: string;
    coloName?: string;
    isPendingReconnect?: boolean;
    openedAt?: string;
    originIp?: string;
    uuid?: string;
  }[];
  connsActiveAt?: string;
  connsInactiveAt?: string;
  createdAt?: string;
  deletedAt?: string;
  metadata?: unknown;
  name?: string;
  status?: "inactive" | "degraded" | "healthy" | "down";
  tunType?:
    | "cfd_tunnel"
    | "warp_connector"
    | "warp"
    | "magic"
    | "ip_sec"
    | "gre"
    | "cni";
}[];

export const ListTunnelWarpConnectorsResponse = Schema.Array(
  Schema.Struct({
    id: Schema.optional(Schema.String),
    accountTag: Schema.optional(Schema.String),
    connections: Schema.optional(
      Schema.Array(
        Schema.Struct({
          id: Schema.optional(Schema.String),
          clientId: Schema.optional(Schema.String),
          clientVersion: Schema.optional(Schema.String),
          coloName: Schema.optional(Schema.String),
          isPendingReconnect: Schema.optional(Schema.Boolean),
          openedAt: Schema.optional(Schema.String),
          originIp: Schema.optional(Schema.String),
          uuid: Schema.optional(Schema.String),
        }).pipe(
          Schema.encodeKeys({
            id: "id",
            clientId: "client_id",
            clientVersion: "client_version",
            coloName: "colo_name",
            isPendingReconnect: "is_pending_reconnect",
            openedAt: "opened_at",
            originIp: "origin_ip",
            uuid: "uuid",
          }),
        ),
      ),
    ),
    connsActiveAt: Schema.optional(Schema.String),
    connsInactiveAt: Schema.optional(Schema.String),
    createdAt: Schema.optional(Schema.String),
    deletedAt: Schema.optional(Schema.String),
    metadata: Schema.optional(Schema.Unknown),
    name: Schema.optional(Schema.String),
    status: Schema.optional(
      Schema.Literals(["inactive", "degraded", "healthy", "down"]),
    ),
    tunType: Schema.optional(
      Schema.Literals([
        "cfd_tunnel",
        "warp_connector",
        "warp",
        "magic",
        "ip_sec",
        "gre",
        "cni",
      ]),
    ),
  }).pipe(
    Schema.encodeKeys({
      id: "id",
      accountTag: "account_tag",
      connections: "connections",
      connsActiveAt: "conns_active_at",
      connsInactiveAt: "conns_inactive_at",
      createdAt: "created_at",
      deletedAt: "deleted_at",
      metadata: "metadata",
      name: "name",
      status: "status",
      tunType: "tun_type",
    }),
  ),
) as unknown as Schema.Schema<ListTunnelWarpConnectorsResponse>;

export type ListTunnelWarpConnectorsError = CommonErrors;

export const listTunnelWarpConnectors: API.OperationMethod<
  ListTunnelWarpConnectorsRequest,
  ListTunnelWarpConnectorsResponse,
  ListTunnelWarpConnectorsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: ListTunnelWarpConnectorsRequest,
  output: ListTunnelWarpConnectorsResponse,
  errors: [],
}));

export interface CreateTunnelWarpConnectorRequest {
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Body param: A user-friendly name for a tunnel. */
  name: string;
}

export const CreateTunnelWarpConnectorRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.String,
}).pipe(
  T.Http({ method: "POST", path: "/accounts/{account_id}/warp_connector" }),
) as unknown as Schema.Schema<CreateTunnelWarpConnectorRequest>;

export interface CreateTunnelWarpConnectorResponse {
  /** UUID of the tunnel. */
  id?: string;
  /** Cloudflare account ID */
  accountTag?: string;
  /** @deprecated This field will start returning an empty array. To fetch the connections of a given tunnel, please use the dedicated endpoint `/accounts/{account_id}/{tunnel_type}/{tunnel_id}/connections` */
  connections?: {
    id?: string;
    clientId?: string;
    clientVersion?: string;
    coloName?: string;
    isPendingReconnect?: boolean;
    openedAt?: string;
    originIp?: string;
    uuid?: string;
  }[];
  /** Timestamp of when the tunnel established at least one connection to Cloudflare's edge. If `null`, the tunnel is inactive. */
  connsActiveAt?: string;
  /** Timestamp of when the tunnel became inactive (no connections to Cloudflare's edge). If `null`, the tunnel is active. */
  connsInactiveAt?: string;
  /** Timestamp of when the resource was created. */
  createdAt?: string;
  /** Timestamp of when the resource was deleted. If `null`, the resource has not been deleted. */
  deletedAt?: string;
  /** Metadata associated with the tunnel. */
  metadata?: unknown;
  /** A user-friendly name for a tunnel. */
  name?: string;
  /** The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and ab */
  status?: "inactive" | "degraded" | "healthy" | "down";
  /** The type of tunnel. */
  tunType?:
    | "cfd_tunnel"
    | "warp_connector"
    | "warp"
    | "magic"
    | "ip_sec"
    | "gre"
    | "cni";
}

export const CreateTunnelWarpConnectorResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  accountTag: Schema.optional(Schema.String),
  connections: Schema.optional(
    Schema.Array(
      Schema.Struct({
        id: Schema.optional(Schema.String),
        clientId: Schema.optional(Schema.String),
        clientVersion: Schema.optional(Schema.String),
        coloName: Schema.optional(Schema.String),
        isPendingReconnect: Schema.optional(Schema.Boolean),
        openedAt: Schema.optional(Schema.String),
        originIp: Schema.optional(Schema.String),
        uuid: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          clientId: "client_id",
          clientVersion: "client_version",
          coloName: "colo_name",
          isPendingReconnect: "is_pending_reconnect",
          openedAt: "opened_at",
          originIp: "origin_ip",
          uuid: "uuid",
        }),
      ),
    ),
  ),
  connsActiveAt: Schema.optional(Schema.String),
  connsInactiveAt: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  deletedAt: Schema.optional(Schema.String),
  metadata: Schema.optional(Schema.Unknown),
  name: Schema.optional(Schema.String),
  status: Schema.optional(
    Schema.Literals(["inactive", "degraded", "healthy", "down"]),
  ),
  tunType: Schema.optional(
    Schema.Literals([
      "cfd_tunnel",
      "warp_connector",
      "warp",
      "magic",
      "ip_sec",
      "gre",
      "cni",
    ]),
  ),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    accountTag: "account_tag",
    connections: "connections",
    connsActiveAt: "conns_active_at",
    connsInactiveAt: "conns_inactive_at",
    createdAt: "created_at",
    deletedAt: "deleted_at",
    metadata: "metadata",
    name: "name",
    status: "status",
    tunType: "tun_type",
  }),
) as unknown as Schema.Schema<CreateTunnelWarpConnectorResponse>;

export type CreateTunnelWarpConnectorError = CommonErrors;

export const createTunnelWarpConnector: API.OperationMethod<
  CreateTunnelWarpConnectorRequest,
  CreateTunnelWarpConnectorResponse,
  CreateTunnelWarpConnectorError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: CreateTunnelWarpConnectorRequest,
  output: CreateTunnelWarpConnectorResponse,
  errors: [],
}));

export interface PatchTunnelWarpConnectorRequest {
  tunnelId: string;
  /** Path param: Cloudflare account ID */
  accountId: string;
  /** Body param: A user-friendly name for a tunnel. */
  name?: string;
  /** Body param: Sets the password required to run a locally-managed tunnel. Must be at least 32 bytes and encoded as a base64 string. */
  tunnelSecret?: string;
}

export const PatchTunnelWarpConnectorRequest = Schema.Struct({
  tunnelId: Schema.String.pipe(T.HttpPath("tunnelId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  name: Schema.optional(Schema.String),
  tunnelSecret: Schema.optional(Schema.String),
}).pipe(
  Schema.encodeKeys({ name: "name", tunnelSecret: "tunnel_secret" }),
  T.Http({
    method: "PATCH",
    path: "/accounts/{account_id}/warp_connector/{tunnelId}",
  }),
) as unknown as Schema.Schema<PatchTunnelWarpConnectorRequest>;

export interface PatchTunnelWarpConnectorResponse {
  /** UUID of the tunnel. */
  id?: string;
  /** Cloudflare account ID */
  accountTag?: string;
  /** @deprecated This field will start returning an empty array. To fetch the connections of a given tunnel, please use the dedicated endpoint `/accounts/{account_id}/{tunnel_type}/{tunnel_id}/connections` */
  connections?: {
    id?: string;
    clientId?: string;
    clientVersion?: string;
    coloName?: string;
    isPendingReconnect?: boolean;
    openedAt?: string;
    originIp?: string;
    uuid?: string;
  }[];
  /** Timestamp of when the tunnel established at least one connection to Cloudflare's edge. If `null`, the tunnel is inactive. */
  connsActiveAt?: string;
  /** Timestamp of when the tunnel became inactive (no connections to Cloudflare's edge). If `null`, the tunnel is active. */
  connsInactiveAt?: string;
  /** Timestamp of when the resource was created. */
  createdAt?: string;
  /** Timestamp of when the resource was deleted. If `null`, the resource has not been deleted. */
  deletedAt?: string;
  /** Metadata associated with the tunnel. */
  metadata?: unknown;
  /** A user-friendly name for a tunnel. */
  name?: string;
  /** The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and ab */
  status?: "inactive" | "degraded" | "healthy" | "down";
  /** The type of tunnel. */
  tunType?:
    | "cfd_tunnel"
    | "warp_connector"
    | "warp"
    | "magic"
    | "ip_sec"
    | "gre"
    | "cni";
}

export const PatchTunnelWarpConnectorResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  accountTag: Schema.optional(Schema.String),
  connections: Schema.optional(
    Schema.Array(
      Schema.Struct({
        id: Schema.optional(Schema.String),
        clientId: Schema.optional(Schema.String),
        clientVersion: Schema.optional(Schema.String),
        coloName: Schema.optional(Schema.String),
        isPendingReconnect: Schema.optional(Schema.Boolean),
        openedAt: Schema.optional(Schema.String),
        originIp: Schema.optional(Schema.String),
        uuid: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          clientId: "client_id",
          clientVersion: "client_version",
          coloName: "colo_name",
          isPendingReconnect: "is_pending_reconnect",
          openedAt: "opened_at",
          originIp: "origin_ip",
          uuid: "uuid",
        }),
      ),
    ),
  ),
  connsActiveAt: Schema.optional(Schema.String),
  connsInactiveAt: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  deletedAt: Schema.optional(Schema.String),
  metadata: Schema.optional(Schema.Unknown),
  name: Schema.optional(Schema.String),
  status: Schema.optional(
    Schema.Literals(["inactive", "degraded", "healthy", "down"]),
  ),
  tunType: Schema.optional(
    Schema.Literals([
      "cfd_tunnel",
      "warp_connector",
      "warp",
      "magic",
      "ip_sec",
      "gre",
      "cni",
    ]),
  ),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    accountTag: "account_tag",
    connections: "connections",
    connsActiveAt: "conns_active_at",
    connsInactiveAt: "conns_inactive_at",
    createdAt: "created_at",
    deletedAt: "deleted_at",
    metadata: "metadata",
    name: "name",
    status: "status",
    tunType: "tun_type",
  }),
) as unknown as Schema.Schema<PatchTunnelWarpConnectorResponse>;

export type PatchTunnelWarpConnectorError = CommonErrors;

export const patchTunnelWarpConnector: API.OperationMethod<
  PatchTunnelWarpConnectorRequest,
  PatchTunnelWarpConnectorResponse,
  PatchTunnelWarpConnectorError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: PatchTunnelWarpConnectorRequest,
  output: PatchTunnelWarpConnectorResponse,
  errors: [],
}));

export interface DeleteTunnelWarpConnectorRequest {
  tunnelId: string;
  /** Cloudflare account ID */
  accountId: string;
}

export const DeleteTunnelWarpConnectorRequest = Schema.Struct({
  tunnelId: Schema.String.pipe(T.HttpPath("tunnelId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "DELETE",
    path: "/accounts/{account_id}/warp_connector/{tunnelId}",
  }),
) as unknown as Schema.Schema<DeleteTunnelWarpConnectorRequest>;

export interface DeleteTunnelWarpConnectorResponse {
  /** UUID of the tunnel. */
  id?: string;
  /** Cloudflare account ID */
  accountTag?: string;
  /** @deprecated This field will start returning an empty array. To fetch the connections of a given tunnel, please use the dedicated endpoint `/accounts/{account_id}/{tunnel_type}/{tunnel_id}/connections` */
  connections?: {
    id?: string;
    clientId?: string;
    clientVersion?: string;
    coloName?: string;
    isPendingReconnect?: boolean;
    openedAt?: string;
    originIp?: string;
    uuid?: string;
  }[];
  /** Timestamp of when the tunnel established at least one connection to Cloudflare's edge. If `null`, the tunnel is inactive. */
  connsActiveAt?: string;
  /** Timestamp of when the tunnel became inactive (no connections to Cloudflare's edge). If `null`, the tunnel is active. */
  connsInactiveAt?: string;
  /** Timestamp of when the resource was created. */
  createdAt?: string;
  /** Timestamp of when the resource was deleted. If `null`, the resource has not been deleted. */
  deletedAt?: string;
  /** Metadata associated with the tunnel. */
  metadata?: unknown;
  /** A user-friendly name for a tunnel. */
  name?: string;
  /** The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and ab */
  status?: "inactive" | "degraded" | "healthy" | "down";
  /** The type of tunnel. */
  tunType?:
    | "cfd_tunnel"
    | "warp_connector"
    | "warp"
    | "magic"
    | "ip_sec"
    | "gre"
    | "cni";
}

export const DeleteTunnelWarpConnectorResponse = Schema.Struct({
  id: Schema.optional(Schema.String),
  accountTag: Schema.optional(Schema.String),
  connections: Schema.optional(
    Schema.Array(
      Schema.Struct({
        id: Schema.optional(Schema.String),
        clientId: Schema.optional(Schema.String),
        clientVersion: Schema.optional(Schema.String),
        coloName: Schema.optional(Schema.String),
        isPendingReconnect: Schema.optional(Schema.Boolean),
        openedAt: Schema.optional(Schema.String),
        originIp: Schema.optional(Schema.String),
        uuid: Schema.optional(Schema.String),
      }).pipe(
        Schema.encodeKeys({
          id: "id",
          clientId: "client_id",
          clientVersion: "client_version",
          coloName: "colo_name",
          isPendingReconnect: "is_pending_reconnect",
          openedAt: "opened_at",
          originIp: "origin_ip",
          uuid: "uuid",
        }),
      ),
    ),
  ),
  connsActiveAt: Schema.optional(Schema.String),
  connsInactiveAt: Schema.optional(Schema.String),
  createdAt: Schema.optional(Schema.String),
  deletedAt: Schema.optional(Schema.String),
  metadata: Schema.optional(Schema.Unknown),
  name: Schema.optional(Schema.String),
  status: Schema.optional(
    Schema.Literals(["inactive", "degraded", "healthy", "down"]),
  ),
  tunType: Schema.optional(
    Schema.Literals([
      "cfd_tunnel",
      "warp_connector",
      "warp",
      "magic",
      "ip_sec",
      "gre",
      "cni",
    ]),
  ),
}).pipe(
  Schema.encodeKeys({
    id: "id",
    accountTag: "account_tag",
    connections: "connections",
    connsActiveAt: "conns_active_at",
    connsInactiveAt: "conns_inactive_at",
    createdAt: "created_at",
    deletedAt: "deleted_at",
    metadata: "metadata",
    name: "name",
    status: "status",
    tunType: "tun_type",
  }),
) as unknown as Schema.Schema<DeleteTunnelWarpConnectorResponse>;

export type DeleteTunnelWarpConnectorError = CommonErrors;

export const deleteTunnelWarpConnector: API.OperationMethod<
  DeleteTunnelWarpConnectorRequest,
  DeleteTunnelWarpConnectorResponse,
  DeleteTunnelWarpConnectorError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: DeleteTunnelWarpConnectorRequest,
  output: DeleteTunnelWarpConnectorResponse,
  errors: [],
}));

// =============================================================================
// TunnelWarpConnectorToken
// =============================================================================

export interface GetTunnelWarpConnectorTokenRequest {
  tunnelId: string;
  /** Cloudflare account ID */
  accountId: string;
}

export const GetTunnelWarpConnectorTokenRequest = Schema.Struct({
  tunnelId: Schema.String.pipe(T.HttpPath("tunnelId")),
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
}).pipe(
  T.Http({
    method: "GET",
    path: "/accounts/{account_id}/warp_connector/{tunnelId}/token",
  }),
) as unknown as Schema.Schema<GetTunnelWarpConnectorTokenRequest>;

export type GetTunnelWarpConnectorTokenResponse = string;

export const GetTunnelWarpConnectorTokenResponse =
  Schema.String as unknown as Schema.Schema<GetTunnelWarpConnectorTokenResponse>;

export type GetTunnelWarpConnectorTokenError = CommonErrors;

export const getTunnelWarpConnectorToken: API.OperationMethod<
  GetTunnelWarpConnectorTokenRequest,
  GetTunnelWarpConnectorTokenResponse,
  GetTunnelWarpConnectorTokenError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: GetTunnelWarpConnectorTokenRequest,
  output: GetTunnelWarpConnectorTokenResponse,
  errors: [],
}));

// =============================================================================
// UsersOrganization
// =============================================================================

export interface RevokeUsersOrganizationRequest {
  /** Path param: The Account ID to use for this endpoint. Mutually exclusive with the Zone ID. */
  accountId?: string;
  /** Path param: The Zone ID to use for this endpoint. Mutually exclusive with the Account ID. */
  zoneId?: string;
  /** Query param: When set to `true`, all devices associated with the user will be revoked. */
  queryDevices?: boolean;
  /** Body param: The email of the user to revoke. */
  email: string;
  /** Body param: When set to `true`, all devices associated with the user will be revoked. */
  bodyDevices?: boolean;
  /** Body param: The uuid of the user to revoke. */
  userUid?: string;
  /** Body param: When set to `true`, the user will be required to re-authenticate to WARP for all Gateway policies that enforce a WARP client session duration. When `false`, the users WARP session will re */
  warpSessionReauth?: boolean;
}

export const RevokeUsersOrganizationRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  zoneId: Schema.String.pipe(T.HttpPath("zone_id")),
  queryDevices: Schema.optional(Schema.Boolean).pipe(
    T.HttpQuery("query_devices"),
  ),
  email: Schema.String,
  bodyDevices: Schema.optional(Schema.Boolean),
  userUid: Schema.optional(Schema.String),
  warpSessionReauth: Schema.optional(Schema.Boolean),
}).pipe(
  Schema.encodeKeys({
    email: "email",
    bodyDevices: "body_devices",
    userUid: "user_uid",
    warpSessionReauth: "warp_session_reauth",
  }),
  T.Http({
    method: "POST",
    path: "/{accountOrZone}/{accountOrZoneId}/access/organizations/revoke_user",
  }),
) as unknown as Schema.Schema<RevokeUsersOrganizationRequest>;

export type RevokeUsersOrganizationResponse = true | false;

export const RevokeUsersOrganizationResponse = Schema.Literals([
  true,
  false,
]) as unknown as Schema.Schema<RevokeUsersOrganizationResponse>;

export type RevokeUsersOrganizationError = CommonErrors;

export const revokeUsersOrganization: API.OperationMethod<
  RevokeUsersOrganizationRequest,
  RevokeUsersOrganizationResponse,
  RevokeUsersOrganizationError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: RevokeUsersOrganizationRequest,
  output: RevokeUsersOrganizationResponse,
  errors: [],
}));

// =============================================================================
// V2AccessInfrastructureTarget
// =============================================================================

export interface BulkDeleteV2AccessInfrastructureTargetsRequest {
  /** Path param: Account identifier */
  accountId: string;
  /** Body param: List of target IDs to bulk delete */
  targetIds: string[];
}

export const BulkDeleteV2AccessInfrastructureTargetsRequest = Schema.Struct({
  accountId: Schema.String.pipe(T.HttpPath("account_id")),
  targetIds: Schema.Array(Schema.String),
}).pipe(
  Schema.encodeKeys({ targetIds: "target_ids" }),
  T.Http({
    method: "POST",
    path: "/accounts/{account_id}/infrastructure/targets/batch_delete",
  }),
) as unknown as Schema.Schema<BulkDeleteV2AccessInfrastructureTargetsRequest>;

export type BulkDeleteV2AccessInfrastructureTargetsResponse = unknown;

export const BulkDeleteV2AccessInfrastructureTargetsResponse =
  Schema.Unknown as unknown as Schema.Schema<BulkDeleteV2AccessInfrastructureTargetsResponse>;

export type BulkDeleteV2AccessInfrastructureTargetsError = CommonErrors;

export const bulkDeleteV2AccessInfrastructureTargets: API.OperationMethod<
  BulkDeleteV2AccessInfrastructureTargetsRequest,
  BulkDeleteV2AccessInfrastructureTargetsResponse,
  BulkDeleteV2AccessInfrastructureTargetsError,
  ApiToken | HttpClient.HttpClient
> = API.make(() => ({
  input: BulkDeleteV2AccessInfrastructureTargetsRequest,
  output: BulkDeleteV2AccessInfrastructureTargetsResponse,
  errors: [],
}));
